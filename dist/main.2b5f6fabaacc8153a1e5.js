(()=>{var __webpack_modules__={192:(module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(537);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(645);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);\n// Imports\n\n\nvar ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, "*{padding:0;margin:0;box-sizing:border-box}body{font-family:\\"Coming Soon\\",cursive;height:100vh;width:100vw;display:flex;flex-direction:column}#header{display:flex;justify-content:center;align-items:center;justify-content:flex-start;background-color:rgba(255,72,0,.7);color:#fff;font-size:1.8rem;font-weight:900;gap:1rem;width:100%}#header .logo{max-height:4rem;padding:5px}#content{display:grid;grid-template-columns:1fr 6fr;height:100vh}#content .sidebar{font-size:1.5rem;padding:10px;background-color:rgba(255,72,0,.3)}#content .sidebar ul{text-align:center;list-style-type:none}#content .sidebar ul .link{padding:10px;text-decoration:none;color:#000;text-shadow:1px 1px #fff}#content .sidebar ul .today,#content .sidebar ul .week{cursor:pointer}#content .sidebar li.projectsLi{background-color:#80f0e4;border-radius:15px}#content .sidebar li.projectsLi ul{padding:10px;display:flex;flex-direction:column;gap:10px;justify-content:center;align-items:center;margin:0 auto}#content .sidebar li.projectsLi ul li.project{font-size:1.3rem;width:220px;background-color:#fff;display:flex;gap:10px;justify-content:center;align-items:center;padding:10px;border:1px solid;font-family:\\"rock salt\\",cursive}#content .sidebar li.projectsLi ul li.project:hover{cursor:pointer}#content .todoList{display:flex;flex-direction:column;justify-content:flex-start;align-items:center;gap:10px;background-color:rgba(255,72,0,.1)}#content .todoList table{margin-top:10px;min-width:800px;max-width:1200px;border-radius:20px}#content .todoList table .titles{font-size:1.5rem;font-family:\\"Times New Roman\\",Times,serif}#content .todoList table .titles:hover{box-shadow:none}#content .todoList table .titles .dueDate{text-align:right}#content .todoList table .titles .projName{text-align:left}#content .todoList table .titles th{padding:10px 0}#content .todoList table tr.createdRow:hover{box-shadow:0 0 5px 5px}#content .todoList table tr.createdRow td{vertical-align:middle;max-width:600px;padding:10px 0 10px 10px}#content .todoList table tr.createdRow .column1{font-size:1.5rem}#content .todoList table tr.createdRow .column2{display:flex;justify-content:flex-end;align-items:center;gap:10px;font-size:1.3rem}#content .todoList table .viewOnly td{vertical-align:middle;max-width:600px;padding:10px 0 10px 10px}#content .todoList table .viewOnly .column1{font-size:1.5rem}#content .todoList table .viewOnly .column2{display:flex;justify-content:flex-end;align-items:center;gap:10px;font-size:1.5rem}i,.addToDoBtn,.addProjectBtn{cursor:pointer}.fa-calendar-day,.fa-bars-progress{cursor:default}.fa-bars-progress,.fa-calendar,.fa-exclamation,.fa-calendar-day{margin-left:10px}.completed{opacity:.5;text-decoration:line-through}#modal,#editModal,#projectModal{margin:auto auto;max-width:100ch;padding:10px;border:0;border-radius:10px;box-shadow:0 0 1em rgba(0,0,0,.3);background-color:salmon}#modal h2,#editModal h2,#projectModal h2{letter-spacing:5px;text-align:center;font-size:1.2rem}#modal .editForm,#modal .projectForm,#modal .form,#editModal .editForm,#editModal .projectForm,#editModal .form,#projectModal .editForm,#projectModal .projectForm,#projectModal .form{display:flex;flex-direction:column;justify-content:center;align-items:center;height:400px;width:350px;gap:20px;font-size:1.2rem;font-weight:bold}#modal .editForm label,#modal .editForm textarea,#modal .editForm input[type=text],#modal .editForm input[type=datetime-local],#modal .editForm .btns,#modal .projectForm label,#modal .projectForm textarea,#modal .projectForm input[type=text],#modal .projectForm input[type=datetime-local],#modal .projectForm .btns,#modal .form label,#modal .form textarea,#modal .form input[type=text],#modal .form input[type=datetime-local],#modal .form .btns,#editModal .editForm label,#editModal .editForm textarea,#editModal .editForm input[type=text],#editModal .editForm input[type=datetime-local],#editModal .editForm .btns,#editModal .projectForm label,#editModal .projectForm textarea,#editModal .projectForm input[type=text],#editModal .projectForm input[type=datetime-local],#editModal .projectForm .btns,#editModal .form label,#editModal .form textarea,#editModal .form input[type=text],#editModal .form input[type=datetime-local],#editModal .form .btns,#projectModal .editForm label,#projectModal .editForm textarea,#projectModal .editForm input[type=text],#projectModal .editForm input[type=datetime-local],#projectModal .editForm .btns,#projectModal .projectForm label,#projectModal .projectForm textarea,#projectModal .projectForm input[type=text],#projectModal .projectForm input[type=datetime-local],#projectModal .projectForm .btns,#projectModal .form label,#projectModal .form textarea,#projectModal .form input[type=text],#projectModal .form input[type=datetime-local],#projectModal .form .btns{letter-spacing:1px;width:200px;font-family:Roboto,Oxygen,Ubuntu,Cantarell,\\"Open Sans\\",\\"Helvetica Neue\\",sans-serif}#modal .editForm input,#modal .editForm textarea,#modal .editForm select,#modal .projectForm input,#modal .projectForm textarea,#modal .projectForm select,#modal .form input,#modal .form textarea,#modal .form select,#editModal .editForm input,#editModal .editForm textarea,#editModal .editForm select,#editModal .projectForm input,#editModal .projectForm textarea,#editModal .projectForm select,#editModal .form input,#editModal .form textarea,#editModal .form select,#projectModal .editForm input,#projectModal .editForm textarea,#projectModal .editForm select,#projectModal .projectForm input,#projectModal .projectForm textarea,#projectModal .projectForm select,#projectModal .form input,#projectModal .form textarea,#projectModal .form select{background-color:#fff}#modal .editForm textarea,#modal .projectForm textarea,#modal .form textarea,#editModal .editForm textarea,#editModal .projectForm textarea,#editModal .form textarea,#projectModal .editForm textarea,#projectModal .projectForm textarea,#projectModal .form textarea{padding:10px;max-width:100%;line-height:1.5;border-radius:5px;border:1px solid #ccc;box-shadow:1px 1px 1px #999}#modal .editForm label,#modal .projectForm label,#modal .form label,#editModal .editForm label,#editModal .projectForm label,#editModal .form label,#projectModal .editForm label,#projectModal .projectForm label,#projectModal .form label{display:block;margin-bottom:5px}#modal .editForm input[type=text],#modal .projectForm input[type=text],#modal .form input[type=text],#editModal .editForm input[type=text],#editModal .projectForm input[type=text],#editModal .form input[type=text],#projectModal .editForm input[type=text],#projectModal .projectForm input[type=text],#projectModal .form input[type=text]{padding:5px}#modal .editForm .btns,#modal .projectForm .btns,#modal .form .btns,#editModal .editForm .btns,#editModal .projectForm .btns,#editModal .form .btns,#projectModal .editForm .btns,#projectModal .projectForm .btns,#projectModal .form .btns{display:flex;justify-content:center;align-items:center;gap:5px}#modal .editForm .btns .submitProjectBtn,#modal .editForm .btns .cancelProjectBtn,#modal .editForm .btns .createModalSubmitBtn,#modal .editForm .btns .createModalCancelBtn,#modal .editForm .btns .cancelEditBtn,#modal .editForm .btns .submitEditBtn,#modal .projectForm .btns .submitProjectBtn,#modal .projectForm .btns .cancelProjectBtn,#modal .projectForm .btns .createModalSubmitBtn,#modal .projectForm .btns .createModalCancelBtn,#modal .projectForm .btns .cancelEditBtn,#modal .projectForm .btns .submitEditBtn,#modal .form .btns .submitProjectBtn,#modal .form .btns .cancelProjectBtn,#modal .form .btns .createModalSubmitBtn,#modal .form .btns .createModalCancelBtn,#modal .form .btns .cancelEditBtn,#modal .form .btns .submitEditBtn,#editModal .editForm .btns .submitProjectBtn,#editModal .editForm .btns .cancelProjectBtn,#editModal .editForm .btns .createModalSubmitBtn,#editModal .editForm .btns .createModalCancelBtn,#editModal .editForm .btns .cancelEditBtn,#editModal .editForm .btns .submitEditBtn,#editModal .projectForm .btns .submitProjectBtn,#editModal .projectForm .btns .cancelProjectBtn,#editModal .projectForm .btns .createModalSubmitBtn,#editModal .projectForm .btns .createModalCancelBtn,#editModal .projectForm .btns .cancelEditBtn,#editModal .projectForm .btns .submitEditBtn,#editModal .form .btns .submitProjectBtn,#editModal .form .btns .cancelProjectBtn,#editModal .form .btns .createModalSubmitBtn,#editModal .form .btns .createModalCancelBtn,#editModal .form .btns .cancelEditBtn,#editModal .form .btns .submitEditBtn,#projectModal .editForm .btns .submitProjectBtn,#projectModal .editForm .btns .cancelProjectBtn,#projectModal .editForm .btns .createModalSubmitBtn,#projectModal .editForm .btns .createModalCancelBtn,#projectModal .editForm .btns .cancelEditBtn,#projectModal .editForm .btns .submitEditBtn,#projectModal .projectForm .btns .submitProjectBtn,#projectModal .projectForm .btns .cancelProjectBtn,#projectModal .projectForm .btns .createModalSubmitBtn,#projectModal .projectForm .btns .createModalCancelBtn,#projectModal .projectForm .btns .cancelEditBtn,#projectModal .projectForm .btns .submitEditBtn,#projectModal .form .btns .submitProjectBtn,#projectModal .form .btns .cancelProjectBtn,#projectModal .form .btns .createModalSubmitBtn,#projectModal .form .btns .createModalCancelBtn,#projectModal .form .btns .cancelEditBtn,#projectModal .form .btns .submitEditBtn{background-color:#adff2f;max-width:50px;padding:10px}#modal .editForm .btns .submitProjectBtn:hover,#modal .editForm .btns .cancelProjectBtn:hover,#modal .editForm .btns .createModalSubmitBtn:hover,#modal .editForm .btns .createModalCancelBtn:hover,#modal .editForm .btns .cancelEditBtn:hover,#modal .editForm .btns .submitEditBtn:hover,#modal .projectForm .btns .submitProjectBtn:hover,#modal .projectForm .btns .cancelProjectBtn:hover,#modal .projectForm .btns .createModalSubmitBtn:hover,#modal .projectForm .btns .createModalCancelBtn:hover,#modal .projectForm .btns .cancelEditBtn:hover,#modal .projectForm .btns .submitEditBtn:hover,#modal .form .btns .submitProjectBtn:hover,#modal .form .btns .cancelProjectBtn:hover,#modal .form .btns .createModalSubmitBtn:hover,#modal .form .btns .createModalCancelBtn:hover,#modal .form .btns .cancelEditBtn:hover,#modal .form .btns .submitEditBtn:hover,#editModal .editForm .btns .submitProjectBtn:hover,#editModal .editForm .btns .cancelProjectBtn:hover,#editModal .editForm .btns .createModalSubmitBtn:hover,#editModal .editForm .btns .createModalCancelBtn:hover,#editModal .editForm .btns .cancelEditBtn:hover,#editModal .editForm .btns .submitEditBtn:hover,#editModal .projectForm .btns .submitProjectBtn:hover,#editModal .projectForm .btns .cancelProjectBtn:hover,#editModal .projectForm .btns .createModalSubmitBtn:hover,#editModal .projectForm .btns .createModalCancelBtn:hover,#editModal .projectForm .btns .cancelEditBtn:hover,#editModal .projectForm .btns .submitEditBtn:hover,#editModal .form .btns .submitProjectBtn:hover,#editModal .form .btns .cancelProjectBtn:hover,#editModal .form .btns .createModalSubmitBtn:hover,#editModal .form .btns .createModalCancelBtn:hover,#editModal .form .btns .cancelEditBtn:hover,#editModal .form .btns .submitEditBtn:hover,#projectModal .editForm .btns .submitProjectBtn:hover,#projectModal .editForm .btns .cancelProjectBtn:hover,#projectModal .editForm .btns .createModalSubmitBtn:hover,#projectModal .editForm .btns .createModalCancelBtn:hover,#projectModal .editForm .btns .cancelEditBtn:hover,#projectModal .editForm .btns .submitEditBtn:hover,#projectModal .projectForm .btns .submitProjectBtn:hover,#projectModal .projectForm .btns .cancelProjectBtn:hover,#projectModal .projectForm .btns .createModalSubmitBtn:hover,#projectModal .projectForm .btns .createModalCancelBtn:hover,#projectModal .projectForm .btns .cancelEditBtn:hover,#projectModal .projectForm .btns .submitEditBtn:hover,#projectModal .form .btns .submitProjectBtn:hover,#projectModal .form .btns .cancelProjectBtn:hover,#projectModal .form .btns .createModalSubmitBtn:hover,#projectModal .form .btns .createModalCancelBtn:hover,#projectModal .form .btns .cancelEditBtn:hover,#projectModal .form .btns .submitEditBtn:hover{cursor:pointer;background-color:#fff}#modal .editForm .btns .cancelEditBtn,#modal .editForm .btns .createModalCancelBtn,#modal .editForm .btns .cancelProjectBtn,#modal .projectForm .btns .cancelEditBtn,#modal .projectForm .btns .createModalCancelBtn,#modal .projectForm .btns .cancelProjectBtn,#modal .form .btns .cancelEditBtn,#modal .form .btns .createModalCancelBtn,#modal .form .btns .cancelProjectBtn,#editModal .editForm .btns .cancelEditBtn,#editModal .editForm .btns .createModalCancelBtn,#editModal .editForm .btns .cancelProjectBtn,#editModal .projectForm .btns .cancelEditBtn,#editModal .projectForm .btns .createModalCancelBtn,#editModal .projectForm .btns .cancelProjectBtn,#editModal .form .btns .cancelEditBtn,#editModal .form .btns .createModalCancelBtn,#editModal .form .btns .cancelProjectBtn,#projectModal .editForm .btns .cancelEditBtn,#projectModal .editForm .btns .createModalCancelBtn,#projectModal .editForm .btns .cancelProjectBtn,#projectModal .projectForm .btns .cancelEditBtn,#projectModal .projectForm .btns .createModalCancelBtn,#projectModal .projectForm .btns .cancelProjectBtn,#projectModal .form .btns .cancelEditBtn,#projectModal .form .btns .createModalCancelBtn,#projectModal .form .btns .cancelProjectBtn{background-color:red}#modal>*,#editModal>*,#projectModal>*{margin:0 0 .5rem 0}#modal::backdrop,#editModal::backdrop,#projectModal::backdrop{background:rgba(0,0,0,.4)}#projectModal .projectForm{height:120px;width:250px}.footer{font-size:1rem;font-family:Roboto,Oxygen,Ubuntu,Cantarell,\\"Open Sans\\",\\"Helvetica Neue\\",sans-serif;padding:10px;background-color:#80f0e4;text-align:center}.fa-circle-plus,.fa-github,.fa-linkedin,.svg{transition-duration:.75s;transform:rotate(720deg) scale(1.5);cursor:pointer}", "",{"version":3,"sources":["webpack://./src/style.scss","webpack://./src/scss/_globals.scss"],"names":[],"mappings":"AAQA,EACI,SAAA,CACA,QAAA,CACA,qBAAA,CAGJ,KACI,iCAAA,CACA,YAAA,CACA,WAAA,CACA,YAAA,CACA,qBAAA,CAGJ,QAnBI,YAAA,CACA,sBAAA,CACA,kBAAA,CAmBA,0BAAA,CACA,kCCvBK,CDwBL,UCzBG,CD0BH,gBAAA,CACA,eAAA,CACA,QAAA,CACA,UAAA,CACA,cACI,eAAA,CACA,WAAA,CAIR,SACI,YAAA,CACA,6BAAA,CACA,YAAA,CACA,kBACI,gBAAA,CACA,YAAA,CACA,kCCzCE,CD0CF,qBACI,iBAAA,CACA,oBAAA,CACA,2BACI,YAAA,CACA,oBAAA,CACA,UC/CD,CDgDC,wBAAA,CAEJ,uDACI,cAAA,CAGR,gCACI,wBCpDC,CDqDD,kBAAA,CAEJ,mCACI,YAAA,CACA,YAAA,CACA,qBAAA,CACA,QAAA,CACA,sBAAA,CACA,kBAAA,CACA,aAAA,CACA,8CACI,gBAAA,CACA,WAAA,CACA,qBAAA,CACA,YAAA,CACA,QAAA,CACA,sBAAA,CACA,kBAAA,CACA,YAAA,CACA,gBAAA,CACA,+BAAA,CACA,oDACI,cAAA,CAKhB,mBACI,YAAA,CACA,qBAAA,CACA,0BAAA,CACA,kBAAA,CACA,QAAA,CACA,kCCxFG,CDyFH,yBACI,eAAA,CACA,eAAA,CACA,gBAAA,CACA,kBAAA,CACA,iCAII,gBAAA,CACA,yCAAA,CAJA,uCACI,eAAA,CAIJ,0CACI,gBAAA,CAEJ,2CACI,eAAA,CAEJ,oCACI,cAAA,CAKJ,6CACI,sBAAA,CAEJ,0CACI,qBAAA,CACA,eAAA,CACA,wBAAA,CAEJ,gDACI,gBAAA,CAEJ,gDACI,YAAA,CACA,wBAAA,CACA,kBAAA,CACA,QAAA,CACA,gBAAA,CAKJ,sCACI,qBAAA,CACA,eAAA,CACA,wBAAA,CAEJ,4CACI,gBAAA,CAEJ,4CACI,YAAA,CACA,wBAAA,CACA,kBAAA,CACA,QAAA,CACA,gBAAA,CAOpB,6BACI,cAAA,CAEJ,mCACI,cAAA,CAEJ,gEACI,gBAAA,CAGJ,WACI,UAAA,CACA,4BAAA,CAIJ,gCAEI,gBAAA,CACA,eAAA,CACA,YAAA,CACA,QAAA,CACA,kBAAA,CACA,iCAAA,CACA,uBAAA,CAEA,yCACI,kBAAA,CACA,iBAAA,CACA,gBAAA,CAGJ,uLAEI,YAAA,CACA,qBAAA,CACA,sBAAA,CACA,kBAAA,CACA,YAAA,CACA,WAAA,CACA,QAAA,CACA,gBAAA,CACA,gBAAA,CAEA,49CAEI,kBAAA,CACA,WAAA,CACA,kFAAA,CAGJ,2uBACI,qBAAA,CAGJ,wQACI,YAAA,CACA,cAAA,CACA,eAAA,CACA,iBAAA,CACA,qBAAA,CACA,2BAAA,CAGJ,6OACI,aAAA,CACA,iBAAA,CAGJ,gVACI,WAAA,CAGJ,6OApOJ,YAAA,CACA,sBAAA,CACA,kBAAA,CAoOQ,OAAA,CACA,42EAII,wBAAA,CACA,cAAA,CACA,YAAA,CACA,grFACI,cAAA,CACA,qBAAA,CAGR,srCACI,oBAAA,CAKZ,sCACA,kBAAA,CAEA,8DACA,yBAAA,CAMA,2BACI,YAAA,CACA,WAAA,CAIR,QACI,cAAA,CACA,kFAAA,CACA,YAAA,CACA,wBAAA,CACA,iBAAA,CAMJ,6CAII,wBAAA,CACA,mCAAA,CACA,cAAA","sourcesContent":["@import \'./scss/globals\';\\n\\n@mixin center {\\n    display: flex;\\n    justify-content: center;\\n    align-items: center;\\n}\\n\\n*{\\n    padding: 0;\\n    margin: 0;\\n    box-sizing: border-box;\\n}\\n\\nbody{\\n    font-family: \'Coming Soon\', cursive;\\n    height: 100vh;\\n    width: 100vw;\\n    display: flex;\\n    flex-direction: column;\\n}\\n\\n#header{\\n    @include center;\\n    justify-content: flex-start;\\n    background-color: $HEADER;\\n    color: $FONT;\\n    font-size: 1.8rem;\\n    font-weight: 900;\\n    gap: 1rem;\\n    width: 100%;\\n    .logo{\\n        max-height: 4rem;\\n        padding: 5px;\\n    }\\n}\\n\\n#content{\\n    display: grid;\\n    grid-template-columns: 1fr 6fr;\\n    height: 100vh;\\n    .sidebar{\\n        font-size: 1.5rem;\\n        padding: 10px;\\n        background-color: $SIDEBAR;\\n        ul{\\n            text-align: center;\\n            list-style-type: none;\\n            .link{\\n                padding: 10px;\\n                text-decoration: none;\\n                color: $SIDEBAR_TEXT;\\n                text-shadow: 1px 1px white;\\n            }\\n            .today, .week{\\n                cursor: pointer;\\n            }\\n        }\\n        li.projectsLi{\\n            background-color: $LOGO-COLOR;\\n            border-radius: 15px;\\n        }\\n        li.projectsLi ul{\\n            padding: 10px;\\n            display: flex;\\n            flex-direction: column;\\n            gap: 10px;\\n            justify-content: center;\\n            align-items: center;\\n            margin: 0 auto;\\n            li.project{\\n                font-size: 1.3rem;\\n                width: 220px;\\n                background-color: white;\\n                display: flex;\\n                gap: 10px;\\n                justify-content: center;\\n                align-items: center;\\n                padding: 10px;\\n                border: 1px solid;\\n                font-family: \'rock salt\', cursive;\\n                &:hover{\\n                    cursor: pointer;\\n                }\\n            }\\n        }\\n    }\\n    .todoList{\\n        display: flex;\\n        flex-direction: column;\\n        justify-content: flex-start;\\n        align-items: center;\\n        gap: 10px;\\n        background-color: $TODOLIST;\\n        table{\\n            margin-top: 10px;\\n            min-width: clamp(320px, 800px, 1000px);\\n            max-width: clamp(400px, 1200px, 1600px);\\n            border-radius: 20px;\\n            .titles{\\n                &:hover{\\n                    box-shadow: none;\\n                }\\n                font-size: 1.5rem;\\n                font-family: \'Times New Roman\', Times, serif;\\n                .dueDate{\\n                    text-align: right;\\n                }\\n                .projName{\\n                    text-align: left;\\n                }\\n                th{\\n                    padding: 10px 0;\\n                }\\n            }\\n\\n            tr.createdRow{\\n                &:hover{\\n                    box-shadow: 0 0 5px 5px;\\n                }\\n                td{\\n                    vertical-align: middle;\\n                    max-width: 600px;\\n                    padding: 10px 0 10px 10px;\\n                }\\n                .column1{\\n                    font-size: 1.5rem;\\n                }\\n                .column2{\\n                    display: flex;\\n                    justify-content: flex-end;\\n                    align-items: center;\\n                    gap: 10px;\\n                    font-size: 1.3rem;\\n                }\\n            }\\n\\n            .viewOnly{\\n                td{\\n                    vertical-align: middle;\\n                    max-width: 600px;\\n                    padding: 10px 0 10px 10px;\\n                }\\n                .column1{\\n                    font-size: 1.5rem;\\n                }\\n                .column2{\\n                    display: flex;\\n                    justify-content: flex-end;\\n                    align-items: center;\\n                    gap: 10px;\\n                    font-size: 1.5rem;\\n                }\\n            }\\n        }\\n    }\\n}\\n\\ni, .addToDoBtn, .addProjectBtn{\\n    cursor: pointer;\\n}\\n.fa-calendar-day, .fa-bars-progress{\\n    cursor: default;\\n}\\n.fa-bars-progress, .fa-calendar, .fa-exclamation, .fa-calendar-day{\\n    margin-left: 10px;\\n}\\n\\n.completed{\\n    opacity: 0.5;\\n    text-decoration: line-through;\\n}\\n\\n\\n#modal, #editModal, #projectModal{\\n\\n    margin: auto auto;\\n    max-width: 100ch;\\n    padding: 10px;\\n    border: 0;\\n    border-radius: 10px;\\n    box-shadow: 0 0 1em rgb(0 0 0 / .3);\\n    background-color: salmon;\\n\\n    h2{\\n        letter-spacing: 5px;\\n        text-align: center;\\n        font-size: 1.2rem;\\n    }\\n\\n    .editForm, .projectForm, .form{\\n        \\n        display: flex;\\n        flex-direction: column;\\n        justify-content: center;\\n        align-items: center;\\n        height: 400px;\\n        width: 350px;\\n        gap: 20px;\\n        font-size: 1.2rem;\\n        font-weight: bold;\\n\\n        label, textarea, input[type=\\"text\\"],\\n        input[type=\\"datetime-local\\"], .btns{\\n            letter-spacing: 1px;\\n            width: 200px;\\n            font-family: Roboto, Oxygen, Ubuntu, Cantarell, \'Open Sans\', \'Helvetica Neue\', sans-serif;\\n        }\\n        \\n        input, textarea, select{\\n            background-color: white;\\n        }\\n    \\n        textarea {\\n            padding: 10px;\\n            max-width: 100%;\\n            line-height: 1.5;\\n            border-radius: 5px;\\n            border: 1px solid #ccc;\\n            box-shadow: 1px 1px 1px #999;\\n        }\\n    \\n        label {\\n            display: block;\\n            margin-bottom: 5px;\\n        }\\n    \\n        input[type=\\"text\\"]{\\n            padding: 5px;\\n        }\\n    \\n        .btns{\\n            @include center;\\n            gap: 5px;\\n            .submitProjectBtn, .cancelProjectBtn, \\n            .createModalSubmitBtn, .createModalCancelBtn,\\n            .cancelEditBtn, .submitEditBtn\\n            {\\n                background-color: greenyellow;\\n                max-width: 50px;\\n                padding: 10px;\\n                &:hover{\\n                    cursor: pointer;\\n                    background-color: white;\\n                }\\n            }\\n            .cancelEditBtn, .createModalCancelBtn, .cancelProjectBtn{\\n                background-color: red;\\n            }\\n        }\\n    }\\n\\n    & > * {\\n    margin: 0 0 0.5rem 0;\\n    }\\n    &::backdrop{\\n    background: rgb(0 0 0 / 0.4);\\n    }\\n\\n}\\n\\n#projectModal{\\n    .projectForm{\\n        height: 120px;\\n        width: 250px;\\n    }\\n}\\n\\n.footer{\\n    font-size: 1rem;\\n    font-family: Roboto, Oxygen, Ubuntu, Cantarell, \'Open Sans\', \'Helvetica Neue\', sans-serif;\\n    padding: 10px;\\n    background-color: #80f0e4;\\n    text-align: center;\\n}\\n\\n\\n// animation\\n\\n.fa-circle-plus, \\n.fa-github, \\n.fa-linkedin,\\n.svg{\\n    transition-duration: 0.75s;\\n    transform: rotate(720deg) scale(1.5);\\n    cursor: pointer;\\n}\\n\\n","$BODY: #3f3f3f;\\n$FONT: white;\\n$HEADER: rgba(255, 72, 0, .7);\\n$SIDEBAR: rgba(255, 72, 0, .3);\\n$SIDEBAR_TEXT: black;\\n$TODOLIST: rgba(255, 72, 0, .1);\\n$TODO_INFO_FORM: white;\\n$LOGO-COLOR: #80f0e4;"],"sourceRoot":""}]);\n// Exports\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUEyQyxXQUFXLHVCQUF1Qiw2QkFBNkIsaUNBQWlDLFdBQVcscUNBQXFDLDJCQUEyQixXQUFXLHNCQUFzQiw4QkFBOEIsdUJBQXVCLDBLQUEwSyxnREFBZ0Qsa0NBQWtDLGdDQUFnQywwQkFBMEIsc0NBQXNDLDhDQUE4QyxtQkFBbUIsZUFBZSx1RUFBdUUsd0NBQXdDLGVBQWUsV0FBVyxPQUFPLGVBQWUsMkJBQTJCLE9BQU8sa0JBQWtCLG1DQUFtQyxPQUFPLEtBQUssa0JBQWtCLG1CQUFtQix3QkFBd0IsdUJBQXVCLE9BQU8sR0FBRyxZQUFZLHNCQUFzQixnR0FBZ0csb0JBQW9CLGdDQUFnQyx5QkFBeUIsR0FBRywyRUFBMkUsaUNBQWlDLDJDQUEyQyxzQkFBc0IsR0FBRyxzQkFBc0IsZUFBZSxnQ0FBZ0MsaUNBQWlDLHVCQUF1QixrQ0FBa0MseUJBQXlCLHVCQUF1QixtQkFBbUI7QUFDdHF0QjtBQUNBLGlFQUFlLHVCQUF1QixFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdG9kby1saXN0Ly4vc3JjL3N0eWxlLnNjc3M/ODc2YyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBJbXBvcnRzXG5pbXBvcnQgX19fQ1NTX0xPQURFUl9BUElfU09VUkNFTUFQX0lNUE9SVF9fXyBmcm9tIFwiLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL3NvdXJjZU1hcHMuanNcIjtcbmltcG9ydCBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18gZnJvbSBcIi4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9hcGkuanNcIjtcbnZhciBfX19DU1NfTE9BREVSX0VYUE9SVF9fXyA9IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyhfX19DU1NfTE9BREVSX0FQSV9TT1VSQ0VNQVBfSU1QT1JUX19fKTtcbi8vIE1vZHVsZVxuX19fQ1NTX0xPQURFUl9FWFBPUlRfX18ucHVzaChbbW9kdWxlLmlkLCBcIip7cGFkZGluZzowO21hcmdpbjowO2JveC1zaXppbmc6Ym9yZGVyLWJveH1ib2R5e2ZvbnQtZmFtaWx5OlxcXCJDb21pbmcgU29vblxcXCIsY3Vyc2l2ZTtoZWlnaHQ6MTAwdmg7d2lkdGg6MTAwdnc7ZGlzcGxheTpmbGV4O2ZsZXgtZGlyZWN0aW9uOmNvbHVtbn0jaGVhZGVye2Rpc3BsYXk6ZmxleDtqdXN0aWZ5LWNvbnRlbnQ6Y2VudGVyO2FsaWduLWl0ZW1zOmNlbnRlcjtqdXN0aWZ5LWNvbnRlbnQ6ZmxleC1zdGFydDtiYWNrZ3JvdW5kLWNvbG9yOnJnYmEoMjU1LDcyLDAsLjcpO2NvbG9yOiNmZmY7Zm9udC1zaXplOjEuOHJlbTtmb250LXdlaWdodDo5MDA7Z2FwOjFyZW07d2lkdGg6MTAwJX0jaGVhZGVyIC5sb2dve21heC1oZWlnaHQ6NHJlbTtwYWRkaW5nOjVweH0jY29udGVudHtkaXNwbGF5OmdyaWQ7Z3JpZC10ZW1wbGF0ZS1jb2x1bW5zOjFmciA2ZnI7aGVpZ2h0OjEwMHZofSNjb250ZW50IC5zaWRlYmFye2ZvbnQtc2l6ZToxLjVyZW07cGFkZGluZzoxMHB4O2JhY2tncm91bmQtY29sb3I6cmdiYSgyNTUsNzIsMCwuMyl9I2NvbnRlbnQgLnNpZGViYXIgdWx7dGV4dC1hbGlnbjpjZW50ZXI7bGlzdC1zdHlsZS10eXBlOm5vbmV9I2NvbnRlbnQgLnNpZGViYXIgdWwgLmxpbmt7cGFkZGluZzoxMHB4O3RleHQtZGVjb3JhdGlvbjpub25lO2NvbG9yOiMwMDA7dGV4dC1zaGFkb3c6MXB4IDFweCAjZmZmfSNjb250ZW50IC5zaWRlYmFyIHVsIC50b2RheSwjY29udGVudCAuc2lkZWJhciB1bCAud2Vla3tjdXJzb3I6cG9pbnRlcn0jY29udGVudCAuc2lkZWJhciBsaS5wcm9qZWN0c0xpe2JhY2tncm91bmQtY29sb3I6IzgwZjBlNDtib3JkZXItcmFkaXVzOjE1cHh9I2NvbnRlbnQgLnNpZGViYXIgbGkucHJvamVjdHNMaSB1bHtwYWRkaW5nOjEwcHg7ZGlzcGxheTpmbGV4O2ZsZXgtZGlyZWN0aW9uOmNvbHVtbjtnYXA6MTBweDtqdXN0aWZ5LWNvbnRlbnQ6Y2VudGVyO2FsaWduLWl0ZW1zOmNlbnRlcjttYXJnaW46MCBhdXRvfSNjb250ZW50IC5zaWRlYmFyIGxpLnByb2plY3RzTGkgdWwgbGkucHJvamVjdHtmb250LXNpemU6MS4zcmVtO3dpZHRoOjIyMHB4O2JhY2tncm91bmQtY29sb3I6I2ZmZjtkaXNwbGF5OmZsZXg7Z2FwOjEwcHg7anVzdGlmeS1jb250ZW50OmNlbnRlcjthbGlnbi1pdGVtczpjZW50ZXI7cGFkZGluZzoxMHB4O2JvcmRlcjoxcHggc29saWQ7Zm9udC1mYW1pbHk6XFxcInJvY2sgc2FsdFxcXCIsY3Vyc2l2ZX0jY29udGVudCAuc2lkZWJhciBsaS5wcm9qZWN0c0xpIHVsIGxpLnByb2plY3Q6aG92ZXJ7Y3Vyc29yOnBvaW50ZXJ9I2NvbnRlbnQgLnRvZG9MaXN0e2Rpc3BsYXk6ZmxleDtmbGV4LWRpcmVjdGlvbjpjb2x1bW47anVzdGlmeS1jb250ZW50OmZsZXgtc3RhcnQ7YWxpZ24taXRlbXM6Y2VudGVyO2dhcDoxMHB4O2JhY2tncm91bmQtY29sb3I6cmdiYSgyNTUsNzIsMCwuMSl9I2NvbnRlbnQgLnRvZG9MaXN0IHRhYmxle21hcmdpbi10b3A6MTBweDttaW4td2lkdGg6ODAwcHg7bWF4LXdpZHRoOjEyMDBweDtib3JkZXItcmFkaXVzOjIwcHh9I2NvbnRlbnQgLnRvZG9MaXN0IHRhYmxlIC50aXRsZXN7Zm9udC1zaXplOjEuNXJlbTtmb250LWZhbWlseTpcXFwiVGltZXMgTmV3IFJvbWFuXFxcIixUaW1lcyxzZXJpZn0jY29udGVudCAudG9kb0xpc3QgdGFibGUgLnRpdGxlczpob3Zlcntib3gtc2hhZG93Om5vbmV9I2NvbnRlbnQgLnRvZG9MaXN0IHRhYmxlIC50aXRsZXMgLmR1ZURhdGV7dGV4dC1hbGlnbjpyaWdodH0jY29udGVudCAudG9kb0xpc3QgdGFibGUgLnRpdGxlcyAucHJvak5hbWV7dGV4dC1hbGlnbjpsZWZ0fSNjb250ZW50IC50b2RvTGlzdCB0YWJsZSAudGl0bGVzIHRoe3BhZGRpbmc6MTBweCAwfSNjb250ZW50IC50b2RvTGlzdCB0YWJsZSB0ci5jcmVhdGVkUm93OmhvdmVye2JveC1zaGFkb3c6MCAwIDVweCA1cHh9I2NvbnRlbnQgLnRvZG9MaXN0IHRhYmxlIHRyLmNyZWF0ZWRSb3cgdGR7dmVydGljYWwtYWxpZ246bWlkZGxlO21heC13aWR0aDo2MDBweDtwYWRkaW5nOjEwcHggMCAxMHB4IDEwcHh9I2NvbnRlbnQgLnRvZG9MaXN0IHRhYmxlIHRyLmNyZWF0ZWRSb3cgLmNvbHVtbjF7Zm9udC1zaXplOjEuNXJlbX0jY29udGVudCAudG9kb0xpc3QgdGFibGUgdHIuY3JlYXRlZFJvdyAuY29sdW1uMntkaXNwbGF5OmZsZXg7anVzdGlmeS1jb250ZW50OmZsZXgtZW5kO2FsaWduLWl0ZW1zOmNlbnRlcjtnYXA6MTBweDtmb250LXNpemU6MS4zcmVtfSNjb250ZW50IC50b2RvTGlzdCB0YWJsZSAudmlld09ubHkgdGR7dmVydGljYWwtYWxpZ246bWlkZGxlO21heC13aWR0aDo2MDBweDtwYWRkaW5nOjEwcHggMCAxMHB4IDEwcHh9I2NvbnRlbnQgLnRvZG9MaXN0IHRhYmxlIC52aWV3T25seSAuY29sdW1uMXtmb250LXNpemU6MS41cmVtfSNjb250ZW50IC50b2RvTGlzdCB0YWJsZSAudmlld09ubHkgLmNvbHVtbjJ7ZGlzcGxheTpmbGV4O2p1c3RpZnktY29udGVudDpmbGV4LWVuZDthbGlnbi1pdGVtczpjZW50ZXI7Z2FwOjEwcHg7Zm9udC1zaXplOjEuNXJlbX1pLC5hZGRUb0RvQnRuLC5hZGRQcm9qZWN0QnRue2N1cnNvcjpwb2ludGVyfS5mYS1jYWxlbmRhci1kYXksLmZhLWJhcnMtcHJvZ3Jlc3N7Y3Vyc29yOmRlZmF1bHR9LmZhLWJhcnMtcHJvZ3Jlc3MsLmZhLWNhbGVuZGFyLC5mYS1leGNsYW1hdGlvbiwuZmEtY2FsZW5kYXItZGF5e21hcmdpbi1sZWZ0OjEwcHh9LmNvbXBsZXRlZHtvcGFjaXR5Oi41O3RleHQtZGVjb3JhdGlvbjpsaW5lLXRocm91Z2h9I21vZGFsLCNlZGl0TW9kYWwsI3Byb2plY3RNb2RhbHttYXJnaW46YXV0byBhdXRvO21heC13aWR0aDoxMDBjaDtwYWRkaW5nOjEwcHg7Ym9yZGVyOjA7Ym9yZGVyLXJhZGl1czoxMHB4O2JveC1zaGFkb3c6MCAwIDFlbSByZ2JhKDAsMCwwLC4zKTtiYWNrZ3JvdW5kLWNvbG9yOnNhbG1vbn0jbW9kYWwgaDIsI2VkaXRNb2RhbCBoMiwjcHJvamVjdE1vZGFsIGgye2xldHRlci1zcGFjaW5nOjVweDt0ZXh0LWFsaWduOmNlbnRlcjtmb250LXNpemU6MS4ycmVtfSNtb2RhbCAuZWRpdEZvcm0sI21vZGFsIC5wcm9qZWN0Rm9ybSwjbW9kYWwgLmZvcm0sI2VkaXRNb2RhbCAuZWRpdEZvcm0sI2VkaXRNb2RhbCAucHJvamVjdEZvcm0sI2VkaXRNb2RhbCAuZm9ybSwjcHJvamVjdE1vZGFsIC5lZGl0Rm9ybSwjcHJvamVjdE1vZGFsIC5wcm9qZWN0Rm9ybSwjcHJvamVjdE1vZGFsIC5mb3Jte2Rpc3BsYXk6ZmxleDtmbGV4LWRpcmVjdGlvbjpjb2x1bW47anVzdGlmeS1jb250ZW50OmNlbnRlcjthbGlnbi1pdGVtczpjZW50ZXI7aGVpZ2h0OjQwMHB4O3dpZHRoOjM1MHB4O2dhcDoyMHB4O2ZvbnQtc2l6ZToxLjJyZW07Zm9udC13ZWlnaHQ6Ym9sZH0jbW9kYWwgLmVkaXRGb3JtIGxhYmVsLCNtb2RhbCAuZWRpdEZvcm0gdGV4dGFyZWEsI21vZGFsIC5lZGl0Rm9ybSBpbnB1dFt0eXBlPXRleHRdLCNtb2RhbCAuZWRpdEZvcm0gaW5wdXRbdHlwZT1kYXRldGltZS1sb2NhbF0sI21vZGFsIC5lZGl0Rm9ybSAuYnRucywjbW9kYWwgLnByb2plY3RGb3JtIGxhYmVsLCNtb2RhbCAucHJvamVjdEZvcm0gdGV4dGFyZWEsI21vZGFsIC5wcm9qZWN0Rm9ybSBpbnB1dFt0eXBlPXRleHRdLCNtb2RhbCAucHJvamVjdEZvcm0gaW5wdXRbdHlwZT1kYXRldGltZS1sb2NhbF0sI21vZGFsIC5wcm9qZWN0Rm9ybSAuYnRucywjbW9kYWwgLmZvcm0gbGFiZWwsI21vZGFsIC5mb3JtIHRleHRhcmVhLCNtb2RhbCAuZm9ybSBpbnB1dFt0eXBlPXRleHRdLCNtb2RhbCAuZm9ybSBpbnB1dFt0eXBlPWRhdGV0aW1lLWxvY2FsXSwjbW9kYWwgLmZvcm0gLmJ0bnMsI2VkaXRNb2RhbCAuZWRpdEZvcm0gbGFiZWwsI2VkaXRNb2RhbCAuZWRpdEZvcm0gdGV4dGFyZWEsI2VkaXRNb2RhbCAuZWRpdEZvcm0gaW5wdXRbdHlwZT10ZXh0XSwjZWRpdE1vZGFsIC5lZGl0Rm9ybSBpbnB1dFt0eXBlPWRhdGV0aW1lLWxvY2FsXSwjZWRpdE1vZGFsIC5lZGl0Rm9ybSAuYnRucywjZWRpdE1vZGFsIC5wcm9qZWN0Rm9ybSBsYWJlbCwjZWRpdE1vZGFsIC5wcm9qZWN0Rm9ybSB0ZXh0YXJlYSwjZWRpdE1vZGFsIC5wcm9qZWN0Rm9ybSBpbnB1dFt0eXBlPXRleHRdLCNlZGl0TW9kYWwgLnByb2plY3RGb3JtIGlucHV0W3R5cGU9ZGF0ZXRpbWUtbG9jYWxdLCNlZGl0TW9kYWwgLnByb2plY3RGb3JtIC5idG5zLCNlZGl0TW9kYWwgLmZvcm0gbGFiZWwsI2VkaXRNb2RhbCAuZm9ybSB0ZXh0YXJlYSwjZWRpdE1vZGFsIC5mb3JtIGlucHV0W3R5cGU9dGV4dF0sI2VkaXRNb2RhbCAuZm9ybSBpbnB1dFt0eXBlPWRhdGV0aW1lLWxvY2FsXSwjZWRpdE1vZGFsIC5mb3JtIC5idG5zLCNwcm9qZWN0TW9kYWwgLmVkaXRGb3JtIGxhYmVsLCNwcm9qZWN0TW9kYWwgLmVkaXRGb3JtIHRleHRhcmVhLCNwcm9qZWN0TW9kYWwgLmVkaXRGb3JtIGlucHV0W3R5cGU9dGV4dF0sI3Byb2plY3RNb2RhbCAuZWRpdEZvcm0gaW5wdXRbdHlwZT1kYXRldGltZS1sb2NhbF0sI3Byb2plY3RNb2RhbCAuZWRpdEZvcm0gLmJ0bnMsI3Byb2plY3RNb2RhbCAucHJvamVjdEZvcm0gbGFiZWwsI3Byb2plY3RNb2RhbCAucHJvamVjdEZvcm0gdGV4dGFyZWEsI3Byb2plY3RNb2RhbCAucHJvamVjdEZvcm0gaW5wdXRbdHlwZT10ZXh0XSwjcHJvamVjdE1vZGFsIC5wcm9qZWN0Rm9ybSBpbnB1dFt0eXBlPWRhdGV0aW1lLWxvY2FsXSwjcHJvamVjdE1vZGFsIC5wcm9qZWN0Rm9ybSAuYnRucywjcHJvamVjdE1vZGFsIC5mb3JtIGxhYmVsLCNwcm9qZWN0TW9kYWwgLmZvcm0gdGV4dGFyZWEsI3Byb2plY3RNb2RhbCAuZm9ybSBpbnB1dFt0eXBlPXRleHRdLCNwcm9qZWN0TW9kYWwgLmZvcm0gaW5wdXRbdHlwZT1kYXRldGltZS1sb2NhbF0sI3Byb2plY3RNb2RhbCAuZm9ybSAuYnRuc3tsZXR0ZXItc3BhY2luZzoxcHg7d2lkdGg6MjAwcHg7Zm9udC1mYW1pbHk6Um9ib3RvLE94eWdlbixVYnVudHUsQ2FudGFyZWxsLFxcXCJPcGVuIFNhbnNcXFwiLFxcXCJIZWx2ZXRpY2EgTmV1ZVxcXCIsc2Fucy1zZXJpZn0jbW9kYWwgLmVkaXRGb3JtIGlucHV0LCNtb2RhbCAuZWRpdEZvcm0gdGV4dGFyZWEsI21vZGFsIC5lZGl0Rm9ybSBzZWxlY3QsI21vZGFsIC5wcm9qZWN0Rm9ybSBpbnB1dCwjbW9kYWwgLnByb2plY3RGb3JtIHRleHRhcmVhLCNtb2RhbCAucHJvamVjdEZvcm0gc2VsZWN0LCNtb2RhbCAuZm9ybSBpbnB1dCwjbW9kYWwgLmZvcm0gdGV4dGFyZWEsI21vZGFsIC5mb3JtIHNlbGVjdCwjZWRpdE1vZGFsIC5lZGl0Rm9ybSBpbnB1dCwjZWRpdE1vZGFsIC5lZGl0Rm9ybSB0ZXh0YXJlYSwjZWRpdE1vZGFsIC5lZGl0Rm9ybSBzZWxlY3QsI2VkaXRNb2RhbCAucHJvamVjdEZvcm0gaW5wdXQsI2VkaXRNb2RhbCAucHJvamVjdEZvcm0gdGV4dGFyZWEsI2VkaXRNb2RhbCAucHJvamVjdEZvcm0gc2VsZWN0LCNlZGl0TW9kYWwgLmZvcm0gaW5wdXQsI2VkaXRNb2RhbCAuZm9ybSB0ZXh0YXJlYSwjZWRpdE1vZGFsIC5mb3JtIHNlbGVjdCwjcHJvamVjdE1vZGFsIC5lZGl0Rm9ybSBpbnB1dCwjcHJvamVjdE1vZGFsIC5lZGl0Rm9ybSB0ZXh0YXJlYSwjcHJvamVjdE1vZGFsIC5lZGl0Rm9ybSBzZWxlY3QsI3Byb2plY3RNb2RhbCAucHJvamVjdEZvcm0gaW5wdXQsI3Byb2plY3RNb2RhbCAucHJvamVjdEZvcm0gdGV4dGFyZWEsI3Byb2plY3RNb2RhbCAucHJvamVjdEZvcm0gc2VsZWN0LCNwcm9qZWN0TW9kYWwgLmZvcm0gaW5wdXQsI3Byb2plY3RNb2RhbCAuZm9ybSB0ZXh0YXJlYSwjcHJvamVjdE1vZGFsIC5mb3JtIHNlbGVjdHtiYWNrZ3JvdW5kLWNvbG9yOiNmZmZ9I21vZGFsIC5lZGl0Rm9ybSB0ZXh0YXJlYSwjbW9kYWwgLnByb2plY3RGb3JtIHRleHRhcmVhLCNtb2RhbCAuZm9ybSB0ZXh0YXJlYSwjZWRpdE1vZGFsIC5lZGl0Rm9ybSB0ZXh0YXJlYSwjZWRpdE1vZGFsIC5wcm9qZWN0Rm9ybSB0ZXh0YXJlYSwjZWRpdE1vZGFsIC5mb3JtIHRleHRhcmVhLCNwcm9qZWN0TW9kYWwgLmVkaXRGb3JtIHRleHRhcmVhLCNwcm9qZWN0TW9kYWwgLnByb2plY3RGb3JtIHRleHRhcmVhLCNwcm9qZWN0TW9kYWwgLmZvcm0gdGV4dGFyZWF7cGFkZGluZzoxMHB4O21heC13aWR0aDoxMDAlO2xpbmUtaGVpZ2h0OjEuNTtib3JkZXItcmFkaXVzOjVweDtib3JkZXI6MXB4IHNvbGlkICNjY2M7Ym94LXNoYWRvdzoxcHggMXB4IDFweCAjOTk5fSNtb2RhbCAuZWRpdEZvcm0gbGFiZWwsI21vZGFsIC5wcm9qZWN0Rm9ybSBsYWJlbCwjbW9kYWwgLmZvcm0gbGFiZWwsI2VkaXRNb2RhbCAuZWRpdEZvcm0gbGFiZWwsI2VkaXRNb2RhbCAucHJvamVjdEZvcm0gbGFiZWwsI2VkaXRNb2RhbCAuZm9ybSBsYWJlbCwjcHJvamVjdE1vZGFsIC5lZGl0Rm9ybSBsYWJlbCwjcHJvamVjdE1vZGFsIC5wcm9qZWN0Rm9ybSBsYWJlbCwjcHJvamVjdE1vZGFsIC5mb3JtIGxhYmVse2Rpc3BsYXk6YmxvY2s7bWFyZ2luLWJvdHRvbTo1cHh9I21vZGFsIC5lZGl0Rm9ybSBpbnB1dFt0eXBlPXRleHRdLCNtb2RhbCAucHJvamVjdEZvcm0gaW5wdXRbdHlwZT10ZXh0XSwjbW9kYWwgLmZvcm0gaW5wdXRbdHlwZT10ZXh0XSwjZWRpdE1vZGFsIC5lZGl0Rm9ybSBpbnB1dFt0eXBlPXRleHRdLCNlZGl0TW9kYWwgLnByb2plY3RGb3JtIGlucHV0W3R5cGU9dGV4dF0sI2VkaXRNb2RhbCAuZm9ybSBpbnB1dFt0eXBlPXRleHRdLCNwcm9qZWN0TW9kYWwgLmVkaXRGb3JtIGlucHV0W3R5cGU9dGV4dF0sI3Byb2plY3RNb2RhbCAucHJvamVjdEZvcm0gaW5wdXRbdHlwZT10ZXh0XSwjcHJvamVjdE1vZGFsIC5mb3JtIGlucHV0W3R5cGU9dGV4dF17cGFkZGluZzo1cHh9I21vZGFsIC5lZGl0Rm9ybSAuYnRucywjbW9kYWwgLnByb2plY3RGb3JtIC5idG5zLCNtb2RhbCAuZm9ybSAuYnRucywjZWRpdE1vZGFsIC5lZGl0Rm9ybSAuYnRucywjZWRpdE1vZGFsIC5wcm9qZWN0Rm9ybSAuYnRucywjZWRpdE1vZGFsIC5mb3JtIC5idG5zLCNwcm9qZWN0TW9kYWwgLmVkaXRGb3JtIC5idG5zLCNwcm9qZWN0TW9kYWwgLnByb2plY3RGb3JtIC5idG5zLCNwcm9qZWN0TW9kYWwgLmZvcm0gLmJ0bnN7ZGlzcGxheTpmbGV4O2p1c3RpZnktY29udGVudDpjZW50ZXI7YWxpZ24taXRlbXM6Y2VudGVyO2dhcDo1cHh9I21vZGFsIC5lZGl0Rm9ybSAuYnRucyAuc3VibWl0UHJvamVjdEJ0biwjbW9kYWwgLmVkaXRGb3JtIC5idG5zIC5jYW5jZWxQcm9qZWN0QnRuLCNtb2RhbCAuZWRpdEZvcm0gLmJ0bnMgLmNyZWF0ZU1vZGFsU3VibWl0QnRuLCNtb2RhbCAuZWRpdEZvcm0gLmJ0bnMgLmNyZWF0ZU1vZGFsQ2FuY2VsQnRuLCNtb2RhbCAuZWRpdEZvcm0gLmJ0bnMgLmNhbmNlbEVkaXRCdG4sI21vZGFsIC5lZGl0Rm9ybSAuYnRucyAuc3VibWl0RWRpdEJ0biwjbW9kYWwgLnByb2plY3RGb3JtIC5idG5zIC5zdWJtaXRQcm9qZWN0QnRuLCNtb2RhbCAucHJvamVjdEZvcm0gLmJ0bnMgLmNhbmNlbFByb2plY3RCdG4sI21vZGFsIC5wcm9qZWN0Rm9ybSAuYnRucyAuY3JlYXRlTW9kYWxTdWJtaXRCdG4sI21vZGFsIC5wcm9qZWN0Rm9ybSAuYnRucyAuY3JlYXRlTW9kYWxDYW5jZWxCdG4sI21vZGFsIC5wcm9qZWN0Rm9ybSAuYnRucyAuY2FuY2VsRWRpdEJ0biwjbW9kYWwgLnByb2plY3RGb3JtIC5idG5zIC5zdWJtaXRFZGl0QnRuLCNtb2RhbCAuZm9ybSAuYnRucyAuc3VibWl0UHJvamVjdEJ0biwjbW9kYWwgLmZvcm0gLmJ0bnMgLmNhbmNlbFByb2plY3RCdG4sI21vZGFsIC5mb3JtIC5idG5zIC5jcmVhdGVNb2RhbFN1Ym1pdEJ0biwjbW9kYWwgLmZvcm0gLmJ0bnMgLmNyZWF0ZU1vZGFsQ2FuY2VsQnRuLCNtb2RhbCAuZm9ybSAuYnRucyAuY2FuY2VsRWRpdEJ0biwjbW9kYWwgLmZvcm0gLmJ0bnMgLnN1Ym1pdEVkaXRCdG4sI2VkaXRNb2RhbCAuZWRpdEZvcm0gLmJ0bnMgLnN1Ym1pdFByb2plY3RCdG4sI2VkaXRNb2RhbCAuZWRpdEZvcm0gLmJ0bnMgLmNhbmNlbFByb2plY3RCdG4sI2VkaXRNb2RhbCAuZWRpdEZvcm0gLmJ0bnMgLmNyZWF0ZU1vZGFsU3VibWl0QnRuLCNlZGl0TW9kYWwgLmVkaXRGb3JtIC5idG5zIC5jcmVhdGVNb2RhbENhbmNlbEJ0biwjZWRpdE1vZGFsIC5lZGl0Rm9ybSAuYnRucyAuY2FuY2VsRWRpdEJ0biwjZWRpdE1vZGFsIC5lZGl0Rm9ybSAuYnRucyAuc3VibWl0RWRpdEJ0biwjZWRpdE1vZGFsIC5wcm9qZWN0Rm9ybSAuYnRucyAuc3VibWl0UHJvamVjdEJ0biwjZWRpdE1vZGFsIC5wcm9qZWN0Rm9ybSAuYnRucyAuY2FuY2VsUHJvamVjdEJ0biwjZWRpdE1vZGFsIC5wcm9qZWN0Rm9ybSAuYnRucyAuY3JlYXRlTW9kYWxTdWJtaXRCdG4sI2VkaXRNb2RhbCAucHJvamVjdEZvcm0gLmJ0bnMgLmNyZWF0ZU1vZGFsQ2FuY2VsQnRuLCNlZGl0TW9kYWwgLnByb2plY3RGb3JtIC5idG5zIC5jYW5jZWxFZGl0QnRuLCNlZGl0TW9kYWwgLnByb2plY3RGb3JtIC5idG5zIC5zdWJtaXRFZGl0QnRuLCNlZGl0TW9kYWwgLmZvcm0gLmJ0bnMgLnN1Ym1pdFByb2plY3RCdG4sI2VkaXRNb2RhbCAuZm9ybSAuYnRucyAuY2FuY2VsUHJvamVjdEJ0biwjZWRpdE1vZGFsIC5mb3JtIC5idG5zIC5jcmVhdGVNb2RhbFN1Ym1pdEJ0biwjZWRpdE1vZGFsIC5mb3JtIC5idG5zIC5jcmVhdGVNb2RhbENhbmNlbEJ0biwjZWRpdE1vZGFsIC5mb3JtIC5idG5zIC5jYW5jZWxFZGl0QnRuLCNlZGl0TW9kYWwgLmZvcm0gLmJ0bnMgLnN1Ym1pdEVkaXRCdG4sI3Byb2plY3RNb2RhbCAuZWRpdEZvcm0gLmJ0bnMgLnN1Ym1pdFByb2plY3RCdG4sI3Byb2plY3RNb2RhbCAuZWRpdEZvcm0gLmJ0bnMgLmNhbmNlbFByb2plY3RCdG4sI3Byb2plY3RNb2RhbCAuZWRpdEZvcm0gLmJ0bnMgLmNyZWF0ZU1vZGFsU3VibWl0QnRuLCNwcm9qZWN0TW9kYWwgLmVkaXRGb3JtIC5idG5zIC5jcmVhdGVNb2RhbENhbmNlbEJ0biwjcHJvamVjdE1vZGFsIC5lZGl0Rm9ybSAuYnRucyAuY2FuY2VsRWRpdEJ0biwjcHJvamVjdE1vZGFsIC5lZGl0Rm9ybSAuYnRucyAuc3VibWl0RWRpdEJ0biwjcHJvamVjdE1vZGFsIC5wcm9qZWN0Rm9ybSAuYnRucyAuc3VibWl0UHJvamVjdEJ0biwjcHJvamVjdE1vZGFsIC5wcm9qZWN0Rm9ybSAuYnRucyAuY2FuY2VsUHJvamVjdEJ0biwjcHJvamVjdE1vZGFsIC5wcm9qZWN0Rm9ybSAuYnRucyAuY3JlYXRlTW9kYWxTdWJtaXRCdG4sI3Byb2plY3RNb2RhbCAucHJvamVjdEZvcm0gLmJ0bnMgLmNyZWF0ZU1vZGFsQ2FuY2VsQnRuLCNwcm9qZWN0TW9kYWwgLnByb2plY3RGb3JtIC5idG5zIC5jYW5jZWxFZGl0QnRuLCNwcm9qZWN0TW9kYWwgLnByb2plY3RGb3JtIC5idG5zIC5zdWJtaXRFZGl0QnRuLCNwcm9qZWN0TW9kYWwgLmZvcm0gLmJ0bnMgLnN1Ym1pdFByb2plY3RCdG4sI3Byb2plY3RNb2RhbCAuZm9ybSAuYnRucyAuY2FuY2VsUHJvamVjdEJ0biwjcHJvamVjdE1vZGFsIC5mb3JtIC5idG5zIC5jcmVhdGVNb2RhbFN1Ym1pdEJ0biwjcHJvamVjdE1vZGFsIC5mb3JtIC5idG5zIC5jcmVhdGVNb2RhbENhbmNlbEJ0biwjcHJvamVjdE1vZGFsIC5mb3JtIC5idG5zIC5jYW5jZWxFZGl0QnRuLCNwcm9qZWN0TW9kYWwgLmZvcm0gLmJ0bnMgLnN1Ym1pdEVkaXRCdG57YmFja2dyb3VuZC1jb2xvcjojYWRmZjJmO21heC13aWR0aDo1MHB4O3BhZGRpbmc6MTBweH0jbW9kYWwgLmVkaXRGb3JtIC5idG5zIC5zdWJtaXRQcm9qZWN0QnRuOmhvdmVyLCNtb2RhbCAuZWRpdEZvcm0gLmJ0bnMgLmNhbmNlbFByb2plY3RCdG46aG92ZXIsI21vZGFsIC5lZGl0Rm9ybSAuYnRucyAuY3JlYXRlTW9kYWxTdWJtaXRCdG46aG92ZXIsI21vZGFsIC5lZGl0Rm9ybSAuYnRucyAuY3JlYXRlTW9kYWxDYW5jZWxCdG46aG92ZXIsI21vZGFsIC5lZGl0Rm9ybSAuYnRucyAuY2FuY2VsRWRpdEJ0bjpob3ZlciwjbW9kYWwgLmVkaXRGb3JtIC5idG5zIC5zdWJtaXRFZGl0QnRuOmhvdmVyLCNtb2RhbCAucHJvamVjdEZvcm0gLmJ0bnMgLnN1Ym1pdFByb2plY3RCdG46aG92ZXIsI21vZGFsIC5wcm9qZWN0Rm9ybSAuYnRucyAuY2FuY2VsUHJvamVjdEJ0bjpob3ZlciwjbW9kYWwgLnByb2plY3RGb3JtIC5idG5zIC5jcmVhdGVNb2RhbFN1Ym1pdEJ0bjpob3ZlciwjbW9kYWwgLnByb2plY3RGb3JtIC5idG5zIC5jcmVhdGVNb2RhbENhbmNlbEJ0bjpob3ZlciwjbW9kYWwgLnByb2plY3RGb3JtIC5idG5zIC5jYW5jZWxFZGl0QnRuOmhvdmVyLCNtb2RhbCAucHJvamVjdEZvcm0gLmJ0bnMgLnN1Ym1pdEVkaXRCdG46aG92ZXIsI21vZGFsIC5mb3JtIC5idG5zIC5zdWJtaXRQcm9qZWN0QnRuOmhvdmVyLCNtb2RhbCAuZm9ybSAuYnRucyAuY2FuY2VsUHJvamVjdEJ0bjpob3ZlciwjbW9kYWwgLmZvcm0gLmJ0bnMgLmNyZWF0ZU1vZGFsU3VibWl0QnRuOmhvdmVyLCNtb2RhbCAuZm9ybSAuYnRucyAuY3JlYXRlTW9kYWxDYW5jZWxCdG46aG92ZXIsI21vZGFsIC5mb3JtIC5idG5zIC5jYW5jZWxFZGl0QnRuOmhvdmVyLCNtb2RhbCAuZm9ybSAuYnRucyAuc3VibWl0RWRpdEJ0bjpob3ZlciwjZWRpdE1vZGFsIC5lZGl0Rm9ybSAuYnRucyAuc3VibWl0UHJvamVjdEJ0bjpob3ZlciwjZWRpdE1vZGFsIC5lZGl0Rm9ybSAuYnRucyAuY2FuY2VsUHJvamVjdEJ0bjpob3ZlciwjZWRpdE1vZGFsIC5lZGl0Rm9ybSAuYnRucyAuY3JlYXRlTW9kYWxTdWJtaXRCdG46aG92ZXIsI2VkaXRNb2RhbCAuZWRpdEZvcm0gLmJ0bnMgLmNyZWF0ZU1vZGFsQ2FuY2VsQnRuOmhvdmVyLCNlZGl0TW9kYWwgLmVkaXRGb3JtIC5idG5zIC5jYW5jZWxFZGl0QnRuOmhvdmVyLCNlZGl0TW9kYWwgLmVkaXRGb3JtIC5idG5zIC5zdWJtaXRFZGl0QnRuOmhvdmVyLCNlZGl0TW9kYWwgLnByb2plY3RGb3JtIC5idG5zIC5zdWJtaXRQcm9qZWN0QnRuOmhvdmVyLCNlZGl0TW9kYWwgLnByb2plY3RGb3JtIC5idG5zIC5jYW5jZWxQcm9qZWN0QnRuOmhvdmVyLCNlZGl0TW9kYWwgLnByb2plY3RGb3JtIC5idG5zIC5jcmVhdGVNb2RhbFN1Ym1pdEJ0bjpob3ZlciwjZWRpdE1vZGFsIC5wcm9qZWN0Rm9ybSAuYnRucyAuY3JlYXRlTW9kYWxDYW5jZWxCdG46aG92ZXIsI2VkaXRNb2RhbCAucHJvamVjdEZvcm0gLmJ0bnMgLmNhbmNlbEVkaXRCdG46aG92ZXIsI2VkaXRNb2RhbCAucHJvamVjdEZvcm0gLmJ0bnMgLnN1Ym1pdEVkaXRCdG46aG92ZXIsI2VkaXRNb2RhbCAuZm9ybSAuYnRucyAuc3VibWl0UHJvamVjdEJ0bjpob3ZlciwjZWRpdE1vZGFsIC5mb3JtIC5idG5zIC5jYW5jZWxQcm9qZWN0QnRuOmhvdmVyLCNlZGl0TW9kYWwgLmZvcm0gLmJ0bnMgLmNyZWF0ZU1vZGFsU3VibWl0QnRuOmhvdmVyLCNlZGl0TW9kYWwgLmZvcm0gLmJ0bnMgLmNyZWF0ZU1vZGFsQ2FuY2VsQnRuOmhvdmVyLCNlZGl0TW9kYWwgLmZvcm0gLmJ0bnMgLmNhbmNlbEVkaXRCdG46aG92ZXIsI2VkaXRNb2RhbCAuZm9ybSAuYnRucyAuc3VibWl0RWRpdEJ0bjpob3ZlciwjcHJvamVjdE1vZGFsIC5lZGl0Rm9ybSAuYnRucyAuc3VibWl0UHJvamVjdEJ0bjpob3ZlciwjcHJvamVjdE1vZGFsIC5lZGl0Rm9ybSAuYnRucyAuY2FuY2VsUHJvamVjdEJ0bjpob3ZlciwjcHJvamVjdE1vZGFsIC5lZGl0Rm9ybSAuYnRucyAuY3JlYXRlTW9kYWxTdWJtaXRCdG46aG92ZXIsI3Byb2plY3RNb2RhbCAuZWRpdEZvcm0gLmJ0bnMgLmNyZWF0ZU1vZGFsQ2FuY2VsQnRuOmhvdmVyLCNwcm9qZWN0TW9kYWwgLmVkaXRGb3JtIC5idG5zIC5jYW5jZWxFZGl0QnRuOmhvdmVyLCNwcm9qZWN0TW9kYWwgLmVkaXRGb3JtIC5idG5zIC5zdWJtaXRFZGl0QnRuOmhvdmVyLCNwcm9qZWN0TW9kYWwgLnByb2plY3RGb3JtIC5idG5zIC5zdWJtaXRQcm9qZWN0QnRuOmhvdmVyLCNwcm9qZWN0TW9kYWwgLnByb2plY3RGb3JtIC5idG5zIC5jYW5jZWxQcm9qZWN0QnRuOmhvdmVyLCNwcm9qZWN0TW9kYWwgLnByb2plY3RGb3JtIC5idG5zIC5jcmVhdGVNb2RhbFN1Ym1pdEJ0bjpob3ZlciwjcHJvamVjdE1vZGFsIC5wcm9qZWN0Rm9ybSAuYnRucyAuY3JlYXRlTW9kYWxDYW5jZWxCdG46aG92ZXIsI3Byb2plY3RNb2RhbCAucHJvamVjdEZvcm0gLmJ0bnMgLmNhbmNlbEVkaXRCdG46aG92ZXIsI3Byb2plY3RNb2RhbCAucHJvamVjdEZvcm0gLmJ0bnMgLnN1Ym1pdEVkaXRCdG46aG92ZXIsI3Byb2plY3RNb2RhbCAuZm9ybSAuYnRucyAuc3VibWl0UHJvamVjdEJ0bjpob3ZlciwjcHJvamVjdE1vZGFsIC5mb3JtIC5idG5zIC5jYW5jZWxQcm9qZWN0QnRuOmhvdmVyLCNwcm9qZWN0TW9kYWwgLmZvcm0gLmJ0bnMgLmNyZWF0ZU1vZGFsU3VibWl0QnRuOmhvdmVyLCNwcm9qZWN0TW9kYWwgLmZvcm0gLmJ0bnMgLmNyZWF0ZU1vZGFsQ2FuY2VsQnRuOmhvdmVyLCNwcm9qZWN0TW9kYWwgLmZvcm0gLmJ0bnMgLmNhbmNlbEVkaXRCdG46aG92ZXIsI3Byb2plY3RNb2RhbCAuZm9ybSAuYnRucyAuc3VibWl0RWRpdEJ0bjpob3ZlcntjdXJzb3I6cG9pbnRlcjtiYWNrZ3JvdW5kLWNvbG9yOiNmZmZ9I21vZGFsIC5lZGl0Rm9ybSAuYnRucyAuY2FuY2VsRWRpdEJ0biwjbW9kYWwgLmVkaXRGb3JtIC5idG5zIC5jcmVhdGVNb2RhbENhbmNlbEJ0biwjbW9kYWwgLmVkaXRGb3JtIC5idG5zIC5jYW5jZWxQcm9qZWN0QnRuLCNtb2RhbCAucHJvamVjdEZvcm0gLmJ0bnMgLmNhbmNlbEVkaXRCdG4sI21vZGFsIC5wcm9qZWN0Rm9ybSAuYnRucyAuY3JlYXRlTW9kYWxDYW5jZWxCdG4sI21vZGFsIC5wcm9qZWN0Rm9ybSAuYnRucyAuY2FuY2VsUHJvamVjdEJ0biwjbW9kYWwgLmZvcm0gLmJ0bnMgLmNhbmNlbEVkaXRCdG4sI21vZGFsIC5mb3JtIC5idG5zIC5jcmVhdGVNb2RhbENhbmNlbEJ0biwjbW9kYWwgLmZvcm0gLmJ0bnMgLmNhbmNlbFByb2plY3RCdG4sI2VkaXRNb2RhbCAuZWRpdEZvcm0gLmJ0bnMgLmNhbmNlbEVkaXRCdG4sI2VkaXRNb2RhbCAuZWRpdEZvcm0gLmJ0bnMgLmNyZWF0ZU1vZGFsQ2FuY2VsQnRuLCNlZGl0TW9kYWwgLmVkaXRGb3JtIC5idG5zIC5jYW5jZWxQcm9qZWN0QnRuLCNlZGl0TW9kYWwgLnByb2plY3RGb3JtIC5idG5zIC5jYW5jZWxFZGl0QnRuLCNlZGl0TW9kYWwgLnByb2plY3RGb3JtIC5idG5zIC5jcmVhdGVNb2RhbENhbmNlbEJ0biwjZWRpdE1vZGFsIC5wcm9qZWN0Rm9ybSAuYnRucyAuY2FuY2VsUHJvamVjdEJ0biwjZWRpdE1vZGFsIC5mb3JtIC5idG5zIC5jYW5jZWxFZGl0QnRuLCNlZGl0TW9kYWwgLmZvcm0gLmJ0bnMgLmNyZWF0ZU1vZGFsQ2FuY2VsQnRuLCNlZGl0TW9kYWwgLmZvcm0gLmJ0bnMgLmNhbmNlbFByb2plY3RCdG4sI3Byb2plY3RNb2RhbCAuZWRpdEZvcm0gLmJ0bnMgLmNhbmNlbEVkaXRCdG4sI3Byb2plY3RNb2RhbCAuZWRpdEZvcm0gLmJ0bnMgLmNyZWF0ZU1vZGFsQ2FuY2VsQnRuLCNwcm9qZWN0TW9kYWwgLmVkaXRGb3JtIC5idG5zIC5jYW5jZWxQcm9qZWN0QnRuLCNwcm9qZWN0TW9kYWwgLnByb2plY3RGb3JtIC5idG5zIC5jYW5jZWxFZGl0QnRuLCNwcm9qZWN0TW9kYWwgLnByb2plY3RGb3JtIC5idG5zIC5jcmVhdGVNb2RhbENhbmNlbEJ0biwjcHJvamVjdE1vZGFsIC5wcm9qZWN0Rm9ybSAuYnRucyAuY2FuY2VsUHJvamVjdEJ0biwjcHJvamVjdE1vZGFsIC5mb3JtIC5idG5zIC5jYW5jZWxFZGl0QnRuLCNwcm9qZWN0TW9kYWwgLmZvcm0gLmJ0bnMgLmNyZWF0ZU1vZGFsQ2FuY2VsQnRuLCNwcm9qZWN0TW9kYWwgLmZvcm0gLmJ0bnMgLmNhbmNlbFByb2plY3RCdG57YmFja2dyb3VuZC1jb2xvcjpyZWR9I21vZGFsPiosI2VkaXRNb2RhbD4qLCNwcm9qZWN0TW9kYWw+KnttYXJnaW46MCAwIC41cmVtIDB9I21vZGFsOjpiYWNrZHJvcCwjZWRpdE1vZGFsOjpiYWNrZHJvcCwjcHJvamVjdE1vZGFsOjpiYWNrZHJvcHtiYWNrZ3JvdW5kOnJnYmEoMCwwLDAsLjQpfSNwcm9qZWN0TW9kYWwgLnByb2plY3RGb3Jte2hlaWdodDoxMjBweDt3aWR0aDoyNTBweH0uZm9vdGVye2ZvbnQtc2l6ZToxcmVtO2ZvbnQtZmFtaWx5OlJvYm90byxPeHlnZW4sVWJ1bnR1LENhbnRhcmVsbCxcXFwiT3BlbiBTYW5zXFxcIixcXFwiSGVsdmV0aWNhIE5ldWVcXFwiLHNhbnMtc2VyaWY7cGFkZGluZzoxMHB4O2JhY2tncm91bmQtY29sb3I6IzgwZjBlNDt0ZXh0LWFsaWduOmNlbnRlcn0uZmEtY2lyY2xlLXBsdXMsLmZhLWdpdGh1YiwuZmEtbGlua2VkaW4sLnN2Z3t0cmFuc2l0aW9uLWR1cmF0aW9uOi43NXM7dHJhbnNmb3JtOnJvdGF0ZSg3MjBkZWcpIHNjYWxlKDEuNSk7Y3Vyc29yOnBvaW50ZXJ9XCIsIFwiXCIse1widmVyc2lvblwiOjMsXCJzb3VyY2VzXCI6W1wid2VicGFjazovLy4vc3JjL3N0eWxlLnNjc3NcIixcIndlYnBhY2s6Ly8uL3NyYy9zY3NzL19nbG9iYWxzLnNjc3NcIl0sXCJuYW1lc1wiOltdLFwibWFwcGluZ3NcIjpcIkFBUUEsRUFDSSxTQUFBLENBQ0EsUUFBQSxDQUNBLHFCQUFBLENBR0osS0FDSSxpQ0FBQSxDQUNBLFlBQUEsQ0FDQSxXQUFBLENBQ0EsWUFBQSxDQUNBLHFCQUFBLENBR0osUUFuQkksWUFBQSxDQUNBLHNCQUFBLENBQ0Esa0JBQUEsQ0FtQkEsMEJBQUEsQ0FDQSxrQ0N2QkssQ0R3QkwsVUN6QkcsQ0QwQkgsZ0JBQUEsQ0FDQSxlQUFBLENBQ0EsUUFBQSxDQUNBLFVBQUEsQ0FDQSxjQUNJLGVBQUEsQ0FDQSxXQUFBLENBSVIsU0FDSSxZQUFBLENBQ0EsNkJBQUEsQ0FDQSxZQUFBLENBQ0Esa0JBQ0ksZ0JBQUEsQ0FDQSxZQUFBLENBQ0Esa0NDekNFLENEMENGLHFCQUNJLGlCQUFBLENBQ0Esb0JBQUEsQ0FDQSwyQkFDSSxZQUFBLENBQ0Esb0JBQUEsQ0FDQSxVQy9DRCxDRGdEQyx3QkFBQSxDQUVKLHVEQUNJLGNBQUEsQ0FHUixnQ0FDSSx3QkNwREMsQ0RxREQsa0JBQUEsQ0FFSixtQ0FDSSxZQUFBLENBQ0EsWUFBQSxDQUNBLHFCQUFBLENBQ0EsUUFBQSxDQUNBLHNCQUFBLENBQ0Esa0JBQUEsQ0FDQSxhQUFBLENBQ0EsOENBQ0ksZ0JBQUEsQ0FDQSxXQUFBLENBQ0EscUJBQUEsQ0FDQSxZQUFBLENBQ0EsUUFBQSxDQUNBLHNCQUFBLENBQ0Esa0JBQUEsQ0FDQSxZQUFBLENBQ0EsZ0JBQUEsQ0FDQSwrQkFBQSxDQUNBLG9EQUNJLGNBQUEsQ0FLaEIsbUJBQ0ksWUFBQSxDQUNBLHFCQUFBLENBQ0EsMEJBQUEsQ0FDQSxrQkFBQSxDQUNBLFFBQUEsQ0FDQSxrQ0N4RkcsQ0R5RkgseUJBQ0ksZUFBQSxDQUNBLGVBQUEsQ0FDQSxnQkFBQSxDQUNBLGtCQUFBLENBQ0EsaUNBSUksZ0JBQUEsQ0FDQSx5Q0FBQSxDQUpBLHVDQUNJLGVBQUEsQ0FJSiwwQ0FDSSxnQkFBQSxDQUVKLDJDQUNJLGVBQUEsQ0FFSixvQ0FDSSxjQUFBLENBS0osNkNBQ0ksc0JBQUEsQ0FFSiwwQ0FDSSxxQkFBQSxDQUNBLGVBQUEsQ0FDQSx3QkFBQSxDQUVKLGdEQUNJLGdCQUFBLENBRUosZ0RBQ0ksWUFBQSxDQUNBLHdCQUFBLENBQ0Esa0JBQUEsQ0FDQSxRQUFBLENBQ0EsZ0JBQUEsQ0FLSixzQ0FDSSxxQkFBQSxDQUNBLGVBQUEsQ0FDQSx3QkFBQSxDQUVKLDRDQUNJLGdCQUFBLENBRUosNENBQ0ksWUFBQSxDQUNBLHdCQUFBLENBQ0Esa0JBQUEsQ0FDQSxRQUFBLENBQ0EsZ0JBQUEsQ0FPcEIsNkJBQ0ksY0FBQSxDQUVKLG1DQUNJLGNBQUEsQ0FFSixnRUFDSSxnQkFBQSxDQUdKLFdBQ0ksVUFBQSxDQUNBLDRCQUFBLENBSUosZ0NBRUksZ0JBQUEsQ0FDQSxlQUFBLENBQ0EsWUFBQSxDQUNBLFFBQUEsQ0FDQSxrQkFBQSxDQUNBLGlDQUFBLENBQ0EsdUJBQUEsQ0FFQSx5Q0FDSSxrQkFBQSxDQUNBLGlCQUFBLENBQ0EsZ0JBQUEsQ0FHSix1TEFFSSxZQUFBLENBQ0EscUJBQUEsQ0FDQSxzQkFBQSxDQUNBLGtCQUFBLENBQ0EsWUFBQSxDQUNBLFdBQUEsQ0FDQSxRQUFBLENBQ0EsZ0JBQUEsQ0FDQSxnQkFBQSxDQUVBLDQ5Q0FFSSxrQkFBQSxDQUNBLFdBQUEsQ0FDQSxrRkFBQSxDQUdKLDJ1QkFDSSxxQkFBQSxDQUdKLHdRQUNJLFlBQUEsQ0FDQSxjQUFBLENBQ0EsZUFBQSxDQUNBLGlCQUFBLENBQ0EscUJBQUEsQ0FDQSwyQkFBQSxDQUdKLDZPQUNJLGFBQUEsQ0FDQSxpQkFBQSxDQUdKLGdWQUNJLFdBQUEsQ0FHSiw2T0FwT0osWUFBQSxDQUNBLHNCQUFBLENBQ0Esa0JBQUEsQ0FvT1EsT0FBQSxDQUNBLDQyRUFJSSx3QkFBQSxDQUNBLGNBQUEsQ0FDQSxZQUFBLENBQ0EsZ3JGQUNJLGNBQUEsQ0FDQSxxQkFBQSxDQUdSLHNyQ0FDSSxvQkFBQSxDQUtaLHNDQUNBLGtCQUFBLENBRUEsOERBQ0EseUJBQUEsQ0FNQSwyQkFDSSxZQUFBLENBQ0EsV0FBQSxDQUlSLFFBQ0ksY0FBQSxDQUNBLGtGQUFBLENBQ0EsWUFBQSxDQUNBLHdCQUFBLENBQ0EsaUJBQUEsQ0FNSiw2Q0FJSSx3QkFBQSxDQUNBLG1DQUFBLENBQ0EsY0FBQVwiLFwic291cmNlc0NvbnRlbnRcIjpbXCJAaW1wb3J0ICcuL3Njc3MvZ2xvYmFscyc7XFxuXFxuQG1peGluIGNlbnRlciB7XFxuICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xcbn1cXG5cXG4qe1xcbiAgICBwYWRkaW5nOiAwO1xcbiAgICBtYXJnaW46IDA7XFxuICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxufVxcblxcbmJvZHl7XFxuICAgIGZvbnQtZmFtaWx5OiAnQ29taW5nIFNvb24nLCBjdXJzaXZlO1xcbiAgICBoZWlnaHQ6IDEwMHZoO1xcbiAgICB3aWR0aDogMTAwdnc7XFxuICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XFxufVxcblxcbiNoZWFkZXJ7XFxuICAgIEBpbmNsdWRlIGNlbnRlcjtcXG4gICAganVzdGlmeS1jb250ZW50OiBmbGV4LXN0YXJ0O1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAkSEVBREVSO1xcbiAgICBjb2xvcjogJEZPTlQ7XFxuICAgIGZvbnQtc2l6ZTogMS44cmVtO1xcbiAgICBmb250LXdlaWdodDogOTAwO1xcbiAgICBnYXA6IDFyZW07XFxuICAgIHdpZHRoOiAxMDAlO1xcbiAgICAubG9nb3tcXG4gICAgICAgIG1heC1oZWlnaHQ6IDRyZW07XFxuICAgICAgICBwYWRkaW5nOiA1cHg7XFxuICAgIH1cXG59XFxuXFxuI2NvbnRlbnR7XFxuICAgIGRpc3BsYXk6IGdyaWQ7XFxuICAgIGdyaWQtdGVtcGxhdGUtY29sdW1uczogMWZyIDZmcjtcXG4gICAgaGVpZ2h0OiAxMDB2aDtcXG4gICAgLnNpZGViYXJ7XFxuICAgICAgICBmb250LXNpemU6IDEuNXJlbTtcXG4gICAgICAgIHBhZGRpbmc6IDEwcHg7XFxuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAkU0lERUJBUjtcXG4gICAgICAgIHVse1xcbiAgICAgICAgICAgIHRleHQtYWxpZ246IGNlbnRlcjtcXG4gICAgICAgICAgICBsaXN0LXN0eWxlLXR5cGU6IG5vbmU7XFxuICAgICAgICAgICAgLmxpbmt7XFxuICAgICAgICAgICAgICAgIHBhZGRpbmc6IDEwcHg7XFxuICAgICAgICAgICAgICAgIHRleHQtZGVjb3JhdGlvbjogbm9uZTtcXG4gICAgICAgICAgICAgICAgY29sb3I6ICRTSURFQkFSX1RFWFQ7XFxuICAgICAgICAgICAgICAgIHRleHQtc2hhZG93OiAxcHggMXB4IHdoaXRlO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAudG9kYXksIC53ZWVre1xcbiAgICAgICAgICAgICAgICBjdXJzb3I6IHBvaW50ZXI7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgbGkucHJvamVjdHNMaXtcXG4gICAgICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAkTE9HTy1DT0xPUjtcXG4gICAgICAgICAgICBib3JkZXItcmFkaXVzOiAxNXB4O1xcbiAgICAgICAgfVxcbiAgICAgICAgbGkucHJvamVjdHNMaSB1bHtcXG4gICAgICAgICAgICBwYWRkaW5nOiAxMHB4O1xcbiAgICAgICAgICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgICAgICAgICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXG4gICAgICAgICAgICBnYXA6IDEwcHg7XFxuICAgICAgICAgICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxuICAgICAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gICAgICAgICAgICBtYXJnaW46IDAgYXV0bztcXG4gICAgICAgICAgICBsaS5wcm9qZWN0e1xcbiAgICAgICAgICAgICAgICBmb250LXNpemU6IDEuM3JlbTtcXG4gICAgICAgICAgICAgICAgd2lkdGg6IDIyMHB4O1xcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB3aGl0ZTtcXG4gICAgICAgICAgICAgICAgZGlzcGxheTogZmxleDtcXG4gICAgICAgICAgICAgICAgZ2FwOiAxMHB4O1xcbiAgICAgICAgICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXG4gICAgICAgICAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gICAgICAgICAgICAgICAgcGFkZGluZzogMTBweDtcXG4gICAgICAgICAgICAgICAgYm9yZGVyOiAxcHggc29saWQ7XFxuICAgICAgICAgICAgICAgIGZvbnQtZmFtaWx5OiAncm9jayBzYWx0JywgY3Vyc2l2ZTtcXG4gICAgICAgICAgICAgICAgJjpob3ZlcntcXG4gICAgICAgICAgICAgICAgICAgIGN1cnNvcjogcG9pbnRlcjtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgfVxcbiAgICAudG9kb0xpc3R7XFxuICAgICAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICAgICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXG4gICAgICAgIGp1c3RpZnktY29udGVudDogZmxleC1zdGFydDtcXG4gICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICAgICAgICBnYXA6IDEwcHg7XFxuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAkVE9ET0xJU1Q7XFxuICAgICAgICB0YWJsZXtcXG4gICAgICAgICAgICBtYXJnaW4tdG9wOiAxMHB4O1xcbiAgICAgICAgICAgIG1pbi13aWR0aDogY2xhbXAoMzIwcHgsIDgwMHB4LCAxMDAwcHgpO1xcbiAgICAgICAgICAgIG1heC13aWR0aDogY2xhbXAoNDAwcHgsIDEyMDBweCwgMTYwMHB4KTtcXG4gICAgICAgICAgICBib3JkZXItcmFkaXVzOiAyMHB4O1xcbiAgICAgICAgICAgIC50aXRsZXN7XFxuICAgICAgICAgICAgICAgICY6aG92ZXJ7XFxuICAgICAgICAgICAgICAgICAgICBib3gtc2hhZG93OiBub25lO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIGZvbnQtc2l6ZTogMS41cmVtO1xcbiAgICAgICAgICAgICAgICBmb250LWZhbWlseTogJ1RpbWVzIE5ldyBSb21hbicsIFRpbWVzLCBzZXJpZjtcXG4gICAgICAgICAgICAgICAgLmR1ZURhdGV7XFxuICAgICAgICAgICAgICAgICAgICB0ZXh0LWFsaWduOiByaWdodDtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAucHJvak5hbWV7XFxuICAgICAgICAgICAgICAgICAgICB0ZXh0LWFsaWduOiBsZWZ0O1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIHRoe1xcbiAgICAgICAgICAgICAgICAgICAgcGFkZGluZzogMTBweCAwO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIHRyLmNyZWF0ZWRSb3d7XFxuICAgICAgICAgICAgICAgICY6aG92ZXJ7XFxuICAgICAgICAgICAgICAgICAgICBib3gtc2hhZG93OiAwIDAgNXB4IDVweDtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICB0ZHtcXG4gICAgICAgICAgICAgICAgICAgIHZlcnRpY2FsLWFsaWduOiBtaWRkbGU7XFxuICAgICAgICAgICAgICAgICAgICBtYXgtd2lkdGg6IDYwMHB4O1xcbiAgICAgICAgICAgICAgICAgICAgcGFkZGluZzogMTBweCAwIDEwcHggMTBweDtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAuY29sdW1uMXtcXG4gICAgICAgICAgICAgICAgICAgIGZvbnQtc2l6ZTogMS41cmVtO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIC5jb2x1bW4ye1xcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheTogZmxleDtcXG4gICAgICAgICAgICAgICAgICAgIGp1c3RpZnktY29udGVudDogZmxleC1lbmQ7XFxuICAgICAgICAgICAgICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgICAgICAgICAgICAgICAgICAgZ2FwOiAxMHB4O1xcbiAgICAgICAgICAgICAgICAgICAgZm9udC1zaXplOiAxLjNyZW07XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgLnZpZXdPbmx5e1xcbiAgICAgICAgICAgICAgICB0ZHtcXG4gICAgICAgICAgICAgICAgICAgIHZlcnRpY2FsLWFsaWduOiBtaWRkbGU7XFxuICAgICAgICAgICAgICAgICAgICBtYXgtd2lkdGg6IDYwMHB4O1xcbiAgICAgICAgICAgICAgICAgICAgcGFkZGluZzogMTBweCAwIDEwcHggMTBweDtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAuY29sdW1uMXtcXG4gICAgICAgICAgICAgICAgICAgIGZvbnQtc2l6ZTogMS41cmVtO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIC5jb2x1bW4ye1xcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheTogZmxleDtcXG4gICAgICAgICAgICAgICAgICAgIGp1c3RpZnktY29udGVudDogZmxleC1lbmQ7XFxuICAgICAgICAgICAgICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgICAgICAgICAgICAgICAgICAgZ2FwOiAxMHB4O1xcbiAgICAgICAgICAgICAgICAgICAgZm9udC1zaXplOiAxLjVyZW07XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgIH1cXG59XFxuXFxuaSwgLmFkZFRvRG9CdG4sIC5hZGRQcm9qZWN0QnRue1xcbiAgICBjdXJzb3I6IHBvaW50ZXI7XFxufVxcbi5mYS1jYWxlbmRhci1kYXksIC5mYS1iYXJzLXByb2dyZXNze1xcbiAgICBjdXJzb3I6IGRlZmF1bHQ7XFxufVxcbi5mYS1iYXJzLXByb2dyZXNzLCAuZmEtY2FsZW5kYXIsIC5mYS1leGNsYW1hdGlvbiwgLmZhLWNhbGVuZGFyLWRheXtcXG4gICAgbWFyZ2luLWxlZnQ6IDEwcHg7XFxufVxcblxcbi5jb21wbGV0ZWR7XFxuICAgIG9wYWNpdHk6IDAuNTtcXG4gICAgdGV4dC1kZWNvcmF0aW9uOiBsaW5lLXRocm91Z2g7XFxufVxcblxcblxcbiNtb2RhbCwgI2VkaXRNb2RhbCwgI3Byb2plY3RNb2RhbHtcXG5cXG4gICAgbWFyZ2luOiBhdXRvIGF1dG87XFxuICAgIG1heC13aWR0aDogMTAwY2g7XFxuICAgIHBhZGRpbmc6IDEwcHg7XFxuICAgIGJvcmRlcjogMDtcXG4gICAgYm9yZGVyLXJhZGl1czogMTBweDtcXG4gICAgYm94LXNoYWRvdzogMCAwIDFlbSByZ2IoMCAwIDAgLyAuMyk7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHNhbG1vbjtcXG5cXG4gICAgaDJ7XFxuICAgICAgICBsZXR0ZXItc3BhY2luZzogNXB4O1xcbiAgICAgICAgdGV4dC1hbGlnbjogY2VudGVyO1xcbiAgICAgICAgZm9udC1zaXplOiAxLjJyZW07XFxuICAgIH1cXG5cXG4gICAgLmVkaXRGb3JtLCAucHJvamVjdEZvcm0sIC5mb3Jte1xcbiAgICAgICAgXFxuICAgICAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICAgICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXG4gICAgICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xcbiAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gICAgICAgIGhlaWdodDogNDAwcHg7XFxuICAgICAgICB3aWR0aDogMzUwcHg7XFxuICAgICAgICBnYXA6IDIwcHg7XFxuICAgICAgICBmb250LXNpemU6IDEuMnJlbTtcXG4gICAgICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xcblxcbiAgICAgICAgbGFiZWwsIHRleHRhcmVhLCBpbnB1dFt0eXBlPVxcXCJ0ZXh0XFxcIl0sXFxuICAgICAgICBpbnB1dFt0eXBlPVxcXCJkYXRldGltZS1sb2NhbFxcXCJdLCAuYnRuc3tcXG4gICAgICAgICAgICBsZXR0ZXItc3BhY2luZzogMXB4O1xcbiAgICAgICAgICAgIHdpZHRoOiAyMDBweDtcXG4gICAgICAgICAgICBmb250LWZhbWlseTogUm9ib3RvLCBPeHlnZW4sIFVidW50dSwgQ2FudGFyZWxsLCAnT3BlbiBTYW5zJywgJ0hlbHZldGljYSBOZXVlJywgc2Fucy1zZXJpZjtcXG4gICAgICAgIH1cXG4gICAgICAgIFxcbiAgICAgICAgaW5wdXQsIHRleHRhcmVhLCBzZWxlY3R7XFxuICAgICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogd2hpdGU7XFxuICAgICAgICB9XFxuICAgIFxcbiAgICAgICAgdGV4dGFyZWEge1xcbiAgICAgICAgICAgIHBhZGRpbmc6IDEwcHg7XFxuICAgICAgICAgICAgbWF4LXdpZHRoOiAxMDAlO1xcbiAgICAgICAgICAgIGxpbmUtaGVpZ2h0OiAxLjU7XFxuICAgICAgICAgICAgYm9yZGVyLXJhZGl1czogNXB4O1xcbiAgICAgICAgICAgIGJvcmRlcjogMXB4IHNvbGlkICNjY2M7XFxuICAgICAgICAgICAgYm94LXNoYWRvdzogMXB4IDFweCAxcHggIzk5OTtcXG4gICAgICAgIH1cXG4gICAgXFxuICAgICAgICBsYWJlbCB7XFxuICAgICAgICAgICAgZGlzcGxheTogYmxvY2s7XFxuICAgICAgICAgICAgbWFyZ2luLWJvdHRvbTogNXB4O1xcbiAgICAgICAgfVxcbiAgICBcXG4gICAgICAgIGlucHV0W3R5cGU9XFxcInRleHRcXFwiXXtcXG4gICAgICAgICAgICBwYWRkaW5nOiA1cHg7XFxuICAgICAgICB9XFxuICAgIFxcbiAgICAgICAgLmJ0bnN7XFxuICAgICAgICAgICAgQGluY2x1ZGUgY2VudGVyO1xcbiAgICAgICAgICAgIGdhcDogNXB4O1xcbiAgICAgICAgICAgIC5zdWJtaXRQcm9qZWN0QnRuLCAuY2FuY2VsUHJvamVjdEJ0biwgXFxuICAgICAgICAgICAgLmNyZWF0ZU1vZGFsU3VibWl0QnRuLCAuY3JlYXRlTW9kYWxDYW5jZWxCdG4sXFxuICAgICAgICAgICAgLmNhbmNlbEVkaXRCdG4sIC5zdWJtaXRFZGl0QnRuXFxuICAgICAgICAgICAge1xcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiBncmVlbnllbGxvdztcXG4gICAgICAgICAgICAgICAgbWF4LXdpZHRoOiA1MHB4O1xcbiAgICAgICAgICAgICAgICBwYWRkaW5nOiAxMHB4O1xcbiAgICAgICAgICAgICAgICAmOmhvdmVye1xcbiAgICAgICAgICAgICAgICAgICAgY3Vyc29yOiBwb2ludGVyO1xcbiAgICAgICAgICAgICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogd2hpdGU7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgLmNhbmNlbEVkaXRCdG4sIC5jcmVhdGVNb2RhbENhbmNlbEJ0biwgLmNhbmNlbFByb2plY3RCdG57XFxuICAgICAgICAgICAgICAgIGJhY2tncm91bmQtY29sb3I6IHJlZDtcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgIH1cXG5cXG4gICAgJiA+ICoge1xcbiAgICBtYXJnaW46IDAgMCAwLjVyZW0gMDtcXG4gICAgfVxcbiAgICAmOjpiYWNrZHJvcHtcXG4gICAgYmFja2dyb3VuZDogcmdiKDAgMCAwIC8gMC40KTtcXG4gICAgfVxcblxcbn1cXG5cXG4jcHJvamVjdE1vZGFse1xcbiAgICAucHJvamVjdEZvcm17XFxuICAgICAgICBoZWlnaHQ6IDEyMHB4O1xcbiAgICAgICAgd2lkdGg6IDI1MHB4O1xcbiAgICB9XFxufVxcblxcbi5mb290ZXJ7XFxuICAgIGZvbnQtc2l6ZTogMXJlbTtcXG4gICAgZm9udC1mYW1pbHk6IFJvYm90bywgT3h5Z2VuLCBVYnVudHUsIENhbnRhcmVsbCwgJ09wZW4gU2FucycsICdIZWx2ZXRpY2EgTmV1ZScsIHNhbnMtc2VyaWY7XFxuICAgIHBhZGRpbmc6IDEwcHg7XFxuICAgIGJhY2tncm91bmQtY29sb3I6ICM4MGYwZTQ7XFxuICAgIHRleHQtYWxpZ246IGNlbnRlcjtcXG59XFxuXFxuXFxuLy8gYW5pbWF0aW9uXFxuXFxuLmZhLWNpcmNsZS1wbHVzLCBcXG4uZmEtZ2l0aHViLCBcXG4uZmEtbGlua2VkaW4sXFxuLnN2Z3tcXG4gICAgdHJhbnNpdGlvbi1kdXJhdGlvbjogMC43NXM7XFxuICAgIHRyYW5zZm9ybTogcm90YXRlKDcyMGRlZykgc2NhbGUoMS41KTtcXG4gICAgY3Vyc29yOiBwb2ludGVyO1xcbn1cXG5cXG5cIixcIiRCT0RZOiAjM2YzZjNmO1xcbiRGT05UOiB3aGl0ZTtcXG4kSEVBREVSOiByZ2JhKDI1NSwgNzIsIDAsIC43KTtcXG4kU0lERUJBUjogcmdiYSgyNTUsIDcyLCAwLCAuMyk7XFxuJFNJREVCQVJfVEVYVDogYmxhY2s7XFxuJFRPRE9MSVNUOiByZ2JhKDI1NSwgNzIsIDAsIC4xKTtcXG4kVE9ET19JTkZPX0ZPUk06IHdoaXRlO1xcbiRMT0dPLUNPTE9SOiAjODBmMGU0O1wiXSxcInNvdXJjZVJvb3RcIjpcIlwifV0pO1xuLy8gRXhwb3J0c1xuZXhwb3J0IGRlZmF1bHQgX19fQ1NTX0xPQURFUl9FWFBPUlRfX187XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///192\n')},645:module=>{"use strict";eval('\n\n/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n*/\nmodule.exports = function (cssWithMappingToString) {\n  var list = []; // return the list of modules as css string\n\n  list.toString = function toString() {\n    return this.map(function (item) {\n      var content = "";\n      var needLayer = typeof item[5] !== "undefined";\n\n      if (item[4]) {\n        content += "@supports (".concat(item[4], ") {");\n      }\n\n      if (item[2]) {\n        content += "@media ".concat(item[2], " {");\n      }\n\n      if (needLayer) {\n        content += "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {");\n      }\n\n      content += cssWithMappingToString(item);\n\n      if (needLayer) {\n        content += "}";\n      }\n\n      if (item[2]) {\n        content += "}";\n      }\n\n      if (item[4]) {\n        content += "}";\n      }\n\n      return content;\n    }).join("");\n  }; // import a list of modules into the list\n\n\n  list.i = function i(modules, media, dedupe, supports, layer) {\n    if (typeof modules === "string") {\n      modules = [[null, modules, undefined]];\n    }\n\n    var alreadyImportedModules = {};\n\n    if (dedupe) {\n      for (var k = 0; k < this.length; k++) {\n        var id = this[k][0];\n\n        if (id != null) {\n          alreadyImportedModules[id] = true;\n        }\n      }\n    }\n\n    for (var _k = 0; _k < modules.length; _k++) {\n      var item = [].concat(modules[_k]);\n\n      if (dedupe && alreadyImportedModules[item[0]]) {\n        continue;\n      }\n\n      if (typeof layer !== "undefined") {\n        if (typeof item[5] === "undefined") {\n          item[5] = layer;\n        } else {\n          item[1] = "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {").concat(item[1], "}");\n          item[5] = layer;\n        }\n      }\n\n      if (media) {\n        if (!item[2]) {\n          item[2] = media;\n        } else {\n          item[1] = "@media ".concat(item[2], " {").concat(item[1], "}");\n          item[2] = media;\n        }\n      }\n\n      if (supports) {\n        if (!item[4]) {\n          item[4] = "".concat(supports);\n        } else {\n          item[1] = "@supports (".concat(item[4], ") {").concat(item[1], "}");\n          item[4] = supports;\n        }\n      }\n\n      list.push(item);\n    }\n  };\n\n  return list;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjQ1LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscURBQXFEO0FBQ3JEOztBQUVBO0FBQ0EsZ0RBQWdEO0FBQ2hEOztBQUVBO0FBQ0EscUZBQXFGO0FBQ3JGOztBQUVBOztBQUVBO0FBQ0EscUJBQXFCO0FBQ3JCOztBQUVBO0FBQ0EscUJBQXFCO0FBQ3JCOztBQUVBO0FBQ0EscUJBQXFCO0FBQ3JCOztBQUVBO0FBQ0EsS0FBSztBQUNMLEtBQUs7OztBQUdMO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0Esc0JBQXNCLGlCQUFpQjtBQUN2Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFCQUFxQixxQkFBcUI7QUFDMUM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixzRkFBc0YscUJBQXFCO0FBQzNHO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsaURBQWlELHFCQUFxQjtBQUN0RTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLHNEQUFzRCxxQkFBcUI7QUFDM0U7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdG9kby1saXN0Ly4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2FwaS5qcz8yNGZiIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG4vKlxuICBNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuICBBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4qL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoY3NzV2l0aE1hcHBpbmdUb1N0cmluZykge1xuICB2YXIgbGlzdCA9IFtdOyAvLyByZXR1cm4gdGhlIGxpc3Qgb2YgbW9kdWxlcyBhcyBjc3Mgc3RyaW5nXG5cbiAgbGlzdC50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgdmFyIGNvbnRlbnQgPSBcIlwiO1xuICAgICAgdmFyIG5lZWRMYXllciA9IHR5cGVvZiBpdGVtWzVdICE9PSBcInVuZGVmaW5lZFwiO1xuXG4gICAgICBpZiAoaXRlbVs0XSkge1xuICAgICAgICBjb250ZW50ICs9IFwiQHN1cHBvcnRzIChcIi5jb25jYXQoaXRlbVs0XSwgXCIpIHtcIik7XG4gICAgICB9XG5cbiAgICAgIGlmIChpdGVtWzJdKSB7XG4gICAgICAgIGNvbnRlbnQgKz0gXCJAbWVkaWEgXCIuY29uY2F0KGl0ZW1bMl0sIFwiIHtcIik7XG4gICAgICB9XG5cbiAgICAgIGlmIChuZWVkTGF5ZXIpIHtcbiAgICAgICAgY29udGVudCArPSBcIkBsYXllclwiLmNvbmNhdChpdGVtWzVdLmxlbmd0aCA+IDAgPyBcIiBcIi5jb25jYXQoaXRlbVs1XSkgOiBcIlwiLCBcIiB7XCIpO1xuICAgICAgfVxuXG4gICAgICBjb250ZW50ICs9IGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSk7XG5cbiAgICAgIGlmIChuZWVkTGF5ZXIpIHtcbiAgICAgICAgY29udGVudCArPSBcIn1cIjtcbiAgICAgIH1cblxuICAgICAgaWYgKGl0ZW1bMl0pIHtcbiAgICAgICAgY29udGVudCArPSBcIn1cIjtcbiAgICAgIH1cblxuICAgICAgaWYgKGl0ZW1bNF0pIHtcbiAgICAgICAgY29udGVudCArPSBcIn1cIjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgfSkuam9pbihcIlwiKTtcbiAgfTsgLy8gaW1wb3J0IGEgbGlzdCBvZiBtb2R1bGVzIGludG8gdGhlIGxpc3RcblxuXG4gIGxpc3QuaSA9IGZ1bmN0aW9uIGkobW9kdWxlcywgbWVkaWEsIGRlZHVwZSwgc3VwcG9ydHMsIGxheWVyKSB7XG4gICAgaWYgKHR5cGVvZiBtb2R1bGVzID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBtb2R1bGVzID0gW1tudWxsLCBtb2R1bGVzLCB1bmRlZmluZWRdXTtcbiAgICB9XG5cbiAgICB2YXIgYWxyZWFkeUltcG9ydGVkTW9kdWxlcyA9IHt9O1xuXG4gICAgaWYgKGRlZHVwZSkge1xuICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCB0aGlzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgIHZhciBpZCA9IHRoaXNba11bMF07XG5cbiAgICAgICAgaWYgKGlkICE9IG51bGwpIHtcbiAgICAgICAgICBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2lkXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKHZhciBfayA9IDA7IF9rIDwgbW9kdWxlcy5sZW5ndGg7IF9rKyspIHtcbiAgICAgIHZhciBpdGVtID0gW10uY29uY2F0KG1vZHVsZXNbX2tdKTtcblxuICAgICAgaWYgKGRlZHVwZSAmJiBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2l0ZW1bMF1dKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGxheWVyICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaXRlbVs1XSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgIGl0ZW1bNV0gPSBsYXllcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpdGVtWzFdID0gXCJAbGF5ZXJcIi5jb25jYXQoaXRlbVs1XS5sZW5ndGggPiAwID8gXCIgXCIuY29uY2F0KGl0ZW1bNV0pIDogXCJcIiwgXCIge1wiKS5jb25jYXQoaXRlbVsxXSwgXCJ9XCIpO1xuICAgICAgICAgIGl0ZW1bNV0gPSBsYXllcjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAobWVkaWEpIHtcbiAgICAgICAgaWYgKCFpdGVtWzJdKSB7XG4gICAgICAgICAgaXRlbVsyXSA9IG1lZGlhO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGl0ZW1bMV0gPSBcIkBtZWRpYSBcIi5jb25jYXQoaXRlbVsyXSwgXCIge1wiKS5jb25jYXQoaXRlbVsxXSwgXCJ9XCIpO1xuICAgICAgICAgIGl0ZW1bMl0gPSBtZWRpYTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoc3VwcG9ydHMpIHtcbiAgICAgICAgaWYgKCFpdGVtWzRdKSB7XG4gICAgICAgICAgaXRlbVs0XSA9IFwiXCIuY29uY2F0KHN1cHBvcnRzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpdGVtWzFdID0gXCJAc3VwcG9ydHMgKFwiLmNvbmNhdChpdGVtWzRdLCBcIikge1wiKS5jb25jYXQoaXRlbVsxXSwgXCJ9XCIpO1xuICAgICAgICAgIGl0ZW1bNF0gPSBzdXBwb3J0cztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBsaXN0LnB1c2goaXRlbSk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBsaXN0O1xufTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///645\n')},537:module=>{"use strict";eval('\n\nmodule.exports = function (item) {\n  var content = item[1];\n  var cssMapping = item[3];\n\n  if (!cssMapping) {\n    return content;\n  }\n\n  if (typeof btoa === "function") {\n    var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(cssMapping))));\n    var data = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(base64);\n    var sourceMapping = "/*# ".concat(data, " */");\n    var sourceURLs = cssMapping.sources.map(function (source) {\n      return "/*# sourceURL=".concat(cssMapping.sourceRoot || "").concat(source, " */");\n    });\n    return [content].concat(sourceURLs).concat([sourceMapping]).join("\\n");\n  }\n\n  return [content].join("\\n");\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTM3LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVEQUF1RCxjQUFjO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90b2RvLWxpc3QvLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvc291cmNlTWFwcy5qcz9hZjEyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gIHZhciBjb250ZW50ID0gaXRlbVsxXTtcbiAgdmFyIGNzc01hcHBpbmcgPSBpdGVtWzNdO1xuXG4gIGlmICghY3NzTWFwcGluZykge1xuICAgIHJldHVybiBjb250ZW50O1xuICB9XG5cbiAgaWYgKHR5cGVvZiBidG9hID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICB2YXIgYmFzZTY0ID0gYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoY3NzTWFwcGluZykpKSk7XG4gICAgdmFyIGRhdGEgPSBcInNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LFwiLmNvbmNhdChiYXNlNjQpO1xuICAgIHZhciBzb3VyY2VNYXBwaW5nID0gXCIvKiMgXCIuY29uY2F0KGRhdGEsIFwiICovXCIpO1xuICAgIHZhciBzb3VyY2VVUkxzID0gY3NzTWFwcGluZy5zb3VyY2VzLm1hcChmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgICByZXR1cm4gXCIvKiMgc291cmNlVVJMPVwiLmNvbmNhdChjc3NNYXBwaW5nLnNvdXJjZVJvb3QgfHwgXCJcIikuY29uY2F0KHNvdXJjZSwgXCIgKi9cIik7XG4gICAgfSk7XG4gICAgcmV0dXJuIFtjb250ZW50XS5jb25jYXQoc291cmNlVVJMcykuY29uY2F0KFtzb3VyY2VNYXBwaW5nXSkuam9pbihcIlxcblwiKTtcbiAgfVxuXG4gIHJldHVybiBbY29udGVudF0uam9pbihcIlxcblwiKTtcbn07Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///537\n')},499:function(module){eval('(function(e,t){ true?module.exports=t():0})(this,function(){"use strict";var e=Math.imul,t=Math.clz32;function i(e){"@babel/helpers - typeof";return i="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},i(e)}function _(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function n(e,t){for(var _,n=0;n<t.length;n++)_=t[n],_.enumerable=_.enumerable||!1,_.configurable=!0,"value"in _&&(_.writable=!0),Object.defineProperty(e,_.key,_)}function l(e,t,i){return t&&n(e.prototype,t),i&&n(e,i),Object.defineProperty(e,"prototype",{writable:!1}),e}function g(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function");e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),Object.defineProperty(e,"prototype",{writable:!1}),t&&u(e,t)}function a(e){return a=Object.setPrototypeOf?Object.getPrototypeOf:function(e){return e.__proto__||Object.getPrototypeOf(e)},a(e)}function u(e,t){return u=Object.setPrototypeOf||function(e,t){return e.__proto__=t,e},u(e,t)}function s(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],function(){})),!0}catch(t){return!1}}function r(){return r=s()?Reflect.construct:function(e,t,i){var _=[null];_.push.apply(_,t);var n=Function.bind.apply(e,_),l=new n;return i&&u(l,i.prototype),l},r.apply(null,arguments)}function d(e){return-1!==Function.toString.call(e).indexOf("[native code]")}function h(e){var t="function"==typeof Map?new Map:void 0;return h=function(e){function i(){return r(e,arguments,a(this).constructor)}if(null===e||!d(e))return e;if("function"!=typeof e)throw new TypeError("Super expression must either be null or a function");if("undefined"!=typeof t){if(t.has(e))return t.get(e);t.set(e,i)}return i.prototype=Object.create(e.prototype,{constructor:{value:i,enumerable:!1,writable:!0,configurable:!0}}),u(i,e)},h(e)}function b(e){if(void 0===e)throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called");return e}function m(e,t){if(t&&("object"==typeof t||"function"==typeof t))return t;if(void 0!==t)throw new TypeError("Derived constructors may only return object or undefined");return b(e)}function c(e){var t=s();return function(){var i,_=a(e);if(t){var n=a(this).constructor;i=Reflect.construct(_,arguments,n)}else i=_.apply(this,arguments);return m(this,i)}}function v(e,t){return y(e)||f(e,t)||D(e,t)||k()}function y(e){if(Array.isArray(e))return e}function f(e,t){var i=null==e?null:"undefined"!=typeof Symbol&&e[Symbol.iterator]||e["@@iterator"];if(null!=i){var _,n,l=[],g=!0,o=!1;try{for(i=i.call(e);!(g=(_=i.next()).done)&&(l.push(_.value),!(t&&l.length===t));g=!0);}catch(e){o=!0,n=e}finally{try{g||null==i["return"]||i["return"]()}finally{if(o)throw n}}return l}}function D(e,t){if(e){if("string"==typeof e)return p(e,t);var i=Object.prototype.toString.call(e).slice(8,-1);return"Object"===i&&e.constructor&&(i=e.constructor.name),"Map"===i||"Set"===i?Array.from(e):"Arguments"===i||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i)?p(e,t):void 0}}function p(e,t){(null==t||t>e.length)&&(t=e.length);for(var _=0,n=Array(t);_<t;_++)n[_]=e[_];return n}function k(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}function B(e,t){var _="undefined"!=typeof Symbol&&e[Symbol.iterator]||e["@@iterator"];if(!_){if(Array.isArray(e)||(_=D(e))||t&&e&&"number"==typeof e.length){_&&(e=_);var n=0,l=function(){};return{s:l,n:function(){return n>=e.length?{done:!0}:{done:!1,value:e[n++]}},e:function(t){throw t},f:l}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var g,a=!0,u=!1;return{s:function(){_=_.call(e)},n:function(){var e=_.next();return a=e.done,e},e:function(t){u=!0,g=t},f:function(){try{a||null==_.return||_.return()}finally{if(u)throw g}}}}var S=function(e){var t=Math.abs,n=Math.max,o=Math.floor;function a(e,t){var i;if(_(this,a),i=u.call(this,e),i.sign=t,Object.setPrototypeOf(b(i),a.prototype),e>a.__kMaxLength)throw new RangeError("Maximum BigInt size exceeded");return i}g(a,e);var u=c(a);return l(a,[{key:"toDebugString",value:function(){var e,t=["BigInt["],i=B(this);try{for(i.s();!(e=i.n()).done;){var _=e.value;t.push((_?(_>>>0).toString(16):_)+", ")}}catch(e){i.e(e)}finally{i.f()}return t.push("]"),t.join("")}},{key:"toString",value:function(){var e=0<arguments.length&&void 0!==arguments[0]?arguments[0]:10;if(2>e||36<e)throw new RangeError("toString() radix argument must be between 2 and 36");return 0===this.length?"0":0==(e&e-1)?a.__toStringBasePowerOfTwo(this,e):a.__toStringGeneric(this,e,!1)}},{key:"valueOf",value:function(){throw new Error("Convert JSBI instances to native numbers using `toNumber`.")}},{key:"__copy",value:function(){for(var e=new a(this.length,this.sign),t=0;t<this.length;t++)e[t]=this[t];return e}},{key:"__trim",value:function(){for(var e=this.length,t=this[e-1];0===t;)e--,t=this[e-1],this.pop();return 0===e&&(this.sign=!1),this}},{key:"__initializeDigits",value:function(){for(var e=0;e<this.length;e++)this[e]=0}},{key:"__clzmsd",value:function(){return a.__clz30(this.__digit(this.length-1))}},{key:"__inplaceMultiplyAdd",value:function(e,t,_){_>this.length&&(_=this.length);for(var n=32767&e,l=e>>>15,g=0,o=t,u=0;u<_;u++){var s=this.__digit(u),r=32767&s,d=s>>>15,h=a.__imul(r,n),b=a.__imul(r,l),m=a.__imul(d,n),c=a.__imul(d,l),v=o+h+g;g=v>>>30,v&=1073741823,v+=((32767&b)<<15)+((32767&m)<<15),g+=v>>>30,o=c+(b>>>15)+(m>>>15),this.__setDigit(u,1073741823&v)}if(0!==g||0!==o)throw new Error("implementation bug")}},{key:"__inplaceAdd",value:function(e,t,_){for(var n,l=0,g=0;g<_;g++)n=this.__halfDigit(t+g)+e.__halfDigit(g)+l,l=n>>>15,this.__setHalfDigit(t+g,32767&n);return l}},{key:"__inplaceSub",value:function(e,t,_){var n=0;if(1&t){t>>=1;for(var l=this.__digit(t),g=32767&l,o=0;o<_-1>>>1;o++){var a=e.__digit(o),u=(l>>>15)-(32767&a)-n;n=1&u>>>15,this.__setDigit(t+o,(32767&u)<<15|32767&g),l=this.__digit(t+o+1),g=(32767&l)-(a>>>15)-n,n=1&g>>>15}var s=e.__digit(o),r=(l>>>15)-(32767&s)-n;n=1&r>>>15,this.__setDigit(t+o,(32767&r)<<15|32767&g);if(t+o+1>=this.length)throw new RangeError("out of bounds");0==(1&_)&&(l=this.__digit(t+o+1),g=(32767&l)-(s>>>15)-n,n=1&g>>>15,this.__setDigit(t+e.length,1073709056&l|32767&g))}else{t>>=1;for(var d=0;d<e.length-1;d++){var h=this.__digit(t+d),b=e.__digit(d),m=(32767&h)-(32767&b)-n;n=1&m>>>15;var c=(h>>>15)-(b>>>15)-n;n=1&c>>>15,this.__setDigit(t+d,(32767&c)<<15|32767&m)}var v=this.__digit(t+d),y=e.__digit(d),f=(32767&v)-(32767&y)-n;n=1&f>>>15;var D=0;0==(1&_)&&(D=(v>>>15)-(y>>>15)-n,n=1&D>>>15),this.__setDigit(t+d,(32767&D)<<15|32767&f)}return n}},{key:"__inplaceRightShift",value:function(e){if(0!==e){for(var t,_=this.__digit(0)>>>e,n=this.length-1,l=0;l<n;l++)t=this.__digit(l+1),this.__setDigit(l,1073741823&t<<30-e|_),_=t>>>e;this.__setDigit(n,_)}}},{key:"__digit",value:function(e){return this[e]}},{key:"__unsignedDigit",value:function(e){return this[e]>>>0}},{key:"__setDigit",value:function(e,t){this[e]=0|t}},{key:"__setDigitGrow",value:function(e,t){this[e]=0|t}},{key:"__halfDigitLength",value:function(){var e=this.length;return 32767>=this.__unsignedDigit(e-1)?2*e-1:2*e}},{key:"__halfDigit",value:function(e){return 32767&this[e>>>1]>>>15*(1&e)}},{key:"__setHalfDigit",value:function(e,t){var i=e>>>1,_=this.__digit(i),n=1&e?32767&_|t<<15:1073709056&_|32767&t;this.__setDigit(i,n)}}],[{key:"BigInt",value:function(e){var t=Number.isFinite;if("number"==typeof e){if(0===e)return a.__zero();if(a.__isOneDigitInt(e))return 0>e?a.__oneDigit(-e,!0):a.__oneDigit(e,!1);if(!t(e)||o(e)!==e)throw new RangeError("The number "+e+" cannot be converted to BigInt because it is not an integer");return a.__fromDouble(e)}if("string"==typeof e){var _=a.__fromString(e);if(null===_)throw new SyntaxError("Cannot convert "+e+" to a BigInt");return _}if("boolean"==typeof e)return!0===e?a.__oneDigit(1,!1):a.__zero();if("object"===i(e)){if(e.constructor===a)return e;var n=a.__toPrimitive(e);return a.BigInt(n)}throw new TypeError("Cannot convert "+e+" to a BigInt")}},{key:"toNumber",value:function(e){var t=e.length;if(0===t)return 0;if(1===t){var i=e.__unsignedDigit(0);return e.sign?-i:i}var _=e.__digit(t-1),n=a.__clz30(_),l=30*t-n;if(1024<l)return e.sign?-Infinity:1/0;var g=l-1,o=_,u=t-1,s=n+3,r=32===s?0:o<<s;r>>>=12;var d=s-12,h=12<=s?0:o<<20+s,b=20+s;for(0<d&&0<u&&(u--,o=e.__digit(u),r|=o>>>30-d,h=o<<d+2,b=d+2);0<b&&0<u;)u--,o=e.__digit(u),h|=30<=b?o<<b-30:o>>>30-b,b-=30;var m=a.__decideRounding(e,b,u,o);if((1===m||0===m&&1==(1&h))&&(h=h+1>>>0,0===h&&(r++,0!=r>>>20&&(r=0,g++,1023<g))))return e.sign?-Infinity:1/0;var c=e.sign?-2147483648:0;return g=g+1023<<20,a.__kBitConversionInts[1]=c|g|r,a.__kBitConversionInts[0]=h,a.__kBitConversionDouble[0]}},{key:"unaryMinus",value:function(e){if(0===e.length)return e;var t=e.__copy();return t.sign=!e.sign,t}},{key:"bitwiseNot",value:function(e){return e.sign?a.__absoluteSubOne(e).__trim():a.__absoluteAddOne(e,!0)}},{key:"exponentiate",value:function(e,t){if(t.sign)throw new RangeError("Exponent must be positive");if(0===t.length)return a.__oneDigit(1,!1);if(0===e.length)return e;if(1===e.length&&1===e.__digit(0))return e.sign&&0==(1&t.__digit(0))?a.unaryMinus(e):e;if(1<t.length)throw new RangeError("BigInt too big");var i=t.__unsignedDigit(0);if(1===i)return e;if(i>=a.__kMaxLengthBits)throw new RangeError("BigInt too big");if(1===e.length&&2===e.__digit(0)){var _=1+(0|i/30),n=e.sign&&0!=(1&i),l=new a(_,n);l.__initializeDigits();var g=1<<i%30;return l.__setDigit(_-1,g),l}var o=null,u=e;for(0!=(1&i)&&(o=e),i>>=1;0!==i;i>>=1)u=a.multiply(u,u),0!=(1&i)&&(null===o?o=u:o=a.multiply(o,u));return o}},{key:"multiply",value:function(e,t){if(0===e.length)return e;if(0===t.length)return t;var _=e.length+t.length;30<=e.__clzmsd()+t.__clzmsd()&&_--;var n=new a(_,e.sign!==t.sign);n.__initializeDigits();for(var l=0;l<e.length;l++)a.__multiplyAccumulate(t,e.__digit(l),n,l);return n.__trim()}},{key:"divide",value:function(e,t){if(0===t.length)throw new RangeError("Division by zero");if(0>a.__absoluteCompare(e,t))return a.__zero();var i,_=e.sign!==t.sign,n=t.__unsignedDigit(0);if(1===t.length&&32767>=n){if(1===n)return _===e.sign?e:a.unaryMinus(e);i=a.__absoluteDivSmall(e,n,null)}else i=a.__absoluteDivLarge(e,t,!0,!1);return i.sign=_,i.__trim()}},{key:"remainder",value:function i(e,t){if(0===t.length)throw new RangeError("Division by zero");if(0>a.__absoluteCompare(e,t))return e;var _=t.__unsignedDigit(0);if(1===t.length&&32767>=_){if(1===_)return a.__zero();var n=a.__absoluteModSmall(e,_);return 0===n?a.__zero():a.__oneDigit(n,e.sign)}var i=a.__absoluteDivLarge(e,t,!1,!0);return i.sign=e.sign,i.__trim()}},{key:"add",value:function(e,t){var i=e.sign;return i===t.sign?a.__absoluteAdd(e,t,i):0<=a.__absoluteCompare(e,t)?a.__absoluteSub(e,t,i):a.__absoluteSub(t,e,!i)}},{key:"subtract",value:function(e,t){var i=e.sign;return i===t.sign?0<=a.__absoluteCompare(e,t)?a.__absoluteSub(e,t,i):a.__absoluteSub(t,e,!i):a.__absoluteAdd(e,t,i)}},{key:"leftShift",value:function(e,t){return 0===t.length||0===e.length?e:t.sign?a.__rightShiftByAbsolute(e,t):a.__leftShiftByAbsolute(e,t)}},{key:"signedRightShift",value:function(e,t){return 0===t.length||0===e.length?e:t.sign?a.__leftShiftByAbsolute(e,t):a.__rightShiftByAbsolute(e,t)}},{key:"unsignedRightShift",value:function(){throw new TypeError("BigInts have no unsigned right shift; use >> instead")}},{key:"lessThan",value:function(e,t){return 0>a.__compareToBigInt(e,t)}},{key:"lessThanOrEqual",value:function(e,t){return 0>=a.__compareToBigInt(e,t)}},{key:"greaterThan",value:function(e,t){return 0<a.__compareToBigInt(e,t)}},{key:"greaterThanOrEqual",value:function(e,t){return 0<=a.__compareToBigInt(e,t)}},{key:"equal",value:function(e,t){if(e.sign!==t.sign)return!1;if(e.length!==t.length)return!1;for(var _=0;_<e.length;_++)if(e.__digit(_)!==t.__digit(_))return!1;return!0}},{key:"notEqual",value:function(e,t){return!a.equal(e,t)}},{key:"bitwiseAnd",value:function(e,t){if(!e.sign&&!t.sign)return a.__absoluteAnd(e,t).__trim();if(e.sign&&t.sign){var i=n(e.length,t.length)+1,_=a.__absoluteSubOne(e,i),l=a.__absoluteSubOne(t);return _=a.__absoluteOr(_,l,_),a.__absoluteAddOne(_,!0,_).__trim()}if(e.sign){var g=[t,e];e=g[0],t=g[1]}return a.__absoluteAndNot(e,a.__absoluteSubOne(t)).__trim()}},{key:"bitwiseXor",value:function(e,t){if(!e.sign&&!t.sign)return a.__absoluteXor(e,t).__trim();if(e.sign&&t.sign){var i=n(e.length,t.length),_=a.__absoluteSubOne(e,i),l=a.__absoluteSubOne(t);return a.__absoluteXor(_,l,_).__trim()}var g=n(e.length,t.length)+1;if(e.sign){var o=[t,e];e=o[0],t=o[1]}var u=a.__absoluteSubOne(t,g);return u=a.__absoluteXor(u,e,u),a.__absoluteAddOne(u,!0,u).__trim()}},{key:"bitwiseOr",value:function(e,t){var i=n(e.length,t.length);if(!e.sign&&!t.sign)return a.__absoluteOr(e,t).__trim();if(e.sign&&t.sign){var _=a.__absoluteSubOne(e,i),l=a.__absoluteSubOne(t);return _=a.__absoluteAnd(_,l,_),a.__absoluteAddOne(_,!0,_).__trim()}if(e.sign){var g=[t,e];e=g[0],t=g[1]}var o=a.__absoluteSubOne(t,i);return o=a.__absoluteAndNot(o,e,o),a.__absoluteAddOne(o,!0,o).__trim()}},{key:"asIntN",value:function(e,t){if(0===t.length)return t;if(e=o(e),0>e)throw new RangeError("Invalid value: not (convertible to) a safe integer");if(0===e)return a.__zero();if(e>=a.__kMaxLengthBits)return t;var _=0|(e+29)/30;if(t.length<_)return t;var l=t.__unsignedDigit(_-1),g=1<<(e-1)%30;if(t.length===_&&l<g)return t;if(!((l&g)===g))return a.__truncateToNBits(e,t);if(!t.sign)return a.__truncateAndSubFromPowerOfTwo(e,t,!0);if(0==(l&g-1)){for(var u=_-2;0<=u;u--)if(0!==t.__digit(u))return a.__truncateAndSubFromPowerOfTwo(e,t,!1);return t.length===_&&l===g?t:a.__truncateToNBits(e,t)}return a.__truncateAndSubFromPowerOfTwo(e,t,!1)}},{key:"asUintN",value:function(e,t){if(0===t.length)return t;if(e=o(e),0>e)throw new RangeError("Invalid value: not (convertible to) a safe integer");if(0===e)return a.__zero();if(t.sign){if(e>a.__kMaxLengthBits)throw new RangeError("BigInt too big");return a.__truncateAndSubFromPowerOfTwo(e,t,!1)}if(e>=a.__kMaxLengthBits)return t;var i=0|(e+29)/30;if(t.length<i)return t;var _=e%30;if(t.length==i){if(0===_)return t;var l=t.__digit(i-1);if(0==l>>>_)return t}return a.__truncateToNBits(e,t)}},{key:"ADD",value:function(e,t){if(e=a.__toPrimitive(e),t=a.__toPrimitive(t),"string"==typeof e)return"string"!=typeof t&&(t=t.toString()),e+t;if("string"==typeof t)return e.toString()+t;if(e=a.__toNumeric(e),t=a.__toNumeric(t),a.__isBigInt(e)&&a.__isBigInt(t))return a.add(e,t);if("number"==typeof e&&"number"==typeof t)return e+t;throw new TypeError("Cannot mix BigInt and other types, use explicit conversions")}},{key:"LT",value:function(e,t){return a.__compare(e,t,0)}},{key:"LE",value:function(e,t){return a.__compare(e,t,1)}},{key:"GT",value:function(e,t){return a.__compare(e,t,2)}},{key:"GE",value:function(e,t){return a.__compare(e,t,3)}},{key:"EQ",value:function(e,t){for(;;){if(a.__isBigInt(e))return a.__isBigInt(t)?a.equal(e,t):a.EQ(t,e);if("number"==typeof e){if(a.__isBigInt(t))return a.__equalToNumber(t,e);if("object"!==i(t))return e==t;t=a.__toPrimitive(t)}else if("string"==typeof e){if(a.__isBigInt(t))return e=a.__fromString(e),null!==e&&a.equal(e,t);if("object"!==i(t))return e==t;t=a.__toPrimitive(t)}else if("boolean"==typeof e){if(a.__isBigInt(t))return a.__equalToNumber(t,+e);if("object"!==i(t))return e==t;t=a.__toPrimitive(t)}else if("symbol"===i(e)){if(a.__isBigInt(t))return!1;if("object"!==i(t))return e==t;t=a.__toPrimitive(t)}else if("object"===i(e)){if("object"===i(t)&&t.constructor!==a)return e==t;e=a.__toPrimitive(e)}else return e==t}}},{key:"NE",value:function(e,t){return!a.EQ(e,t)}},{key:"DataViewGetBigInt64",value:function(e,t){var i=!!(2<arguments.length&&void 0!==arguments[2])&&arguments[2];return a.asIntN(64,a.DataViewGetBigUint64(e,t,i))}},{key:"DataViewGetBigUint64",value:function(e,t){var i=!!(2<arguments.length&&void 0!==arguments[2])&&arguments[2],_=i?[4,0]:[0,4],n=v(_,2),g=n[0],o=n[1],l=e.getUint32(t+g,i),u=e.getUint32(t+o,i),s=new a(3,!1);return s.__setDigit(0,1073741823&u),s.__setDigit(1,(268435455&l)<<2|u>>>30),s.__setDigit(2,l>>>28),s.__trim()}},{key:"DataViewSetBigInt64",value:function(e,t,i){var _=!!(3<arguments.length&&void 0!==arguments[3])&&arguments[3];a.DataViewSetBigUint64(e,t,i,_)}},{key:"DataViewSetBigUint64",value:function(e,t,i){var _=!!(3<arguments.length&&void 0!==arguments[3])&&arguments[3];i=a.asUintN(64,i);var n=0,g=0;if(0<i.length&&(g=i.__digit(0),1<i.length)){var o=i.__digit(1);g|=o<<30,n=o>>>2,2<i.length&&(n|=i.__digit(2)<<28)}var u=_?[4,0]:[0,4],s=v(u,2),r=s[0],d=s[1];e.setUint32(t+r,n,_),e.setUint32(t+d,g,_)}},{key:"__zero",value:function(){return new a(0,!1)}},{key:"__oneDigit",value:function(e,t){var i=new a(1,t);return i.__setDigit(0,e),i}},{key:"__decideRounding",value:function(e,t,i,_){if(0<t)return-1;var n;if(0>t)n=-t-1;else{if(0===i)return-1;i--,_=e.__digit(i),n=29}var l=1<<n;if(0==(_&l))return-1;if(l-=1,0!=(_&l))return 1;for(;0<i;)if(i--,0!==e.__digit(i))return 1;return 0}},{key:"__fromDouble",value:function(e){a.__kBitConversionDouble[0]=e;var t,i=2047&a.__kBitConversionInts[1]>>>20,_=i-1023,n=(0|_/30)+1,l=new a(n,0>e),g=1048575&a.__kBitConversionInts[1]|1048576,o=a.__kBitConversionInts[0],u=20,s=_%30,r=0;if(s<u){var d=u-s;r=d+32,t=g>>>d,g=g<<32-d|o>>>d,o<<=32-d}else if(s===u)r=32,t=g,g=o,o=0;else{var h=s-u;r=32-h,t=g<<h|o>>>32-h,g=o<<h,o=0}l.__setDigit(n-1,t);for(var b=n-2;0<=b;b--)0<r?(r-=30,t=g>>>2,g=g<<30|o>>>2,o<<=30):t=0,l.__setDigit(b,t);return l.__trim()}},{key:"__isWhitespace",value:function(e){return!!(13>=e&&9<=e)||(159>=e?32==e:131071>=e?160==e||5760==e:196607>=e?(e&=131071,10>=e||40==e||41==e||47==e||95==e||4096==e):65279==e)}},{key:"__fromString",value:function(e){var t=1<arguments.length&&void 0!==arguments[1]?arguments[1]:0,i=0,_=e.length,n=0;if(n===_)return a.__zero();for(var l=e.charCodeAt(n);a.__isWhitespace(l);){if(++n===_)return a.__zero();l=e.charCodeAt(n)}if(43===l){if(++n===_)return null;l=e.charCodeAt(n),i=1}else if(45===l){if(++n===_)return null;l=e.charCodeAt(n),i=-1}if(0===t){if(t=10,48===l){if(++n===_)return a.__zero();if(l=e.charCodeAt(n),88===l||120===l){if(t=16,++n===_)return null;l=e.charCodeAt(n)}else if(79===l||111===l){if(t=8,++n===_)return null;l=e.charCodeAt(n)}else if(66===l||98===l){if(t=2,++n===_)return null;l=e.charCodeAt(n)}}}else if(16===t&&48===l){if(++n===_)return a.__zero();if(l=e.charCodeAt(n),88===l||120===l){if(++n===_)return null;l=e.charCodeAt(n)}}if(0!==i&&10!==t)return null;for(;48===l;){if(++n===_)return a.__zero();l=e.charCodeAt(n)}var g=_-n,o=a.__kMaxBitsPerChar[t],u=a.__kBitsPerCharTableMultiplier-1;if(g>1073741824/o)return null;var s=o*g+u>>>a.__kBitsPerCharTableShift,r=new a(0|(s+29)/30,!1),h=10>t?t:10,b=10<t?t-10:0;if(0==(t&t-1)){o>>=a.__kBitsPerCharTableShift;var c=[],v=[],y=!1;do{for(var f,D=0,p=0;;){if(f=void 0,l-48>>>0<h)f=l-48;else if((32|l)-97>>>0<b)f=(32|l)-87;else{y=!0;break}if(p+=o,D=D<<o|f,++n===_){y=!0;break}if(l=e.charCodeAt(n),30<p+o)break}c.push(D),v.push(p)}while(!y);a.__fillFromParts(r,c,v)}else{r.__initializeDigits();var k=!1,B=0;do{for(var S,C=0,I=1;;){if(S=void 0,l-48>>>0<h)S=l-48;else if((32|l)-97>>>0<b)S=(32|l)-87;else{k=!0;break}var A=I*t;if(1073741823<A)break;if(I=A,C=C*t+S,B++,++n===_){k=!0;break}l=e.charCodeAt(n)}u=30*a.__kBitsPerCharTableMultiplier-1;var m=0|(o*B+u>>>a.__kBitsPerCharTableShift)/30;r.__inplaceMultiplyAdd(I,C,m)}while(!k)}if(n!==_){if(!a.__isWhitespace(l))return null;for(n++;n<_;n++)if(l=e.charCodeAt(n),!a.__isWhitespace(l))return null}return r.sign=-1===i,r.__trim()}},{key:"__fillFromParts",value:function(e,t,_){for(var n=0,l=0,g=0,o=t.length-1;0<=o;o--){var a=t[o],u=_[o];l|=a<<g,g+=u,30===g?(e.__setDigit(n++,l),g=0,l=0):30<g&&(e.__setDigit(n++,1073741823&l),g-=30,l=a>>>u-g)}if(0!==l){if(n>=e.length)throw new Error("implementation bug");e.__setDigit(n++,l)}for(;n<e.length;n++)e.__setDigit(n,0)}},{key:"__toStringBasePowerOfTwo",value:function(e,t){var _=e.length,n=t-1;n=(85&n>>>1)+(85&n),n=(51&n>>>2)+(51&n),n=(15&n>>>4)+(15&n);var l=n,g=t-1,o=e.__digit(_-1),u=a.__clz30(o),s=0|(30*_-u+l-1)/l;if(e.sign&&s++,268435456<s)throw new Error("string too long");for(var r=Array(s),d=s-1,h=0,b=0,m=0;m<_-1;m++){var c=e.__digit(m),v=(h|c<<b)&g;r[d--]=a.__kConversionChars[v];var y=l-b;for(h=c>>>y,b=30-y;b>=l;)r[d--]=a.__kConversionChars[h&g],h>>>=l,b-=l}var f=(h|o<<b)&g;for(r[d--]=a.__kConversionChars[f],h=o>>>l-b;0!==h;)r[d--]=a.__kConversionChars[h&g],h>>>=l;if(e.sign&&(r[d--]="-"),-1!==d)throw new Error("implementation bug");return r.join("")}},{key:"__toStringGeneric",value:function(e,t,_){var n=e.length;if(0===n)return"";if(1===n){var l=e.__unsignedDigit(0).toString(t);return!1===_&&e.sign&&(l="-"+l),l}var g=30*n-a.__clz30(e.__digit(n-1)),o=a.__kMaxBitsPerChar[t],u=o-1,s=g*a.__kBitsPerCharTableMultiplier;s+=u-1,s=0|s/u;var r,d,h=s+1>>1,b=a.exponentiate(a.__oneDigit(t,!1),a.__oneDigit(h,!1)),m=b.__unsignedDigit(0);if(1===b.length&&32767>=m){r=new a(e.length,!1),r.__initializeDigits();for(var c,v=0,y=2*e.length-1;0<=y;y--)c=v<<15|e.__halfDigit(y),r.__setHalfDigit(y,0|c/m),v=0|c%m;d=v.toString(t)}else{var f=a.__absoluteDivLarge(e,b,!0,!0);r=f.quotient;var D=f.remainder.__trim();d=a.__toStringGeneric(D,t,!0)}r.__trim();for(var p=a.__toStringGeneric(r,t,!0);d.length<h;)d="0"+d;return!1===_&&e.sign&&(p="-"+p),p+d}},{key:"__unequalSign",value:function(e){return e?-1:1}},{key:"__absoluteGreater",value:function(e){return e?-1:1}},{key:"__absoluteLess",value:function(e){return e?1:-1}},{key:"__compareToBigInt",value:function(e,t){var i=e.sign;if(i!==t.sign)return a.__unequalSign(i);var _=a.__absoluteCompare(e,t);return 0<_?a.__absoluteGreater(i):0>_?a.__absoluteLess(i):0}},{key:"__compareToNumber",value:function(e,i){if(a.__isOneDigitInt(i)){var _=e.sign,n=0>i;if(_!==n)return a.__unequalSign(_);if(0===e.length){if(n)throw new Error("implementation bug");return 0===i?0:-1}if(1<e.length)return a.__absoluteGreater(_);var l=t(i),g=e.__unsignedDigit(0);return g>l?a.__absoluteGreater(_):g<l?a.__absoluteLess(_):0}return a.__compareToDouble(e,i)}},{key:"__compareToDouble",value:function(e,t){if(t!==t)return t;if(t===1/0)return-1;if(t===-Infinity)return 1;var i=e.sign;if(i!==0>t)return a.__unequalSign(i);if(0===t)throw new Error("implementation bug: should be handled elsewhere");if(0===e.length)return-1;a.__kBitConversionDouble[0]=t;var _=2047&a.__kBitConversionInts[1]>>>20;if(2047==_)throw new Error("implementation bug: handled elsewhere");var n=_-1023;if(0>n)return a.__absoluteGreater(i);var l=e.length,g=e.__digit(l-1),o=a.__clz30(g),u=30*l-o,s=n+1;if(u<s)return a.__absoluteLess(i);if(u>s)return a.__absoluteGreater(i);var r=1048576|1048575&a.__kBitConversionInts[1],d=a.__kBitConversionInts[0],h=20,b=29-o;if(b!==(0|(u-1)%30))throw new Error("implementation bug");var m,c=0;if(b<h){var v=h-b;c=v+32,m=r>>>v,r=r<<32-v|d>>>v,d<<=32-v}else if(b===h)c=32,m=r,r=d,d=0;else{var y=b-h;c=32-y,m=r<<y|d>>>32-y,r=d<<y,d=0}if(g>>>=0,m>>>=0,g>m)return a.__absoluteGreater(i);if(g<m)return a.__absoluteLess(i);for(var f=l-2;0<=f;f--){0<c?(c-=30,m=r>>>2,r=r<<30|d>>>2,d<<=30):m=0;var D=e.__unsignedDigit(f);if(D>m)return a.__absoluteGreater(i);if(D<m)return a.__absoluteLess(i)}if(0!==r||0!==d){if(0===c)throw new Error("implementation bug");return a.__absoluteLess(i)}return 0}},{key:"__equalToNumber",value:function(e,i){return a.__isOneDigitInt(i)?0===i?0===e.length:1===e.length&&e.sign===0>i&&e.__unsignedDigit(0)===t(i):0===a.__compareToDouble(e,i)}},{key:"__comparisonResultToBool",value:function(e,t){return 0===t?0>e:1===t?0>=e:2===t?0<e:3===t?0<=e:void 0}},{key:"__compare",value:function(e,t,i){if(e=a.__toPrimitive(e),t=a.__toPrimitive(t),"string"==typeof e&&"string"==typeof t)switch(i){case 0:return e<t;case 1:return e<=t;case 2:return e>t;case 3:return e>=t;}if(a.__isBigInt(e)&&"string"==typeof t)return t=a.__fromString(t),null!==t&&a.__comparisonResultToBool(a.__compareToBigInt(e,t),i);if("string"==typeof e&&a.__isBigInt(t))return e=a.__fromString(e),null!==e&&a.__comparisonResultToBool(a.__compareToBigInt(e,t),i);if(e=a.__toNumeric(e),t=a.__toNumeric(t),a.__isBigInt(e)){if(a.__isBigInt(t))return a.__comparisonResultToBool(a.__compareToBigInt(e,t),i);if("number"!=typeof t)throw new Error("implementation bug");return a.__comparisonResultToBool(a.__compareToNumber(e,t),i)}if("number"!=typeof e)throw new Error("implementation bug");if(a.__isBigInt(t))return a.__comparisonResultToBool(a.__compareToNumber(t,e),2^i);if("number"!=typeof t)throw new Error("implementation bug");return 0===i?e<t:1===i?e<=t:2===i?e>t:3===i?e>=t:void 0}},{key:"__absoluteAdd",value:function(e,t,_){if(e.length<t.length)return a.__absoluteAdd(t,e,_);if(0===e.length)return e;if(0===t.length)return e.sign===_?e:a.unaryMinus(e);var n=e.length;(0===e.__clzmsd()||t.length===e.length&&0===t.__clzmsd())&&n++;for(var l,g=new a(n,_),o=0,u=0;u<t.length;u++)l=e.__digit(u)+t.__digit(u)+o,o=l>>>30,g.__setDigit(u,1073741823&l);for(;u<e.length;u++){var s=e.__digit(u)+o;o=s>>>30,g.__setDigit(u,1073741823&s)}return u<g.length&&g.__setDigit(u,o),g.__trim()}},{key:"__absoluteSub",value:function(e,t,_){if(0===e.length)return e;if(0===t.length)return e.sign===_?e:a.unaryMinus(e);for(var n,l=new a(e.length,_),g=0,o=0;o<t.length;o++)n=e.__digit(o)-t.__digit(o)-g,g=1&n>>>30,l.__setDigit(o,1073741823&n);for(;o<e.length;o++){var u=e.__digit(o)-g;g=1&u>>>30,l.__setDigit(o,1073741823&u)}return l.__trim()}},{key:"__absoluteAddOne",value:function(e,t){var _=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null,n=e.length;null===_?_=new a(n,t):_.sign=t;for(var l,g=1,o=0;o<n;o++)l=e.__digit(o)+g,g=l>>>30,_.__setDigit(o,1073741823&l);return 0!==g&&_.__setDigitGrow(n,1),_}},{key:"__absoluteSubOne",value:function(e,t){var _=e.length;t=t||_;for(var n,l=new a(t,!1),g=1,o=0;o<_;o++)n=e.__digit(o)-g,g=1&n>>>30,l.__setDigit(o,1073741823&n);if(0!==g)throw new Error("implementation bug");for(var u=_;u<t;u++)l.__setDigit(u,0);return l}},{key:"__absoluteAnd",value:function(e,t){var _=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null,n=e.length,l=t.length,g=l;if(n<l){g=n;var o=e,u=n;e=t,n=l,t=o,l=u}var s=g;null===_?_=new a(s,!1):s=_.length;for(var r=0;r<g;r++)_.__setDigit(r,e.__digit(r)&t.__digit(r));for(;r<s;r++)_.__setDigit(r,0);return _}},{key:"__absoluteAndNot",value:function(e,t){var _=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null,n=e.length,l=t.length,g=l;n<l&&(g=n);var o=n;null===_?_=new a(o,!1):o=_.length;for(var u=0;u<g;u++)_.__setDigit(u,e.__digit(u)&~t.__digit(u));for(;u<n;u++)_.__setDigit(u,e.__digit(u));for(;u<o;u++)_.__setDigit(u,0);return _}},{key:"__absoluteOr",value:function(e,t){var _=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null,n=e.length,l=t.length,g=l;if(n<l){g=n;var o=e,u=n;e=t,n=l,t=o,l=u}var s=n;null===_?_=new a(s,!1):s=_.length;for(var r=0;r<g;r++)_.__setDigit(r,e.__digit(r)|t.__digit(r));for(;r<n;r++)_.__setDigit(r,e.__digit(r));for(;r<s;r++)_.__setDigit(r,0);return _}},{key:"__absoluteXor",value:function(e,t){var _=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null,n=e.length,l=t.length,g=l;if(n<l){g=n;var o=e,u=n;e=t,n=l,t=o,l=u}var s=n;null===_?_=new a(s,!1):s=_.length;for(var r=0;r<g;r++)_.__setDigit(r,e.__digit(r)^t.__digit(r));for(;r<n;r++)_.__setDigit(r,e.__digit(r));for(;r<s;r++)_.__setDigit(r,0);return _}},{key:"__absoluteCompare",value:function(e,t){var _=e.length-t.length;if(0!=_)return _;for(var n=e.length-1;0<=n&&e.__digit(n)===t.__digit(n);)n--;return 0>n?0:e.__unsignedDigit(n)>t.__unsignedDigit(n)?1:-1}},{key:"__multiplyAccumulate",value:function(e,t,_,n){if(0!==t){for(var l=32767&t,g=t>>>15,o=0,u=0,s=0;s<e.length;s++,n++){var r=_.__digit(n),d=e.__digit(s),h=32767&d,b=d>>>15,m=a.__imul(h,l),c=a.__imul(h,g),v=a.__imul(b,l),y=a.__imul(b,g);r+=u+m+o,o=r>>>30,r&=1073741823,r+=((32767&c)<<15)+((32767&v)<<15),o+=r>>>30,u=y+(c>>>15)+(v>>>15),_.__setDigit(n,1073741823&r)}for(;0!==o||0!==u;n++){var f=_.__digit(n);f+=o+u,u=0,o=f>>>30,_.__setDigit(n,1073741823&f)}}}},{key:"__internalMultiplyAdd",value:function(e,t,_,l,g){for(var o=_,u=0,s=0;s<l;s++){var d=e.__digit(s),h=a.__imul(32767&d,t),b=a.__imul(d>>>15,t),m=h+((32767&b)<<15)+u+o;o=m>>>30,u=b>>>15,g.__setDigit(s,1073741823&m)}if(g.length>l)for(g.__setDigit(l++,o+u);l<g.length;)g.__setDigit(l++,0);else if(0!==o+u)throw new Error("implementation bug")}},{key:"__absoluteDivSmall",value:function(e,t){var _=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;null===_&&(_=new a(e.length,!1));for(var n=0,l=2*e.length-1;0<=l;l-=2){var g=(n<<15|e.__halfDigit(l))>>>0,o=0|g/t;n=0|g%t,g=(n<<15|e.__halfDigit(l-1))>>>0;var u=0|g/t;n=0|g%t,_.__setDigit(l>>>1,o<<15|u)}return _}},{key:"__absoluteModSmall",value:function(e,t){for(var _,n=0,l=2*e.length-1;0<=l;l--)_=(n<<15|e.__halfDigit(l))>>>0,n=0|_%t;return n}},{key:"__absoluteDivLarge",value:function(e,t,i,_){var l=t.__halfDigitLength(),n=t.length,g=e.__halfDigitLength()-l,o=null;i&&(o=new a(g+2>>>1,!1),o.__initializeDigits());var s=new a(l+2>>>1,!1);s.__initializeDigits();var r=a.__clz15(t.__halfDigit(l-1));0<r&&(t=a.__specialLeftShift(t,r,0));for(var d=a.__specialLeftShift(e,r,1),u=t.__halfDigit(l-1),h=0,b=g;0<=b;b--){var m=32767,v=d.__halfDigit(b+l);if(v!==u){var y=(v<<15|d.__halfDigit(b+l-1))>>>0;m=0|y/u;for(var f=0|y%u,D=t.__halfDigit(l-2),p=d.__halfDigit(b+l-2);a.__imul(m,D)>>>0>(f<<16|p)>>>0&&(m--,f+=u,!(32767<f)););}a.__internalMultiplyAdd(t,m,0,n,s);var k=d.__inplaceSub(s,b,l+1);0!==k&&(k=d.__inplaceAdd(t,b,l),d.__setHalfDigit(b+l,32767&d.__halfDigit(b+l)+k),m--),i&&(1&b?h=m<<15:o.__setDigit(b>>>1,h|m))}if(_)return d.__inplaceRightShift(r),i?{quotient:o,remainder:d}:d;if(i)return o;throw new Error("unreachable")}},{key:"__clz15",value:function(e){return a.__clz30(e)-15}},{key:"__specialLeftShift",value:function(e,t,_){var l=e.length,n=new a(l+_,!1);if(0===t){for(var g=0;g<l;g++)n.__setDigit(g,e.__digit(g));return 0<_&&n.__setDigit(l,0),n}for(var o,u=0,s=0;s<l;s++)o=e.__digit(s),n.__setDigit(s,1073741823&o<<t|u),u=o>>>30-t;return 0<_&&n.__setDigit(l,u),n}},{key:"__leftShiftByAbsolute",value:function(e,t){var _=a.__toShiftAmount(t);if(0>_)throw new RangeError("BigInt too big");var n=0|_/30,l=_%30,g=e.length,o=0!==l&&0!=e.__digit(g-1)>>>30-l,u=g+n+(o?1:0),s=new a(u,e.sign);if(0===l){for(var r=0;r<n;r++)s.__setDigit(r,0);for(;r<u;r++)s.__setDigit(r,e.__digit(r-n))}else{for(var h=0,b=0;b<n;b++)s.__setDigit(b,0);for(var m,c=0;c<g;c++)m=e.__digit(c),s.__setDigit(c+n,1073741823&m<<l|h),h=m>>>30-l;if(o)s.__setDigit(g+n,h);else if(0!==h)throw new Error("implementation bug")}return s.__trim()}},{key:"__rightShiftByAbsolute",value:function(e,t){var _=e.length,n=e.sign,l=a.__toShiftAmount(t);if(0>l)return a.__rightShiftByMaximum(n);var g=0|l/30,o=l%30,u=_-g;if(0>=u)return a.__rightShiftByMaximum(n);var s=!1;if(n){if(0!=(e.__digit(g)&(1<<o)-1))s=!0;else for(var r=0;r<g;r++)if(0!==e.__digit(r)){s=!0;break}}if(s&&0===o){var h=e.__digit(_-1);0==~h&&u++}var b=new a(u,n);if(0===o){b.__setDigit(u-1,0);for(var m=g;m<_;m++)b.__setDigit(m-g,e.__digit(m))}else{for(var c,v=e.__digit(g)>>>o,y=_-g-1,f=0;f<y;f++)c=e.__digit(f+g+1),b.__setDigit(f,1073741823&c<<30-o|v),v=c>>>o;b.__setDigit(y,v)}return s&&(b=a.__absoluteAddOne(b,!0,b)),b.__trim()}},{key:"__rightShiftByMaximum",value:function(e){return e?a.__oneDigit(1,!0):a.__zero()}},{key:"__toShiftAmount",value:function(e){if(1<e.length)return-1;var t=e.__unsignedDigit(0);return t>a.__kMaxLengthBits?-1:t}},{key:"__toPrimitive",value:function(e){var t=1<arguments.length&&void 0!==arguments[1]?arguments[1]:"default";if("object"!==i(e))return e;if(e.constructor===a)return e;if("undefined"!=typeof Symbol&&"symbol"===i(Symbol.toPrimitive)){var _=e[Symbol.toPrimitive];if(_){var n=_(t);if("object"!==i(n))return n;throw new TypeError("Cannot convert object to primitive value")}}var l=e.valueOf;if(l){var g=l.call(e);if("object"!==i(g))return g}var o=e.toString;if(o){var u=o.call(e);if("object"!==i(u))return u}throw new TypeError("Cannot convert object to primitive value")}},{key:"__toNumeric",value:function(e){return a.__isBigInt(e)?e:+e}},{key:"__isBigInt",value:function(e){return"object"===i(e)&&null!==e&&e.constructor===a}},{key:"__truncateToNBits",value:function(e,t){for(var _=0|(e+29)/30,n=new a(_,t.sign),l=_-1,g=0;g<l;g++)n.__setDigit(g,t.__digit(g));var o=t.__digit(l);if(0!=e%30){var u=32-e%30;o=o<<u>>>u}return n.__setDigit(l,o),n.__trim()}},{key:"__truncateAndSubFromPowerOfTwo",value:function(e,t,_){for(var n=Math.min,l,g=0|(e+29)/30,o=new a(g,_),u=0,s=g-1,d=0,h=n(s,t.length);u<h;u++)l=0-t.__digit(u)-d,d=1&l>>>30,o.__setDigit(u,1073741823&l);for(;u<s;u++)o.__setDigit(u,0|1073741823&-d);var b,m=s<t.length?t.__digit(s):0,c=e%30;if(0===c)b=0-m-d,b&=1073741823;else{var v=32-c;m=m<<v>>>v;var y=1<<32-v;b=y-m-d,b&=y-1}return o.__setDigit(s,b),o.__trim()}},{key:"__digitPow",value:function(e,t){for(var i=1;0<t;)1&t&&(i*=e),t>>>=1,e*=e;return i}},{key:"__isOneDigitInt",value:function(e){return(1073741823&e)===e}}]),a}(h(Array));return S.__kMaxLength=33554432,S.__kMaxLengthBits=S.__kMaxLength<<5,S.__kMaxBitsPerChar=[0,0,32,51,64,75,83,90,96,102,107,111,115,119,122,126,128,131,134,136,139,141,143,145,147,149,151,153,154,156,158,159,160,162,163,165,166],S.__kBitsPerCharTableShift=5,S.__kBitsPerCharTableMultiplier=1<<S.__kBitsPerCharTableShift,S.__kConversionChars=["0","1","2","3","4","5","6","7","8","9","a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s","t","u","v","w","x","y","z"],S.__kBitConversionBuffer=new ArrayBuffer(8),S.__kBitConversionDouble=new Float64Array(S.__kBitConversionBuffer),S.__kBitConversionInts=new Int32Array(S.__kBitConversionBuffer),S.__clz30=t?function(e){return t(e)-2}:function(e){var t=Math.LN2,i=Math.log;return 0===e?30:0|29-(0|i(e>>>0)/t)},S.__imul=e||function(e,t){return 0|e*t},S});\n//# sourceMappingURL=jsbi-umd.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDk5LmpzIiwibWFwcGluZ3MiOiJBQUFBLGVBQWUsS0FBb0Qsb0JBQW9CLENBQXNFLENBQUMsa0JBQWtCLGFBQWEsNkJBQTZCLGNBQWMsMEJBQTBCLGlGQUFpRixnQkFBZ0IsYUFBYSxvR0FBb0csTUFBTSxnQkFBZ0IsOEVBQThFLGdCQUFnQixjQUFjLFdBQVcseUhBQXlILGtCQUFrQiwwRUFBMEUsWUFBWSxJQUFJLGdCQUFnQiw0R0FBNEcsMENBQTBDLGFBQWEscUNBQXFDLHVDQUF1QyxZQUFZLFlBQVksY0FBYyxpRUFBaUUsNkNBQTZDLE1BQU0sZ0JBQWdCLDhDQUE4Qyx1QkFBdUIsUUFBUSxhQUFhLDREQUE0RCxtQ0FBbUMscUNBQXFDLElBQUksK0VBQStFLE1BQU0sU0FBUyxVQUFVLGFBQWEsK0NBQStDLGFBQWEsa0JBQWtCLHVDQUF1Qyw2QkFBNkIseUJBQXlCLGNBQWMsOERBQThELGNBQWMsNENBQTRDLHFCQUFxQixhQUFhLDBDQUEwQyw0QkFBNEIsa0dBQWtHLDBCQUEwQiw0QkFBNEIsV0FBVyw4Q0FBOEMsYUFBYSxtREFBbUQsU0FBUyxNQUFNLGNBQWMsb0dBQW9HLFNBQVMsZ0JBQWdCLDBEQUEwRCw4RkFBOEYsWUFBWSxjQUFjLFVBQVUsa0JBQWtCLGFBQWEsTUFBTSwwQkFBMEIsbUNBQW1DLCtCQUErQixrQkFBa0IsZ0JBQWdCLGlDQUFpQyxjQUFjLDZCQUE2QixnQkFBZ0IsbUZBQW1GLFlBQVksdUJBQXVCLElBQUksZ0JBQWdCLDZEQUE2RCxPQUFPLFNBQVMsU0FBUyxRQUFRLElBQUksb0NBQW9DLFFBQVEsY0FBYyxVQUFVLGdCQUFnQixNQUFNLG9DQUFvQyxvREFBb0QsZ0xBQWdMLGdCQUFnQixvQ0FBb0MsdUJBQXVCLElBQUksY0FBYyxTQUFTLGFBQWEsaUtBQWlLLGdCQUFnQixzRUFBc0UsT0FBTyxnRUFBZ0UsU0FBUyx1QkFBdUIsT0FBTyxpQkFBaUIsb0JBQW9CLFFBQVEsRUFBRSxzQkFBc0IsZUFBZSxRQUFRLE1BQU0sNkpBQTZKLGdCQUFnQixPQUFPLGFBQWEsWUFBWSxjQUFjLGVBQWUsa0JBQWtCLGVBQWUsU0FBUyxjQUFjLElBQUksOEJBQThCLFFBQVEsZ0JBQWdCLGtCQUFrQix1Q0FBdUMsZ0JBQWdCLE1BQU0scUpBQXFKLFNBQVMsT0FBTyxXQUFXLGFBQWEscUNBQXFDLDhCQUE4QixJQUFJLFVBQVUsZ0JBQWdCLEVBQUUsY0FBYyx5Q0FBeUMsU0FBUyxPQUFPLFFBQVEsTUFBTSwrQkFBK0IsRUFBRSxnQ0FBZ0MsZ0VBQWdFLHdGQUF3Rix5R0FBeUcsRUFBRSwrQkFBK0IsK0VBQStFLEVBQUUsOEJBQThCLDJDQUEyQyxjQUFjLGlCQUFpQixVQUFVLEVBQUUsOEJBQThCLGtDQUFrQyxNQUFNLDRCQUE0QixtQ0FBbUMsRUFBRSwwQ0FBMEMsWUFBWSxjQUFjLGVBQWUsRUFBRSxnQ0FBZ0MsK0NBQStDLEVBQUUsaURBQWlELCtCQUErQix1Q0FBdUMsSUFBSSxLQUFLLGlIQUFpSCwwSEFBMEgsdURBQXVELEVBQUUseUNBQXlDLGtCQUFrQixJQUFJLHlGQUF5RixVQUFVLEVBQUUseUNBQXlDLFFBQVEsUUFBUSxNQUFNLHdDQUF3QyxVQUFVLEtBQUssMENBQTBDLDhHQUE4RywwQ0FBMEMsc0RBQXNELDREQUE0RCxxSEFBcUgsS0FBSyxNQUFNLFlBQVksYUFBYSxLQUFLLCtEQUErRCxXQUFXLDBCQUEwQixzREFBc0QsK0RBQStELFdBQVcsUUFBUSx3RkFBd0YsVUFBVSxFQUFFLDRDQUE0QyxVQUFVLG9EQUFvRCxJQUFJLHdFQUF3RSx1QkFBdUIsRUFBRSxnQ0FBZ0MsZ0JBQWdCLEVBQUUsd0NBQXdDLG9CQUFvQixFQUFFLHFDQUFxQyxhQUFhLEVBQUUseUNBQXlDLGFBQWEsRUFBRSx5Q0FBeUMsa0JBQWtCLG1EQUFtRCxFQUFFLG9DQUFvQyxxQ0FBcUMsRUFBRSx5Q0FBeUMsdUVBQXVFLHNCQUFzQixJQUFJLCtCQUErQixzQkFBc0IsdUJBQXVCLDJCQUEyQiwwRUFBMEUsdUhBQXVILHlCQUF5Qix1QkFBdUIsd0JBQXdCLHNFQUFzRSxTQUFTLGtFQUFrRSxvQkFBb0IsOEJBQThCLHlCQUF5QixtQkFBbUIseURBQXlELEVBQUUsaUNBQWlDLGVBQWUsa0JBQWtCLFVBQVUsMkJBQTJCLG1CQUFtQiw2Q0FBNkMsc0NBQXNDLDBDQUEwQyxRQUFRLG9DQUFvQyw4REFBOEQsU0FBUyxvREFBb0Qsa0NBQWtDLDhHQUE4RywyQkFBMkIsNkdBQTZHLEVBQUUsbUNBQW1DLHlCQUF5QixpQkFBaUIseUJBQXlCLEVBQUUsbUNBQW1DLHVFQUF1RSxFQUFFLHVDQUF1Qyw0REFBNEQsMENBQTBDLHlCQUF5Qix1RkFBdUYscURBQXFELDJCQUEyQixrQkFBa0IsZ0VBQWdFLG1DQUFtQyxpREFBaUQsdUJBQXVCLGNBQWMsNkJBQTZCLGVBQWUsMEJBQTBCLE1BQU0sbUVBQW1FLFVBQVUsRUFBRSxtQ0FBbUMseUJBQXlCLHlCQUF5Qix3QkFBd0IsbUNBQW1DLCtCQUErQix1QkFBdUIsWUFBWSxXQUFXLCtDQUErQyxtQkFBbUIsRUFBRSxpQ0FBaUMseURBQXlELGdEQUFnRCwrQ0FBK0MsMkJBQTJCLDZDQUE2QyxpQ0FBaUMsdUNBQXVDLDRCQUE0QixFQUFFLHNDQUFzQyx5REFBeUQsdUNBQXVDLDJCQUEyQiwyQkFBMkIsMkJBQTJCLGdDQUFnQywrQ0FBK0Msc0NBQXNDLGlDQUFpQyxFQUFFLDhCQUE4QixhQUFhLHFIQUFxSCxFQUFFLG1DQUFtQyxhQUFhLHFIQUFxSCxFQUFFLG9DQUFvQyx1R0FBdUcsRUFBRSwyQ0FBMkMsdUdBQXVHLEVBQUUsMENBQTBDLDJEQUEyRCxrQkFBa0IsRUFBRSxtQ0FBbUMsbUNBQW1DLEVBQUUsMENBQTBDLG9DQUFvQyxFQUFFLHNDQUFzQyxtQ0FBbUMsRUFBRSw2Q0FBNkMsb0NBQW9DLEVBQUUsZ0NBQWdDLDRCQUE0QixnQ0FBZ0MsWUFBWSxXQUFXLDRDQUE0QyxVQUFVLEVBQUUsbUNBQW1DLHFCQUFxQixFQUFFLHFDQUFxQyx5REFBeUQsbUJBQW1CLCtFQUErRSxtRUFBbUUsV0FBVyxZQUFZLGNBQWMsNkRBQTZELEVBQUUscUNBQXFDLHlEQUF5RCxtQkFBbUIsNkVBQTZFLHVDQUF1Qyw2QkFBNkIsV0FBVyxZQUFZLGNBQWMsOEJBQThCLHFFQUFxRSxFQUFFLG9DQUFvQywyQkFBMkIsd0RBQXdELG1CQUFtQixzREFBc0Qsb0VBQW9FLFdBQVcsWUFBWSxjQUFjLDhCQUE4Qix3RUFBd0UsRUFBRSxpQ0FBaUMseUJBQXlCLHlGQUF5RiwyQkFBMkIsa0NBQWtDLGtCQUFrQix1QkFBdUIsMkNBQTJDLDhCQUE4QixnREFBZ0QsMkRBQTJELGVBQWUsY0FBYyxLQUFLLHdFQUF3RSxzREFBc0QsaURBQWlELEVBQUUsa0NBQWtDLHlCQUF5Qix5RkFBeUYsMkJBQTJCLFdBQVcsK0RBQStELGdEQUFnRCxrQ0FBa0Msa0JBQWtCLHVCQUF1QixXQUFXLGdCQUFnQixrQkFBa0IscUJBQXFCLHFCQUFxQixpQ0FBaUMsRUFBRSw4QkFBOEIsK0dBQStHLDRDQUE0Qyw0RkFBNEYscURBQXFELG9GQUFvRixFQUFFLDZCQUE2QiwyQkFBMkIsRUFBRSw2QkFBNkIsMkJBQTJCLEVBQUUsNkJBQTZCLDJCQUEyQixFQUFFLDZCQUE2QiwyQkFBMkIsRUFBRSw2QkFBNkIsTUFBTSxFQUFFLGlFQUFpRSx1QkFBdUIsaURBQWlELCtCQUErQixxQkFBcUIsNEJBQTRCLHFFQUFxRSwrQkFBK0IscUJBQXFCLDZCQUE2QixrREFBa0QsK0JBQStCLHFCQUFxQix5QkFBeUIsNEJBQTRCLCtCQUErQixxQkFBcUIseUJBQXlCLGtEQUFrRCxxQkFBcUIsbUJBQW1CLEVBQUUsNkJBQTZCLGtCQUFrQixFQUFFLDhDQUE4QyxrRUFBa0UsbURBQW1ELEVBQUUsK0NBQStDLGlLQUFpSywrR0FBK0csRUFBRSxnREFBZ0Qsa0VBQWtFLGlDQUFpQyxFQUFFLGlEQUFpRCxrRUFBa0Usa0JBQWtCLFlBQVksNENBQTRDLG1CQUFtQixtREFBbUQsMkNBQTJDLDJDQUEyQyxFQUFFLDhCQUE4QixvQkFBb0IsRUFBRSxxQ0FBcUMsaUJBQWlCLDRCQUE0QixFQUFFLCtDQUErQyxnQkFBZ0IsTUFBTSxjQUFjLEtBQUssa0JBQWtCLHdCQUF3QixXQUFXLHFCQUFxQiwwQkFBMEIsS0FBSyxJQUFJLGtDQUFrQyxVQUFVLEVBQUUscUNBQXFDLDhCQUE4Qix5S0FBeUssUUFBUSxVQUFVLHdDQUF3QywrQkFBK0IsS0FBSyxVQUFVLGtDQUFrQyxvQkFBb0IsY0FBYyxLQUFLLG1FQUFtRSxtQkFBbUIsRUFBRSx1Q0FBdUMsMklBQTJJLEVBQUUscUNBQXFDLGtGQUFrRiwyQkFBMkIsMEJBQTBCLG9CQUFvQixFQUFFLDZCQUE2QixrQkFBa0IsV0FBVyx1QkFBdUIsc0JBQXNCLGdCQUFnQix1QkFBdUIsdUJBQXVCLFVBQVUsZ0JBQWdCLDZCQUE2QixzQ0FBc0MsNEJBQTRCLGtCQUFrQix5QkFBeUIsMkJBQTJCLGtCQUFrQix3QkFBd0IsMkJBQTJCLG9CQUFvQix3QkFBd0IsNkJBQTZCLHNDQUFzQyx1QkFBdUIsbUJBQW1CLDZCQUE2QixLQUFLLE9BQU8sRUFBRSw2QkFBNkIsa0JBQWtCLHVFQUF1RSw4QkFBOEIsMkZBQTJGLGVBQWUsK0JBQStCLG1CQUFtQixHQUFHLG1CQUFtQixFQUFFLDhCQUE4QixvQ0FBb0MsS0FBSyxLQUFLLE1BQU0sMEJBQTBCLEtBQUssTUFBTSxrQ0FBa0Msb0JBQW9CLFVBQVUseUJBQXlCLEtBQUssdUJBQXVCLGFBQWEsR0FBRyxtQkFBbUIsRUFBRSw4QkFBOEIsb0NBQW9DLEtBQUssS0FBSyxNQUFNLFVBQVUsc0JBQXNCLDRCQUE0QixLQUFLLE1BQU0sa0JBQWtCLHVDQUF1QyxnREFBZ0QsOEJBQThCLFVBQVUsVUFBVSxvQ0FBb0MsUUFBUSxJQUFJLDBEQUEwRCxpQ0FBaUMsRUFBRSw0Q0FBNEMsaUNBQWlDLEtBQUssS0FBSyxrQkFBa0IseUdBQXlHLFVBQVUscURBQXFELG9CQUFvQixLQUFLLFdBQVcsdUJBQXVCLEVBQUUsbURBQW1ELHFCQUFxQiw0REFBNEQsaUVBQWlFLDhEQUE4RCxxQ0FBcUMsTUFBTSxLQUFLLGdDQUFnQywrQkFBK0IsVUFBVSxtQkFBbUIsS0FBSyw4Q0FBOEMsaUJBQWlCLDZDQUE2QyxNQUFNLHlDQUF5QyxxRUFBcUUsbUJBQW1CLEVBQUUsOENBQThDLGVBQWUsa0JBQWtCLFVBQVUsdUNBQXVDLGtDQUFrQyx3R0FBd0csZUFBZSxnR0FBZ0csMkJBQTJCLDRDQUE0Qyw2QkFBNkIsS0FBSywrREFBK0QsZ0JBQWdCLEtBQUssc0NBQXNDLGFBQWEsMkJBQTJCLDhCQUE4QixXQUFXLHNDQUFzQyxXQUFXLFNBQVMscUNBQXFDLEVBQUUsc0NBQXNDLGVBQWUsRUFBRSwwQ0FBMEMsZUFBZSxFQUFFLHVDQUF1QyxlQUFlLEVBQUUsNENBQTRDLGFBQWEsd0NBQXdDLCtCQUErQiw2REFBNkQsRUFBRSw0Q0FBNEMseUJBQXlCLG1CQUFtQixtQ0FBbUMsaUJBQWlCLDJDQUEyQyxrQkFBa0IsNENBQTRDLGtDQUFrQyw0REFBNEQsaUNBQWlDLEVBQUUsNENBQTRDLGtCQUFrQixvQkFBb0IsMEJBQTBCLGFBQWEscUNBQXFDLDRFQUE0RSx5QkFBeUIsOEJBQThCLDBDQUEwQyxvRUFBb0UsYUFBYSxxQ0FBcUMsOERBQThELGtDQUFrQyxxQ0FBcUMsd0ZBQXdGLDBEQUEwRCxVQUFVLFFBQVEsVUFBVSx3Q0FBd0MsK0JBQStCLEtBQUssVUFBVSxrQ0FBa0MsbURBQW1ELGtDQUFrQyxjQUFjLEtBQUssS0FBSyw2Q0FBNkMsMkJBQTJCLHFDQUFxQyxrQ0FBa0MsaUJBQWlCLCtDQUErQywyQkFBMkIsVUFBVSxFQUFFLDBDQUEwQyxxSUFBcUksRUFBRSxtREFBbUQseURBQXlELEVBQUUsc0NBQXNDLDhGQUE4RixrQkFBa0IsbUJBQW1CLGtCQUFrQixvQkFBb0IsbUlBQW1JLG1JQUFtSSwwREFBMEQsaUZBQWlGLDREQUE0RCw4REFBOEQsNERBQTRELG1GQUFtRiw0REFBNEQseURBQXlELEVBQUUsMENBQTBDLG1EQUFtRCx5QkFBeUIsb0RBQW9ELGVBQWUsK0RBQStELCtCQUErQixXQUFXLHdFQUF3RSxLQUFLLFdBQVcsS0FBSyxxQkFBcUIsc0NBQXNDLGlEQUFpRCxFQUFFLDBDQUEwQyx5QkFBeUIsb0RBQW9ELHNDQUFzQyxXQUFXLDBFQUEwRSxLQUFLLFdBQVcsS0FBSyxxQkFBcUIsd0NBQXdDLG1CQUFtQixFQUFFLDJDQUEyQyw2RUFBNkUsK0JBQStCLGtCQUFrQixJQUFJLDJEQUEyRCx1Q0FBdUMsRUFBRSwyQ0FBMkMsZUFBZSxPQUFPLGdDQUFnQyxJQUFJLDZEQUE2RCwrQ0FBK0MsWUFBWSxJQUFJLHNCQUFzQixVQUFVLEVBQUUsd0NBQXdDLDRGQUE0RixRQUFRLElBQUksWUFBWSxnQkFBZ0IsUUFBUSxrQ0FBa0MsWUFBWSxJQUFJLDhDQUE4QyxLQUFLLElBQUksc0JBQXNCLFVBQVUsRUFBRSwyQ0FBMkMsNEZBQTRGLFdBQVcsUUFBUSxrQ0FBa0MsWUFBWSxJQUFJLCtDQUErQyxLQUFLLElBQUksaUNBQWlDLEtBQUssSUFBSSxzQkFBc0IsVUFBVSxFQUFFLHVDQUF1Qyw0RkFBNEYsUUFBUSxJQUFJLFlBQVksZ0JBQWdCLFFBQVEsa0NBQWtDLFlBQVksSUFBSSw4Q0FBOEMsS0FBSyxJQUFJLGlDQUFpQyxLQUFLLElBQUksc0JBQXNCLFVBQVUsRUFBRSx3Q0FBd0MsNEZBQTRGLFFBQVEsSUFBSSxZQUFZLGdCQUFnQixRQUFRLGtDQUFrQyxZQUFZLElBQUksOENBQThDLEtBQUssSUFBSSxpQ0FBaUMsS0FBSyxJQUFJLHNCQUFzQixVQUFVLEVBQUUsNENBQTRDLHdCQUF3QixpQkFBaUIscUJBQXFCLGtDQUFrQyxLQUFLLDZEQUE2RCxFQUFFLG1EQUFtRCxVQUFVLHVDQUF1QyxXQUFXLFNBQVMscUhBQXFILGdJQUFnSSxLQUFLLGFBQWEsS0FBSyxtQkFBbUIsb0RBQW9ELEVBQUUsc0RBQXNELG9CQUFvQixJQUFJLEtBQUssc0ZBQXNGLCtDQUErQyx3Q0FBd0MsV0FBVyxxQkFBcUIsdURBQXVELEVBQUUsNkNBQTZDLGtFQUFrRSxpQ0FBaUMsMkJBQTJCLEtBQUssTUFBTSwyQ0FBMkMseUNBQXlDLFlBQVksb0NBQW9DLFVBQVUsRUFBRSw2Q0FBNkMsNkJBQTZCLEtBQUssMkNBQTJDLFVBQVUsRUFBRSxpREFBaUQsd0VBQXdFLGdEQUFnRCx3QkFBd0IsdUJBQXVCLG9DQUFvQyxxQ0FBcUMsbUVBQW1FLEtBQUssS0FBSyxpQ0FBaUMsVUFBVSx1Q0FBdUMsUUFBUSw0REFBNEQsdURBQXVELEdBQUcsbUNBQW1DLDhCQUE4QiwrSEFBK0gsd0NBQXdDLHVCQUF1QixHQUFHLGNBQWMsZ0NBQWdDLEVBQUUsZ0NBQWdDLHdCQUF3QixFQUFFLCtDQUErQywrQkFBK0IsVUFBVSxZQUFZLElBQUksaUNBQWlDLGdDQUFnQyxrQkFBa0IsSUFBSSxnRUFBZ0UsaUNBQWlDLEVBQUUsZ0RBQWdELDJCQUEyQiw4Q0FBOEMsaUdBQWlHLFVBQVUsWUFBWSxJQUFJLHNCQUFzQixLQUFLLElBQUksbUNBQW1DLEtBQUssZ0JBQWdCLElBQUksc0JBQXNCLGNBQWMsSUFBSSxrRUFBa0UseUJBQXlCLG9EQUFvRCxtQkFBbUIsRUFBRSxpREFBaUQsK0NBQStDLHlDQUF5QywwQkFBMEIsMENBQTBDLFNBQVMsTUFBTSxtQ0FBbUMsaUJBQWlCLElBQUkseUJBQXlCLEtBQUssT0FBTyxhQUFhLHFCQUFxQixXQUFXLGlCQUFpQixVQUFVLG9CQUFvQixZQUFZLElBQUksbUNBQW1DLEtBQUsseUNBQXlDLElBQUksb0VBQW9FLGtCQUFrQixxREFBcUQsRUFBRSw4Q0FBOEMsd0NBQXdDLEVBQUUsd0NBQXdDLHVCQUF1QiwyQkFBMkIsa0NBQWtDLEVBQUUsc0NBQXNDLHVFQUF1RSw0QkFBNEIsOEJBQThCLGlFQUFpRSw0QkFBNEIsTUFBTSxXQUFXLDRCQUE0QixpRUFBaUUsZ0JBQWdCLE1BQU0sZ0JBQWdCLDRCQUE0QixpQkFBaUIsTUFBTSxnQkFBZ0IsNEJBQTRCLGlFQUFpRSxFQUFFLG9DQUFvQyw2QkFBNkIsRUFBRSxtQ0FBbUMsb0RBQW9ELEVBQUUsNENBQTRDLGtEQUFrRCxJQUFJLGlDQUFpQyxtQkFBbUIsWUFBWSxjQUFjLFdBQVcscUNBQXFDLEVBQUUsMkRBQTJELDhFQUE4RSxJQUFJLCtEQUErRCxLQUFLLElBQUksb0NBQW9DLHlDQUF5QywrQkFBK0IsS0FBSyxXQUFXLFdBQVcsY0FBYyxlQUFlLHFDQUFxQyxFQUFFLHFDQUFxQyxZQUFZLElBQUkseUJBQXlCLFVBQVUsRUFBRSx3Q0FBd0MsMEJBQTBCLEtBQUssV0FBVyw2cUJBQTZxQixjQUFjLGFBQWEsMEJBQTBCLG9DQUFvQywyQkFBMkIsYUFBYSxHQUFHO0FBQzdpakMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90b2RvLWxpc3QvLi9ub2RlX21vZHVsZXMvanNiaS9kaXN0L2pzYmktdW1kLmpzP2Y1NTciXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKGUsdCl7XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHMmJlwidW5kZWZpbmVkXCIhPXR5cGVvZiBtb2R1bGU/bW9kdWxlLmV4cG9ydHM9dCgpOlwiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUodCk6KGU9ZXx8c2VsZixlLkpTQkk9dCgpKX0pKHRoaXMsZnVuY3Rpb24oKXtcInVzZSBzdHJpY3RcIjt2YXIgZT1NYXRoLmltdWwsdD1NYXRoLmNsejMyO2Z1bmN0aW9uIGkoZSl7XCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiO3JldHVybiBpPVwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmXCJzeW1ib2xcIj09dHlwZW9mIFN5bWJvbC5pdGVyYXRvcj9mdW5jdGlvbihlKXtyZXR1cm4gdHlwZW9mIGV9OmZ1bmN0aW9uKGUpe3JldHVybiBlJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJmUuY29uc3RydWN0b3I9PT1TeW1ib2wmJmUhPT1TeW1ib2wucHJvdG90eXBlP1wic3ltYm9sXCI6dHlwZW9mIGV9LGkoZSl9ZnVuY3Rpb24gXyhlLHQpe2lmKCEoZSBpbnN0YW5jZW9mIHQpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIil9ZnVuY3Rpb24gbihlLHQpe2Zvcih2YXIgXyxuPTA7bjx0Lmxlbmd0aDtuKyspXz10W25dLF8uZW51bWVyYWJsZT1fLmVudW1lcmFibGV8fCExLF8uY29uZmlndXJhYmxlPSEwLFwidmFsdWVcImluIF8mJihfLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxfLmtleSxfKX1mdW5jdGlvbiBsKGUsdCxpKXtyZXR1cm4gdCYmbihlLnByb3RvdHlwZSx0KSxpJiZuKGUsaSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJwcm90b3R5cGVcIix7d3JpdGFibGU6ITF9KSxlfWZ1bmN0aW9uIGcoZSx0KXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiB0JiZudWxsIT09dCl0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7ZS5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZSh0JiZ0LnByb3RvdHlwZSx7Y29uc3RydWN0b3I6e3ZhbHVlOmUsd3JpdGFibGU6ITAsY29uZmlndXJhYmxlOiEwfX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwicHJvdG90eXBlXCIse3dyaXRhYmxlOiExfSksdCYmdShlLHQpfWZ1bmN0aW9uIGEoZSl7cmV0dXJuIGE9T2JqZWN0LnNldFByb3RvdHlwZU9mP09iamVjdC5nZXRQcm90b3R5cGVPZjpmdW5jdGlvbihlKXtyZXR1cm4gZS5fX3Byb3RvX198fE9iamVjdC5nZXRQcm90b3R5cGVPZihlKX0sYShlKX1mdW5jdGlvbiB1KGUsdCl7cmV0dXJuIHU9T2JqZWN0LnNldFByb3RvdHlwZU9mfHxmdW5jdGlvbihlLHQpe3JldHVybiBlLl9fcHJvdG9fXz10LGV9LHUoZSx0KX1mdW5jdGlvbiBzKCl7aWYoXCJ1bmRlZmluZWRcIj09dHlwZW9mIFJlZmxlY3R8fCFSZWZsZWN0LmNvbnN0cnVjdClyZXR1cm4hMTtpZihSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKXJldHVybiExO2lmKFwiZnVuY3Rpb25cIj09dHlwZW9mIFByb3h5KXJldHVybiEwO3RyeXtyZXR1cm4gQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sW10sZnVuY3Rpb24oKXt9KSksITB9Y2F0Y2godCl7cmV0dXJuITF9fWZ1bmN0aW9uIHIoKXtyZXR1cm4gcj1zKCk/UmVmbGVjdC5jb25zdHJ1Y3Q6ZnVuY3Rpb24oZSx0LGkpe3ZhciBfPVtudWxsXTtfLnB1c2guYXBwbHkoXyx0KTt2YXIgbj1GdW5jdGlvbi5iaW5kLmFwcGx5KGUsXyksbD1uZXcgbjtyZXR1cm4gaSYmdShsLGkucHJvdG90eXBlKSxsfSxyLmFwcGx5KG51bGwsYXJndW1lbnRzKX1mdW5jdGlvbiBkKGUpe3JldHVybi0xIT09RnVuY3Rpb24udG9TdHJpbmcuY2FsbChlKS5pbmRleE9mKFwiW25hdGl2ZSBjb2RlXVwiKX1mdW5jdGlvbiBoKGUpe3ZhciB0PVwiZnVuY3Rpb25cIj09dHlwZW9mIE1hcD9uZXcgTWFwOnZvaWQgMDtyZXR1cm4gaD1mdW5jdGlvbihlKXtmdW5jdGlvbiBpKCl7cmV0dXJuIHIoZSxhcmd1bWVudHMsYSh0aGlzKS5jb25zdHJ1Y3Rvcil9aWYobnVsbD09PWV8fCFkKGUpKXJldHVybiBlO2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIGUpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO2lmKFwidW5kZWZpbmVkXCIhPXR5cGVvZiB0KXtpZih0LmhhcyhlKSlyZXR1cm4gdC5nZXQoZSk7dC5zZXQoZSxpKX1yZXR1cm4gaS5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShlLnByb3RvdHlwZSx7Y29uc3RydWN0b3I6e3ZhbHVlOmksZW51bWVyYWJsZTohMSx3cml0YWJsZTohMCxjb25maWd1cmFibGU6ITB9fSksdShpLGUpfSxoKGUpfWZ1bmN0aW9uIGIoZSl7aWYodm9pZCAwPT09ZSl0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7cmV0dXJuIGV9ZnVuY3Rpb24gbShlLHQpe2lmKHQmJihcIm9iamVjdFwiPT10eXBlb2YgdHx8XCJmdW5jdGlvblwiPT10eXBlb2YgdCkpcmV0dXJuIHQ7aWYodm9pZCAwIT09dCl0aHJvdyBuZXcgVHlwZUVycm9yKFwiRGVyaXZlZCBjb25zdHJ1Y3RvcnMgbWF5IG9ubHkgcmV0dXJuIG9iamVjdCBvciB1bmRlZmluZWRcIik7cmV0dXJuIGIoZSl9ZnVuY3Rpb24gYyhlKXt2YXIgdD1zKCk7cmV0dXJuIGZ1bmN0aW9uKCl7dmFyIGksXz1hKGUpO2lmKHQpe3ZhciBuPWEodGhpcykuY29uc3RydWN0b3I7aT1SZWZsZWN0LmNvbnN0cnVjdChfLGFyZ3VtZW50cyxuKX1lbHNlIGk9Xy5hcHBseSh0aGlzLGFyZ3VtZW50cyk7cmV0dXJuIG0odGhpcyxpKX19ZnVuY3Rpb24gdihlLHQpe3JldHVybiB5KGUpfHxmKGUsdCl8fEQoZSx0KXx8aygpfWZ1bmN0aW9uIHkoZSl7aWYoQXJyYXkuaXNBcnJheShlKSlyZXR1cm4gZX1mdW5jdGlvbiBmKGUsdCl7dmFyIGk9bnVsbD09ZT9udWxsOlwidW5kZWZpbmVkXCIhPXR5cGVvZiBTeW1ib2wmJmVbU3ltYm9sLml0ZXJhdG9yXXx8ZVtcIkBAaXRlcmF0b3JcIl07aWYobnVsbCE9aSl7dmFyIF8sbixsPVtdLGc9ITAsbz0hMTt0cnl7Zm9yKGk9aS5jYWxsKGUpOyEoZz0oXz1pLm5leHQoKSkuZG9uZSkmJihsLnB1c2goXy52YWx1ZSksISh0JiZsLmxlbmd0aD09PXQpKTtnPSEwKTt9Y2F0Y2goZSl7bz0hMCxuPWV9ZmluYWxseXt0cnl7Z3x8bnVsbD09aVtcInJldHVyblwiXXx8aVtcInJldHVyblwiXSgpfWZpbmFsbHl7aWYobyl0aHJvdyBufX1yZXR1cm4gbH19ZnVuY3Rpb24gRChlLHQpe2lmKGUpe2lmKFwic3RyaW5nXCI9PXR5cGVvZiBlKXJldHVybiBwKGUsdCk7dmFyIGk9T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGUpLnNsaWNlKDgsLTEpO3JldHVyblwiT2JqZWN0XCI9PT1pJiZlLmNvbnN0cnVjdG9yJiYoaT1lLmNvbnN0cnVjdG9yLm5hbWUpLFwiTWFwXCI9PT1pfHxcIlNldFwiPT09aT9BcnJheS5mcm9tKGUpOlwiQXJndW1lbnRzXCI9PT1pfHwvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChpKT9wKGUsdCk6dm9pZCAwfX1mdW5jdGlvbiBwKGUsdCl7KG51bGw9PXR8fHQ+ZS5sZW5ndGgpJiYodD1lLmxlbmd0aCk7Zm9yKHZhciBfPTAsbj1BcnJheSh0KTtfPHQ7XysrKW5bX109ZVtfXTtyZXR1cm4gbn1mdW5jdGlvbiBrKCl7dGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKX1mdW5jdGlvbiBCKGUsdCl7dmFyIF89XCJ1bmRlZmluZWRcIiE9dHlwZW9mIFN5bWJvbCYmZVtTeW1ib2wuaXRlcmF0b3JdfHxlW1wiQEBpdGVyYXRvclwiXTtpZighXyl7aWYoQXJyYXkuaXNBcnJheShlKXx8KF89RChlKSl8fHQmJmUmJlwibnVtYmVyXCI9PXR5cGVvZiBlLmxlbmd0aCl7XyYmKGU9Xyk7dmFyIG49MCxsPWZ1bmN0aW9uKCl7fTtyZXR1cm57czpsLG46ZnVuY3Rpb24oKXtyZXR1cm4gbj49ZS5sZW5ndGg/e2RvbmU6ITB9Ontkb25lOiExLHZhbHVlOmVbbisrXX19LGU6ZnVuY3Rpb24odCl7dGhyb3cgdH0sZjpsfX10aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIil9dmFyIGcsYT0hMCx1PSExO3JldHVybntzOmZ1bmN0aW9uKCl7Xz1fLmNhbGwoZSl9LG46ZnVuY3Rpb24oKXt2YXIgZT1fLm5leHQoKTtyZXR1cm4gYT1lLmRvbmUsZX0sZTpmdW5jdGlvbih0KXt1PSEwLGc9dH0sZjpmdW5jdGlvbigpe3RyeXthfHxudWxsPT1fLnJldHVybnx8Xy5yZXR1cm4oKX1maW5hbGx5e2lmKHUpdGhyb3cgZ319fX12YXIgUz1mdW5jdGlvbihlKXt2YXIgdD1NYXRoLmFicyxuPU1hdGgubWF4LG89TWF0aC5mbG9vcjtmdW5jdGlvbiBhKGUsdCl7dmFyIGk7aWYoXyh0aGlzLGEpLGk9dS5jYWxsKHRoaXMsZSksaS5zaWduPXQsT2JqZWN0LnNldFByb3RvdHlwZU9mKGIoaSksYS5wcm90b3R5cGUpLGU+YS5fX2tNYXhMZW5ndGgpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJNYXhpbXVtIEJpZ0ludCBzaXplIGV4Y2VlZGVkXCIpO3JldHVybiBpfWcoYSxlKTt2YXIgdT1jKGEpO3JldHVybiBsKGEsW3trZXk6XCJ0b0RlYnVnU3RyaW5nXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZSx0PVtcIkJpZ0ludFtcIl0saT1CKHRoaXMpO3RyeXtmb3IoaS5zKCk7IShlPWkubigpKS5kb25lOyl7dmFyIF89ZS52YWx1ZTt0LnB1c2goKF8/KF8+Pj4wKS50b1N0cmluZygxNik6XykrXCIsIFwiKX19Y2F0Y2goZSl7aS5lKGUpfWZpbmFsbHl7aS5mKCl9cmV0dXJuIHQucHVzaChcIl1cIiksdC5qb2luKFwiXCIpfX0se2tleTpcInRvU3RyaW5nXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT0wPGFyZ3VtZW50cy5sZW5ndGgmJnZvaWQgMCE9PWFyZ3VtZW50c1swXT9hcmd1bWVudHNbMF06MTA7aWYoMj5lfHwzNjxlKXRocm93IG5ldyBSYW5nZUVycm9yKFwidG9TdHJpbmcoKSByYWRpeCBhcmd1bWVudCBtdXN0IGJlIGJldHdlZW4gMiBhbmQgMzZcIik7cmV0dXJuIDA9PT10aGlzLmxlbmd0aD9cIjBcIjowPT0oZSZlLTEpP2EuX190b1N0cmluZ0Jhc2VQb3dlck9mVHdvKHRoaXMsZSk6YS5fX3RvU3RyaW5nR2VuZXJpYyh0aGlzLGUsITEpfX0se2tleTpcInZhbHVlT2ZcIix2YWx1ZTpmdW5jdGlvbigpe3Rocm93IG5ldyBFcnJvcihcIkNvbnZlcnQgSlNCSSBpbnN0YW5jZXMgdG8gbmF0aXZlIG51bWJlcnMgdXNpbmcgYHRvTnVtYmVyYC5cIil9fSx7a2V5OlwiX19jb3B5XCIsdmFsdWU6ZnVuY3Rpb24oKXtmb3IodmFyIGU9bmV3IGEodGhpcy5sZW5ndGgsdGhpcy5zaWduKSx0PTA7dDx0aGlzLmxlbmd0aDt0KyspZVt0XT10aGlzW3RdO3JldHVybiBlfX0se2tleTpcIl9fdHJpbVwiLHZhbHVlOmZ1bmN0aW9uKCl7Zm9yKHZhciBlPXRoaXMubGVuZ3RoLHQ9dGhpc1tlLTFdOzA9PT10OyllLS0sdD10aGlzW2UtMV0sdGhpcy5wb3AoKTtyZXR1cm4gMD09PWUmJih0aGlzLnNpZ249ITEpLHRoaXN9fSx7a2V5OlwiX19pbml0aWFsaXplRGlnaXRzXCIsdmFsdWU6ZnVuY3Rpb24oKXtmb3IodmFyIGU9MDtlPHRoaXMubGVuZ3RoO2UrKyl0aGlzW2VdPTB9fSx7a2V5OlwiX19jbHptc2RcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiBhLl9fY2x6MzAodGhpcy5fX2RpZ2l0KHRoaXMubGVuZ3RoLTEpKX19LHtrZXk6XCJfX2lucGxhY2VNdWx0aXBseUFkZFwiLHZhbHVlOmZ1bmN0aW9uKGUsdCxfKXtfPnRoaXMubGVuZ3RoJiYoXz10aGlzLmxlbmd0aCk7Zm9yKHZhciBuPTMyNzY3JmUsbD1lPj4+MTUsZz0wLG89dCx1PTA7dTxfO3UrKyl7dmFyIHM9dGhpcy5fX2RpZ2l0KHUpLHI9MzI3NjcmcyxkPXM+Pj4xNSxoPWEuX19pbXVsKHIsbiksYj1hLl9faW11bChyLGwpLG09YS5fX2ltdWwoZCxuKSxjPWEuX19pbXVsKGQsbCksdj1vK2grZztnPXY+Pj4zMCx2Jj0xMDczNzQxODIzLHYrPSgoMzI3NjcmYik8PDE1KSsoKDMyNzY3Jm0pPDwxNSksZys9dj4+PjMwLG89YysoYj4+PjE1KSsobT4+PjE1KSx0aGlzLl9fc2V0RGlnaXQodSwxMDczNzQxODIzJnYpfWlmKDAhPT1nfHwwIT09byl0aHJvdyBuZXcgRXJyb3IoXCJpbXBsZW1lbnRhdGlvbiBidWdcIil9fSx7a2V5OlwiX19pbnBsYWNlQWRkXCIsdmFsdWU6ZnVuY3Rpb24oZSx0LF8pe2Zvcih2YXIgbixsPTAsZz0wO2c8XztnKyspbj10aGlzLl9faGFsZkRpZ2l0KHQrZykrZS5fX2hhbGZEaWdpdChnKStsLGw9bj4+PjE1LHRoaXMuX19zZXRIYWxmRGlnaXQodCtnLDMyNzY3Jm4pO3JldHVybiBsfX0se2tleTpcIl9faW5wbGFjZVN1YlwiLHZhbHVlOmZ1bmN0aW9uKGUsdCxfKXt2YXIgbj0wO2lmKDEmdCl7dD4+PTE7Zm9yKHZhciBsPXRoaXMuX19kaWdpdCh0KSxnPTMyNzY3Jmwsbz0wO288Xy0xPj4+MTtvKyspe3ZhciBhPWUuX19kaWdpdChvKSx1PShsPj4+MTUpLSgzMjc2NyZhKS1uO249MSZ1Pj4+MTUsdGhpcy5fX3NldERpZ2l0KHQrbywoMzI3NjcmdSk8PDE1fDMyNzY3JmcpLGw9dGhpcy5fX2RpZ2l0KHQrbysxKSxnPSgzMjc2NyZsKS0oYT4+PjE1KS1uLG49MSZnPj4+MTV9dmFyIHM9ZS5fX2RpZ2l0KG8pLHI9KGw+Pj4xNSktKDMyNzY3JnMpLW47bj0xJnI+Pj4xNSx0aGlzLl9fc2V0RGlnaXQodCtvLCgzMjc2NyZyKTw8MTV8MzI3NjcmZyk7aWYodCtvKzE+PXRoaXMubGVuZ3RoKXRocm93IG5ldyBSYW5nZUVycm9yKFwib3V0IG9mIGJvdW5kc1wiKTswPT0oMSZfKSYmKGw9dGhpcy5fX2RpZ2l0KHQrbysxKSxnPSgzMjc2NyZsKS0ocz4+PjE1KS1uLG49MSZnPj4+MTUsdGhpcy5fX3NldERpZ2l0KHQrZS5sZW5ndGgsMTA3MzcwOTA1NiZsfDMyNzY3JmcpKX1lbHNle3Q+Pj0xO2Zvcih2YXIgZD0wO2Q8ZS5sZW5ndGgtMTtkKyspe3ZhciBoPXRoaXMuX19kaWdpdCh0K2QpLGI9ZS5fX2RpZ2l0KGQpLG09KDMyNzY3JmgpLSgzMjc2NyZiKS1uO249MSZtPj4+MTU7dmFyIGM9KGg+Pj4xNSktKGI+Pj4xNSktbjtuPTEmYz4+PjE1LHRoaXMuX19zZXREaWdpdCh0K2QsKDMyNzY3JmMpPDwxNXwzMjc2NyZtKX12YXIgdj10aGlzLl9fZGlnaXQodCtkKSx5PWUuX19kaWdpdChkKSxmPSgzMjc2NyZ2KS0oMzI3NjcmeSktbjtuPTEmZj4+PjE1O3ZhciBEPTA7MD09KDEmXykmJihEPSh2Pj4+MTUpLSh5Pj4+MTUpLW4sbj0xJkQ+Pj4xNSksdGhpcy5fX3NldERpZ2l0KHQrZCwoMzI3NjcmRCk8PDE1fDMyNzY3JmYpfXJldHVybiBufX0se2tleTpcIl9faW5wbGFjZVJpZ2h0U2hpZnRcIix2YWx1ZTpmdW5jdGlvbihlKXtpZigwIT09ZSl7Zm9yKHZhciB0LF89dGhpcy5fX2RpZ2l0KDApPj4+ZSxuPXRoaXMubGVuZ3RoLTEsbD0wO2w8bjtsKyspdD10aGlzLl9fZGlnaXQobCsxKSx0aGlzLl9fc2V0RGlnaXQobCwxMDczNzQxODIzJnQ8PDMwLWV8XyksXz10Pj4+ZTt0aGlzLl9fc2V0RGlnaXQobixfKX19fSx7a2V5OlwiX19kaWdpdFwiLHZhbHVlOmZ1bmN0aW9uKGUpe3JldHVybiB0aGlzW2VdfX0se2tleTpcIl9fdW5zaWduZWREaWdpdFwiLHZhbHVlOmZ1bmN0aW9uKGUpe3JldHVybiB0aGlzW2VdPj4+MH19LHtrZXk6XCJfX3NldERpZ2l0XCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXt0aGlzW2VdPTB8dH19LHtrZXk6XCJfX3NldERpZ2l0R3Jvd1wiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7dGhpc1tlXT0wfHR9fSx7a2V5OlwiX19oYWxmRGlnaXRMZW5ndGhcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPXRoaXMubGVuZ3RoO3JldHVybiAzMjc2Nz49dGhpcy5fX3Vuc2lnbmVkRGlnaXQoZS0xKT8yKmUtMToyKmV9fSx7a2V5OlwiX19oYWxmRGlnaXRcIix2YWx1ZTpmdW5jdGlvbihlKXtyZXR1cm4gMzI3NjcmdGhpc1tlPj4+MV0+Pj4xNSooMSZlKX19LHtrZXk6XCJfX3NldEhhbGZEaWdpdFwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7dmFyIGk9ZT4+PjEsXz10aGlzLl9fZGlnaXQoaSksbj0xJmU/MzI3NjcmX3x0PDwxNToxMDczNzA5MDU2Jl98MzI3NjcmdDt0aGlzLl9fc2V0RGlnaXQoaSxuKX19XSxbe2tleTpcIkJpZ0ludFwiLHZhbHVlOmZ1bmN0aW9uKGUpe3ZhciB0PU51bWJlci5pc0Zpbml0ZTtpZihcIm51bWJlclwiPT10eXBlb2YgZSl7aWYoMD09PWUpcmV0dXJuIGEuX196ZXJvKCk7aWYoYS5fX2lzT25lRGlnaXRJbnQoZSkpcmV0dXJuIDA+ZT9hLl9fb25lRGlnaXQoLWUsITApOmEuX19vbmVEaWdpdChlLCExKTtpZighdChlKXx8byhlKSE9PWUpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJUaGUgbnVtYmVyIFwiK2UrXCIgY2Fubm90IGJlIGNvbnZlcnRlZCB0byBCaWdJbnQgYmVjYXVzZSBpdCBpcyBub3QgYW4gaW50ZWdlclwiKTtyZXR1cm4gYS5fX2Zyb21Eb3VibGUoZSl9aWYoXCJzdHJpbmdcIj09dHlwZW9mIGUpe3ZhciBfPWEuX19mcm9tU3RyaW5nKGUpO2lmKG51bGw9PT1fKXRocm93IG5ldyBTeW50YXhFcnJvcihcIkNhbm5vdCBjb252ZXJ0IFwiK2UrXCIgdG8gYSBCaWdJbnRcIik7cmV0dXJuIF99aWYoXCJib29sZWFuXCI9PXR5cGVvZiBlKXJldHVybiEwPT09ZT9hLl9fb25lRGlnaXQoMSwhMSk6YS5fX3plcm8oKTtpZihcIm9iamVjdFwiPT09aShlKSl7aWYoZS5jb25zdHJ1Y3Rvcj09PWEpcmV0dXJuIGU7dmFyIG49YS5fX3RvUHJpbWl0aXZlKGUpO3JldHVybiBhLkJpZ0ludChuKX10aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNvbnZlcnQgXCIrZStcIiB0byBhIEJpZ0ludFwiKX19LHtrZXk6XCJ0b051bWJlclwiLHZhbHVlOmZ1bmN0aW9uKGUpe3ZhciB0PWUubGVuZ3RoO2lmKDA9PT10KXJldHVybiAwO2lmKDE9PT10KXt2YXIgaT1lLl9fdW5zaWduZWREaWdpdCgwKTtyZXR1cm4gZS5zaWduPy1pOml9dmFyIF89ZS5fX2RpZ2l0KHQtMSksbj1hLl9fY2x6MzAoXyksbD0zMCp0LW47aWYoMTAyNDxsKXJldHVybiBlLnNpZ24/LUluZmluaXR5OjEvMDt2YXIgZz1sLTEsbz1fLHU9dC0xLHM9biszLHI9MzI9PT1zPzA6bzw8cztyPj4+PTEyO3ZhciBkPXMtMTIsaD0xMjw9cz8wOm88PDIwK3MsYj0yMCtzO2ZvcigwPGQmJjA8dSYmKHUtLSxvPWUuX19kaWdpdCh1KSxyfD1vPj4+MzAtZCxoPW88PGQrMixiPWQrMik7MDxiJiYwPHU7KXUtLSxvPWUuX19kaWdpdCh1KSxofD0zMDw9Yj9vPDxiLTMwOm8+Pj4zMC1iLGItPTMwO3ZhciBtPWEuX19kZWNpZGVSb3VuZGluZyhlLGIsdSxvKTtpZigoMT09PW18fDA9PT1tJiYxPT0oMSZoKSkmJihoPWgrMT4+PjAsMD09PWgmJihyKyssMCE9cj4+PjIwJiYocj0wLGcrKywxMDIzPGcpKSkpcmV0dXJuIGUuc2lnbj8tSW5maW5pdHk6MS8wO3ZhciBjPWUuc2lnbj8tMjE0NzQ4MzY0ODowO3JldHVybiBnPWcrMTAyMzw8MjAsYS5fX2tCaXRDb252ZXJzaW9uSW50c1sxXT1jfGd8cixhLl9fa0JpdENvbnZlcnNpb25JbnRzWzBdPWgsYS5fX2tCaXRDb252ZXJzaW9uRG91YmxlWzBdfX0se2tleTpcInVuYXJ5TWludXNcIix2YWx1ZTpmdW5jdGlvbihlKXtpZigwPT09ZS5sZW5ndGgpcmV0dXJuIGU7dmFyIHQ9ZS5fX2NvcHkoKTtyZXR1cm4gdC5zaWduPSFlLnNpZ24sdH19LHtrZXk6XCJiaXR3aXNlTm90XCIsdmFsdWU6ZnVuY3Rpb24oZSl7cmV0dXJuIGUuc2lnbj9hLl9fYWJzb2x1dGVTdWJPbmUoZSkuX190cmltKCk6YS5fX2Fic29sdXRlQWRkT25lKGUsITApfX0se2tleTpcImV4cG9uZW50aWF0ZVwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7aWYodC5zaWduKXRocm93IG5ldyBSYW5nZUVycm9yKFwiRXhwb25lbnQgbXVzdCBiZSBwb3NpdGl2ZVwiKTtpZigwPT09dC5sZW5ndGgpcmV0dXJuIGEuX19vbmVEaWdpdCgxLCExKTtpZigwPT09ZS5sZW5ndGgpcmV0dXJuIGU7aWYoMT09PWUubGVuZ3RoJiYxPT09ZS5fX2RpZ2l0KDApKXJldHVybiBlLnNpZ24mJjA9PSgxJnQuX19kaWdpdCgwKSk/YS51bmFyeU1pbnVzKGUpOmU7aWYoMTx0Lmxlbmd0aCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkJpZ0ludCB0b28gYmlnXCIpO3ZhciBpPXQuX191bnNpZ25lZERpZ2l0KDApO2lmKDE9PT1pKXJldHVybiBlO2lmKGk+PWEuX19rTWF4TGVuZ3RoQml0cyl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkJpZ0ludCB0b28gYmlnXCIpO2lmKDE9PT1lLmxlbmd0aCYmMj09PWUuX19kaWdpdCgwKSl7dmFyIF89MSsoMHxpLzMwKSxuPWUuc2lnbiYmMCE9KDEmaSksbD1uZXcgYShfLG4pO2wuX19pbml0aWFsaXplRGlnaXRzKCk7dmFyIGc9MTw8aSUzMDtyZXR1cm4gbC5fX3NldERpZ2l0KF8tMSxnKSxsfXZhciBvPW51bGwsdT1lO2ZvcigwIT0oMSZpKSYmKG89ZSksaT4+PTE7MCE9PWk7aT4+PTEpdT1hLm11bHRpcGx5KHUsdSksMCE9KDEmaSkmJihudWxsPT09bz9vPXU6bz1hLm11bHRpcGx5KG8sdSkpO3JldHVybiBvfX0se2tleTpcIm11bHRpcGx5XCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXtpZigwPT09ZS5sZW5ndGgpcmV0dXJuIGU7aWYoMD09PXQubGVuZ3RoKXJldHVybiB0O3ZhciBfPWUubGVuZ3RoK3QubGVuZ3RoOzMwPD1lLl9fY2x6bXNkKCkrdC5fX2Nsem1zZCgpJiZfLS07dmFyIG49bmV3IGEoXyxlLnNpZ24hPT10LnNpZ24pO24uX19pbml0aWFsaXplRGlnaXRzKCk7Zm9yKHZhciBsPTA7bDxlLmxlbmd0aDtsKyspYS5fX211bHRpcGx5QWNjdW11bGF0ZSh0LGUuX19kaWdpdChsKSxuLGwpO3JldHVybiBuLl9fdHJpbSgpfX0se2tleTpcImRpdmlkZVwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7aWYoMD09PXQubGVuZ3RoKXRocm93IG5ldyBSYW5nZUVycm9yKFwiRGl2aXNpb24gYnkgemVyb1wiKTtpZigwPmEuX19hYnNvbHV0ZUNvbXBhcmUoZSx0KSlyZXR1cm4gYS5fX3plcm8oKTt2YXIgaSxfPWUuc2lnbiE9PXQuc2lnbixuPXQuX191bnNpZ25lZERpZ2l0KDApO2lmKDE9PT10Lmxlbmd0aCYmMzI3Njc+PW4pe2lmKDE9PT1uKXJldHVybiBfPT09ZS5zaWduP2U6YS51bmFyeU1pbnVzKGUpO2k9YS5fX2Fic29sdXRlRGl2U21hbGwoZSxuLG51bGwpfWVsc2UgaT1hLl9fYWJzb2x1dGVEaXZMYXJnZShlLHQsITAsITEpO3JldHVybiBpLnNpZ249XyxpLl9fdHJpbSgpfX0se2tleTpcInJlbWFpbmRlclwiLHZhbHVlOmZ1bmN0aW9uIGkoZSx0KXtpZigwPT09dC5sZW5ndGgpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJEaXZpc2lvbiBieSB6ZXJvXCIpO2lmKDA+YS5fX2Fic29sdXRlQ29tcGFyZShlLHQpKXJldHVybiBlO3ZhciBfPXQuX191bnNpZ25lZERpZ2l0KDApO2lmKDE9PT10Lmxlbmd0aCYmMzI3Njc+PV8pe2lmKDE9PT1fKXJldHVybiBhLl9femVybygpO3ZhciBuPWEuX19hYnNvbHV0ZU1vZFNtYWxsKGUsXyk7cmV0dXJuIDA9PT1uP2EuX196ZXJvKCk6YS5fX29uZURpZ2l0KG4sZS5zaWduKX12YXIgaT1hLl9fYWJzb2x1dGVEaXZMYXJnZShlLHQsITEsITApO3JldHVybiBpLnNpZ249ZS5zaWduLGkuX190cmltKCl9fSx7a2V5OlwiYWRkXCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXt2YXIgaT1lLnNpZ247cmV0dXJuIGk9PT10LnNpZ24/YS5fX2Fic29sdXRlQWRkKGUsdCxpKTowPD1hLl9fYWJzb2x1dGVDb21wYXJlKGUsdCk/YS5fX2Fic29sdXRlU3ViKGUsdCxpKTphLl9fYWJzb2x1dGVTdWIodCxlLCFpKX19LHtrZXk6XCJzdWJ0cmFjdFwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7dmFyIGk9ZS5zaWduO3JldHVybiBpPT09dC5zaWduPzA8PWEuX19hYnNvbHV0ZUNvbXBhcmUoZSx0KT9hLl9fYWJzb2x1dGVTdWIoZSx0LGkpOmEuX19hYnNvbHV0ZVN1Yih0LGUsIWkpOmEuX19hYnNvbHV0ZUFkZChlLHQsaSl9fSx7a2V5OlwibGVmdFNoaWZ0XCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gMD09PXQubGVuZ3RofHwwPT09ZS5sZW5ndGg/ZTp0LnNpZ24/YS5fX3JpZ2h0U2hpZnRCeUFic29sdXRlKGUsdCk6YS5fX2xlZnRTaGlmdEJ5QWJzb2x1dGUoZSx0KX19LHtrZXk6XCJzaWduZWRSaWdodFNoaWZ0XCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gMD09PXQubGVuZ3RofHwwPT09ZS5sZW5ndGg/ZTp0LnNpZ24/YS5fX2xlZnRTaGlmdEJ5QWJzb2x1dGUoZSx0KTphLl9fcmlnaHRTaGlmdEJ5QWJzb2x1dGUoZSx0KX19LHtrZXk6XCJ1bnNpZ25lZFJpZ2h0U2hpZnRcIix2YWx1ZTpmdW5jdGlvbigpe3Rocm93IG5ldyBUeXBlRXJyb3IoXCJCaWdJbnRzIGhhdmUgbm8gdW5zaWduZWQgcmlnaHQgc2hpZnQ7IHVzZSA+PiBpbnN0ZWFkXCIpfX0se2tleTpcImxlc3NUaGFuXCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gMD5hLl9fY29tcGFyZVRvQmlnSW50KGUsdCl9fSx7a2V5OlwibGVzc1RoYW5PckVxdWFsXCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gMD49YS5fX2NvbXBhcmVUb0JpZ0ludChlLHQpfX0se2tleTpcImdyZWF0ZXJUaGFuXCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gMDxhLl9fY29tcGFyZVRvQmlnSW50KGUsdCl9fSx7a2V5OlwiZ3JlYXRlclRoYW5PckVxdWFsXCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gMDw9YS5fX2NvbXBhcmVUb0JpZ0ludChlLHQpfX0se2tleTpcImVxdWFsXCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXtpZihlLnNpZ24hPT10LnNpZ24pcmV0dXJuITE7aWYoZS5sZW5ndGghPT10Lmxlbmd0aClyZXR1cm4hMTtmb3IodmFyIF89MDtfPGUubGVuZ3RoO18rKylpZihlLl9fZGlnaXQoXykhPT10Ll9fZGlnaXQoXykpcmV0dXJuITE7cmV0dXJuITB9fSx7a2V5Olwibm90RXF1YWxcIix2YWx1ZTpmdW5jdGlvbihlLHQpe3JldHVybiFhLmVxdWFsKGUsdCl9fSx7a2V5OlwiYml0d2lzZUFuZFwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7aWYoIWUuc2lnbiYmIXQuc2lnbilyZXR1cm4gYS5fX2Fic29sdXRlQW5kKGUsdCkuX190cmltKCk7aWYoZS5zaWduJiZ0LnNpZ24pe3ZhciBpPW4oZS5sZW5ndGgsdC5sZW5ndGgpKzEsXz1hLl9fYWJzb2x1dGVTdWJPbmUoZSxpKSxsPWEuX19hYnNvbHV0ZVN1Yk9uZSh0KTtyZXR1cm4gXz1hLl9fYWJzb2x1dGVPcihfLGwsXyksYS5fX2Fic29sdXRlQWRkT25lKF8sITAsXykuX190cmltKCl9aWYoZS5zaWduKXt2YXIgZz1bdCxlXTtlPWdbMF0sdD1nWzFdfXJldHVybiBhLl9fYWJzb2x1dGVBbmROb3QoZSxhLl9fYWJzb2x1dGVTdWJPbmUodCkpLl9fdHJpbSgpfX0se2tleTpcImJpdHdpc2VYb3JcIix2YWx1ZTpmdW5jdGlvbihlLHQpe2lmKCFlLnNpZ24mJiF0LnNpZ24pcmV0dXJuIGEuX19hYnNvbHV0ZVhvcihlLHQpLl9fdHJpbSgpO2lmKGUuc2lnbiYmdC5zaWduKXt2YXIgaT1uKGUubGVuZ3RoLHQubGVuZ3RoKSxfPWEuX19hYnNvbHV0ZVN1Yk9uZShlLGkpLGw9YS5fX2Fic29sdXRlU3ViT25lKHQpO3JldHVybiBhLl9fYWJzb2x1dGVYb3IoXyxsLF8pLl9fdHJpbSgpfXZhciBnPW4oZS5sZW5ndGgsdC5sZW5ndGgpKzE7aWYoZS5zaWduKXt2YXIgbz1bdCxlXTtlPW9bMF0sdD1vWzFdfXZhciB1PWEuX19hYnNvbHV0ZVN1Yk9uZSh0LGcpO3JldHVybiB1PWEuX19hYnNvbHV0ZVhvcih1LGUsdSksYS5fX2Fic29sdXRlQWRkT25lKHUsITAsdSkuX190cmltKCl9fSx7a2V5OlwiYml0d2lzZU9yXCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXt2YXIgaT1uKGUubGVuZ3RoLHQubGVuZ3RoKTtpZighZS5zaWduJiYhdC5zaWduKXJldHVybiBhLl9fYWJzb2x1dGVPcihlLHQpLl9fdHJpbSgpO2lmKGUuc2lnbiYmdC5zaWduKXt2YXIgXz1hLl9fYWJzb2x1dGVTdWJPbmUoZSxpKSxsPWEuX19hYnNvbHV0ZVN1Yk9uZSh0KTtyZXR1cm4gXz1hLl9fYWJzb2x1dGVBbmQoXyxsLF8pLGEuX19hYnNvbHV0ZUFkZE9uZShfLCEwLF8pLl9fdHJpbSgpfWlmKGUuc2lnbil7dmFyIGc9W3QsZV07ZT1nWzBdLHQ9Z1sxXX12YXIgbz1hLl9fYWJzb2x1dGVTdWJPbmUodCxpKTtyZXR1cm4gbz1hLl9fYWJzb2x1dGVBbmROb3QobyxlLG8pLGEuX19hYnNvbHV0ZUFkZE9uZShvLCEwLG8pLl9fdHJpbSgpfX0se2tleTpcImFzSW50TlwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7aWYoMD09PXQubGVuZ3RoKXJldHVybiB0O2lmKGU9byhlKSwwPmUpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIHZhbHVlOiBub3QgKGNvbnZlcnRpYmxlIHRvKSBhIHNhZmUgaW50ZWdlclwiKTtpZigwPT09ZSlyZXR1cm4gYS5fX3plcm8oKTtpZihlPj1hLl9fa01heExlbmd0aEJpdHMpcmV0dXJuIHQ7dmFyIF89MHwoZSsyOSkvMzA7aWYodC5sZW5ndGg8XylyZXR1cm4gdDt2YXIgbD10Ll9fdW5zaWduZWREaWdpdChfLTEpLGc9MTw8KGUtMSklMzA7aWYodC5sZW5ndGg9PT1fJiZsPGcpcmV0dXJuIHQ7aWYoISgobCZnKT09PWcpKXJldHVybiBhLl9fdHJ1bmNhdGVUb05CaXRzKGUsdCk7aWYoIXQuc2lnbilyZXR1cm4gYS5fX3RydW5jYXRlQW5kU3ViRnJvbVBvd2VyT2ZUd28oZSx0LCEwKTtpZigwPT0obCZnLTEpKXtmb3IodmFyIHU9Xy0yOzA8PXU7dS0tKWlmKDAhPT10Ll9fZGlnaXQodSkpcmV0dXJuIGEuX190cnVuY2F0ZUFuZFN1YkZyb21Qb3dlck9mVHdvKGUsdCwhMSk7cmV0dXJuIHQubGVuZ3RoPT09XyYmbD09PWc/dDphLl9fdHJ1bmNhdGVUb05CaXRzKGUsdCl9cmV0dXJuIGEuX190cnVuY2F0ZUFuZFN1YkZyb21Qb3dlck9mVHdvKGUsdCwhMSl9fSx7a2V5OlwiYXNVaW50TlwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7aWYoMD09PXQubGVuZ3RoKXJldHVybiB0O2lmKGU9byhlKSwwPmUpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIHZhbHVlOiBub3QgKGNvbnZlcnRpYmxlIHRvKSBhIHNhZmUgaW50ZWdlclwiKTtpZigwPT09ZSlyZXR1cm4gYS5fX3plcm8oKTtpZih0LnNpZ24pe2lmKGU+YS5fX2tNYXhMZW5ndGhCaXRzKXRocm93IG5ldyBSYW5nZUVycm9yKFwiQmlnSW50IHRvbyBiaWdcIik7cmV0dXJuIGEuX190cnVuY2F0ZUFuZFN1YkZyb21Qb3dlck9mVHdvKGUsdCwhMSl9aWYoZT49YS5fX2tNYXhMZW5ndGhCaXRzKXJldHVybiB0O3ZhciBpPTB8KGUrMjkpLzMwO2lmKHQubGVuZ3RoPGkpcmV0dXJuIHQ7dmFyIF89ZSUzMDtpZih0Lmxlbmd0aD09aSl7aWYoMD09PV8pcmV0dXJuIHQ7dmFyIGw9dC5fX2RpZ2l0KGktMSk7aWYoMD09bD4+Pl8pcmV0dXJuIHR9cmV0dXJuIGEuX190cnVuY2F0ZVRvTkJpdHMoZSx0KX19LHtrZXk6XCJBRERcIix2YWx1ZTpmdW5jdGlvbihlLHQpe2lmKGU9YS5fX3RvUHJpbWl0aXZlKGUpLHQ9YS5fX3RvUHJpbWl0aXZlKHQpLFwic3RyaW5nXCI9PXR5cGVvZiBlKXJldHVyblwic3RyaW5nXCIhPXR5cGVvZiB0JiYodD10LnRvU3RyaW5nKCkpLGUrdDtpZihcInN0cmluZ1wiPT10eXBlb2YgdClyZXR1cm4gZS50b1N0cmluZygpK3Q7aWYoZT1hLl9fdG9OdW1lcmljKGUpLHQ9YS5fX3RvTnVtZXJpYyh0KSxhLl9faXNCaWdJbnQoZSkmJmEuX19pc0JpZ0ludCh0KSlyZXR1cm4gYS5hZGQoZSx0KTtpZihcIm51bWJlclwiPT10eXBlb2YgZSYmXCJudW1iZXJcIj09dHlwZW9mIHQpcmV0dXJuIGUrdDt0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IG1peCBCaWdJbnQgYW5kIG90aGVyIHR5cGVzLCB1c2UgZXhwbGljaXQgY29udmVyc2lvbnNcIil9fSx7a2V5OlwiTFRcIix2YWx1ZTpmdW5jdGlvbihlLHQpe3JldHVybiBhLl9fY29tcGFyZShlLHQsMCl9fSx7a2V5OlwiTEVcIix2YWx1ZTpmdW5jdGlvbihlLHQpe3JldHVybiBhLl9fY29tcGFyZShlLHQsMSl9fSx7a2V5OlwiR1RcIix2YWx1ZTpmdW5jdGlvbihlLHQpe3JldHVybiBhLl9fY29tcGFyZShlLHQsMil9fSx7a2V5OlwiR0VcIix2YWx1ZTpmdW5jdGlvbihlLHQpe3JldHVybiBhLl9fY29tcGFyZShlLHQsMyl9fSx7a2V5OlwiRVFcIix2YWx1ZTpmdW5jdGlvbihlLHQpe2Zvcig7Oyl7aWYoYS5fX2lzQmlnSW50KGUpKXJldHVybiBhLl9faXNCaWdJbnQodCk/YS5lcXVhbChlLHQpOmEuRVEodCxlKTtpZihcIm51bWJlclwiPT10eXBlb2YgZSl7aWYoYS5fX2lzQmlnSW50KHQpKXJldHVybiBhLl9fZXF1YWxUb051bWJlcih0LGUpO2lmKFwib2JqZWN0XCIhPT1pKHQpKXJldHVybiBlPT10O3Q9YS5fX3RvUHJpbWl0aXZlKHQpfWVsc2UgaWYoXCJzdHJpbmdcIj09dHlwZW9mIGUpe2lmKGEuX19pc0JpZ0ludCh0KSlyZXR1cm4gZT1hLl9fZnJvbVN0cmluZyhlKSxudWxsIT09ZSYmYS5lcXVhbChlLHQpO2lmKFwib2JqZWN0XCIhPT1pKHQpKXJldHVybiBlPT10O3Q9YS5fX3RvUHJpbWl0aXZlKHQpfWVsc2UgaWYoXCJib29sZWFuXCI9PXR5cGVvZiBlKXtpZihhLl9faXNCaWdJbnQodCkpcmV0dXJuIGEuX19lcXVhbFRvTnVtYmVyKHQsK2UpO2lmKFwib2JqZWN0XCIhPT1pKHQpKXJldHVybiBlPT10O3Q9YS5fX3RvUHJpbWl0aXZlKHQpfWVsc2UgaWYoXCJzeW1ib2xcIj09PWkoZSkpe2lmKGEuX19pc0JpZ0ludCh0KSlyZXR1cm4hMTtpZihcIm9iamVjdFwiIT09aSh0KSlyZXR1cm4gZT09dDt0PWEuX190b1ByaW1pdGl2ZSh0KX1lbHNlIGlmKFwib2JqZWN0XCI9PT1pKGUpKXtpZihcIm9iamVjdFwiPT09aSh0KSYmdC5jb25zdHJ1Y3RvciE9PWEpcmV0dXJuIGU9PXQ7ZT1hLl9fdG9QcmltaXRpdmUoZSl9ZWxzZSByZXR1cm4gZT09dH19fSx7a2V5OlwiTkVcIix2YWx1ZTpmdW5jdGlvbihlLHQpe3JldHVybiFhLkVRKGUsdCl9fSx7a2V5OlwiRGF0YVZpZXdHZXRCaWdJbnQ2NFwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7dmFyIGk9ISEoMjxhcmd1bWVudHMubGVuZ3RoJiZ2b2lkIDAhPT1hcmd1bWVudHNbMl0pJiZhcmd1bWVudHNbMl07cmV0dXJuIGEuYXNJbnROKDY0LGEuRGF0YVZpZXdHZXRCaWdVaW50NjQoZSx0LGkpKX19LHtrZXk6XCJEYXRhVmlld0dldEJpZ1VpbnQ2NFwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7dmFyIGk9ISEoMjxhcmd1bWVudHMubGVuZ3RoJiZ2b2lkIDAhPT1hcmd1bWVudHNbMl0pJiZhcmd1bWVudHNbMl0sXz1pP1s0LDBdOlswLDRdLG49dihfLDIpLGc9blswXSxvPW5bMV0sbD1lLmdldFVpbnQzMih0K2csaSksdT1lLmdldFVpbnQzMih0K28saSkscz1uZXcgYSgzLCExKTtyZXR1cm4gcy5fX3NldERpZ2l0KDAsMTA3Mzc0MTgyMyZ1KSxzLl9fc2V0RGlnaXQoMSwoMjY4NDM1NDU1JmwpPDwyfHU+Pj4zMCkscy5fX3NldERpZ2l0KDIsbD4+PjI4KSxzLl9fdHJpbSgpfX0se2tleTpcIkRhdGFWaWV3U2V0QmlnSW50NjRcIix2YWx1ZTpmdW5jdGlvbihlLHQsaSl7dmFyIF89ISEoMzxhcmd1bWVudHMubGVuZ3RoJiZ2b2lkIDAhPT1hcmd1bWVudHNbM10pJiZhcmd1bWVudHNbM107YS5EYXRhVmlld1NldEJpZ1VpbnQ2NChlLHQsaSxfKX19LHtrZXk6XCJEYXRhVmlld1NldEJpZ1VpbnQ2NFwiLHZhbHVlOmZ1bmN0aW9uKGUsdCxpKXt2YXIgXz0hISgzPGFyZ3VtZW50cy5sZW5ndGgmJnZvaWQgMCE9PWFyZ3VtZW50c1szXSkmJmFyZ3VtZW50c1szXTtpPWEuYXNVaW50Tig2NCxpKTt2YXIgbj0wLGc9MDtpZigwPGkubGVuZ3RoJiYoZz1pLl9fZGlnaXQoMCksMTxpLmxlbmd0aCkpe3ZhciBvPWkuX19kaWdpdCgxKTtnfD1vPDwzMCxuPW8+Pj4yLDI8aS5sZW5ndGgmJihufD1pLl9fZGlnaXQoMik8PDI4KX12YXIgdT1fP1s0LDBdOlswLDRdLHM9dih1LDIpLHI9c1swXSxkPXNbMV07ZS5zZXRVaW50MzIodCtyLG4sXyksZS5zZXRVaW50MzIodCtkLGcsXyl9fSx7a2V5OlwiX196ZXJvXCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IGEoMCwhMSl9fSx7a2V5OlwiX19vbmVEaWdpdFwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7dmFyIGk9bmV3IGEoMSx0KTtyZXR1cm4gaS5fX3NldERpZ2l0KDAsZSksaX19LHtrZXk6XCJfX2RlY2lkZVJvdW5kaW5nXCIsdmFsdWU6ZnVuY3Rpb24oZSx0LGksXyl7aWYoMDx0KXJldHVybi0xO3ZhciBuO2lmKDA+dCluPS10LTE7ZWxzZXtpZigwPT09aSlyZXR1cm4tMTtpLS0sXz1lLl9fZGlnaXQoaSksbj0yOX12YXIgbD0xPDxuO2lmKDA9PShfJmwpKXJldHVybi0xO2lmKGwtPTEsMCE9KF8mbCkpcmV0dXJuIDE7Zm9yKDswPGk7KWlmKGktLSwwIT09ZS5fX2RpZ2l0KGkpKXJldHVybiAxO3JldHVybiAwfX0se2tleTpcIl9fZnJvbURvdWJsZVwiLHZhbHVlOmZ1bmN0aW9uKGUpe2EuX19rQml0Q29udmVyc2lvbkRvdWJsZVswXT1lO3ZhciB0LGk9MjA0NyZhLl9fa0JpdENvbnZlcnNpb25JbnRzWzFdPj4+MjAsXz1pLTEwMjMsbj0oMHxfLzMwKSsxLGw9bmV3IGEobiwwPmUpLGc9MTA0ODU3NSZhLl9fa0JpdENvbnZlcnNpb25JbnRzWzFdfDEwNDg1NzYsbz1hLl9fa0JpdENvbnZlcnNpb25JbnRzWzBdLHU9MjAscz1fJTMwLHI9MDtpZihzPHUpe3ZhciBkPXUtcztyPWQrMzIsdD1nPj4+ZCxnPWc8PDMyLWR8bz4+PmQsbzw8PTMyLWR9ZWxzZSBpZihzPT09dSlyPTMyLHQ9ZyxnPW8sbz0wO2Vsc2V7dmFyIGg9cy11O3I9MzItaCx0PWc8PGh8bz4+PjMyLWgsZz1vPDxoLG89MH1sLl9fc2V0RGlnaXQobi0xLHQpO2Zvcih2YXIgYj1uLTI7MDw9YjtiLS0pMDxyPyhyLT0zMCx0PWc+Pj4yLGc9Zzw8MzB8bz4+PjIsbzw8PTMwKTp0PTAsbC5fX3NldERpZ2l0KGIsdCk7cmV0dXJuIGwuX190cmltKCl9fSx7a2V5OlwiX19pc1doaXRlc3BhY2VcIix2YWx1ZTpmdW5jdGlvbihlKXtyZXR1cm4hISgxMz49ZSYmOTw9ZSl8fCgxNTk+PWU/MzI9PWU6MTMxMDcxPj1lPzE2MD09ZXx8NTc2MD09ZToxOTY2MDc+PWU/KGUmPTEzMTA3MSwxMD49ZXx8NDA9PWV8fDQxPT1lfHw0Nz09ZXx8OTU9PWV8fDQwOTY9PWUpOjY1Mjc5PT1lKX19LHtrZXk6XCJfX2Zyb21TdHJpbmdcIix2YWx1ZTpmdW5jdGlvbihlKXt2YXIgdD0xPGFyZ3VtZW50cy5sZW5ndGgmJnZvaWQgMCE9PWFyZ3VtZW50c1sxXT9hcmd1bWVudHNbMV06MCxpPTAsXz1lLmxlbmd0aCxuPTA7aWYobj09PV8pcmV0dXJuIGEuX196ZXJvKCk7Zm9yKHZhciBsPWUuY2hhckNvZGVBdChuKTthLl9faXNXaGl0ZXNwYWNlKGwpOyl7aWYoKytuPT09XylyZXR1cm4gYS5fX3plcm8oKTtsPWUuY2hhckNvZGVBdChuKX1pZig0Mz09PWwpe2lmKCsrbj09PV8pcmV0dXJuIG51bGw7bD1lLmNoYXJDb2RlQXQobiksaT0xfWVsc2UgaWYoNDU9PT1sKXtpZigrK249PT1fKXJldHVybiBudWxsO2w9ZS5jaGFyQ29kZUF0KG4pLGk9LTF9aWYoMD09PXQpe2lmKHQ9MTAsNDg9PT1sKXtpZigrK249PT1fKXJldHVybiBhLl9femVybygpO2lmKGw9ZS5jaGFyQ29kZUF0KG4pLDg4PT09bHx8MTIwPT09bCl7aWYodD0xNiwrK249PT1fKXJldHVybiBudWxsO2w9ZS5jaGFyQ29kZUF0KG4pfWVsc2UgaWYoNzk9PT1sfHwxMTE9PT1sKXtpZih0PTgsKytuPT09XylyZXR1cm4gbnVsbDtsPWUuY2hhckNvZGVBdChuKX1lbHNlIGlmKDY2PT09bHx8OTg9PT1sKXtpZih0PTIsKytuPT09XylyZXR1cm4gbnVsbDtsPWUuY2hhckNvZGVBdChuKX19fWVsc2UgaWYoMTY9PT10JiY0OD09PWwpe2lmKCsrbj09PV8pcmV0dXJuIGEuX196ZXJvKCk7aWYobD1lLmNoYXJDb2RlQXQobiksODg9PT1sfHwxMjA9PT1sKXtpZigrK249PT1fKXJldHVybiBudWxsO2w9ZS5jaGFyQ29kZUF0KG4pfX1pZigwIT09aSYmMTAhPT10KXJldHVybiBudWxsO2Zvcig7NDg9PT1sOyl7aWYoKytuPT09XylyZXR1cm4gYS5fX3plcm8oKTtsPWUuY2hhckNvZGVBdChuKX12YXIgZz1fLW4sbz1hLl9fa01heEJpdHNQZXJDaGFyW3RdLHU9YS5fX2tCaXRzUGVyQ2hhclRhYmxlTXVsdGlwbGllci0xO2lmKGc+MTA3Mzc0MTgyNC9vKXJldHVybiBudWxsO3ZhciBzPW8qZyt1Pj4+YS5fX2tCaXRzUGVyQ2hhclRhYmxlU2hpZnQscj1uZXcgYSgwfChzKzI5KS8zMCwhMSksaD0xMD50P3Q6MTAsYj0xMDx0P3QtMTA6MDtpZigwPT0odCZ0LTEpKXtvPj49YS5fX2tCaXRzUGVyQ2hhclRhYmxlU2hpZnQ7dmFyIGM9W10sdj1bXSx5PSExO2Rve2Zvcih2YXIgZixEPTAscD0wOzspe2lmKGY9dm9pZCAwLGwtNDg+Pj4wPGgpZj1sLTQ4O2Vsc2UgaWYoKDMyfGwpLTk3Pj4+MDxiKWY9KDMyfGwpLTg3O2Vsc2V7eT0hMDticmVha31pZihwKz1vLEQ9RDw8b3xmLCsrbj09PV8pe3k9ITA7YnJlYWt9aWYobD1lLmNoYXJDb2RlQXQobiksMzA8cCtvKWJyZWFrfWMucHVzaChEKSx2LnB1c2gocCl9d2hpbGUoIXkpO2EuX19maWxsRnJvbVBhcnRzKHIsYyx2KX1lbHNle3IuX19pbml0aWFsaXplRGlnaXRzKCk7dmFyIGs9ITEsQj0wO2Rve2Zvcih2YXIgUyxDPTAsST0xOzspe2lmKFM9dm9pZCAwLGwtNDg+Pj4wPGgpUz1sLTQ4O2Vsc2UgaWYoKDMyfGwpLTk3Pj4+MDxiKVM9KDMyfGwpLTg3O2Vsc2V7az0hMDticmVha312YXIgQT1JKnQ7aWYoMTA3Mzc0MTgyMzxBKWJyZWFrO2lmKEk9QSxDPUMqdCtTLEIrKywrK249PT1fKXtrPSEwO2JyZWFrfWw9ZS5jaGFyQ29kZUF0KG4pfXU9MzAqYS5fX2tCaXRzUGVyQ2hhclRhYmxlTXVsdGlwbGllci0xO3ZhciBtPTB8KG8qQit1Pj4+YS5fX2tCaXRzUGVyQ2hhclRhYmxlU2hpZnQpLzMwO3IuX19pbnBsYWNlTXVsdGlwbHlBZGQoSSxDLG0pfXdoaWxlKCFrKX1pZihuIT09Xyl7aWYoIWEuX19pc1doaXRlc3BhY2UobCkpcmV0dXJuIG51bGw7Zm9yKG4rKztuPF87bisrKWlmKGw9ZS5jaGFyQ29kZUF0KG4pLCFhLl9faXNXaGl0ZXNwYWNlKGwpKXJldHVybiBudWxsfXJldHVybiByLnNpZ249LTE9PT1pLHIuX190cmltKCl9fSx7a2V5OlwiX19maWxsRnJvbVBhcnRzXCIsdmFsdWU6ZnVuY3Rpb24oZSx0LF8pe2Zvcih2YXIgbj0wLGw9MCxnPTAsbz10Lmxlbmd0aC0xOzA8PW87by0tKXt2YXIgYT10W29dLHU9X1tvXTtsfD1hPDxnLGcrPXUsMzA9PT1nPyhlLl9fc2V0RGlnaXQobisrLGwpLGc9MCxsPTApOjMwPGcmJihlLl9fc2V0RGlnaXQobisrLDEwNzM3NDE4MjMmbCksZy09MzAsbD1hPj4+dS1nKX1pZigwIT09bCl7aWYobj49ZS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiaW1wbGVtZW50YXRpb24gYnVnXCIpO2UuX19zZXREaWdpdChuKyssbCl9Zm9yKDtuPGUubGVuZ3RoO24rKyllLl9fc2V0RGlnaXQobiwwKX19LHtrZXk6XCJfX3RvU3RyaW5nQmFzZVBvd2VyT2ZUd29cIix2YWx1ZTpmdW5jdGlvbihlLHQpe3ZhciBfPWUubGVuZ3RoLG49dC0xO249KDg1Jm4+Pj4xKSsoODUmbiksbj0oNTEmbj4+PjIpKyg1MSZuKSxuPSgxNSZuPj4+NCkrKDE1Jm4pO3ZhciBsPW4sZz10LTEsbz1lLl9fZGlnaXQoXy0xKSx1PWEuX19jbHozMChvKSxzPTB8KDMwKl8tdStsLTEpL2w7aWYoZS5zaWduJiZzKyssMjY4NDM1NDU2PHMpdGhyb3cgbmV3IEVycm9yKFwic3RyaW5nIHRvbyBsb25nXCIpO2Zvcih2YXIgcj1BcnJheShzKSxkPXMtMSxoPTAsYj0wLG09MDttPF8tMTttKyspe3ZhciBjPWUuX19kaWdpdChtKSx2PShofGM8PGIpJmc7cltkLS1dPWEuX19rQ29udmVyc2lvbkNoYXJzW3ZdO3ZhciB5PWwtYjtmb3IoaD1jPj4+eSxiPTMwLXk7Yj49bDspcltkLS1dPWEuX19rQ29udmVyc2lvbkNoYXJzW2gmZ10saD4+Pj1sLGItPWx9dmFyIGY9KGh8bzw8YikmZztmb3IocltkLS1dPWEuX19rQ29udmVyc2lvbkNoYXJzW2ZdLGg9bz4+PmwtYjswIT09aDspcltkLS1dPWEuX19rQ29udmVyc2lvbkNoYXJzW2gmZ10saD4+Pj1sO2lmKGUuc2lnbiYmKHJbZC0tXT1cIi1cIiksLTEhPT1kKXRocm93IG5ldyBFcnJvcihcImltcGxlbWVudGF0aW9uIGJ1Z1wiKTtyZXR1cm4gci5qb2luKFwiXCIpfX0se2tleTpcIl9fdG9TdHJpbmdHZW5lcmljXCIsdmFsdWU6ZnVuY3Rpb24oZSx0LF8pe3ZhciBuPWUubGVuZ3RoO2lmKDA9PT1uKXJldHVyblwiXCI7aWYoMT09PW4pe3ZhciBsPWUuX191bnNpZ25lZERpZ2l0KDApLnRvU3RyaW5nKHQpO3JldHVybiExPT09XyYmZS5zaWduJiYobD1cIi1cIitsKSxsfXZhciBnPTMwKm4tYS5fX2NsejMwKGUuX19kaWdpdChuLTEpKSxvPWEuX19rTWF4Qml0c1BlckNoYXJbdF0sdT1vLTEscz1nKmEuX19rQml0c1BlckNoYXJUYWJsZU11bHRpcGxpZXI7cys9dS0xLHM9MHxzL3U7dmFyIHIsZCxoPXMrMT4+MSxiPWEuZXhwb25lbnRpYXRlKGEuX19vbmVEaWdpdCh0LCExKSxhLl9fb25lRGlnaXQoaCwhMSkpLG09Yi5fX3Vuc2lnbmVkRGlnaXQoMCk7aWYoMT09PWIubGVuZ3RoJiYzMjc2Nz49bSl7cj1uZXcgYShlLmxlbmd0aCwhMSksci5fX2luaXRpYWxpemVEaWdpdHMoKTtmb3IodmFyIGMsdj0wLHk9MiplLmxlbmd0aC0xOzA8PXk7eS0tKWM9djw8MTV8ZS5fX2hhbGZEaWdpdCh5KSxyLl9fc2V0SGFsZkRpZ2l0KHksMHxjL20pLHY9MHxjJW07ZD12LnRvU3RyaW5nKHQpfWVsc2V7dmFyIGY9YS5fX2Fic29sdXRlRGl2TGFyZ2UoZSxiLCEwLCEwKTtyPWYucXVvdGllbnQ7dmFyIEQ9Zi5yZW1haW5kZXIuX190cmltKCk7ZD1hLl9fdG9TdHJpbmdHZW5lcmljKEQsdCwhMCl9ci5fX3RyaW0oKTtmb3IodmFyIHA9YS5fX3RvU3RyaW5nR2VuZXJpYyhyLHQsITApO2QubGVuZ3RoPGg7KWQ9XCIwXCIrZDtyZXR1cm4hMT09PV8mJmUuc2lnbiYmKHA9XCItXCIrcCkscCtkfX0se2tleTpcIl9fdW5lcXVhbFNpZ25cIix2YWx1ZTpmdW5jdGlvbihlKXtyZXR1cm4gZT8tMToxfX0se2tleTpcIl9fYWJzb2x1dGVHcmVhdGVyXCIsdmFsdWU6ZnVuY3Rpb24oZSl7cmV0dXJuIGU/LTE6MX19LHtrZXk6XCJfX2Fic29sdXRlTGVzc1wiLHZhbHVlOmZ1bmN0aW9uKGUpe3JldHVybiBlPzE6LTF9fSx7a2V5OlwiX19jb21wYXJlVG9CaWdJbnRcIix2YWx1ZTpmdW5jdGlvbihlLHQpe3ZhciBpPWUuc2lnbjtpZihpIT09dC5zaWduKXJldHVybiBhLl9fdW5lcXVhbFNpZ24oaSk7dmFyIF89YS5fX2Fic29sdXRlQ29tcGFyZShlLHQpO3JldHVybiAwPF8/YS5fX2Fic29sdXRlR3JlYXRlcihpKTowPl8/YS5fX2Fic29sdXRlTGVzcyhpKTowfX0se2tleTpcIl9fY29tcGFyZVRvTnVtYmVyXCIsdmFsdWU6ZnVuY3Rpb24oZSxpKXtpZihhLl9faXNPbmVEaWdpdEludChpKSl7dmFyIF89ZS5zaWduLG49MD5pO2lmKF8hPT1uKXJldHVybiBhLl9fdW5lcXVhbFNpZ24oXyk7aWYoMD09PWUubGVuZ3RoKXtpZihuKXRocm93IG5ldyBFcnJvcihcImltcGxlbWVudGF0aW9uIGJ1Z1wiKTtyZXR1cm4gMD09PWk/MDotMX1pZigxPGUubGVuZ3RoKXJldHVybiBhLl9fYWJzb2x1dGVHcmVhdGVyKF8pO3ZhciBsPXQoaSksZz1lLl9fdW5zaWduZWREaWdpdCgwKTtyZXR1cm4gZz5sP2EuX19hYnNvbHV0ZUdyZWF0ZXIoXyk6ZzxsP2EuX19hYnNvbHV0ZUxlc3MoXyk6MH1yZXR1cm4gYS5fX2NvbXBhcmVUb0RvdWJsZShlLGkpfX0se2tleTpcIl9fY29tcGFyZVRvRG91YmxlXCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXtpZih0IT09dClyZXR1cm4gdDtpZih0PT09MS8wKXJldHVybi0xO2lmKHQ9PT0tSW5maW5pdHkpcmV0dXJuIDE7dmFyIGk9ZS5zaWduO2lmKGkhPT0wPnQpcmV0dXJuIGEuX191bmVxdWFsU2lnbihpKTtpZigwPT09dCl0aHJvdyBuZXcgRXJyb3IoXCJpbXBsZW1lbnRhdGlvbiBidWc6IHNob3VsZCBiZSBoYW5kbGVkIGVsc2V3aGVyZVwiKTtpZigwPT09ZS5sZW5ndGgpcmV0dXJuLTE7YS5fX2tCaXRDb252ZXJzaW9uRG91YmxlWzBdPXQ7dmFyIF89MjA0NyZhLl9fa0JpdENvbnZlcnNpb25JbnRzWzFdPj4+MjA7aWYoMjA0Nz09Xyl0aHJvdyBuZXcgRXJyb3IoXCJpbXBsZW1lbnRhdGlvbiBidWc6IGhhbmRsZWQgZWxzZXdoZXJlXCIpO3ZhciBuPV8tMTAyMztpZigwPm4pcmV0dXJuIGEuX19hYnNvbHV0ZUdyZWF0ZXIoaSk7dmFyIGw9ZS5sZW5ndGgsZz1lLl9fZGlnaXQobC0xKSxvPWEuX19jbHozMChnKSx1PTMwKmwtbyxzPW4rMTtpZih1PHMpcmV0dXJuIGEuX19hYnNvbHV0ZUxlc3MoaSk7aWYodT5zKXJldHVybiBhLl9fYWJzb2x1dGVHcmVhdGVyKGkpO3ZhciByPTEwNDg1NzZ8MTA0ODU3NSZhLl9fa0JpdENvbnZlcnNpb25JbnRzWzFdLGQ9YS5fX2tCaXRDb252ZXJzaW9uSW50c1swXSxoPTIwLGI9MjktbztpZihiIT09KDB8KHUtMSklMzApKXRocm93IG5ldyBFcnJvcihcImltcGxlbWVudGF0aW9uIGJ1Z1wiKTt2YXIgbSxjPTA7aWYoYjxoKXt2YXIgdj1oLWI7Yz12KzMyLG09cj4+PnYscj1yPDwzMi12fGQ+Pj52LGQ8PD0zMi12fWVsc2UgaWYoYj09PWgpYz0zMixtPXIscj1kLGQ9MDtlbHNle3ZhciB5PWItaDtjPTMyLXksbT1yPDx5fGQ+Pj4zMi15LHI9ZDw8eSxkPTB9aWYoZz4+Pj0wLG0+Pj49MCxnPm0pcmV0dXJuIGEuX19hYnNvbHV0ZUdyZWF0ZXIoaSk7aWYoZzxtKXJldHVybiBhLl9fYWJzb2x1dGVMZXNzKGkpO2Zvcih2YXIgZj1sLTI7MDw9ZjtmLS0pezA8Yz8oYy09MzAsbT1yPj4+MixyPXI8PDMwfGQ+Pj4yLGQ8PD0zMCk6bT0wO3ZhciBEPWUuX191bnNpZ25lZERpZ2l0KGYpO2lmKEQ+bSlyZXR1cm4gYS5fX2Fic29sdXRlR3JlYXRlcihpKTtpZihEPG0pcmV0dXJuIGEuX19hYnNvbHV0ZUxlc3MoaSl9aWYoMCE9PXJ8fDAhPT1kKXtpZigwPT09Yyl0aHJvdyBuZXcgRXJyb3IoXCJpbXBsZW1lbnRhdGlvbiBidWdcIik7cmV0dXJuIGEuX19hYnNvbHV0ZUxlc3MoaSl9cmV0dXJuIDB9fSx7a2V5OlwiX19lcXVhbFRvTnVtYmVyXCIsdmFsdWU6ZnVuY3Rpb24oZSxpKXtyZXR1cm4gYS5fX2lzT25lRGlnaXRJbnQoaSk/MD09PWk/MD09PWUubGVuZ3RoOjE9PT1lLmxlbmd0aCYmZS5zaWduPT09MD5pJiZlLl9fdW5zaWduZWREaWdpdCgwKT09PXQoaSk6MD09PWEuX19jb21wYXJlVG9Eb3VibGUoZSxpKX19LHtrZXk6XCJfX2NvbXBhcmlzb25SZXN1bHRUb0Jvb2xcIix2YWx1ZTpmdW5jdGlvbihlLHQpe3JldHVybiAwPT09dD8wPmU6MT09PXQ/MD49ZToyPT09dD8wPGU6Mz09PXQ/MDw9ZTp2b2lkIDB9fSx7a2V5OlwiX19jb21wYXJlXCIsdmFsdWU6ZnVuY3Rpb24oZSx0LGkpe2lmKGU9YS5fX3RvUHJpbWl0aXZlKGUpLHQ9YS5fX3RvUHJpbWl0aXZlKHQpLFwic3RyaW5nXCI9PXR5cGVvZiBlJiZcInN0cmluZ1wiPT10eXBlb2YgdClzd2l0Y2goaSl7Y2FzZSAwOnJldHVybiBlPHQ7Y2FzZSAxOnJldHVybiBlPD10O2Nhc2UgMjpyZXR1cm4gZT50O2Nhc2UgMzpyZXR1cm4gZT49dDt9aWYoYS5fX2lzQmlnSW50KGUpJiZcInN0cmluZ1wiPT10eXBlb2YgdClyZXR1cm4gdD1hLl9fZnJvbVN0cmluZyh0KSxudWxsIT09dCYmYS5fX2NvbXBhcmlzb25SZXN1bHRUb0Jvb2woYS5fX2NvbXBhcmVUb0JpZ0ludChlLHQpLGkpO2lmKFwic3RyaW5nXCI9PXR5cGVvZiBlJiZhLl9faXNCaWdJbnQodCkpcmV0dXJuIGU9YS5fX2Zyb21TdHJpbmcoZSksbnVsbCE9PWUmJmEuX19jb21wYXJpc29uUmVzdWx0VG9Cb29sKGEuX19jb21wYXJlVG9CaWdJbnQoZSx0KSxpKTtpZihlPWEuX190b051bWVyaWMoZSksdD1hLl9fdG9OdW1lcmljKHQpLGEuX19pc0JpZ0ludChlKSl7aWYoYS5fX2lzQmlnSW50KHQpKXJldHVybiBhLl9fY29tcGFyaXNvblJlc3VsdFRvQm9vbChhLl9fY29tcGFyZVRvQmlnSW50KGUsdCksaSk7aWYoXCJudW1iZXJcIiE9dHlwZW9mIHQpdGhyb3cgbmV3IEVycm9yKFwiaW1wbGVtZW50YXRpb24gYnVnXCIpO3JldHVybiBhLl9fY29tcGFyaXNvblJlc3VsdFRvQm9vbChhLl9fY29tcGFyZVRvTnVtYmVyKGUsdCksaSl9aWYoXCJudW1iZXJcIiE9dHlwZW9mIGUpdGhyb3cgbmV3IEVycm9yKFwiaW1wbGVtZW50YXRpb24gYnVnXCIpO2lmKGEuX19pc0JpZ0ludCh0KSlyZXR1cm4gYS5fX2NvbXBhcmlzb25SZXN1bHRUb0Jvb2woYS5fX2NvbXBhcmVUb051bWJlcih0LGUpLDJeaSk7aWYoXCJudW1iZXJcIiE9dHlwZW9mIHQpdGhyb3cgbmV3IEVycm9yKFwiaW1wbGVtZW50YXRpb24gYnVnXCIpO3JldHVybiAwPT09aT9lPHQ6MT09PWk/ZTw9dDoyPT09aT9lPnQ6Mz09PWk/ZT49dDp2b2lkIDB9fSx7a2V5OlwiX19hYnNvbHV0ZUFkZFwiLHZhbHVlOmZ1bmN0aW9uKGUsdCxfKXtpZihlLmxlbmd0aDx0Lmxlbmd0aClyZXR1cm4gYS5fX2Fic29sdXRlQWRkKHQsZSxfKTtpZigwPT09ZS5sZW5ndGgpcmV0dXJuIGU7aWYoMD09PXQubGVuZ3RoKXJldHVybiBlLnNpZ249PT1fP2U6YS51bmFyeU1pbnVzKGUpO3ZhciBuPWUubGVuZ3RoOygwPT09ZS5fX2Nsem1zZCgpfHx0Lmxlbmd0aD09PWUubGVuZ3RoJiYwPT09dC5fX2Nsem1zZCgpKSYmbisrO2Zvcih2YXIgbCxnPW5ldyBhKG4sXyksbz0wLHU9MDt1PHQubGVuZ3RoO3UrKylsPWUuX19kaWdpdCh1KSt0Ll9fZGlnaXQodSkrbyxvPWw+Pj4zMCxnLl9fc2V0RGlnaXQodSwxMDczNzQxODIzJmwpO2Zvcig7dTxlLmxlbmd0aDt1Kyspe3ZhciBzPWUuX19kaWdpdCh1KStvO289cz4+PjMwLGcuX19zZXREaWdpdCh1LDEwNzM3NDE4MjMmcyl9cmV0dXJuIHU8Zy5sZW5ndGgmJmcuX19zZXREaWdpdCh1LG8pLGcuX190cmltKCl9fSx7a2V5OlwiX19hYnNvbHV0ZVN1YlwiLHZhbHVlOmZ1bmN0aW9uKGUsdCxfKXtpZigwPT09ZS5sZW5ndGgpcmV0dXJuIGU7aWYoMD09PXQubGVuZ3RoKXJldHVybiBlLnNpZ249PT1fP2U6YS51bmFyeU1pbnVzKGUpO2Zvcih2YXIgbixsPW5ldyBhKGUubGVuZ3RoLF8pLGc9MCxvPTA7bzx0Lmxlbmd0aDtvKyspbj1lLl9fZGlnaXQobyktdC5fX2RpZ2l0KG8pLWcsZz0xJm4+Pj4zMCxsLl9fc2V0RGlnaXQobywxMDczNzQxODIzJm4pO2Zvcig7bzxlLmxlbmd0aDtvKyspe3ZhciB1PWUuX19kaWdpdChvKS1nO2c9MSZ1Pj4+MzAsbC5fX3NldERpZ2l0KG8sMTA3Mzc0MTgyMyZ1KX1yZXR1cm4gbC5fX3RyaW0oKX19LHtrZXk6XCJfX2Fic29sdXRlQWRkT25lXCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXt2YXIgXz0yPGFyZ3VtZW50cy5sZW5ndGgmJnZvaWQgMCE9PWFyZ3VtZW50c1syXT9hcmd1bWVudHNbMl06bnVsbCxuPWUubGVuZ3RoO251bGw9PT1fP189bmV3IGEobix0KTpfLnNpZ249dDtmb3IodmFyIGwsZz0xLG89MDtvPG47bysrKWw9ZS5fX2RpZ2l0KG8pK2csZz1sPj4+MzAsXy5fX3NldERpZ2l0KG8sMTA3Mzc0MTgyMyZsKTtyZXR1cm4gMCE9PWcmJl8uX19zZXREaWdpdEdyb3cobiwxKSxffX0se2tleTpcIl9fYWJzb2x1dGVTdWJPbmVcIix2YWx1ZTpmdW5jdGlvbihlLHQpe3ZhciBfPWUubGVuZ3RoO3Q9dHx8Xztmb3IodmFyIG4sbD1uZXcgYSh0LCExKSxnPTEsbz0wO288XztvKyspbj1lLl9fZGlnaXQobyktZyxnPTEmbj4+PjMwLGwuX19zZXREaWdpdChvLDEwNzM3NDE4MjMmbik7aWYoMCE9PWcpdGhyb3cgbmV3IEVycm9yKFwiaW1wbGVtZW50YXRpb24gYnVnXCIpO2Zvcih2YXIgdT1fO3U8dDt1KyspbC5fX3NldERpZ2l0KHUsMCk7cmV0dXJuIGx9fSx7a2V5OlwiX19hYnNvbHV0ZUFuZFwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7dmFyIF89Mjxhcmd1bWVudHMubGVuZ3RoJiZ2b2lkIDAhPT1hcmd1bWVudHNbMl0/YXJndW1lbnRzWzJdOm51bGwsbj1lLmxlbmd0aCxsPXQubGVuZ3RoLGc9bDtpZihuPGwpe2c9bjt2YXIgbz1lLHU9bjtlPXQsbj1sLHQ9byxsPXV9dmFyIHM9ZztudWxsPT09Xz9fPW5ldyBhKHMsITEpOnM9Xy5sZW5ndGg7Zm9yKHZhciByPTA7cjxnO3IrKylfLl9fc2V0RGlnaXQocixlLl9fZGlnaXQocikmdC5fX2RpZ2l0KHIpKTtmb3IoO3I8cztyKyspXy5fX3NldERpZ2l0KHIsMCk7cmV0dXJuIF99fSx7a2V5OlwiX19hYnNvbHV0ZUFuZE5vdFwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7dmFyIF89Mjxhcmd1bWVudHMubGVuZ3RoJiZ2b2lkIDAhPT1hcmd1bWVudHNbMl0/YXJndW1lbnRzWzJdOm51bGwsbj1lLmxlbmd0aCxsPXQubGVuZ3RoLGc9bDtuPGwmJihnPW4pO3ZhciBvPW47bnVsbD09PV8/Xz1uZXcgYShvLCExKTpvPV8ubGVuZ3RoO2Zvcih2YXIgdT0wO3U8Zzt1KyspXy5fX3NldERpZ2l0KHUsZS5fX2RpZ2l0KHUpJn50Ll9fZGlnaXQodSkpO2Zvcig7dTxuO3UrKylfLl9fc2V0RGlnaXQodSxlLl9fZGlnaXQodSkpO2Zvcig7dTxvO3UrKylfLl9fc2V0RGlnaXQodSwwKTtyZXR1cm4gX319LHtrZXk6XCJfX2Fic29sdXRlT3JcIix2YWx1ZTpmdW5jdGlvbihlLHQpe3ZhciBfPTI8YXJndW1lbnRzLmxlbmd0aCYmdm9pZCAwIT09YXJndW1lbnRzWzJdP2FyZ3VtZW50c1syXTpudWxsLG49ZS5sZW5ndGgsbD10Lmxlbmd0aCxnPWw7aWYobjxsKXtnPW47dmFyIG89ZSx1PW47ZT10LG49bCx0PW8sbD11fXZhciBzPW47bnVsbD09PV8/Xz1uZXcgYShzLCExKTpzPV8ubGVuZ3RoO2Zvcih2YXIgcj0wO3I8ZztyKyspXy5fX3NldERpZ2l0KHIsZS5fX2RpZ2l0KHIpfHQuX19kaWdpdChyKSk7Zm9yKDtyPG47cisrKV8uX19zZXREaWdpdChyLGUuX19kaWdpdChyKSk7Zm9yKDtyPHM7cisrKV8uX19zZXREaWdpdChyLDApO3JldHVybiBffX0se2tleTpcIl9fYWJzb2x1dGVYb3JcIix2YWx1ZTpmdW5jdGlvbihlLHQpe3ZhciBfPTI8YXJndW1lbnRzLmxlbmd0aCYmdm9pZCAwIT09YXJndW1lbnRzWzJdP2FyZ3VtZW50c1syXTpudWxsLG49ZS5sZW5ndGgsbD10Lmxlbmd0aCxnPWw7aWYobjxsKXtnPW47dmFyIG89ZSx1PW47ZT10LG49bCx0PW8sbD11fXZhciBzPW47bnVsbD09PV8/Xz1uZXcgYShzLCExKTpzPV8ubGVuZ3RoO2Zvcih2YXIgcj0wO3I8ZztyKyspXy5fX3NldERpZ2l0KHIsZS5fX2RpZ2l0KHIpXnQuX19kaWdpdChyKSk7Zm9yKDtyPG47cisrKV8uX19zZXREaWdpdChyLGUuX19kaWdpdChyKSk7Zm9yKDtyPHM7cisrKV8uX19zZXREaWdpdChyLDApO3JldHVybiBffX0se2tleTpcIl9fYWJzb2x1dGVDb21wYXJlXCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXt2YXIgXz1lLmxlbmd0aC10Lmxlbmd0aDtpZigwIT1fKXJldHVybiBfO2Zvcih2YXIgbj1lLmxlbmd0aC0xOzA8PW4mJmUuX19kaWdpdChuKT09PXQuX19kaWdpdChuKTspbi0tO3JldHVybiAwPm4/MDplLl9fdW5zaWduZWREaWdpdChuKT50Ll9fdW5zaWduZWREaWdpdChuKT8xOi0xfX0se2tleTpcIl9fbXVsdGlwbHlBY2N1bXVsYXRlXCIsdmFsdWU6ZnVuY3Rpb24oZSx0LF8sbil7aWYoMCE9PXQpe2Zvcih2YXIgbD0zMjc2NyZ0LGc9dD4+PjE1LG89MCx1PTAscz0wO3M8ZS5sZW5ndGg7cysrLG4rKyl7dmFyIHI9Xy5fX2RpZ2l0KG4pLGQ9ZS5fX2RpZ2l0KHMpLGg9MzI3NjcmZCxiPWQ+Pj4xNSxtPWEuX19pbXVsKGgsbCksYz1hLl9faW11bChoLGcpLHY9YS5fX2ltdWwoYixsKSx5PWEuX19pbXVsKGIsZyk7cis9dSttK28sbz1yPj4+MzAsciY9MTA3Mzc0MTgyMyxyKz0oKDMyNzY3JmMpPDwxNSkrKCgzMjc2NyZ2KTw8MTUpLG8rPXI+Pj4zMCx1PXkrKGM+Pj4xNSkrKHY+Pj4xNSksXy5fX3NldERpZ2l0KG4sMTA3Mzc0MTgyMyZyKX1mb3IoOzAhPT1vfHwwIT09dTtuKyspe3ZhciBmPV8uX19kaWdpdChuKTtmKz1vK3UsdT0wLG89Zj4+PjMwLF8uX19zZXREaWdpdChuLDEwNzM3NDE4MjMmZil9fX19LHtrZXk6XCJfX2ludGVybmFsTXVsdGlwbHlBZGRcIix2YWx1ZTpmdW5jdGlvbihlLHQsXyxsLGcpe2Zvcih2YXIgbz1fLHU9MCxzPTA7czxsO3MrKyl7dmFyIGQ9ZS5fX2RpZ2l0KHMpLGg9YS5fX2ltdWwoMzI3NjcmZCx0KSxiPWEuX19pbXVsKGQ+Pj4xNSx0KSxtPWgrKCgzMjc2NyZiKTw8MTUpK3UrbztvPW0+Pj4zMCx1PWI+Pj4xNSxnLl9fc2V0RGlnaXQocywxMDczNzQxODIzJm0pfWlmKGcubGVuZ3RoPmwpZm9yKGcuX19zZXREaWdpdChsKyssbyt1KTtsPGcubGVuZ3RoOylnLl9fc2V0RGlnaXQobCsrLDApO2Vsc2UgaWYoMCE9PW8rdSl0aHJvdyBuZXcgRXJyb3IoXCJpbXBsZW1lbnRhdGlvbiBidWdcIil9fSx7a2V5OlwiX19hYnNvbHV0ZURpdlNtYWxsXCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXt2YXIgXz0yPGFyZ3VtZW50cy5sZW5ndGgmJnZvaWQgMCE9PWFyZ3VtZW50c1syXT9hcmd1bWVudHNbMl06bnVsbDtudWxsPT09XyYmKF89bmV3IGEoZS5sZW5ndGgsITEpKTtmb3IodmFyIG49MCxsPTIqZS5sZW5ndGgtMTswPD1sO2wtPTIpe3ZhciBnPShuPDwxNXxlLl9faGFsZkRpZ2l0KGwpKT4+PjAsbz0wfGcvdDtuPTB8ZyV0LGc9KG48PDE1fGUuX19oYWxmRGlnaXQobC0xKSk+Pj4wO3ZhciB1PTB8Zy90O249MHxnJXQsXy5fX3NldERpZ2l0KGw+Pj4xLG88PDE1fHUpfXJldHVybiBffX0se2tleTpcIl9fYWJzb2x1dGVNb2RTbWFsbFwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7Zm9yKHZhciBfLG49MCxsPTIqZS5sZW5ndGgtMTswPD1sO2wtLSlfPShuPDwxNXxlLl9faGFsZkRpZ2l0KGwpKT4+PjAsbj0wfF8ldDtyZXR1cm4gbn19LHtrZXk6XCJfX2Fic29sdXRlRGl2TGFyZ2VcIix2YWx1ZTpmdW5jdGlvbihlLHQsaSxfKXt2YXIgbD10Ll9faGFsZkRpZ2l0TGVuZ3RoKCksbj10Lmxlbmd0aCxnPWUuX19oYWxmRGlnaXRMZW5ndGgoKS1sLG89bnVsbDtpJiYobz1uZXcgYShnKzI+Pj4xLCExKSxvLl9faW5pdGlhbGl6ZURpZ2l0cygpKTt2YXIgcz1uZXcgYShsKzI+Pj4xLCExKTtzLl9faW5pdGlhbGl6ZURpZ2l0cygpO3ZhciByPWEuX19jbHoxNSh0Ll9faGFsZkRpZ2l0KGwtMSkpOzA8ciYmKHQ9YS5fX3NwZWNpYWxMZWZ0U2hpZnQodCxyLDApKTtmb3IodmFyIGQ9YS5fX3NwZWNpYWxMZWZ0U2hpZnQoZSxyLDEpLHU9dC5fX2hhbGZEaWdpdChsLTEpLGg9MCxiPWc7MDw9YjtiLS0pe3ZhciBtPTMyNzY3LHY9ZC5fX2hhbGZEaWdpdChiK2wpO2lmKHYhPT11KXt2YXIgeT0odjw8MTV8ZC5fX2hhbGZEaWdpdChiK2wtMSkpPj4+MDttPTB8eS91O2Zvcih2YXIgZj0wfHkldSxEPXQuX19oYWxmRGlnaXQobC0yKSxwPWQuX19oYWxmRGlnaXQoYitsLTIpO2EuX19pbXVsKG0sRCk+Pj4wPihmPDwxNnxwKT4+PjAmJihtLS0sZis9dSwhKDMyNzY3PGYpKTspO31hLl9faW50ZXJuYWxNdWx0aXBseUFkZCh0LG0sMCxuLHMpO3ZhciBrPWQuX19pbnBsYWNlU3ViKHMsYixsKzEpOzAhPT1rJiYoaz1kLl9faW5wbGFjZUFkZCh0LGIsbCksZC5fX3NldEhhbGZEaWdpdChiK2wsMzI3NjcmZC5fX2hhbGZEaWdpdChiK2wpK2spLG0tLSksaSYmKDEmYj9oPW08PDE1Om8uX19zZXREaWdpdChiPj4+MSxofG0pKX1pZihfKXJldHVybiBkLl9faW5wbGFjZVJpZ2h0U2hpZnQociksaT97cXVvdGllbnQ6byxyZW1haW5kZXI6ZH06ZDtpZihpKXJldHVybiBvO3Rocm93IG5ldyBFcnJvcihcInVucmVhY2hhYmxlXCIpfX0se2tleTpcIl9fY2x6MTVcIix2YWx1ZTpmdW5jdGlvbihlKXtyZXR1cm4gYS5fX2NsejMwKGUpLTE1fX0se2tleTpcIl9fc3BlY2lhbExlZnRTaGlmdFwiLHZhbHVlOmZ1bmN0aW9uKGUsdCxfKXt2YXIgbD1lLmxlbmd0aCxuPW5ldyBhKGwrXywhMSk7aWYoMD09PXQpe2Zvcih2YXIgZz0wO2c8bDtnKyspbi5fX3NldERpZ2l0KGcsZS5fX2RpZ2l0KGcpKTtyZXR1cm4gMDxfJiZuLl9fc2V0RGlnaXQobCwwKSxufWZvcih2YXIgbyx1PTAscz0wO3M8bDtzKyspbz1lLl9fZGlnaXQocyksbi5fX3NldERpZ2l0KHMsMTA3Mzc0MTgyMyZvPDx0fHUpLHU9bz4+PjMwLXQ7cmV0dXJuIDA8XyYmbi5fX3NldERpZ2l0KGwsdSksbn19LHtrZXk6XCJfX2xlZnRTaGlmdEJ5QWJzb2x1dGVcIix2YWx1ZTpmdW5jdGlvbihlLHQpe3ZhciBfPWEuX190b1NoaWZ0QW1vdW50KHQpO2lmKDA+Xyl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkJpZ0ludCB0b28gYmlnXCIpO3ZhciBuPTB8Xy8zMCxsPV8lMzAsZz1lLmxlbmd0aCxvPTAhPT1sJiYwIT1lLl9fZGlnaXQoZy0xKT4+PjMwLWwsdT1nK24rKG8/MTowKSxzPW5ldyBhKHUsZS5zaWduKTtpZigwPT09bCl7Zm9yKHZhciByPTA7cjxuO3IrKylzLl9fc2V0RGlnaXQociwwKTtmb3IoO3I8dTtyKyspcy5fX3NldERpZ2l0KHIsZS5fX2RpZ2l0KHItbikpfWVsc2V7Zm9yKHZhciBoPTAsYj0wO2I8bjtiKyspcy5fX3NldERpZ2l0KGIsMCk7Zm9yKHZhciBtLGM9MDtjPGc7YysrKW09ZS5fX2RpZ2l0KGMpLHMuX19zZXREaWdpdChjK24sMTA3Mzc0MTgyMyZtPDxsfGgpLGg9bT4+PjMwLWw7aWYobylzLl9fc2V0RGlnaXQoZytuLGgpO2Vsc2UgaWYoMCE9PWgpdGhyb3cgbmV3IEVycm9yKFwiaW1wbGVtZW50YXRpb24gYnVnXCIpfXJldHVybiBzLl9fdHJpbSgpfX0se2tleTpcIl9fcmlnaHRTaGlmdEJ5QWJzb2x1dGVcIix2YWx1ZTpmdW5jdGlvbihlLHQpe3ZhciBfPWUubGVuZ3RoLG49ZS5zaWduLGw9YS5fX3RvU2hpZnRBbW91bnQodCk7aWYoMD5sKXJldHVybiBhLl9fcmlnaHRTaGlmdEJ5TWF4aW11bShuKTt2YXIgZz0wfGwvMzAsbz1sJTMwLHU9Xy1nO2lmKDA+PXUpcmV0dXJuIGEuX19yaWdodFNoaWZ0QnlNYXhpbXVtKG4pO3ZhciBzPSExO2lmKG4pe2lmKDAhPShlLl9fZGlnaXQoZykmKDE8PG8pLTEpKXM9ITA7ZWxzZSBmb3IodmFyIHI9MDtyPGc7cisrKWlmKDAhPT1lLl9fZGlnaXQocikpe3M9ITA7YnJlYWt9fWlmKHMmJjA9PT1vKXt2YXIgaD1lLl9fZGlnaXQoXy0xKTswPT1+aCYmdSsrfXZhciBiPW5ldyBhKHUsbik7aWYoMD09PW8pe2IuX19zZXREaWdpdCh1LTEsMCk7Zm9yKHZhciBtPWc7bTxfO20rKyliLl9fc2V0RGlnaXQobS1nLGUuX19kaWdpdChtKSl9ZWxzZXtmb3IodmFyIGMsdj1lLl9fZGlnaXQoZyk+Pj5vLHk9Xy1nLTEsZj0wO2Y8eTtmKyspYz1lLl9fZGlnaXQoZitnKzEpLGIuX19zZXREaWdpdChmLDEwNzM3NDE4MjMmYzw8MzAtb3x2KSx2PWM+Pj5vO2IuX19zZXREaWdpdCh5LHYpfXJldHVybiBzJiYoYj1hLl9fYWJzb2x1dGVBZGRPbmUoYiwhMCxiKSksYi5fX3RyaW0oKX19LHtrZXk6XCJfX3JpZ2h0U2hpZnRCeU1heGltdW1cIix2YWx1ZTpmdW5jdGlvbihlKXtyZXR1cm4gZT9hLl9fb25lRGlnaXQoMSwhMCk6YS5fX3plcm8oKX19LHtrZXk6XCJfX3RvU2hpZnRBbW91bnRcIix2YWx1ZTpmdW5jdGlvbihlKXtpZigxPGUubGVuZ3RoKXJldHVybi0xO3ZhciB0PWUuX191bnNpZ25lZERpZ2l0KDApO3JldHVybiB0PmEuX19rTWF4TGVuZ3RoQml0cz8tMTp0fX0se2tleTpcIl9fdG9QcmltaXRpdmVcIix2YWx1ZTpmdW5jdGlvbihlKXt2YXIgdD0xPGFyZ3VtZW50cy5sZW5ndGgmJnZvaWQgMCE9PWFyZ3VtZW50c1sxXT9hcmd1bWVudHNbMV06XCJkZWZhdWx0XCI7aWYoXCJvYmplY3RcIiE9PWkoZSkpcmV0dXJuIGU7aWYoZS5jb25zdHJ1Y3Rvcj09PWEpcmV0dXJuIGU7aWYoXCJ1bmRlZmluZWRcIiE9dHlwZW9mIFN5bWJvbCYmXCJzeW1ib2xcIj09PWkoU3ltYm9sLnRvUHJpbWl0aXZlKSl7dmFyIF89ZVtTeW1ib2wudG9QcmltaXRpdmVdO2lmKF8pe3ZhciBuPV8odCk7aWYoXCJvYmplY3RcIiE9PWkobikpcmV0dXJuIG47dGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjb252ZXJ0IG9iamVjdCB0byBwcmltaXRpdmUgdmFsdWVcIil9fXZhciBsPWUudmFsdWVPZjtpZihsKXt2YXIgZz1sLmNhbGwoZSk7aWYoXCJvYmplY3RcIiE9PWkoZykpcmV0dXJuIGd9dmFyIG89ZS50b1N0cmluZztpZihvKXt2YXIgdT1vLmNhbGwoZSk7aWYoXCJvYmplY3RcIiE9PWkodSkpcmV0dXJuIHV9dGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjb252ZXJ0IG9iamVjdCB0byBwcmltaXRpdmUgdmFsdWVcIil9fSx7a2V5OlwiX190b051bWVyaWNcIix2YWx1ZTpmdW5jdGlvbihlKXtyZXR1cm4gYS5fX2lzQmlnSW50KGUpP2U6K2V9fSx7a2V5OlwiX19pc0JpZ0ludFwiLHZhbHVlOmZ1bmN0aW9uKGUpe3JldHVyblwib2JqZWN0XCI9PT1pKGUpJiZudWxsIT09ZSYmZS5jb25zdHJ1Y3Rvcj09PWF9fSx7a2V5OlwiX190cnVuY2F0ZVRvTkJpdHNcIix2YWx1ZTpmdW5jdGlvbihlLHQpe2Zvcih2YXIgXz0wfChlKzI5KS8zMCxuPW5ldyBhKF8sdC5zaWduKSxsPV8tMSxnPTA7ZzxsO2crKyluLl9fc2V0RGlnaXQoZyx0Ll9fZGlnaXQoZykpO3ZhciBvPXQuX19kaWdpdChsKTtpZigwIT1lJTMwKXt2YXIgdT0zMi1lJTMwO289bzw8dT4+PnV9cmV0dXJuIG4uX19zZXREaWdpdChsLG8pLG4uX190cmltKCl9fSx7a2V5OlwiX190cnVuY2F0ZUFuZFN1YkZyb21Qb3dlck9mVHdvXCIsdmFsdWU6ZnVuY3Rpb24oZSx0LF8pe2Zvcih2YXIgbj1NYXRoLm1pbixsLGc9MHwoZSsyOSkvMzAsbz1uZXcgYShnLF8pLHU9MCxzPWctMSxkPTAsaD1uKHMsdC5sZW5ndGgpO3U8aDt1KyspbD0wLXQuX19kaWdpdCh1KS1kLGQ9MSZsPj4+MzAsby5fX3NldERpZ2l0KHUsMTA3Mzc0MTgyMyZsKTtmb3IoO3U8czt1Kyspby5fX3NldERpZ2l0KHUsMHwxMDczNzQxODIzJi1kKTt2YXIgYixtPXM8dC5sZW5ndGg/dC5fX2RpZ2l0KHMpOjAsYz1lJTMwO2lmKDA9PT1jKWI9MC1tLWQsYiY9MTA3Mzc0MTgyMztlbHNle3ZhciB2PTMyLWM7bT1tPDx2Pj4+djt2YXIgeT0xPDwzMi12O2I9eS1tLWQsYiY9eS0xfXJldHVybiBvLl9fc2V0RGlnaXQocyxiKSxvLl9fdHJpbSgpfX0se2tleTpcIl9fZGlnaXRQb3dcIix2YWx1ZTpmdW5jdGlvbihlLHQpe2Zvcih2YXIgaT0xOzA8dDspMSZ0JiYoaSo9ZSksdD4+Pj0xLGUqPWU7cmV0dXJuIGl9fSx7a2V5OlwiX19pc09uZURpZ2l0SW50XCIsdmFsdWU6ZnVuY3Rpb24oZSl7cmV0dXJuKDEwNzM3NDE4MjMmZSk9PT1lfX1dKSxhfShoKEFycmF5KSk7cmV0dXJuIFMuX19rTWF4TGVuZ3RoPTMzNTU0NDMyLFMuX19rTWF4TGVuZ3RoQml0cz1TLl9fa01heExlbmd0aDw8NSxTLl9fa01heEJpdHNQZXJDaGFyPVswLDAsMzIsNTEsNjQsNzUsODMsOTAsOTYsMTAyLDEwNywxMTEsMTE1LDExOSwxMjIsMTI2LDEyOCwxMzEsMTM0LDEzNiwxMzksMTQxLDE0MywxNDUsMTQ3LDE0OSwxNTEsMTUzLDE1NCwxNTYsMTU4LDE1OSwxNjAsMTYyLDE2MywxNjUsMTY2XSxTLl9fa0JpdHNQZXJDaGFyVGFibGVTaGlmdD01LFMuX19rQml0c1BlckNoYXJUYWJsZU11bHRpcGxpZXI9MTw8Uy5fX2tCaXRzUGVyQ2hhclRhYmxlU2hpZnQsUy5fX2tDb252ZXJzaW9uQ2hhcnM9W1wiMFwiLFwiMVwiLFwiMlwiLFwiM1wiLFwiNFwiLFwiNVwiLFwiNlwiLFwiN1wiLFwiOFwiLFwiOVwiLFwiYVwiLFwiYlwiLFwiY1wiLFwiZFwiLFwiZVwiLFwiZlwiLFwiZ1wiLFwiaFwiLFwiaVwiLFwialwiLFwia1wiLFwibFwiLFwibVwiLFwiblwiLFwib1wiLFwicFwiLFwicVwiLFwiclwiLFwic1wiLFwidFwiLFwidVwiLFwidlwiLFwid1wiLFwieFwiLFwieVwiLFwielwiXSxTLl9fa0JpdENvbnZlcnNpb25CdWZmZXI9bmV3IEFycmF5QnVmZmVyKDgpLFMuX19rQml0Q29udmVyc2lvbkRvdWJsZT1uZXcgRmxvYXQ2NEFycmF5KFMuX19rQml0Q29udmVyc2lvbkJ1ZmZlciksUy5fX2tCaXRDb252ZXJzaW9uSW50cz1uZXcgSW50MzJBcnJheShTLl9fa0JpdENvbnZlcnNpb25CdWZmZXIpLFMuX19jbHozMD10P2Z1bmN0aW9uKGUpe3JldHVybiB0KGUpLTJ9OmZ1bmN0aW9uKGUpe3ZhciB0PU1hdGguTE4yLGk9TWF0aC5sb2c7cmV0dXJuIDA9PT1lPzMwOjB8MjktKDB8aShlPj4+MCkvdCl9LFMuX19pbXVsPWV8fGZ1bmN0aW9uKGUsdCl7cmV0dXJuIDB8ZSp0fSxTfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1qc2JpLXVtZC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///499\n')},379:module=>{"use strict";eval('\n\nvar stylesInDOM = [];\n\nfunction getIndexByIdentifier(identifier) {\n  var result = -1;\n\n  for (var i = 0; i < stylesInDOM.length; i++) {\n    if (stylesInDOM[i].identifier === identifier) {\n      result = i;\n      break;\n    }\n  }\n\n  return result;\n}\n\nfunction modulesToDom(list, options) {\n  var idCountMap = {};\n  var identifiers = [];\n\n  for (var i = 0; i < list.length; i++) {\n    var item = list[i];\n    var id = options.base ? item[0] + options.base : item[0];\n    var count = idCountMap[id] || 0;\n    var identifier = "".concat(id, " ").concat(count);\n    idCountMap[id] = count + 1;\n    var indexByIdentifier = getIndexByIdentifier(identifier);\n    var obj = {\n      css: item[1],\n      media: item[2],\n      sourceMap: item[3],\n      supports: item[4],\n      layer: item[5]\n    };\n\n    if (indexByIdentifier !== -1) {\n      stylesInDOM[indexByIdentifier].references++;\n      stylesInDOM[indexByIdentifier].updater(obj);\n    } else {\n      var updater = addElementStyle(obj, options);\n      options.byIndex = i;\n      stylesInDOM.splice(i, 0, {\n        identifier: identifier,\n        updater: updater,\n        references: 1\n      });\n    }\n\n    identifiers.push(identifier);\n  }\n\n  return identifiers;\n}\n\nfunction addElementStyle(obj, options) {\n  var api = options.domAPI(options);\n  api.update(obj);\n\n  var updater = function updater(newObj) {\n    if (newObj) {\n      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap && newObj.supports === obj.supports && newObj.layer === obj.layer) {\n        return;\n      }\n\n      api.update(obj = newObj);\n    } else {\n      api.remove();\n    }\n  };\n\n  return updater;\n}\n\nmodule.exports = function (list, options) {\n  options = options || {};\n  list = list || [];\n  var lastIdentifiers = modulesToDom(list, options);\n  return function update(newList) {\n    newList = newList || [];\n\n    for (var i = 0; i < lastIdentifiers.length; i++) {\n      var identifier = lastIdentifiers[i];\n      var index = getIndexByIdentifier(identifier);\n      stylesInDOM[index].references--;\n    }\n\n    var newLastIdentifiers = modulesToDom(newList, options);\n\n    for (var _i = 0; _i < lastIdentifiers.length; _i++) {\n      var _identifier = lastIdentifiers[_i];\n\n      var _index = getIndexByIdentifier(_identifier);\n\n      if (stylesInDOM[_index].references === 0) {\n        stylesInDOM[_index].updater();\n\n        stylesInDOM.splice(_index, 1);\n      }\n    }\n\n    lastIdentifiers = newLastIdentifiers;\n  };\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzc5LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViOztBQUVBO0FBQ0E7O0FBRUEsa0JBQWtCLHdCQUF3QjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixpQkFBaUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQiw0QkFBNEI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEscUJBQXFCLDZCQUE2QjtBQUNsRDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90b2RvLWxpc3QvLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbmplY3RTdHlsZXNJbnRvU3R5bGVUYWcuanM/MmRiYSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxudmFyIHN0eWxlc0luRE9NID0gW107XG5cbmZ1bmN0aW9uIGdldEluZGV4QnlJZGVudGlmaWVyKGlkZW50aWZpZXIpIHtcbiAgdmFyIHJlc3VsdCA9IC0xO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3R5bGVzSW5ET00ubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoc3R5bGVzSW5ET01baV0uaWRlbnRpZmllciA9PT0gaWRlbnRpZmllcikge1xuICAgICAgcmVzdWx0ID0gaTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIG1vZHVsZXNUb0RvbShsaXN0LCBvcHRpb25zKSB7XG4gIHZhciBpZENvdW50TWFwID0ge307XG4gIHZhciBpZGVudGlmaWVycyA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBpdGVtID0gbGlzdFtpXTtcbiAgICB2YXIgaWQgPSBvcHRpb25zLmJhc2UgPyBpdGVtWzBdICsgb3B0aW9ucy5iYXNlIDogaXRlbVswXTtcbiAgICB2YXIgY291bnQgPSBpZENvdW50TWFwW2lkXSB8fCAwO1xuICAgIHZhciBpZGVudGlmaWVyID0gXCJcIi5jb25jYXQoaWQsIFwiIFwiKS5jb25jYXQoY291bnQpO1xuICAgIGlkQ291bnRNYXBbaWRdID0gY291bnQgKyAxO1xuICAgIHZhciBpbmRleEJ5SWRlbnRpZmllciA9IGdldEluZGV4QnlJZGVudGlmaWVyKGlkZW50aWZpZXIpO1xuICAgIHZhciBvYmogPSB7XG4gICAgICBjc3M6IGl0ZW1bMV0sXG4gICAgICBtZWRpYTogaXRlbVsyXSxcbiAgICAgIHNvdXJjZU1hcDogaXRlbVszXSxcbiAgICAgIHN1cHBvcnRzOiBpdGVtWzRdLFxuICAgICAgbGF5ZXI6IGl0ZW1bNV1cbiAgICB9O1xuXG4gICAgaWYgKGluZGV4QnlJZGVudGlmaWVyICE9PSAtMSkge1xuICAgICAgc3R5bGVzSW5ET01baW5kZXhCeUlkZW50aWZpZXJdLnJlZmVyZW5jZXMrKztcbiAgICAgIHN0eWxlc0luRE9NW2luZGV4QnlJZGVudGlmaWVyXS51cGRhdGVyKG9iaik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciB1cGRhdGVyID0gYWRkRWxlbWVudFN0eWxlKG9iaiwgb3B0aW9ucyk7XG4gICAgICBvcHRpb25zLmJ5SW5kZXggPSBpO1xuICAgICAgc3R5bGVzSW5ET00uc3BsaWNlKGksIDAsIHtcbiAgICAgICAgaWRlbnRpZmllcjogaWRlbnRpZmllcixcbiAgICAgICAgdXBkYXRlcjogdXBkYXRlcixcbiAgICAgICAgcmVmZXJlbmNlczogMVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWRlbnRpZmllcnMucHVzaChpZGVudGlmaWVyKTtcbiAgfVxuXG4gIHJldHVybiBpZGVudGlmaWVycztcbn1cblxuZnVuY3Rpb24gYWRkRWxlbWVudFN0eWxlKG9iaiwgb3B0aW9ucykge1xuICB2YXIgYXBpID0gb3B0aW9ucy5kb21BUEkob3B0aW9ucyk7XG4gIGFwaS51cGRhdGUob2JqKTtcblxuICB2YXIgdXBkYXRlciA9IGZ1bmN0aW9uIHVwZGF0ZXIobmV3T2JqKSB7XG4gICAgaWYgKG5ld09iaikge1xuICAgICAgaWYgKG5ld09iai5jc3MgPT09IG9iai5jc3MgJiYgbmV3T2JqLm1lZGlhID09PSBvYmoubWVkaWEgJiYgbmV3T2JqLnNvdXJjZU1hcCA9PT0gb2JqLnNvdXJjZU1hcCAmJiBuZXdPYmouc3VwcG9ydHMgPT09IG9iai5zdXBwb3J0cyAmJiBuZXdPYmoubGF5ZXIgPT09IG9iai5sYXllcikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGFwaS51cGRhdGUob2JqID0gbmV3T2JqKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXBpLnJlbW92ZSgpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gdXBkYXRlcjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobGlzdCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgbGlzdCA9IGxpc3QgfHwgW107XG4gIHZhciBsYXN0SWRlbnRpZmllcnMgPSBtb2R1bGVzVG9Eb20obGlzdCwgb3B0aW9ucyk7XG4gIHJldHVybiBmdW5jdGlvbiB1cGRhdGUobmV3TGlzdCkge1xuICAgIG5ld0xpc3QgPSBuZXdMaXN0IHx8IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXN0SWRlbnRpZmllcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBpZGVudGlmaWVyID0gbGFzdElkZW50aWZpZXJzW2ldO1xuICAgICAgdmFyIGluZGV4ID0gZ2V0SW5kZXhCeUlkZW50aWZpZXIoaWRlbnRpZmllcik7XG4gICAgICBzdHlsZXNJbkRPTVtpbmRleF0ucmVmZXJlbmNlcy0tO1xuICAgIH1cblxuICAgIHZhciBuZXdMYXN0SWRlbnRpZmllcnMgPSBtb2R1bGVzVG9Eb20obmV3TGlzdCwgb3B0aW9ucyk7XG5cbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgbGFzdElkZW50aWZpZXJzLmxlbmd0aDsgX2krKykge1xuICAgICAgdmFyIF9pZGVudGlmaWVyID0gbGFzdElkZW50aWZpZXJzW19pXTtcblxuICAgICAgdmFyIF9pbmRleCA9IGdldEluZGV4QnlJZGVudGlmaWVyKF9pZGVudGlmaWVyKTtcblxuICAgICAgaWYgKHN0eWxlc0luRE9NW19pbmRleF0ucmVmZXJlbmNlcyA9PT0gMCkge1xuICAgICAgICBzdHlsZXNJbkRPTVtfaW5kZXhdLnVwZGF0ZXIoKTtcblxuICAgICAgICBzdHlsZXNJbkRPTS5zcGxpY2UoX2luZGV4LCAxKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsYXN0SWRlbnRpZmllcnMgPSBuZXdMYXN0SWRlbnRpZmllcnM7XG4gIH07XG59OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///379\n')},569:module=>{"use strict";eval('\n\nvar memo = {};\n/* istanbul ignore next  */\n\nfunction getTarget(target) {\n  if (typeof memo[target] === "undefined") {\n    var styleTarget = document.querySelector(target); // Special case to return head of iframe instead of iframe itself\n\n    if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n      try {\n        // This will throw an exception if access to iframe is blocked\n        // due to cross-origin restrictions\n        styleTarget = styleTarget.contentDocument.head;\n      } catch (e) {\n        // istanbul ignore next\n        styleTarget = null;\n      }\n    }\n\n    memo[target] = styleTarget;\n  }\n\n  return memo[target];\n}\n/* istanbul ignore next  */\n\n\nfunction insertBySelector(insert, style) {\n  var target = getTarget(insert);\n\n  if (!target) {\n    throw new Error("Couldn\'t find a style target. This probably means that the value for the \'insert\' parameter is invalid.");\n  }\n\n  target.appendChild(style);\n}\n\nmodule.exports = insertBySelector;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTY5LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNEQUFzRDs7QUFFdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3RvZG8tbGlzdC8uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luc2VydEJ5U2VsZWN0b3IuanM/YjIxNCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxudmFyIG1lbW8gPSB7fTtcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICAqL1xuXG5mdW5jdGlvbiBnZXRUYXJnZXQodGFyZ2V0KSB7XG4gIGlmICh0eXBlb2YgbWVtb1t0YXJnZXRdID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgdmFyIHN0eWxlVGFyZ2V0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0YXJnZXQpOyAvLyBTcGVjaWFsIGNhc2UgdG8gcmV0dXJuIGhlYWQgb2YgaWZyYW1lIGluc3RlYWQgb2YgaWZyYW1lIGl0c2VsZlxuXG4gICAgaWYgKHdpbmRvdy5IVE1MSUZyYW1lRWxlbWVudCAmJiBzdHlsZVRhcmdldCBpbnN0YW5jZW9mIHdpbmRvdy5IVE1MSUZyYW1lRWxlbWVudCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gVGhpcyB3aWxsIHRocm93IGFuIGV4Y2VwdGlvbiBpZiBhY2Nlc3MgdG8gaWZyYW1lIGlzIGJsb2NrZWRcbiAgICAgICAgLy8gZHVlIHRvIGNyb3NzLW9yaWdpbiByZXN0cmljdGlvbnNcbiAgICAgICAgc3R5bGVUYXJnZXQgPSBzdHlsZVRhcmdldC5jb250ZW50RG9jdW1lbnQuaGVhZDtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gaXN0YW5idWwgaWdub3JlIG5leHRcbiAgICAgICAgc3R5bGVUYXJnZXQgPSBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIG1lbW9bdGFyZ2V0XSA9IHN0eWxlVGFyZ2V0O1xuICB9XG5cbiAgcmV0dXJuIG1lbW9bdGFyZ2V0XTtcbn1cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICAqL1xuXG5cbmZ1bmN0aW9uIGluc2VydEJ5U2VsZWN0b3IoaW5zZXJ0LCBzdHlsZSkge1xuICB2YXIgdGFyZ2V0ID0gZ2V0VGFyZ2V0KGluc2VydCk7XG5cbiAgaWYgKCF0YXJnZXQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZG4ndCBmaW5kIGEgc3R5bGUgdGFyZ2V0LiBUaGlzIHByb2JhYmx5IG1lYW5zIHRoYXQgdGhlIHZhbHVlIGZvciB0aGUgJ2luc2VydCcgcGFyYW1ldGVyIGlzIGludmFsaWQuXCIpO1xuICB9XG5cbiAgdGFyZ2V0LmFwcGVuZENoaWxkKHN0eWxlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpbnNlcnRCeVNlbGVjdG9yOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///569\n')},216:module=>{"use strict";eval('\n\n/* istanbul ignore next  */\nfunction insertStyleElement(options) {\n  var element = document.createElement("style");\n  options.setAttributes(element, options.attributes);\n  options.insert(element, options.options);\n  return element;\n}\n\nmodule.exports = insertStyleElement;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjE2LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdG9kby1saXN0Ly4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5zZXJ0U3R5bGVFbGVtZW50LmpzP2RlNmMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICAqL1xuZnVuY3Rpb24gaW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMpIHtcbiAgdmFyIGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XG4gIG9wdGlvbnMuc2V0QXR0cmlidXRlcyhlbGVtZW50LCBvcHRpb25zLmF0dHJpYnV0ZXMpO1xuICBvcHRpb25zLmluc2VydChlbGVtZW50LCBvcHRpb25zLm9wdGlvbnMpO1xuICByZXR1cm4gZWxlbWVudDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpbnNlcnRTdHlsZUVsZW1lbnQ7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///216\n')},565:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval('\n\n/* istanbul ignore next  */\nfunction setAttributesWithoutAttributes(styleElement) {\n  var nonce =  true ? __webpack_require__.nc : 0;\n\n  if (nonce) {\n    styleElement.setAttribute("nonce", nonce);\n  }\n}\n\nmodule.exports = setAttributesWithoutAttributes;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTY1LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQSxjQUFjLEtBQXdDLEdBQUcsc0JBQWlCLEdBQUcsQ0FBSTs7QUFFakY7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90b2RvLWxpc3QvLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9zZXRBdHRyaWJ1dGVzV2l0aG91dEF0dHJpYnV0ZXMuanM/ZGRjZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgICovXG5mdW5jdGlvbiBzZXRBdHRyaWJ1dGVzV2l0aG91dEF0dHJpYnV0ZXMoc3R5bGVFbGVtZW50KSB7XG4gIHZhciBub25jZSA9IHR5cGVvZiBfX3dlYnBhY2tfbm9uY2VfXyAhPT0gXCJ1bmRlZmluZWRcIiA/IF9fd2VicGFja19ub25jZV9fIDogbnVsbDtcblxuICBpZiAobm9uY2UpIHtcbiAgICBzdHlsZUVsZW1lbnQuc2V0QXR0cmlidXRlKFwibm9uY2VcIiwgbm9uY2UpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2V0QXR0cmlidXRlc1dpdGhvdXRBdHRyaWJ1dGVzOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///565\n')},795:module=>{"use strict";eval('\n\n/* istanbul ignore next  */\nfunction apply(styleElement, options, obj) {\n  var css = "";\n\n  if (obj.supports) {\n    css += "@supports (".concat(obj.supports, ") {");\n  }\n\n  if (obj.media) {\n    css += "@media ".concat(obj.media, " {");\n  }\n\n  var needLayer = typeof obj.layer !== "undefined";\n\n  if (needLayer) {\n    css += "@layer".concat(obj.layer.length > 0 ? " ".concat(obj.layer) : "", " {");\n  }\n\n  css += obj.css;\n\n  if (needLayer) {\n    css += "}";\n  }\n\n  if (obj.media) {\n    css += "}";\n  }\n\n  if (obj.supports) {\n    css += "}";\n  }\n\n  var sourceMap = obj.sourceMap;\n\n  if (sourceMap && typeof btoa !== "undefined") {\n    css += "\\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), " */");\n  } // For old IE\n\n  /* istanbul ignore if  */\n\n\n  options.styleTagTransform(css, styleElement, options.options);\n}\n\nfunction removeStyleElement(styleElement) {\n  // istanbul ignore if\n  if (styleElement.parentNode === null) {\n    return false;\n  }\n\n  styleElement.parentNode.removeChild(styleElement);\n}\n/* istanbul ignore next  */\n\n\nfunction domAPI(options) {\n  var styleElement = options.insertStyleElement(options);\n  return {\n    update: function update(obj) {\n      apply(styleElement, options, obj);\n    },\n    remove: function remove() {\n      removeStyleElement(styleElement);\n    }\n  };\n}\n\nmodule.exports = domAPI;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzk1LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtEQUFrRDtBQUNsRDs7QUFFQTtBQUNBLDBDQUEwQztBQUMxQzs7QUFFQTs7QUFFQTtBQUNBLGlGQUFpRjtBQUNqRjs7QUFFQTs7QUFFQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTs7QUFFQTtBQUNBLHlEQUF5RDtBQUN6RCxJQUFJOztBQUVKOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90b2RvLWxpc3QvLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9zdHlsZURvbUFQSS5qcz9lNDc5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAgKi9cbmZ1bmN0aW9uIGFwcGx5KHN0eWxlRWxlbWVudCwgb3B0aW9ucywgb2JqKSB7XG4gIHZhciBjc3MgPSBcIlwiO1xuXG4gIGlmIChvYmouc3VwcG9ydHMpIHtcbiAgICBjc3MgKz0gXCJAc3VwcG9ydHMgKFwiLmNvbmNhdChvYmouc3VwcG9ydHMsIFwiKSB7XCIpO1xuICB9XG5cbiAgaWYgKG9iai5tZWRpYSkge1xuICAgIGNzcyArPSBcIkBtZWRpYSBcIi5jb25jYXQob2JqLm1lZGlhLCBcIiB7XCIpO1xuICB9XG5cbiAgdmFyIG5lZWRMYXllciA9IHR5cGVvZiBvYmoubGF5ZXIgIT09IFwidW5kZWZpbmVkXCI7XG5cbiAgaWYgKG5lZWRMYXllcikge1xuICAgIGNzcyArPSBcIkBsYXllclwiLmNvbmNhdChvYmoubGF5ZXIubGVuZ3RoID4gMCA/IFwiIFwiLmNvbmNhdChvYmoubGF5ZXIpIDogXCJcIiwgXCIge1wiKTtcbiAgfVxuXG4gIGNzcyArPSBvYmouY3NzO1xuXG4gIGlmIChuZWVkTGF5ZXIpIHtcbiAgICBjc3MgKz0gXCJ9XCI7XG4gIH1cblxuICBpZiAob2JqLm1lZGlhKSB7XG4gICAgY3NzICs9IFwifVwiO1xuICB9XG5cbiAgaWYgKG9iai5zdXBwb3J0cykge1xuICAgIGNzcyArPSBcIn1cIjtcbiAgfVxuXG4gIHZhciBzb3VyY2VNYXAgPSBvYmouc291cmNlTWFwO1xuXG4gIGlmIChzb3VyY2VNYXAgJiYgdHlwZW9mIGJ0b2EgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBjc3MgKz0gXCJcXG4vKiMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LFwiLmNvbmNhdChidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpLCBcIiAqL1wiKTtcbiAgfSAvLyBGb3Igb2xkIElFXG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICAqL1xuXG5cbiAgb3B0aW9ucy5zdHlsZVRhZ1RyYW5zZm9ybShjc3MsIHN0eWxlRWxlbWVudCwgb3B0aW9ucy5vcHRpb25zKTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlRWxlbWVudCkge1xuICAvLyBpc3RhbmJ1bCBpZ25vcmUgaWZcbiAgaWYgKHN0eWxlRWxlbWVudC5wYXJlbnROb2RlID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgc3R5bGVFbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3R5bGVFbGVtZW50KTtcbn1cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICAqL1xuXG5cbmZ1bmN0aW9uIGRvbUFQSShvcHRpb25zKSB7XG4gIHZhciBzdHlsZUVsZW1lbnQgPSBvcHRpb25zLmluc2VydFN0eWxlRWxlbWVudChvcHRpb25zKTtcbiAgcmV0dXJuIHtcbiAgICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZShvYmopIHtcbiAgICAgIGFwcGx5KHN0eWxlRWxlbWVudCwgb3B0aW9ucywgb2JqKTtcbiAgICB9LFxuICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKCkge1xuICAgICAgcmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlRWxlbWVudCk7XG4gICAgfVxuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGRvbUFQSTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///795\n')},589:module=>{"use strict";eval("\n\n/* istanbul ignore next  */\nfunction styleTagTransform(css, styleElement) {\n  if (styleElement.styleSheet) {\n    styleElement.styleSheet.cssText = css;\n  } else {\n    while (styleElement.firstChild) {\n      styleElement.removeChild(styleElement.firstChild);\n    }\n\n    styleElement.appendChild(document.createTextNode(css));\n  }\n}\n\nmodule.exports = styleTagTransform;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTg5LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90b2RvLWxpc3QvLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9zdHlsZVRhZ1RyYW5zZm9ybS5qcz8xZGRlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAgKi9cbmZ1bmN0aW9uIHN0eWxlVGFnVHJhbnNmb3JtKGNzcywgc3R5bGVFbGVtZW50KSB7XG4gIGlmIChzdHlsZUVsZW1lbnQuc3R5bGVTaGVldCkge1xuICAgIHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0LmNzc1RleHQgPSBjc3M7XG4gIH0gZWxzZSB7XG4gICAgd2hpbGUgKHN0eWxlRWxlbWVudC5maXJzdENoaWxkKSB7XG4gICAgICBzdHlsZUVsZW1lbnQucmVtb3ZlQ2hpbGQoc3R5bGVFbGVtZW50LmZpcnN0Q2hpbGQpO1xuICAgIH1cblxuICAgIHN0eWxlRWxlbWVudC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0eWxlVGFnVHJhbnNmb3JtOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///589\n")},586:(__unused_webpack_module,__unused_webpack___webpack_exports__,__webpack_require__)=>{"use strict";eval("\n// EXTERNAL MODULE: ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\nvar injectStylesIntoStyleTag = __webpack_require__(379);\nvar injectStylesIntoStyleTag_default = /*#__PURE__*/__webpack_require__.n(injectStylesIntoStyleTag);\n// EXTERNAL MODULE: ./node_modules/style-loader/dist/runtime/styleDomAPI.js\nvar styleDomAPI = __webpack_require__(795);\nvar styleDomAPI_default = /*#__PURE__*/__webpack_require__.n(styleDomAPI);\n// EXTERNAL MODULE: ./node_modules/style-loader/dist/runtime/insertBySelector.js\nvar insertBySelector = __webpack_require__(569);\nvar insertBySelector_default = /*#__PURE__*/__webpack_require__.n(insertBySelector);\n// EXTERNAL MODULE: ./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js\nvar setAttributesWithoutAttributes = __webpack_require__(565);\nvar setAttributesWithoutAttributes_default = /*#__PURE__*/__webpack_require__.n(setAttributesWithoutAttributes);\n// EXTERNAL MODULE: ./node_modules/style-loader/dist/runtime/insertStyleElement.js\nvar insertStyleElement = __webpack_require__(216);\nvar insertStyleElement_default = /*#__PURE__*/__webpack_require__.n(insertStyleElement);\n// EXTERNAL MODULE: ./node_modules/style-loader/dist/runtime/styleTagTransform.js\nvar styleTagTransform = __webpack_require__(589);\nvar styleTagTransform_default = /*#__PURE__*/__webpack_require__.n(styleTagTransform);\n// EXTERNAL MODULE: ./node_modules/css-loader/dist/cjs.js!./node_modules/sass-loader/dist/cjs.js!./src/style.scss\nvar style = __webpack_require__(192);\n;// CONCATENATED MODULE: ./src/style.scss\n\n      \n      \n      \n      \n      \n      \n      \n      \n      \n\nvar options = {};\n\noptions.styleTagTransform = (styleTagTransform_default());\noptions.setAttributes = (setAttributesWithoutAttributes_default());\n\n      options.insert = insertBySelector_default().bind(null, \"head\");\n    \noptions.domAPI = (styleDomAPI_default());\noptions.insertStyleElement = (insertStyleElement_default());\n\nvar update = injectStylesIntoStyleTag_default()(style/* default */.Z, options);\n\n\n\n\n       /* harmony default export */ const src_style = (style/* default */.Z && style/* default.locals */.Z.locals ? style/* default.locals */.Z.locals : undefined);\n\n;// CONCATENATED MODULE: ./src/js/documentParts.js\nconst body = document.querySelector('body');\n\nconst sidebar = document.querySelector('.sidebar');\nconst todaysToDos = document.querySelector('.today');\nconst thisWeeksToDos = document.querySelector('.week');\nconst defaultProject = document.querySelector('.defaultProject');\nconst projects = document.querySelector('#projectsContainer');\n\nconst addProjectBtn = document.querySelector('.addProjectBtn');\nconst addToDoBtn = document.querySelector('.addToDoBtn');\n\nconst toDoList = document.querySelector('.todoList');\nconst table = document.querySelector('table');\nconst tableTitle = document.querySelector('.titles.projName');\nconst tableDueDate = document.querySelector('.titles.dueDate');\n\n\nconst modal = document.querySelector('#modal');\nconst editModal = document.querySelector('#editModal');\nconst creationModalTaskName = document.querySelector('.createTaskName');\nconst creationModalTaskDescription = document.querySelector('.createTaskDescription');\nconst creationModalTaskDueDate = document.querySelector('.createTaskDueDate');\nconst creationModalTaskPriority = document.querySelector('.createTaskPriority');\nconst modalCancelBtn = document.querySelector('.createModalCancelBtn');\nconst modalSubmitBtn = document.querySelector('.createModalSubmitBtn');\n\nconst toDoCounter = 0;\n\nconst setPriorityColors = (value, el) => {\n  if(value === 'High'){\n    el.style = 'border-left: 10px solid red; border-radius: 5px;';\n  }\n  else if(value === 'Normal'){\n    el.style = 'border-left: 10px solid yellow; border-radius: 5px;';\n  }\n  else if(value === 'Low'){\n      el.style = 'border-left: 10px solid green; border-radius: 5px;';\n  }\n};\n\nconst plusCircleDiv = document.getElementById('plusCircleDiv');\n\n/* harmony default export */ const documentParts = ({\n\n  sidebar, body, todaysToDos, thisWeeksToDos, projects, defaultProject,\n  toDoList, table, tableTitle, tableDueDate, addToDoBtn, toDoCounter, modal,\n  creationModalTaskName, creationModalTaskDescription, creationModalTaskDueDate,\n  creationModalTaskPriority, editModal, modalCancelBtn, modalSubmitBtn, addProjectBtn, setPriorityColors, plusCircleDiv\n\n});\n// EXTERNAL MODULE: ./node_modules/jsbi/dist/jsbi-umd.js\nvar jsbi_umd = __webpack_require__(499);\n;// CONCATENATED MODULE: ./node_modules/@js-temporal/polyfill/dist/index.esm.js\n\n\nconst INTRINSICS = {};\nconst customUtilInspectFormatters = {\n    ['Temporal.Duration'](depth, options) {\n        const descr = options.stylize(`${this[Symbol.toStringTag]} <${this}>`, 'special');\n        if (depth < 1)\n            return descr;\n        const entries = [];\n        for (const prop of [\n            'years',\n            'months',\n            'weeks',\n            'days',\n            'hours',\n            'minutes',\n            'seconds',\n            'milliseconds',\n            'microseconds',\n            'nanoseconds'\n        ]) {\n            if (this[prop] !== 0)\n                entries.push(`  ${prop}: ${options.stylize(this[prop], 'number')}`);\n        }\n        return descr + ' {\\n' + entries.join(',\\n') + '\\n}';\n    }\n};\nfunction defaultUtilInspectFormatter(depth, options) {\n    return options.stylize(`${this[Symbol.toStringTag]} <${this}>`, 'special');\n}\nfunction MakeIntrinsicClass(Class, name) {\n    Object.defineProperty(Class.prototype, Symbol.toStringTag, {\n        value: name,\n        writable: false,\n        enumerable: false,\n        configurable: true\n    });\n    {\n        Object.defineProperty(Class.prototype, Symbol.for('nodejs.util.inspect.custom'), {\n            value: customUtilInspectFormatters[name] || defaultUtilInspectFormatter,\n            writable: false,\n            enumerable: false,\n            configurable: true\n        });\n    }\n    for (const prop of Object.getOwnPropertyNames(Class)) {\n        // we know that `prop` is present, so the descriptor is never undefined\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        const desc = Object.getOwnPropertyDescriptor(Class, prop);\n        if (!desc.configurable || !desc.enumerable)\n            continue;\n        desc.enumerable = false;\n        Object.defineProperty(Class, prop, desc);\n    }\n    for (const prop of Object.getOwnPropertyNames(Class.prototype)) {\n        // we know that `prop` is present, so the descriptor is never undefined\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        const desc = Object.getOwnPropertyDescriptor(Class.prototype, prop);\n        if (!desc.configurable || !desc.enumerable)\n            continue;\n        desc.enumerable = false;\n        Object.defineProperty(Class.prototype, prop, desc);\n    }\n    DefineIntrinsic(name, Class);\n    DefineIntrinsic(`${name}.prototype`, Class.prototype);\n}\nfunction DefineIntrinsic(name, value) {\n    const key = `%${name}%`;\n    if (INTRINSICS[key] !== undefined)\n        throw new Error(`intrinsic ${name} already exists`);\n    INTRINSICS[key] = value;\n}\nfunction GetIntrinsic(intrinsic) {\n    return INTRINSICS[intrinsic];\n}\n\n// Instant\nconst EPOCHNANOSECONDS = 'slot-epochNanoSeconds';\n// TimeZone\nconst TIMEZONE_ID = 'slot-timezone-identifier';\n// DateTime, Date, Time, YearMonth, MonthDay\nconst ISO_YEAR = 'slot-year';\nconst ISO_MONTH = 'slot-month';\nconst ISO_DAY = 'slot-day';\nconst ISO_HOUR = 'slot-hour';\nconst ISO_MINUTE = 'slot-minute';\nconst ISO_SECOND = 'slot-second';\nconst ISO_MILLISECOND = 'slot-millisecond';\nconst ISO_MICROSECOND = 'slot-microsecond';\nconst ISO_NANOSECOND = 'slot-nanosecond';\nconst CALENDAR = 'slot-calendar';\n// Date, YearMonth, and MonthDay all have the same slots, disambiguation needed:\nconst DATE_BRAND = 'slot-date-brand';\nconst YEAR_MONTH_BRAND = 'slot-year-month-brand';\nconst MONTH_DAY_BRAND = 'slot-month-day-brand';\n// ZonedDateTime\nconst INSTANT = 'slot-cached-instant';\nconst TIME_ZONE = 'slot-time-zone';\n// Duration\nconst YEARS = 'slot-years';\nconst MONTHS = 'slot-months';\nconst WEEKS = 'slot-weeks';\nconst DAYS = 'slot-days';\nconst HOURS = 'slot-hours';\nconst MINUTES = 'slot-minutes';\nconst SECONDS = 'slot-seconds';\nconst MILLISECONDS = 'slot-milliseconds';\nconst MICROSECONDS = 'slot-microseconds';\nconst NANOSECONDS = 'slot-nanoseconds';\n// Calendar\nconst CALENDAR_ID = 'slot-calendar-identifier';\nconst slots = new WeakMap();\nfunction CreateSlots(container) {\n    slots.set(container, Object.create(null));\n}\nfunction GetSlots(container) {\n    return slots.get(container);\n}\nfunction HasSlot(container, ...ids) {\n    if (!container || 'object' !== typeof container)\n        return false;\n    const myslots = GetSlots(container);\n    return !!myslots && ids.reduce((all, id) => all && id in myslots, true);\n}\nfunction GetSlot(container, id) {\n    const value = GetSlots(container)[id];\n    if (value === undefined)\n        throw new TypeError(`Missing internal slot ${id}`);\n    return value;\n}\nfunction SetSlot(container, id, value) {\n    GetSlots(container)[id] = value;\n}\n\nconst ArrayIncludes = Array.prototype.includes;\nconst ArrayPrototypePush$2 = Array.prototype.push;\nconst IntlDateTimeFormat$2 = globalThis.Intl.DateTimeFormat;\nconst ArraySort = Array.prototype.sort;\nconst MathAbs$1 = Math.abs;\nconst MathFloor$1 = Math.floor;\nconst ObjectEntries = Object.entries;\nconst ObjectKeys = Object.keys;\n/**\n * Implementations for each calendar. Non-ISO calendars have an extra `helper`\n * property that provides additional per-calendar logic.\n */\nconst impl = {};\n/**\n * Thin wrapper around the implementation of each built-in calendar. This\n * class's methods follow a similar pattern:\n * 1. Validate parameters\n * 2. Fill in default options (for methods where options are present)\n * 3. Simplify and/or normalize parameters. For example, some methods accept\n *    PlainDate, PlainDateTime, ZonedDateTime, etc. and these are normalized to\n *    PlainDate.\n * 4. Look up the ID of the built-in calendar\n * 5. Fetch the implementation object for that ID.\n * 6. Call the corresponding method in the implementation object.\n */\nclass Calendar {\n    constructor(idParam) {\n        // Note: if the argument is not passed, IsBuiltinCalendar(\"undefined\") will fail. This check\n        //       exists only to improve the error message.\n        if (arguments.length < 1) {\n            throw new RangeError('missing argument: id is required');\n        }\n        const id = ToString(idParam);\n        if (!IsBuiltinCalendar(id))\n            throw new RangeError(`invalid calendar identifier ${id}`);\n        CreateSlots(this);\n        SetSlot(this, CALENDAR_ID, id);\n        {\n            Object.defineProperty(this, '_repr_', {\n                value: `${this[Symbol.toStringTag]} <${id}>`,\n                writable: false,\n                enumerable: false,\n                configurable: false\n            });\n        }\n    }\n    get id() {\n        if (!IsTemporalCalendar(this))\n            throw new TypeError('invalid receiver');\n        return ToString(this);\n    }\n    dateFromFields(fields, optionsParam = undefined) {\n        if (!IsTemporalCalendar(this))\n            throw new TypeError('invalid receiver');\n        if (!IsObject(fields))\n            throw new TypeError('invalid fields');\n        const options = GetOptionsObject(optionsParam);\n        return impl[GetSlot(this, CALENDAR_ID)].dateFromFields(fields, options, this);\n    }\n    yearMonthFromFields(fields, optionsParam = undefined) {\n        if (!IsTemporalCalendar(this))\n            throw new TypeError('invalid receiver');\n        if (!IsObject(fields))\n            throw new TypeError('invalid fields');\n        const options = GetOptionsObject(optionsParam);\n        return impl[GetSlot(this, CALENDAR_ID)].yearMonthFromFields(fields, options, this);\n    }\n    monthDayFromFields(fields, optionsParam = undefined) {\n        if (!IsTemporalCalendar(this))\n            throw new TypeError('invalid receiver');\n        if (!IsObject(fields))\n            throw new TypeError('invalid fields');\n        const options = GetOptionsObject(optionsParam);\n        return impl[GetSlot(this, CALENDAR_ID)].monthDayFromFields(fields, options, this);\n    }\n    fields(fields) {\n        if (!IsTemporalCalendar(this))\n            throw new TypeError('invalid receiver');\n        const fieldsArray = [];\n        const allowed = new Set([\n            'year',\n            'month',\n            'monthCode',\n            'day',\n            'hour',\n            'minute',\n            'second',\n            'millisecond',\n            'microsecond',\n            'nanosecond'\n        ]);\n        for (const name of fields) {\n            if (typeof name !== 'string')\n                throw new TypeError('invalid fields');\n            if (!allowed.has(name))\n                throw new RangeError(`invalid field name ${name}`);\n            allowed.delete(name);\n            ArrayPrototypePush$2.call(fieldsArray, name);\n        }\n        return impl[GetSlot(this, CALENDAR_ID)].fields(fieldsArray);\n    }\n    mergeFields(fields, additionalFields) {\n        if (!IsTemporalCalendar(this))\n            throw new TypeError('invalid receiver');\n        return impl[GetSlot(this, CALENDAR_ID)].mergeFields(fields, additionalFields);\n    }\n    dateAdd(dateParam, durationParam, optionsParam = undefined) {\n        if (!IsTemporalCalendar(this))\n            throw new TypeError('invalid receiver');\n        const date = ToTemporalDate(dateParam);\n        const duration = ToTemporalDuration(durationParam);\n        const options = GetOptionsObject(optionsParam);\n        const overflow = ToTemporalOverflow(options);\n        const { days } = BalanceDuration(GetSlot(duration, DAYS), GetSlot(duration, HOURS), GetSlot(duration, MINUTES), GetSlot(duration, SECONDS), GetSlot(duration, MILLISECONDS), GetSlot(duration, MICROSECONDS), GetSlot(duration, NANOSECONDS), 'day');\n        return impl[GetSlot(this, CALENDAR_ID)].dateAdd(date, GetSlot(duration, YEARS), GetSlot(duration, MONTHS), GetSlot(duration, WEEKS), days, overflow, this);\n    }\n    dateUntil(oneParam, twoParam, optionsParam = undefined) {\n        if (!IsTemporalCalendar(this))\n            throw new TypeError('invalid receiver');\n        const one = ToTemporalDate(oneParam);\n        const two = ToTemporalDate(twoParam);\n        const options = GetOptionsObject(optionsParam);\n        const largestUnit = ToLargestTemporalUnit(options, 'auto', ['hour', 'minute', 'second', 'millisecond', 'microsecond', 'nanosecond'], 'day');\n        const { years, months, weeks, days } = impl[GetSlot(this, CALENDAR_ID)].dateUntil(one, two, largestUnit);\n        const Duration = GetIntrinsic('%Temporal.Duration%');\n        return new Duration(years, months, weeks, days, 0, 0, 0, 0, 0, 0);\n    }\n    year(dateParam) {\n        let date = dateParam;\n        if (!IsTemporalCalendar(this))\n            throw new TypeError('invalid receiver');\n        if (!IsTemporalYearMonth(date))\n            date = ToTemporalDate(date);\n        return impl[GetSlot(this, CALENDAR_ID)].year(date);\n    }\n    month(dateParam) {\n        let date = dateParam;\n        if (!IsTemporalCalendar(this))\n            throw new TypeError('invalid receiver');\n        if (IsTemporalMonthDay(date))\n            throw new TypeError('use monthCode on PlainMonthDay instead');\n        if (!IsTemporalYearMonth(date))\n            date = ToTemporalDate(date);\n        return impl[GetSlot(this, CALENDAR_ID)].month(date);\n    }\n    monthCode(dateParam) {\n        let date = dateParam;\n        if (!IsTemporalCalendar(this))\n            throw new TypeError('invalid receiver');\n        if (!IsTemporalYearMonth(date) && !IsTemporalMonthDay(date))\n            date = ToTemporalDate(date);\n        return impl[GetSlot(this, CALENDAR_ID)].monthCode(date);\n    }\n    day(dateParam) {\n        let date = dateParam;\n        if (!IsTemporalCalendar(this))\n            throw new TypeError('invalid receiver');\n        if (!IsTemporalMonthDay(date))\n            date = ToTemporalDate(date);\n        return impl[GetSlot(this, CALENDAR_ID)].day(date);\n    }\n    era(dateParam) {\n        let date = dateParam;\n        if (!IsTemporalCalendar(this))\n            throw new TypeError('invalid receiver');\n        if (!IsTemporalYearMonth(date))\n            date = ToTemporalDate(date);\n        return impl[GetSlot(this, CALENDAR_ID)].era(date);\n    }\n    eraYear(dateParam) {\n        let date = dateParam;\n        if (!IsTemporalCalendar(this))\n            throw new TypeError('invalid receiver');\n        if (!IsTemporalYearMonth(date))\n            date = ToTemporalDate(date);\n        return impl[GetSlot(this, CALENDAR_ID)].eraYear(date);\n    }\n    dayOfWeek(dateParam) {\n        if (!IsTemporalCalendar(this))\n            throw new TypeError('invalid receiver');\n        const date = ToTemporalDate(dateParam);\n        return impl[GetSlot(this, CALENDAR_ID)].dayOfWeek(date);\n    }\n    dayOfYear(dateParam) {\n        if (!IsTemporalCalendar(this))\n            throw new TypeError('invalid receiver');\n        const date = ToTemporalDate(dateParam);\n        return impl[GetSlot(this, CALENDAR_ID)].dayOfYear(date);\n    }\n    weekOfYear(dateParam) {\n        if (!IsTemporalCalendar(this))\n            throw new TypeError('invalid receiver');\n        const date = ToTemporalDate(dateParam);\n        return impl[GetSlot(this, CALENDAR_ID)].weekOfYear(date);\n    }\n    daysInWeek(dateParam) {\n        if (!IsTemporalCalendar(this))\n            throw new TypeError('invalid receiver');\n        const date = ToTemporalDate(dateParam);\n        return impl[GetSlot(this, CALENDAR_ID)].daysInWeek(date);\n    }\n    daysInMonth(dateParam) {\n        let date = dateParam;\n        if (!IsTemporalCalendar(this))\n            throw new TypeError('invalid receiver');\n        if (!IsTemporalYearMonth(date))\n            date = ToTemporalDate(date);\n        return impl[GetSlot(this, CALENDAR_ID)].daysInMonth(date);\n    }\n    daysInYear(dateParam) {\n        let date = dateParam;\n        if (!IsTemporalCalendar(this))\n            throw new TypeError('invalid receiver');\n        if (!IsTemporalYearMonth(date))\n            date = ToTemporalDate(date);\n        return impl[GetSlot(this, CALENDAR_ID)].daysInYear(date);\n    }\n    monthsInYear(dateParam) {\n        let date = dateParam;\n        if (!IsTemporalCalendar(this))\n            throw new TypeError('invalid receiver');\n        if (!IsTemporalYearMonth(date))\n            date = ToTemporalDate(date);\n        return impl[GetSlot(this, CALENDAR_ID)].monthsInYear(date);\n    }\n    inLeapYear(dateParam) {\n        let date = dateParam;\n        if (!IsTemporalCalendar(this))\n            throw new TypeError('invalid receiver');\n        if (!IsTemporalYearMonth(date))\n            date = ToTemporalDate(date);\n        return impl[GetSlot(this, CALENDAR_ID)].inLeapYear(date);\n    }\n    toString() {\n        if (!IsTemporalCalendar(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, CALENDAR_ID);\n    }\n    toJSON() {\n        if (!IsTemporalCalendar(this))\n            throw new TypeError('invalid receiver');\n        return ToString(this);\n    }\n    static from(item) {\n        return ToTemporalCalendar(item);\n    }\n}\nMakeIntrinsicClass(Calendar, 'Temporal.Calendar');\nDefineIntrinsic('Temporal.Calendar.from', Calendar.from);\n/**\n * Implementation for the ISO 8601 calendar. This is the only calendar that's\n * guaranteed to be supported by all ECMAScript implementations, including those\n * without Intl (ECMA-402) support.\n */\nimpl['iso8601'] = {\n    dateFromFields(fieldsParam, options, calendar) {\n        const overflow = ToTemporalOverflow(options);\n        let fields = PrepareTemporalFields(fieldsParam, [\n            ['day'],\n            ['month', undefined],\n            ['monthCode', undefined],\n            ['year']\n        ]);\n        fields = resolveNonLunisolarMonth(fields);\n        let { year, month, day } = fields;\n        ({ year, month, day } = RegulateISODate(year, month, day, overflow));\n        return CreateTemporalDate(year, month, day, calendar);\n    },\n    yearMonthFromFields(fieldsParam, options, calendar) {\n        const overflow = ToTemporalOverflow(options);\n        let fields = PrepareTemporalFields(fieldsParam, [\n            ['month', undefined],\n            ['monthCode', undefined],\n            ['year']\n        ]);\n        fields = resolveNonLunisolarMonth(fields);\n        let { year, month } = fields;\n        ({ year, month } = RegulateISOYearMonth(year, month, overflow));\n        return CreateTemporalYearMonth(year, month, calendar, /* referenceISODay = */ 1);\n    },\n    monthDayFromFields(fieldsParam, options, calendar) {\n        const overflow = ToTemporalOverflow(options);\n        let fields = PrepareTemporalFields(fieldsParam, [\n            ['day'],\n            ['month', undefined],\n            ['monthCode', undefined],\n            ['year', undefined]\n        ]);\n        if (fields.month !== undefined && fields.year === undefined && fields.monthCode === undefined) {\n            throw new TypeError('either year or monthCode required with month');\n        }\n        const useYear = fields.monthCode === undefined;\n        const referenceISOYear = 1972;\n        fields = resolveNonLunisolarMonth(fields);\n        let { month, day, year } = fields;\n        ({ month, day } = RegulateISODate(useYear ? year : referenceISOYear, month, day, overflow));\n        return CreateTemporalMonthDay(month, day, calendar, referenceISOYear);\n    },\n    fields(fields) {\n        return fields;\n    },\n    mergeFields(fields, additionalFields) {\n        const merged = {};\n        for (const nextKey of ObjectKeys(fields)) {\n            if (nextKey === 'month' || nextKey === 'monthCode')\n                continue;\n            merged[nextKey] = fields[nextKey];\n        }\n        const newKeys = ObjectKeys(additionalFields);\n        for (const nextKey of newKeys) {\n            merged[nextKey] = additionalFields[nextKey];\n        }\n        if (!ArrayIncludes.call(newKeys, 'month') && !ArrayIncludes.call(newKeys, 'monthCode')) {\n            const { month, monthCode } = fields;\n            if (month !== undefined)\n                merged.month = month;\n            if (monthCode !== undefined)\n                merged.monthCode = monthCode;\n        }\n        return merged;\n    },\n    dateAdd(date, years, months, weeks, days, overflow, calendar) {\n        let year = GetSlot(date, ISO_YEAR);\n        let month = GetSlot(date, ISO_MONTH);\n        let day = GetSlot(date, ISO_DAY);\n        ({ year, month, day } = AddISODate(year, month, day, years, months, weeks, days, overflow));\n        return CreateTemporalDate(year, month, day, calendar);\n    },\n    dateUntil(one, two, largestUnit) {\n        return DifferenceISODate(GetSlot(one, ISO_YEAR), GetSlot(one, ISO_MONTH), GetSlot(one, ISO_DAY), GetSlot(two, ISO_YEAR), GetSlot(two, ISO_MONTH), GetSlot(two, ISO_DAY), largestUnit);\n    },\n    year(date) {\n        return GetSlot(date, ISO_YEAR);\n    },\n    era() {\n        return undefined;\n    },\n    eraYear() {\n        return undefined;\n    },\n    month(date) {\n        return GetSlot(date, ISO_MONTH);\n    },\n    monthCode(date) {\n        return buildMonthCode(GetSlot(date, ISO_MONTH));\n    },\n    day(date) {\n        return GetSlot(date, ISO_DAY);\n    },\n    dayOfWeek(date) {\n        return DayOfWeek(GetSlot(date, ISO_YEAR), GetSlot(date, ISO_MONTH), GetSlot(date, ISO_DAY));\n    },\n    dayOfYear(date) {\n        return DayOfYear(GetSlot(date, ISO_YEAR), GetSlot(date, ISO_MONTH), GetSlot(date, ISO_DAY));\n    },\n    weekOfYear(date) {\n        return WeekOfYear(GetSlot(date, ISO_YEAR), GetSlot(date, ISO_MONTH), GetSlot(date, ISO_DAY));\n    },\n    daysInWeek() {\n        return 7;\n    },\n    daysInMonth(date) {\n        return ISODaysInMonth(GetSlot(date, ISO_YEAR), GetSlot(date, ISO_MONTH));\n    },\n    daysInYear(dateParam) {\n        let date = dateParam;\n        if (!HasSlot(date, ISO_YEAR))\n            date = ToTemporalDate(date);\n        return LeapYear(GetSlot(date, ISO_YEAR)) ? 366 : 365;\n    },\n    monthsInYear() {\n        return 12;\n    },\n    inLeapYear(dateParam) {\n        let date = dateParam;\n        if (!HasSlot(date, ISO_YEAR))\n            date = ToTemporalDate(date);\n        return LeapYear(GetSlot(date, ISO_YEAR));\n    }\n};\nfunction monthCodeNumberPart(monthCode) {\n    if (!monthCode.startsWith('M')) {\n        throw new RangeError(`Invalid month code: ${monthCode}.  Month codes must start with M.`);\n    }\n    const month = +monthCode.slice(1);\n    if (isNaN(month))\n        throw new RangeError(`Invalid month code: ${monthCode}`);\n    return month;\n}\nfunction buildMonthCode(month, leap = false) {\n    return `M${month.toString().padStart(2, '0')}${leap ? 'L' : ''}`;\n}\n/**\n * Safely merge a month, monthCode pair into an integer month.\n * If both are present, make sure they match.\n * This logic doesn't work for lunisolar calendars!\n * */\nfunction resolveNonLunisolarMonth(calendarDate, overflow = undefined, monthsPerYear = 12) {\n    let { month, monthCode } = calendarDate;\n    if (monthCode === undefined) {\n        if (month === undefined)\n            throw new TypeError('Either month or monthCode are required');\n        // The ISO calendar uses the default (undefined) value because it does\n        // constrain/reject after this method returns. Non-ISO calendars, however,\n        // rely on this function to constrain/reject out-of-range `month` values.\n        if (overflow === 'reject')\n            RejectToRange(month, 1, monthsPerYear);\n        if (overflow === 'constrain')\n            month = ConstrainToRange(month, 1, monthsPerYear);\n        monthCode = buildMonthCode(month);\n    }\n    else {\n        const numberPart = monthCodeNumberPart(monthCode);\n        if (month !== undefined && month !== numberPart) {\n            throw new RangeError(`monthCode ${monthCode} and month ${month} must match if both are present`);\n        }\n        if (monthCode !== buildMonthCode(numberPart)) {\n            throw new RangeError(`Invalid month code: ${monthCode}`);\n        }\n        month = numberPart;\n        if (month < 1 || month > monthsPerYear)\n            throw new RangeError(`Invalid monthCode: ${monthCode}`);\n    }\n    return { ...calendarDate, month, monthCode };\n}\n/**\n * This prototype implementation of non-ISO calendars makes many repeated calls\n * to Intl APIs which may be slow (e.g. >0.2ms). This trivial cache will speed\n * up these repeat accesses. Each cache instance is associated (via a WeakMap)\n * to a specific Temporal object, which speeds up multiple calendar calls on the\n * same Temporal object instance.  No invalidation or pruning is necessary\n * because each object's cache is thrown away when the object is GC-ed.\n */\nclass OneObjectCache {\n    constructor(cacheToClone) {\n        this.map = new Map();\n        this.calls = 0;\n        this.hits = 0;\n        this.misses = 0;\n        this.now = globalThis.performance ? globalThis.performance.now() : Date.now();\n        if (cacheToClone !== undefined) {\n            let i = 0;\n            for (const entry of cacheToClone.map.entries()) {\n                if (++i > OneObjectCache.MAX_CACHE_ENTRIES)\n                    break;\n                this.map.set(...entry);\n            }\n        }\n    }\n    get(key) {\n        const result = this.map.get(key);\n        if (result) {\n            this.hits++;\n            this.report();\n        }\n        this.calls++;\n        return result;\n    }\n    set(key, value) {\n        this.map.set(key, value);\n        this.misses++;\n        this.report();\n    }\n    report() {\n        /*\n        if (this.calls === 0) return;\n        const ms = (globalThis.performance ? globalThis.performance.now() : Date.now()) - this.now;\n        const hitRate = ((100 * this.hits) / this.calls).toFixed(0);\n        console.log(`${this.calls} calls in ${ms.toFixed(2)}ms. Hits: ${this.hits} (${hitRate}%). Misses: ${this.misses}.`);\n        */\n    }\n    setObject(obj) {\n        if (OneObjectCache.objectMap.get(obj))\n            throw new RangeError('object already cached');\n        OneObjectCache.objectMap.set(obj, this);\n        this.report();\n    }\n    /**\n     * Returns a WeakMap-backed cache that's used to store expensive results\n     * that are associated with a particular Temporal object instance.\n     *\n     * @param obj - object to associate with the cache\n     */\n    static getCacheForObject(obj) {\n        let cache = OneObjectCache.objectMap.get(obj);\n        if (!cache) {\n            cache = new OneObjectCache();\n            OneObjectCache.objectMap.set(obj, cache);\n        }\n        return cache;\n    }\n}\nOneObjectCache.objectMap = new WeakMap();\nOneObjectCache.MAX_CACHE_ENTRIES = 1000;\nfunction toUtcIsoDateString({ isoYear, isoMonth, isoDay }) {\n    const yearString = ISOYearString(isoYear);\n    const monthString = ISODateTimePartString(isoMonth);\n    const dayString = ISODateTimePartString(isoDay);\n    return `${yearString}-${monthString}-${dayString}T00:00Z`;\n}\nfunction simpleDateDiff(one, two) {\n    return {\n        years: one.year - two.year,\n        months: one.month - two.month,\n        days: one.day - two.day\n    };\n}\n/**\n * Implementation helper that's common to all non-ISO calendars\n */\nclass HelperBase {\n    constructor() {\n        // The short era format works for all calendars except Japanese, which will\n        // override.\n        this.eraLength = 'short';\n        // All built-in calendars except Chinese/Dangi and Hebrew use an era\n        this.hasEra = true;\n    }\n    getFormatter() {\n        // `new Intl.DateTimeFormat()` is amazingly slow and chews up RAM. Per\n        // https://bugs.chromium.org/p/v8/issues/detail?id=6528#c4, we cache one\n        // DateTimeFormat instance per calendar. Caching is lazy so we only pay for\n        // calendars that are used. Note that the nonIsoHelperBase object is spread\n        // into each each calendar's implementation before any cache is created, so\n        // each calendar gets its own separate cached formatter.\n        if (typeof this.formatter === 'undefined') {\n            this.formatter = new IntlDateTimeFormat$2(`en-US-u-ca-${this.id}`, {\n                day: 'numeric',\n                month: 'numeric',\n                year: 'numeric',\n                era: this.eraLength,\n                timeZone: 'UTC'\n            });\n        }\n        return this.formatter;\n    }\n    isoToCalendarDate(isoDate, cache) {\n        const { year: isoYear, month: isoMonth, day: isoDay } = isoDate;\n        const key = JSON.stringify({ func: 'isoToCalendarDate', isoYear, isoMonth, isoDay, id: this.id });\n        const cached = cache.get(key);\n        if (cached)\n            return cached;\n        const dateTimeFormat = this.getFormatter();\n        let parts, isoString;\n        try {\n            isoString = toUtcIsoDateString({ isoYear, isoMonth, isoDay });\n            parts = dateTimeFormat.formatToParts(new Date(isoString));\n        }\n        catch (e) {\n            throw new RangeError(`Invalid ISO date: ${JSON.stringify({ isoYear, isoMonth, isoDay })}`);\n        }\n        const result = {};\n        for (let { type, value } of parts) {\n            if (type === 'year')\n                result.eraYear = +value;\n            // TODO: remove this type annotation when `relatedYear` gets into TS lib types\n            if (type === 'relatedYear')\n                result.eraYear = +value;\n            if (type === 'month') {\n                const matches = /^([0-9]*)(.*?)$/.exec(value);\n                if (!matches || matches.length != 3 || (!matches[1] && !matches[2])) {\n                    throw new RangeError(`Unexpected month: ${value}`);\n                }\n                // If the month has no numeric part (should only see this for the Hebrew\n                // calendar with newer FF / Chromium versions; see\n                // https://bugzilla.mozilla.org/show_bug.cgi?id=1751833) then set a\n                // placeholder month index of `1` and rely on the derived class to\n                // calculate the correct month index from the month name stored in\n                // `monthExtra`.\n                result.month = matches[1] ? +matches[1] : 1;\n                if (result.month < 1) {\n                    throw new RangeError(`Invalid month ${value} from ${isoString}[u-ca-${this.id}]` +\n                        ' (probably due to https://bugs.chromium.org/p/v8/issues/detail?id=10527)');\n                }\n                if (result.month > 13) {\n                    throw new RangeError(`Invalid month ${value} from ${isoString}[u-ca-${this.id}]` +\n                        ' (probably due to https://bugs.chromium.org/p/v8/issues/detail?id=10529)');\n                }\n                // The ICU formats for the Hebrew calendar no longer support a numeric\n                // month format. So we'll rely on the derived class to interpret it.\n                // `monthExtra` is also used on the Chinese calendar to handle a suffix\n                // \"bis\" indicating a leap month.\n                if (matches[2])\n                    result.monthExtra = matches[2];\n            }\n            if (type === 'day')\n                result.day = +value;\n            if (this.hasEra && type === 'era' && value != null && value !== '') {\n                // The convention for Temporal era values is lowercase, so following\n                // that convention in this prototype. Punctuation is removed, accented\n                // letters are normalized, and spaces are replaced with dashes.\n                // E.g.: \"ERA0\" => \"era0\", \"Before R.O.C.\" => \"before-roc\", \"En\" => \"eno\"\n                // The call to normalize() and the replacement regex deals with era\n                // names that contain non-ASCII characters like Japanese eras. Also\n                // ignore extra content in parentheses like JPN era date ranges.\n                value = value.split(' (')[0];\n                result.era = value\n                    .normalize('NFD')\n                    .replace(/[^-0-9 \\p{L}]/gu, '')\n                    .replace(' ', '-')\n                    .toLowerCase();\n            }\n        }\n        if (result.eraYear === undefined) {\n            // Node 12 has outdated ICU data that lacks the `relatedYear` field in the\n            // output of Intl.DateTimeFormat.formatToParts.\n            throw new RangeError(`Intl.DateTimeFormat.formatToParts lacks relatedYear in ${this.id} calendar. Try Node 14+ or modern browsers.`);\n        }\n        // Translate eras that may be handled differently by Temporal vs. by Intl\n        // (e.g. Japanese pre-Meiji eras). See https://github.com/tc39/proposal-temporal/issues/526.\n        if (this.reviseIntlEra) {\n            const { era, eraYear } = this.reviseIntlEra(result, isoDate);\n            result.era = era;\n            result.eraYear = eraYear;\n        }\n        if (this.checkIcuBugs)\n            this.checkIcuBugs(isoDate);\n        const calendarDate = this.adjustCalendarDate(result, cache, 'constrain', true);\n        if (calendarDate.year === undefined)\n            throw new RangeError(`Missing year converting ${JSON.stringify(isoDate)}`);\n        if (calendarDate.month === undefined)\n            throw new RangeError(`Missing month converting ${JSON.stringify(isoDate)}`);\n        if (calendarDate.day === undefined)\n            throw new RangeError(`Missing day converting ${JSON.stringify(isoDate)}`);\n        cache.set(key, calendarDate);\n        // Also cache the reverse mapping\n        ['constrain', 'reject'].forEach((overflow) => {\n            const keyReverse = JSON.stringify({\n                func: 'calendarToIsoDate',\n                year: calendarDate.year,\n                month: calendarDate.month,\n                day: calendarDate.day,\n                overflow,\n                id: this.id\n            });\n            cache.set(keyReverse, isoDate);\n        });\n        return calendarDate;\n    }\n    validateCalendarDate(calendarDate) {\n        const { era, month, year, day, eraYear, monthCode, monthExtra } = calendarDate;\n        // When there's a suffix (e.g. \"5bis\" for a leap month in Chinese calendar)\n        // the derived class must deal with it.\n        if (monthExtra !== undefined)\n            throw new RangeError('Unexpected `monthExtra` value');\n        if (year === undefined && eraYear === undefined)\n            throw new TypeError('year or eraYear is required');\n        if (month === undefined && monthCode === undefined)\n            throw new TypeError('month or monthCode is required');\n        if (day === undefined)\n            throw new RangeError('Missing day');\n        if (monthCode !== undefined) {\n            if (typeof monthCode !== 'string') {\n                throw new RangeError(`monthCode must be a string, not ${typeof monthCode}`);\n            }\n            if (!/^M([01]?\\d)(L?)$/.test(monthCode))\n                throw new RangeError(`Invalid monthCode: ${monthCode}`);\n        }\n        if (this.constantEra) {\n            if (era !== undefined && era !== this.constantEra) {\n                throw new RangeError(`era must be ${this.constantEra}, not ${era}`);\n            }\n            if (eraYear !== undefined && year !== undefined && eraYear !== year) {\n                throw new RangeError(`eraYear ${eraYear} does not match year ${year}`);\n            }\n        }\n    }\n    /**\n     * Allows derived calendars to add additional fields and/or to make\n     * adjustments e.g. to set the era based on the date or to revise the month\n     * number in lunisolar calendars per\n     * https://github.com/tc39/proposal-temporal/issues/1203.\n     *\n     * The base implementation fills in missing values by assuming the simplest\n     * possible calendar:\n     * - no eras or a constant era defined in `.constantEra`\n     * - non-lunisolar calendar (no leap months)\n     * */\n    adjustCalendarDate(calendarDateParam, cache = undefined, overflow = 'constrain', \n    // This param is only used by derived classes\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    fromLegacyDate = false) {\n        if (this.calendarType === 'lunisolar')\n            throw new RangeError('Override required for lunisolar calendars');\n        let calendarDate = calendarDateParam;\n        this.validateCalendarDate(calendarDate);\n        // For calendars that always use the same era, set it here so that derived\n        // calendars won't need to implement this method simply to set the era.\n        if (this.constantEra) {\n            // year and eraYear always match when there's only one possible era\n            const { year, eraYear } = calendarDate;\n            calendarDate = {\n                ...calendarDate,\n                era: this.constantEra,\n                year: year !== undefined ? year : eraYear,\n                eraYear: eraYear !== undefined ? eraYear : year\n            };\n        }\n        const largestMonth = this.monthsInYear(calendarDate, cache);\n        let { month, monthCode } = calendarDate;\n        ({ month, monthCode } = resolveNonLunisolarMonth(calendarDate, overflow, largestMonth));\n        return { ...calendarDate, month, monthCode };\n    }\n    regulateMonthDayNaive(calendarDate, overflow, cache) {\n        const largestMonth = this.monthsInYear(calendarDate, cache);\n        let { month, day } = calendarDate;\n        if (overflow === 'reject') {\n            RejectToRange(month, 1, largestMonth);\n            RejectToRange(day, 1, this.maximumMonthLength(calendarDate));\n        }\n        else {\n            month = ConstrainToRange(month, 1, largestMonth);\n            day = ConstrainToRange(day, 1, this.maximumMonthLength({ ...calendarDate, month }));\n        }\n        return { ...calendarDate, month, day };\n    }\n    calendarToIsoDate(dateParam, overflow = 'constrain', cache) {\n        const originalDate = dateParam;\n        // First, normalize the calendar date to ensure that (year, month, day)\n        // are all present, converting monthCode and eraYear if needed.\n        let date = this.adjustCalendarDate(dateParam, cache, overflow, false);\n        // Fix obviously out-of-bounds values. Values that are valid generally, but\n        // not in this particular year, may not be caught here for some calendars.\n        // If so, these will be handled lower below.\n        date = this.regulateMonthDayNaive(date, overflow, cache);\n        const { year, month, day } = date;\n        const key = JSON.stringify({ func: 'calendarToIsoDate', year, month, day, overflow, id: this.id });\n        let cached = cache.get(key);\n        if (cached)\n            return cached;\n        // If YMD are present in the input but the input has been constrained\n        // already, then cache both the original value and the constrained value.\n        let keyOriginal;\n        if (originalDate.year !== undefined &&\n            originalDate.month !== undefined &&\n            originalDate.day !== undefined &&\n            (originalDate.year !== date.year || originalDate.month !== date.month || originalDate.day !== date.day)) {\n            keyOriginal = JSON.stringify({\n                func: 'calendarToIsoDate',\n                year: originalDate.year,\n                month: originalDate.month,\n                day: originalDate.day,\n                overflow,\n                id: this.id\n            });\n            cached = cache.get(keyOriginal);\n            if (cached)\n                return cached;\n        }\n        // First, try to roughly guess the result\n        let isoEstimate = this.estimateIsoDate({ year, month, day });\n        const calculateSameMonthResult = (diffDays) => {\n            // If the estimate is in the same year & month as the target, then we can\n            // calculate the result exactly and short-circuit any additional logic.\n            // This optimization assumes that months are continuous. It would break if\n            // a calendar skipped days, like the Julian->Gregorian switchover. But the\n            // only ICU calendars that currently skip days (japanese/roc/buddhist) is\n            // a bug (https://bugs.chromium.org/p/chromium/issues/detail?id=1173158)\n            // that's currently detected by `checkIcuBugs()` which will throw. So\n            // this optimization should be safe for all ICU calendars.\n            let testIsoEstimate = this.addDaysIso(isoEstimate, diffDays);\n            if (date.day > this.minimumMonthLength(date)) {\n                // There's a chance that the calendar date is out of range. Throw or\n                // constrain if so.\n                let testCalendarDate = this.isoToCalendarDate(testIsoEstimate, cache);\n                while (testCalendarDate.month !== month || testCalendarDate.year !== year) {\n                    if (overflow === 'reject') {\n                        throw new RangeError(`day ${day} does not exist in month ${month} of year ${year}`);\n                    }\n                    // Back up a day at a time until we're not hanging over the month end\n                    testIsoEstimate = this.addDaysIso(testIsoEstimate, -1);\n                    testCalendarDate = this.isoToCalendarDate(testIsoEstimate, cache);\n                }\n            }\n            return testIsoEstimate;\n        };\n        let sign = 0;\n        let roundtripEstimate = this.isoToCalendarDate(isoEstimate, cache);\n        let diff = simpleDateDiff(date, roundtripEstimate);\n        if (diff.years !== 0 || diff.months !== 0 || diff.days !== 0) {\n            const diffTotalDaysEstimate = diff.years * 365 + diff.months * 30 + diff.days;\n            isoEstimate = this.addDaysIso(isoEstimate, diffTotalDaysEstimate);\n            roundtripEstimate = this.isoToCalendarDate(isoEstimate, cache);\n            diff = simpleDateDiff(date, roundtripEstimate);\n            if (diff.years === 0 && diff.months === 0) {\n                isoEstimate = calculateSameMonthResult(diff.days);\n            }\n            else {\n                sign = this.compareCalendarDates(date, roundtripEstimate);\n            }\n        }\n        // If the initial guess is not in the same month, then then bisect the\n        // distance to the target, starting with 8 days per step.\n        let increment = 8;\n        let maybeConstrained = false;\n        while (sign) {\n            isoEstimate = this.addDaysIso(isoEstimate, sign * increment);\n            const oldRoundtripEstimate = roundtripEstimate;\n            roundtripEstimate = this.isoToCalendarDate(isoEstimate, cache);\n            const oldSign = sign;\n            sign = this.compareCalendarDates(date, roundtripEstimate);\n            if (sign) {\n                diff = simpleDateDiff(date, roundtripEstimate);\n                if (diff.years === 0 && diff.months === 0) {\n                    isoEstimate = calculateSameMonthResult(diff.days);\n                    // Signal the loop condition that there's a match.\n                    sign = 0;\n                    // If the calendar day is larger than the minimal length for this\n                    // month, then it might be larger than the actual length of the month.\n                    // So we won't cache it as the correct calendar date for this ISO\n                    // date.\n                    maybeConstrained = date.day > this.minimumMonthLength(date);\n                }\n                else if (oldSign && sign !== oldSign) {\n                    if (increment > 1) {\n                        // If the estimate overshot the target, try again with a smaller increment\n                        // in the reverse direction.\n                        increment /= 2;\n                    }\n                    else {\n                        // Increment is 1, and neither the previous estimate nor the new\n                        // estimate is correct. The only way that can happen is if the\n                        // original date was an invalid value that will be constrained or\n                        // rejected here.\n                        if (overflow === 'reject') {\n                            throw new RangeError(`Can't find ISO date from calendar date: ${JSON.stringify({ ...originalDate })}`);\n                        }\n                        else {\n                            // To constrain, pick the earliest value\n                            const order = this.compareCalendarDates(roundtripEstimate, oldRoundtripEstimate);\n                            // If current value is larger, then back up to the previous value.\n                            if (order > 0)\n                                isoEstimate = this.addDaysIso(isoEstimate, -1);\n                            maybeConstrained = true;\n                            sign = 0;\n                        }\n                    }\n                }\n            }\n        }\n        cache.set(key, isoEstimate);\n        if (keyOriginal)\n            cache.set(keyOriginal, isoEstimate);\n        if (date.year === undefined ||\n            date.month === undefined ||\n            date.day === undefined ||\n            date.monthCode === undefined ||\n            (this.hasEra && (date.era === undefined || date.eraYear === undefined))) {\n            throw new RangeError('Unexpected missing property');\n        }\n        if (!maybeConstrained) {\n            // Also cache the reverse mapping\n            const keyReverse = JSON.stringify({\n                func: 'isoToCalendarDate',\n                isoYear: isoEstimate.year,\n                isoMonth: isoEstimate.month,\n                isoDay: isoEstimate.day,\n                id: this.id\n            });\n            cache.set(keyReverse, date);\n        }\n        return isoEstimate;\n    }\n    temporalToCalendarDate(date, cache) {\n        const isoDate = { year: GetSlot(date, ISO_YEAR), month: GetSlot(date, ISO_MONTH), day: GetSlot(date, ISO_DAY) };\n        const result = this.isoToCalendarDate(isoDate, cache);\n        return result;\n    }\n    compareCalendarDates(date1Param, date2Param) {\n        // `date1` and `date2` are already records. The calls below simply validate\n        // that all three required fields are present.\n        const date1 = PrepareTemporalFields(date1Param, [['day'], ['month'], ['year']]);\n        const date2 = PrepareTemporalFields(date2Param, [['day'], ['month'], ['year']]);\n        if (date1.year !== date2.year)\n            return ComparisonResult(date1.year - date2.year);\n        if (date1.month !== date2.month)\n            return ComparisonResult(date1.month - date2.month);\n        if (date1.day !== date2.day)\n            return ComparisonResult(date1.day - date2.day);\n        return 0;\n    }\n    /** Ensure that a calendar date actually exists. If not, return the closest earlier date. */\n    regulateDate(calendarDate, overflow = 'constrain', cache) {\n        const isoDate = this.calendarToIsoDate(calendarDate, overflow, cache);\n        return this.isoToCalendarDate(isoDate, cache);\n    }\n    addDaysIso(isoDate, days) {\n        const added = AddISODate(isoDate.year, isoDate.month, isoDate.day, 0, 0, 0, days, 'constrain');\n        return added;\n    }\n    addDaysCalendar(calendarDate, days, cache) {\n        const isoDate = this.calendarToIsoDate(calendarDate, 'constrain', cache);\n        const addedIso = this.addDaysIso(isoDate, days);\n        const addedCalendar = this.isoToCalendarDate(addedIso, cache);\n        return addedCalendar;\n    }\n    addMonthsCalendar(calendarDateParam, months, overflow, cache) {\n        let calendarDate = calendarDateParam;\n        const { day } = calendarDate;\n        for (let i = 0, absMonths = MathAbs$1(months); i < absMonths; i++) {\n            const { month } = calendarDate;\n            const oldCalendarDate = calendarDate;\n            const days = months < 0\n                ? -Math.max(day, this.daysInPreviousMonth(calendarDate, cache))\n                : this.daysInMonth(calendarDate, cache);\n            const isoDate = this.calendarToIsoDate(calendarDate, 'constrain', cache);\n            let addedIso = this.addDaysIso(isoDate, days);\n            calendarDate = this.isoToCalendarDate(addedIso, cache);\n            // Normally, we can advance one month by adding the number of days in the\n            // current month. However, if we're at the end of the current month and\n            // the next month has fewer days, then we rolled over to the after-next\n            // month. Below we detect this condition and back up until we're back in\n            // the desired month.\n            if (months > 0) {\n                const monthsInOldYear = this.monthsInYear(oldCalendarDate, cache);\n                while (calendarDate.month - 1 !== month % monthsInOldYear) {\n                    addedIso = this.addDaysIso(addedIso, -1);\n                    calendarDate = this.isoToCalendarDate(addedIso, cache);\n                }\n            }\n            if (calendarDate.day !== day) {\n                // try to retain the original day-of-month, if possible\n                calendarDate = this.regulateDate({ ...calendarDate, day }, 'constrain', cache);\n            }\n        }\n        if (overflow === 'reject' && calendarDate.day !== day) {\n            throw new RangeError(`Day ${day} does not exist in resulting calendar month`);\n        }\n        return calendarDate;\n    }\n    addCalendar(calendarDate, { years = 0, months = 0, weeks = 0, days = 0 }, overflow, cache) {\n        const { year, month, day } = calendarDate;\n        const addedMonths = this.addMonthsCalendar({ year: year + years, month, day }, months, overflow, cache);\n        const initialDays = days + weeks * 7;\n        const addedDays = this.addDaysCalendar(addedMonths, initialDays, cache);\n        return addedDays;\n    }\n    untilCalendar(calendarOne, calendarTwo, largestUnit, cache) {\n        let days = 0;\n        let weeks = 0;\n        let months = 0;\n        let years = 0;\n        switch (largestUnit) {\n            case 'day':\n                days = this.calendarDaysUntil(calendarOne, calendarTwo, cache);\n                break;\n            case 'week': {\n                const totalDays = this.calendarDaysUntil(calendarOne, calendarTwo, cache);\n                days = totalDays % 7;\n                weeks = (totalDays - days) / 7;\n                break;\n            }\n            case 'month':\n            case 'year': {\n                const diffYears = calendarTwo.year - calendarOne.year;\n                const diffMonths = calendarTwo.month - calendarOne.month;\n                const diffDays = calendarTwo.day - calendarOne.day;\n                const sign = this.compareCalendarDates(calendarTwo, calendarOne);\n                if (largestUnit === 'year' && diffYears) {\n                    const isOneFurtherInYear = diffMonths * sign < 0 || (diffMonths === 0 && diffDays * sign < 0);\n                    years = isOneFurtherInYear ? diffYears - sign : diffYears;\n                }\n                const yearsAdded = years ? this.addCalendar(calendarOne, { years }, 'constrain', cache) : calendarOne;\n                // Now we have less than one year remaining. Add one month at a time\n                // until we go over the target, then back up one month and calculate\n                // remaining days and weeks.\n                let current;\n                let next = yearsAdded;\n                do {\n                    months += sign;\n                    current = next;\n                    next = this.addMonthsCalendar(current, sign, 'constrain', cache);\n                    if (next.day !== calendarOne.day) {\n                        // In case the day was constrained down, try to un-constrain it\n                        next = this.regulateDate({ ...next, day: calendarOne.day }, 'constrain', cache);\n                    }\n                } while (this.compareCalendarDates(calendarTwo, next) * sign >= 0);\n                months -= sign; // correct for loop above which overshoots by 1\n                const remainingDays = this.calendarDaysUntil(current, calendarTwo, cache);\n                days = remainingDays;\n                break;\n            }\n        }\n        return { years, months, weeks, days };\n    }\n    daysInMonth(calendarDate, cache) {\n        // Add enough days to roll over to the next month. One we're in the next\n        // month, we can calculate the length of the current month. NOTE: This\n        // algorithm assumes that months are continuous. It would break if a\n        // calendar skipped days, like the Julian->Gregorian switchover. But the\n        // only ICU calendars that currently skip days (japanese/roc/buddhist) is a\n        // bug (https://bugs.chromium.org/p/chromium/issues/detail?id=1173158)\n        // that's currently detected by `checkIcuBugs()` which will throw. So this\n        // code should be safe for all ICU calendars.\n        const { day } = calendarDate;\n        const max = this.maximumMonthLength(calendarDate);\n        const min = this.minimumMonthLength(calendarDate);\n        // easiest case: we already know the month length if min and max are the same.\n        if (min === max)\n            return min;\n        // Add enough days to get into the next month, without skipping it\n        const increment = day <= max - min ? max : min;\n        const isoDate = this.calendarToIsoDate(calendarDate, 'constrain', cache);\n        const addedIsoDate = this.addDaysIso(isoDate, increment);\n        const addedCalendarDate = this.isoToCalendarDate(addedIsoDate, cache);\n        // Now back up to the last day of the original month\n        const endOfMonthIso = this.addDaysIso(addedIsoDate, -addedCalendarDate.day);\n        const endOfMonthCalendar = this.isoToCalendarDate(endOfMonthIso, cache);\n        return endOfMonthCalendar.day;\n    }\n    daysInPreviousMonth(calendarDate, cache) {\n        const { day, month, year } = calendarDate;\n        // Check to see if we already know the month length, and return it if so\n        const previousMonthYear = month > 1 ? year : year - 1;\n        let previousMonthDate = { year: previousMonthYear, month, day: 1 };\n        const previousMonth = month > 1 ? month - 1 : this.monthsInYear(previousMonthDate, cache);\n        previousMonthDate = { ...previousMonthDate, month: previousMonth };\n        const min = this.minimumMonthLength(previousMonthDate);\n        const max = this.maximumMonthLength(previousMonthDate);\n        if (min === max)\n            return max;\n        const isoDate = this.calendarToIsoDate(calendarDate, 'constrain', cache);\n        const lastDayOfPreviousMonthIso = this.addDaysIso(isoDate, -day);\n        const lastDayOfPreviousMonthCalendar = this.isoToCalendarDate(lastDayOfPreviousMonthIso, cache);\n        return lastDayOfPreviousMonthCalendar.day;\n    }\n    startOfCalendarYear(calendarDate) {\n        return { year: calendarDate.year, month: 1, day: 1 };\n    }\n    startOfCalendarMonth(calendarDate) {\n        return { year: calendarDate.year, month: calendarDate.month, day: 1 };\n    }\n    calendarDaysUntil(calendarOne, calendarTwo, cache) {\n        const oneIso = this.calendarToIsoDate(calendarOne, 'constrain', cache);\n        const twoIso = this.calendarToIsoDate(calendarTwo, 'constrain', cache);\n        return this.isoDaysUntil(oneIso, twoIso);\n    }\n    isoDaysUntil(oneIso, twoIso) {\n        const duration = DifferenceISODate(oneIso.year, oneIso.month, oneIso.day, twoIso.year, twoIso.month, twoIso.day, 'day');\n        return duration.days;\n    }\n    monthDayFromFields(fields, overflow, cache) {\n        let { year, month, monthCode, day, era, eraYear } = fields;\n        if (monthCode === undefined) {\n            if (year === undefined && (era === undefined || eraYear === undefined)) {\n                throw new TypeError('`monthCode`, `year`, or `era` and `eraYear` is required');\n            }\n            ({ monthCode, year } = this.adjustCalendarDate({ year, month, monthCode, day, era, eraYear }, cache, overflow));\n        }\n        let isoYear, isoMonth, isoDay;\n        let closestCalendar, closestIso;\n        // Look backwards starting from the calendar year of 1972-01-01 up to 100\n        // calendar years to find a year that has this month and day. Normal months\n        // and days will match immediately, but for leap days and leap months we may\n        // have to look for a while.\n        const startDateIso = { year: 1972, month: 1, day: 1 };\n        const { year: calendarYear } = this.isoToCalendarDate(startDateIso, cache);\n        for (let i = 0; i < 100; i++) {\n            const testCalendarDate = this.adjustCalendarDate({ day, monthCode, year: calendarYear - i }, cache);\n            const isoDate = this.calendarToIsoDate(testCalendarDate, 'constrain', cache);\n            const roundTripCalendarDate = this.isoToCalendarDate(isoDate, cache);\n            ({ year: isoYear, month: isoMonth, day: isoDay } = isoDate);\n            if (roundTripCalendarDate.monthCode === monthCode && roundTripCalendarDate.day === day) {\n                return { month: isoMonth, day: isoDay, year: isoYear };\n            }\n            else if (overflow === 'constrain') {\n                // non-ISO constrain algorithm tries to find the closest date in a matching month\n                if (closestCalendar === undefined ||\n                    (roundTripCalendarDate.monthCode === closestCalendar.monthCode &&\n                        roundTripCalendarDate.day > closestCalendar.day)) {\n                    closestCalendar = roundTripCalendarDate;\n                    closestIso = isoDate;\n                }\n            }\n        }\n        if (overflow === 'constrain' && closestIso !== undefined)\n            return closestIso;\n        throw new RangeError(`No recent ${this.id} year with monthCode ${monthCode} and day ${day}`);\n    }\n}\nclass HebrewHelper extends HelperBase {\n    constructor() {\n        super(...arguments);\n        this.id = 'hebrew';\n        this.calendarType = 'lunisolar';\n        this.months = {\n            Tishri: { leap: 1, regular: 1, monthCode: 'M01', days: 30 },\n            Heshvan: { leap: 2, regular: 2, monthCode: 'M02', days: { min: 29, max: 30 } },\n            Kislev: { leap: 3, regular: 3, monthCode: 'M03', days: { min: 29, max: 30 } },\n            Tevet: { leap: 4, regular: 4, monthCode: 'M04', days: 29 },\n            Shevat: { leap: 5, regular: 5, monthCode: 'M05', days: 30 },\n            Adar: { leap: undefined, regular: 6, monthCode: 'M06', days: 29 },\n            'Adar I': { leap: 6, regular: undefined, monthCode: 'M05L', days: 30 },\n            'Adar II': { leap: 7, regular: undefined, monthCode: 'M06', days: 29 },\n            Nisan: { leap: 8, regular: 7, monthCode: 'M07', days: 30 },\n            Iyar: { leap: 9, regular: 8, monthCode: 'M08', days: 29 },\n            Sivan: { leap: 10, regular: 9, monthCode: 'M09', days: 30 },\n            Tamuz: { leap: 11, regular: 10, monthCode: 'M10', days: 29 },\n            Av: { leap: 12, regular: 11, monthCode: 'M11', days: 30 },\n            Elul: { leap: 13, regular: 12, monthCode: 'M12', days: 29 }\n        };\n        // All built-in calendars except Chinese/Dangi and Hebrew use an era\n        this.hasEra = false;\n    }\n    inLeapYear(calendarDate) {\n        const { year } = calendarDate;\n        // FYI: In addition to adding a month in leap years, the Hebrew calendar\n        // also has per-year changes to the number of days of Heshvan and Kislev.\n        // Given that these can be calculated by counting the number of days in\n        // those months, I assume that these DO NOT need to be exposed as\n        // Hebrew-only prototype fields or methods.\n        return (7 * year + 1) % 19 < 7;\n    }\n    monthsInYear(calendarDate) {\n        return this.inLeapYear(calendarDate) ? 13 : 12;\n    }\n    minimumMonthLength(calendarDate) {\n        return this.minMaxMonthLength(calendarDate, 'min');\n    }\n    maximumMonthLength(calendarDate) {\n        return this.minMaxMonthLength(calendarDate, 'max');\n    }\n    minMaxMonthLength(calendarDate, minOrMax) {\n        const { month, year } = calendarDate;\n        const monthCode = this.getMonthCode(year, month);\n        const monthInfo = ObjectEntries(this.months).find((m) => m[1].monthCode === monthCode);\n        if (monthInfo === undefined)\n            throw new RangeError(`unmatched Hebrew month: ${month}`);\n        const daysInMonth = monthInfo[1].days;\n        return typeof daysInMonth === 'number' ? daysInMonth : daysInMonth[minOrMax];\n    }\n    /** Take a guess at what ISO date a particular calendar date corresponds to */\n    estimateIsoDate(calendarDate) {\n        const { year } = calendarDate;\n        return { year: year - 3760, month: 1, day: 1 };\n    }\n    getMonthCode(year, month) {\n        if (this.inLeapYear({ year })) {\n            return month === 6 ? buildMonthCode(5, true) : buildMonthCode(month < 6 ? month : month - 1);\n        }\n        else {\n            return buildMonthCode(month);\n        }\n    }\n    adjustCalendarDate(calendarDate, cache, overflow = 'constrain', fromLegacyDate = false) {\n        // The incoming type is actually CalendarDate (same as args to\n        // Calendar.dateFromParams) but TS isn't smart enough to follow all the\n        // reassignments below, so as an alternative to 10+ type casts, we'll lie\n        // here and claim that the type has `day` and `year` filled in already.\n        let { year, eraYear, month, monthCode, day, monthExtra } = calendarDate;\n        if (year === undefined && eraYear !== undefined)\n            year = eraYear;\n        if (eraYear === undefined && year !== undefined)\n            eraYear = year;\n        if (fromLegacyDate) {\n            // In Pre Node-14 V8, DateTimeFormat.formatToParts `month: 'numeric'`\n            // output returns the numeric equivalent of `month` as a string, meaning\n            // that `'6'` in a leap year is Adar I, while `'6'` in a non-leap year\n            // means Adar. In this case, `month` will already be correct and no action\n            // is needed. However, in Node 14 and later formatToParts returns the name\n            // of the Hebrew month (e.g. \"Tevet\"), so we'll need to look up the\n            // correct `month` using the string name as a key.\n            if (monthExtra) {\n                const monthInfo = this.months[monthExtra];\n                if (!monthInfo)\n                    throw new RangeError(`Unrecognized month from formatToParts: ${monthExtra}`);\n                month = this.inLeapYear({ year }) ? monthInfo.leap : monthInfo.regular;\n            }\n            // Because we're getting data from legacy Date, then `month` will always be present\n            monthCode = this.getMonthCode(year, month);\n            const result = { year, month: month, day, era: undefined, eraYear, monthCode };\n            return result;\n        }\n        else {\n            // When called without input coming from legacy Date output, simply ensure\n            // that all fields are present.\n            this.validateCalendarDate(calendarDate);\n            if (month === undefined) {\n                if (monthCode.endsWith('L')) {\n                    if (monthCode !== 'M05L') {\n                        throw new RangeError(`Hebrew leap month must have monthCode M05L, not ${monthCode}`);\n                    }\n                    month = 6;\n                    if (!this.inLeapYear({ year })) {\n                        if (overflow === 'reject') {\n                            throw new RangeError(`Hebrew monthCode M05L is invalid in year ${year} which is not a leap year`);\n                        }\n                        else {\n                            // constrain to last day of previous month (Av)\n                            month = 5;\n                            day = 30;\n                            monthCode = 'M05';\n                        }\n                    }\n                }\n                else {\n                    month = monthCodeNumberPart(monthCode);\n                    // if leap month is before this one, the month index is one more than the month code\n                    if (this.inLeapYear({ year }) && month > 6)\n                        month++;\n                    const largestMonth = this.monthsInYear({ year });\n                    if (month < 1 || month > largestMonth)\n                        throw new RangeError(`Invalid monthCode: ${monthCode}`);\n                }\n            }\n            else {\n                if (overflow === 'reject') {\n                    RejectToRange(month, 1, this.monthsInYear({ year }));\n                    RejectToRange(day, 1, this.maximumMonthLength({ year, month }));\n                }\n                else {\n                    month = ConstrainToRange(month, 1, this.monthsInYear({ year }));\n                    day = ConstrainToRange(day, 1, this.maximumMonthLength({ year, month }));\n                }\n                if (monthCode === undefined) {\n                    monthCode = this.getMonthCode(year, month);\n                }\n                else {\n                    const calculatedMonthCode = this.getMonthCode(year, month);\n                    if (calculatedMonthCode !== monthCode) {\n                        throw new RangeError(`monthCode ${monthCode} doesn't correspond to month ${month} in Hebrew year ${year}`);\n                    }\n                }\n            }\n            return { ...calendarDate, day, month, monthCode: monthCode, year, eraYear };\n        }\n    }\n}\n/**\n * For Temporal purposes, the Islamic calendar is simple because it's always the\n * same 12 months in the same order.\n */\nclass IslamicBaseHelper extends HelperBase {\n    constructor() {\n        super(...arguments);\n        this.calendarType = 'lunar';\n        this.DAYS_PER_ISLAMIC_YEAR = 354 + 11 / 30;\n        this.DAYS_PER_ISO_YEAR = 365.2425;\n        this.constantEra = 'ah';\n    }\n    inLeapYear(calendarDate, cache) {\n        // In leap years, the 12th month has 30 days. In non-leap years: 29.\n        const days = this.daysInMonth({ year: calendarDate.year, month: 12, day: 1 }, cache);\n        return days === 30;\n    }\n    monthsInYear( /* calendarYear, cache */) {\n        return 12;\n    }\n    minimumMonthLength( /* calendarDate */) {\n        return 29;\n    }\n    maximumMonthLength( /* calendarDate */) {\n        return 30;\n    }\n    estimateIsoDate(calendarDate) {\n        const { year } = this.adjustCalendarDate(calendarDate);\n        return { year: MathFloor$1((year * this.DAYS_PER_ISLAMIC_YEAR) / this.DAYS_PER_ISO_YEAR) + 622, month: 1, day: 1 };\n    }\n}\n// There are 6 Islamic calendars with the same implementation in this polyfill.\n// They vary only in their ID. They do emit different output from the underlying\n// Intl implementation, but our code for each of them is identical.\nclass IslamicHelper extends IslamicBaseHelper {\n    constructor() {\n        super(...arguments);\n        this.id = 'islamic';\n    }\n}\nclass IslamicUmalquraHelper extends IslamicBaseHelper {\n    constructor() {\n        super(...arguments);\n        this.id = 'islamic-umalqura';\n    }\n}\nclass IslamicTblaHelper extends IslamicBaseHelper {\n    constructor() {\n        super(...arguments);\n        this.id = 'islamic-tbla';\n    }\n}\nclass IslamicCivilHelper extends IslamicBaseHelper {\n    constructor() {\n        super(...arguments);\n        this.id = 'islamic-civil';\n    }\n}\nclass IslamicRgsaHelper extends IslamicBaseHelper {\n    constructor() {\n        super(...arguments);\n        this.id = 'islamic-rgsa';\n    }\n}\nclass IslamicCcHelper extends IslamicBaseHelper {\n    constructor() {\n        super(...arguments);\n        this.id = 'islamicc';\n    }\n}\nclass PersianHelper extends HelperBase {\n    constructor() {\n        super(...arguments);\n        this.id = 'persian';\n        this.calendarType = 'solar';\n        this.constantEra = 'ap';\n    }\n    inLeapYear(calendarDate, cache) {\n        // Same logic (count days in the last month) for Persian as for Islamic,\n        // even though Persian is solar and Islamic is lunar.\n        return IslamicHelper.prototype.inLeapYear.call(this, calendarDate, cache);\n    }\n    monthsInYear( /* calendarYear, cache */) {\n        return 12;\n    }\n    minimumMonthLength(calendarDate) {\n        const { month } = calendarDate;\n        if (month === 12)\n            return 29;\n        return month <= 6 ? 31 : 30;\n    }\n    maximumMonthLength(calendarDate) {\n        const { month } = calendarDate;\n        if (month === 12)\n            return 30;\n        return month <= 6 ? 31 : 30;\n    }\n    estimateIsoDate(calendarDate) {\n        const { year } = this.adjustCalendarDate(calendarDate);\n        return { year: year + 621, month: 1, day: 1 };\n    }\n}\nclass IndianHelper extends HelperBase {\n    constructor() {\n        super(...arguments);\n        this.id = 'indian';\n        this.calendarType = 'solar';\n        this.constantEra = 'saka';\n        // Indian months always start at the same well-known Gregorian month and\n        // day. So this conversion is easy and fast. See\n        // https://en.wikipedia.org/wiki/Indian_national_calendar\n        this.months = {\n            1: { length: 30, month: 3, day: 22, leap: { length: 31, month: 3, day: 21 } },\n            2: { length: 31, month: 4, day: 21 },\n            3: { length: 31, month: 5, day: 22 },\n            4: { length: 31, month: 6, day: 22 },\n            5: { length: 31, month: 7, day: 23 },\n            6: { length: 31, month: 8, day: 23 },\n            7: { length: 30, month: 9, day: 23 },\n            8: { length: 30, month: 10, day: 23 },\n            9: { length: 30, month: 11, day: 22 },\n            10: { length: 30, month: 12, day: 22 },\n            11: { length: 30, month: 1, nextYear: true, day: 21 },\n            12: { length: 30, month: 2, nextYear: true, day: 20 }\n        };\n        // https://bugs.chromium.org/p/v8/issues/detail?id=10529 causes Intl's Indian\n        // calendar output to fail for all dates before 0001-01-01 ISO.  For example,\n        // in Node 12 0000-01-01 is calculated as 6146/12/-583 instead of 10/11/-79 as\n        // expected.\n        this.vulnerableToBceBug = new Date('0000-01-01T00:00Z').toLocaleDateString('en-US-u-ca-indian', { timeZone: 'UTC' }) !== '10/11/-79 Saka';\n    }\n    inLeapYear(calendarDate) {\n        // From https://en.wikipedia.org/wiki/Indian_national_calendar:\n        // Years are counted in the Saka era, which starts its year 0 in the year 78\n        // of the Common Era. To determine leap years, add 78 to the Saka year  if\n        // the result is a leap year in the Gregorian calendar, then the Saka year\n        // is a leap year as well.\n        return isGregorianLeapYear(calendarDate.year + 78);\n    }\n    monthsInYear( /* calendarYear, cache */) {\n        return 12;\n    }\n    minimumMonthLength(calendarDate) {\n        return this.getMonthInfo(calendarDate).length;\n    }\n    maximumMonthLength(calendarDate) {\n        return this.getMonthInfo(calendarDate).length;\n    }\n    getMonthInfo(calendarDate) {\n        const { month } = calendarDate;\n        let monthInfo = this.months[month];\n        if (monthInfo === undefined)\n            throw new RangeError(`Invalid month: ${month}`);\n        if (this.inLeapYear(calendarDate) && monthInfo.leap)\n            monthInfo = monthInfo.leap;\n        return monthInfo;\n    }\n    estimateIsoDate(calendarDateParam) {\n        // FYI, this \"estimate\" is always the exact ISO date, which makes the Indian\n        // calendar fast!\n        const calendarDate = this.adjustCalendarDate(calendarDateParam);\n        const monthInfo = this.getMonthInfo(calendarDate);\n        const isoYear = calendarDate.year + 78 + (monthInfo.nextYear ? 1 : 0);\n        const isoMonth = monthInfo.month;\n        const isoDay = monthInfo.day;\n        const isoDate = AddISODate(isoYear, isoMonth, isoDay, 0, 0, 0, calendarDate.day - 1, 'constrain');\n        return isoDate;\n    }\n    checkIcuBugs(isoDate) {\n        if (this.vulnerableToBceBug && isoDate.year < 1) {\n            throw new RangeError(`calendar '${this.id}' is broken for ISO dates before 0001-01-01` +\n                ' (see https://bugs.chromium.org/p/v8/issues/detail?id=10529)');\n        }\n    }\n}\n/**\n * This function adds additional metadata that makes it easier to work with\n * eras. Note that it mutates and normalizes the original era objects, which is\n * OK because this is non-observable, internal-only metadata.\n *\n * The result is an array of eras with the shape defined above.\n * */\nfunction adjustEras(erasParam) {\n    let eras = erasParam;\n    if (eras.length === 0) {\n        throw new RangeError('Invalid era data: eras are required');\n    }\n    if (eras.length === 1 && eras[0].reverseOf) {\n        throw new RangeError('Invalid era data: anchor era cannot count years backwards');\n    }\n    if (eras.length === 1 && !eras[0].name) {\n        throw new RangeError('Invalid era data: at least one named era is required');\n    }\n    if (eras.filter((e) => e.reverseOf != null).length > 1) {\n        throw new RangeError('Invalid era data: only one era can count years backwards');\n    }\n    // Find the \"anchor era\" which is the era used for (era-less) `year`. Reversed\n    // eras can never be anchors. The era without an `anchorEpoch` property is the\n    // anchor.\n    let anchorEra;\n    eras.forEach((e) => {\n        if (e.isAnchor || (!e.anchorEpoch && !e.reverseOf)) {\n            if (anchorEra)\n                throw new RangeError('Invalid era data: cannot have multiple anchor eras');\n            anchorEra = e;\n            e.anchorEpoch = { year: e.hasYearZero ? 0 : 1 };\n        }\n        else if (!e.name) {\n            throw new RangeError('If era name is blank, it must be the anchor era');\n        }\n    });\n    // If the era name is undefined, then it's an anchor that doesn't interact\n    // with eras at all. For example, Japanese `year` is always the same as ISO\n    // `year`.  So this \"era\" is the anchor era but isn't used for era matching.\n    // Strip it from the list that's returned.\n    eras = eras.filter((e) => e.name);\n    eras.forEach((e) => {\n        // Some eras are mirror images of another era e.g. B.C. is the reverse of A.D.\n        // Replace the string-valued \"reverseOf\" property with the actual era object\n        // that's reversed.\n        const { reverseOf } = e;\n        if (reverseOf) {\n            const reversedEra = eras.find((era) => era.name === reverseOf);\n            if (reversedEra === undefined)\n                throw new RangeError(`Invalid era data: unmatched reverseOf era: ${reverseOf}`);\n            e.reverseOf = reversedEra;\n            e.anchorEpoch = reversedEra.anchorEpoch;\n            e.isoEpoch = reversedEra.isoEpoch;\n        }\n        if (e.anchorEpoch.month === undefined)\n            e.anchorEpoch.month = 1;\n        if (e.anchorEpoch.day === undefined)\n            e.anchorEpoch.day = 1;\n    });\n    // Ensure that the latest epoch is first in the array. This lets us try to\n    // match eras in index order, with the last era getting the remaining older\n    // years. Any reverse-signed era must be at the end.\n    ArraySort.call(eras, (e1, e2) => {\n        if (e1.reverseOf)\n            return 1;\n        if (e2.reverseOf)\n            return -1;\n        if (!e1.isoEpoch || !e2.isoEpoch)\n            throw new RangeError('Invalid era data: missing ISO epoch');\n        return e2.isoEpoch.year - e1.isoEpoch.year;\n    });\n    // If there's a reversed era, then the one before it must be the era that's\n    // being reversed.\n    const lastEraReversed = eras[eras.length - 1].reverseOf;\n    if (lastEraReversed) {\n        if (lastEraReversed !== eras[eras.length - 2])\n            throw new RangeError('Invalid era data: invalid reverse-sign era');\n    }\n    // Finally, add a \"genericName\" property in the format \"era{n} where `n` is\n    // zero-based index, with the oldest era being zero. This format is used by\n    // older versions of ICU data.\n    eras.forEach((e, i) => {\n        e.genericName = `era${eras.length - 1 - i}`;\n    });\n    return { eras: eras, anchorEra: (anchorEra || eras[0]) };\n}\nfunction isGregorianLeapYear(year) {\n    return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);\n}\n/** Base for all Gregorian-like calendars. */\nclass GregorianBaseHelper extends HelperBase {\n    constructor(id, originalEras) {\n        super();\n        this.calendarType = 'solar';\n        // Several calendars based on the Gregorian calendar use Julian dates (not\n        // proleptic Gregorian dates) before the Julian switchover in Oct 1582. See\n        // https://bugs.chromium.org/p/chromium/issues/detail?id=1173158.\n        this.v8IsVulnerableToJulianBug = new Date('+001001-01-01T00:00Z')\n            .toLocaleDateString('en-US-u-ca-japanese', { timeZone: 'UTC' })\n            .startsWith('12');\n        this.calendarIsVulnerableToJulianBug = false;\n        this.id = id;\n        const { eras, anchorEra } = adjustEras(originalEras);\n        this.anchorEra = anchorEra;\n        this.eras = eras;\n    }\n    inLeapYear(calendarDate) {\n        // Calendars that don't override this method use the same months and leap\n        // years as Gregorian. Once we know the ISO year corresponding to the\n        // calendar year, we'll know if it's a leap year or not.\n        const { year } = this.estimateIsoDate({ month: 1, day: 1, year: calendarDate.year });\n        return isGregorianLeapYear(year);\n    }\n    monthsInYear( /* calendarDate */) {\n        return 12;\n    }\n    minimumMonthLength(calendarDate) {\n        const { month } = calendarDate;\n        if (month === 2)\n            return this.inLeapYear(calendarDate) ? 29 : 28;\n        return [4, 6, 9, 11].indexOf(month) >= 0 ? 30 : 31;\n    }\n    maximumMonthLength(calendarDate) {\n        return this.minimumMonthLength(calendarDate);\n    }\n    /** Fill in missing parts of the (year, era, eraYear) tuple */\n    completeEraYear(calendarDate) {\n        const checkField = (name, value) => {\n            const currentValue = calendarDate[name];\n            if (currentValue != null && currentValue != value) {\n                throw new RangeError(`Input ${name} ${currentValue} doesn't match calculated value ${value}`);\n            }\n        };\n        const eraFromYear = (year) => {\n            let eraYear;\n            const adjustedCalendarDate = { ...calendarDate, year };\n            const matchingEra = this.eras.find((e, i) => {\n                if (i === this.eras.length - 1) {\n                    if (e.reverseOf) {\n                        // This is a reverse-sign era (like BCE) which must be the oldest\n                        // era. Count years backwards.\n                        if (year > 0)\n                            throw new RangeError(`Signed year ${year} is invalid for era ${e.name}`);\n                        eraYear = e.anchorEpoch.year - year;\n                        return true;\n                    }\n                    // last era always gets all \"leftover\" (older than epoch) years,\n                    // so no need for a comparison like below.\n                    eraYear = year - e.anchorEpoch.year + (e.hasYearZero ? 0 : 1);\n                    return true;\n                }\n                const comparison = this.compareCalendarDates(adjustedCalendarDate, e.anchorEpoch);\n                if (comparison >= 0) {\n                    eraYear = year - e.anchorEpoch.year + (e.hasYearZero ? 0 : 1);\n                    return true;\n                }\n                return false;\n            });\n            if (!matchingEra)\n                throw new RangeError(`Year ${year} was not matched by any era`);\n            return { eraYear: eraYear, era: matchingEra.name };\n        };\n        let { year, eraYear, era } = calendarDate;\n        if (year != null) {\n            ({ eraYear, era } = eraFromYear(year));\n            checkField('era', era);\n            checkField('eraYear', eraYear);\n        }\n        else if (eraYear != null) {\n            const matchingEra = era === undefined ? undefined : this.eras.find((e) => e.name === era || e.genericName === era);\n            if (!matchingEra)\n                throw new RangeError(`Era ${era} (ISO year ${eraYear}) was not matched by any era`);\n            if (eraYear < 1 && matchingEra.reverseOf) {\n                throw new RangeError(`Years in ${era} era must be positive, not ${year}`);\n            }\n            if (matchingEra.reverseOf) {\n                year = matchingEra.anchorEpoch.year - eraYear;\n            }\n            else {\n                year = eraYear + matchingEra.anchorEpoch.year - (matchingEra.hasYearZero ? 0 : 1);\n            }\n            checkField('year', year);\n            // We'll accept dates where the month/day is earlier than the start of\n            // the era or after its end as long as it's in the same year. If that\n            // happens, we'll adjust the era/eraYear pair to be the correct era for\n            // the `year`.\n            ({ eraYear, era } = eraFromYear(year));\n        }\n        else {\n            throw new RangeError('Either `year` or `eraYear` and `era` are required');\n        }\n        return { ...calendarDate, year, eraYear, era };\n    }\n    adjustCalendarDate(calendarDateParam, cache, overflow = 'constrain') {\n        let calendarDate = calendarDateParam;\n        // Because this is not a lunisolar calendar, it's safe to convert monthCode to a number\n        const { month, monthCode } = calendarDate;\n        if (month === undefined)\n            calendarDate = { ...calendarDate, month: monthCodeNumberPart(monthCode) };\n        this.validateCalendarDate(calendarDate);\n        calendarDate = this.completeEraYear(calendarDate);\n        return super.adjustCalendarDate(calendarDate, cache, overflow);\n    }\n    estimateIsoDate(calendarDateParam) {\n        const calendarDate = this.adjustCalendarDate(calendarDateParam);\n        const { year, month, day } = calendarDate;\n        const { anchorEra } = this;\n        const isoYearEstimate = year + anchorEra.isoEpoch.year - (anchorEra.hasYearZero ? 0 : 1);\n        return RegulateISODate(isoYearEstimate, month, day, 'constrain');\n    }\n    checkIcuBugs(isoDate) {\n        if (this.calendarIsVulnerableToJulianBug && this.v8IsVulnerableToJulianBug) {\n            const beforeJulianSwitch = CompareISODate(isoDate.year, isoDate.month, isoDate.day, 1582, 10, 15) < 0;\n            if (beforeJulianSwitch) {\n                throw new RangeError(`calendar '${this.id}' is broken for ISO dates before 1582-10-15` +\n                    ' (see https://bugs.chromium.org/p/chromium/issues/detail?id=1173158)');\n            }\n        }\n    }\n}\nclass OrthodoxBaseHelper extends GregorianBaseHelper {\n    constructor(id, originalEras) {\n        super(id, originalEras);\n    }\n    inLeapYear(calendarDate) {\n        // Leap years happen one year before the Julian leap year. Note that this\n        // calendar is based on the Julian calendar which has a leap year every 4\n        // years, unlike the Gregorian calendar which doesn't have leap years on\n        // years divisible by 100 except years divisible by 400.\n        //\n        // Note that we're assuming that leap years in before-epoch times match\n        // how leap years are defined now. This is probably not accurate but I'm\n        // not sure how better to do it.\n        const { year } = calendarDate;\n        return (year + 1) % 4 === 0;\n    }\n    monthsInYear( /* calendarDate */) {\n        return 13;\n    }\n    minimumMonthLength(calendarDate) {\n        const { month } = calendarDate;\n        // Ethiopian/Coptic calendars have 12 30-day months and an extra 5-6 day 13th month.\n        if (month === 13)\n            return this.inLeapYear(calendarDate) ? 6 : 5;\n        return 30;\n    }\n    maximumMonthLength(calendarDate) {\n        return this.minimumMonthLength(calendarDate);\n    }\n}\n// `coptic` and `ethiopic` calendars are very similar to `ethioaa` calendar,\n// with the following differences:\n// - Coptic uses BCE-like positive numbers for years before its epoch (the other\n//   two use negative year numbers before epoch)\n// - Coptic has a different epoch date\n// - Ethiopic has an additional second era that starts at the same date as the\n//   zero era of ethioaa.\nclass EthioaaHelper extends OrthodoxBaseHelper {\n    constructor() {\n        super('ethioaa', [{ name: 'era0', isoEpoch: { year: -5492, month: 7, day: 17 } }]);\n    }\n}\nclass CopticHelper extends OrthodoxBaseHelper {\n    constructor() {\n        super('coptic', [\n            { name: 'era1', isoEpoch: { year: 284, month: 8, day: 29 } },\n            { name: 'era0', reverseOf: 'era1' }\n        ]);\n    }\n}\n// Anchor is currently the older era to match ethioaa, but should it be the newer era?\n// See https://github.com/tc39/ecma402/issues/534 for discussion.\nclass EthiopicHelper extends OrthodoxBaseHelper {\n    constructor() {\n        super('ethiopic', [\n            { name: 'era0', isoEpoch: { year: -5492, month: 7, day: 17 } },\n            { name: 'era1', isoEpoch: { year: 8, month: 8, day: 27 }, anchorEpoch: { year: 5501 } }\n        ]);\n    }\n}\nclass RocHelper extends GregorianBaseHelper {\n    constructor() {\n        super('roc', [\n            { name: 'minguo', isoEpoch: { year: 1912, month: 1, day: 1 } },\n            { name: 'before-roc', reverseOf: 'minguo' }\n        ]);\n        this.calendarIsVulnerableToJulianBug = true;\n    }\n}\nclass BuddhistHelper extends GregorianBaseHelper {\n    constructor() {\n        super('buddhist', [{ name: 'be', hasYearZero: true, isoEpoch: { year: -543, month: 1, day: 1 } }]);\n        this.calendarIsVulnerableToJulianBug = true;\n    }\n}\nclass GregoryHelper extends GregorianBaseHelper {\n    constructor() {\n        super('gregory', [\n            { name: 'ce', isoEpoch: { year: 1, month: 1, day: 1 } },\n            { name: 'bce', reverseOf: 'ce' }\n        ]);\n    }\n    reviseIntlEra(calendarDate /*, isoDate: IsoDate*/) {\n        let { era, eraYear } = calendarDate;\n        // Firefox 96 introduced a bug where the `'short'` format of the era\n        // option mistakenly returns the one-letter (narrow) format instead. The\n        // code below handles either the correct or Firefox-buggy format. See\n        // https://bugzilla.mozilla.org/show_bug.cgi?id=1752253\n        if (era === 'bc' || era === 'b')\n            era = 'bce';\n        if (era === 'ad' || era === 'a')\n            era = 'ce';\n        return { era, eraYear };\n    }\n}\n// NOTE: Only the 5 modern eras (Meiji and later) are included. For dates\n// before Meiji 1, the `ce` and `bce` eras are used. Challenges with pre-Meiji\n// eras include:\n// - Start/end dates of older eras are not precisely defined, which is\n//   challenging given Temporal's need for precision\n// - Some era dates and/or names are disputed by historians\n// - As historical research proceeds, new eras are discovered and existing era\n//   dates are modified, leading to considerable churn which is not good for\n//   Temporal use.\n//  - The earliest era (in 645 CE) may not end up being the earliest depending\n//    on future historical scholarship\n//  - Before Meiji, Japan used a lunar (or lunisolar?) calendar but AFAIK\n//    that's not reflected in the ICU implementation.\n//\n// For more discussion: https://github.com/tc39/proposal-temporal/issues/526.\n//\n// Here's a full list of CLDR/ICU eras:\n// https://github.com/unicode-org/icu/blob/master/icu4c/source/data/locales/root.txt#L1582-L1818\n// https://github.com/unicode-org/cldr/blob/master/common/supplemental/supplementalData.xml#L4310-L4546\n//\n// NOTE: Japan started using the Gregorian calendar in 6 Meiji, replacing a\n// lunisolar calendar. So the day before January 1 of 6 Meiji (1873) was not\n// December 31, but December 2, of 5 Meiji (1872). The existing Ecma-402\n// Japanese calendar doesn't seem to take this into account, so neither do we:\n// > args = ['en-ca-u-ca-japanese', { era: 'short' }]\n// > new Date('1873-01-01T12:00').toLocaleString(...args)\n// '1 1, 6 Meiji, 12:00:00 PM'\n// > new Date('1872-12-31T12:00').toLocaleString(...args)\n// '12 31, 5 Meiji, 12:00:00 PM'\nclass JapaneseHelper extends GregorianBaseHelper {\n    constructor() {\n        super('japanese', [\n            // The Japanese calendar `year` is just the ISO year, because (unlike other\n            // ICU calendars) there's no obvious \"default era\", we use the ISO year.\n            { name: 'reiwa', isoEpoch: { year: 2019, month: 5, day: 1 }, anchorEpoch: { year: 2019, month: 5, day: 1 } },\n            { name: 'heisei', isoEpoch: { year: 1989, month: 1, day: 8 }, anchorEpoch: { year: 1989, month: 1, day: 8 } },\n            { name: 'showa', isoEpoch: { year: 1926, month: 12, day: 25 }, anchorEpoch: { year: 1926, month: 12, day: 25 } },\n            { name: 'taisho', isoEpoch: { year: 1912, month: 7, day: 30 }, anchorEpoch: { year: 1912, month: 7, day: 30 } },\n            { name: 'meiji', isoEpoch: { year: 1868, month: 9, day: 8 }, anchorEpoch: { year: 1868, month: 9, day: 8 } },\n            { name: 'ce', isoEpoch: { year: 1, month: 1, day: 1 } },\n            { name: 'bce', reverseOf: 'ce' }\n        ]);\n        this.calendarIsVulnerableToJulianBug = true;\n        // The last 3 Japanese eras confusingly return only one character in the\n        // default \"short\" era, so need to use the long format.\n        this.eraLength = 'long';\n    }\n    reviseIntlEra(calendarDate, isoDate) {\n        const { era, eraYear } = calendarDate;\n        const { year: isoYear } = isoDate;\n        if (this.eras.find((e) => e.name === era))\n            return { era, eraYear };\n        return (isoYear < 1 ? { era: 'bce', eraYear: 1 - isoYear } : { era: 'ce', eraYear: isoYear });\n    }\n}\nclass ChineseBaseHelper extends HelperBase {\n    constructor() {\n        super(...arguments);\n        this.calendarType = 'lunisolar';\n        // All built-in calendars except Chinese/Dangi and Hebrew use an era\n        this.hasEra = false;\n    }\n    inLeapYear(calendarDate, cache) {\n        const months = this.getMonthList(calendarDate.year, cache);\n        return ObjectEntries(months).length === 13;\n    }\n    monthsInYear(calendarDate, cache) {\n        return this.inLeapYear(calendarDate, cache) ? 13 : 12;\n    }\n    minimumMonthLength( /* calendarDate */) {\n        return 29;\n    }\n    maximumMonthLength( /* calendarDate */) {\n        return 30;\n    }\n    getMonthList(calendarYear, cache) {\n        if (calendarYear === undefined) {\n            throw new TypeError('Missing year');\n        }\n        const key = JSON.stringify({ func: 'getMonthList', calendarYear, id: this.id });\n        const cached = cache.get(key);\n        if (cached)\n            return cached;\n        const dateTimeFormat = this.getFormatter();\n        const getCalendarDate = (isoYear, daysPastFeb1) => {\n            const isoStringFeb1 = toUtcIsoDateString({ isoYear, isoMonth: 2, isoDay: 1 });\n            const legacyDate = new Date(isoStringFeb1);\n            // Now add the requested number of days, which may wrap to the next month.\n            legacyDate.setUTCDate(daysPastFeb1 + 1);\n            const newYearGuess = dateTimeFormat.formatToParts(legacyDate);\n            const calendarMonthString = newYearGuess.find((tv) => tv.type === 'month').value;\n            const calendarDay = +newYearGuess.find((tv) => tv.type === 'day').value;\n            let calendarYearToVerify = newYearGuess.find((tv) => tv.type === 'relatedYear');\n            if (calendarYearToVerify !== undefined) {\n                calendarYearToVerify = +calendarYearToVerify.value;\n            }\n            else {\n                // Node 12 has outdated ICU data that lacks the `relatedYear` field in the\n                // output of Intl.DateTimeFormat.formatToParts.\n                throw new RangeError(`Intl.DateTimeFormat.formatToParts lacks relatedYear in ${this.id} calendar. Try Node 14+ or modern browsers.`);\n            }\n            return { calendarMonthString, calendarDay, calendarYearToVerify };\n        };\n        // First, find a date close to Chinese New Year. Feb 17 will either be in\n        // the first month or near the end of the last month of the previous year.\n        let isoDaysDelta = 17;\n        let { calendarMonthString, calendarDay, calendarYearToVerify } = getCalendarDate(calendarYear, isoDaysDelta);\n        // If we didn't guess the first month correctly, add (almost in some months)\n        // a lunar month\n        if (calendarMonthString !== '1') {\n            isoDaysDelta += 29;\n            ({ calendarMonthString, calendarDay } = getCalendarDate(calendarYear, isoDaysDelta));\n        }\n        // Now back up to near the start of the first month, but not too near that\n        // off-by-one issues matter.\n        isoDaysDelta -= calendarDay - 5;\n        const result = {};\n        let monthIndex = 1;\n        let oldCalendarDay;\n        let oldMonthString;\n        let done = false;\n        do {\n            ({ calendarMonthString, calendarDay, calendarYearToVerify } = getCalendarDate(calendarYear, isoDaysDelta));\n            if (oldCalendarDay) {\n                result[oldMonthString].daysInMonth = oldCalendarDay + 30 - calendarDay;\n            }\n            if (calendarYearToVerify !== calendarYear) {\n                done = true;\n            }\n            else {\n                result[calendarMonthString] = { monthIndex: monthIndex++ };\n                // Move to the next month. Because months are sometimes 29 days, the day of the\n                // calendar month will move forward slowly but not enough to flip over to a new\n                // month before the loop ends at 12-13 months.\n                isoDaysDelta += 30;\n            }\n            oldCalendarDay = calendarDay;\n            oldMonthString = calendarMonthString;\n        } while (!done);\n        result[oldMonthString].daysInMonth = oldCalendarDay + 30 - calendarDay;\n        cache.set(key, result);\n        return result;\n    }\n    estimateIsoDate(calendarDate) {\n        const { year, month } = calendarDate;\n        return { year, month: month >= 12 ? 12 : month + 1, day: 1 };\n    }\n    adjustCalendarDate(calendarDate, cache, overflow = 'constrain', fromLegacyDate = false) {\n        let { year, month, monthExtra, day, monthCode, eraYear } = calendarDate;\n        if (fromLegacyDate) {\n            // Legacy Date output returns a string that's an integer with an optional\n            // \"bis\" suffix used only by the Chinese/Dangi calendar to indicate a leap\n            // month. Below we'll normalize the output.\n            year = eraYear;\n            if (monthExtra && monthExtra !== 'bis')\n                throw new RangeError(`Unexpected leap month suffix: ${monthExtra}`);\n            const monthCode = buildMonthCode(month, monthExtra !== undefined);\n            const monthString = `${month}${monthExtra || ''}`;\n            const months = this.getMonthList(year, cache);\n            const monthInfo = months[monthString];\n            if (monthInfo === undefined)\n                throw new RangeError(`Unmatched month ${monthString} in Chinese year ${year}`);\n            month = monthInfo.monthIndex;\n            return { year: year, month, day: day, era: undefined, eraYear, monthCode };\n        }\n        else {\n            // When called without input coming from legacy Date output,\n            // simply ensure that all fields are present.\n            this.validateCalendarDate(calendarDate);\n            if (year === undefined)\n                year = eraYear;\n            if (eraYear === undefined)\n                eraYear = year;\n            if (month === undefined) {\n                const months = this.getMonthList(year, cache);\n                let numberPart = monthCode.replace('L', 'bis').slice(1);\n                if (numberPart[0] === '0')\n                    numberPart = numberPart.slice(1);\n                let monthInfo = months[numberPart];\n                month = monthInfo && monthInfo.monthIndex;\n                // If this leap month isn't present in this year, constrain down to the last day of the previous month.\n                if (month === undefined &&\n                    monthCode.endsWith('L') &&\n                    !ArrayIncludes.call(['M01L', 'M12L', 'M13L'], monthCode) &&\n                    overflow === 'constrain') {\n                    let withoutML = monthCode.slice(1, -1);\n                    if (withoutML[0] === '0')\n                        withoutML = withoutML.slice(1);\n                    monthInfo = months[withoutML];\n                    if (monthInfo) {\n                        ({ daysInMonth: day, monthIndex: month } = monthInfo);\n                        monthCode = buildMonthCode(withoutML);\n                    }\n                }\n                if (month === undefined) {\n                    throw new RangeError(`Unmatched month ${monthCode} in Chinese year ${year}`);\n                }\n            }\n            else if (monthCode === undefined) {\n                const months = this.getMonthList(year, cache);\n                const monthEntries = ObjectEntries(months);\n                const largestMonth = monthEntries.length;\n                if (overflow === 'reject') {\n                    RejectToRange(month, 1, largestMonth);\n                    RejectToRange(day, 1, this.maximumMonthLength());\n                }\n                else {\n                    month = ConstrainToRange(month, 1, largestMonth);\n                    day = ConstrainToRange(day, 1, this.maximumMonthLength());\n                }\n                const matchingMonthEntry = monthEntries.find(([, v]) => v.monthIndex === month);\n                if (matchingMonthEntry === undefined) {\n                    throw new RangeError(`Invalid month ${month} in Chinese year ${year}`);\n                }\n                monthCode = buildMonthCode(matchingMonthEntry[0].replace('bis', ''), matchingMonthEntry[0].indexOf('bis') !== -1);\n            }\n            else {\n                // Both month and monthCode are present. Make sure they don't conflict.\n                const months = this.getMonthList(year, cache);\n                let numberPart = monthCode.replace('L', 'bis').slice(1);\n                if (numberPart[0] === '0')\n                    numberPart = numberPart.slice(1);\n                const monthInfo = months[numberPart];\n                if (!monthInfo)\n                    throw new RangeError(`Unmatched monthCode ${monthCode} in Chinese year ${year}`);\n                if (month !== monthInfo.monthIndex) {\n                    throw new RangeError(`monthCode ${monthCode} doesn't correspond to month ${month} in Chinese year ${year}`);\n                }\n            }\n            return {\n                ...calendarDate,\n                year: year,\n                eraYear,\n                month,\n                monthCode: monthCode,\n                day: day\n            };\n        }\n    }\n}\nclass ChineseHelper extends ChineseBaseHelper {\n    constructor() {\n        super(...arguments);\n        this.id = 'chinese';\n    }\n}\n// Dangi (Korean) calendar has same implementation as Chinese\nclass DangiHelper extends ChineseBaseHelper {\n    constructor() {\n        super(...arguments);\n        this.id = 'dangi';\n    }\n}\n/**\n * Common implementation of all non-ISO calendars.\n * Per-calendar id and logic live in `id` and `helper` properties attached later.\n * This split allowed an easy separation between code that was similar between\n * ISO and non-ISO implementations vs. code that was very different.\n */\nconst nonIsoImpl = {\n    // `helper` is added when this object is spread into each calendar's\n    // implementation\n    helper: undefined,\n    dateFromFields(fieldsParam, options, calendar) {\n        const overflow = ToTemporalOverflow(options);\n        const cache = new OneObjectCache();\n        // Intentionally alphabetical\n        const fields = PrepareTemporalFields(fieldsParam, [\n            ['day'],\n            ['era', undefined],\n            ['eraYear', undefined],\n            ['month', undefined],\n            ['monthCode', undefined],\n            ['year', undefined]\n        ]);\n        const { year, month, day } = this.helper.calendarToIsoDate(fields, overflow, cache);\n        const result = CreateTemporalDate(year, month, day, calendar);\n        cache.setObject(result);\n        return result;\n    },\n    yearMonthFromFields(fieldsParam, options, calendar) {\n        const overflow = ToTemporalOverflow(options);\n        const cache = new OneObjectCache();\n        // Intentionally alphabetical\n        const fields = PrepareTemporalFields(fieldsParam, [\n            ['era', undefined],\n            ['eraYear', undefined],\n            ['month', undefined],\n            ['monthCode', undefined],\n            ['year', undefined]\n        ]);\n        const { year, month, day } = this.helper.calendarToIsoDate({ ...fields, day: 1 }, overflow, cache);\n        const result = CreateTemporalYearMonth(year, month, calendar, /* referenceISODay = */ day);\n        cache.setObject(result);\n        return result;\n    },\n    monthDayFromFields(fieldsParam, options, calendar) {\n        const overflow = ToTemporalOverflow(options);\n        // All built-in calendars require `day`, but some allow other fields to be\n        // substituted for `month`. And for lunisolar calendars, either `monthCode`\n        // or `year` must be provided because `month` is ambiguous without a year or\n        // a code.\n        const cache = new OneObjectCache();\n        const fields = PrepareTemporalFields(fieldsParam, [\n            ['day'],\n            ['era', undefined],\n            ['eraYear', undefined],\n            ['month', undefined],\n            ['monthCode', undefined],\n            ['year', undefined]\n        ]);\n        const { year, month, day } = this.helper.monthDayFromFields(fields, overflow, cache);\n        // `year` is a reference year where this month/day exists in this calendar\n        const result = CreateTemporalMonthDay(month, day, calendar, /* referenceISOYear = */ year);\n        cache.setObject(result);\n        return result;\n    },\n    fields(fieldsParam) {\n        let fields = fieldsParam;\n        if (ArrayIncludes.call(fields, 'year'))\n            fields = [...fields, 'era', 'eraYear'];\n        return fields;\n    },\n    mergeFields(fields, additionalFields) {\n        const fieldsCopy = { ...fields };\n        const additionalFieldsCopy = { ...additionalFields };\n        // era and eraYear are intentionally unused\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        const { month, monthCode, year, era, eraYear, ...original } = fieldsCopy;\n        const { month: newMonth, monthCode: newMonthCode, year: newYear, era: newEra, eraYear: newEraYear } = additionalFieldsCopy;\n        if (newMonth === undefined && newMonthCode === undefined) {\n            original.month = month;\n            original.monthCode = monthCode;\n        }\n        if (newYear === undefined && newEra === undefined && newEraYear === undefined) {\n            // Only `year` is needed. We don't set era and eraYear because it's\n            // possible to create a conflict for eras that start or end mid-year. See\n            // https://github.com/tc39/proposal-temporal/issues/1784.\n            original.year = year;\n        }\n        return { ...original, ...additionalFieldsCopy };\n    },\n    dateAdd(date, years, months, weeks, days, overflow, calendar) {\n        const cache = OneObjectCache.getCacheForObject(date);\n        const calendarDate = this.helper.temporalToCalendarDate(date, cache);\n        const added = this.helper.addCalendar(calendarDate, { years, months, weeks, days }, overflow, cache);\n        const isoAdded = this.helper.calendarToIsoDate(added, 'constrain', cache);\n        const { year, month, day } = isoAdded;\n        const newTemporalObject = CreateTemporalDate(year, month, day, calendar);\n        // The new object's cache starts with the cache of the old object\n        const newCache = new OneObjectCache(cache);\n        newCache.setObject(newTemporalObject);\n        return newTemporalObject;\n    },\n    dateUntil(one, two, largestUnit) {\n        const cacheOne = OneObjectCache.getCacheForObject(one);\n        const cacheTwo = OneObjectCache.getCacheForObject(two);\n        const calendarOne = this.helper.temporalToCalendarDate(one, cacheOne);\n        const calendarTwo = this.helper.temporalToCalendarDate(two, cacheTwo);\n        const result = this.helper.untilCalendar(calendarOne, calendarTwo, largestUnit, cacheOne);\n        return result;\n    },\n    year(date) {\n        const cache = OneObjectCache.getCacheForObject(date);\n        const calendarDate = this.helper.temporalToCalendarDate(date, cache);\n        return calendarDate.year;\n    },\n    month(date) {\n        const cache = OneObjectCache.getCacheForObject(date);\n        const calendarDate = this.helper.temporalToCalendarDate(date, cache);\n        return calendarDate.month;\n    },\n    day(date) {\n        const cache = OneObjectCache.getCacheForObject(date);\n        const calendarDate = this.helper.temporalToCalendarDate(date, cache);\n        return calendarDate.day;\n    },\n    era(date) {\n        if (!this.helper.hasEra)\n            return undefined;\n        const cache = OneObjectCache.getCacheForObject(date);\n        const calendarDate = this.helper.temporalToCalendarDate(date, cache);\n        return calendarDate.era;\n    },\n    eraYear(date) {\n        if (!this.helper.hasEra)\n            return undefined;\n        const cache = OneObjectCache.getCacheForObject(date);\n        const calendarDate = this.helper.temporalToCalendarDate(date, cache);\n        return calendarDate.eraYear;\n    },\n    monthCode(date) {\n        const cache = OneObjectCache.getCacheForObject(date);\n        const calendarDate = this.helper.temporalToCalendarDate(date, cache);\n        return calendarDate.monthCode;\n    },\n    dayOfWeek(date) {\n        return impl['iso8601'].dayOfWeek(date);\n    },\n    dayOfYear(date) {\n        const cache = OneObjectCache.getCacheForObject(date);\n        const calendarDate = this.helper.isoToCalendarDate(date, cache);\n        const startOfYear = this.helper.startOfCalendarYear(calendarDate);\n        const diffDays = this.helper.calendarDaysUntil(startOfYear, calendarDate, cache);\n        return diffDays + 1;\n    },\n    weekOfYear(date) {\n        return impl['iso8601'].weekOfYear(date);\n    },\n    daysInWeek(date) {\n        return impl['iso8601'].daysInWeek(date);\n    },\n    daysInMonth(date) {\n        const cache = OneObjectCache.getCacheForObject(date);\n        const calendarDate = this.helper.temporalToCalendarDate(date, cache);\n        // Easy case: if the helper knows the length without any heavy calculation.\n        const max = this.helper.maximumMonthLength(calendarDate);\n        const min = this.helper.minimumMonthLength(calendarDate);\n        if (max === min)\n            return max;\n        // The harder case is where months vary every year, e.g. islamic calendars.\n        // Find the answer by calculating the difference in days between the first\n        // day of the current month and the first day of the next month.\n        const startOfMonthCalendar = this.helper.startOfCalendarMonth(calendarDate);\n        const startOfNextMonthCalendar = this.helper.addMonthsCalendar(startOfMonthCalendar, 1, 'constrain', cache);\n        const result = this.helper.calendarDaysUntil(startOfMonthCalendar, startOfNextMonthCalendar, cache);\n        return result;\n    },\n    daysInYear(dateParam) {\n        let date = dateParam;\n        if (!HasSlot(date, ISO_YEAR))\n            date = ToTemporalDate(date);\n        const cache = OneObjectCache.getCacheForObject(date);\n        const calendarDate = this.helper.temporalToCalendarDate(date, cache);\n        const startOfYearCalendar = this.helper.startOfCalendarYear(calendarDate);\n        const startOfNextYearCalendar = this.helper.addCalendar(startOfYearCalendar, { years: 1 }, 'constrain', cache);\n        const result = this.helper.calendarDaysUntil(startOfYearCalendar, startOfNextYearCalendar, cache);\n        return result;\n    },\n    monthsInYear(date) {\n        const cache = OneObjectCache.getCacheForObject(date);\n        const calendarDate = this.helper.temporalToCalendarDate(date, cache);\n        const result = this.helper.monthsInYear(calendarDate, cache);\n        return result;\n    },\n    inLeapYear(dateParam) {\n        let date = dateParam;\n        if (!HasSlot(date, ISO_YEAR))\n            date = ToTemporalDate(date);\n        const cache = OneObjectCache.getCacheForObject(date);\n        const calendarDate = this.helper.temporalToCalendarDate(date, cache);\n        const result = this.helper.inLeapYear(calendarDate, cache);\n        return result;\n    }\n};\nfor (const Helper of [\n    HebrewHelper,\n    PersianHelper,\n    EthiopicHelper,\n    EthioaaHelper,\n    CopticHelper,\n    ChineseHelper,\n    DangiHelper,\n    RocHelper,\n    IndianHelper,\n    BuddhistHelper,\n    GregoryHelper,\n    JapaneseHelper,\n    IslamicHelper,\n    IslamicUmalquraHelper,\n    IslamicTblaHelper,\n    IslamicCivilHelper,\n    IslamicRgsaHelper,\n    IslamicCcHelper\n]) {\n    const helper = new Helper();\n    // Clone the singleton non-ISO implementation that's the same for all\n    // calendars. The `helper` property contains per-calendar logic.\n    impl[helper.id] = { ...nonIsoImpl, helper };\n}\nconst BUILTIN_CALENDAR_IDS = Object.keys(impl);\nfunction IsBuiltinCalendar(id) {\n    return ArrayIncludes.call(BUILTIN_CALENDAR_IDS, id);\n}\n\nconst tzComponent = /\\.[-A-Za-z_]|\\.\\.[-A-Za-z._]{1,12}|\\.[-A-Za-z_][-A-Za-z._]{0,12}|[A-Za-z_][-A-Za-z._]{0,13}/;\nconst offsetNoCapture = /(?:[+\\u2212-][0-2][0-9](?::?[0-5][0-9](?::?[0-5][0-9](?:[.,]\\d{1,9})?)?)?)/;\nconst timeZoneID = new RegExp(`(?:(?:${tzComponent.source})(?:\\\\/(?:${tzComponent.source}))*|Etc/GMT[-+]\\\\d{1,2}|${offsetNoCapture.source})`);\nconst calComponent = /[A-Za-z0-9]{3,8}/;\nconst calendarID = new RegExp(`(?:${calComponent.source}(?:-${calComponent.source})*)`);\nconst yearpart = /(?:[+\\u2212-]\\d{6}|\\d{4})/;\nconst monthpart = /(?:0[1-9]|1[0-2])/;\nconst daypart = /(?:0[1-9]|[12]\\d|3[01])/;\nconst datesplit = new RegExp(`(${yearpart.source})(?:-(${monthpart.source})-(${daypart.source})|(${monthpart.source})(${daypart.source}))`);\nconst timesplit = /(\\d{2})(?::(\\d{2})(?::(\\d{2})(?:[.,](\\d{1,9}))?)?|(\\d{2})(?:(\\d{2})(?:[.,](\\d{1,9}))?)?)?/;\nconst offset = /([+\\u2212-])([01][0-9]|2[0-3])(?::?([0-5][0-9])(?::?([0-5][0-9])(?:[.,](\\d{1,9}))?)?)?/;\nconst zonesplit = new RegExp(`(?:([zZ])|(?:${offset.source})?)(?:\\\\[(${timeZoneID.source})\\\\])?`);\nconst calendar = new RegExp(`\\\\[u-ca=(${calendarID.source})\\\\]`);\nconst zoneddatetime = new RegExp(`^${datesplit.source}(?:(?:T|\\\\s+)${timesplit.source})?${zonesplit.source}(?:${calendar.source})?$`, 'i');\nconst time = new RegExp(`^T?${timesplit.source}(?:${zonesplit.source})?(?:${calendar.source})?$`, 'i');\n// The short forms of YearMonth and MonthDay are only for the ISO calendar.\n// Non-ISO calendar YearMonth and MonthDay have to parse as a Temporal.PlainDate,\n// with the reference fields.\n// YYYYMM forbidden by ISO 8601 because ambiguous with YYMMDD, but allowed by\n// RFC 3339 and we don't allow 2-digit years, so we allow it.\n// Not ambiguous with HHMMSS because that requires a 'T' prefix\nconst yearmonth = new RegExp(`^(${yearpart.source})-?(${monthpart.source})$`);\nconst monthday = new RegExp(`^(?:--)?(${monthpart.source})-?(${daypart.source})$`);\nconst fraction = /(\\d+)(?:[.,](\\d{1,9}))?/;\nconst durationDate = /(?:(\\d+)Y)?(?:(\\d+)M)?(?:(\\d+)W)?(?:(\\d+)D)?/;\nconst durationTime = new RegExp(`(?:${fraction.source}H)?(?:${fraction.source}M)?(?:${fraction.source}S)?`);\nconst duration = new RegExp(`^([+\\u2212-])?P${durationDate.source}(?:T(?!$)${durationTime.source})?$`, 'i');\n\nconst ArrayPrototypePush$1 = Array.prototype.push;\nconst IntlDateTimeFormat$1 = globalThis.Intl.DateTimeFormat;\nconst MathMin = Math.min;\nconst MathMax = Math.max;\nconst MathAbs = Math.abs;\nconst MathFloor = Math.floor;\nconst MathSign = Math.sign;\nconst MathTrunc = Math.trunc;\nconst NumberIsNaN = Number.isNaN;\nconst NumberIsFinite = Number.isFinite;\nconst NumberCtor = Number;\nconst StringCtor = String;\nconst NumberMaxSafeInteger = Number.MAX_SAFE_INTEGER;\nconst ObjectCreate$2 = Object.create;\nconst ObjectDefineProperty = Object.defineProperty;\nconst ObjectIs = Object.is;\nconst ReflectApply$1 = Reflect.apply;\nconst ZERO = jsbi_umd.BigInt(0);\nconst ONE = jsbi_umd.BigInt(1);\nconst SIXTY = jsbi_umd.BigInt(60);\nconst THOUSAND = jsbi_umd.BigInt(1e3);\nconst MILLION = jsbi_umd.BigInt(1e6);\nconst BILLION = jsbi_umd.BigInt(1e9);\nconst NEGATIVE_ONE = jsbi_umd.BigInt(-1);\nconst DAY_SECONDS = 86400;\nconst DAY_NANOS = jsbi_umd.multiply(jsbi_umd.BigInt(DAY_SECONDS), BILLION);\nconst NS_MIN = jsbi_umd.multiply(jsbi_umd.BigInt(-86400), jsbi_umd.BigInt(1e17));\nconst NS_MAX = jsbi_umd.multiply(jsbi_umd.BigInt(86400), jsbi_umd.BigInt(1e17));\nconst YEAR_MIN = -271821;\nconst YEAR_MAX = 275760;\nconst BEFORE_FIRST_OFFSET_TRANSITION = jsbi_umd.multiply(jsbi_umd.BigInt(-388152), jsbi_umd.BigInt(1e13)); // 1847-01-01T00:00:00Z\nconst ABOUT_TEN_YEARS_NANOS = jsbi_umd.multiply(DAY_NANOS, jsbi_umd.BigInt(366 * 10));\nconst ABOUT_ONE_YEAR_NANOS = jsbi_umd.multiply(DAY_NANOS, jsbi_umd.BigInt(366 * 1));\nconst TWO_WEEKS_NANOS = jsbi_umd.multiply(DAY_NANOS, jsbi_umd.BigInt(2 * 7));\nfunction IsInteger(value) {\n    if (typeof value !== 'number' || !NumberIsFinite(value))\n        return false;\n    const abs = MathAbs(value);\n    return MathFloor(abs) === abs;\n}\nfunction IsObject(value) {\n    return (typeof value === 'object' && value !== null) || typeof value === 'function';\n}\nfunction ToNumber(value) {\n    if (typeof value === 'bigint')\n        throw new TypeError('Cannot convert BigInt to number');\n    return NumberCtor(value);\n}\nfunction ToInteger(value) {\n    const num = ToNumber(value);\n    if (NumberIsNaN(num))\n        return 0;\n    const integer = MathTrunc(num);\n    if (num === 0)\n        return 0;\n    return integer;\n}\nfunction ToString(value) {\n    if (typeof value === 'symbol') {\n        throw new TypeError('Cannot convert a Symbol value to a String');\n    }\n    return StringCtor(value);\n}\nfunction ToIntegerThrowOnInfinity(value) {\n    const integer = ToInteger(value);\n    if (!NumberIsFinite(integer)) {\n        throw new RangeError('infinity is out of range');\n    }\n    return integer;\n}\nfunction ToPositiveInteger(valueParam, property) {\n    const value = ToInteger(valueParam);\n    if (!NumberIsFinite(value)) {\n        throw new RangeError('infinity is out of range');\n    }\n    if (value < 1) {\n        if (property !== undefined) {\n            throw new RangeError(`property '${property}' cannot be a a number less than one`);\n        }\n        throw new RangeError('Cannot convert a number less than one to a positive integer');\n    }\n    return value;\n}\nfunction ToIntegerWithoutRounding(valueParam) {\n    const value = ToNumber(valueParam);\n    if (NumberIsNaN(value))\n        return 0;\n    if (!NumberIsFinite(value)) {\n        throw new RangeError('infinity is out of range');\n    }\n    if (!IsInteger(value)) {\n        throw new RangeError(`unsupported fractional value ${value}`);\n    }\n    return ToInteger(value); // (value) in spec text; converts -0 to 0\n}\nfunction divmod(x, y) {\n    const quotient = jsbi_umd.divide(x, y);\n    const remainder = jsbi_umd.remainder(x, y);\n    return { quotient, remainder };\n}\nfunction abs(x) {\n    if (jsbi_umd.lessThan(x, ZERO))\n        return jsbi_umd.multiply(x, NEGATIVE_ONE);\n    return x;\n}\nconst BUILTIN_CASTS = new Map([\n    ['year', ToIntegerThrowOnInfinity],\n    ['month', ToPositiveInteger],\n    ['monthCode', ToString],\n    ['day', ToPositiveInteger],\n    ['hour', ToIntegerThrowOnInfinity],\n    ['minute', ToIntegerThrowOnInfinity],\n    ['second', ToIntegerThrowOnInfinity],\n    ['millisecond', ToIntegerThrowOnInfinity],\n    ['microsecond', ToIntegerThrowOnInfinity],\n    ['nanosecond', ToIntegerThrowOnInfinity],\n    ['years', ToIntegerWithoutRounding],\n    ['months', ToIntegerWithoutRounding],\n    ['weeks', ToIntegerWithoutRounding],\n    ['days', ToIntegerWithoutRounding],\n    ['hours', ToIntegerWithoutRounding],\n    ['minutes', ToIntegerWithoutRounding],\n    ['seconds', ToIntegerWithoutRounding],\n    ['milliseconds', ToIntegerWithoutRounding],\n    ['microseconds', ToIntegerWithoutRounding],\n    ['nanoseconds', ToIntegerWithoutRounding],\n    ['era', ToString],\n    ['eraYear', ToInteger],\n    ['offset', ToString]\n]);\nconst ALLOWED_UNITS = [\n    'year',\n    'month',\n    'week',\n    'day',\n    'hour',\n    'minute',\n    'second',\n    'millisecond',\n    'microsecond',\n    'nanosecond'\n];\nconst SINGULAR_PLURAL_UNITS = [\n    ['years', 'year'],\n    ['months', 'month'],\n    ['weeks', 'week'],\n    ['days', 'day'],\n    ['hours', 'hour'],\n    ['minutes', 'minute'],\n    ['seconds', 'second'],\n    ['milliseconds', 'millisecond'],\n    ['microseconds', 'microsecond'],\n    ['nanoseconds', 'nanosecond']\n];\nconst IntlDateTimeFormatEnUsCache = new Map();\nfunction getIntlDateTimeFormatEnUsForTimeZone(timeZoneIdentifier) {\n    let instance = IntlDateTimeFormatEnUsCache.get(timeZoneIdentifier);\n    if (instance === undefined) {\n        instance = new IntlDateTimeFormat$1('en-us', {\n            timeZone: StringCtor(timeZoneIdentifier),\n            hour12: false,\n            era: 'short',\n            year: 'numeric',\n            month: 'numeric',\n            day: 'numeric',\n            hour: 'numeric',\n            minute: 'numeric',\n            second: 'numeric'\n        });\n        IntlDateTimeFormatEnUsCache.set(timeZoneIdentifier, instance);\n    }\n    return instance;\n}\nfunction IsTemporalInstant(item) {\n    return HasSlot(item, EPOCHNANOSECONDS) && !HasSlot(item, TIME_ZONE, CALENDAR);\n}\nfunction IsTemporalTimeZone(item) {\n    return HasSlot(item, TIMEZONE_ID);\n}\nfunction IsTemporalCalendar(item) {\n    return HasSlot(item, CALENDAR_ID);\n}\nfunction IsTemporalDuration(item) {\n    return HasSlot(item, YEARS, MONTHS, DAYS, HOURS, MINUTES, SECONDS, MILLISECONDS, MICROSECONDS, NANOSECONDS);\n}\nfunction IsTemporalDate(item) {\n    return HasSlot(item, DATE_BRAND);\n}\nfunction IsTemporalTime(item) {\n    return (HasSlot(item, ISO_HOUR, ISO_MINUTE, ISO_SECOND, ISO_MILLISECOND, ISO_MICROSECOND, ISO_NANOSECOND) &&\n        !HasSlot(item, ISO_YEAR, ISO_MONTH, ISO_DAY));\n}\nfunction IsTemporalDateTime(item) {\n    return HasSlot(item, ISO_YEAR, ISO_MONTH, ISO_DAY, ISO_HOUR, ISO_MINUTE, ISO_SECOND, ISO_MILLISECOND, ISO_MICROSECOND, ISO_NANOSECOND);\n}\nfunction IsTemporalYearMonth(item) {\n    return HasSlot(item, YEAR_MONTH_BRAND);\n}\nfunction IsTemporalMonthDay(item) {\n    return HasSlot(item, MONTH_DAY_BRAND);\n}\nfunction IsTemporalZonedDateTime(item) {\n    return HasSlot(item, EPOCHNANOSECONDS, TIME_ZONE, CALENDAR);\n}\nfunction RejectObjectWithCalendarOrTimeZone(item) {\n    if (HasSlot(item, CALENDAR) || HasSlot(item, TIME_ZONE)) {\n        throw new TypeError('with() does not support a calendar or timeZone property');\n    }\n    if (item.calendar !== undefined) {\n        throw new TypeError('with() does not support a calendar property');\n    }\n    if (item.timeZone !== undefined) {\n        throw new TypeError('with() does not support a timeZone property');\n    }\n}\nfunction ParseTemporalTimeZone(stringIdent) {\n    let { ianaName, offset, z } = ParseTemporalTimeZoneString(stringIdent);\n    if (ianaName)\n        return ianaName;\n    if (z)\n        return 'UTC';\n    return offset; // if !ianaName && !z then offset must be present\n}\nfunction FormatCalendarAnnotation(id, showCalendar) {\n    if (showCalendar === 'never')\n        return '';\n    if (showCalendar === 'auto' && id === 'iso8601')\n        return '';\n    return `[u-ca=${id}]`;\n}\nfunction ParseISODateTime(isoString) {\n    // ZDT is the superset of fields for every other Temporal type\n    const match = zoneddatetime.exec(isoString);\n    if (!match)\n        throw new RangeError(`invalid ISO 8601 string: ${isoString}`);\n    let yearString = match[1];\n    if (yearString[0] === '\\u2212')\n        yearString = `-${yearString.slice(1)}`;\n    if (yearString === '-000000')\n        throw new RangeError(`invalid ISO 8601 string: ${isoString}`);\n    const year = ToInteger(yearString);\n    const month = ToInteger(match[2] || match[4]);\n    const day = ToInteger(match[3] || match[5]);\n    const hour = ToInteger(match[6]);\n    const hasTime = match[6] !== undefined;\n    const minute = ToInteger(match[7] || match[10]);\n    let second = ToInteger(match[8] || match[11]);\n    if (second === 60)\n        second = 59;\n    const fraction = (match[9] || match[12]) + '000000000';\n    const millisecond = ToInteger(fraction.slice(0, 3));\n    const microsecond = ToInteger(fraction.slice(3, 6));\n    const nanosecond = ToInteger(fraction.slice(6, 9));\n    let offset;\n    let z = false;\n    if (match[13]) {\n        offset = undefined;\n        z = true;\n    }\n    else if (match[14] && match[15]) {\n        const offsetSign = match[14] === '-' || match[14] === '\\u2212' ? '-' : '+';\n        const offsetHours = match[15] || '00';\n        const offsetMinutes = match[16] || '00';\n        const offsetSeconds = match[17] || '00';\n        let offsetFraction = match[18] || '0';\n        offset = `${offsetSign}${offsetHours}:${offsetMinutes}`;\n        if (+offsetFraction) {\n            while (offsetFraction.endsWith('0'))\n                offsetFraction = offsetFraction.slice(0, -1);\n            offset += `:${offsetSeconds}.${offsetFraction}`;\n        }\n        else if (+offsetSeconds) {\n            offset += `:${offsetSeconds}`;\n        }\n        if (offset === '-00:00')\n            offset = '+00:00';\n    }\n    let ianaName = match[19];\n    if (ianaName) {\n        try {\n            // Canonicalize name if it is an IANA link name or is capitalized wrong\n            ianaName = GetCanonicalTimeZoneIdentifier(ianaName).toString();\n        }\n        catch {\n            // Not an IANA name, may be a custom ID, pass through unchanged\n        }\n    }\n    const calendar = match[20];\n    return {\n        year,\n        month,\n        day,\n        hasTime,\n        hour,\n        minute,\n        second,\n        millisecond,\n        microsecond,\n        nanosecond,\n        ianaName,\n        offset,\n        z,\n        calendar\n    };\n}\nfunction ParseTemporalInstantString(isoString) {\n    const result = ParseISODateTime(isoString);\n    if (!result.z && !result.offset)\n        throw new RangeError('Temporal.Instant requires a time zone offset');\n    return result;\n}\nfunction ParseTemporalZonedDateTimeString(isoString) {\n    const result = ParseISODateTime(isoString);\n    if (!result.ianaName)\n        throw new RangeError('Temporal.ZonedDateTime requires a time zone ID in brackets');\n    return result;\n}\nfunction ParseTemporalDateTimeString(isoString) {\n    return ParseISODateTime(isoString);\n}\nfunction ParseTemporalDateString(isoString) {\n    return ParseISODateTime(isoString);\n}\nfunction ParseTemporalTimeString(isoString) {\n    const match = time.exec(isoString);\n    let hour, minute, second, millisecond, microsecond, nanosecond, calendar;\n    if (match) {\n        hour = ToInteger(match[1]);\n        minute = ToInteger(match[2] || match[5]);\n        second = ToInteger(match[3] || match[6]);\n        if (second === 60)\n            second = 59;\n        const fraction = (match[4] || match[7]) + '000000000';\n        millisecond = ToInteger(fraction.slice(0, 3));\n        microsecond = ToInteger(fraction.slice(3, 6));\n        nanosecond = ToInteger(fraction.slice(6, 9));\n        calendar = match[15];\n    }\n    else {\n        let z, hasTime;\n        ({ hasTime, hour, minute, second, millisecond, microsecond, nanosecond, calendar, z } =\n            ParseISODateTime(isoString));\n        if (!hasTime)\n            throw new RangeError(`time is missing in string: ${isoString}`);\n        if (z)\n            throw new RangeError('Z designator not supported for PlainTime');\n    }\n    // if it's a date-time string, OK\n    if (/[tT ][0-9][0-9]/.test(isoString)) {\n        return { hour, minute, second, millisecond, microsecond, nanosecond, calendar };\n    }\n    // slow but non-grammar-dependent way to ensure that time-only strings that\n    // are also valid PlainMonthDay and PlainYearMonth throw. corresponds to\n    // assertion in spec text\n    try {\n        const { month, day } = ParseTemporalMonthDayString(isoString);\n        RejectISODate(1972, month, day);\n    }\n    catch {\n        try {\n            const { year, month } = ParseTemporalYearMonthString(isoString);\n            RejectISODate(year, month, 1);\n        }\n        catch {\n            return { hour, minute, second, millisecond, microsecond, nanosecond, calendar };\n        }\n    }\n    throw new RangeError(`invalid ISO 8601 time-only string ${isoString}; may need a T prefix`);\n}\nfunction ParseTemporalYearMonthString(isoString) {\n    const match = yearmonth.exec(isoString);\n    let year, month, calendar, referenceISODay;\n    if (match) {\n        let yearString = match[1];\n        if (yearString[0] === '\\u2212')\n            yearString = `-${yearString.slice(1)}`;\n        if (yearString === '-000000')\n            throw new RangeError(`invalid ISO 8601 string: ${isoString}`);\n        year = ToInteger(yearString);\n        month = ToInteger(match[2]);\n        calendar = match[3];\n    }\n    else {\n        let z;\n        ({ year, month, calendar, day: referenceISODay, z } = ParseISODateTime(isoString));\n        if (z)\n            throw new RangeError('Z designator not supported for PlainYearMonth');\n    }\n    return { year, month, calendar, referenceISODay };\n}\nfunction ParseTemporalMonthDayString(isoString) {\n    const match = monthday.exec(isoString);\n    let month, day, calendar, referenceISOYear;\n    if (match) {\n        month = ToInteger(match[1]);\n        day = ToInteger(match[2]);\n    }\n    else {\n        let z;\n        ({ month, day, calendar, year: referenceISOYear, z } = ParseISODateTime(isoString));\n        if (z)\n            throw new RangeError('Z designator not supported for PlainMonthDay');\n    }\n    return { month, day, calendar, referenceISOYear };\n}\nfunction ParseTemporalTimeZoneString(stringIdent) {\n    try {\n        let canonicalIdent = GetCanonicalTimeZoneIdentifier(stringIdent);\n        if (canonicalIdent) {\n            canonicalIdent = canonicalIdent.toString();\n            if (TestTimeZoneOffsetString(canonicalIdent))\n                return { offset: canonicalIdent };\n            return { ianaName: canonicalIdent };\n        }\n    }\n    catch {\n        // fall through\n    }\n    try {\n        // Try parsing ISO string instead\n        const result = ParseISODateTime(stringIdent);\n        if (result.z || result.offset || result.ianaName) {\n            return result;\n        }\n    }\n    catch {\n        // fall through\n    }\n    throw new RangeError(`Invalid time zone: ${stringIdent}`);\n}\nfunction ParseTemporalDurationString(isoString) {\n    const match = duration.exec(isoString);\n    if (!match)\n        throw new RangeError(`invalid duration: ${isoString}`);\n    if (match.slice(2).every((element) => element === undefined)) {\n        throw new RangeError(`invalid duration: ${isoString}`);\n    }\n    const sign = match[1] === '-' || match[1] === '\\u2212' ? -1 : 1;\n    const years = ToInteger(match[2]) * sign;\n    const months = ToInteger(match[3]) * sign;\n    const weeks = ToInteger(match[4]) * sign;\n    const days = ToInteger(match[5]) * sign;\n    const hours = ToInteger(match[6]) * sign;\n    let fHours = match[7];\n    let minutes = ToInteger(match[8]) * sign;\n    let fMinutes = match[9];\n    let seconds = ToInteger(match[10]) * sign;\n    const fSeconds = match[11] + '000000000';\n    let milliseconds = ToInteger(fSeconds.slice(0, 3)) * sign;\n    let microseconds = ToInteger(fSeconds.slice(3, 6)) * sign;\n    let nanoseconds = ToInteger(fSeconds.slice(6, 9)) * sign;\n    fHours = fHours ? (sign * ToInteger(fHours)) / 10 ** fHours.length : 0;\n    fMinutes = fMinutes ? (sign * ToInteger(fMinutes)) / 10 ** fMinutes.length : 0;\n    ({ minutes, seconds, milliseconds, microseconds, nanoseconds } = DurationHandleFractions(fHours, minutes, fMinutes, seconds, milliseconds, microseconds, nanoseconds));\n    return { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds };\n}\nfunction ParseTemporalInstant(isoString) {\n    const { year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, offset, z } = ParseTemporalInstantString(isoString);\n    const epochNs = GetEpochFromISOParts(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond);\n    if (epochNs === null)\n        throw new RangeError('DateTime outside of supported range');\n    const offsetNs = z ? 0 : ParseTimeZoneOffsetString(offset);\n    return jsbi_umd.subtract(epochNs, jsbi_umd.BigInt(offsetNs));\n}\nfunction RegulateISODate(yearParam, monthParam, dayParam, overflow) {\n    let year = yearParam;\n    let month = monthParam;\n    let day = dayParam;\n    switch (overflow) {\n        case 'reject':\n            RejectISODate(year, month, day);\n            break;\n        case 'constrain':\n            ({ year, month, day } = ConstrainISODate(year, month, day));\n            break;\n    }\n    return { year, month, day };\n}\nfunction RegulateTime(hourParam, minuteParam, secondParam, millisecondParam, microsecondParam, nanosecondParam, overflow) {\n    let hour = hourParam;\n    let minute = minuteParam;\n    let second = secondParam;\n    let millisecond = millisecondParam;\n    let microsecond = microsecondParam;\n    let nanosecond = nanosecondParam;\n    switch (overflow) {\n        case 'reject':\n            RejectTime(hour, minute, second, millisecond, microsecond, nanosecond);\n            break;\n        case 'constrain':\n            ({ hour, minute, second, millisecond, microsecond, nanosecond } = ConstrainTime(hour, minute, second, millisecond, microsecond, nanosecond));\n            break;\n    }\n    return { hour, minute, second, millisecond, microsecond, nanosecond };\n}\nfunction RegulateISOYearMonth(yearParam, monthParam, overflow) {\n    let year = yearParam;\n    let month = monthParam;\n    const referenceISODay = 1;\n    switch (overflow) {\n        case 'reject':\n            RejectISODate(year, month, referenceISODay);\n            break;\n        case 'constrain':\n            ({ year, month } = ConstrainISODate(year, month));\n            break;\n    }\n    return { year, month };\n}\nfunction DurationHandleFractions(fHoursParam, minutesParam, fMinutesParam, secondsParam, millisecondsParam, microsecondsParam, nanosecondsParam) {\n    let fHours = fHoursParam;\n    let minutes = minutesParam;\n    let fMinutes = fMinutesParam;\n    let seconds = secondsParam;\n    let milliseconds = millisecondsParam;\n    let microseconds = microsecondsParam;\n    let nanoseconds = nanosecondsParam;\n    if (fHours !== 0) {\n        [minutes, fMinutes, seconds, milliseconds, microseconds, nanoseconds].forEach((val) => {\n            if (val !== 0)\n                throw new RangeError('only the smallest unit can be fractional');\n        });\n        const mins = fHours * 60;\n        minutes = MathTrunc(mins);\n        fMinutes = mins % 1;\n    }\n    if (fMinutes !== 0) {\n        [seconds, milliseconds, microseconds, nanoseconds].forEach((val) => {\n            if (val !== 0)\n                throw new RangeError('only the smallest unit can be fractional');\n        });\n        const secs = fMinutes * 60;\n        seconds = MathTrunc(secs);\n        const fSeconds = secs % 1;\n        if (fSeconds !== 0) {\n            const mils = fSeconds * 1000;\n            milliseconds = MathTrunc(mils);\n            const fMilliseconds = mils % 1;\n            if (fMilliseconds !== 0) {\n                const mics = fMilliseconds * 1000;\n                microseconds = MathTrunc(mics);\n                const fMicroseconds = mics % 1;\n                if (fMicroseconds !== 0) {\n                    const nans = fMicroseconds * 1000;\n                    nanoseconds = MathTrunc(nans);\n                }\n            }\n        }\n    }\n    return { minutes, seconds, milliseconds, microseconds, nanoseconds };\n}\nfunction ToTemporalDurationRecord(item) {\n    if (IsTemporalDuration(item)) {\n        return {\n            years: GetSlot(item, YEARS),\n            months: GetSlot(item, MONTHS),\n            weeks: GetSlot(item, WEEKS),\n            days: GetSlot(item, DAYS),\n            hours: GetSlot(item, HOURS),\n            minutes: GetSlot(item, MINUTES),\n            seconds: GetSlot(item, SECONDS),\n            milliseconds: GetSlot(item, MILLISECONDS),\n            microseconds: GetSlot(item, MICROSECONDS),\n            nanoseconds: GetSlot(item, NANOSECONDS)\n        };\n    }\n    const props = ToPartialRecord(item, [\n        'days',\n        'hours',\n        'microseconds',\n        'milliseconds',\n        'minutes',\n        'months',\n        'nanoseconds',\n        'seconds',\n        'weeks',\n        'years'\n    ]);\n    if (!props)\n        throw new TypeError('invalid duration-like');\n    const { years = 0, months = 0, weeks = 0, days = 0, hours = 0, minutes = 0, seconds = 0, milliseconds = 0, microseconds = 0, nanoseconds = 0 } = props;\n    return { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds };\n}\nfunction ToLimitedTemporalDuration(item, disallowedProperties = []) {\n    let record;\n    if (IsObject(item)) {\n        record = ToTemporalDurationRecord(item);\n    }\n    else {\n        const str = ToString(item);\n        record = ParseTemporalDurationString(str);\n    }\n    const { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = record;\n    RejectDuration(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n    for (const property of disallowedProperties) {\n        if (record[property] !== 0) {\n            throw new RangeError(`Duration field ${property} not supported by Temporal.Instant. Try Temporal.ZonedDateTime instead.`);\n        }\n    }\n    return record;\n}\nfunction ToTemporalOverflow(options) {\n    return GetOption(options, 'overflow', ['constrain', 'reject'], 'constrain');\n}\nfunction ToTemporalDisambiguation(options) {\n    return GetOption(options, 'disambiguation', ['compatible', 'earlier', 'later', 'reject'], 'compatible');\n}\nfunction ToTemporalRoundingMode(options, fallback) {\n    return GetOption(options, 'roundingMode', ['ceil', 'floor', 'trunc', 'halfExpand'], fallback);\n}\nfunction NegateTemporalRoundingMode(roundingMode) {\n    switch (roundingMode) {\n        case 'ceil':\n            return 'floor';\n        case 'floor':\n            return 'ceil';\n        default:\n            return roundingMode;\n    }\n}\nfunction ToTemporalOffset(options, fallback) {\n    return GetOption(options, 'offset', ['prefer', 'use', 'ignore', 'reject'], fallback);\n}\nfunction ToShowCalendarOption(options) {\n    return GetOption(options, 'calendarName', ['auto', 'always', 'never'], 'auto');\n}\nfunction ToShowTimeZoneNameOption(options) {\n    return GetOption(options, 'timeZoneName', ['auto', 'never'], 'auto');\n}\nfunction ToShowOffsetOption(options) {\n    return GetOption(options, 'offset', ['auto', 'never'], 'auto');\n}\nfunction ToTemporalRoundingIncrement(options, dividend, inclusive) {\n    let maximum = Infinity;\n    if (dividend !== undefined)\n        maximum = dividend;\n    if (!inclusive && dividend !== undefined)\n        maximum = dividend > 1 ? dividend - 1 : 1;\n    const increment = GetNumberOption(options, 'roundingIncrement', 1, maximum, 1);\n    if (dividend !== undefined && dividend % increment !== 0) {\n        throw new RangeError(`Rounding increment must divide evenly into ${dividend}`);\n    }\n    return increment;\n}\nfunction ToTemporalDateTimeRoundingIncrement(options, smallestUnit) {\n    const maximumIncrements = {\n        year: undefined,\n        month: undefined,\n        week: undefined,\n        day: undefined,\n        hour: 24,\n        minute: 60,\n        second: 60,\n        millisecond: 1000,\n        microsecond: 1000,\n        nanosecond: 1000\n    };\n    return ToTemporalRoundingIncrement(options, maximumIncrements[smallestUnit], false);\n}\nfunction ToSecondsStringPrecision(options) {\n    const smallestUnit = ToSmallestTemporalUnit(options, undefined, ['year', 'month', 'week', 'day', 'hour']);\n    switch (smallestUnit) {\n        case 'minute':\n            return { precision: 'minute', unit: 'minute', increment: 1 };\n        case 'second':\n            return { precision: 0, unit: 'second', increment: 1 };\n        case 'millisecond':\n            return { precision: 3, unit: 'millisecond', increment: 1 };\n        case 'microsecond':\n            return { precision: 6, unit: 'microsecond', increment: 1 };\n        case 'nanosecond':\n            return { precision: 9, unit: 'nanosecond', increment: 1 };\n    }\n    let digits = options.fractionalSecondDigits;\n    if (digits === undefined)\n        digits = 'auto';\n    if (typeof digits !== 'number') {\n        const stringDigits = ToString(digits);\n        if (stringDigits === 'auto')\n            return { precision: 'auto', unit: 'nanosecond', increment: 1 };\n        throw new RangeError(`fractionalSecondDigits must be 'auto' or 0 through 9, not ${stringDigits}`);\n    }\n    if (NumberIsNaN(digits) || digits < 0 || digits > 9) {\n        throw new RangeError(`fractionalSecondDigits must be 'auto' or 0 through 9, not ${digits}`);\n    }\n    const precision = MathFloor(digits);\n    switch (precision) {\n        case 0:\n            return { precision, unit: 'second', increment: 1 };\n        case 1:\n        case 2:\n        case 3:\n            return { precision, unit: 'millisecond', increment: 10 ** (3 - precision) };\n        case 4:\n        case 5:\n        case 6:\n            return { precision, unit: 'microsecond', increment: 10 ** (6 - precision) };\n        case 7:\n        case 8:\n        case 9:\n            return { precision, unit: 'nanosecond', increment: 10 ** (9 - precision) };\n        default:\n            throw new RangeError(`fractionalSecondDigits must be 'auto' or 0 through 9, not ${digits}`);\n    }\n}\nfunction ToLargestTemporalUnit(options, fallback, disallowedStrings = [], autoValue) {\n    const singular = new Map(SINGULAR_PLURAL_UNITS.filter(([, sing]) => !disallowedStrings.includes(sing)));\n    const allowed = new Set(ALLOWED_UNITS);\n    for (const s of disallowedStrings) {\n        allowed.delete(s);\n    }\n    const retval = GetOption(options, 'largestUnit', ['auto', ...allowed, ...singular.keys()], fallback);\n    if (retval === 'auto' && autoValue !== undefined)\n        return autoValue;\n    if (singular.has(retval)) {\n        return singular.get(retval);\n    }\n    return retval;\n}\nfunction ToSmallestTemporalUnit(options, fallback, disallowedStrings = []) {\n    const singular = new Map(SINGULAR_PLURAL_UNITS.filter(([, sing]) => !disallowedStrings.includes(sing)));\n    const allowed = new Set(ALLOWED_UNITS);\n    for (const s of disallowedStrings) {\n        allowed.delete(s);\n    }\n    const value = GetOption(options, 'smallestUnit', [...allowed, ...singular.keys()], fallback);\n    if (singular.has(value)) {\n        return singular.get(value);\n    }\n    return value;\n}\nfunction ToTemporalDurationTotalUnit(options) {\n    // This AO is identical to ToSmallestTemporalUnit, except:\n    // - default is always `undefined` (caller will throw if omitted)\n    // - option is named `unit` (not `smallestUnit`)\n    // - all units are valid (no `disallowedStrings`)\n    const singular = new Map(SINGULAR_PLURAL_UNITS);\n    const value = GetOption(options, 'unit', [...singular.values(), ...singular.keys()], undefined);\n    if (singular.has(value)) {\n        return singular.get(value);\n    }\n    return value;\n}\nfunction ToRelativeTemporalObject(options) {\n    const relativeTo = options.relativeTo;\n    if (relativeTo === undefined)\n        return relativeTo;\n    let offsetBehaviour = 'option';\n    let matchMinutes = false;\n    let year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar, timeZone, offset;\n    if (IsObject(relativeTo)) {\n        if (IsTemporalZonedDateTime(relativeTo) || IsTemporalDate(relativeTo))\n            return relativeTo;\n        if (IsTemporalDateTime(relativeTo))\n            return TemporalDateTimeToDate(relativeTo);\n        calendar = GetTemporalCalendarWithISODefault(relativeTo);\n        const fieldNames = CalendarFields(calendar, [\n            'day',\n            'hour',\n            'microsecond',\n            'millisecond',\n            'minute',\n            'month',\n            'monthCode',\n            'nanosecond',\n            'second',\n            'year'\n        ]);\n        const fields = ToTemporalDateTimeFields(relativeTo, fieldNames);\n        const dateOptions = ObjectCreate$2(null);\n        dateOptions.overflow = 'constrain';\n        ({ year, month, day, hour, minute, second, millisecond, microsecond, nanosecond } = InterpretTemporalDateTimeFields(calendar, fields, dateOptions));\n        // The `offset` and `timeZone` properties only exist on ZonedDateTime (or\n        // ZonedDateTimeLike-property bags). The assertions below are used to avoid\n        // TS errors while not diverging runtime code from proposal-temporal.\n        offset = relativeTo.offset;\n        if (offset === undefined)\n            offsetBehaviour = 'wall';\n        timeZone = relativeTo.timeZone;\n    }\n    else {\n        let ianaName, z;\n        ({ year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar, ianaName, offset, z } =\n            ParseISODateTime(ToString(relativeTo)));\n        if (ianaName)\n            timeZone = ianaName;\n        if (z) {\n            offsetBehaviour = 'exact';\n        }\n        else if (!offset) {\n            offsetBehaviour = 'wall';\n        }\n        if (!calendar)\n            calendar = GetISO8601Calendar();\n        calendar = ToTemporalCalendar(calendar);\n        matchMinutes = true;\n    }\n    if (timeZone) {\n        timeZone = ToTemporalTimeZone(timeZone);\n        let offsetNs = 0;\n        if (offsetBehaviour === 'option')\n            offsetNs = ParseTimeZoneOffsetString(ToString(offset));\n        const epochNanoseconds = InterpretISODateTimeOffset(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, offsetBehaviour, offsetNs, timeZone, 'compatible', 'reject', matchMinutes);\n        return CreateTemporalZonedDateTime(epochNanoseconds, timeZone, calendar);\n    }\n    return CreateTemporalDate(year, month, day, calendar);\n}\nfunction ValidateTemporalUnitRange(largestUnit, smallestUnit) {\n    if (ALLOWED_UNITS.indexOf(largestUnit) > ALLOWED_UNITS.indexOf(smallestUnit)) {\n        throw new RangeError(`largestUnit ${largestUnit} cannot be smaller than smallestUnit ${smallestUnit}`);\n    }\n}\nfunction DefaultTemporalLargestUnit(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds) {\n    const singular = new Map(SINGULAR_PLURAL_UNITS);\n    for (const [prop, v] of [\n        ['years', years],\n        ['months', months],\n        ['weeks', weeks],\n        ['days', days],\n        ['hours', hours],\n        ['minutes', minutes],\n        ['seconds', seconds],\n        ['milliseconds', milliseconds],\n        ['microseconds', microseconds],\n        ['nanoseconds', nanoseconds]\n    ]) {\n        if (v !== 0)\n            return singular.get(prop);\n    }\n    return 'nanosecond';\n}\nfunction LargerOfTwoTemporalUnits(unit1, unit2) {\n    if (ALLOWED_UNITS.indexOf(unit1) > ALLOWED_UNITS.indexOf(unit2))\n        return unit2;\n    return unit1;\n}\nfunction ToPartialRecord(bagParam, fieldsParam) {\n    // External callers are limited to specific types, but this function's\n    // implementation uses generic property types. The casts below (and at the\n    // end) convert to/from generic records.\n    const bag = bagParam;\n    const fields = fieldsParam;\n    let any = false;\n    let result = {};\n    for (const property of fields) {\n        const value = bag[property];\n        if (value !== undefined) {\n            any = true;\n            if (BUILTIN_CASTS.has(property)) {\n                result[property] = BUILTIN_CASTS.get(property)(value);\n            }\n            else {\n                result[property] = value;\n            }\n        }\n    }\n    return any ? result : false;\n}\nfunction PrepareTemporalFields(bagParam, fieldsParam) {\n    // External callers are limited to specific types, but this function's\n    // implementation uses generic property types. The casts below (and at the\n    // end) convert to/from generic records.\n    const bag = bagParam;\n    const fields = fieldsParam;\n    const result = {};\n    let any = false;\n    for (const fieldRecord of fields) {\n        const [property, defaultValue] = fieldRecord;\n        let value = bag[property];\n        if (value === undefined) {\n            if (fieldRecord.length === 1) {\n                throw new TypeError(`required property '${property}' missing or undefined`);\n            }\n            value = defaultValue;\n        }\n        else {\n            any = true;\n            if (BUILTIN_CASTS.has(property)) {\n                value = BUILTIN_CASTS.get(property)(value);\n            }\n        }\n        result[property] = value;\n    }\n    if (!any) {\n        throw new TypeError('no supported properties found');\n    }\n    if ((result['era'] === undefined) !==\n        (result['eraYear'] === undefined)) {\n        throw new RangeError(\"properties 'era' and 'eraYear' must be provided together\");\n    }\n    return result;\n}\n// field access in the following operations is intentionally alphabetical\nfunction ToTemporalDateFields(bag, fieldNames) {\n    const entries = [\n        ['day', undefined],\n        ['month', undefined],\n        ['monthCode', undefined],\n        ['year', undefined]\n    ];\n    // Add extra fields from the calendar at the end\n    fieldNames.forEach((fieldName) => {\n        if (!entries.some(([name]) => name === fieldName)) {\n            entries.push([fieldName, undefined]);\n        }\n    });\n    return PrepareTemporalFields(bag, entries);\n}\nfunction ToTemporalDateTimeFields(bag, fieldNames) {\n    const entries = [\n        ['day', undefined],\n        ['hour', 0],\n        ['microsecond', 0],\n        ['millisecond', 0],\n        ['minute', 0],\n        ['month', undefined],\n        ['monthCode', undefined],\n        ['nanosecond', 0],\n        ['second', 0],\n        ['year', undefined]\n    ];\n    // Add extra fields from the calendar at the end\n    fieldNames.forEach((fieldName) => {\n        if (!entries.some(([name]) => name === fieldName)) {\n            entries.push([fieldName, undefined]);\n        }\n    });\n    return PrepareTemporalFields(bag, entries);\n}\nfunction ToTemporalMonthDayFields(bag, fieldNames) {\n    const entries = [\n        ['day', undefined],\n        ['month', undefined],\n        ['monthCode', undefined],\n        ['year', undefined]\n    ];\n    // Add extra fields from the calendar at the end\n    fieldNames.forEach((fieldName) => {\n        if (!entries.some(([name]) => name === fieldName)) {\n            entries.push([fieldName, undefined]);\n        }\n    });\n    return PrepareTemporalFields(bag, entries);\n}\nfunction ToTemporalTimeRecord(bag) {\n    return PrepareTemporalFields(bag, [\n        ['hour', 0],\n        ['microsecond', 0],\n        ['millisecond', 0],\n        ['minute', 0],\n        ['nanosecond', 0],\n        ['second', 0]\n    ]);\n}\nfunction ToTemporalYearMonthFields(bag, fieldNames) {\n    const entries = [\n        ['month', undefined],\n        ['monthCode', undefined],\n        ['year', undefined]\n    ];\n    // Add extra fields from the calendar at the end\n    fieldNames.forEach((fieldName) => {\n        if (!entries.some(([name]) => name === fieldName)) {\n            entries.push([fieldName, undefined]);\n        }\n    });\n    return PrepareTemporalFields(bag, entries);\n}\nfunction ToTemporalZonedDateTimeFields(bag, fieldNames) {\n    const entries = [\n        ['day', undefined],\n        ['hour', 0],\n        ['microsecond', 0],\n        ['millisecond', 0],\n        ['minute', 0],\n        ['month', undefined],\n        ['monthCode', undefined],\n        ['nanosecond', 0],\n        ['second', 0],\n        ['year', undefined],\n        ['offset', undefined],\n        ['timeZone']\n    ];\n    // Add extra fields from the calendar at the end\n    fieldNames.forEach((fieldName) => {\n        if (!entries.some(([name]) => name === fieldName)) {\n            entries.push([fieldName, undefined]);\n        }\n    });\n    return PrepareTemporalFields(bag, entries);\n}\nfunction ToTemporalDate(itemParam, options = ObjectCreate$2(null)) {\n    let item = itemParam;\n    if (IsObject(item)) {\n        if (IsTemporalDate(item))\n            return item;\n        if (IsTemporalZonedDateTime(item)) {\n            item = BuiltinTimeZoneGetPlainDateTimeFor(GetSlot(item, TIME_ZONE), GetSlot(item, INSTANT), GetSlot(item, CALENDAR));\n        }\n        if (IsTemporalDateTime(item)) {\n            return CreateTemporalDate(GetSlot(item, ISO_YEAR), GetSlot(item, ISO_MONTH), GetSlot(item, ISO_DAY), GetSlot(item, CALENDAR));\n        }\n        const calendar = GetTemporalCalendarWithISODefault(item);\n        const fieldNames = CalendarFields(calendar, ['day', 'month', 'monthCode', 'year']);\n        const fields = ToTemporalDateFields(item, fieldNames);\n        return DateFromFields(calendar, fields, options);\n    }\n    ToTemporalOverflow(options); // validate and ignore\n    const { year, month, day, calendar, z } = ParseTemporalDateString(ToString(item));\n    if (z)\n        throw new RangeError('Z designator not supported for PlainDate');\n    const TemporalPlainDate = GetIntrinsic('%Temporal.PlainDate%');\n    return new TemporalPlainDate(year, month, day, calendar); // include validation\n}\nfunction InterpretTemporalDateTimeFields(calendar, fields, options) {\n    let { hour, minute, second, millisecond, microsecond, nanosecond } = ToTemporalTimeRecord(fields);\n    const overflow = ToTemporalOverflow(options);\n    const date = DateFromFields(calendar, fields, options);\n    const year = GetSlot(date, ISO_YEAR);\n    const month = GetSlot(date, ISO_MONTH);\n    const day = GetSlot(date, ISO_DAY);\n    ({ hour, minute, second, millisecond, microsecond, nanosecond } = RegulateTime(hour, minute, second, millisecond, microsecond, nanosecond, overflow));\n    return { year, month, day, hour, minute, second, millisecond, microsecond, nanosecond };\n}\nfunction ToTemporalDateTime(item, options = ObjectCreate$2(null)) {\n    let year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar;\n    if (IsObject(item)) {\n        if (IsTemporalDateTime(item))\n            return item;\n        if (IsTemporalZonedDateTime(item)) {\n            return BuiltinTimeZoneGetPlainDateTimeFor(GetSlot(item, TIME_ZONE), GetSlot(item, INSTANT), GetSlot(item, CALENDAR));\n        }\n        if (IsTemporalDate(item)) {\n            return CreateTemporalDateTime(GetSlot(item, ISO_YEAR), GetSlot(item, ISO_MONTH), GetSlot(item, ISO_DAY), 0, 0, 0, 0, 0, 0, GetSlot(item, CALENDAR));\n        }\n        calendar = GetTemporalCalendarWithISODefault(item);\n        const fieldNames = CalendarFields(calendar, [\n            'day',\n            'hour',\n            'microsecond',\n            'millisecond',\n            'minute',\n            'month',\n            'monthCode',\n            'nanosecond',\n            'second',\n            'year'\n        ]);\n        const fields = ToTemporalDateTimeFields(item, fieldNames);\n        ({ year, month, day, hour, minute, second, millisecond, microsecond, nanosecond } = InterpretTemporalDateTimeFields(calendar, fields, options));\n    }\n    else {\n        ToTemporalOverflow(options); // validate and ignore\n        let z;\n        ({ year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar, z } =\n            ParseTemporalDateTimeString(ToString(item)));\n        if (z)\n            throw new RangeError('Z designator not supported for PlainDateTime');\n        RejectDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond);\n        if (calendar === undefined)\n            calendar = GetISO8601Calendar();\n        calendar = ToTemporalCalendar(calendar);\n    }\n    return CreateTemporalDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar);\n}\nfunction ToTemporalDuration(item) {\n    let years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds;\n    if (IsObject(item)) {\n        if (IsTemporalDuration(item))\n            return item;\n        ({ years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } =\n            ToTemporalDurationRecord(item));\n    }\n    else {\n        ({ years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } =\n            ParseTemporalDurationString(ToString(item)));\n    }\n    const TemporalDuration = GetIntrinsic('%Temporal.Duration%');\n    return new TemporalDuration(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n}\nfunction ToTemporalInstant(item) {\n    if (IsTemporalInstant(item))\n        return item;\n    if (IsTemporalZonedDateTime(item)) {\n        const TemporalInstant = GetIntrinsic('%Temporal.Instant%');\n        return new TemporalInstant(GetSlot(item, EPOCHNANOSECONDS));\n    }\n    const ns = ParseTemporalInstant(ToString(item));\n    const TemporalInstant = GetIntrinsic('%Temporal.Instant%');\n    return new TemporalInstant(ns);\n}\nfunction ToTemporalMonthDay(item, options = ObjectCreate$2(null)) {\n    if (IsObject(item)) {\n        if (IsTemporalMonthDay(item))\n            return item;\n        let calendar, calendarAbsent;\n        if (HasSlot(item, CALENDAR)) {\n            calendar = GetSlot(item, CALENDAR);\n            calendarAbsent = false;\n        }\n        else {\n            let maybeStringCalendar = item.calendar;\n            calendarAbsent = maybeStringCalendar === undefined;\n            if (maybeStringCalendar === undefined)\n                maybeStringCalendar = GetISO8601Calendar();\n            calendar = ToTemporalCalendar(maybeStringCalendar);\n        }\n        const fieldNames = CalendarFields(calendar, ['day', 'month', 'monthCode', 'year']);\n        const fields = ToTemporalMonthDayFields(item, fieldNames);\n        // Callers who omit the calendar are not writing calendar-independent\n        // code. In that case, `monthCode`/`year` can be omitted; `month` and\n        // `day` are sufficient. Add a `year` to satisfy calendar validation.\n        if (calendarAbsent && fields.month !== undefined && fields.monthCode === undefined && fields.year === undefined) {\n            fields.year = 1972;\n        }\n        return MonthDayFromFields(calendar, fields, options);\n    }\n    ToTemporalOverflow(options); // validate and ignore\n    let { month, day, referenceISOYear, calendar: maybeStringCalendar } = ParseTemporalMonthDayString(ToString(item));\n    let calendar = maybeStringCalendar;\n    if (calendar === undefined)\n        calendar = GetISO8601Calendar();\n    calendar = ToTemporalCalendar(calendar);\n    if (referenceISOYear === undefined) {\n        RejectISODate(1972, month, day);\n        return CreateTemporalMonthDay(month, day, calendar);\n    }\n    const result = CreateTemporalMonthDay(month, day, calendar, referenceISOYear);\n    const canonicalOptions = ObjectCreate$2(null);\n    return MonthDayFromFields(calendar, result, canonicalOptions);\n}\nfunction ToTemporalTime(itemParam, overflow = 'constrain') {\n    let item = itemParam;\n    let hour, minute, second, millisecond, microsecond, nanosecond, calendar;\n    if (IsObject(item)) {\n        if (IsTemporalTime(item))\n            return item;\n        if (IsTemporalZonedDateTime(item)) {\n            item = BuiltinTimeZoneGetPlainDateTimeFor(GetSlot(item, TIME_ZONE), GetSlot(item, INSTANT), GetSlot(item, CALENDAR));\n        }\n        if (IsTemporalDateTime(item)) {\n            const TemporalPlainTime = GetIntrinsic('%Temporal.PlainTime%');\n            return new TemporalPlainTime(GetSlot(item, ISO_HOUR), GetSlot(item, ISO_MINUTE), GetSlot(item, ISO_SECOND), GetSlot(item, ISO_MILLISECOND), GetSlot(item, ISO_MICROSECOND), GetSlot(item, ISO_NANOSECOND));\n        }\n        calendar = GetTemporalCalendarWithISODefault(item);\n        if (ToString(calendar) !== 'iso8601') {\n            throw new RangeError('PlainTime can only have iso8601 calendar');\n        }\n        ({ hour, minute, second, millisecond, microsecond, nanosecond } = ToTemporalTimeRecord(item));\n        ({ hour, minute, second, millisecond, microsecond, nanosecond } = RegulateTime(hour, minute, second, millisecond, microsecond, nanosecond, overflow));\n    }\n    else {\n        ({ hour, minute, second, millisecond, microsecond, nanosecond, calendar } = ParseTemporalTimeString(ToString(item)));\n        RejectTime(hour, minute, second, millisecond, microsecond, nanosecond);\n        if (calendar !== undefined && calendar !== 'iso8601') {\n            throw new RangeError('PlainTime can only have iso8601 calendar');\n        }\n    }\n    const TemporalPlainTime = GetIntrinsic('%Temporal.PlainTime%');\n    return new TemporalPlainTime(hour, minute, second, millisecond, microsecond, nanosecond);\n}\nfunction ToTemporalYearMonth(item, options = ObjectCreate$2(null)) {\n    if (IsObject(item)) {\n        if (IsTemporalYearMonth(item))\n            return item;\n        const calendar = GetTemporalCalendarWithISODefault(item);\n        const fieldNames = CalendarFields(calendar, ['month', 'monthCode', 'year']);\n        const fields = ToTemporalYearMonthFields(item, fieldNames);\n        return YearMonthFromFields(calendar, fields, options);\n    }\n    ToTemporalOverflow(options); // validate and ignore\n    let { year, month, referenceISODay, calendar: maybeStringCalendar } = ParseTemporalYearMonthString(ToString(item));\n    // TODO: replace with ternary?\n    let calendar = maybeStringCalendar;\n    if (calendar === undefined)\n        calendar = GetISO8601Calendar();\n    calendar = ToTemporalCalendar(calendar);\n    if (referenceISODay === undefined) {\n        RejectISODate(year, month, 1);\n        return CreateTemporalYearMonth(year, month, calendar);\n    }\n    const result = CreateTemporalYearMonth(year, month, calendar, referenceISODay);\n    const canonicalOptions = ObjectCreate$2(null);\n    return YearMonthFromFields(calendar, result, canonicalOptions);\n}\nfunction InterpretISODateTimeOffset(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, offsetBehaviour, offsetNs, timeZone, disambiguation, offsetOpt, matchMinute) {\n    const DateTime = GetIntrinsic('%Temporal.PlainDateTime%');\n    const dt = new DateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond);\n    if (offsetBehaviour === 'wall' || offsetOpt === 'ignore') {\n        // Simple case: ISO string without a TZ offset (or caller wants to ignore\n        // the offset), so just convert DateTime to Instant in the given time zone\n        const instant = BuiltinTimeZoneGetInstantFor(timeZone, dt, disambiguation);\n        return GetSlot(instant, EPOCHNANOSECONDS);\n    }\n    // The caller wants the offset to always win ('use') OR the caller is OK\n    // with the offset winning ('prefer' or 'reject') as long as it's valid\n    // for this timezone and date/time.\n    if (offsetBehaviour === 'exact' || offsetOpt === 'use') {\n        // Calculate the instant for the input's date/time and offset\n        const epochNs = GetEpochFromISOParts(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond);\n        if (epochNs === null)\n            throw new RangeError('ZonedDateTime outside of supported range');\n        return jsbi_umd.subtract(epochNs, jsbi_umd.BigInt(offsetNs));\n    }\n    // \"prefer\" or \"reject\"\n    const possibleInstants = GetPossibleInstantsFor(timeZone, dt);\n    for (const candidate of possibleInstants) {\n        const candidateOffset = GetOffsetNanosecondsFor(timeZone, candidate);\n        const roundedCandidateOffset = jsbi_umd.toNumber(RoundNumberToIncrement(jsbi_umd.BigInt(candidateOffset), 60e9, 'halfExpand'));\n        if (candidateOffset === offsetNs || (matchMinute && roundedCandidateOffset === offsetNs)) {\n            return GetSlot(candidate, EPOCHNANOSECONDS);\n        }\n    }\n    // the user-provided offset doesn't match any instants for this time\n    // zone and date/time.\n    if (offsetOpt === 'reject') {\n        const offsetStr = FormatTimeZoneOffsetString(offsetNs);\n        const timeZoneString = IsTemporalTimeZone(timeZone) ? GetSlot(timeZone, TIMEZONE_ID) : 'time zone';\n        // The tsc emit for this line rewrites to invoke the PlainDateTime's valueOf method, NOT\n        // toString (which is invoked by Node when using template literals directly).\n        // See https://github.com/microsoft/TypeScript/issues/39744 for the proposed fix in tsc emit\n        throw new RangeError(`Offset ${offsetStr} is invalid for ${dt.toString()} in ${timeZoneString}`);\n    }\n    // fall through: offsetOpt === 'prefer', but the offset doesn't match\n    // so fall back to use the time zone instead.\n    const instant = DisambiguatePossibleInstants(possibleInstants, timeZone, dt, disambiguation);\n    return GetSlot(instant, EPOCHNANOSECONDS);\n}\nfunction ToTemporalZonedDateTime(item, options = ObjectCreate$2(null)) {\n    let year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, timeZone, offset, calendar;\n    let matchMinute = false;\n    let offsetBehaviour = 'option';\n    if (IsObject(item)) {\n        if (IsTemporalZonedDateTime(item))\n            return item;\n        calendar = GetTemporalCalendarWithISODefault(item);\n        const fieldNames = CalendarFields(calendar, [\n            'day',\n            'hour',\n            'microsecond',\n            'millisecond',\n            'minute',\n            'month',\n            'monthCode',\n            'nanosecond',\n            'second',\n            'year'\n        ]);\n        const fields = ToTemporalZonedDateTimeFields(item, fieldNames);\n        ({ year, month, day, hour, minute, second, millisecond, microsecond, nanosecond } = InterpretTemporalDateTimeFields(calendar, fields, options));\n        timeZone = ToTemporalTimeZone(fields.timeZone);\n        offset = fields.offset;\n        if (offset === undefined) {\n            offsetBehaviour = 'wall';\n        }\n        else {\n            offset = ToString(offset);\n        }\n    }\n    else {\n        ToTemporalOverflow(options); // validate and ignore\n        let ianaName, z;\n        ({ year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, ianaName, offset, z, calendar } =\n            ParseTemporalZonedDateTimeString(ToString(item)));\n        if (!ianaName)\n            throw new RangeError('time zone ID required in brackets');\n        if (z) {\n            offsetBehaviour = 'exact';\n        }\n        else if (!offset) {\n            offsetBehaviour = 'wall';\n        }\n        const TemporalTimeZone = GetIntrinsic('%Temporal.TimeZone%');\n        timeZone = new TemporalTimeZone(ianaName);\n        if (!calendar)\n            calendar = GetISO8601Calendar();\n        calendar = ToTemporalCalendar(calendar);\n        matchMinute = true; // ISO strings may specify offset with less precision\n    }\n    let offsetNs = 0;\n    // The code above guarantees that if offsetBehaviour === 'option', then\n    // `offset` is not undefined.\n    if (offsetBehaviour === 'option')\n        offsetNs = ParseTimeZoneOffsetString(offset);\n    const disambiguation = ToTemporalDisambiguation(options);\n    const offsetOpt = ToTemporalOffset(options, 'reject');\n    const epochNanoseconds = InterpretISODateTimeOffset(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, offsetBehaviour, offsetNs, timeZone, disambiguation, offsetOpt, matchMinute);\n    return CreateTemporalZonedDateTime(epochNanoseconds, timeZone, calendar);\n}\nfunction CreateTemporalDateSlots(result, isoYear, isoMonth, isoDay, calendar) {\n    RejectISODate(isoYear, isoMonth, isoDay);\n    RejectDateRange(isoYear, isoMonth, isoDay);\n    CreateSlots(result);\n    SetSlot(result, ISO_YEAR, isoYear);\n    SetSlot(result, ISO_MONTH, isoMonth);\n    SetSlot(result, ISO_DAY, isoDay);\n    SetSlot(result, CALENDAR, calendar);\n    SetSlot(result, DATE_BRAND, true);\n    {\n        ObjectDefineProperty(result, '_repr_', {\n            value: `${result[Symbol.toStringTag]} <${TemporalDateToString(result)}>`,\n            writable: false,\n            enumerable: false,\n            configurable: false\n        });\n    }\n}\nfunction CreateTemporalDate(isoYear, isoMonth, isoDay, calendar = GetISO8601Calendar()) {\n    const TemporalPlainDate = GetIntrinsic('%Temporal.PlainDate%');\n    const result = ObjectCreate$2(TemporalPlainDate.prototype);\n    CreateTemporalDateSlots(result, isoYear, isoMonth, isoDay, calendar);\n    return result;\n}\nfunction CreateTemporalDateTimeSlots(result, isoYear, isoMonth, isoDay, h, min, s, ms, s, ns, calendar) {\n    RejectDateTime(isoYear, isoMonth, isoDay, h, min, s, ms, s, ns);\n    RejectDateTimeRange(isoYear, isoMonth, isoDay, h, min, s, ms, s, ns);\n    CreateSlots(result);\n    SetSlot(result, ISO_YEAR, isoYear);\n    SetSlot(result, ISO_MONTH, isoMonth);\n    SetSlot(result, ISO_DAY, isoDay);\n    SetSlot(result, ISO_HOUR, h);\n    SetSlot(result, ISO_MINUTE, min);\n    SetSlot(result, ISO_SECOND, s);\n    SetSlot(result, ISO_MILLISECOND, ms);\n    SetSlot(result, ISO_MICROSECOND, s);\n    SetSlot(result, ISO_NANOSECOND, ns);\n    SetSlot(result, CALENDAR, calendar);\n    {\n        Object.defineProperty(result, '_repr_', {\n            value: `${result[Symbol.toStringTag]} <${TemporalDateTimeToString(result, 'auto')}>`,\n            writable: false,\n            enumerable: false,\n            configurable: false\n        });\n    }\n}\nfunction CreateTemporalDateTime(isoYear, isoMonth, isoDay, h, min, s, ms, s, ns, calendar = GetISO8601Calendar()) {\n    const TemporalPlainDateTime = GetIntrinsic('%Temporal.PlainDateTime%');\n    const result = ObjectCreate$2(TemporalPlainDateTime.prototype);\n    CreateTemporalDateTimeSlots(result, isoYear, isoMonth, isoDay, h, min, s, ms, s, ns, calendar);\n    return result;\n}\nfunction CreateTemporalMonthDaySlots(result, isoMonth, isoDay, calendar, referenceISOYear) {\n    RejectISODate(referenceISOYear, isoMonth, isoDay);\n    RejectDateRange(referenceISOYear, isoMonth, isoDay);\n    CreateSlots(result);\n    SetSlot(result, ISO_MONTH, isoMonth);\n    SetSlot(result, ISO_DAY, isoDay);\n    SetSlot(result, ISO_YEAR, referenceISOYear);\n    SetSlot(result, CALENDAR, calendar);\n    SetSlot(result, MONTH_DAY_BRAND, true);\n    {\n        Object.defineProperty(result, '_repr_', {\n            value: `${result[Symbol.toStringTag]} <${TemporalMonthDayToString(result)}>`,\n            writable: false,\n            enumerable: false,\n            configurable: false\n        });\n    }\n}\nfunction CreateTemporalMonthDay(isoMonth, isoDay, calendar = GetISO8601Calendar(), referenceISOYear = 1972) {\n    const TemporalPlainMonthDay = GetIntrinsic('%Temporal.PlainMonthDay%');\n    const result = ObjectCreate$2(TemporalPlainMonthDay.prototype);\n    CreateTemporalMonthDaySlots(result, isoMonth, isoDay, calendar, referenceISOYear);\n    return result;\n}\nfunction CreateTemporalYearMonthSlots(result, isoYear, isoMonth, calendar, referenceISODay) {\n    RejectISODate(isoYear, isoMonth, referenceISODay);\n    RejectYearMonthRange(isoYear, isoMonth);\n    CreateSlots(result);\n    SetSlot(result, ISO_YEAR, isoYear);\n    SetSlot(result, ISO_MONTH, isoMonth);\n    SetSlot(result, ISO_DAY, referenceISODay);\n    SetSlot(result, CALENDAR, calendar);\n    SetSlot(result, YEAR_MONTH_BRAND, true);\n    {\n        Object.defineProperty(result, '_repr_', {\n            value: `${result[Symbol.toStringTag]} <${TemporalYearMonthToString(result)}>`,\n            writable: false,\n            enumerable: false,\n            configurable: false\n        });\n    }\n}\nfunction CreateTemporalYearMonth(isoYear, isoMonth, calendar = GetISO8601Calendar(), referenceISODay = 1) {\n    const TemporalPlainYearMonth = GetIntrinsic('%Temporal.PlainYearMonth%');\n    const result = ObjectCreate$2(TemporalPlainYearMonth.prototype);\n    CreateTemporalYearMonthSlots(result, isoYear, isoMonth, calendar, referenceISODay);\n    return result;\n}\nfunction CreateTemporalZonedDateTimeSlots(result, epochNanoseconds, timeZone, calendar) {\n    ValidateEpochNanoseconds(epochNanoseconds);\n    CreateSlots(result);\n    SetSlot(result, EPOCHNANOSECONDS, epochNanoseconds);\n    SetSlot(result, TIME_ZONE, timeZone);\n    SetSlot(result, CALENDAR, calendar);\n    const TemporalInstant = GetIntrinsic('%Temporal.Instant%');\n    const instant = new TemporalInstant(GetSlot(result, EPOCHNANOSECONDS));\n    SetSlot(result, INSTANT, instant);\n    {\n        Object.defineProperty(result, '_repr_', {\n            value: `${result[Symbol.toStringTag]} <${TemporalZonedDateTimeToString(result, 'auto')}>`,\n            writable: false,\n            enumerable: false,\n            configurable: false\n        });\n    }\n}\nfunction CreateTemporalZonedDateTime(epochNanoseconds, timeZone, calendar = GetISO8601Calendar()) {\n    const TemporalZonedDateTime = GetIntrinsic('%Temporal.ZonedDateTime%');\n    const result = ObjectCreate$2(TemporalZonedDateTime.prototype);\n    CreateTemporalZonedDateTimeSlots(result, epochNanoseconds, timeZone, calendar);\n    return result;\n}\nfunction GetISO8601Calendar() {\n    const TemporalCalendar = GetIntrinsic('%Temporal.Calendar%');\n    return new TemporalCalendar('iso8601');\n}\n// TODO: should (can?) we make this generic so the field names are checked\n// against the type that the calendar is a property of?\nfunction CalendarFields(calendar, fieldNamesParam) {\n    let fieldNames = fieldNamesParam;\n    if (calendar.fields) {\n        fieldNames = calendar.fields(fieldNames);\n    }\n    const result = [];\n    for (const name of fieldNames) {\n        if (typeof name !== 'string')\n            throw new TypeError('bad return from calendar.fields()');\n        ArrayPrototypePush$1.call(result, name);\n    }\n    return result;\n}\nfunction CalendarMergeFields(calendar, fields, additionalFields) {\n    const calMergeFields = calendar.mergeFields;\n    if (!calMergeFields) {\n        return { ...fields, ...additionalFields };\n    }\n    const result = Reflect.apply(calMergeFields, calendar, [fields, additionalFields]);\n    if (!IsObject(result))\n        throw new TypeError('bad return from calendar.mergeFields()');\n    return result;\n}\nfunction CalendarDateAdd(calendar, date, duration, options, dateAddParam) {\n    let dateAdd = dateAddParam;\n    if (dateAdd === undefined) {\n        dateAdd = calendar.dateAdd;\n    }\n    const result = ReflectApply$1(dateAdd, calendar, [date, duration, options]);\n    if (!IsTemporalDate(result))\n        throw new TypeError('invalid result');\n    return result;\n}\nfunction CalendarDateUntil(calendar, date, otherDate, options, dateUntilParam) {\n    let dateUntil = dateUntilParam;\n    if (dateUntil === undefined) {\n        dateUntil = calendar.dateUntil;\n    }\n    const result = ReflectApply$1(dateUntil, calendar, [date, otherDate, options]);\n    if (!IsTemporalDuration(result))\n        throw new TypeError('invalid result');\n    return result;\n}\nfunction CalendarYear(calendar, dateLike) {\n    const result = calendar.year(dateLike);\n    if (result === undefined) {\n        throw new RangeError('calendar year result must be an integer');\n    }\n    return ToIntegerThrowOnInfinity(result);\n}\nfunction CalendarMonth(calendar, dateLike) {\n    const result = calendar.month(dateLike);\n    if (result === undefined) {\n        throw new RangeError('calendar month result must be a positive integer');\n    }\n    return ToPositiveInteger(result);\n}\nfunction CalendarMonthCode(calendar, dateLike) {\n    const result = calendar.monthCode(dateLike);\n    if (result === undefined) {\n        throw new RangeError('calendar monthCode result must be a string');\n    }\n    return ToString(result);\n}\nfunction CalendarDay(calendar, dateLike) {\n    const result = calendar.day(dateLike);\n    if (result === undefined) {\n        throw new RangeError('calendar day result must be a positive integer');\n    }\n    return ToPositiveInteger(result);\n}\nfunction CalendarEra(calendar, dateLike) {\n    let result = calendar.era(dateLike);\n    if (result !== undefined) {\n        result = ToString(result);\n    }\n    return result;\n}\nfunction CalendarEraYear(calendar, dateLike) {\n    let result = calendar.eraYear(dateLike);\n    if (result !== undefined) {\n        result = ToIntegerThrowOnInfinity(result);\n    }\n    return result;\n}\nfunction CalendarDayOfWeek(calendar, dateLike) {\n    return calendar.dayOfWeek(dateLike);\n}\nfunction CalendarDayOfYear(calendar, dateLike) {\n    return calendar.dayOfYear(dateLike);\n}\nfunction CalendarWeekOfYear(calendar, dateLike) {\n    return calendar.weekOfYear(dateLike);\n}\nfunction CalendarDaysInWeek(calendar, dateLike) {\n    return calendar.daysInWeek(dateLike);\n}\nfunction CalendarDaysInMonth(calendar, dateLike) {\n    return calendar.daysInMonth(dateLike);\n}\nfunction CalendarDaysInYear(calendar, dateLike) {\n    return calendar.daysInYear(dateLike);\n}\nfunction CalendarMonthsInYear(calendar, dateLike) {\n    return calendar.monthsInYear(dateLike);\n}\nfunction CalendarInLeapYear(calendar, dateLike) {\n    return calendar.inLeapYear(dateLike);\n}\nfunction ToTemporalCalendar(calendarLikeParam) {\n    let calendarLike = calendarLikeParam;\n    if (IsObject(calendarLike)) {\n        if (HasSlot(calendarLike, CALENDAR))\n            return GetSlot(calendarLike, CALENDAR);\n        if (!('calendar' in calendarLike))\n            return calendarLike;\n        calendarLike = calendarLike.calendar;\n        if (IsObject(calendarLike) && !('calendar' in calendarLike))\n            return calendarLike;\n    }\n    const identifier = ToString(calendarLike);\n    const TemporalCalendar = GetIntrinsic('%Temporal.Calendar%');\n    if (IsBuiltinCalendar(identifier))\n        return new TemporalCalendar(identifier);\n    let calendar;\n    try {\n        ({ calendar } = ParseISODateTime(identifier));\n    }\n    catch {\n        throw new RangeError(`Invalid calendar: ${identifier}`);\n    }\n    if (!calendar)\n        calendar = 'iso8601';\n    return new TemporalCalendar(calendar);\n}\nfunction GetTemporalCalendarWithISODefault(item) {\n    if (HasSlot(item, CALENDAR))\n        return GetSlot(item, CALENDAR);\n    const { calendar } = item;\n    if (calendar === undefined)\n        return GetISO8601Calendar();\n    return ToTemporalCalendar(calendar);\n}\nfunction CalendarEquals(one, two) {\n    if (one === two)\n        return true;\n    const cal1 = ToString(one);\n    const cal2 = ToString(two);\n    return cal1 === cal2;\n}\nfunction ConsolidateCalendars(one, two) {\n    if (one === two)\n        return two;\n    const sOne = ToString(one);\n    const sTwo = ToString(two);\n    if (sOne === sTwo || sOne === 'iso8601') {\n        return two;\n    }\n    else if (sTwo === 'iso8601') {\n        return one;\n    }\n    else {\n        throw new RangeError('irreconcilable calendars');\n    }\n}\nfunction DateFromFields(calendar, fields, options) {\n    const result = calendar.dateFromFields(fields, options);\n    if (!IsTemporalDate(result))\n        throw new TypeError('invalid result');\n    return result;\n}\nfunction YearMonthFromFields(calendar, fields, options) {\n    const result = calendar.yearMonthFromFields(fields, options);\n    if (!IsTemporalYearMonth(result))\n        throw new TypeError('invalid result');\n    return result;\n}\nfunction MonthDayFromFields(calendar, fields, options) {\n    const result = calendar.monthDayFromFields(fields, options);\n    if (!IsTemporalMonthDay(result))\n        throw new TypeError('invalid result');\n    return result;\n}\nfunction ToTemporalTimeZone(temporalTimeZoneLikeParam) {\n    let temporalTimeZoneLike = temporalTimeZoneLikeParam;\n    if (IsObject(temporalTimeZoneLike)) {\n        if (IsTemporalZonedDateTime(temporalTimeZoneLike))\n            return GetSlot(temporalTimeZoneLike, TIME_ZONE);\n        if (!('timeZone' in temporalTimeZoneLike))\n            return temporalTimeZoneLike;\n        temporalTimeZoneLike = temporalTimeZoneLike.timeZone;\n        if (IsObject(temporalTimeZoneLike) && !('timeZone' in temporalTimeZoneLike)) {\n            return temporalTimeZoneLike;\n        }\n    }\n    const identifier = ToString(temporalTimeZoneLike);\n    const timeZone = ParseTemporalTimeZone(identifier);\n    const TemporalTimeZone = GetIntrinsic('%Temporal.TimeZone%');\n    return new TemporalTimeZone(timeZone);\n}\nfunction TimeZoneEquals(one, two) {\n    if (one === two)\n        return true;\n    const tz1 = ToString(one);\n    const tz2 = ToString(two);\n    return tz1 === tz2;\n}\nfunction TemporalDateTimeToDate(dateTime) {\n    return CreateTemporalDate(GetSlot(dateTime, ISO_YEAR), GetSlot(dateTime, ISO_MONTH), GetSlot(dateTime, ISO_DAY), GetSlot(dateTime, CALENDAR));\n}\nfunction TemporalDateTimeToTime(dateTime) {\n    const Time = GetIntrinsic('%Temporal.PlainTime%');\n    return new Time(GetSlot(dateTime, ISO_HOUR), GetSlot(dateTime, ISO_MINUTE), GetSlot(dateTime, ISO_SECOND), GetSlot(dateTime, ISO_MILLISECOND), GetSlot(dateTime, ISO_MICROSECOND), GetSlot(dateTime, ISO_NANOSECOND));\n}\nfunction GetOffsetNanosecondsFor(timeZone, instant) {\n    let getOffsetNanosecondsFor = timeZone.getOffsetNanosecondsFor;\n    if (typeof getOffsetNanosecondsFor !== 'function') {\n        throw new TypeError('getOffsetNanosecondsFor not callable');\n    }\n    const offsetNs = Reflect.apply(getOffsetNanosecondsFor, timeZone, [instant]);\n    if (typeof offsetNs !== 'number') {\n        throw new TypeError('bad return from getOffsetNanosecondsFor');\n    }\n    if (!IsInteger(offsetNs) || MathAbs(offsetNs) > 86400e9) {\n        throw new RangeError('out-of-range return from getOffsetNanosecondsFor');\n    }\n    return offsetNs;\n}\nfunction BuiltinTimeZoneGetOffsetStringFor(timeZone, instant) {\n    const offsetNs = GetOffsetNanosecondsFor(timeZone, instant);\n    return FormatTimeZoneOffsetString(offsetNs);\n}\nfunction BuiltinTimeZoneGetPlainDateTimeFor(timeZone, instant, calendar) {\n    const ns = GetSlot(instant, EPOCHNANOSECONDS);\n    const offsetNs = GetOffsetNanosecondsFor(timeZone, instant);\n    let { year, month, day, hour, minute, second, millisecond, microsecond, nanosecond } = GetISOPartsFromEpoch(ns);\n    ({ year, month, day, hour, minute, second, millisecond, microsecond, nanosecond } = BalanceISODateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond + offsetNs));\n    return CreateTemporalDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar);\n}\nfunction BuiltinTimeZoneGetInstantFor(timeZone, dateTime, disambiguation) {\n    const possibleInstants = GetPossibleInstantsFor(timeZone, dateTime);\n    return DisambiguatePossibleInstants(possibleInstants, timeZone, dateTime, disambiguation);\n}\nfunction DisambiguatePossibleInstants(possibleInstants, timeZone, dateTime, disambiguation) {\n    const Instant = GetIntrinsic('%Temporal.Instant%');\n    const numInstants = possibleInstants.length;\n    if (numInstants === 1)\n        return possibleInstants[0];\n    if (numInstants) {\n        switch (disambiguation) {\n            case 'compatible':\n            // fall through because 'compatible' means 'earlier' for \"fall back\" transitions\n            case 'earlier':\n                return possibleInstants[0];\n            case 'later':\n                return possibleInstants[numInstants - 1];\n            case 'reject': {\n                throw new RangeError('multiple instants found');\n            }\n        }\n    }\n    const year = GetSlot(dateTime, ISO_YEAR);\n    const month = GetSlot(dateTime, ISO_MONTH);\n    const day = GetSlot(dateTime, ISO_DAY);\n    const hour = GetSlot(dateTime, ISO_HOUR);\n    const minute = GetSlot(dateTime, ISO_MINUTE);\n    const second = GetSlot(dateTime, ISO_SECOND);\n    const millisecond = GetSlot(dateTime, ISO_MILLISECOND);\n    const microsecond = GetSlot(dateTime, ISO_MICROSECOND);\n    const nanosecond = GetSlot(dateTime, ISO_NANOSECOND);\n    const utcns = GetEpochFromISOParts(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond);\n    if (utcns === null)\n        throw new RangeError('DateTime outside of supported range');\n    const dayBefore = new Instant(jsbi_umd.subtract(utcns, DAY_NANOS));\n    const dayAfter = new Instant(jsbi_umd.add(utcns, DAY_NANOS));\n    const offsetBefore = GetOffsetNanosecondsFor(timeZone, dayBefore);\n    const offsetAfter = GetOffsetNanosecondsFor(timeZone, dayAfter);\n    const nanoseconds = offsetAfter - offsetBefore;\n    switch (disambiguation) {\n        case 'earlier': {\n            const calendar = GetSlot(dateTime, CALENDAR);\n            const PlainDateTime = GetIntrinsic('%Temporal.PlainDateTime%');\n            const earlier = AddDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar, 0, 0, 0, 0, 0, 0, 0, 0, 0, -nanoseconds, undefined);\n            const earlierPlainDateTime = new PlainDateTime(earlier.year, earlier.month, earlier.day, earlier.hour, earlier.minute, earlier.second, earlier.millisecond, earlier.microsecond, earlier.nanosecond, calendar);\n            return GetPossibleInstantsFor(timeZone, earlierPlainDateTime)[0];\n        }\n        case 'compatible':\n        // fall through because 'compatible' means 'later' for \"spring forward\" transitions\n        case 'later': {\n            const calendar = GetSlot(dateTime, CALENDAR);\n            const PlainDateTime = GetIntrinsic('%Temporal.PlainDateTime%');\n            const later = AddDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar, 0, 0, 0, 0, 0, 0, 0, 0, 0, nanoseconds, undefined);\n            const laterPlainDateTime = new PlainDateTime(later.year, later.month, later.day, later.hour, later.minute, later.second, later.millisecond, later.microsecond, later.nanosecond, calendar);\n            const possible = GetPossibleInstantsFor(timeZone, laterPlainDateTime);\n            return possible[possible.length - 1];\n        }\n        case 'reject': {\n            throw new RangeError('no such instant found');\n        }\n    }\n}\nfunction GetPossibleInstantsFor(timeZone, dateTime) {\n    const possibleInstants = timeZone.getPossibleInstantsFor(dateTime);\n    const result = [];\n    for (const instant of possibleInstants) {\n        if (!IsTemporalInstant(instant)) {\n            throw new TypeError('bad return from getPossibleInstantsFor');\n        }\n        ArrayPrototypePush$1.call(result, instant);\n    }\n    return result;\n}\nfunction ISOYearString(year) {\n    let yearString;\n    if (year < 1000 || year > 9999) {\n        const sign = year < 0 ? '-' : '+';\n        const yearNumber = MathAbs(year);\n        yearString = sign + `000000${yearNumber}`.slice(-6);\n    }\n    else {\n        yearString = `${year}`;\n    }\n    return yearString;\n}\nfunction ISODateTimePartString(part) {\n    return `00${part}`.slice(-2);\n}\nfunction FormatSecondsStringPart(second, millisecond, microsecond, nanosecond, precision) {\n    if (precision === 'minute')\n        return '';\n    const secs = `:${ISODateTimePartString(second)}`;\n    let fractionNumber = millisecond * 1e6 + microsecond * 1e3 + nanosecond;\n    let fraction;\n    if (precision === 'auto') {\n        if (fractionNumber === 0)\n            return secs;\n        fraction = `${fractionNumber}`.padStart(9, '0');\n        while (fraction[fraction.length - 1] === '0')\n            fraction = fraction.slice(0, -1);\n    }\n    else {\n        if (precision === 0)\n            return secs;\n        fraction = `${fractionNumber}`.padStart(9, '0').slice(0, precision);\n    }\n    return `${secs}.${fraction}`;\n}\nfunction TemporalInstantToString(instant, timeZone, precision) {\n    let outputTimeZone = timeZone;\n    if (outputTimeZone === undefined) {\n        const TemporalTimeZone = GetIntrinsic('%Temporal.TimeZone%');\n        outputTimeZone = new TemporalTimeZone('UTC');\n    }\n    const iso = GetISO8601Calendar();\n    const dateTime = BuiltinTimeZoneGetPlainDateTimeFor(outputTimeZone, instant, iso);\n    const year = ISOYearString(GetSlot(dateTime, ISO_YEAR));\n    const month = ISODateTimePartString(GetSlot(dateTime, ISO_MONTH));\n    const day = ISODateTimePartString(GetSlot(dateTime, ISO_DAY));\n    const hour = ISODateTimePartString(GetSlot(dateTime, ISO_HOUR));\n    const minute = ISODateTimePartString(GetSlot(dateTime, ISO_MINUTE));\n    const seconds = FormatSecondsStringPart(GetSlot(dateTime, ISO_SECOND), GetSlot(dateTime, ISO_MILLISECOND), GetSlot(dateTime, ISO_MICROSECOND), GetSlot(dateTime, ISO_NANOSECOND), precision);\n    let timeZoneString = 'Z';\n    if (timeZone !== undefined) {\n        const offsetNs = GetOffsetNanosecondsFor(outputTimeZone, instant);\n        timeZoneString = FormatISOTimeZoneOffsetString(offsetNs);\n    }\n    return `${year}-${month}-${day}T${hour}:${minute}${seconds}${timeZoneString}`;\n}\nfunction TemporalDurationToString(duration, precision = 'auto', options = undefined) {\n    function formatNumber(num) {\n        if (num <= NumberMaxSafeInteger)\n            return num.toString(10);\n        return jsbi_umd.BigInt(num).toString(10);\n    }\n    const years = GetSlot(duration, YEARS);\n    const months = GetSlot(duration, MONTHS);\n    const weeks = GetSlot(duration, WEEKS);\n    const days = GetSlot(duration, DAYS);\n    const hours = GetSlot(duration, HOURS);\n    const minutes = GetSlot(duration, MINUTES);\n    let seconds = GetSlot(duration, SECONDS);\n    let ms = GetSlot(duration, MILLISECONDS);\n    let s = GetSlot(duration, MICROSECONDS);\n    let ns = GetSlot(duration, NANOSECONDS);\n    const sign = DurationSign(years, months, weeks, days, hours, minutes, seconds, ms, s, ns);\n    if (options) {\n        const { unit, increment, roundingMode } = options;\n        ({\n            seconds,\n            milliseconds: ms,\n            microseconds: s,\n            nanoseconds: ns\n        } = RoundDuration(0, 0, 0, 0, 0, 0, seconds, ms, s, ns, increment, unit, roundingMode));\n    }\n    const dateParts = [];\n    if (years)\n        dateParts.push(`${formatNumber(MathAbs(years))}Y`);\n    if (months)\n        dateParts.push(`${formatNumber(MathAbs(months))}M`);\n    if (weeks)\n        dateParts.push(`${formatNumber(MathAbs(weeks))}W`);\n    if (days)\n        dateParts.push(`${formatNumber(MathAbs(days))}D`);\n    const timeParts = [];\n    if (hours)\n        timeParts.push(`${formatNumber(MathAbs(hours))}H`);\n    if (minutes)\n        timeParts.push(`${formatNumber(MathAbs(minutes))}M`);\n    const secondParts = [];\n    let total = TotalDurationNanoseconds(0, 0, 0, seconds, ms, s, ns, 0);\n    let nsBigInt, sBigInt, msBigInt, secondsBigInt;\n    ({ quotient: total, remainder: nsBigInt } = divmod(total, THOUSAND));\n    ({ quotient: total, remainder: sBigInt } = divmod(total, THOUSAND));\n    ({ quotient: secondsBigInt, remainder: msBigInt } = divmod(total, THOUSAND));\n    const fraction = MathAbs(jsbi_umd.toNumber(msBigInt)) * 1e6 + MathAbs(jsbi_umd.toNumber(sBigInt)) * 1e3 + MathAbs(jsbi_umd.toNumber(nsBigInt));\n    let decimalPart;\n    if (precision === 'auto') {\n        if (fraction !== 0) {\n            decimalPart = `${fraction}`.padStart(9, '0');\n            while (decimalPart[decimalPart.length - 1] === '0') {\n                decimalPart = decimalPart.slice(0, -1);\n            }\n        }\n    }\n    else if (precision !== 0) {\n        decimalPart = `${fraction}`.padStart(9, '0').slice(0, precision);\n    }\n    if (decimalPart)\n        secondParts.unshift('.', decimalPart);\n    if (!jsbi_umd.equal(secondsBigInt, ZERO) || secondParts.length || precision !== 'auto') {\n        secondParts.unshift(abs(secondsBigInt).toString());\n    }\n    if (secondParts.length)\n        timeParts.push(`${secondParts.join('')}S`);\n    if (timeParts.length)\n        timeParts.unshift('T');\n    if (!dateParts.length && !timeParts.length)\n        return 'PT0S';\n    return `${sign < 0 ? '-' : ''}P${dateParts.join('')}${timeParts.join('')}`;\n}\nfunction TemporalDateToString(date, showCalendar = 'auto') {\n    const year = ISOYearString(GetSlot(date, ISO_YEAR));\n    const month = ISODateTimePartString(GetSlot(date, ISO_MONTH));\n    const day = ISODateTimePartString(GetSlot(date, ISO_DAY));\n    const calendarID = ToString(GetSlot(date, CALENDAR));\n    const calendar = FormatCalendarAnnotation(calendarID, showCalendar);\n    return `${year}-${month}-${day}${calendar}`;\n}\nfunction TemporalDateTimeToString(dateTime, precision, showCalendar = 'auto', options = undefined) {\n    let year = GetSlot(dateTime, ISO_YEAR);\n    let month = GetSlot(dateTime, ISO_MONTH);\n    let day = GetSlot(dateTime, ISO_DAY);\n    let hour = GetSlot(dateTime, ISO_HOUR);\n    let minute = GetSlot(dateTime, ISO_MINUTE);\n    let second = GetSlot(dateTime, ISO_SECOND);\n    let millisecond = GetSlot(dateTime, ISO_MILLISECOND);\n    let microsecond = GetSlot(dateTime, ISO_MICROSECOND);\n    let nanosecond = GetSlot(dateTime, ISO_NANOSECOND);\n    if (options) {\n        const { unit, increment, roundingMode } = options;\n        ({ year, month, day, hour, minute, second, millisecond, microsecond, nanosecond } = RoundISODateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, increment, unit, roundingMode));\n    }\n    const yearString = ISOYearString(year);\n    const monthString = ISODateTimePartString(month);\n    const dayString = ISODateTimePartString(day);\n    const hourString = ISODateTimePartString(hour);\n    const minuteString = ISODateTimePartString(minute);\n    const secondsString = FormatSecondsStringPart(second, millisecond, microsecond, nanosecond, precision);\n    const calendarID = ToString(GetSlot(dateTime, CALENDAR));\n    const calendar = FormatCalendarAnnotation(calendarID, showCalendar);\n    return `${yearString}-${monthString}-${dayString}T${hourString}:${minuteString}${secondsString}${calendar}`;\n}\nfunction TemporalMonthDayToString(monthDay, showCalendar = 'auto') {\n    const month = ISODateTimePartString(GetSlot(monthDay, ISO_MONTH));\n    const day = ISODateTimePartString(GetSlot(monthDay, ISO_DAY));\n    let resultString = `${month}-${day}`;\n    const calendar = GetSlot(monthDay, CALENDAR);\n    const calendarID = ToString(calendar);\n    if (calendarID !== 'iso8601') {\n        const year = ISOYearString(GetSlot(monthDay, ISO_YEAR));\n        resultString = `${year}-${resultString}`;\n    }\n    const calendarString = FormatCalendarAnnotation(calendarID, showCalendar);\n    if (calendarString)\n        resultString += calendarString;\n    return resultString;\n}\nfunction TemporalYearMonthToString(yearMonth, showCalendar = 'auto') {\n    const year = ISOYearString(GetSlot(yearMonth, ISO_YEAR));\n    const month = ISODateTimePartString(GetSlot(yearMonth, ISO_MONTH));\n    let resultString = `${year}-${month}`;\n    const calendar = GetSlot(yearMonth, CALENDAR);\n    const calendarID = ToString(calendar);\n    if (calendarID !== 'iso8601') {\n        const day = ISODateTimePartString(GetSlot(yearMonth, ISO_DAY));\n        resultString += `-${day}`;\n    }\n    const calendarString = FormatCalendarAnnotation(calendarID, showCalendar);\n    if (calendarString)\n        resultString += calendarString;\n    return resultString;\n}\nfunction TemporalZonedDateTimeToString(zdt, precision, showCalendar = 'auto', showTimeZone = 'auto', showOffset = 'auto', options = undefined) {\n    let instant = GetSlot(zdt, INSTANT);\n    if (options) {\n        const { unit, increment, roundingMode } = options;\n        const ns = RoundInstant(GetSlot(zdt, EPOCHNANOSECONDS), increment, unit, roundingMode);\n        const TemporalInstant = GetIntrinsic('%Temporal.Instant%');\n        instant = new TemporalInstant(ns);\n    }\n    const tz = GetSlot(zdt, TIME_ZONE);\n    const iso = GetISO8601Calendar();\n    const dateTime = BuiltinTimeZoneGetPlainDateTimeFor(tz, instant, iso);\n    const year = ISOYearString(GetSlot(dateTime, ISO_YEAR));\n    const month = ISODateTimePartString(GetSlot(dateTime, ISO_MONTH));\n    const day = ISODateTimePartString(GetSlot(dateTime, ISO_DAY));\n    const hour = ISODateTimePartString(GetSlot(dateTime, ISO_HOUR));\n    const minute = ISODateTimePartString(GetSlot(dateTime, ISO_MINUTE));\n    const seconds = FormatSecondsStringPart(GetSlot(dateTime, ISO_SECOND), GetSlot(dateTime, ISO_MILLISECOND), GetSlot(dateTime, ISO_MICROSECOND), GetSlot(dateTime, ISO_NANOSECOND), precision);\n    let result = `${year}-${month}-${day}T${hour}:${minute}${seconds}`;\n    if (showOffset !== 'never') {\n        const offsetNs = GetOffsetNanosecondsFor(tz, instant);\n        result += FormatISOTimeZoneOffsetString(offsetNs);\n    }\n    if (showTimeZone !== 'never')\n        result += `[${tz}]`;\n    const calendarID = ToString(GetSlot(zdt, CALENDAR));\n    result += FormatCalendarAnnotation(calendarID, showCalendar);\n    return result;\n}\nfunction TestTimeZoneOffsetString(string) {\n    return OFFSET.test(StringCtor(string));\n}\nfunction ParseTimeZoneOffsetString(string) {\n    const match = OFFSET.exec(StringCtor(string));\n    if (!match) {\n        throw new RangeError(`invalid time zone offset: ${string}`);\n    }\n    const sign = match[1] === '-' || match[1] === '\\u2212' ? -1 : +1;\n    const hours = +match[2];\n    const minutes = +(match[3] || 0);\n    const seconds = +(match[4] || 0);\n    const nanoseconds = +((match[5] || 0) + '000000000').slice(0, 9);\n    return sign * (((hours * 60 + minutes) * 60 + seconds) * 1e9 + nanoseconds);\n}\nfunction GetCanonicalTimeZoneIdentifier(timeZoneIdentifier) {\n    if (TestTimeZoneOffsetString(timeZoneIdentifier)) {\n        const offsetNs = ParseTimeZoneOffsetString(timeZoneIdentifier);\n        return FormatTimeZoneOffsetString(offsetNs);\n    }\n    const formatter = getIntlDateTimeFormatEnUsForTimeZone(StringCtor(timeZoneIdentifier));\n    return formatter.resolvedOptions().timeZone;\n}\nfunction GetIANATimeZoneOffsetNanoseconds(epochNanoseconds, id) {\n    const { year, month, day, hour, minute, second, millisecond, microsecond, nanosecond } = GetIANATimeZoneDateTimeParts(epochNanoseconds, id);\n    const utc = GetEpochFromISOParts(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond);\n    if (utc === null)\n        throw new RangeError('Date outside of supported range');\n    return jsbi_umd.toNumber(jsbi_umd.subtract(utc, epochNanoseconds));\n}\nfunction FormatTimeZoneOffsetString(offsetNanosecondsParam) {\n    const sign = offsetNanosecondsParam < 0 ? '-' : '+';\n    const offsetNanoseconds = MathAbs(offsetNanosecondsParam);\n    const nanoseconds = offsetNanoseconds % 1e9;\n    const seconds = MathFloor(offsetNanoseconds / 1e9) % 60;\n    const minutes = MathFloor(offsetNanoseconds / 60e9) % 60;\n    const hours = MathFloor(offsetNanoseconds / 3600e9);\n    const hourString = ISODateTimePartString(hours);\n    const minuteString = ISODateTimePartString(minutes);\n    const secondString = ISODateTimePartString(seconds);\n    let post = '';\n    if (nanoseconds) {\n        let fraction = `${nanoseconds}`.padStart(9, '0');\n        while (fraction[fraction.length - 1] === '0')\n            fraction = fraction.slice(0, -1);\n        post = `:${secondString}.${fraction}`;\n    }\n    else if (seconds) {\n        post = `:${secondString}`;\n    }\n    return `${sign}${hourString}:${minuteString}${post}`;\n}\nfunction FormatISOTimeZoneOffsetString(offsetNanosecondsParam) {\n    let offsetNanoseconds = jsbi_umd.toNumber(RoundNumberToIncrement(jsbi_umd.BigInt(offsetNanosecondsParam), 60e9, 'halfExpand'));\n    const sign = offsetNanoseconds < 0 ? '-' : '+';\n    offsetNanoseconds = MathAbs(offsetNanoseconds);\n    const minutes = (offsetNanoseconds / 60e9) % 60;\n    const hours = MathFloor(offsetNanoseconds / 3600e9);\n    const hourString = ISODateTimePartString(hours);\n    const minuteString = ISODateTimePartString(minutes);\n    return `${sign}${hourString}:${minuteString}`;\n}\nfunction GetEpochFromISOParts(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond) {\n    // Note: Date.UTC() interprets one and two-digit years as being in the\n    // 20th century, so don't use it\n    const legacyDate = new Date();\n    legacyDate.setUTCHours(hour, minute, second, millisecond);\n    legacyDate.setUTCFullYear(year, month - 1, day);\n    const ms = legacyDate.getTime();\n    if (NumberIsNaN(ms))\n        return null;\n    let ns = jsbi_umd.multiply(jsbi_umd.BigInt(ms), MILLION);\n    ns = jsbi_umd.add(ns, jsbi_umd.multiply(jsbi_umd.BigInt(microsecond), THOUSAND));\n    ns = jsbi_umd.add(ns, jsbi_umd.BigInt(nanosecond));\n    if (jsbi_umd.lessThan(ns, NS_MIN) || jsbi_umd.greaterThan(ns, NS_MAX))\n        return null;\n    return ns;\n}\nfunction GetISOPartsFromEpoch(epochNanoseconds) {\n    const { quotient, remainder } = divmod(epochNanoseconds, MILLION);\n    let epochMilliseconds = jsbi_umd.toNumber(quotient);\n    let nanos = jsbi_umd.toNumber(remainder);\n    if (nanos < 0) {\n        nanos += 1e6;\n        epochMilliseconds -= 1;\n    }\n    const microsecond = MathFloor(nanos / 1e3) % 1e3;\n    const nanosecond = nanos % 1e3;\n    const item = new Date(epochMilliseconds);\n    const year = item.getUTCFullYear();\n    const month = item.getUTCMonth() + 1;\n    const day = item.getUTCDate();\n    const hour = item.getUTCHours();\n    const minute = item.getUTCMinutes();\n    const second = item.getUTCSeconds();\n    const millisecond = item.getUTCMilliseconds();\n    return { epochMilliseconds, year, month, day, hour, minute, second, millisecond, microsecond, nanosecond };\n}\n// ts-prune-ignore-next TODO: remove this after tests are converted to TS\nfunction GetIANATimeZoneDateTimeParts(epochNanoseconds, id) {\n    const { epochMilliseconds, millisecond, microsecond, nanosecond } = GetISOPartsFromEpoch(epochNanoseconds);\n    const { year, month, day, hour, minute, second } = GetFormatterParts(id, epochMilliseconds);\n    return BalanceISODateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond);\n}\nfunction maxJSBI(one, two) {\n    return jsbi_umd.lessThan(one, two) ? two : one;\n}\n/**\n * Our best guess at how far in advance new rules will be put into the TZDB for\n * future offset transitions. We'll pick 10 years but can always revise it if\n * we find that countries are being unusually proactive in their announcing\n * of offset changes.\n */\nfunction afterLatestPossibleTzdbRuleChange() {\n    return jsbi_umd.add(SystemUTCEpochNanoSeconds(), ABOUT_TEN_YEARS_NANOS);\n}\nfunction GetIANATimeZoneNextTransition(epochNanoseconds, id) {\n    // Decide how far in the future after `epochNanoseconds` we'll look for an\n    // offset change. There are two cases:\n    // 1. If it's a past date (or a date in the near future) then it's possible\n    //    that the time zone may have newly added DST in the next few years. So\n    //    we'll have to look from the provided time until a few years after the\n    //    current system time. (Changes to DST policy are usually announced a few\n    //    years in the future.) Note that the first DST anywhere started in 1847,\n    //    so we'll start checks in 1847 instead of wasting cycles on years where\n    //    there will never be transitions.\n    // 2. If it's a future date beyond the next few years, then we'll just assume\n    //    that the latest DST policy in TZDB will still be in effect.  In this\n    //    case, we only need to look one year in the future to see if there are\n    //    any DST transitions.  We actually only need to look 9-10 months because\n    //    DST has two transitions per year, but we'll use a year just to be safe.\n    const oneYearLater = jsbi_umd.add(epochNanoseconds, ABOUT_ONE_YEAR_NANOS);\n    const uppercap = maxJSBI(afterLatestPossibleTzdbRuleChange(), oneYearLater);\n    // The first transition (in any timezone) recorded in the TZDB was in 1847, so\n    // start there if an earlier date is supplied.\n    let leftNanos = maxJSBI(BEFORE_FIRST_OFFSET_TRANSITION, epochNanoseconds);\n    const leftOffsetNs = GetIANATimeZoneOffsetNanoseconds(leftNanos, id);\n    let rightNanos = leftNanos;\n    let rightOffsetNs = leftOffsetNs;\n    while (leftOffsetNs === rightOffsetNs && jsbi_umd.lessThan(jsbi_umd.BigInt(leftNanos), uppercap)) {\n        rightNanos = jsbi_umd.add(leftNanos, TWO_WEEKS_NANOS);\n        rightOffsetNs = GetIANATimeZoneOffsetNanoseconds(rightNanos, id);\n        if (leftOffsetNs === rightOffsetNs) {\n            leftNanos = rightNanos;\n        }\n    }\n    if (leftOffsetNs === rightOffsetNs)\n        return null;\n    const result = bisect((epochNs) => GetIANATimeZoneOffsetNanoseconds(epochNs, id), leftNanos, rightNanos, leftOffsetNs, rightOffsetNs);\n    return result;\n}\nfunction GetIANATimeZonePreviousTransition(epochNanoseconds, id) {\n    // If a time zone uses DST (at the time of `epochNanoseconds`), then we only\n    // have to look back one year to find a transition. But if it doesn't use DST,\n    // then we need to look all the way back to 1847 (the earliest rule in the\n    // TZDB) to see if it had other offset transitions in the past. Looping back\n    // from a far-future date to 1847 is very slow (minutes of 100% CPU!), and is\n    // also unnecessary because DST rules aren't put into the TZDB more than a few\n    // years in the future because the political changes in time zones happen with\n    // only a few years' warning. Therefore, if a far-future date is provided,\n    // then we'll run the check in two parts:\n    // 1. First, we'll look back for up to one year to see if the latest TZDB\n    //    rules have DST.\n    // 2. If not, then we'll \"fast-reverse\" back to a few years later than the\n    //    current system time, and then look back to 1847. This reduces the\n    //    worst-case loop from 273K years to 175 years, for a ~1500x improvement\n    //    in worst-case perf.\n    const afterLatestRule = afterLatestPossibleTzdbRuleChange();\n    const isFarFuture = jsbi_umd.greaterThan(epochNanoseconds, afterLatestRule);\n    const lowercap = isFarFuture ? jsbi_umd.subtract(epochNanoseconds, ABOUT_ONE_YEAR_NANOS) : BEFORE_FIRST_OFFSET_TRANSITION;\n    let rightNanos = jsbi_umd.subtract(epochNanoseconds, ONE);\n    const rightOffsetNs = GetIANATimeZoneOffsetNanoseconds(rightNanos, id);\n    let leftNanos = rightNanos;\n    let leftOffsetNs = rightOffsetNs;\n    while (rightOffsetNs === leftOffsetNs && jsbi_umd.greaterThan(rightNanos, lowercap)) {\n        leftNanos = jsbi_umd.subtract(rightNanos, TWO_WEEKS_NANOS);\n        leftOffsetNs = GetIANATimeZoneOffsetNanoseconds(leftNanos, id);\n        if (rightOffsetNs === leftOffsetNs) {\n            rightNanos = leftNanos;\n        }\n    }\n    if (rightOffsetNs === leftOffsetNs) {\n        if (isFarFuture) {\n            // There was no DST after looking back one year, which means that the most\n            // recent TZDB rules don't have any recurring transitions. To check for\n            // transitions in older rules, back up to a few years after the current\n            // date and then look all the way back to 1847. Note that we move back one\n            // day from the latest possible rule so that when the recursion runs it\n            // won't consider the new time to be \"far future\" because the system clock\n            // has advanced in the meantime.\n            const newTimeToCheck = jsbi_umd.subtract(afterLatestRule, DAY_NANOS);\n            return GetIANATimeZonePreviousTransition(newTimeToCheck, id);\n        }\n        return null;\n    }\n    const result = bisect((epochNs) => GetIANATimeZoneOffsetNanoseconds(epochNs, id), leftNanos, rightNanos, leftOffsetNs, rightOffsetNs);\n    return result;\n}\n// ts-prune-ignore-next TODO: remove this after tests are converted to TS\nfunction parseFromEnUsFormat(datetime) {\n    const parts = datetime.split(/[^\\w]+/);\n    if (parts.length !== 7) {\n        throw new RangeError(`expected 7 parts in \"${datetime}`);\n    }\n    const month = +parts[0];\n    const day = +parts[1];\n    let year = +parts[2];\n    const era = parts[3].toUpperCase();\n    if (era === 'B' || era === 'BC') {\n        year = -year + 1;\n    }\n    else if (era !== 'A' && era !== 'AD') {\n        throw new RangeError(`Unknown era ${era} in \"${datetime}`);\n    }\n    let hour = +parts[4];\n    if (hour === 24) {\n        // bugs.chromium.org/p/chromium/issues/detail?id=1045791\n        hour = 0;\n    }\n    const minute = +parts[5];\n    const second = +parts[6];\n    if (!NumberIsFinite(year) ||\n        !NumberIsFinite(month) ||\n        !NumberIsFinite(day) ||\n        !NumberIsFinite(hour) ||\n        !NumberIsFinite(minute) ||\n        !NumberIsFinite(second)) {\n        throw new RangeError(`Invalid number in \"${datetime}`);\n    }\n    return { year, month, day, hour, minute, second };\n}\n// ts-prune-ignore-next TODO: remove this after tests are converted to TS\nfunction GetFormatterParts(timeZone, epochMilliseconds) {\n    const formatter = getIntlDateTimeFormatEnUsForTimeZone(timeZone);\n    // Using `format` instead of `formatToParts` for compatibility with older clients\n    const datetime = formatter.format(new Date(epochMilliseconds));\n    return parseFromEnUsFormat(datetime);\n}\nfunction GetIANATimeZoneEpochValue(id, year, month, day, hour, minute, second, millisecond, microsecond, nanosecond) {\n    const ns = GetEpochFromISOParts(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond);\n    if (ns === null)\n        throw new RangeError('DateTime outside of supported range');\n    let nsEarlier = jsbi_umd.subtract(ns, DAY_NANOS);\n    if (jsbi_umd.lessThan(nsEarlier, NS_MIN))\n        nsEarlier = ns;\n    let nsLater = jsbi_umd.add(ns, DAY_NANOS);\n    if (jsbi_umd.greaterThan(nsLater, NS_MAX))\n        nsLater = ns;\n    const earliest = GetIANATimeZoneOffsetNanoseconds(nsEarlier, id);\n    const latest = GetIANATimeZoneOffsetNanoseconds(nsLater, id);\n    const found = earliest === latest ? [earliest] : [earliest, latest];\n    return found\n        .map((offsetNanoseconds) => {\n        const epochNanoseconds = jsbi_umd.subtract(ns, jsbi_umd.BigInt(offsetNanoseconds));\n        const parts = GetIANATimeZoneDateTimeParts(epochNanoseconds, id);\n        if (year !== parts.year ||\n            month !== parts.month ||\n            day !== parts.day ||\n            hour !== parts.hour ||\n            minute !== parts.minute ||\n            second !== parts.second ||\n            millisecond !== parts.millisecond ||\n            microsecond !== parts.microsecond ||\n            nanosecond !== parts.nanosecond) {\n            return undefined;\n        }\n        return epochNanoseconds;\n    })\n        .filter((x) => x !== undefined);\n}\nfunction LeapYear(year) {\n    if (undefined === year)\n        return false;\n    const isDiv4 = year % 4 === 0;\n    const isDiv100 = year % 100 === 0;\n    const isDiv400 = year % 400 === 0;\n    return isDiv4 && (!isDiv100 || isDiv400);\n}\nfunction ISODaysInMonth(year, month) {\n    const DoM = {\n        standard: [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],\n        leapyear: [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n    };\n    return DoM[LeapYear(year) ? 'leapyear' : 'standard'][month - 1];\n}\nfunction DayOfWeek(year, month, day) {\n    const m = month + (month < 3 ? 10 : -2);\n    const Y = year - (month < 3 ? 1 : 0);\n    const c = MathFloor(Y / 100);\n    const y = Y - c * 100;\n    const d = day;\n    const pD = d;\n    const pM = MathFloor(2.6 * m - 0.2);\n    const pY = y + MathFloor(y / 4);\n    const pC = MathFloor(c / 4) - 2 * c;\n    const dow = (pD + pM + pY + pC) % 7;\n    return dow + (dow <= 0 ? 7 : 0);\n}\nfunction DayOfYear(year, month, day) {\n    let days = day;\n    for (let m = month - 1; m > 0; m--) {\n        days += ISODaysInMonth(year, m);\n    }\n    return days;\n}\nfunction WeekOfYear(year, month, day) {\n    const doy = DayOfYear(year, month, day);\n    const dow = DayOfWeek(year, month, day) || 7;\n    const doj = DayOfWeek(year, 1, 1);\n    const week = MathFloor((doy - dow + 10) / 7);\n    if (week < 1) {\n        if (doj === 5 || (doj === 6 && LeapYear(year - 1))) {\n            return 53;\n        }\n        else {\n            return 52;\n        }\n    }\n    if (week === 53) {\n        if ((LeapYear(year) ? 366 : 365) - doy < 4 - dow) {\n            return 1;\n        }\n    }\n    return week;\n}\nfunction DurationSign(y, mon, w, d, h, min, s, ms, s, ns) {\n    for (const prop of [y, mon, w, d, h, min, s, ms, s, ns]) {\n        if (prop !== 0)\n            return prop < 0 ? -1 : 1;\n    }\n    return 0;\n}\nfunction BalanceISOYearMonth(yearParam, monthParam) {\n    let year = yearParam;\n    let month = monthParam;\n    if (!NumberIsFinite(year) || !NumberIsFinite(month))\n        throw new RangeError('infinity is out of range');\n    month -= 1;\n    year += MathFloor(month / 12);\n    month %= 12;\n    if (month < 0)\n        month += 12;\n    month += 1;\n    return { year, month };\n}\nfunction BalanceISODate(yearParam, monthParam, dayParam) {\n    let year = yearParam;\n    let month = monthParam;\n    let day = dayParam;\n    if (!NumberIsFinite(day))\n        throw new RangeError('infinity is out of range');\n    ({ year, month } = BalanceISOYearMonth(year, month));\n    let daysInYear = 0;\n    let testYear = month > 2 ? year : year - 1;\n    while (((daysInYear = LeapYear(testYear) ? 366 : 365), day < -daysInYear)) {\n        year -= 1;\n        testYear -= 1;\n        day += daysInYear;\n    }\n    testYear += 1;\n    while (((daysInYear = LeapYear(testYear) ? 366 : 365), day > daysInYear)) {\n        year += 1;\n        testYear += 1;\n        day -= daysInYear;\n    }\n    while (day < 1) {\n        ({ year, month } = BalanceISOYearMonth(year, month - 1));\n        day += ISODaysInMonth(year, month);\n    }\n    while (day > ISODaysInMonth(year, month)) {\n        day -= ISODaysInMonth(year, month);\n        ({ year, month } = BalanceISOYearMonth(year, month + 1));\n    }\n    return { year, month, day };\n}\nfunction BalanceISODateTime(yearParam, monthParam, dayParam, hourParam, minuteParam, secondParam, millisecondParam, microsecondParam, nanosecondParam) {\n    const { deltaDays, hour, minute, second, millisecond, microsecond, nanosecond } = BalanceTime(hourParam, minuteParam, secondParam, millisecondParam, microsecondParam, nanosecondParam);\n    const { year, month, day } = BalanceISODate(yearParam, monthParam, dayParam + deltaDays);\n    return { year, month, day, hour, minute, second, millisecond, microsecond, nanosecond };\n}\nfunction BalanceTime(hourParam, minuteParam, secondParam, millisecondParam, microsecondParam, nanosecondParam) {\n    let hour = hourParam;\n    let minute = minuteParam;\n    let second = secondParam;\n    let millisecond = millisecondParam;\n    let microsecond = microsecondParam;\n    let nanosecond = nanosecondParam;\n    if (!NumberIsFinite(hour) ||\n        !NumberIsFinite(minute) ||\n        !NumberIsFinite(second) ||\n        !NumberIsFinite(millisecond) ||\n        !NumberIsFinite(microsecond) ||\n        !NumberIsFinite(nanosecond)) {\n        throw new RangeError('infinity is out of range');\n    }\n    microsecond += MathFloor(nanosecond / 1000);\n    nanosecond = NonNegativeModulo(nanosecond, 1000);\n    millisecond += MathFloor(microsecond / 1000);\n    microsecond = NonNegativeModulo(microsecond, 1000);\n    second += MathFloor(millisecond / 1000);\n    millisecond = NonNegativeModulo(millisecond, 1000);\n    minute += MathFloor(second / 60);\n    second = NonNegativeModulo(second, 60);\n    hour += MathFloor(minute / 60);\n    minute = NonNegativeModulo(minute, 60);\n    const deltaDays = MathFloor(hour / 24);\n    hour = NonNegativeModulo(hour, 24);\n    return { deltaDays, hour, minute, second, millisecond, microsecond, nanosecond };\n}\nfunction TotalDurationNanoseconds(daysParam, hoursParam, minutesParam, secondsParam, millisecondsParam, microsecondsParam, nanosecondsParam, offsetShift) {\n    const days = jsbi_umd.BigInt(daysParam);\n    let nanoseconds = jsbi_umd.BigInt(nanosecondsParam);\n    if (daysParam !== 0)\n        nanoseconds = jsbi_umd.subtract(jsbi_umd.BigInt(nanosecondsParam), jsbi_umd.BigInt(offsetShift));\n    const hours = jsbi_umd.add(jsbi_umd.BigInt(hoursParam), jsbi_umd.multiply(days, jsbi_umd.BigInt(24)));\n    const minutes = jsbi_umd.add(jsbi_umd.BigInt(minutesParam), jsbi_umd.multiply(hours, SIXTY));\n    const seconds = jsbi_umd.add(jsbi_umd.BigInt(secondsParam), jsbi_umd.multiply(minutes, SIXTY));\n    const milliseconds = jsbi_umd.add(jsbi_umd.BigInt(millisecondsParam), jsbi_umd.multiply(seconds, THOUSAND));\n    const microseconds = jsbi_umd.add(jsbi_umd.BigInt(microsecondsParam), jsbi_umd.multiply(milliseconds, THOUSAND));\n    return jsbi_umd.add(jsbi_umd.BigInt(nanoseconds), jsbi_umd.multiply(microseconds, THOUSAND));\n}\nfunction NanosecondsToDays(nanosecondsParam, relativeTo) {\n    const TemporalInstant = GetIntrinsic('%Temporal.Instant%');\n    const sign = MathSign(jsbi_umd.toNumber(nanosecondsParam));\n    let nanoseconds = jsbi_umd.BigInt(nanosecondsParam);\n    let dayLengthNs = 86400e9;\n    if (sign === 0)\n        return { days: 0, nanoseconds: ZERO, dayLengthNs };\n    if (!IsTemporalZonedDateTime(relativeTo)) {\n        let days;\n        ({ quotient: days, remainder: nanoseconds } = divmod(nanoseconds, jsbi_umd.BigInt(dayLengthNs)));\n        return { days: jsbi_umd.toNumber(days), nanoseconds, dayLengthNs };\n    }\n    const startNs = GetSlot(relativeTo, EPOCHNANOSECONDS);\n    const start = GetSlot(relativeTo, INSTANT);\n    const endNs = jsbi_umd.add(startNs, nanoseconds);\n    const end = new TemporalInstant(endNs);\n    const timeZone = GetSlot(relativeTo, TIME_ZONE);\n    const calendar = GetSlot(relativeTo, CALENDAR);\n    // Find the difference in days only.\n    const dtStart = BuiltinTimeZoneGetPlainDateTimeFor(timeZone, start, calendar);\n    const dtEnd = BuiltinTimeZoneGetPlainDateTimeFor(timeZone, end, calendar);\n    let { days } = DifferenceISODateTime(GetSlot(dtStart, ISO_YEAR), GetSlot(dtStart, ISO_MONTH), GetSlot(dtStart, ISO_DAY), GetSlot(dtStart, ISO_HOUR), GetSlot(dtStart, ISO_MINUTE), GetSlot(dtStart, ISO_SECOND), GetSlot(dtStart, ISO_MILLISECOND), GetSlot(dtStart, ISO_MICROSECOND), GetSlot(dtStart, ISO_NANOSECOND), GetSlot(dtEnd, ISO_YEAR), GetSlot(dtEnd, ISO_MONTH), GetSlot(dtEnd, ISO_DAY), GetSlot(dtEnd, ISO_HOUR), GetSlot(dtEnd, ISO_MINUTE), GetSlot(dtEnd, ISO_SECOND), GetSlot(dtEnd, ISO_MILLISECOND), GetSlot(dtEnd, ISO_MICROSECOND), GetSlot(dtEnd, ISO_NANOSECOND), calendar, 'day');\n    let intermediateNs = AddZonedDateTime(start, timeZone, calendar, 0, 0, 0, days, 0, 0, 0, 0, 0, 0);\n    // may disambiguate\n    // If clock time after addition was in the middle of a skipped period, the\n    // endpoint was disambiguated to a later clock time. So it's possible that\n    // the resulting disambiguated result is later than endNs. If so, then back\n    // up one day and try again. Repeat if necessary (some transitions are\n    // > 24 hours) until either there's zero days left or the date duration is\n    // back inside the period where it belongs. Note that this case only can\n    // happen for positive durations because the only direction that\n    // `disambiguation: 'compatible'` can change clock time is forwards.\n    if (sign === 1) {\n        while (days > 0 && jsbi_umd.greaterThan(intermediateNs, endNs)) {\n            --days;\n            intermediateNs = AddZonedDateTime(start, timeZone, calendar, 0, 0, 0, days, 0, 0, 0, 0, 0, 0);\n            // may do disambiguation\n        }\n    }\n    nanoseconds = jsbi_umd.subtract(endNs, intermediateNs);\n    let isOverflow = false;\n    let relativeInstant = new TemporalInstant(intermediateNs);\n    do {\n        // calculate length of the next day (day that contains the time remainder)\n        const oneDayFartherNs = AddZonedDateTime(relativeInstant, timeZone, calendar, 0, 0, 0, sign, 0, 0, 0, 0, 0, 0);\n        const relativeNs = GetSlot(relativeInstant, EPOCHNANOSECONDS);\n        dayLengthNs = jsbi_umd.toNumber(jsbi_umd.subtract(oneDayFartherNs, relativeNs));\n        isOverflow = jsbi_umd.greaterThan(jsbi_umd.multiply(jsbi_umd.subtract(nanoseconds, jsbi_umd.BigInt(dayLengthNs)), jsbi_umd.BigInt(sign)), ZERO);\n        if (isOverflow) {\n            nanoseconds = jsbi_umd.subtract(nanoseconds, jsbi_umd.BigInt(dayLengthNs));\n            relativeInstant = new TemporalInstant(oneDayFartherNs);\n            days += sign;\n        }\n    } while (isOverflow);\n    return { days, nanoseconds, dayLengthNs: MathAbs(dayLengthNs) };\n}\nfunction BalanceDuration(daysParam, hoursParam, minutesParam, secondsParam, millisecondsParam, microsecondsParam, nanosecondsParam, largestUnit, relativeTo = undefined) {\n    let days = daysParam;\n    let nanosecondsBigInt, microsecondsBigInt, millisecondsBigInt, secondsBigInt, minutesBigInt, hoursBigInt;\n    if (IsTemporalZonedDateTime(relativeTo)) {\n        const endNs = AddZonedDateTime(GetSlot(relativeTo, INSTANT), GetSlot(relativeTo, TIME_ZONE), GetSlot(relativeTo, CALENDAR), 0, 0, 0, days, hoursParam, minutesParam, secondsParam, millisecondsParam, microsecondsParam, nanosecondsParam);\n        const startNs = GetSlot(relativeTo, EPOCHNANOSECONDS);\n        nanosecondsBigInt = jsbi_umd.subtract(endNs, startNs);\n    }\n    else {\n        nanosecondsBigInt = TotalDurationNanoseconds(days, hoursParam, minutesParam, secondsParam, millisecondsParam, microsecondsParam, nanosecondsParam, 0);\n    }\n    if (largestUnit === 'year' || largestUnit === 'month' || largestUnit === 'week' || largestUnit === 'day') {\n        ({ days, nanoseconds: nanosecondsBigInt } = NanosecondsToDays(nanosecondsBigInt, relativeTo));\n    }\n    else {\n        days = 0;\n    }\n    const sign = jsbi_umd.lessThan(nanosecondsBigInt, ZERO) ? -1 : 1;\n    nanosecondsBigInt = abs(nanosecondsBigInt);\n    microsecondsBigInt = millisecondsBigInt = secondsBigInt = minutesBigInt = hoursBigInt = ZERO;\n    switch (largestUnit) {\n        case 'year':\n        case 'month':\n        case 'week':\n        case 'day':\n        case 'hour':\n            ({ quotient: microsecondsBigInt, remainder: nanosecondsBigInt } = divmod(nanosecondsBigInt, THOUSAND));\n            ({ quotient: millisecondsBigInt, remainder: microsecondsBigInt } = divmod(microsecondsBigInt, THOUSAND));\n            ({ quotient: secondsBigInt, remainder: millisecondsBigInt } = divmod(millisecondsBigInt, THOUSAND));\n            ({ quotient: minutesBigInt, remainder: secondsBigInt } = divmod(secondsBigInt, SIXTY));\n            ({ quotient: hoursBigInt, remainder: minutesBigInt } = divmod(minutesBigInt, SIXTY));\n            break;\n        case 'minute':\n            ({ quotient: microsecondsBigInt, remainder: nanosecondsBigInt } = divmod(nanosecondsBigInt, THOUSAND));\n            ({ quotient: millisecondsBigInt, remainder: microsecondsBigInt } = divmod(microsecondsBigInt, THOUSAND));\n            ({ quotient: secondsBigInt, remainder: millisecondsBigInt } = divmod(millisecondsBigInt, THOUSAND));\n            ({ quotient: minutesBigInt, remainder: secondsBigInt } = divmod(secondsBigInt, SIXTY));\n            break;\n        case 'second':\n            ({ quotient: microsecondsBigInt, remainder: nanosecondsBigInt } = divmod(nanosecondsBigInt, THOUSAND));\n            ({ quotient: millisecondsBigInt, remainder: microsecondsBigInt } = divmod(microsecondsBigInt, THOUSAND));\n            ({ quotient: secondsBigInt, remainder: millisecondsBigInt } = divmod(millisecondsBigInt, THOUSAND));\n            break;\n        case 'millisecond':\n            ({ quotient: microsecondsBigInt, remainder: nanosecondsBigInt } = divmod(nanosecondsBigInt, THOUSAND));\n            ({ quotient: millisecondsBigInt, remainder: microsecondsBigInt } = divmod(microsecondsBigInt, THOUSAND));\n            break;\n        case 'microsecond':\n            ({ quotient: microsecondsBigInt, remainder: nanosecondsBigInt } = divmod(nanosecondsBigInt, THOUSAND));\n            break;\n        case 'nanosecond':\n            break;\n        default:\n            throw new Error('assert not reached');\n    }\n    const hours = jsbi_umd.toNumber(hoursBigInt) * sign;\n    const minutes = jsbi_umd.toNumber(minutesBigInt) * sign;\n    const seconds = jsbi_umd.toNumber(secondsBigInt) * sign;\n    const milliseconds = jsbi_umd.toNumber(millisecondsBigInt) * sign;\n    const microseconds = jsbi_umd.toNumber(microsecondsBigInt) * sign;\n    const nanoseconds = jsbi_umd.toNumber(nanosecondsBigInt) * sign;\n    return { days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds };\n}\nfunction UnbalanceDurationRelative(yearsParam, monthsParam, weeksParam, daysParam, largestUnit, relativeToParam) {\n    let years = yearsParam;\n    let months = monthsParam;\n    let weeks = weeksParam;\n    let days = daysParam;\n    const TemporalDuration = GetIntrinsic('%Temporal.Duration%');\n    const sign = DurationSign(years, months, weeks, days, 0, 0, 0, 0, 0, 0);\n    let calendar;\n    let relativeTo;\n    if (relativeToParam) {\n        relativeTo = ToTemporalDate(relativeToParam);\n        calendar = GetSlot(relativeTo, CALENDAR);\n    }\n    const oneYear = new TemporalDuration(sign);\n    const oneMonth = new TemporalDuration(0, sign);\n    const oneWeek = new TemporalDuration(0, 0, sign);\n    switch (largestUnit) {\n        case 'year':\n            // no-op\n            break;\n        case 'month':\n            {\n                if (!calendar)\n                    throw new RangeError('a starting point is required for months balancing');\n                // balance years down to months\n                const dateAdd = calendar.dateAdd;\n                const dateUntil = calendar.dateUntil;\n                let relativeToDateOnly = relativeTo;\n                while (MathAbs(years) > 0) {\n                    const addOptions = ObjectCreate$2(null);\n                    const newRelativeTo = CalendarDateAdd(calendar, relativeToDateOnly, oneYear, addOptions, dateAdd);\n                    const untilOptions = ObjectCreate$2(null);\n                    untilOptions.largestUnit = 'month';\n                    const untilResult = CalendarDateUntil(calendar, relativeToDateOnly, newRelativeTo, untilOptions, dateUntil);\n                    const oneYearMonths = GetSlot(untilResult, MONTHS);\n                    relativeToDateOnly = newRelativeTo;\n                    months += oneYearMonths;\n                    years -= sign;\n                }\n            }\n            break;\n        case 'week':\n            if (!calendar)\n                throw new RangeError('a starting point is required for weeks balancing');\n            // balance years down to days\n            while (MathAbs(years) > 0) {\n                let oneYearDays;\n                ({ relativeTo, days: oneYearDays } = MoveRelativeDate(calendar, relativeTo, oneYear));\n                days += oneYearDays;\n                years -= sign;\n            }\n            // balance months down to days\n            while (MathAbs(months) > 0) {\n                let oneMonthDays;\n                ({ relativeTo, days: oneMonthDays } = MoveRelativeDate(calendar, relativeTo, oneMonth));\n                days += oneMonthDays;\n                months -= sign;\n            }\n            break;\n        default:\n            // balance years down to days\n            while (MathAbs(years) > 0) {\n                if (!calendar)\n                    throw new RangeError('a starting point is required for balancing calendar units');\n                let oneYearDays;\n                ({ relativeTo, days: oneYearDays } = MoveRelativeDate(calendar, relativeTo, oneYear));\n                days += oneYearDays;\n                years -= sign;\n            }\n            // balance months down to days\n            while (MathAbs(months) > 0) {\n                if (!calendar)\n                    throw new RangeError('a starting point is required for balancing calendar units');\n                let oneMonthDays;\n                ({ relativeTo, days: oneMonthDays } = MoveRelativeDate(calendar, relativeTo, oneMonth));\n                days += oneMonthDays;\n                months -= sign;\n            }\n            // balance weeks down to days\n            while (MathAbs(weeks) > 0) {\n                if (!calendar)\n                    throw new RangeError('a starting point is required for balancing calendar units');\n                let oneWeekDays;\n                ({ relativeTo, days: oneWeekDays } = MoveRelativeDate(calendar, relativeTo, oneWeek));\n                days += oneWeekDays;\n                weeks -= sign;\n            }\n            break;\n    }\n    return { years, months, weeks, days };\n}\nfunction BalanceDurationRelative(yearsParam, monthsParam, weeksParam, daysParam, largestUnit, relativeToParam) {\n    let years = yearsParam;\n    let months = monthsParam;\n    let weeks = weeksParam;\n    let days = daysParam;\n    const TemporalDuration = GetIntrinsic('%Temporal.Duration%');\n    const sign = DurationSign(years, months, weeks, days, 0, 0, 0, 0, 0, 0);\n    if (sign === 0)\n        return { years, months, weeks, days };\n    let calendar;\n    let relativeTo;\n    if (relativeToParam) {\n        relativeTo = ToTemporalDate(relativeToParam);\n        calendar = GetSlot(relativeTo, CALENDAR);\n    }\n    const oneYear = new TemporalDuration(sign);\n    const oneMonth = new TemporalDuration(0, sign);\n    const oneWeek = new TemporalDuration(0, 0, sign);\n    switch (largestUnit) {\n        case 'year': {\n            if (!calendar)\n                throw new RangeError('a starting point is required for years balancing');\n            // balance days up to years\n            let newRelativeTo, oneYearDays;\n            ({ relativeTo: newRelativeTo, days: oneYearDays } = MoveRelativeDate(calendar, relativeTo, oneYear));\n            while (MathAbs(days) >= MathAbs(oneYearDays)) {\n                days -= oneYearDays;\n                years += sign;\n                relativeTo = newRelativeTo;\n                ({ relativeTo: newRelativeTo, days: oneYearDays } = MoveRelativeDate(calendar, relativeTo, oneYear));\n            }\n            // balance days up to months\n            let oneMonthDays;\n            ({ relativeTo: newRelativeTo, days: oneMonthDays } = MoveRelativeDate(calendar, relativeTo, oneMonth));\n            while (MathAbs(days) >= MathAbs(oneMonthDays)) {\n                days -= oneMonthDays;\n                months += sign;\n                relativeTo = newRelativeTo;\n                ({ relativeTo: newRelativeTo, days: oneMonthDays } = MoveRelativeDate(calendar, relativeTo, oneMonth));\n            }\n            // balance months up to years\n            const dateAdd = calendar.dateAdd;\n            const addOptions = ObjectCreate$2(null);\n            newRelativeTo = CalendarDateAdd(calendar, relativeTo, oneYear, addOptions, dateAdd);\n            const dateUntil = calendar.dateUntil;\n            const untilOptions = ObjectCreate$2(null);\n            untilOptions.largestUnit = 'month';\n            let untilResult = CalendarDateUntil(calendar, relativeTo, newRelativeTo, untilOptions, dateUntil);\n            let oneYearMonths = GetSlot(untilResult, MONTHS);\n            while (MathAbs(months) >= MathAbs(oneYearMonths)) {\n                months -= oneYearMonths;\n                years += sign;\n                relativeTo = newRelativeTo;\n                const addOptions = ObjectCreate$2(null);\n                newRelativeTo = CalendarDateAdd(calendar, relativeTo, oneYear, addOptions, dateAdd);\n                const untilOptions = ObjectCreate$2(null);\n                untilOptions.largestUnit = 'month';\n                untilResult = CalendarDateUntil(calendar, relativeTo, newRelativeTo, untilOptions, dateUntil);\n                oneYearMonths = GetSlot(untilResult, MONTHS);\n            }\n            break;\n        }\n        case 'month': {\n            if (!calendar)\n                throw new RangeError('a starting point is required for months balancing');\n            // balance days up to months\n            let newRelativeTo, oneMonthDays;\n            ({ relativeTo: newRelativeTo, days: oneMonthDays } = MoveRelativeDate(calendar, relativeTo, oneMonth));\n            while (MathAbs(days) >= MathAbs(oneMonthDays)) {\n                days -= oneMonthDays;\n                months += sign;\n                relativeTo = newRelativeTo;\n                ({ relativeTo: newRelativeTo, days: oneMonthDays } = MoveRelativeDate(calendar, relativeTo, oneMonth));\n            }\n            break;\n        }\n        case 'week': {\n            if (!calendar)\n                throw new RangeError('a starting point is required for weeks balancing');\n            // balance days up to weeks\n            let newRelativeTo, oneWeekDays;\n            ({ relativeTo: newRelativeTo, days: oneWeekDays } = MoveRelativeDate(calendar, relativeTo, oneWeek));\n            while (MathAbs(days) >= MathAbs(oneWeekDays)) {\n                days -= oneWeekDays;\n                weeks += sign;\n                relativeTo = newRelativeTo;\n                ({ relativeTo: newRelativeTo, days: oneWeekDays } = MoveRelativeDate(calendar, relativeTo, oneWeek));\n            }\n            break;\n        }\n    }\n    return { years, months, weeks, days };\n}\nfunction CalculateOffsetShift(relativeTo, y, mon, w, d, h, min, s, ms, s, ns) {\n    if (IsTemporalZonedDateTime(relativeTo)) {\n        const instant = GetSlot(relativeTo, INSTANT);\n        const timeZone = GetSlot(relativeTo, TIME_ZONE);\n        const calendar = GetSlot(relativeTo, CALENDAR);\n        const offsetBefore = GetOffsetNanosecondsFor(timeZone, instant);\n        const after = AddZonedDateTime(instant, timeZone, calendar, y, mon, w, d, h, min, s, ms, s, ns);\n        const TemporalInstant = GetIntrinsic('%Temporal.Instant%');\n        const instantAfter = new TemporalInstant(after);\n        const offsetAfter = GetOffsetNanosecondsFor(timeZone, instantAfter);\n        return offsetAfter - offsetBefore;\n    }\n    return 0;\n}\nfunction CreateNegatedTemporalDuration(duration) {\n    const TemporalDuration = GetIntrinsic('%Temporal.Duration%');\n    return new TemporalDuration(-GetSlot(duration, YEARS), -GetSlot(duration, MONTHS), -GetSlot(duration, WEEKS), -GetSlot(duration, DAYS), -GetSlot(duration, HOURS), -GetSlot(duration, MINUTES), -GetSlot(duration, SECONDS), -GetSlot(duration, MILLISECONDS), -GetSlot(duration, MICROSECONDS), -GetSlot(duration, NANOSECONDS));\n}\nfunction ConstrainToRange(value, min, max) {\n    // Math.Max accepts undefined values and returns NaN. Undefined values are\n    // used for optional params in the method below.\n    return MathMin(max, MathMax(min, value));\n}\nfunction ConstrainISODate(year, monthParam, dayParam) {\n    const month = ConstrainToRange(monthParam, 1, 12);\n    const day = ConstrainToRange(dayParam, 1, ISODaysInMonth(year, month));\n    return { year, month, day };\n}\nfunction ConstrainTime(hourParam, minuteParam, secondParam, millisecondParam, microsecondParam, nanosecondParam) {\n    const hour = ConstrainToRange(hourParam, 0, 23);\n    const minute = ConstrainToRange(minuteParam, 0, 59);\n    const second = ConstrainToRange(secondParam, 0, 59);\n    const millisecond = ConstrainToRange(millisecondParam, 0, 999);\n    const microsecond = ConstrainToRange(microsecondParam, 0, 999);\n    const nanosecond = ConstrainToRange(nanosecondParam, 0, 999);\n    return { hour, minute, second, millisecond, microsecond, nanosecond };\n}\nfunction RejectToRange(value, min, max) {\n    if (value < min || value > max)\n        throw new RangeError(`value out of range: ${min} <= ${value} <= ${max}`);\n}\nfunction RejectISODate(year, month, day) {\n    RejectToRange(month, 1, 12);\n    RejectToRange(day, 1, ISODaysInMonth(year, month));\n}\nfunction RejectDateRange(year, month, day) {\n    // Noon avoids trouble at edges of DateTime range (excludes midnight)\n    RejectDateTimeRange(year, month, day, 12, 0, 0, 0, 0, 0);\n}\nfunction RejectTime(hour, minute, second, millisecond, microsecond, nanosecond) {\n    RejectToRange(hour, 0, 23);\n    RejectToRange(minute, 0, 59);\n    RejectToRange(second, 0, 59);\n    RejectToRange(millisecond, 0, 999);\n    RejectToRange(microsecond, 0, 999);\n    RejectToRange(nanosecond, 0, 999);\n}\nfunction RejectDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond) {\n    RejectISODate(year, month, day);\n    RejectTime(hour, minute, second, millisecond, microsecond, nanosecond);\n}\nfunction RejectDateTimeRange(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond) {\n    RejectToRange(year, YEAR_MIN, YEAR_MAX);\n    // Reject any DateTime 24 hours or more outside the Instant range\n    if ((year === YEAR_MIN &&\n        null ==\n            GetEpochFromISOParts(year, month, day + 1, hour, minute, second, millisecond, microsecond, nanosecond - 1)) ||\n        (year === YEAR_MAX &&\n            null ==\n                GetEpochFromISOParts(year, month, day - 1, hour, minute, second, millisecond, microsecond, nanosecond + 1))) {\n        throw new RangeError('DateTime outside of supported range');\n    }\n}\nfunction ValidateEpochNanoseconds(epochNanoseconds) {\n    if (jsbi_umd.lessThan(epochNanoseconds, NS_MIN) || jsbi_umd.greaterThan(epochNanoseconds, NS_MAX)) {\n        throw new RangeError('Instant outside of supported range');\n    }\n}\nfunction RejectYearMonthRange(year, month) {\n    RejectToRange(year, YEAR_MIN, YEAR_MAX);\n    if (year === YEAR_MIN) {\n        RejectToRange(month, 4, 12);\n    }\n    else if (year === YEAR_MAX) {\n        RejectToRange(month, 1, 9);\n    }\n}\nfunction RejectDuration(y, mon, w, d, h, min, s, ms, s, ns) {\n    const sign = DurationSign(y, mon, w, d, h, min, s, ms, s, ns);\n    for (const prop of [y, mon, w, d, h, min, s, ms, s, ns]) {\n        if (!NumberIsFinite(prop))\n            throw new RangeError('infinite values not allowed as duration fields');\n        const propSign = MathSign(prop);\n        if (propSign !== 0 && propSign !== sign)\n            throw new RangeError('mixed-sign values not allowed as duration fields');\n    }\n}\nfunction DifferenceISODate(y1, m1, d1, y2, m2, d2, largestUnit) {\n    switch (largestUnit) {\n        case 'year':\n        case 'month': {\n            const sign = -CompareISODate(y1, m1, d1, y2, m2, d2);\n            if (sign === 0)\n                return { years: 0, months: 0, weeks: 0, days: 0 };\n            const start = { year: y1, month: m1, day: d1 };\n            const end = { year: y2, month: m2, day: d2 };\n            let years = end.year - start.year;\n            let mid = AddISODate(y1, m1, d1, years, 0, 0, 0, 'constrain');\n            let midSign = -CompareISODate(mid.year, mid.month, mid.day, y2, m2, d2);\n            if (midSign === 0) {\n                return largestUnit === 'year'\n                    ? { years, months: 0, weeks: 0, days: 0 }\n                    : { years: 0, months: years * 12, weeks: 0, days: 0 };\n            }\n            let months = end.month - start.month;\n            if (midSign !== sign) {\n                years -= sign;\n                months += sign * 12;\n            }\n            mid = AddISODate(y1, m1, d1, years, months, 0, 0, 'constrain');\n            midSign = -CompareISODate(mid.year, mid.month, mid.day, y2, m2, d2);\n            if (midSign === 0) {\n                return largestUnit === 'year'\n                    ? { years, months, weeks: 0, days: 0 }\n                    : { years: 0, months: months + years * 12, weeks: 0, days: 0 };\n            }\n            if (midSign !== sign) {\n                // The end date is later in the month than mid date (or earlier for\n                // negative durations). Back up one month.\n                months -= sign;\n                if (months === -sign) {\n                    years -= sign;\n                    months = 11 * sign;\n                }\n                mid = AddISODate(y1, m1, d1, years, months, 0, 0, 'constrain');\n                midSign = -CompareISODate(y1, m1, d1, mid.year, mid.month, mid.day);\n            }\n            let days = 0;\n            // If we get here, months and years are correct (no overflow), and `mid`\n            // is within the range from `start` to `end`. To count the days between\n            // `mid` and `end`, there are 3 cases:\n            // 1) same month: use simple subtraction\n            // 2) end is previous month from intermediate (negative duration)\n            // 3) end is next month from intermediate (positive duration)\n            if (mid.month === end.month) {\n                // 1) same month: use simple subtraction\n                days = end.day - mid.day;\n            }\n            else if (sign < 0) {\n                // 2) end is previous month from intermediate (negative duration)\n                // Example: intermediate: Feb 1, end: Jan 30, DaysInMonth = 31, days = -2\n                days = -mid.day - (ISODaysInMonth(end.year, end.month) - end.day);\n            }\n            else {\n                // 3) end is next month from intermediate (positive duration)\n                // Example: intermediate: Jan 29, end: Feb 1, DaysInMonth = 31, days = 3\n                days = end.day + (ISODaysInMonth(mid.year, mid.month) - mid.day);\n            }\n            if (largestUnit === 'month') {\n                months += years * 12;\n                years = 0;\n            }\n            return { years, months, weeks: 0, days };\n        }\n        case 'week':\n        case 'day': {\n            let larger, smaller, sign;\n            if (CompareISODate(y1, m1, d1, y2, m2, d2) < 0) {\n                smaller = { year: y1, month: m1, day: d1 };\n                larger = { year: y2, month: m2, day: d2 };\n                sign = 1;\n            }\n            else {\n                smaller = { year: y2, month: m2, day: d2 };\n                larger = { year: y1, month: m1, day: d1 };\n                sign = -1;\n            }\n            let days = DayOfYear(larger.year, larger.month, larger.day) - DayOfYear(smaller.year, smaller.month, smaller.day);\n            for (let year = smaller.year; year < larger.year; ++year) {\n                days += LeapYear(year) ? 366 : 365;\n            }\n            let weeks = 0;\n            if (largestUnit === 'week') {\n                weeks = MathFloor(days / 7);\n                days %= 7;\n            }\n            weeks *= sign;\n            days *= sign;\n            return { years: 0, months: 0, weeks, days };\n        }\n        default:\n            throw new Error('assert not reached');\n    }\n}\nfunction DifferenceTime(h1, min1, s1, ms1, s1, ns1, h2, min2, s2, ms2, s2, ns2) {\n    let hours = h2 - h1;\n    let minutes = min2 - min1;\n    let seconds = s2 - s1;\n    let milliseconds = ms2 - ms1;\n    let microseconds = s2 - s1;\n    let nanoseconds = ns2 - ns1;\n    const sign = DurationSign(0, 0, 0, 0, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n    hours *= sign;\n    minutes *= sign;\n    seconds *= sign;\n    milliseconds *= sign;\n    microseconds *= sign;\n    nanoseconds *= sign;\n    let deltaDays = 0;\n    ({\n        deltaDays,\n        hour: hours,\n        minute: minutes,\n        second: seconds,\n        millisecond: milliseconds,\n        microsecond: microseconds,\n        nanosecond: nanoseconds\n    } = BalanceTime(hours, minutes, seconds, milliseconds, microseconds, nanoseconds));\n    deltaDays *= sign;\n    hours *= sign;\n    minutes *= sign;\n    seconds *= sign;\n    milliseconds *= sign;\n    microseconds *= sign;\n    nanoseconds *= sign;\n    return { deltaDays, hours, minutes, seconds, milliseconds, microseconds, nanoseconds };\n}\nfunction DifferenceInstant(ns1, ns2, increment, unit, roundingMode) {\n    const diff = jsbi_umd.subtract(ns2, ns1);\n    const remainder = jsbi_umd.remainder(diff, jsbi_umd.BigInt(86400e9));\n    const wholeDays = jsbi_umd.subtract(diff, remainder);\n    const roundedRemainder = RoundNumberToIncrement(remainder, nsPerTimeUnit[unit] * increment, roundingMode);\n    const roundedDiff = jsbi_umd.add(wholeDays, roundedRemainder);\n    const nanoseconds = jsbi_umd.toNumber(jsbi_umd.remainder(roundedDiff, THOUSAND));\n    const microseconds = jsbi_umd.toNumber(jsbi_umd.remainder(jsbi_umd.divide(roundedDiff, THOUSAND), THOUSAND));\n    const milliseconds = jsbi_umd.toNumber(jsbi_umd.remainder(jsbi_umd.divide(roundedDiff, MILLION), THOUSAND));\n    const seconds = jsbi_umd.toNumber(jsbi_umd.divide(roundedDiff, BILLION));\n    return { seconds, milliseconds, microseconds, nanoseconds };\n}\nfunction DifferenceISODateTime(y1Param, mon1Param, d1Param, h1, min1, s1, ms1, s1, ns1, y2, mon2, d2, h2, min2, s2, ms2, s2, ns2, calendar, largestUnit, options = ObjectCreate$2(null)) {\n    let y1 = y1Param;\n    let mon1 = mon1Param;\n    let d1 = d1Param;\n    let { deltaDays, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = DifferenceTime(h1, min1, s1, ms1, s1, ns1, h2, min2, s2, ms2, s2, ns2);\n    const timeSign = DurationSign(0, 0, 0, deltaDays, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n    ({ year: y1, month: mon1, day: d1 } = BalanceISODate(y1, mon1, d1 + deltaDays));\n    const dateSign = CompareISODate(y2, mon2, d2, y1, mon1, d1);\n    if (dateSign === -timeSign) {\n        ({ year: y1, month: mon1, day: d1 } = BalanceISODate(y1, mon1, d1 - timeSign));\n        ({ hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = BalanceDuration(-timeSign, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, largestUnit));\n    }\n    const date1 = CreateTemporalDate(y1, mon1, d1, calendar);\n    const date2 = CreateTemporalDate(y2, mon2, d2, calendar);\n    const dateLargestUnit = LargerOfTwoTemporalUnits('day', largestUnit);\n    const untilOptions = { ...options, largestUnit: dateLargestUnit };\n    let { years, months, weeks, days } = CalendarDateUntil(calendar, date1, date2, untilOptions);\n    // Signs of date part and time part may not agree; balance them together\n    ({ days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = BalanceDuration(days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, largestUnit));\n    return { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds };\n}\nfunction DifferenceZonedDateTime(ns1, ns2, timeZone, calendar, largestUnit, options) {\n    const nsDiff = jsbi_umd.subtract(ns2, ns1);\n    if (jsbi_umd.equal(nsDiff, ZERO)) {\n        return {\n            years: 0,\n            months: 0,\n            weeks: 0,\n            days: 0,\n            hours: 0,\n            minutes: 0,\n            seconds: 0,\n            milliseconds: 0,\n            microseconds: 0,\n            nanoseconds: 0\n        };\n    }\n    // Find the difference in dates only.\n    const TemporalInstant = GetIntrinsic('%Temporal.Instant%');\n    const start = new TemporalInstant(ns1);\n    const end = new TemporalInstant(ns2);\n    const dtStart = BuiltinTimeZoneGetPlainDateTimeFor(timeZone, start, calendar);\n    const dtEnd = BuiltinTimeZoneGetPlainDateTimeFor(timeZone, end, calendar);\n    let { years, months, weeks, days } = DifferenceISODateTime(GetSlot(dtStart, ISO_YEAR), GetSlot(dtStart, ISO_MONTH), GetSlot(dtStart, ISO_DAY), GetSlot(dtStart, ISO_HOUR), GetSlot(dtStart, ISO_MINUTE), GetSlot(dtStart, ISO_SECOND), GetSlot(dtStart, ISO_MILLISECOND), GetSlot(dtStart, ISO_MICROSECOND), GetSlot(dtStart, ISO_NANOSECOND), GetSlot(dtEnd, ISO_YEAR), GetSlot(dtEnd, ISO_MONTH), GetSlot(dtEnd, ISO_DAY), GetSlot(dtEnd, ISO_HOUR), GetSlot(dtEnd, ISO_MINUTE), GetSlot(dtEnd, ISO_SECOND), GetSlot(dtEnd, ISO_MILLISECOND), GetSlot(dtEnd, ISO_MICROSECOND), GetSlot(dtEnd, ISO_NANOSECOND), calendar, largestUnit, options);\n    const intermediateNs = AddZonedDateTime(start, timeZone, calendar, years, months, weeks, 0, 0, 0, 0, 0, 0, 0);\n    // may disambiguate\n    let timeRemainderNs = jsbi_umd.subtract(ns2, intermediateNs);\n    const intermediate = CreateTemporalZonedDateTime(intermediateNs, timeZone, calendar);\n    ({ nanoseconds: timeRemainderNs, days } = NanosecondsToDays(timeRemainderNs, intermediate));\n    // Finally, merge the date and time durations and return the merged result.\n    const { hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = BalanceDuration(0, 0, 0, 0, 0, 0, jsbi_umd.toNumber(timeRemainderNs), 'hour');\n    return { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds };\n}\nfunction AddISODate(yearParam, monthParam, dayParam, yearsParam, monthsParam, weeksParam, daysParam, overflow) {\n    let year = yearParam;\n    let month = monthParam;\n    let day = dayParam;\n    let years = yearsParam;\n    let months = monthsParam;\n    let weeks = weeksParam;\n    let days = daysParam;\n    year += years;\n    month += months;\n    ({ year, month } = BalanceISOYearMonth(year, month));\n    ({ year, month, day } = RegulateISODate(year, month, day, overflow));\n    days += 7 * weeks;\n    day += days;\n    ({ year, month, day } = BalanceISODate(year, month, day));\n    return { year, month, day };\n}\nfunction AddTime(hourParam, minuteParam, secondParam, millisecondParam, microsecondParam, nanosecondParam, hours, minutes, seconds, milliseconds, microseconds, nanoseconds) {\n    let hour = hourParam;\n    let minute = minuteParam;\n    let second = secondParam;\n    let millisecond = millisecondParam;\n    let microsecond = microsecondParam;\n    let nanosecond = nanosecondParam;\n    hour += hours;\n    minute += minutes;\n    second += seconds;\n    millisecond += milliseconds;\n    microsecond += microseconds;\n    nanosecond += nanoseconds;\n    let deltaDays = 0;\n    ({ deltaDays, hour, minute, second, millisecond, microsecond, nanosecond } = BalanceTime(hour, minute, second, millisecond, microsecond, nanosecond));\n    return { deltaDays, hour, minute, second, millisecond, microsecond, nanosecond };\n}\nfunction AddDuration(y1, mon1, w1, d1, h1, min1, s1, ms1, s1, ns1, y2, mon2, w2, d2, h2, min2, s2, ms2, s2, ns2, relativeTo) {\n    const largestUnit1 = DefaultTemporalLargestUnit(y1, mon1, w1, d1, h1, min1, s1, ms1, s1, ns1);\n    const largestUnit2 = DefaultTemporalLargestUnit(y2, mon2, w2, d2, h2, min2, s2, ms2, s2, ns2);\n    const largestUnit = LargerOfTwoTemporalUnits(largestUnit1, largestUnit2);\n    let years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds;\n    if (!relativeTo) {\n        if (largestUnit === 'year' || largestUnit === 'month' || largestUnit === 'week') {\n            throw new RangeError('relativeTo is required for years, months, or weeks arithmetic');\n        }\n        years = months = weeks = 0;\n        ({ days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = BalanceDuration(d1 + d2, h1 + h2, min1 + min2, s1 + s2, ms1 + ms2, s1 + s2, ns1 + ns2, largestUnit));\n    }\n    else if (IsTemporalDate(relativeTo)) {\n        const TemporalDuration = GetIntrinsic('%Temporal.Duration%');\n        const calendar = GetSlot(relativeTo, CALENDAR);\n        const dateDuration1 = new TemporalDuration(y1, mon1, w1, d1, 0, 0, 0, 0, 0, 0);\n        const dateDuration2 = new TemporalDuration(y2, mon2, w2, d2, 0, 0, 0, 0, 0, 0);\n        const dateAdd = calendar.dateAdd;\n        const firstAddOptions = ObjectCreate$2(null);\n        const intermediate = CalendarDateAdd(calendar, relativeTo, dateDuration1, firstAddOptions, dateAdd);\n        const secondAddOptions = ObjectCreate$2(null);\n        const end = CalendarDateAdd(calendar, intermediate, dateDuration2, secondAddOptions, dateAdd);\n        const dateLargestUnit = LargerOfTwoTemporalUnits('day', largestUnit);\n        const differenceOptions = ObjectCreate$2(null);\n        differenceOptions.largestUnit = dateLargestUnit;\n        ({ years, months, weeks, days } = CalendarDateUntil(calendar, relativeTo, end, differenceOptions));\n        // Signs of date part and time part may not agree; balance them together\n        ({ days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = BalanceDuration(days, h1 + h2, min1 + min2, s1 + s2, ms1 + ms2, s1 + s2, ns1 + ns2, largestUnit));\n    }\n    else {\n        // relativeTo is a ZonedDateTime\n        const TemporalInstant = GetIntrinsic('%Temporal.Instant%');\n        const timeZone = GetSlot(relativeTo, TIME_ZONE);\n        const calendar = GetSlot(relativeTo, CALENDAR);\n        const intermediateNs = AddZonedDateTime(GetSlot(relativeTo, INSTANT), timeZone, calendar, y1, mon1, w1, d1, h1, min1, s1, ms1, s1, ns1);\n        const endNs = AddZonedDateTime(new TemporalInstant(intermediateNs), timeZone, calendar, y2, mon2, w2, d2, h2, min2, s2, ms2, s2, ns2);\n        if (largestUnit !== 'year' && largestUnit !== 'month' && largestUnit !== 'week' && largestUnit !== 'day') {\n            // The user is only asking for a time difference, so return difference of instants.\n            years = 0;\n            months = 0;\n            weeks = 0;\n            days = 0;\n            ({ seconds, milliseconds, microseconds, nanoseconds } = DifferenceInstant(GetSlot(relativeTo, EPOCHNANOSECONDS), endNs, 1, 'nanosecond', 'halfExpand'));\n            ({ hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = BalanceDuration(0, 0, 0, seconds, milliseconds, microseconds, nanoseconds, largestUnit));\n        }\n        else {\n            ({ years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } =\n                DifferenceZonedDateTime(GetSlot(relativeTo, EPOCHNANOSECONDS), endNs, timeZone, calendar, largestUnit));\n        }\n    }\n    RejectDuration(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n    return { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds };\n}\nfunction AddInstant(epochNanoseconds, h, min, s, ms, s, ns) {\n    let sum = ZERO;\n    sum = jsbi_umd.add(sum, jsbi_umd.BigInt(ns));\n    sum = jsbi_umd.add(sum, jsbi_umd.multiply(jsbi_umd.BigInt(s), THOUSAND));\n    sum = jsbi_umd.add(sum, jsbi_umd.multiply(jsbi_umd.BigInt(ms), MILLION));\n    sum = jsbi_umd.add(sum, jsbi_umd.multiply(jsbi_umd.BigInt(s), BILLION));\n    sum = jsbi_umd.add(sum, jsbi_umd.multiply(jsbi_umd.BigInt(min), jsbi_umd.BigInt(60 * 1e9)));\n    sum = jsbi_umd.add(sum, jsbi_umd.multiply(jsbi_umd.BigInt(h), jsbi_umd.BigInt(60 * 60 * 1e9)));\n    const result = jsbi_umd.add(epochNanoseconds, sum);\n    ValidateEpochNanoseconds(result);\n    return result;\n}\nfunction AddDateTime(year, month, day, hourParam, minuteParam, secondParam, millisecondParam, microsecondParam, nanosecondParam, calendar, years, months, weeks, daysParam, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, options) {\n    let days = daysParam;\n    // Add the time part\n    let { deltaDays, hour, minute, second, millisecond, microsecond, nanosecond } = AddTime(hourParam, minuteParam, secondParam, millisecondParam, microsecondParam, nanosecondParam, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n    days += deltaDays;\n    // Delegate the date part addition to the calendar\n    const TemporalDuration = GetIntrinsic('%Temporal.Duration%');\n    const datePart = CreateTemporalDate(year, month, day, calendar);\n    const dateDuration = new TemporalDuration(years, months, weeks, days, 0, 0, 0, 0, 0, 0);\n    const addedDate = CalendarDateAdd(calendar, datePart, dateDuration, options);\n    return {\n        year: GetSlot(addedDate, ISO_YEAR),\n        month: GetSlot(addedDate, ISO_MONTH),\n        day: GetSlot(addedDate, ISO_DAY),\n        hour,\n        minute,\n        second,\n        millisecond,\n        microsecond,\n        nanosecond\n    };\n}\nfunction AddZonedDateTime(instant, timeZone, calendar, years, months, weeks, days, h, min, s, ms, s, ns, options) {\n    // If only time is to be added, then use Instant math. It's not OK to fall\n    // through to the date/time code below because compatible disambiguation in\n    // the PlainDateTime=>Instant conversion will change the offset of any\n    // ZonedDateTime in the repeated clock time after a backwards transition.\n    // When adding/subtracting time units and not dates, this disambiguation is\n    // not expected and so is avoided below via a fast path for time-only\n    // arithmetic.\n    // BTW, this behavior is similar in spirit to offset: 'prefer' in `with`.\n    const TemporalDuration = GetIntrinsic('%Temporal.Duration%');\n    if (DurationSign(years, months, weeks, days, 0, 0, 0, 0, 0, 0) === 0) {\n        return AddInstant(GetSlot(instant, EPOCHNANOSECONDS), h, min, s, ms, s, ns);\n    }\n    // RFC 5545 requires the date portion to be added in calendar days and the\n    // time portion to be added in exact time.\n    const dt = BuiltinTimeZoneGetPlainDateTimeFor(timeZone, instant, calendar);\n    const datePart = CreateTemporalDate(GetSlot(dt, ISO_YEAR), GetSlot(dt, ISO_MONTH), GetSlot(dt, ISO_DAY), calendar);\n    const dateDuration = new TemporalDuration(years, months, weeks, days, 0, 0, 0, 0, 0, 0);\n    const addedDate = CalendarDateAdd(calendar, datePart, dateDuration, options);\n    const dtIntermediate = CreateTemporalDateTime(GetSlot(addedDate, ISO_YEAR), GetSlot(addedDate, ISO_MONTH), GetSlot(addedDate, ISO_DAY), GetSlot(dt, ISO_HOUR), GetSlot(dt, ISO_MINUTE), GetSlot(dt, ISO_SECOND), GetSlot(dt, ISO_MILLISECOND), GetSlot(dt, ISO_MICROSECOND), GetSlot(dt, ISO_NANOSECOND), calendar);\n    // Note that 'compatible' is used below because this disambiguation behavior\n    // is required by RFC 5545.\n    const instantIntermediate = BuiltinTimeZoneGetInstantFor(timeZone, dtIntermediate, 'compatible');\n    return AddInstant(GetSlot(instantIntermediate, EPOCHNANOSECONDS), h, min, s, ms, s, ns);\n}\nfunction RoundNumberToIncrement(quantity, increment, mode) {\n    if (increment === 1)\n        return quantity;\n    let { quotient, remainder } = divmod(quantity, jsbi_umd.BigInt(increment));\n    if (jsbi_umd.equal(remainder, ZERO))\n        return quantity;\n    const sign = jsbi_umd.lessThan(remainder, ZERO) ? -1 : 1;\n    switch (mode) {\n        case 'ceil':\n            if (sign > 0)\n                quotient = jsbi_umd.add(quotient, jsbi_umd.BigInt(sign));\n            break;\n        case 'floor':\n            if (sign < 0)\n                quotient = jsbi_umd.add(quotient, jsbi_umd.BigInt(sign));\n            break;\n        case 'trunc':\n            // no change needed, because divmod is a truncation\n            break;\n        case 'halfExpand':\n            // \"half up away from zero\"\n            if (jsbi_umd.toNumber(abs(jsbi_umd.multiply(remainder, jsbi_umd.BigInt(2)))) >= increment) {\n                quotient = jsbi_umd.add(quotient, jsbi_umd.BigInt(sign));\n            }\n            break;\n    }\n    return jsbi_umd.multiply(quotient, jsbi_umd.BigInt(increment));\n}\nfunction RoundInstant(epochNs, increment, unit, roundingMode) {\n    // Note: NonNegativeModulo, but with BigInt\n    let remainder = jsbi_umd.remainder(epochNs, jsbi_umd.BigInt(86400e9));\n    if (jsbi_umd.lessThan(remainder, ZERO))\n        remainder = jsbi_umd.add(remainder, jsbi_umd.BigInt(86400e9));\n    const wholeDays = jsbi_umd.subtract(epochNs, remainder);\n    const roundedRemainder = RoundNumberToIncrement(remainder, nsPerTimeUnit[unit] * increment, roundingMode);\n    return jsbi_umd.add(wholeDays, roundedRemainder);\n}\nfunction RoundISODateTime(yearParam, monthParam, dayParam, hourParam, minuteParam, secondParam, millisecondParam, microsecondParam, nanosecondParam, increment, unit, roundingMode, dayLengthNs = 86400e9) {\n    const { deltaDays, hour, minute, second, millisecond, microsecond, nanosecond } = RoundTime(hourParam, minuteParam, secondParam, millisecondParam, microsecondParam, nanosecondParam, increment, unit, roundingMode, dayLengthNs);\n    const { year, month, day } = BalanceISODate(yearParam, monthParam, dayParam + deltaDays);\n    return { year, month, day, hour, minute, second, millisecond, microsecond, nanosecond };\n}\nfunction RoundTime(hour, minute, second, millisecond, microsecond, nanosecond, increment, unit, roundingMode, dayLengthNs = 86400e9) {\n    let quantity = ZERO;\n    switch (unit) {\n        case 'day':\n        case 'hour':\n            quantity = jsbi_umd.BigInt(hour);\n        // fall through\n        case 'minute':\n            quantity = jsbi_umd.add(jsbi_umd.multiply(quantity, SIXTY), jsbi_umd.BigInt(minute));\n        // fall through\n        case 'second':\n            quantity = jsbi_umd.add(jsbi_umd.multiply(quantity, SIXTY), jsbi_umd.BigInt(second));\n        // fall through\n        case 'millisecond':\n            quantity = jsbi_umd.add(jsbi_umd.multiply(quantity, THOUSAND), jsbi_umd.BigInt(millisecond));\n        // fall through\n        case 'microsecond':\n            quantity = jsbi_umd.add(jsbi_umd.multiply(quantity, THOUSAND), jsbi_umd.BigInt(microsecond));\n        // fall through\n        case 'nanosecond':\n            quantity = jsbi_umd.add(jsbi_umd.multiply(quantity, THOUSAND), jsbi_umd.BigInt(nanosecond));\n    }\n    const nsPerUnit = unit === 'day' ? dayLengthNs : nsPerTimeUnit[unit];\n    const rounded = RoundNumberToIncrement(quantity, nsPerUnit * increment, roundingMode);\n    const result = jsbi_umd.toNumber(jsbi_umd.divide(rounded, jsbi_umd.BigInt(nsPerUnit)));\n    switch (unit) {\n        case 'day':\n            return { deltaDays: result, hour: 0, minute: 0, second: 0, millisecond: 0, microsecond: 0, nanosecond: 0 };\n        case 'hour':\n            return BalanceTime(result, 0, 0, 0, 0, 0);\n        case 'minute':\n            return BalanceTime(hour, result, 0, 0, 0, 0);\n        case 'second':\n            return BalanceTime(hour, minute, result, 0, 0, 0);\n        case 'millisecond':\n            return BalanceTime(hour, minute, second, result, 0, 0);\n        case 'microsecond':\n            return BalanceTime(hour, minute, second, millisecond, result, 0);\n        case 'nanosecond':\n            return BalanceTime(hour, minute, second, millisecond, microsecond, result);\n        default:\n            throw new Error(`Invalid unit ${unit}`);\n    }\n}\nfunction DaysUntil(earlier, later) {\n    return DifferenceISODate(GetSlot(earlier, ISO_YEAR), GetSlot(earlier, ISO_MONTH), GetSlot(earlier, ISO_DAY), GetSlot(later, ISO_YEAR), GetSlot(later, ISO_MONTH), GetSlot(later, ISO_DAY), 'day').days;\n}\nfunction MoveRelativeDate(calendar, relativeToParam, duration) {\n    const options = ObjectCreate$2(null);\n    const later = CalendarDateAdd(calendar, relativeToParam, duration, options);\n    const days = DaysUntil(relativeToParam, later);\n    return { relativeTo: later, days };\n}\nfunction MoveRelativeZonedDateTime(relativeTo, years, months, weeks, days) {\n    const timeZone = GetSlot(relativeTo, TIME_ZONE);\n    const calendar = GetSlot(relativeTo, CALENDAR);\n    const intermediateNs = AddZonedDateTime(GetSlot(relativeTo, INSTANT), timeZone, calendar, years, months, weeks, days, 0, 0, 0, 0, 0, 0);\n    return CreateTemporalZonedDateTime(intermediateNs, timeZone, calendar);\n}\nfunction AdjustRoundedDurationDays(yearsParam, monthsParam, weeksParam, daysParam, hoursParam, minutesParam, secondsParam, millisecondsParam, microsecondsParam, nanosecondsParam, increment, unit, roundingMode, relativeTo) {\n    let years = yearsParam;\n    let months = monthsParam;\n    let weeks = weeksParam;\n    let days = daysParam;\n    let hours = hoursParam;\n    let minutes = minutesParam;\n    let seconds = secondsParam;\n    let milliseconds = millisecondsParam;\n    let microseconds = microsecondsParam;\n    let nanoseconds = nanosecondsParam;\n    if (!IsTemporalZonedDateTime(relativeTo) ||\n        unit === 'year' ||\n        unit === 'month' ||\n        unit === 'week' ||\n        unit === 'day' ||\n        (unit === 'nanosecond' && increment === 1)) {\n        return { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds };\n    }\n    // There's one more round of rounding possible: if relativeTo is a\n    // ZonedDateTime, the time units could have rounded up into enough hours\n    // to exceed the day length. If this happens, grow the date part by a\n    // single day and re-run exact time rounding on the smaller remainder. DO\n    // NOT RECURSE, because once the extra hours are sucked up into the date\n    // duration, there's no way for another full day to come from the next\n    // round of rounding. And if it were possible (e.g. contrived calendar\n    // with 30-minute-long \"days\") then it'd risk an infinite loop.\n    let timeRemainderNs = TotalDurationNanoseconds(0, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, 0);\n    const direction = MathSign(jsbi_umd.toNumber(timeRemainderNs));\n    const timeZone = GetSlot(relativeTo, TIME_ZONE);\n    const calendar = GetSlot(relativeTo, CALENDAR);\n    const dayStart = AddZonedDateTime(GetSlot(relativeTo, INSTANT), timeZone, calendar, years, months, weeks, days, 0, 0, 0, 0, 0, 0);\n    const TemporalInstant = GetIntrinsic('%Temporal.Instant%');\n    const dayEnd = AddZonedDateTime(new TemporalInstant(dayStart), timeZone, calendar, 0, 0, 0, direction, 0, 0, 0, 0, 0, 0);\n    const dayLengthNs = jsbi_umd.subtract(dayEnd, dayStart);\n    if (jsbi_umd.greaterThanOrEqual(jsbi_umd.multiply(jsbi_umd.subtract(timeRemainderNs, dayLengthNs), jsbi_umd.BigInt(direction)), ZERO)) {\n        ({ years, months, weeks, days } = AddDuration(years, months, weeks, days, 0, 0, 0, 0, 0, 0, 0, 0, 0, direction, 0, 0, 0, 0, 0, 0, relativeTo));\n        timeRemainderNs = RoundInstant(jsbi_umd.subtract(timeRemainderNs, dayLengthNs), increment, unit, roundingMode);\n        ({ hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = BalanceDuration(0, 0, 0, 0, 0, 0, jsbi_umd.toNumber(timeRemainderNs), 'hour'));\n    }\n    return { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds };\n}\nfunction RoundDuration(yearsParam, monthsParam, weeksParam, daysParam, hoursParam, minutesParam, secondsParam, millisecondsParam, microsecondsParam, nanosecondsParam, increment, unit, roundingMode, relativeToParam = undefined) {\n    let years = yearsParam;\n    let months = monthsParam;\n    let weeks = weeksParam;\n    let days = daysParam;\n    let hours = hoursParam;\n    let minutes = minutesParam;\n    let seconds = secondsParam;\n    let milliseconds = millisecondsParam;\n    let microseconds = microsecondsParam;\n    let nanoseconds = jsbi_umd.BigInt(nanosecondsParam);\n    const TemporalDuration = GetIntrinsic('%Temporal.Duration%');\n    let calendar, zdtRelative;\n    // A cast is used below because relativeTo will be either PlainDate or\n    // undefined for the rest of this long method (after any ZDT=>PlainDate\n    // conversion below), and TS isn't smart enough to know that the type has\n    // changed. See https://github.com/microsoft/TypeScript/issues/27706.\n    let relativeTo = relativeToParam;\n    if (relativeTo) {\n        if (IsTemporalZonedDateTime(relativeTo)) {\n            zdtRelative = relativeTo;\n            relativeTo = ToTemporalDate(relativeTo);\n        }\n        else if (!IsTemporalDate(relativeTo)) {\n            throw new TypeError('starting point must be PlainDate or ZonedDateTime');\n        }\n        calendar = GetSlot(relativeTo, CALENDAR);\n    }\n    // First convert time units up to days, if rounding to days or higher units.\n    // If rounding relative to a ZonedDateTime, then some days may not be 24h.\n    // TS doesn't know that `dayLengthNs` is only used if the unit is day or\n    // larger. We'll cast away `undefined` when it's used lower down below.\n    let dayLengthNs;\n    if (unit === 'year' || unit === 'month' || unit === 'week' || unit === 'day') {\n        nanoseconds = TotalDurationNanoseconds(0, hours, minutes, seconds, milliseconds, microseconds, nanosecondsParam, 0);\n        let intermediate;\n        if (zdtRelative) {\n            intermediate = MoveRelativeZonedDateTime(zdtRelative, years, months, weeks, days);\n        }\n        let deltaDays;\n        let dayLength;\n        ({ days: deltaDays, nanoseconds, dayLengthNs: dayLength } = NanosecondsToDays(nanoseconds, intermediate));\n        dayLengthNs = jsbi_umd.BigInt(dayLength);\n        days += deltaDays;\n        hours = minutes = seconds = milliseconds = microseconds = 0;\n    }\n    let total;\n    switch (unit) {\n        case 'year': {\n            if (!calendar)\n                throw new RangeError('A starting point is required for years rounding');\n            // convert months and weeks to days by calculating difference(\n            // relativeTo + years, relativeTo + { years, months, weeks })\n            const yearsDuration = new TemporalDuration(years);\n            const dateAdd = calendar.dateAdd;\n            const firstAddOptions = ObjectCreate$2(null);\n            const yearsLater = CalendarDateAdd(calendar, relativeTo, yearsDuration, firstAddOptions, dateAdd);\n            const yearsMonthsWeeks = new TemporalDuration(years, months, weeks);\n            const secondAddOptions = ObjectCreate$2(null);\n            const yearsMonthsWeeksLater = CalendarDateAdd(calendar, relativeTo, yearsMonthsWeeks, secondAddOptions, dateAdd);\n            const monthsWeeksInDays = DaysUntil(yearsLater, yearsMonthsWeeksLater);\n            relativeTo = yearsLater;\n            days += monthsWeeksInDays;\n            const thirdAddOptions = ObjectCreate$2(null);\n            const daysLater = CalendarDateAdd(calendar, relativeTo, { days }, thirdAddOptions, dateAdd);\n            const untilOptions = ObjectCreate$2(null);\n            untilOptions.largestUnit = 'year';\n            const yearsPassed = CalendarDateUntil(calendar, relativeTo, daysLater, untilOptions).years;\n            years += yearsPassed;\n            const oldRelativeTo = relativeTo;\n            const fourthAddOptions = ObjectCreate$2(null);\n            relativeTo = CalendarDateAdd(calendar, relativeTo, { years: yearsPassed }, fourthAddOptions, dateAdd);\n            const daysPassed = DaysUntil(oldRelativeTo, relativeTo);\n            days -= daysPassed;\n            const oneYear = new TemporalDuration(days < 0 ? -1 : 1);\n            let { days: oneYearDays } = MoveRelativeDate(calendar, relativeTo, oneYear);\n            // Note that `nanoseconds` below (here and in similar code for months,\n            // weeks, and days further below) isn't actually nanoseconds for the\n            // full date range.  Instead, it's a BigInt representation of total\n            // days multiplied by the number of nanoseconds in the last day of\n            // the duration. This lets us do days-or-larger rounding using BigInt\n            // math which reduces precision loss.\n            oneYearDays = MathAbs(oneYearDays);\n            // dayLengthNs is never undefined if unit is `day` or larger.\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            const divisor = jsbi_umd.multiply(jsbi_umd.BigInt(oneYearDays), dayLengthNs);\n            nanoseconds = jsbi_umd.add(\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            jsbi_umd.add(jsbi_umd.multiply(divisor, jsbi_umd.BigInt(years)), jsbi_umd.multiply(jsbi_umd.BigInt(days), dayLengthNs)), nanoseconds);\n            const rounded = RoundNumberToIncrement(nanoseconds, jsbi_umd.toNumber(jsbi_umd.multiply(divisor, jsbi_umd.BigInt(increment))), roundingMode);\n            total = jsbi_umd.toNumber(nanoseconds) / jsbi_umd.toNumber(divisor);\n            years = jsbi_umd.toNumber(jsbi_umd.divide(rounded, divisor));\n            nanoseconds = ZERO;\n            months = weeks = days = 0;\n            break;\n        }\n        case 'month': {\n            if (!calendar)\n                throw new RangeError('A starting point is required for months rounding');\n            // convert weeks to days by calculating difference(relativeTo +\n            //   { years, months }, relativeTo + { years, months, weeks })\n            const yearsMonths = new TemporalDuration(years, months);\n            const dateAdd = calendar.dateAdd;\n            const firstAddOptions = ObjectCreate$2(null);\n            const yearsMonthsLater = CalendarDateAdd(calendar, relativeTo, yearsMonths, firstAddOptions, dateAdd);\n            const yearsMonthsWeeks = new TemporalDuration(years, months, weeks);\n            const secondAddOptions = ObjectCreate$2(null);\n            const yearsMonthsWeeksLater = CalendarDateAdd(calendar, relativeTo, yearsMonthsWeeks, secondAddOptions, dateAdd);\n            const weeksInDays = DaysUntil(yearsMonthsLater, yearsMonthsWeeksLater);\n            relativeTo = yearsMonthsLater;\n            days += weeksInDays;\n            // Months may be different lengths of days depending on the calendar,\n            // convert days to months in a loop as described above under 'years'.\n            const sign = MathSign(days);\n            const oneMonth = new TemporalDuration(0, days < 0 ? -1 : 1);\n            let oneMonthDays;\n            ({ relativeTo, days: oneMonthDays } = MoveRelativeDate(calendar, relativeTo, oneMonth));\n            while (MathAbs(days) >= MathAbs(oneMonthDays)) {\n                months += sign;\n                days -= oneMonthDays;\n                ({ relativeTo, days: oneMonthDays } = MoveRelativeDate(calendar, relativeTo, oneMonth));\n            }\n            oneMonthDays = MathAbs(oneMonthDays);\n            // dayLengthNs is never undefined if unit is `day` or larger.\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            const divisor = jsbi_umd.multiply(jsbi_umd.BigInt(oneMonthDays), dayLengthNs);\n            nanoseconds = jsbi_umd.add(\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            jsbi_umd.add(jsbi_umd.multiply(divisor, jsbi_umd.BigInt(months)), jsbi_umd.multiply(jsbi_umd.BigInt(days), dayLengthNs)), nanoseconds);\n            const rounded = RoundNumberToIncrement(nanoseconds, jsbi_umd.toNumber(jsbi_umd.multiply(divisor, jsbi_umd.BigInt(increment))), roundingMode);\n            total = jsbi_umd.toNumber(nanoseconds) / jsbi_umd.toNumber(divisor);\n            months = jsbi_umd.toNumber(jsbi_umd.divide(rounded, divisor));\n            nanoseconds = ZERO;\n            weeks = days = 0;\n            break;\n        }\n        case 'week': {\n            if (!calendar)\n                throw new RangeError('A starting point is required for weeks rounding');\n            // Weeks may be different lengths of days depending on the calendar,\n            // convert days to weeks in a loop as described above under 'years'.\n            const sign = MathSign(days);\n            const oneWeek = new TemporalDuration(0, 0, days < 0 ? -1 : 1);\n            let oneWeekDays;\n            ({ relativeTo, days: oneWeekDays } = MoveRelativeDate(calendar, relativeTo, oneWeek));\n            while (MathAbs(days) >= MathAbs(oneWeekDays)) {\n                weeks += sign;\n                days -= oneWeekDays;\n                ({ relativeTo, days: oneWeekDays } = MoveRelativeDate(calendar, relativeTo, oneWeek));\n            }\n            oneWeekDays = MathAbs(oneWeekDays);\n            // dayLengthNs is never undefined if unit is `day` or larger.\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            const divisor = jsbi_umd.multiply(jsbi_umd.BigInt(oneWeekDays), dayLengthNs);\n            nanoseconds = jsbi_umd.add(\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            jsbi_umd.add(jsbi_umd.multiply(divisor, jsbi_umd.BigInt(weeks)), jsbi_umd.multiply(jsbi_umd.BigInt(days), dayLengthNs)), nanoseconds);\n            const rounded = RoundNumberToIncrement(nanoseconds, jsbi_umd.toNumber(jsbi_umd.multiply(divisor, jsbi_umd.BigInt(increment))), roundingMode);\n            total = jsbi_umd.toNumber(nanoseconds) / jsbi_umd.toNumber(divisor);\n            weeks = jsbi_umd.toNumber(jsbi_umd.divide(rounded, divisor));\n            nanoseconds = ZERO;\n            days = 0;\n            break;\n        }\n        case 'day': {\n            // dayLengthNs is never undefined if unit is `day` or larger.\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            const divisor = dayLengthNs;\n            nanoseconds = jsbi_umd.add(jsbi_umd.multiply(divisor, jsbi_umd.BigInt(days)), nanoseconds);\n            const rounded = RoundNumberToIncrement(nanoseconds, jsbi_umd.toNumber(jsbi_umd.multiply(divisor, jsbi_umd.BigInt(increment))), roundingMode);\n            total = jsbi_umd.toNumber(nanoseconds) / jsbi_umd.toNumber(divisor);\n            days = jsbi_umd.toNumber(jsbi_umd.divide(rounded, divisor));\n            nanoseconds = ZERO;\n            break;\n        }\n        case 'hour': {\n            const divisor = 3600e9;\n            let allNanoseconds = jsbi_umd.multiply(jsbi_umd.BigInt(hours), jsbi_umd.BigInt(3600e9));\n            allNanoseconds = jsbi_umd.add(allNanoseconds, jsbi_umd.multiply(jsbi_umd.BigInt(minutes), jsbi_umd.BigInt(60e9)));\n            allNanoseconds = jsbi_umd.add(allNanoseconds, jsbi_umd.multiply(jsbi_umd.BigInt(seconds), BILLION));\n            allNanoseconds = jsbi_umd.add(allNanoseconds, jsbi_umd.multiply(jsbi_umd.BigInt(milliseconds), MILLION));\n            allNanoseconds = jsbi_umd.add(allNanoseconds, jsbi_umd.multiply(jsbi_umd.BigInt(microseconds), THOUSAND));\n            allNanoseconds = jsbi_umd.add(allNanoseconds, nanoseconds);\n            total = jsbi_umd.toNumber(allNanoseconds) / divisor;\n            const rounded = RoundNumberToIncrement(allNanoseconds, divisor * increment, roundingMode);\n            hours = jsbi_umd.toNumber(jsbi_umd.divide(rounded, jsbi_umd.BigInt(divisor)));\n            nanoseconds = ZERO;\n            minutes = seconds = milliseconds = microseconds = 0;\n            break;\n        }\n        case 'minute': {\n            const divisor = 60e9;\n            let allNanoseconds = jsbi_umd.multiply(jsbi_umd.BigInt(minutes), jsbi_umd.BigInt(60e9));\n            allNanoseconds = jsbi_umd.add(allNanoseconds, jsbi_umd.multiply(jsbi_umd.BigInt(seconds), BILLION));\n            allNanoseconds = jsbi_umd.add(allNanoseconds, jsbi_umd.multiply(jsbi_umd.BigInt(milliseconds), MILLION));\n            allNanoseconds = jsbi_umd.add(allNanoseconds, jsbi_umd.multiply(jsbi_umd.BigInt(microseconds), THOUSAND));\n            allNanoseconds = jsbi_umd.add(allNanoseconds, nanoseconds);\n            total = jsbi_umd.toNumber(allNanoseconds) / divisor;\n            const rounded = RoundNumberToIncrement(allNanoseconds, divisor * increment, roundingMode);\n            minutes = jsbi_umd.toNumber(jsbi_umd.divide(rounded, jsbi_umd.BigInt(divisor)));\n            nanoseconds = ZERO;\n            seconds = milliseconds = microseconds = 0;\n            break;\n        }\n        case 'second': {\n            const divisor = 1e9;\n            let allNanoseconds = jsbi_umd.multiply(jsbi_umd.BigInt(seconds), BILLION);\n            allNanoseconds = jsbi_umd.add(allNanoseconds, jsbi_umd.multiply(jsbi_umd.BigInt(milliseconds), MILLION));\n            allNanoseconds = jsbi_umd.add(allNanoseconds, jsbi_umd.multiply(jsbi_umd.BigInt(microseconds), THOUSAND));\n            allNanoseconds = jsbi_umd.add(allNanoseconds, nanoseconds);\n            total = jsbi_umd.toNumber(allNanoseconds) / divisor;\n            const rounded = RoundNumberToIncrement(allNanoseconds, divisor * increment, roundingMode);\n            seconds = jsbi_umd.toNumber(jsbi_umd.divide(rounded, jsbi_umd.BigInt(divisor)));\n            nanoseconds = ZERO;\n            milliseconds = microseconds = 0;\n            break;\n        }\n        case 'millisecond': {\n            const divisor = 1e6;\n            let allNanoseconds = jsbi_umd.multiply(jsbi_umd.BigInt(milliseconds), MILLION);\n            allNanoseconds = jsbi_umd.add(allNanoseconds, jsbi_umd.multiply(jsbi_umd.BigInt(microseconds), THOUSAND));\n            allNanoseconds = jsbi_umd.add(allNanoseconds, nanoseconds);\n            total = jsbi_umd.toNumber(allNanoseconds) / divisor;\n            const rounded = RoundNumberToIncrement(allNanoseconds, divisor * increment, roundingMode);\n            milliseconds = jsbi_umd.toNumber(jsbi_umd.divide(rounded, jsbi_umd.BigInt(divisor)));\n            nanoseconds = ZERO;\n            microseconds = 0;\n            break;\n        }\n        case 'microsecond': {\n            const divisor = 1e3;\n            let allNanoseconds = jsbi_umd.multiply(jsbi_umd.BigInt(microseconds), THOUSAND);\n            allNanoseconds = jsbi_umd.add(allNanoseconds, nanoseconds);\n            total = jsbi_umd.toNumber(allNanoseconds) / divisor;\n            const rounded = RoundNumberToIncrement(allNanoseconds, divisor * increment, roundingMode);\n            microseconds = jsbi_umd.toNumber(jsbi_umd.divide(rounded, jsbi_umd.BigInt(divisor)));\n            nanoseconds = ZERO;\n            break;\n        }\n        case 'nanosecond': {\n            total = jsbi_umd.toNumber(nanoseconds);\n            nanoseconds = RoundNumberToIncrement(nanoseconds, increment, roundingMode);\n            break;\n        }\n    }\n    return {\n        years,\n        months,\n        weeks,\n        days,\n        hours,\n        minutes,\n        seconds,\n        milliseconds,\n        microseconds,\n        nanoseconds: jsbi_umd.toNumber(nanoseconds),\n        total\n    };\n}\nfunction CompareISODate(y1, m1, d1, y2, m2, d2) {\n    for (const [x, y] of [\n        [y1, y2],\n        [m1, m2],\n        [d1, d2]\n    ]) {\n        if (x !== y)\n            return ComparisonResult(x - y);\n    }\n    return 0;\n}\nfunction NonNegativeModulo(x, y) {\n    let result = x % y;\n    if (ObjectIs(result, -0))\n        return 0;\n    if (result < 0)\n        result += y;\n    return result;\n}\nfunction ToBigIntExternal(arg) {\n    const jsbiBI = ToBigInt(arg);\n    if (typeof globalThis.BigInt !== 'undefined')\n        return globalThis.BigInt(jsbiBI.toString(10));\n    return jsbiBI;\n}\nfunction ToBigInt(arg) {\n    if (arg instanceof jsbi_umd) {\n        return arg;\n    }\n    let prim = arg;\n    if (typeof arg === 'object') {\n        const toPrimFn = arg[Symbol.toPrimitive];\n        if (toPrimFn && typeof toPrimFn === 'function') {\n            prim = ReflectApply$1(toPrimFn, arg, ['number']);\n        }\n    }\n    switch (typeof prim) {\n        case 'undefined':\n        case 'object':\n        case 'number':\n        case 'symbol':\n        default:\n            throw new TypeError(`cannot convert ${typeof arg} to bigint`);\n        case 'string':\n            if (!prim.match(/^\\s*(?:[+-]?\\d+\\s*)?$/)) {\n                throw new SyntaxError('invalid BigInt syntax');\n            }\n        // eslint: no-fallthrough: false\n        case 'bigint':\n            try {\n                return jsbi_umd.BigInt(prim.toString());\n            }\n            catch (e) {\n                if (e instanceof Error && e.message.startsWith('Invalid integer'))\n                    throw new SyntaxError(e.message);\n                throw e;\n            }\n        case 'boolean':\n            if (prim) {\n                return ONE;\n            }\n            else {\n                return ZERO;\n            }\n    }\n}\n// Note: This method returns values with bogus nanoseconds based on the previous iteration's\n// milliseconds. That way there is a guarantee that the full nanoseconds are always going to be\n// increasing at least and that the microsecond and nanosecond fields are likely to be non-zero.\nconst SystemUTCEpochNanoSeconds = (() => {\n    let ns = jsbi_umd.BigInt(Date.now() % 1e6);\n    return () => {\n        const ms = jsbi_umd.BigInt(Date.now());\n        const result = jsbi_umd.add(jsbi_umd.multiply(ms, MILLION), ns);\n        ns = jsbi_umd.divide(ms, MILLION);\n        if (jsbi_umd.greaterThan(result, NS_MAX))\n            return NS_MAX;\n        if (jsbi_umd.lessThan(result, NS_MIN))\n            return NS_MIN;\n        return result;\n    };\n})();\nfunction SystemTimeZone() {\n    const fmt = new IntlDateTimeFormat$1('en-us');\n    const TemporalTimeZone = GetIntrinsic('%Temporal.TimeZone%');\n    return new TemporalTimeZone(ParseTemporalTimeZone(fmt.resolvedOptions().timeZone));\n}\nfunction ComparisonResult(value) {\n    return value < 0 ? -1 : value > 0 ? 1 : value;\n}\nfunction GetOptionsObject(options) {\n    if (options === undefined)\n        return ObjectCreate$2(null);\n    if (IsObject(options) && options !== null)\n        return options;\n    throw new TypeError(`Options parameter must be an object, not ${options === null ? 'null' : `${typeof options}`}`);\n}\nfunction CreateOnePropObject(propName, propValue) {\n    const o = ObjectCreate$2(null);\n    o[propName] = propValue;\n    return o;\n}\nfunction GetOption(options, property, allowedValues, fallback) {\n    let value = options[property];\n    if (value !== undefined) {\n        value = ToString(value);\n        if (!allowedValues.includes(value)) {\n            throw new RangeError(`${property} must be one of ${allowedValues.join(', ')}, not ${value}`);\n        }\n        return value;\n    }\n    return fallback;\n}\nfunction GetNumberOption(options, property, minimum, maximum, fallback) {\n    let valueRaw = options[property];\n    if (valueRaw === undefined)\n        return fallback;\n    const value = ToNumber(valueRaw);\n    if (NumberIsNaN(value) || value < minimum || value > maximum) {\n        throw new RangeError(`${property} must be between ${minimum} and ${maximum}, not ${value}`);\n    }\n    return MathFloor(value);\n}\nconst OFFSET = new RegExp(`^${offset.source}$`);\nfunction bisect(getState, leftParam, rightParam, lstateParam = getState(leftParam), rstateParam = getState(rightParam)) {\n    // This doesn't make much sense - why do these get converted unnecessarily?\n    let left = jsbi_umd.BigInt(leftParam);\n    let right = jsbi_umd.BigInt(rightParam);\n    let lstate = lstateParam;\n    let rstate = rstateParam;\n    while (jsbi_umd.greaterThan(jsbi_umd.subtract(right, left), ONE)) {\n        const middle = jsbi_umd.divide(jsbi_umd.add(left, right), jsbi_umd.BigInt(2));\n        const mstate = getState(middle);\n        if (mstate === lstate) {\n            left = middle;\n            lstate = mstate;\n        }\n        else if (mstate === rstate) {\n            right = middle;\n            rstate = mstate;\n        }\n        else {\n            throw new Error(`invalid state in bisection ${lstate} - ${mstate} - ${rstate}`);\n        }\n    }\n    return right;\n}\nconst nsPerTimeUnit = {\n    hour: 3600e9,\n    minute: 60e9,\n    second: 1e9,\n    millisecond: 1e6,\n    microsecond: 1e3,\n    nanosecond: 1\n};\n\nconst DATE = Symbol('date');\nconst YM = Symbol('ym');\nconst MD = Symbol('md');\nconst TIME = Symbol('time');\nconst DATETIME = Symbol('datetime');\nconst ZONED = Symbol('zoneddatetime');\nconst INST = Symbol('instant');\nconst ORIGINAL = Symbol('original');\nconst TZ_RESOLVED = Symbol('timezone');\nconst TZ_GIVEN = Symbol('timezone-id-given');\nconst CAL_ID = Symbol('calendar-id');\nconst LOCALE = Symbol('locale');\nconst OPTIONS = Symbol('options');\nconst descriptor = (value) => {\n    return {\n        value,\n        enumerable: true,\n        writable: false,\n        configurable: true\n    };\n};\nconst IntlDateTimeFormat = globalThis.Intl.DateTimeFormat;\nconst ObjectAssign$1 = Object.assign;\nconst ObjectHasOwnProperty = Object.prototype.hasOwnProperty;\nconst ReflectApply = Reflect.apply;\n// Construction of built-in Intl.DateTimeFormat objects is sloooooow,\n// so we'll only create those instances when we need them.\n// See https://bugs.chromium.org/p/v8/issues/detail?id=6528\nfunction getPropLazy(obj, prop) {\n    let val = obj[prop];\n    if (typeof val === 'function') {\n        // If we get here, `val` is an \"amender function\". It will take the user's\n        // options and transform them into suitable options to be passed into the\n        // built-in (non-polyfill) Intl.DateTimeFormat constructor. These options\n        // will vary depending on the Temporal type, so that's why we store separate\n        // formatters in separate props on the polyfill's DateTimeFormat instances.\n        // The efficiency happens because we don't create an (expensive) formatter\n        // until the user calls toLocaleString for that Temporal type.\n        val = new IntlDateTimeFormat(obj[LOCALE], val(obj[OPTIONS]));\n        // TODO: can this be typed more cleanly?\n        obj[prop] = val;\n    }\n    return val;\n}\n// Similarly, lazy-init TimeZone instances.\nfunction getResolvedTimeZoneLazy(obj) {\n    let val = obj[TZ_RESOLVED];\n    if (typeof val === 'string') {\n        val = ToTemporalTimeZone(val);\n        obj[TZ_RESOLVED] = val;\n    }\n    return val;\n}\nfunction DateTimeFormatImpl(locale = undefined, optionsParam = {}) {\n    if (!(this instanceof DateTimeFormatImpl)) {\n        return new DateTimeFormatImpl(locale, optionsParam);\n    }\n    const hasOptions = typeof optionsParam !== 'undefined';\n    const options = hasOptions ? ObjectAssign$1({}, optionsParam) : {};\n    // TODO: remove type assertion after Temporal types land in TS lib types\n    const original = new IntlDateTimeFormat(locale, options);\n    const ro = original.resolvedOptions();\n    // DateTimeFormat instances are very expensive to create. Therefore, they will\n    // be lazily created only when needed, using the locale and options provided.\n    // But it's possible for callers to mutate those inputs before lazy creation\n    // happens. For this reason, we clone the inputs instead of caching the\n    // original objects. To avoid the complexity of deep cloning any inputs that\n    // are themselves objects (e.g. the locales array, or options property values\n    // that will be coerced to strings), we rely on `resolvedOptions()` to do the\n    // coercion and cloning for us. Unfortunately, we can't just use the resolved\n    // options as-is because our options-amending logic adds additional fields if\n    // the user doesn't supply any unit fields like year, month, day, hour, etc.\n    // Therefore, we limit the properties in the clone to properties that were\n    // present in the original input.\n    if (hasOptions) {\n        const clonedResolved = ObjectAssign$1({}, ro);\n        for (const prop in clonedResolved) {\n            if (!ReflectApply(ObjectHasOwnProperty, options, [prop])) {\n                delete clonedResolved[prop];\n            }\n        }\n        this[OPTIONS] = clonedResolved;\n    }\n    else {\n        this[OPTIONS] = options;\n    }\n    this[TZ_GIVEN] = options.timeZone ? options.timeZone : null;\n    this[LOCALE] = ro.locale;\n    this[ORIGINAL] = original;\n    this[TZ_RESOLVED] = ro.timeZone;\n    this[CAL_ID] = ro.calendar;\n    this[DATE] = dateAmend;\n    this[YM] = yearMonthAmend;\n    this[MD] = monthDayAmend;\n    this[TIME] = timeAmend;\n    this[DATETIME] = datetimeAmend;\n    this[ZONED] = zonedDateTimeAmend;\n    this[INST] = instantAmend;\n    return undefined; // TODO: I couldn't satisfy TS without adding this. Is there another way?\n}\nObject.defineProperty(DateTimeFormatImpl, 'name', {\n    writable: true,\n    value: 'DateTimeFormat'\n});\nDateTimeFormatImpl.supportedLocalesOf = function (locales, options) {\n    return IntlDateTimeFormat.supportedLocalesOf(locales, options);\n};\nconst properties = {\n    resolvedOptions: descriptor(resolvedOptions),\n    format: descriptor(format),\n    formatRange: descriptor(formatRange)\n};\nif ('formatToParts' in IntlDateTimeFormat.prototype) {\n    properties.formatToParts = descriptor(formatToParts);\n}\nif ('formatRangeToParts' in IntlDateTimeFormat.prototype) {\n    properties.formatRangeToParts = descriptor(formatRangeToParts);\n}\nDateTimeFormatImpl.prototype = Object.create(IntlDateTimeFormat.prototype, properties);\n// Ensure that the prototype isn't writeable.\nObject.defineProperty(DateTimeFormatImpl, 'prototype', {\n    writable: false,\n    enumerable: false,\n    configurable: false\n});\nconst DateTimeFormat = DateTimeFormatImpl;\nfunction resolvedOptions() {\n    return this[ORIGINAL].resolvedOptions();\n}\nfunction adjustFormatterTimeZone(formatter, timeZone) {\n    if (!timeZone)\n        return formatter;\n    const options = formatter.resolvedOptions();\n    if (options.timeZone === timeZone)\n        return formatter;\n    // Existing Intl isn't typed to accept Temporal-specific options, but will not\n    // break at runtime if we pass them. Also, the lib types for resolved options\n    // are less restrictive than the types for options. For example, `weekday` is\n    // `'long' | 'short' | 'narrow'` in options but `string` in resolved options.\n    // TODO: investigate why, and file an issue against TS if it's a bug.\n    return new IntlDateTimeFormat(options.locale, { ...options, timeZone });\n}\n// TODO: investigate why there's a rest parameter here. Does this function really need to accept extra params?\n// And if so, why doesn't formatRange also accept extra params?\nfunction format(datetime, ...rest) {\n    let { instant, formatter, timeZone } = extractOverrides(datetime, this);\n    if (instant && formatter) {\n        formatter = adjustFormatterTimeZone(formatter, timeZone);\n        return formatter.format(instant.epochMilliseconds);\n    }\n    return this[ORIGINAL].format(datetime, ...rest);\n}\nfunction formatToParts(datetime, ...rest) {\n    let { instant, formatter, timeZone } = extractOverrides(datetime, this);\n    if (instant && formatter) {\n        formatter = adjustFormatterTimeZone(formatter, timeZone);\n        return formatter.formatToParts(instant.epochMilliseconds);\n    }\n    return this[ORIGINAL].formatToParts(datetime, ...rest);\n}\nfunction formatRange(a, b) {\n    if (isTemporalObject(a) || isTemporalObject(b)) {\n        if (!sameTemporalType(a, b)) {\n            throw new TypeError('Intl.DateTimeFormat.formatRange accepts two values of the same type');\n        }\n        const { instant: aa, formatter: aformatter, timeZone: atz } = extractOverrides(a, this);\n        const { instant: bb, formatter: bformatter, timeZone: btz } = extractOverrides(b, this);\n        if (atz && btz && atz !== btz) {\n            throw new RangeError('cannot format range between different time zones');\n        }\n        if (aa && bb && aformatter && bformatter && aformatter === bformatter) {\n            const formatter = adjustFormatterTimeZone(aformatter, atz);\n            // TODO: Remove type assertion after this method lands in TS lib types\n            return formatter.formatRange(aa.epochMilliseconds, bb.epochMilliseconds);\n        }\n    }\n    // TODO: Remove type assertion after this method lands in TS lib types\n    return this[ORIGINAL].formatRange(a, b);\n}\nfunction formatRangeToParts(a, b) {\n    if (isTemporalObject(a) || isTemporalObject(b)) {\n        if (!sameTemporalType(a, b)) {\n            throw new TypeError('Intl.DateTimeFormat.formatRangeToParts accepts two values of the same type');\n        }\n        const { instant: aa, formatter: aformatter, timeZone: atz } = extractOverrides(a, this);\n        const { instant: bb, formatter: bformatter, timeZone: btz } = extractOverrides(b, this);\n        if (atz && btz && atz !== btz) {\n            throw new RangeError('cannot format range between different time zones');\n        }\n        if (aa && bb && aformatter && bformatter && aformatter === bformatter) {\n            const formatter = adjustFormatterTimeZone(aformatter, atz);\n            // TODO: Remove type assertion after this method lands in TS lib types\n            return formatter.formatRangeToParts(aa.epochMilliseconds, bb.epochMilliseconds);\n        }\n    }\n    // TODO: Remove type assertion after this method lands in TS lib types\n    return this[ORIGINAL].formatRangeToParts(a, b);\n}\nfunction amend(optionsParam = {}, amended = {}) {\n    const options = ObjectAssign$1({}, optionsParam);\n    for (const opt of [\n        'year',\n        'month',\n        'day',\n        'hour',\n        'minute',\n        'second',\n        'weekday',\n        'dayPeriod',\n        'timeZoneName',\n        'dateStyle',\n        'timeStyle'\n    ]) {\n        options[opt] = opt in amended ? amended[opt] : options[opt];\n        if (options[opt] === false || options[opt] === undefined)\n            delete options[opt];\n    }\n    return options;\n}\nfunction timeAmend(optionsParam) {\n    let options = amend(optionsParam, {\n        year: false,\n        month: false,\n        day: false,\n        weekday: false,\n        timeZoneName: false,\n        dateStyle: false\n    });\n    if (!hasTimeOptions(options)) {\n        options = ObjectAssign$1({}, options, {\n            hour: 'numeric',\n            minute: 'numeric',\n            second: 'numeric'\n        });\n    }\n    return options;\n}\nfunction yearMonthAmend(optionsParam) {\n    let options = amend(optionsParam, {\n        day: false,\n        hour: false,\n        minute: false,\n        second: false,\n        weekday: false,\n        dayPeriod: false,\n        timeZoneName: false,\n        dateStyle: false,\n        timeStyle: false\n    });\n    if (!('year' in options || 'month' in options)) {\n        options = ObjectAssign$1(options, { year: 'numeric', month: 'numeric' });\n    }\n    return options;\n}\nfunction monthDayAmend(optionsParam) {\n    let options = amend(optionsParam, {\n        year: false,\n        hour: false,\n        minute: false,\n        second: false,\n        weekday: false,\n        dayPeriod: false,\n        timeZoneName: false,\n        dateStyle: false,\n        timeStyle: false\n    });\n    if (!('month' in options || 'day' in options)) {\n        options = ObjectAssign$1({}, options, { month: 'numeric', day: 'numeric' });\n    }\n    return options;\n}\nfunction dateAmend(optionsParam) {\n    let options = amend(optionsParam, {\n        hour: false,\n        minute: false,\n        second: false,\n        dayPeriod: false,\n        timeZoneName: false,\n        timeStyle: false\n    });\n    if (!hasDateOptions(options)) {\n        options = ObjectAssign$1({}, options, {\n            year: 'numeric',\n            month: 'numeric',\n            day: 'numeric'\n        });\n    }\n    return options;\n}\nfunction datetimeAmend(optionsParam) {\n    let options = amend(optionsParam, { timeZoneName: false });\n    if (!hasTimeOptions(options) && !hasDateOptions(options)) {\n        options = ObjectAssign$1({}, options, {\n            year: 'numeric',\n            month: 'numeric',\n            day: 'numeric',\n            hour: 'numeric',\n            minute: 'numeric',\n            second: 'numeric'\n        });\n    }\n    return options;\n}\nfunction zonedDateTimeAmend(optionsParam) {\n    let options = optionsParam;\n    if (!hasTimeOptions(options) && !hasDateOptions(options)) {\n        options = ObjectAssign$1({}, options, {\n            year: 'numeric',\n            month: 'numeric',\n            day: 'numeric',\n            hour: 'numeric',\n            minute: 'numeric',\n            second: 'numeric'\n        });\n        if (options.timeZoneName === undefined)\n            options.timeZoneName = 'short';\n    }\n    return options;\n}\nfunction instantAmend(optionsParam) {\n    let options = optionsParam;\n    if (!hasTimeOptions(options) && !hasDateOptions(options)) {\n        options = ObjectAssign$1({}, options, {\n            year: 'numeric',\n            month: 'numeric',\n            day: 'numeric',\n            hour: 'numeric',\n            minute: 'numeric',\n            second: 'numeric'\n        });\n    }\n    return options;\n}\nfunction hasDateOptions(options) {\n    return 'year' in options || 'month' in options || 'day' in options || 'weekday' in options || 'dateStyle' in options;\n}\nfunction hasTimeOptions(options) {\n    return ('hour' in options || 'minute' in options || 'second' in options || 'timeStyle' in options || 'dayPeriod' in options);\n}\nfunction isTemporalObject(obj) {\n    return (IsTemporalDate(obj) ||\n        IsTemporalTime(obj) ||\n        IsTemporalDateTime(obj) ||\n        IsTemporalZonedDateTime(obj) ||\n        IsTemporalYearMonth(obj) ||\n        IsTemporalMonthDay(obj) ||\n        IsTemporalInstant(obj));\n}\nfunction sameTemporalType(x, y) {\n    if (!isTemporalObject(x) || !isTemporalObject(y))\n        return false;\n    if (IsTemporalTime(x) && !IsTemporalTime(y))\n        return false;\n    if (IsTemporalDate(x) && !IsTemporalDate(y))\n        return false;\n    if (IsTemporalDateTime(x) && !IsTemporalDateTime(y))\n        return false;\n    if (IsTemporalZonedDateTime(x) && !IsTemporalZonedDateTime(y))\n        return false;\n    if (IsTemporalYearMonth(x) && !IsTemporalYearMonth(y))\n        return false;\n    if (IsTemporalMonthDay(x) && !IsTemporalMonthDay(y))\n        return false;\n    if (IsTemporalInstant(x) && !IsTemporalInstant(y))\n        return false;\n    return true;\n}\nfunction extractOverrides(temporalObj, main) {\n    const DateTime = GetIntrinsic('%Temporal.PlainDateTime%');\n    if (IsTemporalTime(temporalObj)) {\n        const hour = GetSlot(temporalObj, ISO_HOUR);\n        const minute = GetSlot(temporalObj, ISO_MINUTE);\n        const second = GetSlot(temporalObj, ISO_SECOND);\n        const millisecond = GetSlot(temporalObj, ISO_MILLISECOND);\n        const microsecond = GetSlot(temporalObj, ISO_MICROSECOND);\n        const nanosecond = GetSlot(temporalObj, ISO_NANOSECOND);\n        const datetime = new DateTime(1970, 1, 1, hour, minute, second, millisecond, microsecond, nanosecond, main[CAL_ID]);\n        return {\n            instant: BuiltinTimeZoneGetInstantFor(getResolvedTimeZoneLazy(main), datetime, 'compatible'),\n            formatter: getPropLazy(main, TIME)\n        };\n    }\n    if (IsTemporalYearMonth(temporalObj)) {\n        const isoYear = GetSlot(temporalObj, ISO_YEAR);\n        const isoMonth = GetSlot(temporalObj, ISO_MONTH);\n        const referenceISODay = GetSlot(temporalObj, ISO_DAY);\n        const calendar = ToString(GetSlot(temporalObj, CALENDAR));\n        if (calendar !== main[CAL_ID]) {\n            throw new RangeError(`cannot format PlainYearMonth with calendar ${calendar} in locale with calendar ${main[CAL_ID]}`);\n        }\n        const datetime = new DateTime(isoYear, isoMonth, referenceISODay, 12, 0, 0, 0, 0, 0, calendar);\n        return {\n            instant: BuiltinTimeZoneGetInstantFor(getResolvedTimeZoneLazy(main), datetime, 'compatible'),\n            formatter: getPropLazy(main, YM)\n        };\n    }\n    if (IsTemporalMonthDay(temporalObj)) {\n        const referenceISOYear = GetSlot(temporalObj, ISO_YEAR);\n        const isoMonth = GetSlot(temporalObj, ISO_MONTH);\n        const isoDay = GetSlot(temporalObj, ISO_DAY);\n        const calendar = ToString(GetSlot(temporalObj, CALENDAR));\n        if (calendar !== main[CAL_ID]) {\n            throw new RangeError(`cannot format PlainMonthDay with calendar ${calendar} in locale with calendar ${main[CAL_ID]}`);\n        }\n        const datetime = new DateTime(referenceISOYear, isoMonth, isoDay, 12, 0, 0, 0, 0, 0, calendar);\n        return {\n            instant: BuiltinTimeZoneGetInstantFor(getResolvedTimeZoneLazy(main), datetime, 'compatible'),\n            formatter: getPropLazy(main, MD)\n        };\n    }\n    if (IsTemporalDate(temporalObj)) {\n        const isoYear = GetSlot(temporalObj, ISO_YEAR);\n        const isoMonth = GetSlot(temporalObj, ISO_MONTH);\n        const isoDay = GetSlot(temporalObj, ISO_DAY);\n        const calendar = ToString(GetSlot(temporalObj, CALENDAR));\n        if (calendar !== 'iso8601' && calendar !== main[CAL_ID]) {\n            throw new RangeError(`cannot format PlainDate with calendar ${calendar} in locale with calendar ${main[CAL_ID]}`);\n        }\n        const datetime = new DateTime(isoYear, isoMonth, isoDay, 12, 0, 0, 0, 0, 0, main[CAL_ID]);\n        return {\n            instant: BuiltinTimeZoneGetInstantFor(getResolvedTimeZoneLazy(main), datetime, 'compatible'),\n            formatter: getPropLazy(main, DATE)\n        };\n    }\n    if (IsTemporalDateTime(temporalObj)) {\n        const isoYear = GetSlot(temporalObj, ISO_YEAR);\n        const isoMonth = GetSlot(temporalObj, ISO_MONTH);\n        const isoDay = GetSlot(temporalObj, ISO_DAY);\n        const hour = GetSlot(temporalObj, ISO_HOUR);\n        const minute = GetSlot(temporalObj, ISO_MINUTE);\n        const second = GetSlot(temporalObj, ISO_SECOND);\n        const millisecond = GetSlot(temporalObj, ISO_MILLISECOND);\n        const microsecond = GetSlot(temporalObj, ISO_MICROSECOND);\n        const nanosecond = GetSlot(temporalObj, ISO_NANOSECOND);\n        const calendar = ToString(GetSlot(temporalObj, CALENDAR));\n        if (calendar !== 'iso8601' && calendar !== main[CAL_ID]) {\n            throw new RangeError(`cannot format PlainDateTime with calendar ${calendar} in locale with calendar ${main[CAL_ID]}`);\n        }\n        let datetime = temporalObj;\n        if (calendar === 'iso8601') {\n            datetime = new DateTime(isoYear, isoMonth, isoDay, hour, minute, second, millisecond, microsecond, nanosecond, main[CAL_ID]);\n        }\n        return {\n            instant: BuiltinTimeZoneGetInstantFor(getResolvedTimeZoneLazy(main), datetime, 'compatible'),\n            formatter: getPropLazy(main, DATETIME)\n        };\n    }\n    if (IsTemporalZonedDateTime(temporalObj)) {\n        const calendar = ToString(GetSlot(temporalObj, CALENDAR));\n        if (calendar !== 'iso8601' && calendar !== main[CAL_ID]) {\n            throw new RangeError(`cannot format ZonedDateTime with calendar ${calendar} in locale with calendar ${main[CAL_ID]}`);\n        }\n        const timeZone = GetSlot(temporalObj, TIME_ZONE);\n        const objTimeZone = ToString(timeZone);\n        if (main[TZ_GIVEN] && main[TZ_GIVEN] !== objTimeZone) {\n            throw new RangeError(`timeZone option ${main[TZ_GIVEN]} doesn't match actual time zone ${objTimeZone}`);\n        }\n        return {\n            instant: GetSlot(temporalObj, INSTANT),\n            formatter: getPropLazy(main, ZONED),\n            timeZone: objTimeZone\n        };\n    }\n    if (IsTemporalInstant(temporalObj)) {\n        return {\n            instant: temporalObj,\n            formatter: getPropLazy(main, INST)\n        };\n    }\n    return {};\n}\n\nvar intl = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    DateTimeFormat: DateTimeFormat\n});\n\nconst DISALLOWED_UNITS$3 = ['year', 'month', 'week', 'day'];\nconst MAX_DIFFERENCE_INCREMENTS = {\n    hour: 24,\n    minute: 60,\n    second: 60,\n    millisecond: 1000,\n    microsecond: 1000,\n    nanosecond: 1000\n};\nclass Instant {\n    constructor(epochNanoseconds) {\n        // Note: if the argument is not passed, ToBigInt(undefined) will throw. This check exists only\n        //       to improve the error message.\n        if (arguments.length < 1) {\n            throw new TypeError('missing argument: epochNanoseconds is required');\n        }\n        const ns = ToBigInt(epochNanoseconds);\n        ValidateEpochNanoseconds(ns);\n        CreateSlots(this);\n        SetSlot(this, EPOCHNANOSECONDS, ns);\n        {\n            const repr = TemporalInstantToString(this, undefined, 'auto');\n            Object.defineProperty(this, '_repr_', {\n                value: `${this[Symbol.toStringTag]} <${repr}>`,\n                writable: false,\n                enumerable: false,\n                configurable: false\n            });\n        }\n    }\n    get epochSeconds() {\n        if (!IsTemporalInstant(this))\n            throw new TypeError('invalid receiver');\n        const value = GetSlot(this, EPOCHNANOSECONDS);\n        return jsbi_umd.toNumber(jsbi_umd.divide(value, BILLION));\n    }\n    get epochMilliseconds() {\n        if (!IsTemporalInstant(this))\n            throw new TypeError('invalid receiver');\n        const value = jsbi_umd.BigInt(GetSlot(this, EPOCHNANOSECONDS));\n        return jsbi_umd.toNumber(jsbi_umd.divide(value, MILLION));\n    }\n    get epochMicroseconds() {\n        if (!IsTemporalInstant(this))\n            throw new TypeError('invalid receiver');\n        const value = jsbi_umd.BigInt(GetSlot(this, EPOCHNANOSECONDS));\n        return ToBigIntExternal(jsbi_umd.divide(value, THOUSAND));\n    }\n    get epochNanoseconds() {\n        if (!IsTemporalInstant(this))\n            throw new TypeError('invalid receiver');\n        return ToBigIntExternal(jsbi_umd.BigInt(GetSlot(this, EPOCHNANOSECONDS)));\n    }\n    add(temporalDurationLike) {\n        if (!IsTemporalInstant(this))\n            throw new TypeError('invalid receiver');\n        const { hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = ToLimitedTemporalDuration(temporalDurationLike, ['years', 'months', 'weeks', 'days']);\n        const ns = AddInstant(GetSlot(this, EPOCHNANOSECONDS), hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n        return new Instant(ns);\n    }\n    subtract(temporalDurationLike) {\n        if (!IsTemporalInstant(this))\n            throw new TypeError('invalid receiver');\n        const { hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = ToLimitedTemporalDuration(temporalDurationLike, ['years', 'months', 'weeks', 'days']);\n        const ns = AddInstant(GetSlot(this, EPOCHNANOSECONDS), -hours, -minutes, -seconds, -milliseconds, -microseconds, -nanoseconds);\n        return new Instant(ns);\n    }\n    until(otherParam, optionsParam = undefined) {\n        if (!IsTemporalInstant(this))\n            throw new TypeError('invalid receiver');\n        const other = ToTemporalInstant(otherParam);\n        const options = GetOptionsObject(optionsParam);\n        const smallestUnit = ToSmallestTemporalUnit(options, 'nanosecond', DISALLOWED_UNITS$3);\n        const defaultLargestUnit = LargerOfTwoTemporalUnits('second', smallestUnit);\n        const largestUnit = ToLargestTemporalUnit(options, 'auto', DISALLOWED_UNITS$3, defaultLargestUnit);\n        ValidateTemporalUnitRange(largestUnit, smallestUnit);\n        const roundingMode = ToTemporalRoundingMode(options, 'trunc');\n        const roundingIncrement = ToTemporalRoundingIncrement(options, MAX_DIFFERENCE_INCREMENTS[smallestUnit], false);\n        const onens = GetSlot(this, EPOCHNANOSECONDS);\n        const twons = GetSlot(other, EPOCHNANOSECONDS);\n        let { seconds, milliseconds, microseconds, nanoseconds } = DifferenceInstant(onens, twons, roundingIncrement, smallestUnit, roundingMode);\n        let hours, minutes;\n        ({ hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = BalanceDuration(0, 0, 0, seconds, milliseconds, microseconds, nanoseconds, largestUnit));\n        const Duration = GetIntrinsic('%Temporal.Duration%');\n        return new Duration(0, 0, 0, 0, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n    }\n    since(otherParam, optionsParam = undefined) {\n        if (!IsTemporalInstant(this))\n            throw new TypeError('invalid receiver');\n        const other = ToTemporalInstant(otherParam);\n        const options = GetOptionsObject(optionsParam);\n        const smallestUnit = ToSmallestTemporalUnit(options, 'nanosecond', DISALLOWED_UNITS$3);\n        const defaultLargestUnit = LargerOfTwoTemporalUnits('second', smallestUnit);\n        const largestUnit = ToLargestTemporalUnit(options, 'auto', DISALLOWED_UNITS$3, defaultLargestUnit);\n        ValidateTemporalUnitRange(largestUnit, smallestUnit);\n        const roundingMode = ToTemporalRoundingMode(options, 'trunc');\n        const roundingIncrement = ToTemporalRoundingIncrement(options, MAX_DIFFERENCE_INCREMENTS[smallestUnit], false);\n        const onens = GetSlot(other, EPOCHNANOSECONDS);\n        const twons = GetSlot(this, EPOCHNANOSECONDS);\n        let { seconds, milliseconds, microseconds, nanoseconds } = DifferenceInstant(onens, twons, roundingIncrement, smallestUnit, roundingMode);\n        let hours, minutes;\n        ({ hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = BalanceDuration(0, 0, 0, seconds, milliseconds, microseconds, nanoseconds, largestUnit));\n        const Duration = GetIntrinsic('%Temporal.Duration%');\n        return new Duration(0, 0, 0, 0, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n    }\n    round(optionsParam) {\n        if (!IsTemporalInstant(this))\n            throw new TypeError('invalid receiver');\n        if (optionsParam === undefined)\n            throw new TypeError('options parameter is required');\n        const options = typeof optionsParam === 'string'\n            ? CreateOnePropObject('smallestUnit', optionsParam)\n            : GetOptionsObject(optionsParam);\n        const smallestUnit = ToSmallestTemporalUnit(options, undefined, DISALLOWED_UNITS$3);\n        if (smallestUnit === undefined)\n            throw new RangeError('smallestUnit is required');\n        const roundingMode = ToTemporalRoundingMode(options, 'halfExpand');\n        const maximumIncrements = {\n            hour: 24,\n            minute: 1440,\n            second: 86400,\n            millisecond: 86400e3,\n            microsecond: 86400e6,\n            nanosecond: 86400e9\n        };\n        const roundingIncrement = ToTemporalRoundingIncrement(options, maximumIncrements[smallestUnit], true);\n        const ns = GetSlot(this, EPOCHNANOSECONDS);\n        const roundedNs = RoundInstant(ns, roundingIncrement, smallestUnit, roundingMode);\n        return new Instant(roundedNs);\n    }\n    equals(otherParam) {\n        if (!IsTemporalInstant(this))\n            throw new TypeError('invalid receiver');\n        const other = ToTemporalInstant(otherParam);\n        const one = GetSlot(this, EPOCHNANOSECONDS);\n        const two = GetSlot(other, EPOCHNANOSECONDS);\n        return jsbi_umd.equal(jsbi_umd.BigInt(one), jsbi_umd.BigInt(two));\n    }\n    toString(optionsParam = undefined) {\n        if (!IsTemporalInstant(this))\n            throw new TypeError('invalid receiver');\n        const options = GetOptionsObject(optionsParam);\n        let timeZone = options.timeZone;\n        if (timeZone !== undefined)\n            timeZone = ToTemporalTimeZone(timeZone);\n        // Although TS doesn't acknowledge it, below here `timeZone` is a Temporal.TimeZoneProtocol\n        const { precision, unit, increment } = ToSecondsStringPrecision(options);\n        const roundingMode = ToTemporalRoundingMode(options, 'trunc');\n        const ns = GetSlot(this, EPOCHNANOSECONDS);\n        const roundedNs = RoundInstant(ns, increment, unit, roundingMode);\n        const roundedInstant = new Instant(roundedNs);\n        return TemporalInstantToString(roundedInstant, timeZone, precision);\n    }\n    toJSON() {\n        if (!IsTemporalInstant(this))\n            throw new TypeError('invalid receiver');\n        return TemporalInstantToString(this, undefined, 'auto');\n    }\n    toLocaleString(locales = undefined, options = undefined) {\n        if (!IsTemporalInstant(this))\n            throw new TypeError('invalid receiver');\n        return new DateTimeFormat(locales, options).format(this);\n    }\n    valueOf() {\n        throw new TypeError('use compare() or equals() to compare Temporal.Instant');\n    }\n    toZonedDateTime(item) {\n        if (!IsTemporalInstant(this))\n            throw new TypeError('invalid receiver');\n        if (!IsObject(item)) {\n            throw new TypeError('invalid argument in toZonedDateTime');\n        }\n        const calendarLike = item.calendar;\n        if (calendarLike === undefined) {\n            throw new TypeError('missing calendar property in toZonedDateTime');\n        }\n        const calendar = ToTemporalCalendar(calendarLike);\n        const temporalTimeZoneLike = item.timeZone;\n        if (temporalTimeZoneLike === undefined) {\n            throw new TypeError('missing timeZone property in toZonedDateTime');\n        }\n        const timeZone = ToTemporalTimeZone(temporalTimeZoneLike);\n        return CreateTemporalZonedDateTime(GetSlot(this, EPOCHNANOSECONDS), timeZone, calendar);\n    }\n    toZonedDateTimeISO(itemParam) {\n        let item = itemParam;\n        if (!IsTemporalInstant(this))\n            throw new TypeError('invalid receiver');\n        if (IsObject(item)) {\n            const timeZoneProperty = item.timeZone;\n            if (timeZoneProperty !== undefined) {\n                item = timeZoneProperty;\n            }\n        }\n        const timeZone = ToTemporalTimeZone(item);\n        const calendar = GetISO8601Calendar();\n        return CreateTemporalZonedDateTime(GetSlot(this, EPOCHNANOSECONDS), timeZone, calendar);\n    }\n    static fromEpochSeconds(epochSecondsParam) {\n        const epochSeconds = ToNumber(epochSecondsParam);\n        const epochNanoseconds = jsbi_umd.multiply(jsbi_umd.BigInt(epochSeconds), BILLION);\n        ValidateEpochNanoseconds(epochNanoseconds);\n        return new Instant(epochNanoseconds);\n    }\n    static fromEpochMilliseconds(epochMillisecondsParam) {\n        const epochMilliseconds = ToNumber(epochMillisecondsParam);\n        const epochNanoseconds = jsbi_umd.multiply(jsbi_umd.BigInt(epochMilliseconds), MILLION);\n        ValidateEpochNanoseconds(epochNanoseconds);\n        return new Instant(epochNanoseconds);\n    }\n    static fromEpochMicroseconds(epochMicrosecondsParam) {\n        const epochMicroseconds = ToBigInt(epochMicrosecondsParam);\n        const epochNanoseconds = jsbi_umd.multiply(epochMicroseconds, THOUSAND);\n        ValidateEpochNanoseconds(epochNanoseconds);\n        return new Instant(epochNanoseconds);\n    }\n    static fromEpochNanoseconds(epochNanosecondsParam) {\n        const epochNanoseconds = ToBigInt(epochNanosecondsParam);\n        ValidateEpochNanoseconds(epochNanoseconds);\n        return new Instant(epochNanoseconds);\n    }\n    static from(item) {\n        if (IsTemporalInstant(item)) {\n            return new Instant(GetSlot(item, EPOCHNANOSECONDS));\n        }\n        return ToTemporalInstant(item);\n    }\n    static compare(oneParam, twoParam) {\n        const one = ToTemporalInstant(oneParam);\n        const two = ToTemporalInstant(twoParam);\n        const oneNs = GetSlot(one, EPOCHNANOSECONDS);\n        const twoNs = GetSlot(two, EPOCHNANOSECONDS);\n        if (jsbi_umd.lessThan(oneNs, twoNs))\n            return -1;\n        if (jsbi_umd.greaterThan(oneNs, twoNs))\n            return 1;\n        return 0;\n    }\n}\nMakeIntrinsicClass(Instant, 'Temporal.Instant');\n\nconst DISALLOWED_UNITS$2 = ['hour', 'minute', 'second', 'millisecond', 'microsecond', 'nanosecond'];\nclass PlainDate {\n    constructor(isoYearParam, isoMonthParam, isoDayParam, calendarParam = GetISO8601Calendar()) {\n        const isoYear = ToIntegerThrowOnInfinity(isoYearParam);\n        const isoMonth = ToIntegerThrowOnInfinity(isoMonthParam);\n        const isoDay = ToIntegerThrowOnInfinity(isoDayParam);\n        const calendar = ToTemporalCalendar(calendarParam);\n        // Note: if the arguments are not passed,\n        //       ToIntegerThrowOnInfinity(undefined) will have returned 0, which will\n        //       be rejected by RejectISODate in CreateTemporalDateSlots. This check\n        //       exists only to improve the error message.\n        if (arguments.length < 3) {\n            throw new RangeError('missing argument: isoYear, isoMonth and isoDay are required');\n        }\n        CreateTemporalDateSlots(this, isoYear, isoMonth, isoDay, calendar);\n    }\n    get calendar() {\n        if (!IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, CALENDAR);\n    }\n    get era() {\n        if (!IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        return CalendarEra(GetSlot(this, CALENDAR), this);\n    }\n    get eraYear() {\n        if (!IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        return CalendarEraYear(GetSlot(this, CALENDAR), this);\n    }\n    get year() {\n        if (!IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        return CalendarYear(GetSlot(this, CALENDAR), this);\n    }\n    get month() {\n        if (!IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        return CalendarMonth(GetSlot(this, CALENDAR), this);\n    }\n    get monthCode() {\n        if (!IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        return CalendarMonthCode(GetSlot(this, CALENDAR), this);\n    }\n    get day() {\n        if (!IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        return CalendarDay(GetSlot(this, CALENDAR), this);\n    }\n    get dayOfWeek() {\n        if (!IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        return CalendarDayOfWeek(GetSlot(this, CALENDAR), this);\n    }\n    get dayOfYear() {\n        if (!IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        return CalendarDayOfYear(GetSlot(this, CALENDAR), this);\n    }\n    get weekOfYear() {\n        if (!IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        return CalendarWeekOfYear(GetSlot(this, CALENDAR), this);\n    }\n    get daysInWeek() {\n        if (!IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        return CalendarDaysInWeek(GetSlot(this, CALENDAR), this);\n    }\n    get daysInMonth() {\n        if (!IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        return CalendarDaysInMonth(GetSlot(this, CALENDAR), this);\n    }\n    get daysInYear() {\n        if (!IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        return CalendarDaysInYear(GetSlot(this, CALENDAR), this);\n    }\n    get monthsInYear() {\n        if (!IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        return CalendarMonthsInYear(GetSlot(this, CALENDAR), this);\n    }\n    get inLeapYear() {\n        if (!IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        return CalendarInLeapYear(GetSlot(this, CALENDAR), this);\n    }\n    with(temporalDateLike, optionsParam = undefined) {\n        if (!IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        if (!IsObject(temporalDateLike)) {\n            throw new TypeError('invalid argument');\n        }\n        RejectObjectWithCalendarOrTimeZone(temporalDateLike);\n        const calendar = GetSlot(this, CALENDAR);\n        const fieldNames = CalendarFields(calendar, ['day', 'month', 'monthCode', 'year']);\n        const props = ToPartialRecord(temporalDateLike, fieldNames);\n        if (!props) {\n            throw new TypeError('invalid date-like');\n        }\n        let fields = ToTemporalDateFields(this, fieldNames);\n        fields = CalendarMergeFields(calendar, fields, props);\n        fields = ToTemporalDateFields(fields, fieldNames);\n        const options = GetOptionsObject(optionsParam);\n        return DateFromFields(calendar, fields, options);\n    }\n    withCalendar(calendarParam) {\n        if (!IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        const calendar = ToTemporalCalendar(calendarParam);\n        return new PlainDate(GetSlot(this, ISO_YEAR), GetSlot(this, ISO_MONTH), GetSlot(this, ISO_DAY), calendar);\n    }\n    add(temporalDurationLike, optionsParam = undefined) {\n        if (!IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        const duration = ToTemporalDuration(temporalDurationLike);\n        const options = GetOptionsObject(optionsParam);\n        return CalendarDateAdd(GetSlot(this, CALENDAR), this, duration, options);\n    }\n    subtract(temporalDurationLike, optionsParam = undefined) {\n        if (!IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        const duration = CreateNegatedTemporalDuration(ToTemporalDuration(temporalDurationLike));\n        const options = GetOptionsObject(optionsParam);\n        return CalendarDateAdd(GetSlot(this, CALENDAR), this, duration, options);\n    }\n    until(otherParam, optionsParam = undefined) {\n        if (!IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        const other = ToTemporalDate(otherParam);\n        const calendar = GetSlot(this, CALENDAR);\n        const otherCalendar = GetSlot(other, CALENDAR);\n        const calendarId = ToString(calendar);\n        const otherCalendarId = ToString(otherCalendar);\n        if (calendarId !== otherCalendarId) {\n            throw new RangeError(`cannot compute difference between dates of ${calendarId} and ${otherCalendarId} calendars`);\n        }\n        const options = GetOptionsObject(optionsParam);\n        const smallestUnit = ToSmallestTemporalUnit(options, 'day', DISALLOWED_UNITS$2);\n        const defaultLargestUnit = LargerOfTwoTemporalUnits('day', smallestUnit);\n        const largestUnit = ToLargestTemporalUnit(options, 'auto', DISALLOWED_UNITS$2, defaultLargestUnit);\n        ValidateTemporalUnitRange(largestUnit, smallestUnit);\n        const roundingMode = ToTemporalRoundingMode(options, 'trunc');\n        const roundingIncrement = ToTemporalRoundingIncrement(options, undefined, false);\n        const untilOptions = { ...options, largestUnit };\n        const result = CalendarDateUntil(calendar, this, other, untilOptions);\n        if (smallestUnit === 'day' && roundingIncrement === 1)\n            return result;\n        let { years, months, weeks, days } = result;\n        ({ years, months, weeks, days } = RoundDuration(years, months, weeks, days, 0, 0, 0, 0, 0, 0, roundingIncrement, smallestUnit, roundingMode, this));\n        const Duration = GetIntrinsic('%Temporal.Duration%');\n        return new Duration(years, months, weeks, days, 0, 0, 0, 0, 0, 0);\n    }\n    since(otherParam, optionsParam = undefined) {\n        if (!IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        const other = ToTemporalDate(otherParam);\n        const calendar = GetSlot(this, CALENDAR);\n        const otherCalendar = GetSlot(other, CALENDAR);\n        const calendarId = ToString(calendar);\n        const otherCalendarId = ToString(otherCalendar);\n        if (calendarId !== otherCalendarId) {\n            throw new RangeError(`cannot compute difference between dates of ${calendarId} and ${otherCalendarId} calendars`);\n        }\n        const options = GetOptionsObject(optionsParam);\n        const smallestUnit = ToSmallestTemporalUnit(options, 'day', DISALLOWED_UNITS$2);\n        const defaultLargestUnit = LargerOfTwoTemporalUnits('day', smallestUnit);\n        const largestUnit = ToLargestTemporalUnit(options, 'auto', DISALLOWED_UNITS$2, defaultLargestUnit);\n        ValidateTemporalUnitRange(largestUnit, smallestUnit);\n        const roundingMode = ToTemporalRoundingMode(options, 'trunc');\n        const roundingIncrement = ToTemporalRoundingIncrement(options, undefined, false);\n        const untilOptions = { ...options, largestUnit };\n        let { years, months, weeks, days } = CalendarDateUntil(calendar, this, other, untilOptions);\n        const Duration = GetIntrinsic('%Temporal.Duration%');\n        if (smallestUnit === 'day' && roundingIncrement === 1) {\n            return new Duration(-years, -months, -weeks, -days, 0, 0, 0, 0, 0, 0);\n        }\n        ({ years, months, weeks, days } = RoundDuration(years, months, weeks, days, 0, 0, 0, 0, 0, 0, roundingIncrement, smallestUnit, NegateTemporalRoundingMode(roundingMode), this));\n        return new Duration(-years, -months, -weeks, -days, 0, 0, 0, 0, 0, 0);\n    }\n    equals(otherParam) {\n        if (!IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        const other = ToTemporalDate(otherParam);\n        for (const slot of [ISO_YEAR, ISO_MONTH, ISO_DAY]) {\n            const val1 = GetSlot(this, slot);\n            const val2 = GetSlot(other, slot);\n            if (val1 !== val2)\n                return false;\n        }\n        return CalendarEquals(GetSlot(this, CALENDAR), GetSlot(other, CALENDAR));\n    }\n    toString(optionsParam = undefined) {\n        if (!IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        const options = GetOptionsObject(optionsParam);\n        const showCalendar = ToShowCalendarOption(options);\n        return TemporalDateToString(this, showCalendar);\n    }\n    toJSON() {\n        if (!IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        return TemporalDateToString(this);\n    }\n    toLocaleString(locales = undefined, options = undefined) {\n        if (!IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        return new DateTimeFormat(locales, options).format(this);\n    }\n    valueOf() {\n        throw new TypeError('use compare() or equals() to compare Temporal.PlainDate');\n    }\n    toPlainDateTime(temporalTimeParam = undefined) {\n        if (!IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        const year = GetSlot(this, ISO_YEAR);\n        const month = GetSlot(this, ISO_MONTH);\n        const day = GetSlot(this, ISO_DAY);\n        const calendar = GetSlot(this, CALENDAR);\n        if (temporalTimeParam === undefined)\n            return CreateTemporalDateTime(year, month, day, 0, 0, 0, 0, 0, 0, calendar);\n        const temporalTime = ToTemporalTime(temporalTimeParam);\n        const hour = GetSlot(temporalTime, ISO_HOUR);\n        const minute = GetSlot(temporalTime, ISO_MINUTE);\n        const second = GetSlot(temporalTime, ISO_SECOND);\n        const millisecond = GetSlot(temporalTime, ISO_MILLISECOND);\n        const microsecond = GetSlot(temporalTime, ISO_MICROSECOND);\n        const nanosecond = GetSlot(temporalTime, ISO_NANOSECOND);\n        return CreateTemporalDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar);\n    }\n    toZonedDateTime(item) {\n        if (!IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        let timeZone, temporalTime;\n        if (IsObject(item)) {\n            const timeZoneLike = item.timeZone;\n            if (timeZoneLike === undefined) {\n                // The cast below is needed because it's possible here for\n                // `timeZoneLike` here to be `{ plainTime: Temporal.PlainTimeLike }`,\n                // not a TimeZoneProtocol.\n                // TODO: should we check for that shape to improve on the (bad) error\n                // message that the caller will get from ToTemporalTimeZone?\n                timeZone = ToTemporalTimeZone(item);\n            }\n            else {\n                timeZone = ToTemporalTimeZone(timeZoneLike);\n                temporalTime = item.plainTime;\n            }\n        }\n        else {\n            timeZone = ToTemporalTimeZone(item);\n        }\n        const year = GetSlot(this, ISO_YEAR);\n        const month = GetSlot(this, ISO_MONTH);\n        const day = GetSlot(this, ISO_DAY);\n        const calendar = GetSlot(this, CALENDAR);\n        let hour = 0, minute = 0, second = 0, millisecond = 0, microsecond = 0, nanosecond = 0;\n        if (temporalTime !== undefined) {\n            temporalTime = ToTemporalTime(temporalTime);\n            hour = GetSlot(temporalTime, ISO_HOUR);\n            minute = GetSlot(temporalTime, ISO_MINUTE);\n            second = GetSlot(temporalTime, ISO_SECOND);\n            millisecond = GetSlot(temporalTime, ISO_MILLISECOND);\n            microsecond = GetSlot(temporalTime, ISO_MICROSECOND);\n            nanosecond = GetSlot(temporalTime, ISO_NANOSECOND);\n        }\n        const dt = CreateTemporalDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar);\n        const instant = BuiltinTimeZoneGetInstantFor(timeZone, dt, 'compatible');\n        return CreateTemporalZonedDateTime(GetSlot(instant, EPOCHNANOSECONDS), timeZone, calendar);\n    }\n    toPlainYearMonth() {\n        if (!IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        const calendar = GetSlot(this, CALENDAR);\n        const fieldNames = CalendarFields(calendar, ['monthCode', 'year']);\n        const fields = ToTemporalYearMonthFields(this, fieldNames);\n        return YearMonthFromFields(calendar, fields);\n    }\n    toPlainMonthDay() {\n        if (!IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        const calendar = GetSlot(this, CALENDAR);\n        const fieldNames = CalendarFields(calendar, ['day', 'monthCode']);\n        const fields = ToTemporalMonthDayFields(this, fieldNames);\n        return MonthDayFromFields(calendar, fields);\n    }\n    getISOFields() {\n        if (!IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        return {\n            calendar: GetSlot(this, CALENDAR),\n            isoDay: GetSlot(this, ISO_DAY),\n            isoMonth: GetSlot(this, ISO_MONTH),\n            isoYear: GetSlot(this, ISO_YEAR)\n        };\n    }\n    static from(item, optionsParam = undefined) {\n        const options = GetOptionsObject(optionsParam);\n        if (IsTemporalDate(item)) {\n            ToTemporalOverflow(options); // validate and ignore\n            return CreateTemporalDate(GetSlot(item, ISO_YEAR), GetSlot(item, ISO_MONTH), GetSlot(item, ISO_DAY), GetSlot(item, CALENDAR));\n        }\n        return ToTemporalDate(item, options);\n    }\n    static compare(oneParam, twoParam) {\n        const one = ToTemporalDate(oneParam);\n        const two = ToTemporalDate(twoParam);\n        return CompareISODate(GetSlot(one, ISO_YEAR), GetSlot(one, ISO_MONTH), GetSlot(one, ISO_DAY), GetSlot(two, ISO_YEAR), GetSlot(two, ISO_MONTH), GetSlot(two, ISO_DAY));\n    }\n}\nMakeIntrinsicClass(PlainDate, 'Temporal.PlainDate');\n\nclass PlainDateTime {\n    constructor(isoYearParam, isoMonthParam, isoDayParam, hourParam = 0, minuteParam = 0, secondParam = 0, millisecondParam = 0, microsecondParam = 0, nanosecondParam = 0, calendarParam = GetISO8601Calendar()) {\n        const isoYear = ToIntegerThrowOnInfinity(isoYearParam);\n        const isoMonth = ToIntegerThrowOnInfinity(isoMonthParam);\n        const isoDay = ToIntegerThrowOnInfinity(isoDayParam);\n        const hour = ToIntegerThrowOnInfinity(hourParam);\n        const minute = ToIntegerThrowOnInfinity(minuteParam);\n        const second = ToIntegerThrowOnInfinity(secondParam);\n        const millisecond = ToIntegerThrowOnInfinity(millisecondParam);\n        const microsecond = ToIntegerThrowOnInfinity(microsecondParam);\n        const nanosecond = ToIntegerThrowOnInfinity(nanosecondParam);\n        const calendar = ToTemporalCalendar(calendarParam);\n        // Note: if the arguments are not passed,\n        //       ToIntegerThrowOnInfinity(undefined) will have returned 0, which will\n        //       be rejected by RejectDateTime in CreateTemporalDateTimeSlots. This\n        //       check exists only to improve the error message.\n        if (arguments.length < 3) {\n            throw new RangeError('missing argument: isoYear, isoMonth and isoDay are required');\n        }\n        CreateTemporalDateTimeSlots(this, isoYear, isoMonth, isoDay, hour, minute, second, millisecond, microsecond, nanosecond, calendar);\n    }\n    get calendar() {\n        if (!IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, CALENDAR);\n    }\n    get year() {\n        if (!IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        return CalendarYear(GetSlot(this, CALENDAR), this);\n    }\n    get month() {\n        if (!IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        return CalendarMonth(GetSlot(this, CALENDAR), this);\n    }\n    get monthCode() {\n        if (!IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        return CalendarMonthCode(GetSlot(this, CALENDAR), this);\n    }\n    get day() {\n        if (!IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        return CalendarDay(GetSlot(this, CALENDAR), this);\n    }\n    get hour() {\n        if (!IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, ISO_HOUR);\n    }\n    get minute() {\n        if (!IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, ISO_MINUTE);\n    }\n    get second() {\n        if (!IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, ISO_SECOND);\n    }\n    get millisecond() {\n        if (!IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, ISO_MILLISECOND);\n    }\n    get microsecond() {\n        if (!IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, ISO_MICROSECOND);\n    }\n    get nanosecond() {\n        if (!IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, ISO_NANOSECOND);\n    }\n    get era() {\n        if (!IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        return CalendarEra(GetSlot(this, CALENDAR), this);\n    }\n    get eraYear() {\n        if (!IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        return CalendarEraYear(GetSlot(this, CALENDAR), this);\n    }\n    get dayOfWeek() {\n        if (!IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        return CalendarDayOfWeek(GetSlot(this, CALENDAR), this);\n    }\n    get dayOfYear() {\n        if (!IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        return CalendarDayOfYear(GetSlot(this, CALENDAR), this);\n    }\n    get weekOfYear() {\n        if (!IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        return CalendarWeekOfYear(GetSlot(this, CALENDAR), this);\n    }\n    get daysInWeek() {\n        if (!IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        return CalendarDaysInWeek(GetSlot(this, CALENDAR), this);\n    }\n    get daysInYear() {\n        if (!IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        return CalendarDaysInYear(GetSlot(this, CALENDAR), this);\n    }\n    get daysInMonth() {\n        if (!IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        return CalendarDaysInMonth(GetSlot(this, CALENDAR), this);\n    }\n    get monthsInYear() {\n        if (!IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        return CalendarMonthsInYear(GetSlot(this, CALENDAR), this);\n    }\n    get inLeapYear() {\n        if (!IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        return CalendarInLeapYear(GetSlot(this, CALENDAR), this);\n    }\n    with(temporalDateTimeLike, optionsParam = undefined) {\n        if (!IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        if (!IsObject(temporalDateTimeLike)) {\n            throw new TypeError('invalid argument');\n        }\n        RejectObjectWithCalendarOrTimeZone(temporalDateTimeLike);\n        const options = GetOptionsObject(optionsParam);\n        const calendar = GetSlot(this, CALENDAR);\n        const fieldNames = CalendarFields(calendar, [\n            'day',\n            'hour',\n            'microsecond',\n            'millisecond',\n            'minute',\n            'month',\n            'monthCode',\n            'nanosecond',\n            'second',\n            'year'\n        ]);\n        const props = ToPartialRecord(temporalDateTimeLike, fieldNames);\n        if (!props) {\n            throw new TypeError('invalid date-time-like');\n        }\n        let fields = ToTemporalDateTimeFields(this, fieldNames);\n        fields = CalendarMergeFields(calendar, fields, props);\n        fields = ToTemporalDateTimeFields(fields, fieldNames);\n        const { year, month, day, hour, minute, second, millisecond, microsecond, nanosecond } = InterpretTemporalDateTimeFields(calendar, fields, options);\n        return CreateTemporalDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar);\n    }\n    withPlainTime(temporalTimeParam = undefined) {\n        if (!IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        const year = GetSlot(this, ISO_YEAR);\n        const month = GetSlot(this, ISO_MONTH);\n        const day = GetSlot(this, ISO_DAY);\n        const calendar = GetSlot(this, CALENDAR);\n        if (temporalTimeParam === undefined)\n            return CreateTemporalDateTime(year, month, day, 0, 0, 0, 0, 0, 0, calendar);\n        const temporalTime = ToTemporalTime(temporalTimeParam);\n        const hour = GetSlot(temporalTime, ISO_HOUR);\n        const minute = GetSlot(temporalTime, ISO_MINUTE);\n        const second = GetSlot(temporalTime, ISO_SECOND);\n        const millisecond = GetSlot(temporalTime, ISO_MILLISECOND);\n        const microsecond = GetSlot(temporalTime, ISO_MICROSECOND);\n        const nanosecond = GetSlot(temporalTime, ISO_NANOSECOND);\n        return CreateTemporalDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar);\n    }\n    withPlainDate(temporalDateParam) {\n        if (!IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        const temporalDate = ToTemporalDate(temporalDateParam);\n        const year = GetSlot(temporalDate, ISO_YEAR);\n        const month = GetSlot(temporalDate, ISO_MONTH);\n        const day = GetSlot(temporalDate, ISO_DAY);\n        let calendar = GetSlot(temporalDate, CALENDAR);\n        const hour = GetSlot(this, ISO_HOUR);\n        const minute = GetSlot(this, ISO_MINUTE);\n        const second = GetSlot(this, ISO_SECOND);\n        const millisecond = GetSlot(this, ISO_MILLISECOND);\n        const microsecond = GetSlot(this, ISO_MICROSECOND);\n        const nanosecond = GetSlot(this, ISO_NANOSECOND);\n        calendar = ConsolidateCalendars(GetSlot(this, CALENDAR), calendar);\n        return CreateTemporalDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar);\n    }\n    withCalendar(calendarParam) {\n        if (!IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        const calendar = ToTemporalCalendar(calendarParam);\n        return new PlainDateTime(GetSlot(this, ISO_YEAR), GetSlot(this, ISO_MONTH), GetSlot(this, ISO_DAY), GetSlot(this, ISO_HOUR), GetSlot(this, ISO_MINUTE), GetSlot(this, ISO_SECOND), GetSlot(this, ISO_MILLISECOND), GetSlot(this, ISO_MICROSECOND), GetSlot(this, ISO_NANOSECOND), calendar);\n    }\n    add(temporalDurationLike, optionsParam = undefined) {\n        if (!IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        const duration = ToLimitedTemporalDuration(temporalDurationLike);\n        const { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = duration;\n        const options = GetOptionsObject(optionsParam);\n        const calendar = GetSlot(this, CALENDAR);\n        const { year, month, day, hour, minute, second, millisecond, microsecond, nanosecond } = AddDateTime(GetSlot(this, ISO_YEAR), GetSlot(this, ISO_MONTH), GetSlot(this, ISO_DAY), GetSlot(this, ISO_HOUR), GetSlot(this, ISO_MINUTE), GetSlot(this, ISO_SECOND), GetSlot(this, ISO_MILLISECOND), GetSlot(this, ISO_MICROSECOND), GetSlot(this, ISO_NANOSECOND), calendar, years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, options);\n        return CreateTemporalDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar);\n    }\n    subtract(temporalDurationLike, optionsParam = undefined) {\n        if (!IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        const duration = ToLimitedTemporalDuration(temporalDurationLike);\n        const { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = duration;\n        const options = GetOptionsObject(optionsParam);\n        const calendar = GetSlot(this, CALENDAR);\n        const { year, month, day, hour, minute, second, millisecond, microsecond, nanosecond } = AddDateTime(GetSlot(this, ISO_YEAR), GetSlot(this, ISO_MONTH), GetSlot(this, ISO_DAY), GetSlot(this, ISO_HOUR), GetSlot(this, ISO_MINUTE), GetSlot(this, ISO_SECOND), GetSlot(this, ISO_MILLISECOND), GetSlot(this, ISO_MICROSECOND), GetSlot(this, ISO_NANOSECOND), calendar, -years, -months, -weeks, -days, -hours, -minutes, -seconds, -milliseconds, -microseconds, -nanoseconds, options);\n        return CreateTemporalDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar);\n    }\n    until(otherParam, optionsParam = undefined) {\n        if (!IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        const other = ToTemporalDateTime(otherParam);\n        const calendar = GetSlot(this, CALENDAR);\n        const otherCalendar = GetSlot(other, CALENDAR);\n        const calendarId = ToString(calendar);\n        const otherCalendarId = ToString(otherCalendar);\n        if (calendarId !== otherCalendarId) {\n            throw new RangeError(`cannot compute difference between dates of ${calendarId} and ${otherCalendarId} calendars`);\n        }\n        const options = GetOptionsObject(optionsParam);\n        const smallestUnit = ToSmallestTemporalUnit(options, 'nanosecond');\n        const defaultLargestUnit = LargerOfTwoTemporalUnits('day', smallestUnit);\n        const largestUnit = ToLargestTemporalUnit(options, 'auto', [], defaultLargestUnit);\n        ValidateTemporalUnitRange(largestUnit, smallestUnit);\n        const roundingMode = ToTemporalRoundingMode(options, 'trunc');\n        const roundingIncrement = ToTemporalDateTimeRoundingIncrement(options, smallestUnit);\n        let { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = DifferenceISODateTime(GetSlot(this, ISO_YEAR), GetSlot(this, ISO_MONTH), GetSlot(this, ISO_DAY), GetSlot(this, ISO_HOUR), GetSlot(this, ISO_MINUTE), GetSlot(this, ISO_SECOND), GetSlot(this, ISO_MILLISECOND), GetSlot(this, ISO_MICROSECOND), GetSlot(this, ISO_NANOSECOND), GetSlot(other, ISO_YEAR), GetSlot(other, ISO_MONTH), GetSlot(other, ISO_DAY), GetSlot(other, ISO_HOUR), GetSlot(other, ISO_MINUTE), GetSlot(other, ISO_SECOND), GetSlot(other, ISO_MILLISECOND), GetSlot(other, ISO_MICROSECOND), GetSlot(other, ISO_NANOSECOND), calendar, largestUnit, options);\n        const relativeTo = TemporalDateTimeToDate(this);\n        ({ years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } =\n            RoundDuration(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, roundingIncrement, smallestUnit, roundingMode, relativeTo));\n        ({ days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = BalanceDuration(days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, largestUnit));\n        const Duration = GetIntrinsic('%Temporal.Duration%');\n        return new Duration(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n    }\n    since(otherParam, optionsParam = undefined) {\n        if (!IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        const other = ToTemporalDateTime(otherParam);\n        const calendar = GetSlot(this, CALENDAR);\n        const otherCalendar = GetSlot(other, CALENDAR);\n        const calendarId = ToString(calendar);\n        const otherCalendarId = ToString(otherCalendar);\n        if (calendarId !== otherCalendarId) {\n            throw new RangeError(`cannot compute difference between dates of ${calendarId} and ${otherCalendarId} calendars`);\n        }\n        const options = GetOptionsObject(optionsParam);\n        const smallestUnit = ToSmallestTemporalUnit(options, 'nanosecond');\n        const defaultLargestUnit = LargerOfTwoTemporalUnits('day', smallestUnit);\n        const largestUnit = ToLargestTemporalUnit(options, 'auto', [], defaultLargestUnit);\n        ValidateTemporalUnitRange(largestUnit, smallestUnit);\n        const roundingMode = ToTemporalRoundingMode(options, 'trunc');\n        const roundingIncrement = ToTemporalDateTimeRoundingIncrement(options, smallestUnit);\n        let { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = DifferenceISODateTime(GetSlot(this, ISO_YEAR), GetSlot(this, ISO_MONTH), GetSlot(this, ISO_DAY), GetSlot(this, ISO_HOUR), GetSlot(this, ISO_MINUTE), GetSlot(this, ISO_SECOND), GetSlot(this, ISO_MILLISECOND), GetSlot(this, ISO_MICROSECOND), GetSlot(this, ISO_NANOSECOND), GetSlot(other, ISO_YEAR), GetSlot(other, ISO_MONTH), GetSlot(other, ISO_DAY), GetSlot(other, ISO_HOUR), GetSlot(other, ISO_MINUTE), GetSlot(other, ISO_SECOND), GetSlot(other, ISO_MILLISECOND), GetSlot(other, ISO_MICROSECOND), GetSlot(other, ISO_NANOSECOND), calendar, largestUnit, options);\n        const relativeTo = TemporalDateTimeToDate(this);\n        ({ years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } =\n            RoundDuration(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, roundingIncrement, smallestUnit, NegateTemporalRoundingMode(roundingMode), relativeTo));\n        ({ days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = BalanceDuration(days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, largestUnit));\n        const Duration = GetIntrinsic('%Temporal.Duration%');\n        return new Duration(-years, -months, -weeks, -days, -hours, -minutes, -seconds, -milliseconds, -microseconds, -nanoseconds);\n    }\n    round(optionsParam) {\n        if (!IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        if (optionsParam === undefined)\n            throw new TypeError('options parameter is required');\n        const options = typeof optionsParam === 'string'\n            ? CreateOnePropObject('smallestUnit', optionsParam)\n            : GetOptionsObject(optionsParam);\n        const smallestUnit = ToSmallestTemporalUnit(options, undefined, ['year', 'month', 'week']);\n        if (smallestUnit === undefined)\n            throw new RangeError('smallestUnit is required');\n        const roundingMode = ToTemporalRoundingMode(options, 'halfExpand');\n        const maximumIncrements = {\n            day: 1,\n            hour: 24,\n            minute: 60,\n            second: 60,\n            millisecond: 1000,\n            microsecond: 1000,\n            nanosecond: 1000\n        };\n        const roundingIncrement = ToTemporalRoundingIncrement(options, maximumIncrements[smallestUnit], false);\n        let year = GetSlot(this, ISO_YEAR);\n        let month = GetSlot(this, ISO_MONTH);\n        let day = GetSlot(this, ISO_DAY);\n        let hour = GetSlot(this, ISO_HOUR);\n        let minute = GetSlot(this, ISO_MINUTE);\n        let second = GetSlot(this, ISO_SECOND);\n        let millisecond = GetSlot(this, ISO_MILLISECOND);\n        let microsecond = GetSlot(this, ISO_MICROSECOND);\n        let nanosecond = GetSlot(this, ISO_NANOSECOND);\n        ({ year, month, day, hour, minute, second, millisecond, microsecond, nanosecond } = RoundISODateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, roundingIncrement, smallestUnit, roundingMode));\n        return CreateTemporalDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, GetSlot(this, CALENDAR));\n    }\n    equals(otherParam) {\n        if (!IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        const other = ToTemporalDateTime(otherParam);\n        for (const slot of [\n            ISO_YEAR,\n            ISO_MONTH,\n            ISO_DAY,\n            ISO_HOUR,\n            ISO_MINUTE,\n            ISO_SECOND,\n            ISO_MILLISECOND,\n            ISO_MICROSECOND,\n            ISO_NANOSECOND\n        ]) {\n            const val1 = GetSlot(this, slot);\n            const val2 = GetSlot(other, slot);\n            if (val1 !== val2)\n                return false;\n        }\n        return CalendarEquals(GetSlot(this, CALENDAR), GetSlot(other, CALENDAR));\n    }\n    toString(optionsParam = undefined) {\n        if (!IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        const options = GetOptionsObject(optionsParam);\n        const { precision, unit, increment } = ToSecondsStringPrecision(options);\n        const showCalendar = ToShowCalendarOption(options);\n        const roundingMode = ToTemporalRoundingMode(options, 'trunc');\n        return TemporalDateTimeToString(this, precision, showCalendar, { unit, increment, roundingMode });\n    }\n    toJSON() {\n        if (!IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        return TemporalDateTimeToString(this, 'auto');\n    }\n    toLocaleString(locales = undefined, options = undefined) {\n        if (!IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        return new DateTimeFormat(locales, options).format(this);\n    }\n    valueOf() {\n        throw new TypeError('use compare() or equals() to compare Temporal.PlainDateTime');\n    }\n    toZonedDateTime(temporalTimeZoneLike, optionsParam = undefined) {\n        if (!IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        const timeZone = ToTemporalTimeZone(temporalTimeZoneLike);\n        const options = GetOptionsObject(optionsParam);\n        const disambiguation = ToTemporalDisambiguation(options);\n        const instant = BuiltinTimeZoneGetInstantFor(timeZone, this, disambiguation);\n        return CreateTemporalZonedDateTime(GetSlot(instant, EPOCHNANOSECONDS), timeZone, GetSlot(this, CALENDAR));\n    }\n    toPlainDate() {\n        if (!IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        return TemporalDateTimeToDate(this);\n    }\n    toPlainYearMonth() {\n        if (!IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        const calendar = GetSlot(this, CALENDAR);\n        const fieldNames = CalendarFields(calendar, ['monthCode', 'year']);\n        const fields = ToTemporalYearMonthFields(this, fieldNames);\n        return YearMonthFromFields(calendar, fields);\n    }\n    toPlainMonthDay() {\n        if (!IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        const calendar = GetSlot(this, CALENDAR);\n        const fieldNames = CalendarFields(calendar, ['day', 'monthCode']);\n        const fields = ToTemporalMonthDayFields(this, fieldNames);\n        return MonthDayFromFields(calendar, fields);\n    }\n    toPlainTime() {\n        if (!IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        return TemporalDateTimeToTime(this);\n    }\n    getISOFields() {\n        if (!IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        return {\n            calendar: GetSlot(this, CALENDAR),\n            isoDay: GetSlot(this, ISO_DAY),\n            isoHour: GetSlot(this, ISO_HOUR),\n            isoMicrosecond: GetSlot(this, ISO_MICROSECOND),\n            isoMillisecond: GetSlot(this, ISO_MILLISECOND),\n            isoMinute: GetSlot(this, ISO_MINUTE),\n            isoMonth: GetSlot(this, ISO_MONTH),\n            isoNanosecond: GetSlot(this, ISO_NANOSECOND),\n            isoSecond: GetSlot(this, ISO_SECOND),\n            isoYear: GetSlot(this, ISO_YEAR)\n        };\n    }\n    static from(item, optionsParam = undefined) {\n        const options = GetOptionsObject(optionsParam);\n        if (IsTemporalDateTime(item)) {\n            ToTemporalOverflow(options); // validate and ignore\n            return CreateTemporalDateTime(GetSlot(item, ISO_YEAR), GetSlot(item, ISO_MONTH), GetSlot(item, ISO_DAY), GetSlot(item, ISO_HOUR), GetSlot(item, ISO_MINUTE), GetSlot(item, ISO_SECOND), GetSlot(item, ISO_MILLISECOND), GetSlot(item, ISO_MICROSECOND), GetSlot(item, ISO_NANOSECOND), GetSlot(item, CALENDAR));\n        }\n        return ToTemporalDateTime(item, options);\n    }\n    static compare(oneParam, twoParam) {\n        const one = ToTemporalDateTime(oneParam);\n        const two = ToTemporalDateTime(twoParam);\n        for (const slot of [\n            ISO_YEAR,\n            ISO_MONTH,\n            ISO_DAY,\n            ISO_HOUR,\n            ISO_MINUTE,\n            ISO_SECOND,\n            ISO_MILLISECOND,\n            ISO_MICROSECOND,\n            ISO_NANOSECOND\n        ]) {\n            const val1 = GetSlot(one, slot);\n            const val2 = GetSlot(two, slot);\n            if (val1 !== val2)\n                return ComparisonResult(val1 - val2);\n        }\n        return 0;\n    }\n}\nMakeIntrinsicClass(PlainDateTime, 'Temporal.PlainDateTime');\n\nclass Duration {\n    constructor(yearsParam = 0, monthsParam = 0, weeksParam = 0, daysParam = 0, hoursParam = 0, minutesParam = 0, secondsParam = 0, millisecondsParam = 0, microsecondsParam = 0, nanosecondsParam = 0) {\n        const years = ToIntegerWithoutRounding(yearsParam);\n        const months = ToIntegerWithoutRounding(monthsParam);\n        const weeks = ToIntegerWithoutRounding(weeksParam);\n        const days = ToIntegerWithoutRounding(daysParam);\n        const hours = ToIntegerWithoutRounding(hoursParam);\n        const minutes = ToIntegerWithoutRounding(minutesParam);\n        const seconds = ToIntegerWithoutRounding(secondsParam);\n        const milliseconds = ToIntegerWithoutRounding(millisecondsParam);\n        const microseconds = ToIntegerWithoutRounding(microsecondsParam);\n        const nanoseconds = ToIntegerWithoutRounding(nanosecondsParam);\n        const sign = DurationSign(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n        for (const prop of [years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds]) {\n            if (!Number.isFinite(prop))\n                throw new RangeError('infinite values not allowed as duration fields');\n            const propSign = Math.sign(prop);\n            if (propSign !== 0 && propSign !== sign)\n                throw new RangeError('mixed-sign values not allowed as duration fields');\n        }\n        CreateSlots(this);\n        SetSlot(this, YEARS, years);\n        SetSlot(this, MONTHS, months);\n        SetSlot(this, WEEKS, weeks);\n        SetSlot(this, DAYS, days);\n        SetSlot(this, HOURS, hours);\n        SetSlot(this, MINUTES, minutes);\n        SetSlot(this, SECONDS, seconds);\n        SetSlot(this, MILLISECONDS, milliseconds);\n        SetSlot(this, MICROSECONDS, microseconds);\n        SetSlot(this, NANOSECONDS, nanoseconds);\n        {\n            Object.defineProperty(this, '_repr_', {\n                value: `${this[Symbol.toStringTag]} <${TemporalDurationToString(this)}>`,\n                writable: false,\n                enumerable: false,\n                configurable: false\n            });\n        }\n    }\n    get years() {\n        if (!IsTemporalDuration(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, YEARS);\n    }\n    get months() {\n        if (!IsTemporalDuration(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, MONTHS);\n    }\n    get weeks() {\n        if (!IsTemporalDuration(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, WEEKS);\n    }\n    get days() {\n        if (!IsTemporalDuration(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, DAYS);\n    }\n    get hours() {\n        if (!IsTemporalDuration(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, HOURS);\n    }\n    get minutes() {\n        if (!IsTemporalDuration(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, MINUTES);\n    }\n    get seconds() {\n        if (!IsTemporalDuration(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, SECONDS);\n    }\n    get milliseconds() {\n        if (!IsTemporalDuration(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, MILLISECONDS);\n    }\n    get microseconds() {\n        if (!IsTemporalDuration(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, MICROSECONDS);\n    }\n    get nanoseconds() {\n        if (!IsTemporalDuration(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, NANOSECONDS);\n    }\n    get sign() {\n        if (!IsTemporalDuration(this))\n            throw new TypeError('invalid receiver');\n        return DurationSign(GetSlot(this, YEARS), GetSlot(this, MONTHS), GetSlot(this, WEEKS), GetSlot(this, DAYS), GetSlot(this, HOURS), GetSlot(this, MINUTES), GetSlot(this, SECONDS), GetSlot(this, MILLISECONDS), GetSlot(this, MICROSECONDS), GetSlot(this, NANOSECONDS));\n    }\n    get blank() {\n        if (!IsTemporalDuration(this))\n            throw new TypeError('invalid receiver');\n        return (DurationSign(GetSlot(this, YEARS), GetSlot(this, MONTHS), GetSlot(this, WEEKS), GetSlot(this, DAYS), GetSlot(this, HOURS), GetSlot(this, MINUTES), GetSlot(this, SECONDS), GetSlot(this, MILLISECONDS), GetSlot(this, MICROSECONDS), GetSlot(this, NANOSECONDS)) === 0);\n    }\n    with(durationLike) {\n        if (!IsTemporalDuration(this))\n            throw new TypeError('invalid receiver');\n        const props = ToPartialRecord(durationLike, [\n            'days',\n            'hours',\n            'microseconds',\n            'milliseconds',\n            'minutes',\n            'months',\n            'nanoseconds',\n            'seconds',\n            'weeks',\n            'years'\n        ]);\n        if (!props) {\n            throw new TypeError('invalid duration-like');\n        }\n        const { years = GetSlot(this, YEARS), months = GetSlot(this, MONTHS), weeks = GetSlot(this, WEEKS), days = GetSlot(this, DAYS), hours = GetSlot(this, HOURS), minutes = GetSlot(this, MINUTES), seconds = GetSlot(this, SECONDS), milliseconds = GetSlot(this, MILLISECONDS), microseconds = GetSlot(this, MICROSECONDS), nanoseconds = GetSlot(this, NANOSECONDS) } = props;\n        return new Duration(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n    }\n    negated() {\n        if (!IsTemporalDuration(this))\n            throw new TypeError('invalid receiver');\n        return CreateNegatedTemporalDuration(this);\n    }\n    abs() {\n        if (!IsTemporalDuration(this))\n            throw new TypeError('invalid receiver');\n        return new Duration(Math.abs(GetSlot(this, YEARS)), Math.abs(GetSlot(this, MONTHS)), Math.abs(GetSlot(this, WEEKS)), Math.abs(GetSlot(this, DAYS)), Math.abs(GetSlot(this, HOURS)), Math.abs(GetSlot(this, MINUTES)), Math.abs(GetSlot(this, SECONDS)), Math.abs(GetSlot(this, MILLISECONDS)), Math.abs(GetSlot(this, MICROSECONDS)), Math.abs(GetSlot(this, NANOSECONDS)));\n    }\n    add(other, optionsParam = undefined) {\n        if (!IsTemporalDuration(this))\n            throw new TypeError('invalid receiver');\n        let { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = ToLimitedTemporalDuration(other);\n        const options = GetOptionsObject(optionsParam);\n        const relativeTo = ToRelativeTemporalObject(options);\n        ({ years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = AddDuration(GetSlot(this, YEARS), GetSlot(this, MONTHS), GetSlot(this, WEEKS), GetSlot(this, DAYS), GetSlot(this, HOURS), GetSlot(this, MINUTES), GetSlot(this, SECONDS), GetSlot(this, MILLISECONDS), GetSlot(this, MICROSECONDS), GetSlot(this, NANOSECONDS), years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, relativeTo));\n        return new Duration(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n    }\n    subtract(other, optionsParam = undefined) {\n        if (!IsTemporalDuration(this))\n            throw new TypeError('invalid receiver');\n        let { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = ToLimitedTemporalDuration(other);\n        const options = GetOptionsObject(optionsParam);\n        const relativeTo = ToRelativeTemporalObject(options);\n        ({ years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = AddDuration(GetSlot(this, YEARS), GetSlot(this, MONTHS), GetSlot(this, WEEKS), GetSlot(this, DAYS), GetSlot(this, HOURS), GetSlot(this, MINUTES), GetSlot(this, SECONDS), GetSlot(this, MILLISECONDS), GetSlot(this, MICROSECONDS), GetSlot(this, NANOSECONDS), -years, -months, -weeks, -days, -hours, -minutes, -seconds, -milliseconds, -microseconds, -nanoseconds, relativeTo));\n        return new Duration(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n    }\n    round(optionsParam) {\n        if (!IsTemporalDuration(this))\n            throw new TypeError('invalid receiver');\n        if (optionsParam === undefined)\n            throw new TypeError('options parameter is required');\n        let years = GetSlot(this, YEARS);\n        let months = GetSlot(this, MONTHS);\n        let weeks = GetSlot(this, WEEKS);\n        let days = GetSlot(this, DAYS);\n        let hours = GetSlot(this, HOURS);\n        let minutes = GetSlot(this, MINUTES);\n        let seconds = GetSlot(this, SECONDS);\n        let milliseconds = GetSlot(this, MILLISECONDS);\n        let microseconds = GetSlot(this, MICROSECONDS);\n        let nanoseconds = GetSlot(this, NANOSECONDS);\n        let defaultLargestUnit = DefaultTemporalLargestUnit(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n        const options = typeof optionsParam === 'string'\n            ? CreateOnePropObject('smallestUnit', optionsParam)\n            : GetOptionsObject(optionsParam);\n        let smallestUnit = ToSmallestTemporalUnit(options, undefined);\n        let smallestUnitPresent = true;\n        if (!smallestUnit) {\n            smallestUnitPresent = false;\n            smallestUnit = 'nanosecond';\n        }\n        defaultLargestUnit = LargerOfTwoTemporalUnits(defaultLargestUnit, smallestUnit);\n        let largestUnit = ToLargestTemporalUnit(options, undefined);\n        let largestUnitPresent = true;\n        if (!largestUnit) {\n            largestUnitPresent = false;\n            largestUnit = defaultLargestUnit;\n        }\n        if (largestUnit === 'auto')\n            largestUnit = defaultLargestUnit;\n        if (!smallestUnitPresent && !largestUnitPresent) {\n            throw new RangeError('at least one of smallestUnit or largestUnit is required');\n        }\n        ValidateTemporalUnitRange(largestUnit, smallestUnit);\n        const roundingMode = ToTemporalRoundingMode(options, 'halfExpand');\n        const roundingIncrement = ToTemporalDateTimeRoundingIncrement(options, smallestUnit);\n        let relativeTo = ToRelativeTemporalObject(options);\n        ({ years, months, weeks, days } = UnbalanceDurationRelative(years, months, weeks, days, largestUnit, relativeTo));\n        ({ years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } =\n            RoundDuration(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, roundingIncrement, smallestUnit, roundingMode, relativeTo));\n        ({ years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } =\n            AdjustRoundedDurationDays(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, roundingIncrement, smallestUnit, roundingMode, relativeTo));\n        ({ years, months, weeks, days } = BalanceDurationRelative(years, months, weeks, days, largestUnit, relativeTo));\n        if (IsTemporalZonedDateTime(relativeTo)) {\n            relativeTo = MoveRelativeZonedDateTime(relativeTo, years, months, weeks, 0);\n        }\n        ({ days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = BalanceDuration(days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, largestUnit, relativeTo));\n        return new Duration(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n    }\n    total(optionsParam) {\n        if (!IsTemporalDuration(this))\n            throw new TypeError('invalid receiver');\n        let years = GetSlot(this, YEARS);\n        let months = GetSlot(this, MONTHS);\n        let weeks = GetSlot(this, WEEKS);\n        let days = GetSlot(this, DAYS);\n        let hours = GetSlot(this, HOURS);\n        let minutes = GetSlot(this, MINUTES);\n        let seconds = GetSlot(this, SECONDS);\n        let milliseconds = GetSlot(this, MILLISECONDS);\n        let microseconds = GetSlot(this, MICROSECONDS);\n        let nanoseconds = GetSlot(this, NANOSECONDS);\n        if (optionsParam === undefined)\n            throw new TypeError('options argument is required');\n        const options = typeof optionsParam === 'string'\n            ? CreateOnePropObject('unit', optionsParam)\n            : GetOptionsObject(optionsParam);\n        const unit = ToTemporalDurationTotalUnit(options);\n        if (unit === undefined)\n            throw new RangeError('unit option is required');\n        const relativeTo = ToRelativeTemporalObject(options);\n        // Convert larger units down to days\n        ({ years, months, weeks, days } = UnbalanceDurationRelative(years, months, weeks, days, unit, relativeTo));\n        // If the unit we're totalling is smaller than `days`, convert days down to that unit.\n        let intermediate;\n        if (IsTemporalZonedDateTime(relativeTo)) {\n            intermediate = MoveRelativeZonedDateTime(relativeTo, years, months, weeks, 0);\n        }\n        ({ days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = BalanceDuration(days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, unit, intermediate));\n        // Finally, truncate to the correct unit and calculate remainder\n        const { total } = RoundDuration(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, 1, unit, 'trunc', relativeTo);\n        return total;\n    }\n    toString(optionsParam = undefined) {\n        if (!IsTemporalDuration(this))\n            throw new TypeError('invalid receiver');\n        const options = GetOptionsObject(optionsParam);\n        const { precision, unit, increment } = ToSecondsStringPrecision(options);\n        if (precision === 'minute')\n            throw new RangeError('smallestUnit must not be \"minute\"');\n        const roundingMode = ToTemporalRoundingMode(options, 'trunc');\n        return TemporalDurationToString(this, precision, { unit, increment, roundingMode });\n    }\n    toJSON() {\n        if (!IsTemporalDuration(this))\n            throw new TypeError('invalid receiver');\n        return TemporalDurationToString(this);\n    }\n    toLocaleString(locales = undefined, options = undefined) {\n        if (!IsTemporalDuration(this))\n            throw new TypeError('invalid receiver');\n        if (typeof Intl !== 'undefined' && typeof Intl.DurationFormat !== 'undefined') {\n            return new Intl.DurationFormat(locales, options).format(this);\n        }\n        console.warn('Temporal.Duration.prototype.toLocaleString() requires Intl.DurationFormat.');\n        return TemporalDurationToString(this);\n    }\n    valueOf() {\n        throw new TypeError('use compare() to compare Temporal.Duration');\n    }\n    static from(item) {\n        if (IsTemporalDuration(item)) {\n            return new Duration(GetSlot(item, YEARS), GetSlot(item, MONTHS), GetSlot(item, WEEKS), GetSlot(item, DAYS), GetSlot(item, HOURS), GetSlot(item, MINUTES), GetSlot(item, SECONDS), GetSlot(item, MILLISECONDS), GetSlot(item, MICROSECONDS), GetSlot(item, NANOSECONDS));\n        }\n        return ToTemporalDuration(item);\n    }\n    static compare(oneParam, twoParam, optionsParam = undefined) {\n        const one = ToTemporalDuration(oneParam);\n        const two = ToTemporalDuration(twoParam);\n        const options = GetOptionsObject(optionsParam);\n        const relativeTo = ToRelativeTemporalObject(options);\n        const y1 = GetSlot(one, YEARS);\n        const mon1 = GetSlot(one, MONTHS);\n        const w1 = GetSlot(one, WEEKS);\n        let d1 = GetSlot(one, DAYS);\n        const h1 = GetSlot(one, HOURS);\n        const min1 = GetSlot(one, MINUTES);\n        const s1 = GetSlot(one, SECONDS);\n        const ms1 = GetSlot(one, MILLISECONDS);\n        const s1 = GetSlot(one, MICROSECONDS);\n        let ns1 = GetSlot(one, NANOSECONDS);\n        const y2 = GetSlot(two, YEARS);\n        const mon2 = GetSlot(two, MONTHS);\n        const w2 = GetSlot(two, WEEKS);\n        let d2 = GetSlot(two, DAYS);\n        const h2 = GetSlot(two, HOURS);\n        const min2 = GetSlot(two, MINUTES);\n        const s2 = GetSlot(two, SECONDS);\n        const ms2 = GetSlot(two, MILLISECONDS);\n        const s2 = GetSlot(two, MICROSECONDS);\n        let ns2 = GetSlot(two, NANOSECONDS);\n        const shift1 = CalculateOffsetShift(relativeTo, y1, mon1, w1, d1, h1, min1, s1, ms1, s1, ns1);\n        const shift2 = CalculateOffsetShift(relativeTo, y2, mon2, w2, d2, h2, min2, s2, ms2, s2, ns2);\n        if (y1 !== 0 || y2 !== 0 || mon1 !== 0 || mon2 !== 0 || w1 !== 0 || w2 !== 0) {\n            ({ days: d1 } = UnbalanceDurationRelative(y1, mon1, w1, d1, 'day', relativeTo));\n            ({ days: d2 } = UnbalanceDurationRelative(y2, mon2, w2, d2, 'day', relativeTo));\n        }\n        const totalNs1 = TotalDurationNanoseconds(d1, h1, min1, s1, ms1, s1, ns1, shift1);\n        const totalNs2 = TotalDurationNanoseconds(d2, h2, min2, s2, ms2, s2, ns2, shift2);\n        return ComparisonResult(jsbi_umd.toNumber(jsbi_umd.subtract(totalNs1, totalNs2)));\n    }\n}\nMakeIntrinsicClass(Duration, 'Temporal.Duration');\n\nconst ObjectCreate$1 = Object.create;\nclass PlainMonthDay {\n    constructor(isoMonthParam, isoDayParam, calendarParam = GetISO8601Calendar(), referenceISOYearParam = 1972) {\n        const isoMonth = ToIntegerThrowOnInfinity(isoMonthParam);\n        const isoDay = ToIntegerThrowOnInfinity(isoDayParam);\n        const calendar = ToTemporalCalendar(calendarParam);\n        const referenceISOYear = ToIntegerThrowOnInfinity(referenceISOYearParam);\n        // Note: if the arguments are not passed,\n        //       ToIntegerThrowOnInfinity(undefined) will have returned 0, which will\n        //       be rejected by RejectISODate in CreateTemporalMonthDaySlots. This\n        //       check exists only to improve the error message.\n        if (arguments.length < 2) {\n            throw new RangeError('missing argument: isoMonth and isoDay are required');\n        }\n        CreateTemporalMonthDaySlots(this, isoMonth, isoDay, calendar, referenceISOYear);\n    }\n    get monthCode() {\n        if (!IsTemporalMonthDay(this))\n            throw new TypeError('invalid receiver');\n        return CalendarMonthCode(GetSlot(this, CALENDAR), this);\n    }\n    get day() {\n        if (!IsTemporalMonthDay(this))\n            throw new TypeError('invalid receiver');\n        return CalendarDay(GetSlot(this, CALENDAR), this);\n    }\n    get calendar() {\n        if (!IsTemporalMonthDay(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, CALENDAR);\n    }\n    with(temporalMonthDayLike, optionsParam = undefined) {\n        if (!IsTemporalMonthDay(this))\n            throw new TypeError('invalid receiver');\n        if (!IsObject(temporalMonthDayLike)) {\n            throw new TypeError('invalid argument');\n        }\n        RejectObjectWithCalendarOrTimeZone(temporalMonthDayLike);\n        const calendar = GetSlot(this, CALENDAR);\n        const fieldNames = CalendarFields(calendar, ['day', 'month', 'monthCode', 'year']);\n        const props = ToPartialRecord(temporalMonthDayLike, fieldNames);\n        if (!props) {\n            throw new TypeError('invalid month-day-like');\n        }\n        let fields = ToTemporalMonthDayFields(this, fieldNames);\n        fields = CalendarMergeFields(calendar, fields, props);\n        fields = ToTemporalMonthDayFields(fields, fieldNames);\n        const options = GetOptionsObject(optionsParam);\n        return MonthDayFromFields(calendar, fields, options);\n    }\n    equals(otherParam) {\n        if (!IsTemporalMonthDay(this))\n            throw new TypeError('invalid receiver');\n        const other = ToTemporalMonthDay(otherParam);\n        for (const slot of [ISO_MONTH, ISO_DAY, ISO_YEAR]) {\n            const val1 = GetSlot(this, slot);\n            const val2 = GetSlot(other, slot);\n            if (val1 !== val2)\n                return false;\n        }\n        return CalendarEquals(GetSlot(this, CALENDAR), GetSlot(other, CALENDAR));\n    }\n    toString(optionsParam = undefined) {\n        if (!IsTemporalMonthDay(this))\n            throw new TypeError('invalid receiver');\n        const options = GetOptionsObject(optionsParam);\n        const showCalendar = ToShowCalendarOption(options);\n        return TemporalMonthDayToString(this, showCalendar);\n    }\n    toJSON() {\n        if (!IsTemporalMonthDay(this))\n            throw new TypeError('invalid receiver');\n        return TemporalMonthDayToString(this);\n    }\n    toLocaleString(locales = undefined, options = undefined) {\n        if (!IsTemporalMonthDay(this))\n            throw new TypeError('invalid receiver');\n        return new DateTimeFormat(locales, options).format(this);\n    }\n    valueOf() {\n        throw new TypeError('use equals() to compare Temporal.PlainMonthDay');\n    }\n    toPlainDate(item) {\n        if (!IsTemporalMonthDay(this))\n            throw new TypeError('invalid receiver');\n        if (!IsObject(item))\n            throw new TypeError('argument should be an object');\n        const calendar = GetSlot(this, CALENDAR);\n        const receiverFieldNames = CalendarFields(calendar, ['day', 'monthCode']);\n        const fields = ToTemporalMonthDayFields(this, receiverFieldNames);\n        const inputFieldNames = CalendarFields(calendar, ['year']);\n        const inputEntries = [['year', undefined]];\n        // Add extra fields from the calendar at the end\n        inputFieldNames.forEach((fieldName) => {\n            if (!inputEntries.some(([name]) => name === fieldName)) {\n                inputEntries.push([fieldName, undefined]); // Make TS ignore extra fields\n            }\n        });\n        const inputFields = PrepareTemporalFields(item, inputEntries);\n        let mergedFields = CalendarMergeFields(calendar, fields, inputFields);\n        const mergedFieldNames = [...new Set([...receiverFieldNames, ...inputFieldNames])];\n        const mergedEntries = [];\n        mergedFieldNames.forEach((fieldName) => {\n            if (!mergedEntries.some(([name]) => name === fieldName)) {\n                mergedEntries.push([fieldName, undefined]);\n            }\n        });\n        mergedFields = PrepareTemporalFields(mergedFields, mergedEntries);\n        const options = ObjectCreate$1(null);\n        options.overflow = 'reject';\n        return DateFromFields(calendar, mergedFields, options);\n    }\n    getISOFields() {\n        if (!IsTemporalMonthDay(this))\n            throw new TypeError('invalid receiver');\n        return {\n            calendar: GetSlot(this, CALENDAR),\n            isoDay: GetSlot(this, ISO_DAY),\n            isoMonth: GetSlot(this, ISO_MONTH),\n            isoYear: GetSlot(this, ISO_YEAR)\n        };\n    }\n    static from(item, optionsParam = undefined) {\n        const options = GetOptionsObject(optionsParam);\n        if (IsTemporalMonthDay(item)) {\n            ToTemporalOverflow(options); // validate and ignore\n            return CreateTemporalMonthDay(GetSlot(item, ISO_MONTH), GetSlot(item, ISO_DAY), GetSlot(item, CALENDAR), GetSlot(item, ISO_YEAR));\n        }\n        return ToTemporalMonthDay(item, options);\n    }\n}\nMakeIntrinsicClass(PlainMonthDay, 'Temporal.PlainMonthDay');\n\nconst instant = () => {\n    const Instant = GetIntrinsic('%Temporal.Instant%');\n    return new Instant(SystemUTCEpochNanoSeconds());\n};\nconst plainDateTime = (calendarLike, temporalTimeZoneLike = timeZone()) => {\n    const tZ = ToTemporalTimeZone(temporalTimeZoneLike);\n    const calendar = ToTemporalCalendar(calendarLike);\n    const inst = instant();\n    return BuiltinTimeZoneGetPlainDateTimeFor(tZ, inst, calendar);\n};\nconst plainDateTimeISO = (temporalTimeZoneLike = timeZone()) => {\n    const tZ = ToTemporalTimeZone(temporalTimeZoneLike);\n    const calendar = GetISO8601Calendar();\n    const inst = instant();\n    return BuiltinTimeZoneGetPlainDateTimeFor(tZ, inst, calendar);\n};\nconst zonedDateTime = (calendarLike, temporalTimeZoneLike = timeZone()) => {\n    const tZ = ToTemporalTimeZone(temporalTimeZoneLike);\n    const calendar = ToTemporalCalendar(calendarLike);\n    return CreateTemporalZonedDateTime(SystemUTCEpochNanoSeconds(), tZ, calendar);\n};\nconst zonedDateTimeISO = (temporalTimeZoneLike = timeZone()) => {\n    return zonedDateTime(GetISO8601Calendar(), temporalTimeZoneLike);\n};\nconst plainDate = (calendarLike, temporalTimeZoneLike = timeZone()) => {\n    return TemporalDateTimeToDate(plainDateTime(calendarLike, temporalTimeZoneLike));\n};\nconst plainDateISO = (temporalTimeZoneLike = timeZone()) => {\n    return TemporalDateTimeToDate(plainDateTimeISO(temporalTimeZoneLike));\n};\nconst plainTimeISO = (temporalTimeZoneLike = timeZone()) => {\n    return TemporalDateTimeToTime(plainDateTimeISO(temporalTimeZoneLike));\n};\nconst timeZone = () => {\n    return SystemTimeZone();\n};\nconst Now = {\n    instant,\n    plainDateTime,\n    plainDateTimeISO,\n    plainDate,\n    plainDateISO,\n    plainTimeISO,\n    timeZone,\n    zonedDateTime,\n    zonedDateTimeISO,\n    [Symbol.toStringTag]: 'Temporal.Now'\n};\nObject.defineProperty(Now, Symbol.toStringTag, {\n    value: 'Temporal.Now',\n    writable: false,\n    enumerable: false,\n    configurable: true\n});\n\nconst ObjectAssign = Object.assign;\nconst DISALLOWED_UNITS$1 = ['year', 'month', 'week', 'day'];\nconst MAX_INCREMENTS = {\n    hour: 24,\n    minute: 60,\n    second: 60,\n    millisecond: 1000,\n    microsecond: 1000,\n    nanosecond: 1000\n};\nfunction TemporalTimeToString(time, precision, options = undefined) {\n    let hour = GetSlot(time, ISO_HOUR);\n    let minute = GetSlot(time, ISO_MINUTE);\n    let second = GetSlot(time, ISO_SECOND);\n    let millisecond = GetSlot(time, ISO_MILLISECOND);\n    let microsecond = GetSlot(time, ISO_MICROSECOND);\n    let nanosecond = GetSlot(time, ISO_NANOSECOND);\n    if (options) {\n        const { unit, increment, roundingMode } = options;\n        ({ hour, minute, second, millisecond, microsecond, nanosecond } = RoundTime(hour, minute, second, millisecond, microsecond, nanosecond, increment, unit, roundingMode));\n    }\n    const hourString = ISODateTimePartString(hour);\n    const minuteString = ISODateTimePartString(minute);\n    const seconds = FormatSecondsStringPart(second, millisecond, microsecond, nanosecond, precision);\n    return `${hourString}:${minuteString}${seconds}`;\n}\nclass PlainTime {\n    constructor(isoHourParam = 0, isoMinuteParam = 0, isoSecondParam = 0, isoMillisecondParam = 0, isoMicrosecondParam = 0, isoNanosecondParam = 0) {\n        const isoHour = ToIntegerThrowOnInfinity(isoHourParam);\n        const isoMinute = ToIntegerThrowOnInfinity(isoMinuteParam);\n        const isoSecond = ToIntegerThrowOnInfinity(isoSecondParam);\n        const isoMillisecond = ToIntegerThrowOnInfinity(isoMillisecondParam);\n        const isoMicrosecond = ToIntegerThrowOnInfinity(isoMicrosecondParam);\n        const isoNanosecond = ToIntegerThrowOnInfinity(isoNanosecondParam);\n        RejectTime(isoHour, isoMinute, isoSecond, isoMillisecond, isoMicrosecond, isoNanosecond);\n        CreateSlots(this);\n        SetSlot(this, ISO_HOUR, isoHour);\n        SetSlot(this, ISO_MINUTE, isoMinute);\n        SetSlot(this, ISO_SECOND, isoSecond);\n        SetSlot(this, ISO_MILLISECOND, isoMillisecond);\n        SetSlot(this, ISO_MICROSECOND, isoMicrosecond);\n        SetSlot(this, ISO_NANOSECOND, isoNanosecond);\n        SetSlot(this, CALENDAR, GetISO8601Calendar());\n        {\n            Object.defineProperty(this, '_repr_', {\n                value: `${this[Symbol.toStringTag]} <${TemporalTimeToString(this, 'auto')}>`,\n                writable: false,\n                enumerable: false,\n                configurable: false\n            });\n        }\n    }\n    get calendar() {\n        if (!IsTemporalTime(this))\n            throw new TypeError('invalid receiver');\n        // PlainTime's calendar isn't settable, so can't be a userland calendar\n        return GetSlot(this, CALENDAR);\n    }\n    get hour() {\n        if (!IsTemporalTime(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, ISO_HOUR);\n    }\n    get minute() {\n        if (!IsTemporalTime(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, ISO_MINUTE);\n    }\n    get second() {\n        if (!IsTemporalTime(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, ISO_SECOND);\n    }\n    get millisecond() {\n        if (!IsTemporalTime(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, ISO_MILLISECOND);\n    }\n    get microsecond() {\n        if (!IsTemporalTime(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, ISO_MICROSECOND);\n    }\n    get nanosecond() {\n        if (!IsTemporalTime(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, ISO_NANOSECOND);\n    }\n    with(temporalTimeLike, optionsParam = undefined) {\n        if (!IsTemporalTime(this))\n            throw new TypeError('invalid receiver');\n        if (!IsObject(temporalTimeLike)) {\n            throw new TypeError('invalid argument');\n        }\n        RejectObjectWithCalendarOrTimeZone(temporalTimeLike);\n        const options = GetOptionsObject(optionsParam);\n        const overflow = ToTemporalOverflow(options);\n        const props = ToPartialRecord(temporalTimeLike, [\n            'hour',\n            'microsecond',\n            'millisecond',\n            'minute',\n            'nanosecond',\n            'second'\n        ]);\n        if (!props) {\n            throw new TypeError('invalid time-like');\n        }\n        const fields = ToTemporalTimeRecord(this);\n        let { hour, minute, second, millisecond, microsecond, nanosecond } = ObjectAssign(fields, props);\n        ({ hour, minute, second, millisecond, microsecond, nanosecond } = RegulateTime(hour, minute, second, millisecond, microsecond, nanosecond, overflow));\n        return new PlainTime(hour, minute, second, millisecond, microsecond, nanosecond);\n    }\n    add(temporalDurationLike) {\n        if (!IsTemporalTime(this))\n            throw new TypeError('invalid receiver');\n        const duration = ToLimitedTemporalDuration(temporalDurationLike);\n        const { hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = duration;\n        let hour = GetSlot(this, ISO_HOUR);\n        let minute = GetSlot(this, ISO_MINUTE);\n        let second = GetSlot(this, ISO_SECOND);\n        let millisecond = GetSlot(this, ISO_MILLISECOND);\n        let microsecond = GetSlot(this, ISO_MICROSECOND);\n        let nanosecond = GetSlot(this, ISO_NANOSECOND);\n        ({ hour, minute, second, millisecond, microsecond, nanosecond } = AddTime(hour, minute, second, millisecond, microsecond, nanosecond, hours, minutes, seconds, milliseconds, microseconds, nanoseconds));\n        ({ hour, minute, second, millisecond, microsecond, nanosecond } = RegulateTime(hour, minute, second, millisecond, microsecond, nanosecond, 'reject'));\n        return new PlainTime(hour, minute, second, millisecond, microsecond, nanosecond);\n    }\n    subtract(temporalDurationLike) {\n        if (!IsTemporalTime(this))\n            throw new TypeError('invalid receiver');\n        const duration = ToLimitedTemporalDuration(temporalDurationLike);\n        const { hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = duration;\n        let hour = GetSlot(this, ISO_HOUR);\n        let minute = GetSlot(this, ISO_MINUTE);\n        let second = GetSlot(this, ISO_SECOND);\n        let millisecond = GetSlot(this, ISO_MILLISECOND);\n        let microsecond = GetSlot(this, ISO_MICROSECOND);\n        let nanosecond = GetSlot(this, ISO_NANOSECOND);\n        ({ hour, minute, second, millisecond, microsecond, nanosecond } = AddTime(hour, minute, second, millisecond, microsecond, nanosecond, -hours, -minutes, -seconds, -milliseconds, -microseconds, -nanoseconds));\n        ({ hour, minute, second, millisecond, microsecond, nanosecond } = RegulateTime(hour, minute, second, millisecond, microsecond, nanosecond, 'reject'));\n        return new PlainTime(hour, minute, second, millisecond, microsecond, nanosecond);\n    }\n    until(otherParam, optionsParam = undefined) {\n        if (!IsTemporalTime(this))\n            throw new TypeError('invalid receiver');\n        const other = ToTemporalTime(otherParam);\n        const options = GetOptionsObject(optionsParam);\n        const largestUnit = ToLargestTemporalUnit(options, 'auto', DISALLOWED_UNITS$1, 'hour');\n        const smallestUnit = ToSmallestTemporalUnit(options, 'nanosecond', DISALLOWED_UNITS$1);\n        ValidateTemporalUnitRange(largestUnit, smallestUnit);\n        const roundingMode = ToTemporalRoundingMode(options, 'trunc');\n        const roundingIncrement = ToTemporalRoundingIncrement(options, MAX_INCREMENTS[smallestUnit], false);\n        let { hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = DifferenceTime(GetSlot(this, ISO_HOUR), GetSlot(this, ISO_MINUTE), GetSlot(this, ISO_SECOND), GetSlot(this, ISO_MILLISECOND), GetSlot(this, ISO_MICROSECOND), GetSlot(this, ISO_NANOSECOND), GetSlot(other, ISO_HOUR), GetSlot(other, ISO_MINUTE), GetSlot(other, ISO_SECOND), GetSlot(other, ISO_MILLISECOND), GetSlot(other, ISO_MICROSECOND), GetSlot(other, ISO_NANOSECOND));\n        ({ hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = RoundDuration(0, 0, 0, 0, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, roundingIncrement, smallestUnit, roundingMode));\n        ({ hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = BalanceDuration(0, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, largestUnit));\n        const Duration = GetIntrinsic('%Temporal.Duration%');\n        return new Duration(0, 0, 0, 0, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n    }\n    since(otherParam, optionsParam = undefined) {\n        if (!IsTemporalTime(this))\n            throw new TypeError('invalid receiver');\n        const other = ToTemporalTime(otherParam);\n        const options = GetOptionsObject(optionsParam);\n        const largestUnit = ToLargestTemporalUnit(options, 'auto', DISALLOWED_UNITS$1, 'hour');\n        const smallestUnit = ToSmallestTemporalUnit(options, 'nanosecond', DISALLOWED_UNITS$1);\n        ValidateTemporalUnitRange(largestUnit, smallestUnit);\n        const roundingMode = ToTemporalRoundingMode(options, 'trunc');\n        const roundingIncrement = ToTemporalRoundingIncrement(options, MAX_INCREMENTS[smallestUnit], false);\n        let { hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = DifferenceTime(GetSlot(other, ISO_HOUR), GetSlot(other, ISO_MINUTE), GetSlot(other, ISO_SECOND), GetSlot(other, ISO_MILLISECOND), GetSlot(other, ISO_MICROSECOND), GetSlot(other, ISO_NANOSECOND), GetSlot(this, ISO_HOUR), GetSlot(this, ISO_MINUTE), GetSlot(this, ISO_SECOND), GetSlot(this, ISO_MILLISECOND), GetSlot(this, ISO_MICROSECOND), GetSlot(this, ISO_NANOSECOND));\n        ({ hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = RoundDuration(0, 0, 0, 0, -hours, -minutes, -seconds, -milliseconds, -microseconds, -nanoseconds, roundingIncrement, smallestUnit, NegateTemporalRoundingMode(roundingMode)));\n        hours = -hours;\n        minutes = -minutes;\n        seconds = -seconds;\n        milliseconds = -milliseconds;\n        microseconds = -microseconds;\n        nanoseconds = -nanoseconds;\n        ({ hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = BalanceDuration(0, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, largestUnit));\n        const Duration = GetIntrinsic('%Temporal.Duration%');\n        return new Duration(0, 0, 0, 0, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n    }\n    round(optionsParam) {\n        if (!IsTemporalTime(this))\n            throw new TypeError('invalid receiver');\n        if (optionsParam === undefined)\n            throw new TypeError('options parameter is required');\n        const options = typeof optionsParam === 'string'\n            ? CreateOnePropObject('smallestUnit', optionsParam)\n            : GetOptionsObject(optionsParam);\n        const smallestUnit = ToSmallestTemporalUnit(options, undefined, DISALLOWED_UNITS$1);\n        if (smallestUnit === undefined)\n            throw new RangeError('smallestUnit is required');\n        const roundingMode = ToTemporalRoundingMode(options, 'halfExpand');\n        const roundingIncrement = ToTemporalRoundingIncrement(options, MAX_INCREMENTS[smallestUnit], false);\n        let hour = GetSlot(this, ISO_HOUR);\n        let minute = GetSlot(this, ISO_MINUTE);\n        let second = GetSlot(this, ISO_SECOND);\n        let millisecond = GetSlot(this, ISO_MILLISECOND);\n        let microsecond = GetSlot(this, ISO_MICROSECOND);\n        let nanosecond = GetSlot(this, ISO_NANOSECOND);\n        ({ hour, minute, second, millisecond, microsecond, nanosecond } = RoundTime(hour, minute, second, millisecond, microsecond, nanosecond, roundingIncrement, smallestUnit, roundingMode));\n        return new PlainTime(hour, minute, second, millisecond, microsecond, nanosecond);\n    }\n    equals(otherParam) {\n        if (!IsTemporalTime(this))\n            throw new TypeError('invalid receiver');\n        const other = ToTemporalTime(otherParam);\n        for (const slot of [ISO_HOUR, ISO_MINUTE, ISO_SECOND, ISO_MILLISECOND, ISO_MICROSECOND, ISO_NANOSECOND]) {\n            const val1 = GetSlot(this, slot);\n            const val2 = GetSlot(other, slot);\n            if (val1 !== val2)\n                return false;\n        }\n        return true;\n    }\n    toString(optionsParam = undefined) {\n        if (!IsTemporalTime(this))\n            throw new TypeError('invalid receiver');\n        const options = GetOptionsObject(optionsParam);\n        const { precision, unit, increment } = ToSecondsStringPrecision(options);\n        const roundingMode = ToTemporalRoundingMode(options, 'trunc');\n        return TemporalTimeToString(this, precision, { unit, increment, roundingMode });\n    }\n    toJSON() {\n        if (!IsTemporalTime(this))\n            throw new TypeError('invalid receiver');\n        return TemporalTimeToString(this, 'auto');\n    }\n    toLocaleString(locales = undefined, options = undefined) {\n        if (!IsTemporalTime(this))\n            throw new TypeError('invalid receiver');\n        return new DateTimeFormat(locales, options).format(this);\n    }\n    valueOf() {\n        throw new TypeError('use compare() or equals() to compare Temporal.PlainTime');\n    }\n    toPlainDateTime(temporalDateParam) {\n        if (!IsTemporalTime(this))\n            throw new TypeError('invalid receiver');\n        const temporalDate = ToTemporalDate(temporalDateParam);\n        const year = GetSlot(temporalDate, ISO_YEAR);\n        const month = GetSlot(temporalDate, ISO_MONTH);\n        const day = GetSlot(temporalDate, ISO_DAY);\n        const calendar = GetSlot(temporalDate, CALENDAR);\n        const hour = GetSlot(this, ISO_HOUR);\n        const minute = GetSlot(this, ISO_MINUTE);\n        const second = GetSlot(this, ISO_SECOND);\n        const millisecond = GetSlot(this, ISO_MILLISECOND);\n        const microsecond = GetSlot(this, ISO_MICROSECOND);\n        const nanosecond = GetSlot(this, ISO_NANOSECOND);\n        return CreateTemporalDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar);\n    }\n    toZonedDateTime(item) {\n        if (!IsTemporalTime(this))\n            throw new TypeError('invalid receiver');\n        if (!IsObject(item)) {\n            throw new TypeError('invalid argument');\n        }\n        const dateLike = item.plainDate;\n        if (dateLike === undefined) {\n            throw new TypeError('missing date property');\n        }\n        const temporalDate = ToTemporalDate(dateLike);\n        const timeZoneLike = item.timeZone;\n        if (timeZoneLike === undefined) {\n            throw new TypeError('missing timeZone property');\n        }\n        const timeZone = ToTemporalTimeZone(timeZoneLike);\n        const year = GetSlot(temporalDate, ISO_YEAR);\n        const month = GetSlot(temporalDate, ISO_MONTH);\n        const day = GetSlot(temporalDate, ISO_DAY);\n        const calendar = GetSlot(temporalDate, CALENDAR);\n        const hour = GetSlot(this, ISO_HOUR);\n        const minute = GetSlot(this, ISO_MINUTE);\n        const second = GetSlot(this, ISO_SECOND);\n        const millisecond = GetSlot(this, ISO_MILLISECOND);\n        const microsecond = GetSlot(this, ISO_MICROSECOND);\n        const nanosecond = GetSlot(this, ISO_NANOSECOND);\n        const PlainDateTime = GetIntrinsic('%Temporal.PlainDateTime%');\n        const dt = new PlainDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar);\n        const instant = BuiltinTimeZoneGetInstantFor(timeZone, dt, 'compatible');\n        return CreateTemporalZonedDateTime(GetSlot(instant, EPOCHNANOSECONDS), timeZone, calendar);\n    }\n    getISOFields() {\n        if (!IsTemporalTime(this))\n            throw new TypeError('invalid receiver');\n        return {\n            calendar: GetSlot(this, CALENDAR),\n            isoHour: GetSlot(this, ISO_HOUR),\n            isoMicrosecond: GetSlot(this, ISO_MICROSECOND),\n            isoMillisecond: GetSlot(this, ISO_MILLISECOND),\n            isoMinute: GetSlot(this, ISO_MINUTE),\n            isoNanosecond: GetSlot(this, ISO_NANOSECOND),\n            isoSecond: GetSlot(this, ISO_SECOND)\n        };\n    }\n    static from(item, optionsParam = undefined) {\n        const options = GetOptionsObject(optionsParam);\n        const overflow = ToTemporalOverflow(options);\n        if (IsTemporalTime(item)) {\n            return new PlainTime(GetSlot(item, ISO_HOUR), GetSlot(item, ISO_MINUTE), GetSlot(item, ISO_SECOND), GetSlot(item, ISO_MILLISECOND), GetSlot(item, ISO_MICROSECOND), GetSlot(item, ISO_NANOSECOND));\n        }\n        return ToTemporalTime(item, overflow);\n    }\n    static compare(oneParam, twoParam) {\n        const one = ToTemporalTime(oneParam);\n        const two = ToTemporalTime(twoParam);\n        for (const slot of [ISO_HOUR, ISO_MINUTE, ISO_SECOND, ISO_MILLISECOND, ISO_MICROSECOND, ISO_NANOSECOND]) {\n            const val1 = GetSlot(one, slot);\n            const val2 = GetSlot(two, slot);\n            if (val1 !== val2)\n                return ComparisonResult(val1 - val2);\n        }\n        return 0;\n    }\n}\nMakeIntrinsicClass(PlainTime, 'Temporal.PlainTime');\n\nclass TimeZone {\n    constructor(timeZoneIdentifierParam) {\n        // Note: if the argument is not passed, GetCanonicalTimeZoneIdentifier(undefined) will throw.\n        //       This check exists only to improve the error message.\n        if (arguments.length < 1) {\n            throw new RangeError('missing argument: identifier is required');\n        }\n        const timeZoneIdentifier = GetCanonicalTimeZoneIdentifier(timeZoneIdentifierParam);\n        CreateSlots(this);\n        SetSlot(this, TIMEZONE_ID, timeZoneIdentifier);\n        {\n            Object.defineProperty(this, '_repr_', {\n                value: `${this[Symbol.toStringTag]} <${timeZoneIdentifier}>`,\n                writable: false,\n                enumerable: false,\n                configurable: false\n            });\n        }\n    }\n    get id() {\n        if (!IsTemporalTimeZone(this))\n            throw new TypeError('invalid receiver');\n        return ToString(this);\n    }\n    getOffsetNanosecondsFor(instantParam) {\n        if (!IsTemporalTimeZone(this))\n            throw new TypeError('invalid receiver');\n        const instant = ToTemporalInstant(instantParam);\n        const id = GetSlot(this, TIMEZONE_ID);\n        if (TestTimeZoneOffsetString(id)) {\n            return ParseTimeZoneOffsetString(id);\n        }\n        return GetIANATimeZoneOffsetNanoseconds(GetSlot(instant, EPOCHNANOSECONDS), id);\n    }\n    getOffsetStringFor(instantParam) {\n        if (!IsTemporalTimeZone(this))\n            throw new TypeError('invalid receiver');\n        const instant = ToTemporalInstant(instantParam);\n        return BuiltinTimeZoneGetOffsetStringFor(this, instant);\n    }\n    getPlainDateTimeFor(instantParam, calendarParam = GetISO8601Calendar()) {\n        const instant = ToTemporalInstant(instantParam);\n        const calendar = ToTemporalCalendar(calendarParam);\n        return BuiltinTimeZoneGetPlainDateTimeFor(this, instant, calendar);\n    }\n    getInstantFor(dateTimeParam, optionsParam = undefined) {\n        if (!IsTemporalTimeZone(this))\n            throw new TypeError('invalid receiver');\n        const dateTime = ToTemporalDateTime(dateTimeParam);\n        const options = GetOptionsObject(optionsParam);\n        const disambiguation = ToTemporalDisambiguation(options);\n        return BuiltinTimeZoneGetInstantFor(this, dateTime, disambiguation);\n    }\n    getPossibleInstantsFor(dateTimeParam) {\n        if (!IsTemporalTimeZone(this))\n            throw new TypeError('invalid receiver');\n        const dateTime = ToTemporalDateTime(dateTimeParam);\n        const Instant = GetIntrinsic('%Temporal.Instant%');\n        const id = GetSlot(this, TIMEZONE_ID);\n        if (TestTimeZoneOffsetString(id)) {\n            const epochNs = GetEpochFromISOParts(GetSlot(dateTime, ISO_YEAR), GetSlot(dateTime, ISO_MONTH), GetSlot(dateTime, ISO_DAY), GetSlot(dateTime, ISO_HOUR), GetSlot(dateTime, ISO_MINUTE), GetSlot(dateTime, ISO_SECOND), GetSlot(dateTime, ISO_MILLISECOND), GetSlot(dateTime, ISO_MICROSECOND), GetSlot(dateTime, ISO_NANOSECOND));\n            if (epochNs === null)\n                throw new RangeError('DateTime outside of supported range');\n            const offsetNs = ParseTimeZoneOffsetString(id);\n            return [new Instant(jsbi_umd.subtract(epochNs, jsbi_umd.BigInt(offsetNs)))];\n        }\n        const possibleEpochNs = GetIANATimeZoneEpochValue(id, GetSlot(dateTime, ISO_YEAR), GetSlot(dateTime, ISO_MONTH), GetSlot(dateTime, ISO_DAY), GetSlot(dateTime, ISO_HOUR), GetSlot(dateTime, ISO_MINUTE), GetSlot(dateTime, ISO_SECOND), GetSlot(dateTime, ISO_MILLISECOND), GetSlot(dateTime, ISO_MICROSECOND), GetSlot(dateTime, ISO_NANOSECOND));\n        return possibleEpochNs.map((ns) => new Instant(ns));\n    }\n    getNextTransition(startingPointParam) {\n        if (!IsTemporalTimeZone(this))\n            throw new TypeError('invalid receiver');\n        const startingPoint = ToTemporalInstant(startingPointParam);\n        const id = GetSlot(this, TIMEZONE_ID);\n        // Offset time zones or UTC have no transitions\n        if (TestTimeZoneOffsetString(id) || id === 'UTC') {\n            return null;\n        }\n        let epochNanoseconds = GetSlot(startingPoint, EPOCHNANOSECONDS);\n        const Instant = GetIntrinsic('%Temporal.Instant%');\n        epochNanoseconds = GetIANATimeZoneNextTransition(epochNanoseconds, id);\n        return epochNanoseconds === null ? null : new Instant(epochNanoseconds);\n    }\n    getPreviousTransition(startingPointParam) {\n        if (!IsTemporalTimeZone(this))\n            throw new TypeError('invalid receiver');\n        const startingPoint = ToTemporalInstant(startingPointParam);\n        const id = GetSlot(this, TIMEZONE_ID);\n        // Offset time zones or UTC have no transitions\n        if (TestTimeZoneOffsetString(id) || id === 'UTC') {\n            return null;\n        }\n        let epochNanoseconds = GetSlot(startingPoint, EPOCHNANOSECONDS);\n        const Instant = GetIntrinsic('%Temporal.Instant%');\n        epochNanoseconds = GetIANATimeZonePreviousTransition(epochNanoseconds, id);\n        return epochNanoseconds === null ? null : new Instant(epochNanoseconds);\n    }\n    toString() {\n        if (!IsTemporalTimeZone(this))\n            throw new TypeError('invalid receiver');\n        return ToString(GetSlot(this, TIMEZONE_ID));\n    }\n    toJSON() {\n        if (!IsTemporalTimeZone(this))\n            throw new TypeError('invalid receiver');\n        return ToString(this);\n    }\n    static from(item) {\n        return ToTemporalTimeZone(item);\n    }\n}\nMakeIntrinsicClass(TimeZone, 'Temporal.TimeZone');\n\nconst ObjectCreate = Object.create;\nconst DISALLOWED_UNITS = [\n    'week',\n    'day',\n    'hour',\n    'minute',\n    'second',\n    'millisecond',\n    'microsecond',\n    'nanosecond'\n];\nclass PlainYearMonth {\n    constructor(isoYearParam, isoMonthParam, calendarParam = GetISO8601Calendar(), referenceISODayParam = 1) {\n        const isoYear = ToIntegerThrowOnInfinity(isoYearParam);\n        const isoMonth = ToIntegerThrowOnInfinity(isoMonthParam);\n        const calendar = ToTemporalCalendar(calendarParam);\n        const referenceISODay = ToIntegerThrowOnInfinity(referenceISODayParam);\n        // Note: if the arguments are not passed,\n        //       ToIntegerThrowOnInfinity(undefined) will have returned 0, which will\n        //       be rejected by RejectISODate in CreateTemporalYearMonthSlots. This\n        //       check exists only to improve the error message.\n        if (arguments.length < 2) {\n            throw new RangeError('missing argument: isoYear and isoMonth are required');\n        }\n        CreateTemporalYearMonthSlots(this, isoYear, isoMonth, calendar, referenceISODay);\n    }\n    get year() {\n        if (!IsTemporalYearMonth(this))\n            throw new TypeError('invalid receiver');\n        return CalendarYear(GetSlot(this, CALENDAR), this);\n    }\n    get month() {\n        if (!IsTemporalYearMonth(this))\n            throw new TypeError('invalid receiver');\n        return CalendarMonth(GetSlot(this, CALENDAR), this);\n    }\n    get monthCode() {\n        if (!IsTemporalYearMonth(this))\n            throw new TypeError('invalid receiver');\n        return CalendarMonthCode(GetSlot(this, CALENDAR), this);\n    }\n    get calendar() {\n        if (!IsTemporalYearMonth(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, CALENDAR);\n    }\n    get era() {\n        if (!IsTemporalYearMonth(this))\n            throw new TypeError('invalid receiver');\n        return CalendarEra(GetSlot(this, CALENDAR), this);\n    }\n    get eraYear() {\n        if (!IsTemporalYearMonth(this))\n            throw new TypeError('invalid receiver');\n        return CalendarEraYear(GetSlot(this, CALENDAR), this);\n    }\n    get daysInMonth() {\n        if (!IsTemporalYearMonth(this))\n            throw new TypeError('invalid receiver');\n        return CalendarDaysInMonth(GetSlot(this, CALENDAR), this);\n    }\n    get daysInYear() {\n        if (!IsTemporalYearMonth(this))\n            throw new TypeError('invalid receiver');\n        return CalendarDaysInYear(GetSlot(this, CALENDAR), this);\n    }\n    get monthsInYear() {\n        if (!IsTemporalYearMonth(this))\n            throw new TypeError('invalid receiver');\n        return CalendarMonthsInYear(GetSlot(this, CALENDAR), this);\n    }\n    get inLeapYear() {\n        if (!IsTemporalYearMonth(this))\n            throw new TypeError('invalid receiver');\n        return CalendarInLeapYear(GetSlot(this, CALENDAR), this);\n    }\n    with(temporalYearMonthLike, optionsParam = undefined) {\n        if (!IsTemporalYearMonth(this))\n            throw new TypeError('invalid receiver');\n        if (!IsObject(temporalYearMonthLike)) {\n            throw new TypeError('invalid argument');\n        }\n        RejectObjectWithCalendarOrTimeZone(temporalYearMonthLike);\n        const calendar = GetSlot(this, CALENDAR);\n        const fieldNames = CalendarFields(calendar, ['month', 'monthCode', 'year']);\n        const props = ToPartialRecord(temporalYearMonthLike, fieldNames);\n        if (!props) {\n            throw new TypeError('invalid year-month-like');\n        }\n        let fields = ToTemporalYearMonthFields(this, fieldNames);\n        fields = CalendarMergeFields(calendar, fields, props);\n        fields = ToTemporalYearMonthFields(fields, fieldNames);\n        const options = GetOptionsObject(optionsParam);\n        return YearMonthFromFields(calendar, fields, options);\n    }\n    add(temporalDurationLike, optionsParam = undefined) {\n        if (!IsTemporalYearMonth(this))\n            throw new TypeError('invalid receiver');\n        const duration = ToLimitedTemporalDuration(temporalDurationLike);\n        let { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = duration;\n        ({ days } = BalanceDuration(days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, 'day'));\n        const options = GetOptionsObject(optionsParam);\n        const calendar = GetSlot(this, CALENDAR);\n        const fieldNames = CalendarFields(calendar, ['monthCode', 'year']);\n        const fields = ToTemporalYearMonthFields(this, fieldNames);\n        const sign = DurationSign(years, months, weeks, days, 0, 0, 0, 0, 0, 0);\n        const day = sign < 0 ? ToPositiveInteger(CalendarDaysInMonth(calendar, this)) : 1;\n        const startDate = DateFromFields(calendar, { ...fields, day });\n        const optionsCopy = { ...options };\n        const addedDate = CalendarDateAdd(calendar, startDate, { ...duration, days }, options);\n        const addedDateFields = ToTemporalYearMonthFields(addedDate, fieldNames);\n        return YearMonthFromFields(calendar, addedDateFields, optionsCopy);\n    }\n    subtract(temporalDurationLike, optionsParam = undefined) {\n        if (!IsTemporalYearMonth(this))\n            throw new TypeError('invalid receiver');\n        let duration = ToLimitedTemporalDuration(temporalDurationLike);\n        duration = {\n            years: -duration.years,\n            months: -duration.months,\n            weeks: -duration.weeks,\n            days: -duration.days,\n            hours: -duration.hours,\n            minutes: -duration.minutes,\n            seconds: -duration.seconds,\n            milliseconds: -duration.milliseconds,\n            microseconds: -duration.microseconds,\n            nanoseconds: -duration.nanoseconds\n        };\n        let { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = duration;\n        ({ days } = BalanceDuration(days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, 'day'));\n        const options = GetOptionsObject(optionsParam);\n        const calendar = GetSlot(this, CALENDAR);\n        const fieldNames = CalendarFields(calendar, ['monthCode', 'year']);\n        const fields = ToTemporalYearMonthFields(this, fieldNames);\n        const sign = DurationSign(years, months, weeks, days, 0, 0, 0, 0, 0, 0);\n        const day = sign < 0 ? ToPositiveInteger(CalendarDaysInMonth(calendar, this)) : 1;\n        const startDate = DateFromFields(calendar, { ...fields, day });\n        const optionsCopy = { ...options };\n        const addedDate = CalendarDateAdd(calendar, startDate, { ...duration, days }, options);\n        const addedDateFields = ToTemporalYearMonthFields(addedDate, fieldNames);\n        return YearMonthFromFields(calendar, addedDateFields, optionsCopy);\n    }\n    until(otherParam, optionsParam = undefined) {\n        if (!IsTemporalYearMonth(this))\n            throw new TypeError('invalid receiver');\n        const other = ToTemporalYearMonth(otherParam);\n        const calendar = GetSlot(this, CALENDAR);\n        const otherCalendar = GetSlot(other, CALENDAR);\n        const calendarID = ToString(calendar);\n        const otherCalendarID = ToString(otherCalendar);\n        if (calendarID !== otherCalendarID) {\n            throw new RangeError(`cannot compute difference between months of ${calendarID} and ${otherCalendarID} calendars`);\n        }\n        const options = GetOptionsObject(optionsParam);\n        const smallestUnit = ToSmallestTemporalUnit(options, 'month', DISALLOWED_UNITS);\n        const largestUnit = ToLargestTemporalUnit(options, 'auto', DISALLOWED_UNITS, 'year');\n        ValidateTemporalUnitRange(largestUnit, smallestUnit);\n        const roundingMode = ToTemporalRoundingMode(options, 'trunc');\n        const roundingIncrement = ToTemporalRoundingIncrement(options, undefined, false);\n        const fieldNames = CalendarFields(calendar, ['monthCode', 'year']);\n        const otherFields = ToTemporalYearMonthFields(other, fieldNames);\n        const thisFields = ToTemporalYearMonthFields(this, fieldNames);\n        const otherDate = DateFromFields(calendar, { ...otherFields, day: 1 });\n        const thisDate = DateFromFields(calendar, { ...thisFields, day: 1 });\n        const untilOptions = { ...options, largestUnit };\n        const result = CalendarDateUntil(calendar, thisDate, otherDate, untilOptions);\n        if (smallestUnit === 'month' && roundingIncrement === 1)\n            return result;\n        let { years, months } = result;\n        ({ years, months } = RoundDuration(years, months, 0, 0, 0, 0, 0, 0, 0, 0, roundingIncrement, smallestUnit, roundingMode, thisDate));\n        const Duration = GetIntrinsic('%Temporal.Duration%');\n        return new Duration(years, months, 0, 0, 0, 0, 0, 0, 0, 0);\n    }\n    since(otherParam, optionsParam = undefined) {\n        if (!IsTemporalYearMonth(this))\n            throw new TypeError('invalid receiver');\n        const other = ToTemporalYearMonth(otherParam);\n        const calendar = GetSlot(this, CALENDAR);\n        const otherCalendar = GetSlot(other, CALENDAR);\n        const calendarID = ToString(calendar);\n        const otherCalendarID = ToString(otherCalendar);\n        if (calendarID !== otherCalendarID) {\n            throw new RangeError(`cannot compute difference between months of ${calendarID} and ${otherCalendarID} calendars`);\n        }\n        const options = GetOptionsObject(optionsParam);\n        const smallestUnit = ToSmallestTemporalUnit(options, 'month', DISALLOWED_UNITS);\n        const largestUnit = ToLargestTemporalUnit(options, 'auto', DISALLOWED_UNITS, 'year');\n        ValidateTemporalUnitRange(largestUnit, smallestUnit);\n        const roundingMode = ToTemporalRoundingMode(options, 'trunc');\n        const roundingIncrement = ToTemporalRoundingIncrement(options, undefined, false);\n        const fieldNames = CalendarFields(calendar, ['monthCode', 'year']);\n        const otherFields = ToTemporalYearMonthFields(other, fieldNames);\n        const thisFields = ToTemporalYearMonthFields(this, fieldNames);\n        const otherDate = DateFromFields(calendar, { ...otherFields, day: 1 });\n        const thisDate = DateFromFields(calendar, { ...thisFields, day: 1 });\n        const untilOptions = { ...options, largestUnit };\n        let { years, months } = CalendarDateUntil(calendar, thisDate, otherDate, untilOptions);\n        const Duration = GetIntrinsic('%Temporal.Duration%');\n        if (smallestUnit === 'month' && roundingIncrement === 1) {\n            return new Duration(-years, -months, 0, 0, 0, 0, 0, 0, 0, 0);\n        }\n        ({ years, months } = RoundDuration(years, months, 0, 0, 0, 0, 0, 0, 0, 0, roundingIncrement, smallestUnit, NegateTemporalRoundingMode(roundingMode), thisDate));\n        return new Duration(-years, -months, 0, 0, 0, 0, 0, 0, 0, 0);\n    }\n    equals(otherParam) {\n        if (!IsTemporalYearMonth(this))\n            throw new TypeError('invalid receiver');\n        const other = ToTemporalYearMonth(otherParam);\n        for (const slot of [ISO_YEAR, ISO_MONTH, ISO_DAY]) {\n            const val1 = GetSlot(this, slot);\n            const val2 = GetSlot(other, slot);\n            if (val1 !== val2)\n                return false;\n        }\n        return CalendarEquals(GetSlot(this, CALENDAR), GetSlot(other, CALENDAR));\n    }\n    toString(optionsParam = undefined) {\n        if (!IsTemporalYearMonth(this))\n            throw new TypeError('invalid receiver');\n        const options = GetOptionsObject(optionsParam);\n        const showCalendar = ToShowCalendarOption(options);\n        return TemporalYearMonthToString(this, showCalendar);\n    }\n    toJSON() {\n        if (!IsTemporalYearMonth(this))\n            throw new TypeError('invalid receiver');\n        return TemporalYearMonthToString(this);\n    }\n    toLocaleString(locales = undefined, options = undefined) {\n        if (!IsTemporalYearMonth(this))\n            throw new TypeError('invalid receiver');\n        return new DateTimeFormat(locales, options).format(this);\n    }\n    valueOf() {\n        throw new TypeError('use compare() or equals() to compare Temporal.PlainYearMonth');\n    }\n    toPlainDate(item) {\n        if (!IsTemporalYearMonth(this))\n            throw new TypeError('invalid receiver');\n        if (!IsObject(item))\n            throw new TypeError('argument should be an object');\n        const calendar = GetSlot(this, CALENDAR);\n        const receiverFieldNames = CalendarFields(calendar, ['monthCode', 'year']);\n        const fields = ToTemporalYearMonthFields(this, receiverFieldNames);\n        const inputFieldNames = CalendarFields(calendar, ['day']);\n        const inputEntries = [['day']];\n        // Add extra fields from the calendar at the end\n        inputFieldNames.forEach((fieldName) => {\n            if (!inputEntries.some(([name]) => name === fieldName)) {\n                inputEntries.push([\n                    fieldName,\n                    undefined\n                ]); // Make TS ignore extra fields\n            }\n        });\n        const inputFields = PrepareTemporalFields(item, inputEntries);\n        let mergedFields = CalendarMergeFields(calendar, fields, inputFields);\n        const mergedFieldNames = [...new Set([...receiverFieldNames, ...inputFieldNames])];\n        const mergedEntries = [];\n        mergedFieldNames.forEach((fieldName) => {\n            if (!mergedEntries.some(([name]) => name === fieldName)) {\n                mergedEntries.push([fieldName, undefined]);\n            }\n        });\n        mergedFields = PrepareTemporalFields(mergedFields, mergedEntries);\n        const options = ObjectCreate(null);\n        options.overflow = 'reject';\n        return DateFromFields(calendar, mergedFields, options);\n    }\n    getISOFields() {\n        if (!IsTemporalYearMonth(this))\n            throw new TypeError('invalid receiver');\n        return {\n            calendar: GetSlot(this, CALENDAR),\n            isoDay: GetSlot(this, ISO_DAY),\n            isoMonth: GetSlot(this, ISO_MONTH),\n            isoYear: GetSlot(this, ISO_YEAR)\n        };\n    }\n    static from(item, optionsParam = undefined) {\n        const options = GetOptionsObject(optionsParam);\n        if (IsTemporalYearMonth(item)) {\n            ToTemporalOverflow(options); // validate and ignore\n            return CreateTemporalYearMonth(GetSlot(item, ISO_YEAR), GetSlot(item, ISO_MONTH), GetSlot(item, CALENDAR), GetSlot(item, ISO_DAY));\n        }\n        return ToTemporalYearMonth(item, options);\n    }\n    static compare(oneParam, twoParam) {\n        const one = ToTemporalYearMonth(oneParam);\n        const two = ToTemporalYearMonth(twoParam);\n        return CompareISODate(GetSlot(one, ISO_YEAR), GetSlot(one, ISO_MONTH), GetSlot(one, ISO_DAY), GetSlot(two, ISO_YEAR), GetSlot(two, ISO_MONTH), GetSlot(two, ISO_DAY));\n    }\n}\nMakeIntrinsicClass(PlainYearMonth, 'Temporal.PlainYearMonth');\n\nconst ArrayPrototypePush = Array.prototype.push;\nclass ZonedDateTime {\n    constructor(epochNanosecondsParam, timeZoneParam, calendarParam = GetISO8601Calendar()) {\n        // Note: if the argument is not passed, ToBigInt(undefined) will throw. This check exists only\n        //       to improve the error message.\n        //       ToTemporalTimeZone(undefined) will end up calling TimeZone.from(\"undefined\"), which\n        //       could succeed.\n        if (arguments.length < 1) {\n            throw new TypeError('missing argument: epochNanoseconds is required');\n        }\n        const epochNanoseconds = ToBigInt(epochNanosecondsParam);\n        const timeZone = ToTemporalTimeZone(timeZoneParam);\n        const calendar = ToTemporalCalendar(calendarParam);\n        CreateTemporalZonedDateTimeSlots(this, epochNanoseconds, timeZone, calendar);\n    }\n    get calendar() {\n        if (!IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, CALENDAR);\n    }\n    get timeZone() {\n        if (!IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, TIME_ZONE);\n    }\n    get year() {\n        if (!IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return CalendarYear(GetSlot(this, CALENDAR), dateTime(this));\n    }\n    get month() {\n        if (!IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return CalendarMonth(GetSlot(this, CALENDAR), dateTime(this));\n    }\n    get monthCode() {\n        if (!IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return CalendarMonthCode(GetSlot(this, CALENDAR), dateTime(this));\n    }\n    get day() {\n        if (!IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return CalendarDay(GetSlot(this, CALENDAR), dateTime(this));\n    }\n    get hour() {\n        if (!IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(dateTime(this), ISO_HOUR);\n    }\n    get minute() {\n        if (!IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(dateTime(this), ISO_MINUTE);\n    }\n    get second() {\n        if (!IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(dateTime(this), ISO_SECOND);\n    }\n    get millisecond() {\n        if (!IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(dateTime(this), ISO_MILLISECOND);\n    }\n    get microsecond() {\n        if (!IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(dateTime(this), ISO_MICROSECOND);\n    }\n    get nanosecond() {\n        if (!IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(dateTime(this), ISO_NANOSECOND);\n    }\n    get era() {\n        if (!IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return CalendarEra(GetSlot(this, CALENDAR), dateTime(this));\n    }\n    get eraYear() {\n        if (!IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return CalendarEraYear(GetSlot(this, CALENDAR), dateTime(this));\n    }\n    get epochSeconds() {\n        if (!IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        const value = GetSlot(this, EPOCHNANOSECONDS);\n        return jsbi_umd.toNumber(jsbi_umd.divide(value, BILLION));\n    }\n    get epochMilliseconds() {\n        if (!IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        const value = GetSlot(this, EPOCHNANOSECONDS);\n        return jsbi_umd.toNumber(jsbi_umd.divide(value, MILLION));\n    }\n    get epochMicroseconds() {\n        if (!IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        const value = GetSlot(this, EPOCHNANOSECONDS);\n        return ToBigIntExternal(jsbi_umd.divide(value, THOUSAND));\n    }\n    get epochNanoseconds() {\n        if (!IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return ToBigIntExternal(GetSlot(this, EPOCHNANOSECONDS));\n    }\n    get dayOfWeek() {\n        if (!IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return CalendarDayOfWeek(GetSlot(this, CALENDAR), dateTime(this));\n    }\n    get dayOfYear() {\n        if (!IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return CalendarDayOfYear(GetSlot(this, CALENDAR), dateTime(this));\n    }\n    get weekOfYear() {\n        if (!IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return CalendarWeekOfYear(GetSlot(this, CALENDAR), dateTime(this));\n    }\n    get hoursInDay() {\n        if (!IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        const dt = dateTime(this);\n        const DateTime = GetIntrinsic('%Temporal.PlainDateTime%');\n        const year = GetSlot(dt, ISO_YEAR);\n        const month = GetSlot(dt, ISO_MONTH);\n        const day = GetSlot(dt, ISO_DAY);\n        const today = new DateTime(year, month, day, 0, 0, 0, 0, 0, 0);\n        const tomorrowFields = AddISODate(year, month, day, 0, 0, 0, 1, 'reject');\n        const tomorrow = new DateTime(tomorrowFields.year, tomorrowFields.month, tomorrowFields.day, 0, 0, 0, 0, 0, 0);\n        const timeZone = GetSlot(this, TIME_ZONE);\n        const todayNs = GetSlot(BuiltinTimeZoneGetInstantFor(timeZone, today, 'compatible'), EPOCHNANOSECONDS);\n        const tomorrowNs = GetSlot(BuiltinTimeZoneGetInstantFor(timeZone, tomorrow, 'compatible'), EPOCHNANOSECONDS);\n        return jsbi_umd.toNumber(jsbi_umd.subtract(tomorrowNs, todayNs)) / 3.6e12;\n    }\n    get daysInWeek() {\n        if (!IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return CalendarDaysInWeek(GetSlot(this, CALENDAR), dateTime(this));\n    }\n    get daysInMonth() {\n        if (!IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return CalendarDaysInMonth(GetSlot(this, CALENDAR), dateTime(this));\n    }\n    get daysInYear() {\n        if (!IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return CalendarDaysInYear(GetSlot(this, CALENDAR), dateTime(this));\n    }\n    get monthsInYear() {\n        if (!IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return CalendarMonthsInYear(GetSlot(this, CALENDAR), dateTime(this));\n    }\n    get inLeapYear() {\n        if (!IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return CalendarInLeapYear(GetSlot(this, CALENDAR), dateTime(this));\n    }\n    get offset() {\n        if (!IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return BuiltinTimeZoneGetOffsetStringFor(GetSlot(this, TIME_ZONE), GetSlot(this, INSTANT));\n    }\n    get offsetNanoseconds() {\n        if (!IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return GetOffsetNanosecondsFor(GetSlot(this, TIME_ZONE), GetSlot(this, INSTANT));\n    }\n    with(temporalZonedDateTimeLike, optionsParam = undefined) {\n        if (!IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        if (!IsObject(temporalZonedDateTimeLike)) {\n            throw new TypeError('invalid zoned-date-time-like');\n        }\n        RejectObjectWithCalendarOrTimeZone(temporalZonedDateTimeLike);\n        const options = GetOptionsObject(optionsParam);\n        const disambiguation = ToTemporalDisambiguation(options);\n        const offset = ToTemporalOffset(options, 'prefer');\n        const timeZone = GetSlot(this, TIME_ZONE);\n        const calendar = GetSlot(this, CALENDAR);\n        const fieldNames = CalendarFields(calendar, [\n            'day',\n            'hour',\n            'microsecond',\n            'millisecond',\n            'minute',\n            'month',\n            'monthCode',\n            'nanosecond',\n            'second',\n            'year'\n        ]);\n        ArrayPrototypePush.call(fieldNames, 'offset');\n        const props = ToPartialRecord(temporalZonedDateTimeLike, fieldNames);\n        if (!props) {\n            throw new TypeError('invalid zoned-date-time-like');\n        }\n        // Unlike ToTemporalZonedDateTimeFields, the offset property will be required.\n        const entries = [\n            ['day', undefined],\n            ['hour', 0],\n            ['microsecond', 0],\n            ['millisecond', 0],\n            ['minute', 0],\n            ['month', undefined],\n            ['monthCode', undefined],\n            ['nanosecond', 0],\n            ['second', 0],\n            ['year', undefined],\n            ['offset'],\n            ['timeZone']\n        ];\n        // Add extra fields from the calendar at the end\n        fieldNames.forEach((fieldName) => {\n            if (!entries.some(([name]) => name === fieldName)) {\n                entries.push([fieldName, undefined]);\n            }\n        });\n        let fields = PrepareTemporalFields(this, entries);\n        fields = CalendarMergeFields(calendar, fields, props);\n        fields = PrepareTemporalFields(fields, entries);\n        const { year, month, day, hour, minute, second, millisecond, microsecond, nanosecond } = InterpretTemporalDateTimeFields(calendar, fields, options);\n        const offsetNs = ParseTimeZoneOffsetString(fields.offset);\n        const epochNanoseconds = InterpretISODateTimeOffset(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, 'option', offsetNs, timeZone, disambiguation, offset, \n        /* matchMinute = */ false);\n        return CreateTemporalZonedDateTime(epochNanoseconds, GetSlot(this, TIME_ZONE), calendar);\n    }\n    withPlainDate(temporalDateParam) {\n        if (!IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        const temporalDate = ToTemporalDate(temporalDateParam);\n        const year = GetSlot(temporalDate, ISO_YEAR);\n        const month = GetSlot(temporalDate, ISO_MONTH);\n        const day = GetSlot(temporalDate, ISO_DAY);\n        let calendar = GetSlot(temporalDate, CALENDAR);\n        const thisDt = dateTime(this);\n        const hour = GetSlot(thisDt, ISO_HOUR);\n        const minute = GetSlot(thisDt, ISO_MINUTE);\n        const second = GetSlot(thisDt, ISO_SECOND);\n        const millisecond = GetSlot(thisDt, ISO_MILLISECOND);\n        const microsecond = GetSlot(thisDt, ISO_MICROSECOND);\n        const nanosecond = GetSlot(thisDt, ISO_NANOSECOND);\n        calendar = ConsolidateCalendars(GetSlot(this, CALENDAR), calendar);\n        const timeZone = GetSlot(this, TIME_ZONE);\n        const PlainDateTime = GetIntrinsic('%Temporal.PlainDateTime%');\n        const dt = new PlainDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar);\n        const instant = BuiltinTimeZoneGetInstantFor(timeZone, dt, 'compatible');\n        return CreateTemporalZonedDateTime(GetSlot(instant, EPOCHNANOSECONDS), timeZone, calendar);\n    }\n    withPlainTime(temporalTimeParam = undefined) {\n        if (!IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        const PlainTime = GetIntrinsic('%Temporal.PlainTime%');\n        const temporalTime = temporalTimeParam == undefined ? new PlainTime() : ToTemporalTime(temporalTimeParam);\n        const thisDt = dateTime(this);\n        const year = GetSlot(thisDt, ISO_YEAR);\n        const month = GetSlot(thisDt, ISO_MONTH);\n        const day = GetSlot(thisDt, ISO_DAY);\n        const calendar = GetSlot(this, CALENDAR);\n        const hour = GetSlot(temporalTime, ISO_HOUR);\n        const minute = GetSlot(temporalTime, ISO_MINUTE);\n        const second = GetSlot(temporalTime, ISO_SECOND);\n        const millisecond = GetSlot(temporalTime, ISO_MILLISECOND);\n        const microsecond = GetSlot(temporalTime, ISO_MICROSECOND);\n        const nanosecond = GetSlot(temporalTime, ISO_NANOSECOND);\n        const timeZone = GetSlot(this, TIME_ZONE);\n        const PlainDateTime = GetIntrinsic('%Temporal.PlainDateTime%');\n        const dt = new PlainDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar);\n        const instant = BuiltinTimeZoneGetInstantFor(timeZone, dt, 'compatible');\n        return CreateTemporalZonedDateTime(GetSlot(instant, EPOCHNANOSECONDS), timeZone, calendar);\n    }\n    withTimeZone(timeZoneParam) {\n        if (!IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        const timeZone = ToTemporalTimeZone(timeZoneParam);\n        return CreateTemporalZonedDateTime(GetSlot(this, EPOCHNANOSECONDS), timeZone, GetSlot(this, CALENDAR));\n    }\n    withCalendar(calendarParam) {\n        if (!IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        const calendar = ToTemporalCalendar(calendarParam);\n        return CreateTemporalZonedDateTime(GetSlot(this, EPOCHNANOSECONDS), GetSlot(this, TIME_ZONE), calendar);\n    }\n    add(temporalDurationLike, optionsParam = undefined) {\n        if (!IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        const duration = ToLimitedTemporalDuration(temporalDurationLike);\n        const { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = duration;\n        const options = GetOptionsObject(optionsParam);\n        const timeZone = GetSlot(this, TIME_ZONE);\n        const calendar = GetSlot(this, CALENDAR);\n        const epochNanoseconds = AddZonedDateTime(GetSlot(this, INSTANT), timeZone, calendar, years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, options);\n        return CreateTemporalZonedDateTime(epochNanoseconds, timeZone, calendar);\n    }\n    subtract(temporalDurationLike, optionsParam = undefined) {\n        if (!IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        const duration = ToLimitedTemporalDuration(temporalDurationLike);\n        const { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = duration;\n        const options = GetOptionsObject(optionsParam);\n        const timeZone = GetSlot(this, TIME_ZONE);\n        const calendar = GetSlot(this, CALENDAR);\n        const epochNanoseconds = AddZonedDateTime(GetSlot(this, INSTANT), timeZone, calendar, -years, -months, -weeks, -days, -hours, -minutes, -seconds, -milliseconds, -microseconds, -nanoseconds, options);\n        return CreateTemporalZonedDateTime(epochNanoseconds, timeZone, calendar);\n    }\n    until(otherParam, optionsParam = undefined) {\n        if (!IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        const other = ToTemporalZonedDateTime(otherParam);\n        const calendar = GetSlot(this, CALENDAR);\n        const otherCalendar = GetSlot(other, CALENDAR);\n        const calendarId = ToString(calendar);\n        const otherCalendarId = ToString(otherCalendar);\n        if (calendarId !== otherCalendarId) {\n            throw new RangeError(`cannot compute difference between dates of ${calendarId} and ${otherCalendarId} calendars`);\n        }\n        const options = GetOptionsObject(optionsParam);\n        const smallestUnit = ToSmallestTemporalUnit(options, 'nanosecond');\n        const defaultLargestUnit = LargerOfTwoTemporalUnits('hour', smallestUnit);\n        const largestUnit = ToLargestTemporalUnit(options, 'auto', [], defaultLargestUnit);\n        ValidateTemporalUnitRange(largestUnit, smallestUnit);\n        const roundingMode = ToTemporalRoundingMode(options, 'trunc');\n        const roundingIncrement = ToTemporalDateTimeRoundingIncrement(options, smallestUnit);\n        const ns1 = GetSlot(this, EPOCHNANOSECONDS);\n        const ns2 = GetSlot(other, EPOCHNANOSECONDS);\n        let years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds;\n        if (largestUnit !== 'year' && largestUnit !== 'month' && largestUnit !== 'week' && largestUnit !== 'day') {\n            // The user is only asking for a time difference, so return difference of instants.\n            years = 0;\n            months = 0;\n            weeks = 0;\n            days = 0;\n            ({ seconds, milliseconds, microseconds, nanoseconds } = DifferenceInstant(ns1, ns2, roundingIncrement, smallestUnit, roundingMode));\n            ({ hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = BalanceDuration(0, 0, 0, seconds, milliseconds, microseconds, nanoseconds, largestUnit));\n        }\n        else {\n            const timeZone = GetSlot(this, TIME_ZONE);\n            if (!TimeZoneEquals(timeZone, GetSlot(other, TIME_ZONE))) {\n                throw new RangeError(\"When calculating difference between time zones, largestUnit must be 'hours' \" +\n                    'or smaller because day lengths can vary between time zones due to DST or time zone offset changes.');\n            }\n            const untilOptions = { ...options, largestUnit };\n            ({ years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } =\n                DifferenceZonedDateTime(ns1, ns2, timeZone, calendar, largestUnit, untilOptions));\n            ({ years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } =\n                RoundDuration(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, roundingIncrement, smallestUnit, roundingMode, this));\n            ({ years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } =\n                AdjustRoundedDurationDays(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, roundingIncrement, smallestUnit, roundingMode, this));\n        }\n        const Duration = GetIntrinsic('%Temporal.Duration%');\n        return new Duration(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n    }\n    since(otherParam, optionsParam = undefined) {\n        if (!IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        const other = ToTemporalZonedDateTime(otherParam);\n        const calendar = GetSlot(this, CALENDAR);\n        const otherCalendar = GetSlot(other, CALENDAR);\n        const calendarId = ToString(calendar);\n        const otherCalendarId = ToString(otherCalendar);\n        if (calendarId !== otherCalendarId) {\n            throw new RangeError(`cannot compute difference between dates of ${calendarId} and ${otherCalendarId} calendars`);\n        }\n        const options = GetOptionsObject(optionsParam);\n        const smallestUnit = ToSmallestTemporalUnit(options, 'nanosecond');\n        const defaultLargestUnit = LargerOfTwoTemporalUnits('hour', smallestUnit);\n        const largestUnit = ToLargestTemporalUnit(options, 'auto', [], defaultLargestUnit);\n        ValidateTemporalUnitRange(largestUnit, smallestUnit);\n        let roundingMode = ToTemporalRoundingMode(options, 'trunc');\n        roundingMode = NegateTemporalRoundingMode(roundingMode);\n        const roundingIncrement = ToTemporalDateTimeRoundingIncrement(options, smallestUnit);\n        const ns1 = GetSlot(this, EPOCHNANOSECONDS);\n        const ns2 = GetSlot(other, EPOCHNANOSECONDS);\n        let years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds;\n        if (largestUnit !== 'year' && largestUnit !== 'month' && largestUnit !== 'week' && largestUnit !== 'day') {\n            // The user is only asking for a time difference, so return difference of instants.\n            years = 0;\n            months = 0;\n            weeks = 0;\n            days = 0;\n            ({ seconds, milliseconds, microseconds, nanoseconds } = DifferenceInstant(ns1, ns2, roundingIncrement, smallestUnit, roundingMode));\n            ({ hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = BalanceDuration(0, 0, 0, seconds, milliseconds, microseconds, nanoseconds, largestUnit));\n        }\n        else {\n            const timeZone = GetSlot(this, TIME_ZONE);\n            if (!TimeZoneEquals(timeZone, GetSlot(other, TIME_ZONE))) {\n                throw new RangeError(\"When calculating difference between time zones, largestUnit must be 'hours' \" +\n                    'or smaller because day lengths can vary between time zones due to DST or time zone offset changes.');\n            }\n            const untilOptions = { ...options, largestUnit };\n            ({ years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } =\n                DifferenceZonedDateTime(ns1, ns2, timeZone, calendar, largestUnit, untilOptions));\n            ({ years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } =\n                RoundDuration(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, roundingIncrement, smallestUnit, roundingMode, this));\n            ({ years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } =\n                AdjustRoundedDurationDays(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, roundingIncrement, smallestUnit, roundingMode, this));\n        }\n        const Duration = GetIntrinsic('%Temporal.Duration%');\n        return new Duration(-years, -months, -weeks, -days, -hours, -minutes, -seconds, -milliseconds, -microseconds, -nanoseconds);\n    }\n    round(optionsParam) {\n        if (!IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        if (optionsParam === undefined)\n            throw new TypeError('options parameter is required');\n        const options = typeof optionsParam === 'string'\n            ? CreateOnePropObject('smallestUnit', optionsParam)\n            : GetOptionsObject(optionsParam);\n        const smallestUnit = ToSmallestTemporalUnit(options, undefined, ['year', 'month', 'week']);\n        if (smallestUnit === undefined)\n            throw new RangeError('smallestUnit is required');\n        const roundingMode = ToTemporalRoundingMode(options, 'halfExpand');\n        const maximumIncrements = {\n            day: 1,\n            hour: 24,\n            minute: 60,\n            second: 60,\n            millisecond: 1000,\n            microsecond: 1000,\n            nanosecond: 1000\n        };\n        const roundingIncrement = ToTemporalRoundingIncrement(options, maximumIncrements[smallestUnit], false);\n        // first, round the underlying DateTime fields\n        const dt = dateTime(this);\n        let year = GetSlot(dt, ISO_YEAR);\n        let month = GetSlot(dt, ISO_MONTH);\n        let day = GetSlot(dt, ISO_DAY);\n        let hour = GetSlot(dt, ISO_HOUR);\n        let minute = GetSlot(dt, ISO_MINUTE);\n        let second = GetSlot(dt, ISO_SECOND);\n        let millisecond = GetSlot(dt, ISO_MILLISECOND);\n        let microsecond = GetSlot(dt, ISO_MICROSECOND);\n        let nanosecond = GetSlot(dt, ISO_NANOSECOND);\n        const DateTime = GetIntrinsic('%Temporal.PlainDateTime%');\n        const timeZone = GetSlot(this, TIME_ZONE);\n        const calendar = GetSlot(this, CALENDAR);\n        const dtStart = new DateTime(GetSlot(dt, ISO_YEAR), GetSlot(dt, ISO_MONTH), GetSlot(dt, ISO_DAY), 0, 0, 0, 0, 0, 0);\n        const instantStart = BuiltinTimeZoneGetInstantFor(timeZone, dtStart, 'compatible');\n        const endNs = AddZonedDateTime(instantStart, timeZone, calendar, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0);\n        const dayLengthNs = jsbi_umd.subtract(endNs, jsbi_umd.BigInt(GetSlot(instantStart, EPOCHNANOSECONDS)));\n        if (jsbi_umd.equal(dayLengthNs, ZERO)) {\n            throw new RangeError('cannot round a ZonedDateTime in a calendar with zero-length days');\n        }\n        ({ year, month, day, hour, minute, second, millisecond, microsecond, nanosecond } = RoundISODateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, roundingIncrement, smallestUnit, roundingMode, \n        // Days are guaranteed to be shorter than Number.MAX_SAFE_INTEGER\n        // (which can hold up to 104 days in nanoseconds)\n        jsbi_umd.toNumber(dayLengthNs)));\n        // Now reset all DateTime fields but leave the TimeZone. The offset will\n        // also be retained if the new date/time values are still OK with the old\n        // offset. Otherwise the offset will be changed to be compatible with the\n        // new date/time values. If DST disambiguation is required, the `compatible`\n        // disambiguation algorithm will be used.\n        const offsetNs = GetOffsetNanosecondsFor(timeZone, GetSlot(this, INSTANT));\n        const epochNanoseconds = InterpretISODateTimeOffset(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, 'option', offsetNs, timeZone, 'compatible', 'prefer', \n        /* matchMinute = */ false);\n        return CreateTemporalZonedDateTime(epochNanoseconds, timeZone, GetSlot(this, CALENDAR));\n    }\n    equals(otherParam) {\n        if (!IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        const other = ToTemporalZonedDateTime(otherParam);\n        const one = GetSlot(this, EPOCHNANOSECONDS);\n        const two = GetSlot(other, EPOCHNANOSECONDS);\n        if (!jsbi_umd.equal(jsbi_umd.BigInt(one), jsbi_umd.BigInt(two)))\n            return false;\n        if (!TimeZoneEquals(GetSlot(this, TIME_ZONE), GetSlot(other, TIME_ZONE)))\n            return false;\n        return CalendarEquals(GetSlot(this, CALENDAR), GetSlot(other, CALENDAR));\n    }\n    toString(optionsParam = undefined) {\n        if (!IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        const options = GetOptionsObject(optionsParam);\n        const { precision, unit, increment } = ToSecondsStringPrecision(options);\n        const roundingMode = ToTemporalRoundingMode(options, 'trunc');\n        const showCalendar = ToShowCalendarOption(options);\n        const showTimeZone = ToShowTimeZoneNameOption(options);\n        const showOffset = ToShowOffsetOption(options);\n        return TemporalZonedDateTimeToString(this, precision, showCalendar, showTimeZone, showOffset, {\n            unit,\n            increment,\n            roundingMode\n        });\n    }\n    toLocaleString(locales = undefined, options = undefined) {\n        if (!IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return new DateTimeFormat(locales, options).format(this);\n    }\n    toJSON() {\n        if (!IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return TemporalZonedDateTimeToString(this, 'auto');\n    }\n    valueOf() {\n        throw new TypeError('use compare() or equals() to compare Temporal.ZonedDateTime');\n    }\n    startOfDay() {\n        if (!IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        const dt = dateTime(this);\n        const DateTime = GetIntrinsic('%Temporal.PlainDateTime%');\n        const calendar = GetSlot(this, CALENDAR);\n        const dtStart = new DateTime(GetSlot(dt, ISO_YEAR), GetSlot(dt, ISO_MONTH), GetSlot(dt, ISO_DAY), 0, 0, 0, 0, 0, 0, calendar);\n        const timeZone = GetSlot(this, TIME_ZONE);\n        const instant = BuiltinTimeZoneGetInstantFor(timeZone, dtStart, 'compatible');\n        return CreateTemporalZonedDateTime(GetSlot(instant, EPOCHNANOSECONDS), timeZone, calendar);\n    }\n    toInstant() {\n        if (!IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        const TemporalInstant = GetIntrinsic('%Temporal.Instant%');\n        return new TemporalInstant(GetSlot(this, EPOCHNANOSECONDS));\n    }\n    toPlainDate() {\n        if (!IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return TemporalDateTimeToDate(dateTime(this));\n    }\n    toPlainTime() {\n        if (!IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return TemporalDateTimeToTime(dateTime(this));\n    }\n    toPlainDateTime() {\n        if (!IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return dateTime(this);\n    }\n    toPlainYearMonth() {\n        if (!IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        const calendar = GetSlot(this, CALENDAR);\n        const fieldNames = CalendarFields(calendar, ['monthCode', 'year']);\n        const fields = ToTemporalYearMonthFields(this, fieldNames);\n        return YearMonthFromFields(calendar, fields);\n    }\n    toPlainMonthDay() {\n        if (!IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        const calendar = GetSlot(this, CALENDAR);\n        const fieldNames = CalendarFields(calendar, ['day', 'monthCode']);\n        const fields = ToTemporalMonthDayFields(this, fieldNames);\n        return MonthDayFromFields(calendar, fields);\n    }\n    getISOFields() {\n        if (!IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        const dt = dateTime(this);\n        const tz = GetSlot(this, TIME_ZONE);\n        return {\n            calendar: GetSlot(this, CALENDAR),\n            isoDay: GetSlot(dt, ISO_DAY),\n            isoHour: GetSlot(dt, ISO_HOUR),\n            isoMicrosecond: GetSlot(dt, ISO_MICROSECOND),\n            isoMillisecond: GetSlot(dt, ISO_MILLISECOND),\n            isoMinute: GetSlot(dt, ISO_MINUTE),\n            isoMonth: GetSlot(dt, ISO_MONTH),\n            isoNanosecond: GetSlot(dt, ISO_NANOSECOND),\n            isoSecond: GetSlot(dt, ISO_SECOND),\n            isoYear: GetSlot(dt, ISO_YEAR),\n            offset: BuiltinTimeZoneGetOffsetStringFor(tz, GetSlot(this, INSTANT)),\n            timeZone: tz\n        };\n    }\n    static from(item, optionsParam = undefined) {\n        const options = GetOptionsObject(optionsParam);\n        if (IsTemporalZonedDateTime(item)) {\n            ToTemporalOverflow(options); // validate and ignore\n            ToTemporalDisambiguation(options);\n            ToTemporalOffset(options, 'reject');\n            return CreateTemporalZonedDateTime(GetSlot(item, EPOCHNANOSECONDS), GetSlot(item, TIME_ZONE), GetSlot(item, CALENDAR));\n        }\n        return ToTemporalZonedDateTime(item, options);\n    }\n    static compare(oneParam, twoParam) {\n        const one = ToTemporalZonedDateTime(oneParam);\n        const two = ToTemporalZonedDateTime(twoParam);\n        const ns1 = GetSlot(one, EPOCHNANOSECONDS);\n        const ns2 = GetSlot(two, EPOCHNANOSECONDS);\n        if (jsbi_umd.lessThan(jsbi_umd.BigInt(ns1), jsbi_umd.BigInt(ns2)))\n            return -1;\n        if (jsbi_umd.greaterThan(jsbi_umd.BigInt(ns1), jsbi_umd.BigInt(ns2)))\n            return 1;\n        return 0;\n    }\n}\nMakeIntrinsicClass(ZonedDateTime, 'Temporal.ZonedDateTime');\nfunction dateTime(zdt) {\n    return BuiltinTimeZoneGetPlainDateTimeFor(GetSlot(zdt, TIME_ZONE), GetSlot(zdt, INSTANT), GetSlot(zdt, CALENDAR));\n}\n\nvar temporal = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    Instant: Instant,\n    Calendar: Calendar,\n    PlainDate: PlainDate,\n    PlainDateTime: PlainDateTime,\n    Duration: Duration,\n    PlainMonthDay: PlainMonthDay,\n    Now: Now,\n    PlainTime: PlainTime,\n    TimeZone: TimeZone,\n    PlainYearMonth: PlainYearMonth,\n    ZonedDateTime: ZonedDateTime\n});\n\nfunction toTemporalInstant() {\n    // Observable access to valueOf is not correct here, but unavoidable\n    const epochNanoseconds = JSBI.multiply(JSBI.BigInt(+this), MILLION);\n    return new Instant(ToBigInt(epochNanoseconds));\n}\n\n// This entry point treats Temporal as a library, and does not polyfill it onto\n// Work around https://github.com/babel/babel/issues/2025.\nconst types = [\n    Instant,\n    Calendar,\n    PlainDate,\n    PlainDateTime,\n    Duration,\n    PlainMonthDay,\n    // Temporal.Now, // plain object (not a constructor), so no `prototype`\n    PlainTime,\n    TimeZone,\n    PlainYearMonth,\n    ZonedDateTime\n];\nfor (const type of types) {\n    const descriptor = Object.getOwnPropertyDescriptor(type, 'prototype');\n    if (descriptor.configurable || descriptor.enumerable || descriptor.writable) {\n        descriptor.configurable = false;\n        descriptor.enumerable = false;\n        descriptor.writable = false;\n        Object.defineProperty(type, 'prototype', descriptor);\n    }\n}\n\n\n//# sourceMappingURL=index.esm.js.map\n\n;// CONCATENATED MODULE: ./src/js/time.js\n\n\n// 2022-03-16T03:52 => 03/16/2022 @ 03:52 AM\nconst dateFilter = (date) => {\n    let splitTimeAndDate = date.split('T');\n    let splitDate = splitTimeAndDate[0].split('-');\n    let splitTime = splitTimeAndDate[1].split(':');\n    let fixedHour = 0;\n    if(splitTime[0] >= 0 && splitTime[0] < 12){\n        fixedHour = splitTime[0]+ ':' + splitTime[1]+'AM';\n    }\n    else{\n        fixedHour = splitTime[0]+ ':' + splitTime[1]+'PM';  \n    }\n    let fixedDate = splitDate[1] + '/' + splitDate[2] + '/' + splitDate[0];\n    let fixedTimeAndDate =  fixedDate + ' @ ' + fixedHour;\n    return fixedTimeAndDate;\n}\nconst convertDate = (date) => {\n    let dd_date = date.value.substring(0, 10);\n\n    let dd_year = dd_date.substring(0, 4);\n    let dd_month = dd_date.substring(5, 7);\n    let dd_day = dd_date.substring(8, 10);\n    \n    return { dd_date, dd_year, dd_month, dd_day };\n};\n\n// Temporal\n\nconst now = () => {\n    return temporal.Now.zonedDateTimeISO().toPlainDateTime().round({smallestUnit: \"minute\", roundingMode: \"floor\"}).toString();\n};\n\nconst today = () => {\n    return temporal.Now.zonedDateTimeISO().toPlainDate().toString();\n};\n\nconst thisWeek = () => {\n    let today = temporal.Now.zonedDateTimeISO()\n    let oneWeekFromToday = today.add({ days: 7});\n    return oneWeekFromToday.toPlainDate();\n};\n\nconst todayCheck = (yearCheck, monthCheck, dayCheck) => {\n    return Temporal.PlainDate.from({year: yearCheck, month: monthCheck, day: dayCheck}).equals(today());\n};\n\nconst thisWeekCheck = (yearCheck, monthCheck, dayCheck) => {\n\n    let convertedDate = Temporal.PlainDate.from({year: yearCheck, month: monthCheck, day: dayCheck});\n    let difference = convertedDate.until(thisWeek()).days;\n\n    if (+difference <= 7 && +difference >= 0){\n        return true;\n    }\n    else{\n        return false;\n    }\n};\n;// CONCATENATED MODULE: ./src/js/todo.js\n\n\n\nconst Todo = (title, description, dueDate, priority, id) => {\n\n    const getTitle = () => title;\n    const getDescription = () => description;\n    const getDueDate = () => dueDate;\n    const getPriority = () => priority;\n    const getID = () => id;\n\n    const setTitle = (newTitle) => title = newTitle; \n    const setDescription = (newDescription) => description = newDescription;\n    const setDueDate = (newDueDate) => dueDate = newDueDate;\n    const setPriority = (newPriority) => priority = newPriority;\n    const setID = (newID) => id = newID;\n\n    // pass in value from getDueDate() to get Temporal-friendly date format\n    const convertedDate = (calendarDate) => {\n        let dd_date = calendarDate.substring(0, 10);\n        return { dd_date };\n    };\n\n    const isTodayCheck = (convertedDate) => {\n        let dateHolder = convertedDate.dd_date;\n        let date = dateHolder.substring(0, 10);\n        let yr = date.substring(0, 4);\n        let month = date.substring(5, 7);\n        let day = date.substring(8, 10);\n        return temporal.PlainDate.from({year: yr, month: month, day: day}).equals(today());\n    };\n\n    const isThisWeekCheck = (convertedDate) => {\n        let dateHolder = convertedDate.dd_date;\n        let date = dateHolder.substring(0, 10);\n        let yr = date.substring(0, 4);\n        let month = date.substring(5, 7);\n        let day = date.substring(8, 10);\n\n        let temporalDateFormat = temporal.PlainDate.from({year: yr, month: month, day: day});\n        let difference = temporalDateFormat.until(thisWeek()).days;\n\n        if (+difference <= 7 && +difference >= 0){\n            return true;\n        }\n        else{\n            return false;\n        }\n    };\n\n    return { getTitle, getDescription, getDueDate, getPriority, getID, setTitle, setDescription, \n        setDueDate, setPriority, setID, convertedDate, isTodayCheck, isThisWeekCheck, \n    };\n};\n;// CONCATENATED MODULE: ./src/js/project.js\nconst Project = (title, index) => {\n\n    let arr = [];\n\n    const getTitle = () => title;\n    const getIndex = () => index;\n    \n    const setTitle = (newTitle) => title = newTitle; \n    const setIndex = (newIndex) => index = newIndex;\n\n    const addToList = (obj) => arr.push(obj);\n    const removeFromList = (targetID) => {\n        let index;\n        for(let i = 0; i < arr.length; i++){\n            if (arr[i].getID() == targetID){\n                index = i;\n            }\n            if(index > -1){\n                arr.splice(index, 1);\n            }\n        }\n    };\n\n    const filterTodaysToDos = () => {\n        const todaysToDos = arr.filter(toDo => toDo.isTodayCheck(toDo.convertedDate(toDo.getDueDate())));\n        return todaysToDos;\n    };\n    const filterThisWeeksToDos = () => {\n        const thisWeeksToDos = arr.filter(toDo => toDo.isThisWeekCheck(toDo.convertedDate(toDo.getDueDate())));\n        return thisWeeksToDos;\n    }\n\n    return {getTitle, getIndex, setTitle, \n        setIndex, arr, addToList, removeFromList,\n        filterTodaysToDos, filterThisWeeksToDos,\n    };\n};\n;// CONCATENATED MODULE: ./src/js/defaultProjects.js\n\n\n\n\n// localStorage.clear();\n\nconst listOfProjects = JSON.parse(localStorage.getItem('lists')) || [];\nlet currentProjectIndex = localStorage.getItem('listID') || 0;\n\nlet a = Todo('hi', 'hi', '2022-03-22T03:45', 'High', 10);\n\nlet projectCount = 0;\n\nconst defaultProj = Project(\"General\", projectCount);\nprojectCount++;\nlistOfProjects.push(defaultProj);\n\nconst everythingProj = Project(\"Everything\", projectCount);\nprojectCount++;\neverythingProj.addToList(a);\nlistOfProjects.push(everythingProj);\n\nconst defaultProjects_todaysToDos = Project(\"Today's 2Dos\", projectCount);\nprojectCount++;\nlistOfProjects.push(defaultProjects_todaysToDos);\n\nconst defaultProjects_thisWeeksToDos = Project(\"Week's 2Dos\", projectCount);\nprojectCount++;\nlistOfProjects.push(defaultProjects_thisWeeksToDos);\n\n\n/* harmony default export */ const defaultProjects = ({\n    listOfProjects, currentProjectIndex, projectCount,\n    defaultProj, todaysToDos: defaultProjects_todaysToDos, thisWeeksToDos: defaultProjects_thisWeeksToDos\n});\n;// CONCATENATED MODULE: ./src/js/createModals.js\nconst createProjectModal = () => {\n    \n    const newModal = document.createElement('dialog');\n    newModal.classList.add('projectModal');\n    newModal.setAttribute('id', 'projectModal');\n\n    const projectModalHeader = document.createElement('h2');\n    projectModalHeader.textContent = 'New Project';\n\n    const projectModalForm = document.createElement('form');\n    projectModalForm.classList.add('projectForm');\n    projectModalForm.setAttribute('method', 'dialog');\n\n    const projectNameDiv = document.createElement('div');\n    const projectName = document.createElement('input');\n    const projectNameLabel = document.createElement('label');\n    projectName.setAttribute('type', 'text');\n    projectName.setAttribute('name', 'projectName');\n    projectName.setAttribute('id', 'projectName');\n    projectName.setAttribute('placeholder', 'Fitness');\n    projectNameLabel.setAttribute('for', 'projectName');\n    projectNameLabel.textContent = 'Title';\n    projectNameDiv.appendChild(projectNameLabel);\n    projectNameDiv.appendChild(projectName);\n\n    const btns = document.createElement('div');\n    btns.classList.add('btns');\n    const submitBtn = document.createElement('button');\n    submitBtn.innerHTML = `<i class=\"fa-solid fa-check\"></i>`;\n    submitBtn.classList.add('submitProjectBtn');\n    submitBtn.setAttribute('type', 'button');\n    const cancelBtn = document.createElement('button');\n    cancelBtn.innerHTML = `<i class=\"fa-solid fa-ban\"></i>`;\n    cancelBtn.classList.add('cancelProjectBtn');\n    submitBtn.setAttribute('type', 'button');\n    btns.appendChild(submitBtn);\n    btns.appendChild(cancelBtn);\n\n    newModal.appendChild(projectModalHeader);\n    projectModalForm.appendChild(projectNameDiv);\n    projectModalForm.appendChild(btns);\n    newModal.appendChild(projectModalForm);\n\n    return {newModal, projectModalForm, projectName, submitBtn, cancelBtn};\n};\n\n\nconst createEditModal = (name, description, dueDate, priority) => {\n    \n    const newModal = document.createElement('dialog');\n    newModal.classList.add('editModal');\n    newModal.setAttribute('id', 'editModal');\n\n    const editModalHeader = document.createElement('h2');\n    editModalHeader.textContent = 'Edit Task';\n\n    const editModalForm = document.createElement('form');\n    editModalForm.classList.add('editForm');\n    editModalForm.setAttribute('method', 'dialog');\n\n    const taskNameDiv = document.createElement('div');\n    const taskName = document.createElement('input');\n    const taskNameLabel = document.createElement('label');\n    taskName.setAttribute('type', 'text');\n    taskName.setAttribute('name', 'taskName');\n    taskName.setAttribute('id', 'taskName');\n    taskName.setAttribute('placeholder', 'Take out the trash');\n    taskName.setAttribute('value', name);\n    taskNameLabel.setAttribute('for', 'taskName');\n    taskNameLabel.textContent = 'Title';\n    taskNameDiv.appendChild(taskNameLabel);\n    taskNameDiv.appendChild(taskName);\n\n    const taskDescriptionDiv = document.createElement('div');\n    const taskDescription = document.createElement('textarea');\n    const taskDescriptionLabel = document.createElement('label');\n    taskDescription.setAttribute('name', 'taskDescription');\n    taskDescription.setAttribute('id', 'taskDescription');\n    taskDescription.setAttribute('placeholder', 'I avoid the acumulation of trash by performing the sacred art of removing said trash...');\n    taskDescription.value = description;\n    taskDescriptionLabel.setAttribute('for', 'taskDescription');\n    taskDescriptionLabel.textContent = 'Description';\n    taskDescriptionDiv.appendChild(taskDescriptionLabel);\n    taskDescriptionDiv.appendChild(taskDescription);\n\n    const taskDueDateDiv = document.createElement('div');\n    const taskDueDate = document.createElement('input');\n    const taskDueDateLabel = document.createElement('label');\n    taskDueDate.setAttribute('type', 'datetime-local');\n    taskDueDate.setAttribute('name', 'taskDueDate');\n    taskDueDate.setAttribute('id', 'taskDueDate');\n    taskDueDate.setAttribute('value', dueDate);\n    taskDueDateLabel.setAttribute('for', 'taskDueDate');\n    taskDueDateLabel.textContent = 'Due Date';\n    taskDueDateDiv.appendChild(taskDueDateLabel);\n    taskDueDateDiv.appendChild(taskDueDate);\n\n    const taskPriorityDiv = document.createElement('div');\n    const taskPriority = document.createElement('select');\n    const taskPriorityLabel = document.createElement('label');\n    taskPriority.setAttribute('name', 'taskPriority');\n    taskPriority.setAttribute('id', 'taskPriorityEdit');\n    taskPriorityLabel.setAttribute('for', 'taskPriority');\n    taskPriorityLabel.textContent = 'Priority';\n    const highPriority = document.createElement('option');\n    highPriority.textContent = 'High';\n    const normalPriority = document.createElement('option');\n    normalPriority.textContent = 'Normal';\n    const lowPriority = document.createElement('option');\n    lowPriority.textContent = 'Low';\n\n    taskPriority.appendChild(highPriority);\n    taskPriority.appendChild(normalPriority);\n    taskPriority.appendChild(lowPriority);\n\n    taskPriority.value = priority;\n    \n    taskPriorityDiv.appendChild(taskPriorityLabel);\n    taskPriorityDiv.appendChild(taskPriority);\n\n    const btns = document.createElement('div');\n    btns.classList.add('btns');\n    const submitBtn = document.createElement('button');\n    submitBtn.innerHTML = `<i class=\"fa-solid fa-check\"></i>`;\n    submitBtn.classList.add('submitEditBtn');\n    submitBtn.setAttribute('type', 'button');\n    const cancelBtn = document.createElement('button');\n    cancelBtn.innerHTML = `<i class=\"fa-solid fa-ban\"></i>`;\n    cancelBtn.classList.add('cancelEditBtn');\n    submitBtn.setAttribute('type', 'button');\n    btns.appendChild(submitBtn);\n    btns.appendChild(cancelBtn);\n\n    newModal.appendChild(editModalHeader);\n    editModalForm.appendChild(taskNameDiv);\n    editModalForm.appendChild(taskDescriptionDiv);\n    editModalForm.appendChild(taskDueDateDiv);\n    editModalForm.appendChild(taskPriorityDiv);\n    editModalForm.appendChild(btns);\n    newModal.appendChild(editModalForm);\n\n    return {newModal, editModalForm, taskName, taskDueDate, taskPriority, \n        taskDescription, submitBtn, cancelBtn};\n};\n;// CONCATENATED MODULE: ./src/js/addListeners.js\n\n\n\n\n\n\n\nconst addEventListeners = () => {\n    // remove toDo\n    const trashBtns = document.querySelectorAll('.fa-trash-can');\n    for (let i = 0; i < trashBtns.length; i++) {\n        trashBtns[i].addEventListener('click', deleteToDo);\n    }\n    // mark complete\n    const uncheckedBoxes = document.querySelectorAll('.fa-square');\n    for (let i = 0; i < uncheckedBoxes.length; i++) {\n        uncheckedBoxes[i].addEventListener('click', completeToDo);\n    }\n    // mark incomplete\n    const checkedBoxes = document.querySelectorAll('.fa-square-check');\n    for (let i = 0; i < checkedBoxes.length; i++) {\n        checkedBoxes[i].addEventListener('click', undoToDoCompletion);\n    }\n    // edit toDo modal\n    const editModalBtns = document.querySelectorAll('.fa-pen-to-square');\n    for (let i = 0; i < editModalBtns.length; i++) {\n        editModalBtns[i].addEventListener('click', instantiateEditModal);\n    }\n    // create toDo modal\n    documentParts.addToDoBtn.addEventListener('click', instantiateCreationModal);\n    // create project modal\n    documentParts.addProjectBtn.addEventListener('click', instantiateProjectModal);\n    // remove project modal\n    const removeProjectBtns = document.querySelectorAll('.fa-circle-minus');\n    for (let i = 0; i < removeProjectBtns.length; i++) {\n        removeProjectBtns[i].addEventListener('click', removeProject);\n    }\n    \n};\n\n\n// selectedProject ex. defaults.listOfProjects[defaults.currentProjectIndex]\ndocumentParts.sidebar.addEventListener('click', loadProject);\n\nfunction loadProject (e) {\n    if(e.target.classList.contains('otherProjects')){\n        // setup\n        const projIndex = e.target.getAttribute('data-index');\n        defaultProjects.currentProjectIndex = projIndex;\n        documentParts.table.textContent = '';\n        // generateTableHeader \n        let tr = document.createElement('tr');\n        tr.classList.add('titles');\n        let thProjName = document.createElement('th');\n        thProjName.classList.add('projName');\n\n        if (defaultProjects.listOfProjects[defaultProjects.currentProjectIndex].getTitle().length > 0){\n            thProjName.textContent = defaultProjects.listOfProjects[defaultProjects.currentProjectIndex].getTitle().substring(0,30);\n        }\n        else{\n            thProjName.textContent = 'Unnamed';\n        }\n        let thDueDate = document.createElement('th');\n        thDueDate.classList.add('dueDate');\n        thDueDate.innerHTML = `Due Date <i class=\"fa-solid fa-calendar-day\"></i>`;\n        tr.appendChild(thProjName);\n        tr.appendChild(thDueDate);\n        documentParts.table.appendChild(tr);\n        // generate rows\n        const makeRow = (row) => {\n            const tr = document.createElement('tr');\n            tr.classList.add('createdRow');\n            tr.setAttribute('data-index', `${row.getID()}`);\n            const td1 = document.createElement('td');\n            const td2 = document.createElement('td');\n            td1.classList.add('column1');\n            td2.classList.add('column2');\n\n            documentParts.setPriorityColors(row.getPriority(), td1);\n    \n            td1.innerHTML = `<i class=\"fa-regular fa-square\"></i> ${row.getTitle()}`;\n            td2.innerHTML = `${dateFilter(row.getDueDate())} <i class=\"fa-regular fa-pen-to-square\"></i><i class=\"fa-regular fa-trash-can\"></i>`;\n    \n            tr.appendChild(td1);\n            tr.appendChild(td2);\n    \n            return tr;\n        };\n    \n        for (let i = 0; i < defaultProjects.listOfProjects[defaultProjects.currentProjectIndex].arr.length; i++) {\n            documentParts.table.appendChild(makeRow(defaultProjects.listOfProjects[defaultProjects.currentProjectIndex].arr[i]));\n        }\n\n        if(!documentParts.toDoList.contains(documentParts.addToDoBtn)){\n            documentParts.toDoList.appendChild(documentParts.addToDoBtn);\n        }\n\n        // addEventListeners()\n        addEventListeners();\n    }\n};\n\nconst deleteToDo = (e) => {\n    const item = e.target;\n    const todo = item.parentElement.parentElement;\n    todo.remove();\n\n    const removeFromArray = () => {\n        let targetIndex = todo.getAttribute('data-index');\n        let list = defaultProjects.listOfProjects;\n        let index = defaultProjects.currentProjectIndex;\n\n        for (let i = 0; i < list[index].arr.length; i++) {\n            let id = list[index].arr[i].getID();\n            if (id == targetIndex) {\n                list[index].removeFromList(id);\n                list[1].removeFromList(id);\n            }\n        }\n        \n    };\n    removeFromArray();\n};\n\nconst completeToDo = (e) => {\n    const item = e.target;\n    const todo = item.parentElement.parentElement;\n    todo.classList.add('completed');\n    todo.innerHTML = todo.innerHTML.replace('<i class=\"fa-regular fa-square\"></i>', '<i class=\"fa-regular fa-square-check\"></i>');\n    addEventListeners();\n};\n\nconst undoToDoCompletion = (e) => {\n    const item = e.target;\n    const todo = item.parentElement.parentElement;\n    todo.classList.remove('completed');\n    todo.innerHTML = todo.innerHTML.replace('<i class=\"fa-regular fa-square-check\"></i>', '<i class=\"fa-regular fa-square\"></i>');\n    addEventListeners();\n};\n\nconst instantiateEditModal = (e) => {\n\n    const item = e.target;\n    const todo = item.parentElement.parentElement;\n    const targetIndex = todo.getAttribute('data-index');\n    const shortHand = defaultProjects.listOfProjects[defaultProjects.currentProjectIndex];\n\n    const getToDoInfo = () => {\n        for (let i = 0; i < shortHand.arr.length; i++) {\n            if (shortHand.arr[i].getID() == targetIndex) {\n                let name = shortHand.arr[i].getTitle();\n                let description = shortHand.arr[i].getDescription();\n                let dueDate = shortHand.arr[i].getDueDate();\n                let priority = shortHand.arr[i].getPriority();\n                let id = i;\n                return { name, description, dueDate, priority, id };\n            }\n        }\n    };\n\n    const toDoInfo = getToDoInfo();\n    const form = createEditModal(toDoInfo.name, toDoInfo.description,\n        toDoInfo.dueDate, toDoInfo.priority);\n\n    documentParts.body.appendChild(form.newModal);\n    form.newModal.showModal();\n\n    const submitEditBtn = document.querySelector('.submitEditBtn');\n    const cancelEditBtn = document.querySelector('.cancelEditBtn');\n\n    cancelEditBtn.addEventListener('click', function cancelEditModal(e) {\n        e.preventDefault();\n        form.newModal.close();\n        documentParts.body.removeChild(form.newModal);\n        addEventListeners();\n    });\n\n    submitEditBtn.addEventListener('click', function submitEditModal(e) {\n        e.preventDefault();\n\n        // update Arr values\n\n        shortHand.arr[toDoInfo.id].setTitle(form.taskName.value);\n        shortHand.arr[toDoInfo.id].setDescription(form.taskDescription.value);\n        shortHand.arr[toDoInfo.id].setDueDate(form.taskDueDate.value);\n        shortHand.arr[toDoInfo.id].setPriority(form.taskPriority.value);\n\n        // update table values\n        todo.children[0].innerHTML = `<i class=\"fa-regular fa-square\"></i> ${form.taskName.value}`;\n        \n        documentParts.setPriorityColors(form.taskPriority.value, todo.children[0]);\n\n        if (form.taskDueDate.value !== '') {\n            let filteredDueDate = dateFilter(form.taskDueDate.value);\n            todo.children[1].innerHTML = `${filteredDueDate} <i class=\"fa-regular fa-pen-to-square\"></i><i class=\"fa-regular fa-trash-can\"></i>`;\n        }\n        else {\n            todo.children[1].innerHTML = `<i class=\"fa-regular fa-pen-to-square\"></i><i class=\"fa-regular fa-trash-can\"></i>`;\n        }\n\n        documentParts.body.removeChild(form.newModal);\n        addEventListeners();\n    });\n};\n\nconst instantiateCreationModal = (e) => {\n    e.preventDefault();\n\n    documentParts.modal.showModal();\n\n    // set default date value to now\n    let dueDate = document.querySelector('#createTaskDueDate');\n    dueDate.setAttribute(\"value\", `${now()}`);\n\n    documentParts.modalCancelBtn.addEventListener('click', function cancelCreationModal() {\n        documentParts.modal.close();\n    });\n\n    documentParts.modalSubmitBtn.addEventListener('click', addToDoToTable);\n    addEventListeners();\n};\n\nconst instantiateProjectModal = (e) => {\n\n    e.preventDefault();\n\n    const proj = createProjectModal();\n    documentParts.body.appendChild(proj.newModal);\n\n    proj.newModal.showModal();\n\n    const submitProjectBtn = document.querySelector('.submitProjectBtn');\n    const cancelProjectBtn = document.querySelector('.cancelProjectBtn');\n\n    cancelProjectBtn.addEventListener('click', function cancelProjectModal(e) {\n        e.preventDefault();\n        proj.newModal.close();\n        documentParts.body.removeChild(proj.newModal);\n        addEventListeners();\n    });\n\n    submitProjectBtn.addEventListener('click', function submitProjectModal(e) {\n        e.preventDefault();\n\n        // create new project\n        const newProj = Project(proj.projectName.value, defaultProjects.projectCount);\n        defaultProjects.projectCount++;\n\n        proj.newModal.close();\n        documentParts.body.removeChild(proj.newModal);\n\n        // add new project to projects\n\n        defaultProjects.listOfProjects.push(newProj);\n\n        // update html to show project\n\n        const li = document.createElement('li');\n        li.classList.add('project');\n        li.classList.add('otherProjects');\n        li.setAttribute('data-index', defaultProjects.projectCount - 1);\n\n        let name = proj.projectName.value.toLowerCase();\n        name = name.charAt(0).toUpperCase() + name.slice(1);\n        if (name.length > 12) {\n            name = name.substring(0, 10) + '...';\n        }\n        li.innerHTML = `<i class=\"fa-solid fa-masks-theater\"></i>${name} <i class=\"fa-solid fa-circle-minus\"></i>`;\n        documentParts.projects.appendChild(li);\n\n        // update misc\n        addEventListeners();\n    });\n};\n\n\nconst removeProject = (e) => {\n    let projects = e.target.parentElement.parentElement;\n    let project = e.target.parentElement;\n    for (let i = 0; i < defaultProjects.listOfProjects.length; i++) {\n        if (defaultProjects.listOfProjects[i].getIndex() == project.getAttribute('data-index')) {\n            \n            // splice out project\n            let removedList = defaultProjects.listOfProjects[i].arr;\n            let removedListIndexes = [];\n            \n            // update everythingProj to remove these toDos\n            for(let j = 0; j < removedList.length; j++){\n                removedListIndexes.push(removedList[j].getID());\n            }\n            \n            const removeFromArray = () => {\n                let list = defaultProjects.listOfProjects;\n                let length = removedListIndexes.length;\n                for(let k = 0; k < length; k++){\n                    list[i].removeFromList(removedListIndexes[k]);\n                    list[1].removeFromList(removedListIndexes[k]);\n                }\n            };\n            removeFromArray();\n\n        }\n    }\n    projects.removeChild(project);\n    documentParts.table.textContent = 'Please select a project';\n    if(documentParts.toDoList.contains(documentParts.addToDoBtn)){\n        documentParts.toDoList.removeChild(documentParts.addToDoBtn);\n    }\n};\n;// CONCATENATED MODULE: ./src/js/addToDo.js\n\n\n\n\n\n\nconst addToDoToTable = () => {\n\n    const makeRow = () => {\n        const tr = document.createElement('tr');\n        tr.classList.add('createdRow');\n        tr.setAttribute('data-index', `${documentParts.toDoCounter}`);\n        const td1 = document.createElement('td');\n        const td2 = document.createElement('td');\n        td1.classList.add('column1');\n        td2.classList.add('column2');\n\n        documentParts.setPriorityColors(createTaskPriority.value, td1);\n\n        td1.innerHTML = `<i class=\"fa-regular fa-square\"></i> ${createTaskName.value}`;\n        if (createTaskDueDate.value !== '') {\n            let filteredDueDate = dateFilter(createTaskDueDate.value);\n            td2.innerHTML = `${filteredDueDate} <i class=\"fa-regular fa-pen-to-square\"></i><i class=\"fa-regular fa-trash-can\"></i>`;\n        }\n        else {\n            td2.innerHTML = `<i class=\"fa-regular fa-pen-to-square\"></i><i class=\"fa-regular fa-trash-can\"></i>`;\n        }\n\n        tr.appendChild(td1);\n        tr.appendChild(td2);\n\n        return tr;\n    };\n\n    const row = makeRow();\n\n    // create an object to store the values and push into defaultProj later\n    let toDoObj = Todo(createTaskName.value, createTaskDescription.value, createTaskDueDate.value,\n        createTaskPriority.value, documentParts.toDoCounter);\n    \n    documentParts.toDoCounter++;\n\n    defaultProjects.listOfProjects[defaultProjects.currentProjectIndex].addToList(toDoObj);\n    defaultProjects.listOfProjects[1].addToList(toDoObj);\n\n    documentParts.table.appendChild(row);\n    // set default values\n    createTaskName.value = '';\n    createTaskDescription.value = '';\n    createTaskDueDate.value = now();\n    createTaskPriority.value = 'Normal';\n    addEventListeners();\n};\n\n;// CONCATENATED MODULE: ./src/js/projectPageGeneration.js\n\n\n\n\n\nconst generateProject = (selectedProject) => {\n    defaultProjects.currentProjectIndex = selectedProject.getIndex();\n    clearOldProject();\n    generateTableHeader(selectedProject);\n    generateRows(selectedProject);\n    addEventListeners();\n};\n\nconst clearOldProject = () => {\n    documentParts.table.textContent = '';\n};\n\nconst generateTableHeader = (selectedProject) => {\n    let tr = document.createElement('tr');\n    tr.classList.add('titles');\n    let thProjName = document.createElement('th');\n    thProjName.classList.add('projName');\n    thProjName.textContent = selectedProject.getTitle().substring(0,30);\n    let thDueDate = document.createElement('th');\n    thDueDate.classList.add('dueDate');\n    thDueDate.innerHTML = `Due Date <i class=\"fa-solid fa-calendar-day\"></i>`;\n    tr.appendChild(thProjName);\n    tr.appendChild(thDueDate);\n    documentParts.table.appendChild(tr);\n};\n\nconst generateRows = (selectedProject) => {\n\n    if(selectedProject.getIndex() == 2 || selectedProject.getIndex() == 3){\n        const makeRow = (row) => {\n            const tr = document.createElement('tr');\n            tr.classList.add('viewOnly');\n            tr.setAttribute('data-index', `${row.getID()}`);\n            const td1 = document.createElement('td');\n            const td2 = document.createElement('td');\n            td1.classList.add('column1');\n            td2.classList.add('column2');\n\n            documentParts.setPriorityColors(row.getPriority(), td1);\n    \n            td1.innerHTML = `${row.getTitle()}`;\n            td2.innerHTML = `${dateFilter(row.getDueDate())}`;\n    \n            tr.appendChild(td1);\n            tr.appendChild(td2);\n    \n            return tr;\n        };\n    \n        for (let i = 0; i < selectedProject.arr.length; i++) {\n            documentParts.table.appendChild(makeRow(selectedProject.arr[i]));\n        }\n        if(documentParts.toDoList.contains(documentParts.addToDoBtn)){\n            documentParts.toDoList.removeChild(documentParts.addToDoBtn);\n        }\n    }\n    else{\n        const makeRow = (row) => {\n            const tr = document.createElement('tr');\n            tr.classList.add('createdRow');\n            tr.setAttribute('data-index', `${row.getID()}`);\n            const td1 = document.createElement('td');\n            const td2 = document.createElement('td');\n            td1.classList.add('column1');\n            td2.classList.add('column2');\n\n            documentParts.setPriorityColors(row.getPriority(), td1);\n    \n            td1.innerHTML = `<i class=\"fa-regular fa-square\"></i> ${row.getTitle()}`;\n            td2.innerHTML = `${dateFilter(row.getDueDate())} <i class=\"fa-regular fa-pen-to-square\"></i><i class=\"fa-regular fa-trash-can\"></i>`;\n    \n            tr.appendChild(td1);\n            tr.appendChild(td2);\n    \n            return tr;\n        };\n    \n        for (let i = 0; i < selectedProject.arr.length; i++) {\n            documentParts.table.appendChild(makeRow(selectedProject.arr[i]));\n        }\n        \n        if(!documentParts.toDoList.contains(documentParts.addToDoBtn)){\n            documentParts.toDoList.appendChild(documentParts.addToDoBtn);\n        }\n    }            \n\n};\n\nconst generateTodaysToDos = () => {\n    defaultProjects.listOfProjects[2].arr.splice(0, defaultProjects.listOfProjects[2].arr.length, ...defaultProjects.listOfProjects[1].filterTodaysToDos());\n    generateProject(defaultProjects.todaysToDos);\n};\n\nconst generateThisWeeksToDos = () => {\n    defaultProjects.listOfProjects[3].arr.splice(0, defaultProjects.listOfProjects[3].arr.length, ...defaultProjects.listOfProjects[1].filterThisWeeksToDos());\n    generateProject(defaultProjects.thisWeeksToDos);\n};\n\nconst generateDefaultToDos = () => {\n    generateProject(defaultProjects.defaultProj);\n};\n\nconst setupDefaultProjects = () => {\n    documentParts.todaysToDos.addEventListener('click', generateTodaysToDos);\n    documentParts.thisWeeksToDos.addEventListener('click', generateThisWeeksToDos);\n    documentParts.defaultProject.addEventListener('click', generateDefaultToDos);\n    generateProject(defaultProjects.listOfProjects[defaultProjects.currentProjectIndex]);\n};\n\nsetupDefaultProjects();\n// EXTERNAL MODULE: ./src/img/plus-circle.png\nvar plus_circle = __webpack_require__(680);\n// EXTERNAL MODULE: ./src/img/todoList.png\nvar todoList = __webpack_require__(661);\n;// CONCATENATED MODULE: ./src/index.js\n\n\n\n\n\n\n\n\ndocumentParts.plusCircleDiv.style.backgroundImage = `url(${todoList})`;\n\n\naddEventListeners();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsS0FBSztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDZCQUE2QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsK0VBQStFO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyw4R0FBOEc7QUFDekg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxhQUFhLHNDQUFzQyxhQUFhO0FBQzVHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELFNBQVM7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQyxZQUFZLGdDQUFnQztBQUM1QztBQUNBO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQ7QUFDQTtBQUNBLFVBQVUsNkRBQTZEO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLDZEQUE2RDtBQUNwRSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsK0VBQStFO0FBQzFGO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxXQUFXO0FBQ3RCO0FBQ0E7QUFDQSxrREFBa0QsV0FBVztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxXQUFXO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsK0VBQStFO0FBQ3pGLE9BQU8sK0VBQStFO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0VBQStFLFVBQVUsMEJBQTBCLGFBQWE7QUFDaEk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsVUFBVSwwQkFBMEIsYUFBYTtBQUMvSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRSxVQUFVLDBCQUEwQixhQUFhO0FBQzNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFLFVBQVUsMEJBQTBCLGFBQWE7QUFDL0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLCtFQUErRTtBQUMvRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLCtGQUErRjtBQUMvRztBQUNBO0FBQ0EsZ0JBQWdCLCtFQUErRTtBQUMvRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsK0ZBQStGO0FBQy9HO0FBQ0E7QUFDQSxnQkFBZ0IsK0VBQStFO0FBQy9GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRUFBK0UsWUFBWSxNQUFNLGlCQUFpQjtBQUNsSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYywrRkFBK0Y7QUFDN0c7QUFDQSxXQUFXLCtGQUErRjtBQUMxRztBQUNBLFdBQVcseUVBQXlFO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtFQUErRSxZQUFZLE1BQU0saUJBQWlCO0FBQ2xIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLCtGQUErRjtBQUM3RztBQUNBLFdBQVcsK0ZBQStGO0FBQzFHO0FBQ0EsV0FBVyx5RUFBeUU7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLCtFQUErRTtBQUMxRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw2QkFBNkI7QUFDN0M7QUFDQTtBQUNBLHlFQUF5RSwrQkFBK0I7QUFDeEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDBCQUEwQixHQUFHLCtCQUErQjtBQUN0RjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QTtBQUNBLFdBQVcsNkRBQTZEO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw2QkFBNkI7QUFDN0M7QUFDQSx1REFBdUQsK0JBQStCO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDBCQUEwQixHQUFHLG1CQUFtQjtBQUMxRTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxpQkFBYSxVQUFVLGVBQVc7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLCtGQUErRjtBQUM3RyxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELGdCQUFnQjtBQUNyRSw4QkFBOEI7QUFDOUIsaUVBQWlFLG1CQUFtQjtBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsK0ZBQStGO0FBQzdHLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsZ0JBQWdCO0FBQ3JFLDhCQUE4QjtBQUM5QixpRUFBaUUsbUJBQW1CO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdGQUFnRixZQUFZLE1BQU0saUJBQWlCO0FBQ25IO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELHdCQUF3QjtBQUM3RSxvREFBb0QsdUJBQXVCO0FBQzNFLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQSxjQUFjLGdCQUFnQjtBQUM5QixXQUFXLGdCQUFnQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRkFBZ0YsWUFBWSxNQUFNLGlCQUFpQjtBQUNuSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCx3QkFBd0I7QUFDN0Usb0RBQW9ELHVCQUF1QjtBQUMzRSwrQkFBK0I7QUFDL0IsY0FBYyxnQkFBZ0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGdCQUFnQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsaUJBQWEsQ0FBQyxlQUFXO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGlCQUFhLENBQUMsZUFBVztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGVBQVc7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsaUJBQWEsQ0FBQyxpQkFBYTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsK0VBQStFO0FBQy9GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsK0ZBQStGO0FBQy9HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLCtGQUErRjtBQUMvRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRUFBK0UsWUFBWSxNQUFNLGlCQUFpQjtBQUNsSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxtREFBbUQ7QUFDbEUsZUFBZSxtRUFBbUU7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkMsZUFBZSwrRkFBK0Y7QUFDOUc7QUFDQSxlQUFlLCtGQUErRjtBQUM5RztBQUNBLGVBQWUsK0ZBQStGO0FBQzlHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRUFBK0UsWUFBWSxNQUFNLGlCQUFpQjtBQUNsSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG1EQUFtRDtBQUNsRSxlQUFlLG1FQUFtRTtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQyxlQUFlLCtGQUErRjtBQUM5RztBQUNBLGVBQWUsK0ZBQStGO0FBQzlHO0FBQ0EsZUFBZSwrRkFBK0Y7QUFDOUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixpQkFBYSxRQUFRLGVBQVc7QUFDNUQsWUFBWSxjQUFVO0FBQ3RCO0FBQ0E7QUFDQSxXQUFXLCtFQUErRTtBQUMxRjtBQUNBO0FBQ0EsUUFBUSxpQkFBYTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsY0FBVSxDQUFDLGVBQVcsT0FBTyxlQUFXO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw2QkFBNkI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixnQ0FBZ0M7QUFDeEQsWUFBWSwrQkFBbUI7QUFDL0I7QUFDQSxXQUFXLCtCQUFtQixDQUFDLHdCQUFZO0FBQzNDLFlBQVksa0NBQXNCLENBQUMsd0JBQVk7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLFlBQVk7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsWUFBWSwrQkFBbUI7QUFDL0I7QUFDQSxvRUFBb0UsZUFBZTtBQUNuRiwrQkFBK0IsVUFBVSxvQkFBb0I7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0NBQWdDO0FBQ3hELFlBQVksK0JBQW1CO0FBQy9CO0FBQ0E7QUFDQSxZQUFZLCtCQUFtQixDQUFDLHdCQUFZO0FBQzVDLFlBQVksa0NBQXNCLENBQUMsd0JBQVk7QUFDL0M7QUFDQTs7QUFFQTs7QUFFTztBQUNQLElBQUksNENBQXFDLElBQUksNENBQXFDLEtBQUssbURBQTRDO0FBQ25JLG9CQUFvQiwyQkFBb0I7QUFDeEM7O0FBRU87QUFDUCxJQUFJLDRDQUFxQyxJQUFJLDRDQUFxQyxLQUFLLHNEQUErQztBQUN0SSxvQkFBb0IsOEJBQXVCO0FBQzNDOztBQUVPO0FBQ1Asb0JBQW9CLDJCQUFvQjtBQUN4Qzs7QUFFQTtBQUNBLElBQUksMENBQThCO0FBQ2xDLElBQUksNkNBQWlDO0FBQ3JDLElBQUksNkNBQWlDO0FBQ3JDLG9CQUFvQiw4QkFBdUIsQ0FBQyxtQ0FBNEI7QUFDeEU7O0FBRUEsdUI7Ozs7OztBQ2xIc0I7QUFDQTtBQUNhO0FBQ0M7QUFDa0I7QUFDdkI7QUFDYzs7QUFFN0MsaURBQXFDLFVBQVUsUUFBVyxDQUFDOzs7QUFHM0QsaUJBQWlCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdG9kby1saXN0Ly4vc3JjL3N0eWxlLnNjc3M/NzViYSIsIndlYnBhY2s6Ly90b2RvLWxpc3QvLi9zcmMvanMvZG9jdW1lbnRQYXJ0cy5qcz82OWVkIiwid2VicGFjazovL3RvZG8tbGlzdC8uL25vZGVfbW9kdWxlcy9AanMtdGVtcG9yYWwvcG9seWZpbGwvZGlzdC9pbmRleC5lc20uanM/NWI2MSIsIndlYnBhY2s6Ly90b2RvLWxpc3QvLi9zcmMvanMvdGltZS5qcz81ZmZkIiwid2VicGFjazovL3RvZG8tbGlzdC8uL3NyYy9qcy90b2RvLmpzP2VhM2QiLCJ3ZWJwYWNrOi8vdG9kby1saXN0Ly4vc3JjL2pzL3Byb2plY3QuanM/ZWY1OCIsIndlYnBhY2s6Ly90b2RvLWxpc3QvLi9zcmMvanMvZGVmYXVsdFByb2plY3RzLmpzPzY3YTUiLCJ3ZWJwYWNrOi8vdG9kby1saXN0Ly4vc3JjL2pzL2NyZWF0ZU1vZGFscy5qcz8zYWE4Iiwid2VicGFjazovL3RvZG8tbGlzdC8uL3NyYy9qcy9hZGRMaXN0ZW5lcnMuanM/NDY0YSIsIndlYnBhY2s6Ly90b2RvLWxpc3QvLi9zcmMvanMvYWRkVG9Eby5qcz8xOGY0Iiwid2VicGFjazovL3RvZG8tbGlzdC8uL3NyYy9qcy9wcm9qZWN0UGFnZUdlbmVyYXRpb24uanM/NjcyMyIsIndlYnBhY2s6Ly90b2RvLWxpc3QvLi9zcmMvaW5kZXguanM/YjYzNSJdLCJzb3VyY2VzQ29udGVudCI6WyJcbiAgICAgIGltcG9ydCBBUEkgZnJvbSBcIiEuLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbmplY3RTdHlsZXNJbnRvU3R5bGVUYWcuanNcIjtcbiAgICAgIGltcG9ydCBkb21BUEkgZnJvbSBcIiEuLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9zdHlsZURvbUFQSS5qc1wiO1xuICAgICAgaW1wb3J0IGluc2VydEZuIGZyb20gXCIhLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5zZXJ0QnlTZWxlY3Rvci5qc1wiO1xuICAgICAgaW1wb3J0IHNldEF0dHJpYnV0ZXMgZnJvbSBcIiEuLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9zZXRBdHRyaWJ1dGVzV2l0aG91dEF0dHJpYnV0ZXMuanNcIjtcbiAgICAgIGltcG9ydCBpbnNlcnRTdHlsZUVsZW1lbnQgZnJvbSBcIiEuLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbnNlcnRTdHlsZUVsZW1lbnQuanNcIjtcbiAgICAgIGltcG9ydCBzdHlsZVRhZ1RyYW5zZm9ybUZuIGZyb20gXCIhLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvc3R5bGVUYWdUcmFuc2Zvcm0uanNcIjtcbiAgICAgIGltcG9ydCBjb250ZW50LCAqIGFzIG5hbWVkRXhwb3J0IGZyb20gXCIhIS4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL3N0eWxlLnNjc3NcIjtcbiAgICAgIFxuICAgICAgXG5cbnZhciBvcHRpb25zID0ge307XG5cbm9wdGlvbnMuc3R5bGVUYWdUcmFuc2Zvcm0gPSBzdHlsZVRhZ1RyYW5zZm9ybUZuO1xub3B0aW9ucy5zZXRBdHRyaWJ1dGVzID0gc2V0QXR0cmlidXRlcztcblxuICAgICAgb3B0aW9ucy5pbnNlcnQgPSBpbnNlcnRGbi5iaW5kKG51bGwsIFwiaGVhZFwiKTtcbiAgICBcbm9wdGlvbnMuZG9tQVBJID0gZG9tQVBJO1xub3B0aW9ucy5pbnNlcnRTdHlsZUVsZW1lbnQgPSBpbnNlcnRTdHlsZUVsZW1lbnQ7XG5cbnZhciB1cGRhdGUgPSBBUEkoY29udGVudCwgb3B0aW9ucyk7XG5cblxuXG5leHBvcnQgKiBmcm9tIFwiISEuLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcyEuLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvZGlzdC9janMuanMhLi9zdHlsZS5zY3NzXCI7XG4gICAgICAgZXhwb3J0IGRlZmF1bHQgY29udGVudCAmJiBjb250ZW50LmxvY2FscyA/IGNvbnRlbnQubG9jYWxzIDogdW5kZWZpbmVkO1xuIiwiY29uc3QgYm9keSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2JvZHknKTtcblxuY29uc3Qgc2lkZWJhciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5zaWRlYmFyJyk7XG5jb25zdCB0b2RheXNUb0RvcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy50b2RheScpO1xuY29uc3QgdGhpc1dlZWtzVG9Eb3MgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcud2VlaycpO1xuY29uc3QgZGVmYXVsdFByb2plY3QgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuZGVmYXVsdFByb2plY3QnKTtcbmNvbnN0IHByb2plY3RzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI3Byb2plY3RzQ29udGFpbmVyJyk7XG5cbmNvbnN0IGFkZFByb2plY3RCdG4gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuYWRkUHJvamVjdEJ0bicpO1xuY29uc3QgYWRkVG9Eb0J0biA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5hZGRUb0RvQnRuJyk7XG5cbmNvbnN0IHRvRG9MaXN0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLnRvZG9MaXN0Jyk7XG5jb25zdCB0YWJsZSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ3RhYmxlJyk7XG5jb25zdCB0YWJsZVRpdGxlID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLnRpdGxlcy5wcm9qTmFtZScpO1xuY29uc3QgdGFibGVEdWVEYXRlID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLnRpdGxlcy5kdWVEYXRlJyk7XG5cblxuY29uc3QgbW9kYWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjbW9kYWwnKTtcbmNvbnN0IGVkaXRNb2RhbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNlZGl0TW9kYWwnKTtcbmNvbnN0IGNyZWF0aW9uTW9kYWxUYXNrTmFtZSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5jcmVhdGVUYXNrTmFtZScpO1xuY29uc3QgY3JlYXRpb25Nb2RhbFRhc2tEZXNjcmlwdGlvbiA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5jcmVhdGVUYXNrRGVzY3JpcHRpb24nKTtcbmNvbnN0IGNyZWF0aW9uTW9kYWxUYXNrRHVlRGF0ZSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5jcmVhdGVUYXNrRHVlRGF0ZScpO1xuY29uc3QgY3JlYXRpb25Nb2RhbFRhc2tQcmlvcml0eSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5jcmVhdGVUYXNrUHJpb3JpdHknKTtcbmNvbnN0IG1vZGFsQ2FuY2VsQnRuID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmNyZWF0ZU1vZGFsQ2FuY2VsQnRuJyk7XG5jb25zdCBtb2RhbFN1Ym1pdEJ0biA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5jcmVhdGVNb2RhbFN1Ym1pdEJ0bicpO1xuXG5jb25zdCB0b0RvQ291bnRlciA9IDA7XG5cbmNvbnN0IHNldFByaW9yaXR5Q29sb3JzID0gKHZhbHVlLCBlbCkgPT4ge1xuICBpZih2YWx1ZSA9PT0gJ0hpZ2gnKXtcbiAgICBlbC5zdHlsZSA9ICdib3JkZXItbGVmdDogMTBweCBzb2xpZCByZWQ7IGJvcmRlci1yYWRpdXM6IDVweDsnO1xuICB9XG4gIGVsc2UgaWYodmFsdWUgPT09ICdOb3JtYWwnKXtcbiAgICBlbC5zdHlsZSA9ICdib3JkZXItbGVmdDogMTBweCBzb2xpZCB5ZWxsb3c7IGJvcmRlci1yYWRpdXM6IDVweDsnO1xuICB9XG4gIGVsc2UgaWYodmFsdWUgPT09ICdMb3cnKXtcbiAgICAgIGVsLnN0eWxlID0gJ2JvcmRlci1sZWZ0OiAxMHB4IHNvbGlkIGdyZWVuOyBib3JkZXItcmFkaXVzOiA1cHg7JztcbiAgfVxufTtcblxuY29uc3QgcGx1c0NpcmNsZURpdiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdwbHVzQ2lyY2xlRGl2Jyk7XG5cbmV4cG9ydCBkZWZhdWx0IHtcblxuICBzaWRlYmFyLCBib2R5LCB0b2RheXNUb0RvcywgdGhpc1dlZWtzVG9Eb3MsIHByb2plY3RzLCBkZWZhdWx0UHJvamVjdCxcbiAgdG9Eb0xpc3QsIHRhYmxlLCB0YWJsZVRpdGxlLCB0YWJsZUR1ZURhdGUsIGFkZFRvRG9CdG4sIHRvRG9Db3VudGVyLCBtb2RhbCxcbiAgY3JlYXRpb25Nb2RhbFRhc2tOYW1lLCBjcmVhdGlvbk1vZGFsVGFza0Rlc2NyaXB0aW9uLCBjcmVhdGlvbk1vZGFsVGFza0R1ZURhdGUsXG4gIGNyZWF0aW9uTW9kYWxUYXNrUHJpb3JpdHksIGVkaXRNb2RhbCwgbW9kYWxDYW5jZWxCdG4sIG1vZGFsU3VibWl0QnRuLCBhZGRQcm9qZWN0QnRuLCBzZXRQcmlvcml0eUNvbG9ycywgcGx1c0NpcmNsZURpdlxuXG59OyIsImltcG9ydCBKU0JJIGZyb20gJ2pzYmknO1xuXG5jb25zdCBJTlRSSU5TSUNTID0ge307XG5jb25zdCBjdXN0b21VdGlsSW5zcGVjdEZvcm1hdHRlcnMgPSB7XG4gICAgWydUZW1wb3JhbC5EdXJhdGlvbiddKGRlcHRoLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGRlc2NyID0gb3B0aW9ucy5zdHlsaXplKGAke3RoaXNbU3ltYm9sLnRvU3RyaW5nVGFnXX0gPCR7dGhpc30+YCwgJ3NwZWNpYWwnKTtcbiAgICAgICAgaWYgKGRlcHRoIDwgMSlcbiAgICAgICAgICAgIHJldHVybiBkZXNjcjtcbiAgICAgICAgY29uc3QgZW50cmllcyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHByb3Agb2YgW1xuICAgICAgICAgICAgJ3llYXJzJyxcbiAgICAgICAgICAgICdtb250aHMnLFxuICAgICAgICAgICAgJ3dlZWtzJyxcbiAgICAgICAgICAgICdkYXlzJyxcbiAgICAgICAgICAgICdob3VycycsXG4gICAgICAgICAgICAnbWludXRlcycsXG4gICAgICAgICAgICAnc2Vjb25kcycsXG4gICAgICAgICAgICAnbWlsbGlzZWNvbmRzJyxcbiAgICAgICAgICAgICdtaWNyb3NlY29uZHMnLFxuICAgICAgICAgICAgJ25hbm9zZWNvbmRzJ1xuICAgICAgICBdKSB7XG4gICAgICAgICAgICBpZiAodGhpc1twcm9wXSAhPT0gMClcbiAgICAgICAgICAgICAgICBlbnRyaWVzLnB1c2goYCAgJHtwcm9wfTogJHtvcHRpb25zLnN0eWxpemUodGhpc1twcm9wXSwgJ251bWJlcicpfWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZXNjciArICcge1xcbicgKyBlbnRyaWVzLmpvaW4oJyxcXG4nKSArICdcXG59JztcbiAgICB9XG59O1xuZnVuY3Rpb24gZGVmYXVsdFV0aWxJbnNwZWN0Rm9ybWF0dGVyKGRlcHRoLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMuc3R5bGl6ZShgJHt0aGlzW1N5bWJvbC50b1N0cmluZ1RhZ119IDwke3RoaXN9PmAsICdzcGVjaWFsJyk7XG59XG5mdW5jdGlvbiBNYWtlSW50cmluc2ljQ2xhc3MoQ2xhc3MsIG5hbWUpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ2xhc3MucHJvdG90eXBlLCBTeW1ib2wudG9TdHJpbmdUYWcsIHtcbiAgICAgICAgdmFsdWU6IG5hbWUsXG4gICAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENsYXNzLnByb3RvdHlwZSwgU3ltYm9sLmZvcignbm9kZWpzLnV0aWwuaW5zcGVjdC5jdXN0b20nKSwge1xuICAgICAgICAgICAgdmFsdWU6IGN1c3RvbVV0aWxJbnNwZWN0Rm9ybWF0dGVyc1tuYW1lXSB8fCBkZWZhdWx0VXRpbEluc3BlY3RGb3JtYXR0ZXIsXG4gICAgICAgICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBwcm9wIG9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKENsYXNzKSkge1xuICAgICAgICAvLyB3ZSBrbm93IHRoYXQgYHByb3BgIGlzIHByZXNlbnQsIHNvIHRoZSBkZXNjcmlwdG9yIGlzIG5ldmVyIHVuZGVmaW5lZFxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgICBjb25zdCBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihDbGFzcywgcHJvcCk7XG4gICAgICAgIGlmICghZGVzYy5jb25maWd1cmFibGUgfHwgIWRlc2MuZW51bWVyYWJsZSlcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBkZXNjLmVudW1lcmFibGUgPSBmYWxzZTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENsYXNzLCBwcm9wLCBkZXNjKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBwcm9wIG9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKENsYXNzLnByb3RvdHlwZSkpIHtcbiAgICAgICAgLy8gd2Uga25vdyB0aGF0IGBwcm9wYCBpcyBwcmVzZW50LCBzbyB0aGUgZGVzY3JpcHRvciBpcyBuZXZlciB1bmRlZmluZWRcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICAgICAgY29uc3QgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoQ2xhc3MucHJvdG90eXBlLCBwcm9wKTtcbiAgICAgICAgaWYgKCFkZXNjLmNvbmZpZ3VyYWJsZSB8fCAhZGVzYy5lbnVtZXJhYmxlKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGRlc2MuZW51bWVyYWJsZSA9IGZhbHNlO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ2xhc3MucHJvdG90eXBlLCBwcm9wLCBkZXNjKTtcbiAgICB9XG4gICAgRGVmaW5lSW50cmluc2ljKG5hbWUsIENsYXNzKTtcbiAgICBEZWZpbmVJbnRyaW5zaWMoYCR7bmFtZX0ucHJvdG90eXBlYCwgQ2xhc3MucHJvdG90eXBlKTtcbn1cbmZ1bmN0aW9uIERlZmluZUludHJpbnNpYyhuYW1lLCB2YWx1ZSkge1xuICAgIGNvbnN0IGtleSA9IGAlJHtuYW1lfSVgO1xuICAgIGlmIChJTlRSSU5TSUNTW2tleV0gIT09IHVuZGVmaW5lZClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnRyaW5zaWMgJHtuYW1lfSBhbHJlYWR5IGV4aXN0c2ApO1xuICAgIElOVFJJTlNJQ1Nba2V5XSA9IHZhbHVlO1xufVxuZnVuY3Rpb24gR2V0SW50cmluc2ljKGludHJpbnNpYykge1xuICAgIHJldHVybiBJTlRSSU5TSUNTW2ludHJpbnNpY107XG59XG5cbi8vIEluc3RhbnRcbmNvbnN0IEVQT0NITkFOT1NFQ09ORFMgPSAnc2xvdC1lcG9jaE5hbm9TZWNvbmRzJztcbi8vIFRpbWVab25lXG5jb25zdCBUSU1FWk9ORV9JRCA9ICdzbG90LXRpbWV6b25lLWlkZW50aWZpZXInO1xuLy8gRGF0ZVRpbWUsIERhdGUsIFRpbWUsIFllYXJNb250aCwgTW9udGhEYXlcbmNvbnN0IElTT19ZRUFSID0gJ3Nsb3QteWVhcic7XG5jb25zdCBJU09fTU9OVEggPSAnc2xvdC1tb250aCc7XG5jb25zdCBJU09fREFZID0gJ3Nsb3QtZGF5JztcbmNvbnN0IElTT19IT1VSID0gJ3Nsb3QtaG91cic7XG5jb25zdCBJU09fTUlOVVRFID0gJ3Nsb3QtbWludXRlJztcbmNvbnN0IElTT19TRUNPTkQgPSAnc2xvdC1zZWNvbmQnO1xuY29uc3QgSVNPX01JTExJU0VDT05EID0gJ3Nsb3QtbWlsbGlzZWNvbmQnO1xuY29uc3QgSVNPX01JQ1JPU0VDT05EID0gJ3Nsb3QtbWljcm9zZWNvbmQnO1xuY29uc3QgSVNPX05BTk9TRUNPTkQgPSAnc2xvdC1uYW5vc2Vjb25kJztcbmNvbnN0IENBTEVOREFSID0gJ3Nsb3QtY2FsZW5kYXInO1xuLy8gRGF0ZSwgWWVhck1vbnRoLCBhbmQgTW9udGhEYXkgYWxsIGhhdmUgdGhlIHNhbWUgc2xvdHMsIGRpc2FtYmlndWF0aW9uIG5lZWRlZDpcbmNvbnN0IERBVEVfQlJBTkQgPSAnc2xvdC1kYXRlLWJyYW5kJztcbmNvbnN0IFlFQVJfTU9OVEhfQlJBTkQgPSAnc2xvdC15ZWFyLW1vbnRoLWJyYW5kJztcbmNvbnN0IE1PTlRIX0RBWV9CUkFORCA9ICdzbG90LW1vbnRoLWRheS1icmFuZCc7XG4vLyBab25lZERhdGVUaW1lXG5jb25zdCBJTlNUQU5UID0gJ3Nsb3QtY2FjaGVkLWluc3RhbnQnO1xuY29uc3QgVElNRV9aT05FID0gJ3Nsb3QtdGltZS16b25lJztcbi8vIER1cmF0aW9uXG5jb25zdCBZRUFSUyA9ICdzbG90LXllYXJzJztcbmNvbnN0IE1PTlRIUyA9ICdzbG90LW1vbnRocyc7XG5jb25zdCBXRUVLUyA9ICdzbG90LXdlZWtzJztcbmNvbnN0IERBWVMgPSAnc2xvdC1kYXlzJztcbmNvbnN0IEhPVVJTID0gJ3Nsb3QtaG91cnMnO1xuY29uc3QgTUlOVVRFUyA9ICdzbG90LW1pbnV0ZXMnO1xuY29uc3QgU0VDT05EUyA9ICdzbG90LXNlY29uZHMnO1xuY29uc3QgTUlMTElTRUNPTkRTID0gJ3Nsb3QtbWlsbGlzZWNvbmRzJztcbmNvbnN0IE1JQ1JPU0VDT05EUyA9ICdzbG90LW1pY3Jvc2Vjb25kcyc7XG5jb25zdCBOQU5PU0VDT05EUyA9ICdzbG90LW5hbm9zZWNvbmRzJztcbi8vIENhbGVuZGFyXG5jb25zdCBDQUxFTkRBUl9JRCA9ICdzbG90LWNhbGVuZGFyLWlkZW50aWZpZXInO1xuY29uc3Qgc2xvdHMgPSBuZXcgV2Vha01hcCgpO1xuZnVuY3Rpb24gQ3JlYXRlU2xvdHMoY29udGFpbmVyKSB7XG4gICAgc2xvdHMuc2V0KGNvbnRhaW5lciwgT2JqZWN0LmNyZWF0ZShudWxsKSk7XG59XG5mdW5jdGlvbiBHZXRTbG90cyhjb250YWluZXIpIHtcbiAgICByZXR1cm4gc2xvdHMuZ2V0KGNvbnRhaW5lcik7XG59XG5mdW5jdGlvbiBIYXNTbG90KGNvbnRhaW5lciwgLi4uaWRzKSB7XG4gICAgaWYgKCFjb250YWluZXIgfHwgJ29iamVjdCcgIT09IHR5cGVvZiBjb250YWluZXIpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBjb25zdCBteXNsb3RzID0gR2V0U2xvdHMoY29udGFpbmVyKTtcbiAgICByZXR1cm4gISFteXNsb3RzICYmIGlkcy5yZWR1Y2UoKGFsbCwgaWQpID0+IGFsbCAmJiBpZCBpbiBteXNsb3RzLCB0cnVlKTtcbn1cbmZ1bmN0aW9uIEdldFNsb3QoY29udGFpbmVyLCBpZCkge1xuICAgIGNvbnN0IHZhbHVlID0gR2V0U2xvdHMoY29udGFpbmVyKVtpZF07XG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE1pc3NpbmcgaW50ZXJuYWwgc2xvdCAke2lkfWApO1xuICAgIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIFNldFNsb3QoY29udGFpbmVyLCBpZCwgdmFsdWUpIHtcbiAgICBHZXRTbG90cyhjb250YWluZXIpW2lkXSA9IHZhbHVlO1xufVxuXG5jb25zdCBBcnJheUluY2x1ZGVzID0gQXJyYXkucHJvdG90eXBlLmluY2x1ZGVzO1xuY29uc3QgQXJyYXlQcm90b3R5cGVQdXNoJDIgPSBBcnJheS5wcm90b3R5cGUucHVzaDtcbmNvbnN0IEludGxEYXRlVGltZUZvcm1hdCQyID0gZ2xvYmFsVGhpcy5JbnRsLkRhdGVUaW1lRm9ybWF0O1xuY29uc3QgQXJyYXlTb3J0ID0gQXJyYXkucHJvdG90eXBlLnNvcnQ7XG5jb25zdCBNYXRoQWJzJDEgPSBNYXRoLmFicztcbmNvbnN0IE1hdGhGbG9vciQxID0gTWF0aC5mbG9vcjtcbmNvbnN0IE9iamVjdEVudHJpZXMgPSBPYmplY3QuZW50cmllcztcbmNvbnN0IE9iamVjdEtleXMgPSBPYmplY3Qua2V5cztcbi8qKlxuICogSW1wbGVtZW50YXRpb25zIGZvciBlYWNoIGNhbGVuZGFyLiBOb24tSVNPIGNhbGVuZGFycyBoYXZlIGFuIGV4dHJhIGBoZWxwZXJgXG4gKiBwcm9wZXJ0eSB0aGF0IHByb3ZpZGVzIGFkZGl0aW9uYWwgcGVyLWNhbGVuZGFyIGxvZ2ljLlxuICovXG5jb25zdCBpbXBsID0ge307XG4vKipcbiAqIFRoaW4gd3JhcHBlciBhcm91bmQgdGhlIGltcGxlbWVudGF0aW9uIG9mIGVhY2ggYnVpbHQtaW4gY2FsZW5kYXIuIFRoaXNcbiAqIGNsYXNzJ3MgbWV0aG9kcyBmb2xsb3cgYSBzaW1pbGFyIHBhdHRlcm46XG4gKiAxLiBWYWxpZGF0ZSBwYXJhbWV0ZXJzXG4gKiAyLiBGaWxsIGluIGRlZmF1bHQgb3B0aW9ucyAoZm9yIG1ldGhvZHMgd2hlcmUgb3B0aW9ucyBhcmUgcHJlc2VudClcbiAqIDMuIFNpbXBsaWZ5IGFuZC9vciBub3JtYWxpemUgcGFyYW1ldGVycy4gRm9yIGV4YW1wbGUsIHNvbWUgbWV0aG9kcyBhY2NlcHRcbiAqICAgIFBsYWluRGF0ZSwgUGxhaW5EYXRlVGltZSwgWm9uZWREYXRlVGltZSwgZXRjLiBhbmQgdGhlc2UgYXJlIG5vcm1hbGl6ZWQgdG9cbiAqICAgIFBsYWluRGF0ZS5cbiAqIDQuIExvb2sgdXAgdGhlIElEIG9mIHRoZSBidWlsdC1pbiBjYWxlbmRhclxuICogNS4gRmV0Y2ggdGhlIGltcGxlbWVudGF0aW9uIG9iamVjdCBmb3IgdGhhdCBJRC5cbiAqIDYuIENhbGwgdGhlIGNvcnJlc3BvbmRpbmcgbWV0aG9kIGluIHRoZSBpbXBsZW1lbnRhdGlvbiBvYmplY3QuXG4gKi9cbmNsYXNzIENhbGVuZGFyIHtcbiAgICBjb25zdHJ1Y3RvcihpZFBhcmFtKSB7XG4gICAgICAgIC8vIE5vdGU6IGlmIHRoZSBhcmd1bWVudCBpcyBub3QgcGFzc2VkLCBJc0J1aWx0aW5DYWxlbmRhcihcInVuZGVmaW5lZFwiKSB3aWxsIGZhaWwuIFRoaXMgY2hlY2tcbiAgICAgICAgLy8gICAgICAgZXhpc3RzIG9ubHkgdG8gaW1wcm92ZSB0aGUgZXJyb3IgbWVzc2FnZS5cbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAxKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignbWlzc2luZyBhcmd1bWVudDogaWQgaXMgcmVxdWlyZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpZCA9IFRvU3RyaW5nKGlkUGFyYW0pO1xuICAgICAgICBpZiAoIUlzQnVpbHRpbkNhbGVuZGFyKGlkKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBpbnZhbGlkIGNhbGVuZGFyIGlkZW50aWZpZXIgJHtpZH1gKTtcbiAgICAgICAgQ3JlYXRlU2xvdHModGhpcyk7XG4gICAgICAgIFNldFNsb3QodGhpcywgQ0FMRU5EQVJfSUQsIGlkKTtcbiAgICAgICAge1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdfcmVwcl8nLCB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IGAke3RoaXNbU3ltYm9sLnRvU3RyaW5nVGFnXX0gPCR7aWR9PmAsXG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBpZCgpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsQ2FsZW5kYXIodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIHJldHVybiBUb1N0cmluZyh0aGlzKTtcbiAgICB9XG4gICAgZGF0ZUZyb21GaWVsZHMoZmllbGRzLCBvcHRpb25zUGFyYW0gPSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsQ2FsZW5kYXIodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIGlmICghSXNPYmplY3QoZmllbGRzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgZmllbGRzJyk7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSBHZXRPcHRpb25zT2JqZWN0KG9wdGlvbnNQYXJhbSk7XG4gICAgICAgIHJldHVybiBpbXBsW0dldFNsb3QodGhpcywgQ0FMRU5EQVJfSUQpXS5kYXRlRnJvbUZpZWxkcyhmaWVsZHMsIG9wdGlvbnMsIHRoaXMpO1xuICAgIH1cbiAgICB5ZWFyTW9udGhGcm9tRmllbGRzKGZpZWxkcywgb3B0aW9uc1BhcmFtID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbENhbGVuZGFyKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICBpZiAoIUlzT2JqZWN0KGZpZWxkcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIGZpZWxkcycpO1xuICAgICAgICBjb25zdCBvcHRpb25zID0gR2V0T3B0aW9uc09iamVjdChvcHRpb25zUGFyYW0pO1xuICAgICAgICByZXR1cm4gaW1wbFtHZXRTbG90KHRoaXMsIENBTEVOREFSX0lEKV0ueWVhck1vbnRoRnJvbUZpZWxkcyhmaWVsZHMsIG9wdGlvbnMsIHRoaXMpO1xuICAgIH1cbiAgICBtb250aERheUZyb21GaWVsZHMoZmllbGRzLCBvcHRpb25zUGFyYW0gPSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsQ2FsZW5kYXIodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIGlmICghSXNPYmplY3QoZmllbGRzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgZmllbGRzJyk7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSBHZXRPcHRpb25zT2JqZWN0KG9wdGlvbnNQYXJhbSk7XG4gICAgICAgIHJldHVybiBpbXBsW0dldFNsb3QodGhpcywgQ0FMRU5EQVJfSUQpXS5tb250aERheUZyb21GaWVsZHMoZmllbGRzLCBvcHRpb25zLCB0aGlzKTtcbiAgICB9XG4gICAgZmllbGRzKGZpZWxkcykge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxDYWxlbmRhcih0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgY29uc3QgZmllbGRzQXJyYXkgPSBbXTtcbiAgICAgICAgY29uc3QgYWxsb3dlZCA9IG5ldyBTZXQoW1xuICAgICAgICAgICAgJ3llYXInLFxuICAgICAgICAgICAgJ21vbnRoJyxcbiAgICAgICAgICAgICdtb250aENvZGUnLFxuICAgICAgICAgICAgJ2RheScsXG4gICAgICAgICAgICAnaG91cicsXG4gICAgICAgICAgICAnbWludXRlJyxcbiAgICAgICAgICAgICdzZWNvbmQnLFxuICAgICAgICAgICAgJ21pbGxpc2Vjb25kJyxcbiAgICAgICAgICAgICdtaWNyb3NlY29uZCcsXG4gICAgICAgICAgICAnbmFub3NlY29uZCdcbiAgICAgICAgXSk7XG4gICAgICAgIGZvciAoY29uc3QgbmFtZSBvZiBmaWVsZHMpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBmaWVsZHMnKTtcbiAgICAgICAgICAgIGlmICghYWxsb3dlZC5oYXMobmFtZSkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYGludmFsaWQgZmllbGQgbmFtZSAke25hbWV9YCk7XG4gICAgICAgICAgICBhbGxvd2VkLmRlbGV0ZShuYW1lKTtcbiAgICAgICAgICAgIEFycmF5UHJvdG90eXBlUHVzaCQyLmNhbGwoZmllbGRzQXJyYXksIG5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbXBsW0dldFNsb3QodGhpcywgQ0FMRU5EQVJfSUQpXS5maWVsZHMoZmllbGRzQXJyYXkpO1xuICAgIH1cbiAgICBtZXJnZUZpZWxkcyhmaWVsZHMsIGFkZGl0aW9uYWxGaWVsZHMpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsQ2FsZW5kYXIodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIHJldHVybiBpbXBsW0dldFNsb3QodGhpcywgQ0FMRU5EQVJfSUQpXS5tZXJnZUZpZWxkcyhmaWVsZHMsIGFkZGl0aW9uYWxGaWVsZHMpO1xuICAgIH1cbiAgICBkYXRlQWRkKGRhdGVQYXJhbSwgZHVyYXRpb25QYXJhbSwgb3B0aW9uc1BhcmFtID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbENhbGVuZGFyKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICBjb25zdCBkYXRlID0gVG9UZW1wb3JhbERhdGUoZGF0ZVBhcmFtKTtcbiAgICAgICAgY29uc3QgZHVyYXRpb24gPSBUb1RlbXBvcmFsRHVyYXRpb24oZHVyYXRpb25QYXJhbSk7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSBHZXRPcHRpb25zT2JqZWN0KG9wdGlvbnNQYXJhbSk7XG4gICAgICAgIGNvbnN0IG92ZXJmbG93ID0gVG9UZW1wb3JhbE92ZXJmbG93KG9wdGlvbnMpO1xuICAgICAgICBjb25zdCB7IGRheXMgfSA9IEJhbGFuY2VEdXJhdGlvbihHZXRTbG90KGR1cmF0aW9uLCBEQVlTKSwgR2V0U2xvdChkdXJhdGlvbiwgSE9VUlMpLCBHZXRTbG90KGR1cmF0aW9uLCBNSU5VVEVTKSwgR2V0U2xvdChkdXJhdGlvbiwgU0VDT05EUyksIEdldFNsb3QoZHVyYXRpb24sIE1JTExJU0VDT05EUyksIEdldFNsb3QoZHVyYXRpb24sIE1JQ1JPU0VDT05EUyksIEdldFNsb3QoZHVyYXRpb24sIE5BTk9TRUNPTkRTKSwgJ2RheScpO1xuICAgICAgICByZXR1cm4gaW1wbFtHZXRTbG90KHRoaXMsIENBTEVOREFSX0lEKV0uZGF0ZUFkZChkYXRlLCBHZXRTbG90KGR1cmF0aW9uLCBZRUFSUyksIEdldFNsb3QoZHVyYXRpb24sIE1PTlRIUyksIEdldFNsb3QoZHVyYXRpb24sIFdFRUtTKSwgZGF5cywgb3ZlcmZsb3csIHRoaXMpO1xuICAgIH1cbiAgICBkYXRlVW50aWwob25lUGFyYW0sIHR3b1BhcmFtLCBvcHRpb25zUGFyYW0gPSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsQ2FsZW5kYXIodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIGNvbnN0IG9uZSA9IFRvVGVtcG9yYWxEYXRlKG9uZVBhcmFtKTtcbiAgICAgICAgY29uc3QgdHdvID0gVG9UZW1wb3JhbERhdGUodHdvUGFyYW0pO1xuICAgICAgICBjb25zdCBvcHRpb25zID0gR2V0T3B0aW9uc09iamVjdChvcHRpb25zUGFyYW0pO1xuICAgICAgICBjb25zdCBsYXJnZXN0VW5pdCA9IFRvTGFyZ2VzdFRlbXBvcmFsVW5pdChvcHRpb25zLCAnYXV0bycsIFsnaG91cicsICdtaW51dGUnLCAnc2Vjb25kJywgJ21pbGxpc2Vjb25kJywgJ21pY3Jvc2Vjb25kJywgJ25hbm9zZWNvbmQnXSwgJ2RheScpO1xuICAgICAgICBjb25zdCB7IHllYXJzLCBtb250aHMsIHdlZWtzLCBkYXlzIH0gPSBpbXBsW0dldFNsb3QodGhpcywgQ0FMRU5EQVJfSUQpXS5kYXRlVW50aWwob25lLCB0d28sIGxhcmdlc3RVbml0KTtcbiAgICAgICAgY29uc3QgRHVyYXRpb24gPSBHZXRJbnRyaW5zaWMoJyVUZW1wb3JhbC5EdXJhdGlvbiUnKTtcbiAgICAgICAgcmV0dXJuIG5ldyBEdXJhdGlvbih5ZWFycywgbW9udGhzLCB3ZWVrcywgZGF5cywgMCwgMCwgMCwgMCwgMCwgMCk7XG4gICAgfVxuICAgIHllYXIoZGF0ZVBhcmFtKSB7XG4gICAgICAgIGxldCBkYXRlID0gZGF0ZVBhcmFtO1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxDYWxlbmRhcih0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsWWVhck1vbnRoKGRhdGUpKVxuICAgICAgICAgICAgZGF0ZSA9IFRvVGVtcG9yYWxEYXRlKGRhdGUpO1xuICAgICAgICByZXR1cm4gaW1wbFtHZXRTbG90KHRoaXMsIENBTEVOREFSX0lEKV0ueWVhcihkYXRlKTtcbiAgICB9XG4gICAgbW9udGgoZGF0ZVBhcmFtKSB7XG4gICAgICAgIGxldCBkYXRlID0gZGF0ZVBhcmFtO1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxDYWxlbmRhcih0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgaWYgKElzVGVtcG9yYWxNb250aERheShkYXRlKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3VzZSBtb250aENvZGUgb24gUGxhaW5Nb250aERheSBpbnN0ZWFkJyk7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbFllYXJNb250aChkYXRlKSlcbiAgICAgICAgICAgIGRhdGUgPSBUb1RlbXBvcmFsRGF0ZShkYXRlKTtcbiAgICAgICAgcmV0dXJuIGltcGxbR2V0U2xvdCh0aGlzLCBDQUxFTkRBUl9JRCldLm1vbnRoKGRhdGUpO1xuICAgIH1cbiAgICBtb250aENvZGUoZGF0ZVBhcmFtKSB7XG4gICAgICAgIGxldCBkYXRlID0gZGF0ZVBhcmFtO1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxDYWxlbmRhcih0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsWWVhck1vbnRoKGRhdGUpICYmICFJc1RlbXBvcmFsTW9udGhEYXkoZGF0ZSkpXG4gICAgICAgICAgICBkYXRlID0gVG9UZW1wb3JhbERhdGUoZGF0ZSk7XG4gICAgICAgIHJldHVybiBpbXBsW0dldFNsb3QodGhpcywgQ0FMRU5EQVJfSUQpXS5tb250aENvZGUoZGF0ZSk7XG4gICAgfVxuICAgIGRheShkYXRlUGFyYW0pIHtcbiAgICAgICAgbGV0IGRhdGUgPSBkYXRlUGFyYW07XG4gICAgICAgIGlmICghSXNUZW1wb3JhbENhbGVuZGFyKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxNb250aERheShkYXRlKSlcbiAgICAgICAgICAgIGRhdGUgPSBUb1RlbXBvcmFsRGF0ZShkYXRlKTtcbiAgICAgICAgcmV0dXJuIGltcGxbR2V0U2xvdCh0aGlzLCBDQUxFTkRBUl9JRCldLmRheShkYXRlKTtcbiAgICB9XG4gICAgZXJhKGRhdGVQYXJhbSkge1xuICAgICAgICBsZXQgZGF0ZSA9IGRhdGVQYXJhbTtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsQ2FsZW5kYXIodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbFllYXJNb250aChkYXRlKSlcbiAgICAgICAgICAgIGRhdGUgPSBUb1RlbXBvcmFsRGF0ZShkYXRlKTtcbiAgICAgICAgcmV0dXJuIGltcGxbR2V0U2xvdCh0aGlzLCBDQUxFTkRBUl9JRCldLmVyYShkYXRlKTtcbiAgICB9XG4gICAgZXJhWWVhcihkYXRlUGFyYW0pIHtcbiAgICAgICAgbGV0IGRhdGUgPSBkYXRlUGFyYW07XG4gICAgICAgIGlmICghSXNUZW1wb3JhbENhbGVuZGFyKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxZZWFyTW9udGgoZGF0ZSkpXG4gICAgICAgICAgICBkYXRlID0gVG9UZW1wb3JhbERhdGUoZGF0ZSk7XG4gICAgICAgIHJldHVybiBpbXBsW0dldFNsb3QodGhpcywgQ0FMRU5EQVJfSUQpXS5lcmFZZWFyKGRhdGUpO1xuICAgIH1cbiAgICBkYXlPZldlZWsoZGF0ZVBhcmFtKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbENhbGVuZGFyKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICBjb25zdCBkYXRlID0gVG9UZW1wb3JhbERhdGUoZGF0ZVBhcmFtKTtcbiAgICAgICAgcmV0dXJuIGltcGxbR2V0U2xvdCh0aGlzLCBDQUxFTkRBUl9JRCldLmRheU9mV2VlayhkYXRlKTtcbiAgICB9XG4gICAgZGF5T2ZZZWFyKGRhdGVQYXJhbSkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxDYWxlbmRhcih0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgY29uc3QgZGF0ZSA9IFRvVGVtcG9yYWxEYXRlKGRhdGVQYXJhbSk7XG4gICAgICAgIHJldHVybiBpbXBsW0dldFNsb3QodGhpcywgQ0FMRU5EQVJfSUQpXS5kYXlPZlllYXIoZGF0ZSk7XG4gICAgfVxuICAgIHdlZWtPZlllYXIoZGF0ZVBhcmFtKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbENhbGVuZGFyKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICBjb25zdCBkYXRlID0gVG9UZW1wb3JhbERhdGUoZGF0ZVBhcmFtKTtcbiAgICAgICAgcmV0dXJuIGltcGxbR2V0U2xvdCh0aGlzLCBDQUxFTkRBUl9JRCldLndlZWtPZlllYXIoZGF0ZSk7XG4gICAgfVxuICAgIGRheXNJbldlZWsoZGF0ZVBhcmFtKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbENhbGVuZGFyKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICBjb25zdCBkYXRlID0gVG9UZW1wb3JhbERhdGUoZGF0ZVBhcmFtKTtcbiAgICAgICAgcmV0dXJuIGltcGxbR2V0U2xvdCh0aGlzLCBDQUxFTkRBUl9JRCldLmRheXNJbldlZWsoZGF0ZSk7XG4gICAgfVxuICAgIGRheXNJbk1vbnRoKGRhdGVQYXJhbSkge1xuICAgICAgICBsZXQgZGF0ZSA9IGRhdGVQYXJhbTtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsQ2FsZW5kYXIodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbFllYXJNb250aChkYXRlKSlcbiAgICAgICAgICAgIGRhdGUgPSBUb1RlbXBvcmFsRGF0ZShkYXRlKTtcbiAgICAgICAgcmV0dXJuIGltcGxbR2V0U2xvdCh0aGlzLCBDQUxFTkRBUl9JRCldLmRheXNJbk1vbnRoKGRhdGUpO1xuICAgIH1cbiAgICBkYXlzSW5ZZWFyKGRhdGVQYXJhbSkge1xuICAgICAgICBsZXQgZGF0ZSA9IGRhdGVQYXJhbTtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsQ2FsZW5kYXIodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbFllYXJNb250aChkYXRlKSlcbiAgICAgICAgICAgIGRhdGUgPSBUb1RlbXBvcmFsRGF0ZShkYXRlKTtcbiAgICAgICAgcmV0dXJuIGltcGxbR2V0U2xvdCh0aGlzLCBDQUxFTkRBUl9JRCldLmRheXNJblllYXIoZGF0ZSk7XG4gICAgfVxuICAgIG1vbnRoc0luWWVhcihkYXRlUGFyYW0pIHtcbiAgICAgICAgbGV0IGRhdGUgPSBkYXRlUGFyYW07XG4gICAgICAgIGlmICghSXNUZW1wb3JhbENhbGVuZGFyKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxZZWFyTW9udGgoZGF0ZSkpXG4gICAgICAgICAgICBkYXRlID0gVG9UZW1wb3JhbERhdGUoZGF0ZSk7XG4gICAgICAgIHJldHVybiBpbXBsW0dldFNsb3QodGhpcywgQ0FMRU5EQVJfSUQpXS5tb250aHNJblllYXIoZGF0ZSk7XG4gICAgfVxuICAgIGluTGVhcFllYXIoZGF0ZVBhcmFtKSB7XG4gICAgICAgIGxldCBkYXRlID0gZGF0ZVBhcmFtO1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxDYWxlbmRhcih0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsWWVhck1vbnRoKGRhdGUpKVxuICAgICAgICAgICAgZGF0ZSA9IFRvVGVtcG9yYWxEYXRlKGRhdGUpO1xuICAgICAgICByZXR1cm4gaW1wbFtHZXRTbG90KHRoaXMsIENBTEVOREFSX0lEKV0uaW5MZWFwWWVhcihkYXRlKTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbENhbGVuZGFyKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICByZXR1cm4gR2V0U2xvdCh0aGlzLCBDQUxFTkRBUl9JRCk7XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsQ2FsZW5kYXIodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIHJldHVybiBUb1N0cmluZyh0aGlzKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb20oaXRlbSkge1xuICAgICAgICByZXR1cm4gVG9UZW1wb3JhbENhbGVuZGFyKGl0ZW0pO1xuICAgIH1cbn1cbk1ha2VJbnRyaW5zaWNDbGFzcyhDYWxlbmRhciwgJ1RlbXBvcmFsLkNhbGVuZGFyJyk7XG5EZWZpbmVJbnRyaW5zaWMoJ1RlbXBvcmFsLkNhbGVuZGFyLmZyb20nLCBDYWxlbmRhci5mcm9tKTtcbi8qKlxuICogSW1wbGVtZW50YXRpb24gZm9yIHRoZSBJU08gODYwMSBjYWxlbmRhci4gVGhpcyBpcyB0aGUgb25seSBjYWxlbmRhciB0aGF0J3NcbiAqIGd1YXJhbnRlZWQgdG8gYmUgc3VwcG9ydGVkIGJ5IGFsbCBFQ01BU2NyaXB0IGltcGxlbWVudGF0aW9ucywgaW5jbHVkaW5nIHRob3NlXG4gKiB3aXRob3V0IEludGwgKEVDTUEtNDAyKSBzdXBwb3J0LlxuICovXG5pbXBsWydpc284NjAxJ10gPSB7XG4gICAgZGF0ZUZyb21GaWVsZHMoZmllbGRzUGFyYW0sIG9wdGlvbnMsIGNhbGVuZGFyKSB7XG4gICAgICAgIGNvbnN0IG92ZXJmbG93ID0gVG9UZW1wb3JhbE92ZXJmbG93KG9wdGlvbnMpO1xuICAgICAgICBsZXQgZmllbGRzID0gUHJlcGFyZVRlbXBvcmFsRmllbGRzKGZpZWxkc1BhcmFtLCBbXG4gICAgICAgICAgICBbJ2RheSddLFxuICAgICAgICAgICAgWydtb250aCcsIHVuZGVmaW5lZF0sXG4gICAgICAgICAgICBbJ21vbnRoQ29kZScsIHVuZGVmaW5lZF0sXG4gICAgICAgICAgICBbJ3llYXInXVxuICAgICAgICBdKTtcbiAgICAgICAgZmllbGRzID0gcmVzb2x2ZU5vbkx1bmlzb2xhck1vbnRoKGZpZWxkcyk7XG4gICAgICAgIGxldCB7IHllYXIsIG1vbnRoLCBkYXkgfSA9IGZpZWxkcztcbiAgICAgICAgKHsgeWVhciwgbW9udGgsIGRheSB9ID0gUmVndWxhdGVJU09EYXRlKHllYXIsIG1vbnRoLCBkYXksIG92ZXJmbG93KSk7XG4gICAgICAgIHJldHVybiBDcmVhdGVUZW1wb3JhbERhdGUoeWVhciwgbW9udGgsIGRheSwgY2FsZW5kYXIpO1xuICAgIH0sXG4gICAgeWVhck1vbnRoRnJvbUZpZWxkcyhmaWVsZHNQYXJhbSwgb3B0aW9ucywgY2FsZW5kYXIpIHtcbiAgICAgICAgY29uc3Qgb3ZlcmZsb3cgPSBUb1RlbXBvcmFsT3ZlcmZsb3cob3B0aW9ucyk7XG4gICAgICAgIGxldCBmaWVsZHMgPSBQcmVwYXJlVGVtcG9yYWxGaWVsZHMoZmllbGRzUGFyYW0sIFtcbiAgICAgICAgICAgIFsnbW9udGgnLCB1bmRlZmluZWRdLFxuICAgICAgICAgICAgWydtb250aENvZGUnLCB1bmRlZmluZWRdLFxuICAgICAgICAgICAgWyd5ZWFyJ11cbiAgICAgICAgXSk7XG4gICAgICAgIGZpZWxkcyA9IHJlc29sdmVOb25MdW5pc29sYXJNb250aChmaWVsZHMpO1xuICAgICAgICBsZXQgeyB5ZWFyLCBtb250aCB9ID0gZmllbGRzO1xuICAgICAgICAoeyB5ZWFyLCBtb250aCB9ID0gUmVndWxhdGVJU09ZZWFyTW9udGgoeWVhciwgbW9udGgsIG92ZXJmbG93KSk7XG4gICAgICAgIHJldHVybiBDcmVhdGVUZW1wb3JhbFllYXJNb250aCh5ZWFyLCBtb250aCwgY2FsZW5kYXIsIC8qIHJlZmVyZW5jZUlTT0RheSA9ICovIDEpO1xuICAgIH0sXG4gICAgbW9udGhEYXlGcm9tRmllbGRzKGZpZWxkc1BhcmFtLCBvcHRpb25zLCBjYWxlbmRhcikge1xuICAgICAgICBjb25zdCBvdmVyZmxvdyA9IFRvVGVtcG9yYWxPdmVyZmxvdyhvcHRpb25zKTtcbiAgICAgICAgbGV0IGZpZWxkcyA9IFByZXBhcmVUZW1wb3JhbEZpZWxkcyhmaWVsZHNQYXJhbSwgW1xuICAgICAgICAgICAgWydkYXknXSxcbiAgICAgICAgICAgIFsnbW9udGgnLCB1bmRlZmluZWRdLFxuICAgICAgICAgICAgWydtb250aENvZGUnLCB1bmRlZmluZWRdLFxuICAgICAgICAgICAgWyd5ZWFyJywgdW5kZWZpbmVkXVxuICAgICAgICBdKTtcbiAgICAgICAgaWYgKGZpZWxkcy5tb250aCAhPT0gdW5kZWZpbmVkICYmIGZpZWxkcy55ZWFyID09PSB1bmRlZmluZWQgJiYgZmllbGRzLm1vbnRoQ29kZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdlaXRoZXIgeWVhciBvciBtb250aENvZGUgcmVxdWlyZWQgd2l0aCBtb250aCcpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVzZVllYXIgPSBmaWVsZHMubW9udGhDb2RlID09PSB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IHJlZmVyZW5jZUlTT1llYXIgPSAxOTcyO1xuICAgICAgICBmaWVsZHMgPSByZXNvbHZlTm9uTHVuaXNvbGFyTW9udGgoZmllbGRzKTtcbiAgICAgICAgbGV0IHsgbW9udGgsIGRheSwgeWVhciB9ID0gZmllbGRzO1xuICAgICAgICAoeyBtb250aCwgZGF5IH0gPSBSZWd1bGF0ZUlTT0RhdGUodXNlWWVhciA/IHllYXIgOiByZWZlcmVuY2VJU09ZZWFyLCBtb250aCwgZGF5LCBvdmVyZmxvdykpO1xuICAgICAgICByZXR1cm4gQ3JlYXRlVGVtcG9yYWxNb250aERheShtb250aCwgZGF5LCBjYWxlbmRhciwgcmVmZXJlbmNlSVNPWWVhcik7XG4gICAgfSxcbiAgICBmaWVsZHMoZmllbGRzKSB7XG4gICAgICAgIHJldHVybiBmaWVsZHM7XG4gICAgfSxcbiAgICBtZXJnZUZpZWxkcyhmaWVsZHMsIGFkZGl0aW9uYWxGaWVsZHMpIHtcbiAgICAgICAgY29uc3QgbWVyZ2VkID0ge307XG4gICAgICAgIGZvciAoY29uc3QgbmV4dEtleSBvZiBPYmplY3RLZXlzKGZpZWxkcykpIHtcbiAgICAgICAgICAgIGlmIChuZXh0S2V5ID09PSAnbW9udGgnIHx8IG5leHRLZXkgPT09ICdtb250aENvZGUnKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgbWVyZ2VkW25leHRLZXldID0gZmllbGRzW25leHRLZXldO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5ld0tleXMgPSBPYmplY3RLZXlzKGFkZGl0aW9uYWxGaWVsZHMpO1xuICAgICAgICBmb3IgKGNvbnN0IG5leHRLZXkgb2YgbmV3S2V5cykge1xuICAgICAgICAgICAgbWVyZ2VkW25leHRLZXldID0gYWRkaXRpb25hbEZpZWxkc1tuZXh0S2V5XTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIUFycmF5SW5jbHVkZXMuY2FsbChuZXdLZXlzLCAnbW9udGgnKSAmJiAhQXJyYXlJbmNsdWRlcy5jYWxsKG5ld0tleXMsICdtb250aENvZGUnKSkge1xuICAgICAgICAgICAgY29uc3QgeyBtb250aCwgbW9udGhDb2RlIH0gPSBmaWVsZHM7XG4gICAgICAgICAgICBpZiAobW9udGggIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICBtZXJnZWQubW9udGggPSBtb250aDtcbiAgICAgICAgICAgIGlmIChtb250aENvZGUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICBtZXJnZWQubW9udGhDb2RlID0gbW9udGhDb2RlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXJnZWQ7XG4gICAgfSxcbiAgICBkYXRlQWRkKGRhdGUsIHllYXJzLCBtb250aHMsIHdlZWtzLCBkYXlzLCBvdmVyZmxvdywgY2FsZW5kYXIpIHtcbiAgICAgICAgbGV0IHllYXIgPSBHZXRTbG90KGRhdGUsIElTT19ZRUFSKTtcbiAgICAgICAgbGV0IG1vbnRoID0gR2V0U2xvdChkYXRlLCBJU09fTU9OVEgpO1xuICAgICAgICBsZXQgZGF5ID0gR2V0U2xvdChkYXRlLCBJU09fREFZKTtcbiAgICAgICAgKHsgeWVhciwgbW9udGgsIGRheSB9ID0gQWRkSVNPRGF0ZSh5ZWFyLCBtb250aCwgZGF5LCB5ZWFycywgbW9udGhzLCB3ZWVrcywgZGF5cywgb3ZlcmZsb3cpKTtcbiAgICAgICAgcmV0dXJuIENyZWF0ZVRlbXBvcmFsRGF0ZSh5ZWFyLCBtb250aCwgZGF5LCBjYWxlbmRhcik7XG4gICAgfSxcbiAgICBkYXRlVW50aWwob25lLCB0d28sIGxhcmdlc3RVbml0KSB7XG4gICAgICAgIHJldHVybiBEaWZmZXJlbmNlSVNPRGF0ZShHZXRTbG90KG9uZSwgSVNPX1lFQVIpLCBHZXRTbG90KG9uZSwgSVNPX01PTlRIKSwgR2V0U2xvdChvbmUsIElTT19EQVkpLCBHZXRTbG90KHR3bywgSVNPX1lFQVIpLCBHZXRTbG90KHR3bywgSVNPX01PTlRIKSwgR2V0U2xvdCh0d28sIElTT19EQVkpLCBsYXJnZXN0VW5pdCk7XG4gICAgfSxcbiAgICB5ZWFyKGRhdGUpIHtcbiAgICAgICAgcmV0dXJuIEdldFNsb3QoZGF0ZSwgSVNPX1lFQVIpO1xuICAgIH0sXG4gICAgZXJhKCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH0sXG4gICAgZXJhWWVhcigpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9LFxuICAgIG1vbnRoKGRhdGUpIHtcbiAgICAgICAgcmV0dXJuIEdldFNsb3QoZGF0ZSwgSVNPX01PTlRIKTtcbiAgICB9LFxuICAgIG1vbnRoQ29kZShkYXRlKSB7XG4gICAgICAgIHJldHVybiBidWlsZE1vbnRoQ29kZShHZXRTbG90KGRhdGUsIElTT19NT05USCkpO1xuICAgIH0sXG4gICAgZGF5KGRhdGUpIHtcbiAgICAgICAgcmV0dXJuIEdldFNsb3QoZGF0ZSwgSVNPX0RBWSk7XG4gICAgfSxcbiAgICBkYXlPZldlZWsoZGF0ZSkge1xuICAgICAgICByZXR1cm4gRGF5T2ZXZWVrKEdldFNsb3QoZGF0ZSwgSVNPX1lFQVIpLCBHZXRTbG90KGRhdGUsIElTT19NT05USCksIEdldFNsb3QoZGF0ZSwgSVNPX0RBWSkpO1xuICAgIH0sXG4gICAgZGF5T2ZZZWFyKGRhdGUpIHtcbiAgICAgICAgcmV0dXJuIERheU9mWWVhcihHZXRTbG90KGRhdGUsIElTT19ZRUFSKSwgR2V0U2xvdChkYXRlLCBJU09fTU9OVEgpLCBHZXRTbG90KGRhdGUsIElTT19EQVkpKTtcbiAgICB9LFxuICAgIHdlZWtPZlllYXIoZGF0ZSkge1xuICAgICAgICByZXR1cm4gV2Vla09mWWVhcihHZXRTbG90KGRhdGUsIElTT19ZRUFSKSwgR2V0U2xvdChkYXRlLCBJU09fTU9OVEgpLCBHZXRTbG90KGRhdGUsIElTT19EQVkpKTtcbiAgICB9LFxuICAgIGRheXNJbldlZWsoKSB7XG4gICAgICAgIHJldHVybiA3O1xuICAgIH0sXG4gICAgZGF5c0luTW9udGgoZGF0ZSkge1xuICAgICAgICByZXR1cm4gSVNPRGF5c0luTW9udGgoR2V0U2xvdChkYXRlLCBJU09fWUVBUiksIEdldFNsb3QoZGF0ZSwgSVNPX01PTlRIKSk7XG4gICAgfSxcbiAgICBkYXlzSW5ZZWFyKGRhdGVQYXJhbSkge1xuICAgICAgICBsZXQgZGF0ZSA9IGRhdGVQYXJhbTtcbiAgICAgICAgaWYgKCFIYXNTbG90KGRhdGUsIElTT19ZRUFSKSlcbiAgICAgICAgICAgIGRhdGUgPSBUb1RlbXBvcmFsRGF0ZShkYXRlKTtcbiAgICAgICAgcmV0dXJuIExlYXBZZWFyKEdldFNsb3QoZGF0ZSwgSVNPX1lFQVIpKSA/IDM2NiA6IDM2NTtcbiAgICB9LFxuICAgIG1vbnRoc0luWWVhcigpIHtcbiAgICAgICAgcmV0dXJuIDEyO1xuICAgIH0sXG4gICAgaW5MZWFwWWVhcihkYXRlUGFyYW0pIHtcbiAgICAgICAgbGV0IGRhdGUgPSBkYXRlUGFyYW07XG4gICAgICAgIGlmICghSGFzU2xvdChkYXRlLCBJU09fWUVBUikpXG4gICAgICAgICAgICBkYXRlID0gVG9UZW1wb3JhbERhdGUoZGF0ZSk7XG4gICAgICAgIHJldHVybiBMZWFwWWVhcihHZXRTbG90KGRhdGUsIElTT19ZRUFSKSk7XG4gICAgfVxufTtcbmZ1bmN0aW9uIG1vbnRoQ29kZU51bWJlclBhcnQobW9udGhDb2RlKSB7XG4gICAgaWYgKCFtb250aENvZGUuc3RhcnRzV2l0aCgnTScpKSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBJbnZhbGlkIG1vbnRoIGNvZGU6ICR7bW9udGhDb2RlfS4gIE1vbnRoIGNvZGVzIG11c3Qgc3RhcnQgd2l0aCBNLmApO1xuICAgIH1cbiAgICBjb25zdCBtb250aCA9ICttb250aENvZGUuc2xpY2UoMSk7XG4gICAgaWYgKGlzTmFOKG1vbnRoKSlcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYEludmFsaWQgbW9udGggY29kZTogJHttb250aENvZGV9YCk7XG4gICAgcmV0dXJuIG1vbnRoO1xufVxuZnVuY3Rpb24gYnVpbGRNb250aENvZGUobW9udGgsIGxlYXAgPSBmYWxzZSkge1xuICAgIHJldHVybiBgTSR7bW9udGgudG9TdHJpbmcoKS5wYWRTdGFydCgyLCAnMCcpfSR7bGVhcCA/ICdMJyA6ICcnfWA7XG59XG4vKipcbiAqIFNhZmVseSBtZXJnZSBhIG1vbnRoLCBtb250aENvZGUgcGFpciBpbnRvIGFuIGludGVnZXIgbW9udGguXG4gKiBJZiBib3RoIGFyZSBwcmVzZW50LCBtYWtlIHN1cmUgdGhleSBtYXRjaC5cbiAqIFRoaXMgbG9naWMgZG9lc24ndCB3b3JrIGZvciBsdW5pc29sYXIgY2FsZW5kYXJzIVxuICogKi9cbmZ1bmN0aW9uIHJlc29sdmVOb25MdW5pc29sYXJNb250aChjYWxlbmRhckRhdGUsIG92ZXJmbG93ID0gdW5kZWZpbmVkLCBtb250aHNQZXJZZWFyID0gMTIpIHtcbiAgICBsZXQgeyBtb250aCwgbW9udGhDb2RlIH0gPSBjYWxlbmRhckRhdGU7XG4gICAgaWYgKG1vbnRoQ29kZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChtb250aCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRWl0aGVyIG1vbnRoIG9yIG1vbnRoQ29kZSBhcmUgcmVxdWlyZWQnKTtcbiAgICAgICAgLy8gVGhlIElTTyBjYWxlbmRhciB1c2VzIHRoZSBkZWZhdWx0ICh1bmRlZmluZWQpIHZhbHVlIGJlY2F1c2UgaXQgZG9lc1xuICAgICAgICAvLyBjb25zdHJhaW4vcmVqZWN0IGFmdGVyIHRoaXMgbWV0aG9kIHJldHVybnMuIE5vbi1JU08gY2FsZW5kYXJzLCBob3dldmVyLFxuICAgICAgICAvLyByZWx5IG9uIHRoaXMgZnVuY3Rpb24gdG8gY29uc3RyYWluL3JlamVjdCBvdXQtb2YtcmFuZ2UgYG1vbnRoYCB2YWx1ZXMuXG4gICAgICAgIGlmIChvdmVyZmxvdyA9PT0gJ3JlamVjdCcpXG4gICAgICAgICAgICBSZWplY3RUb1JhbmdlKG1vbnRoLCAxLCBtb250aHNQZXJZZWFyKTtcbiAgICAgICAgaWYgKG92ZXJmbG93ID09PSAnY29uc3RyYWluJylcbiAgICAgICAgICAgIG1vbnRoID0gQ29uc3RyYWluVG9SYW5nZShtb250aCwgMSwgbW9udGhzUGVyWWVhcik7XG4gICAgICAgIG1vbnRoQ29kZSA9IGJ1aWxkTW9udGhDb2RlKG1vbnRoKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IG51bWJlclBhcnQgPSBtb250aENvZGVOdW1iZXJQYXJ0KG1vbnRoQ29kZSk7XG4gICAgICAgIGlmIChtb250aCAhPT0gdW5kZWZpbmVkICYmIG1vbnRoICE9PSBudW1iZXJQYXJ0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgbW9udGhDb2RlICR7bW9udGhDb2RlfSBhbmQgbW9udGggJHttb250aH0gbXVzdCBtYXRjaCBpZiBib3RoIGFyZSBwcmVzZW50YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1vbnRoQ29kZSAhPT0gYnVpbGRNb250aENvZGUobnVtYmVyUGFydCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBJbnZhbGlkIG1vbnRoIGNvZGU6ICR7bW9udGhDb2RlfWApO1xuICAgICAgICB9XG4gICAgICAgIG1vbnRoID0gbnVtYmVyUGFydDtcbiAgICAgICAgaWYgKG1vbnRoIDwgMSB8fCBtb250aCA+IG1vbnRoc1BlclllYXIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgSW52YWxpZCBtb250aENvZGU6ICR7bW9udGhDb2RlfWApO1xuICAgIH1cbiAgICByZXR1cm4geyAuLi5jYWxlbmRhckRhdGUsIG1vbnRoLCBtb250aENvZGUgfTtcbn1cbi8qKlxuICogVGhpcyBwcm90b3R5cGUgaW1wbGVtZW50YXRpb24gb2Ygbm9uLUlTTyBjYWxlbmRhcnMgbWFrZXMgbWFueSByZXBlYXRlZCBjYWxsc1xuICogdG8gSW50bCBBUElzIHdoaWNoIG1heSBiZSBzbG93IChlLmcuID4wLjJtcykuIFRoaXMgdHJpdmlhbCBjYWNoZSB3aWxsIHNwZWVkXG4gKiB1cCB0aGVzZSByZXBlYXQgYWNjZXNzZXMuIEVhY2ggY2FjaGUgaW5zdGFuY2UgaXMgYXNzb2NpYXRlZCAodmlhIGEgV2Vha01hcClcbiAqIHRvIGEgc3BlY2lmaWMgVGVtcG9yYWwgb2JqZWN0LCB3aGljaCBzcGVlZHMgdXAgbXVsdGlwbGUgY2FsZW5kYXIgY2FsbHMgb24gdGhlXG4gKiBzYW1lIFRlbXBvcmFsIG9iamVjdCBpbnN0YW5jZS4gIE5vIGludmFsaWRhdGlvbiBvciBwcnVuaW5nIGlzIG5lY2Vzc2FyeVxuICogYmVjYXVzZSBlYWNoIG9iamVjdCdzIGNhY2hlIGlzIHRocm93biBhd2F5IHdoZW4gdGhlIG9iamVjdCBpcyBHQy1lZC5cbiAqL1xuY2xhc3MgT25lT2JqZWN0Q2FjaGUge1xuICAgIGNvbnN0cnVjdG9yKGNhY2hlVG9DbG9uZSkge1xuICAgICAgICB0aGlzLm1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5jYWxscyA9IDA7XG4gICAgICAgIHRoaXMuaGl0cyA9IDA7XG4gICAgICAgIHRoaXMubWlzc2VzID0gMDtcbiAgICAgICAgdGhpcy5ub3cgPSBnbG9iYWxUaGlzLnBlcmZvcm1hbmNlID8gZ2xvYmFsVGhpcy5wZXJmb3JtYW5jZS5ub3coKSA6IERhdGUubm93KCk7XG4gICAgICAgIGlmIChjYWNoZVRvQ2xvbmUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICAgICAgZm9yIChjb25zdCBlbnRyeSBvZiBjYWNoZVRvQ2xvbmUubWFwLmVudHJpZXMoKSkge1xuICAgICAgICAgICAgICAgIGlmICgrK2kgPiBPbmVPYmplY3RDYWNoZS5NQVhfQ0FDSEVfRU5UUklFUylcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgdGhpcy5tYXAuc2V0KC4uLmVudHJ5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQoa2V5KSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMubWFwLmdldChrZXkpO1xuICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICB0aGlzLmhpdHMrKztcbiAgICAgICAgICAgIHRoaXMucmVwb3J0KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jYWxscysrO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBzZXQoa2V5LCB2YWx1ZSkge1xuICAgICAgICB0aGlzLm1hcC5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgIHRoaXMubWlzc2VzKys7XG4gICAgICAgIHRoaXMucmVwb3J0KCk7XG4gICAgfVxuICAgIHJlcG9ydCgpIHtcbiAgICAgICAgLypcbiAgICAgICAgaWYgKHRoaXMuY2FsbHMgPT09IDApIHJldHVybjtcbiAgICAgICAgY29uc3QgbXMgPSAoZ2xvYmFsVGhpcy5wZXJmb3JtYW5jZSA/IGdsb2JhbFRoaXMucGVyZm9ybWFuY2Uubm93KCkgOiBEYXRlLm5vdygpKSAtIHRoaXMubm93O1xuICAgICAgICBjb25zdCBoaXRSYXRlID0gKCgxMDAgKiB0aGlzLmhpdHMpIC8gdGhpcy5jYWxscykudG9GaXhlZCgwKTtcbiAgICAgICAgY29uc29sZS5sb2coYCR7dGhpcy5jYWxsc30gY2FsbHMgaW4gJHttcy50b0ZpeGVkKDIpfW1zLiBIaXRzOiAke3RoaXMuaGl0c30gKCR7aGl0UmF0ZX0lKS4gTWlzc2VzOiAke3RoaXMubWlzc2VzfS5gKTtcbiAgICAgICAgKi9cbiAgICB9XG4gICAgc2V0T2JqZWN0KG9iaikge1xuICAgICAgICBpZiAoT25lT2JqZWN0Q2FjaGUub2JqZWN0TWFwLmdldChvYmopKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ29iamVjdCBhbHJlYWR5IGNhY2hlZCcpO1xuICAgICAgICBPbmVPYmplY3RDYWNoZS5vYmplY3RNYXAuc2V0KG9iaiwgdGhpcyk7XG4gICAgICAgIHRoaXMucmVwb3J0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBXZWFrTWFwLWJhY2tlZCBjYWNoZSB0aGF0J3MgdXNlZCB0byBzdG9yZSBleHBlbnNpdmUgcmVzdWx0c1xuICAgICAqIHRoYXQgYXJlIGFzc29jaWF0ZWQgd2l0aCBhIHBhcnRpY3VsYXIgVGVtcG9yYWwgb2JqZWN0IGluc3RhbmNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIG9iaiAtIG9iamVjdCB0byBhc3NvY2lhdGUgd2l0aCB0aGUgY2FjaGVcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0Q2FjaGVGb3JPYmplY3Qob2JqKSB7XG4gICAgICAgIGxldCBjYWNoZSA9IE9uZU9iamVjdENhY2hlLm9iamVjdE1hcC5nZXQob2JqKTtcbiAgICAgICAgaWYgKCFjYWNoZSkge1xuICAgICAgICAgICAgY2FjaGUgPSBuZXcgT25lT2JqZWN0Q2FjaGUoKTtcbiAgICAgICAgICAgIE9uZU9iamVjdENhY2hlLm9iamVjdE1hcC5zZXQob2JqLCBjYWNoZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNhY2hlO1xuICAgIH1cbn1cbk9uZU9iamVjdENhY2hlLm9iamVjdE1hcCA9IG5ldyBXZWFrTWFwKCk7XG5PbmVPYmplY3RDYWNoZS5NQVhfQ0FDSEVfRU5UUklFUyA9IDEwMDA7XG5mdW5jdGlvbiB0b1V0Y0lzb0RhdGVTdHJpbmcoeyBpc29ZZWFyLCBpc29Nb250aCwgaXNvRGF5IH0pIHtcbiAgICBjb25zdCB5ZWFyU3RyaW5nID0gSVNPWWVhclN0cmluZyhpc29ZZWFyKTtcbiAgICBjb25zdCBtb250aFN0cmluZyA9IElTT0RhdGVUaW1lUGFydFN0cmluZyhpc29Nb250aCk7XG4gICAgY29uc3QgZGF5U3RyaW5nID0gSVNPRGF0ZVRpbWVQYXJ0U3RyaW5nKGlzb0RheSk7XG4gICAgcmV0dXJuIGAke3llYXJTdHJpbmd9LSR7bW9udGhTdHJpbmd9LSR7ZGF5U3RyaW5nfVQwMDowMFpgO1xufVxuZnVuY3Rpb24gc2ltcGxlRGF0ZURpZmYob25lLCB0d28pIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB5ZWFyczogb25lLnllYXIgLSB0d28ueWVhcixcbiAgICAgICAgbW9udGhzOiBvbmUubW9udGggLSB0d28ubW9udGgsXG4gICAgICAgIGRheXM6IG9uZS5kYXkgLSB0d28uZGF5XG4gICAgfTtcbn1cbi8qKlxuICogSW1wbGVtZW50YXRpb24gaGVscGVyIHRoYXQncyBjb21tb24gdG8gYWxsIG5vbi1JU08gY2FsZW5kYXJzXG4gKi9cbmNsYXNzIEhlbHBlckJhc2Uge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAvLyBUaGUgc2hvcnQgZXJhIGZvcm1hdCB3b3JrcyBmb3IgYWxsIGNhbGVuZGFycyBleGNlcHQgSmFwYW5lc2UsIHdoaWNoIHdpbGxcbiAgICAgICAgLy8gb3ZlcnJpZGUuXG4gICAgICAgIHRoaXMuZXJhTGVuZ3RoID0gJ3Nob3J0JztcbiAgICAgICAgLy8gQWxsIGJ1aWx0LWluIGNhbGVuZGFycyBleGNlcHQgQ2hpbmVzZS9EYW5naSBhbmQgSGVicmV3IHVzZSBhbiBlcmFcbiAgICAgICAgdGhpcy5oYXNFcmEgPSB0cnVlO1xuICAgIH1cbiAgICBnZXRGb3JtYXR0ZXIoKSB7XG4gICAgICAgIC8vIGBuZXcgSW50bC5EYXRlVGltZUZvcm1hdCgpYCBpcyBhbWF6aW5nbHkgc2xvdyBhbmQgY2hld3MgdXAgUkFNLiBQZXJcbiAgICAgICAgLy8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9NjUyOCNjNCwgd2UgY2FjaGUgb25lXG4gICAgICAgIC8vIERhdGVUaW1lRm9ybWF0IGluc3RhbmNlIHBlciBjYWxlbmRhci4gQ2FjaGluZyBpcyBsYXp5IHNvIHdlIG9ubHkgcGF5IGZvclxuICAgICAgICAvLyBjYWxlbmRhcnMgdGhhdCBhcmUgdXNlZC4gTm90ZSB0aGF0IHRoZSBub25Jc29IZWxwZXJCYXNlIG9iamVjdCBpcyBzcHJlYWRcbiAgICAgICAgLy8gaW50byBlYWNoIGVhY2ggY2FsZW5kYXIncyBpbXBsZW1lbnRhdGlvbiBiZWZvcmUgYW55IGNhY2hlIGlzIGNyZWF0ZWQsIHNvXG4gICAgICAgIC8vIGVhY2ggY2FsZW5kYXIgZ2V0cyBpdHMgb3duIHNlcGFyYXRlIGNhY2hlZCBmb3JtYXR0ZXIuXG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5mb3JtYXR0ZXIgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aGlzLmZvcm1hdHRlciA9IG5ldyBJbnRsRGF0ZVRpbWVGb3JtYXQkMihgZW4tVVMtdS1jYS0ke3RoaXMuaWR9YCwge1xuICAgICAgICAgICAgICAgIGRheTogJ251bWVyaWMnLFxuICAgICAgICAgICAgICAgIG1vbnRoOiAnbnVtZXJpYycsXG4gICAgICAgICAgICAgICAgeWVhcjogJ251bWVyaWMnLFxuICAgICAgICAgICAgICAgIGVyYTogdGhpcy5lcmFMZW5ndGgsXG4gICAgICAgICAgICAgICAgdGltZVpvbmU6ICdVVEMnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5mb3JtYXR0ZXI7XG4gICAgfVxuICAgIGlzb1RvQ2FsZW5kYXJEYXRlKGlzb0RhdGUsIGNhY2hlKSB7XG4gICAgICAgIGNvbnN0IHsgeWVhcjogaXNvWWVhciwgbW9udGg6IGlzb01vbnRoLCBkYXk6IGlzb0RheSB9ID0gaXNvRGF0ZTtcbiAgICAgICAgY29uc3Qga2V5ID0gSlNPTi5zdHJpbmdpZnkoeyBmdW5jOiAnaXNvVG9DYWxlbmRhckRhdGUnLCBpc29ZZWFyLCBpc29Nb250aCwgaXNvRGF5LCBpZDogdGhpcy5pZCB9KTtcbiAgICAgICAgY29uc3QgY2FjaGVkID0gY2FjaGUuZ2V0KGtleSk7XG4gICAgICAgIGlmIChjYWNoZWQpXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkO1xuICAgICAgICBjb25zdCBkYXRlVGltZUZvcm1hdCA9IHRoaXMuZ2V0Rm9ybWF0dGVyKCk7XG4gICAgICAgIGxldCBwYXJ0cywgaXNvU3RyaW5nO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaXNvU3RyaW5nID0gdG9VdGNJc29EYXRlU3RyaW5nKHsgaXNvWWVhciwgaXNvTW9udGgsIGlzb0RheSB9KTtcbiAgICAgICAgICAgIHBhcnRzID0gZGF0ZVRpbWVGb3JtYXQuZm9ybWF0VG9QYXJ0cyhuZXcgRGF0ZShpc29TdHJpbmcpKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYEludmFsaWQgSVNPIGRhdGU6ICR7SlNPTi5zdHJpbmdpZnkoeyBpc29ZZWFyLCBpc29Nb250aCwgaXNvRGF5IH0pfWApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgICAgICBmb3IgKGxldCB7IHR5cGUsIHZhbHVlIH0gb2YgcGFydHMpIHtcbiAgICAgICAgICAgIGlmICh0eXBlID09PSAneWVhcicpXG4gICAgICAgICAgICAgICAgcmVzdWx0LmVyYVllYXIgPSArdmFsdWU7XG4gICAgICAgICAgICAvLyBUT0RPOiByZW1vdmUgdGhpcyB0eXBlIGFubm90YXRpb24gd2hlbiBgcmVsYXRlZFllYXJgIGdldHMgaW50byBUUyBsaWIgdHlwZXNcbiAgICAgICAgICAgIGlmICh0eXBlID09PSAncmVsYXRlZFllYXInKVxuICAgICAgICAgICAgICAgIHJlc3VsdC5lcmFZZWFyID0gK3ZhbHVlO1xuICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdtb250aCcpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtYXRjaGVzID0gL14oWzAtOV0qKSguKj8pJC8uZXhlYyh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKCFtYXRjaGVzIHx8IG1hdGNoZXMubGVuZ3RoICE9IDMgfHwgKCFtYXRjaGVzWzFdICYmICFtYXRjaGVzWzJdKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgVW5leHBlY3RlZCBtb250aDogJHt2YWx1ZX1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIG1vbnRoIGhhcyBubyBudW1lcmljIHBhcnQgKHNob3VsZCBvbmx5IHNlZSB0aGlzIGZvciB0aGUgSGVicmV3XG4gICAgICAgICAgICAgICAgLy8gY2FsZW5kYXIgd2l0aCBuZXdlciBGRiAvIENocm9taXVtIHZlcnNpb25zOyBzZWVcbiAgICAgICAgICAgICAgICAvLyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0xNzUxODMzKSB0aGVuIHNldCBhXG4gICAgICAgICAgICAgICAgLy8gcGxhY2Vob2xkZXIgbW9udGggaW5kZXggb2YgYDFgIGFuZCByZWx5IG9uIHRoZSBkZXJpdmVkIGNsYXNzIHRvXG4gICAgICAgICAgICAgICAgLy8gY2FsY3VsYXRlIHRoZSBjb3JyZWN0IG1vbnRoIGluZGV4IGZyb20gdGhlIG1vbnRoIG5hbWUgc3RvcmVkIGluXG4gICAgICAgICAgICAgICAgLy8gYG1vbnRoRXh0cmFgLlxuICAgICAgICAgICAgICAgIHJlc3VsdC5tb250aCA9IG1hdGNoZXNbMV0gPyArbWF0Y2hlc1sxXSA6IDE7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5tb250aCA8IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYEludmFsaWQgbW9udGggJHt2YWx1ZX0gZnJvbSAke2lzb1N0cmluZ31bdS1jYS0ke3RoaXMuaWR9XWAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJyAocHJvYmFibHkgZHVlIHRvIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTEwNTI3KScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0Lm1vbnRoID4gMTMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYEludmFsaWQgbW9udGggJHt2YWx1ZX0gZnJvbSAke2lzb1N0cmluZ31bdS1jYS0ke3RoaXMuaWR9XWAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJyAocHJvYmFibHkgZHVlIHRvIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTEwNTI5KScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBUaGUgSUNVIGZvcm1hdHMgZm9yIHRoZSBIZWJyZXcgY2FsZW5kYXIgbm8gbG9uZ2VyIHN1cHBvcnQgYSBudW1lcmljXG4gICAgICAgICAgICAgICAgLy8gbW9udGggZm9ybWF0LiBTbyB3ZSdsbCByZWx5IG9uIHRoZSBkZXJpdmVkIGNsYXNzIHRvIGludGVycHJldCBpdC5cbiAgICAgICAgICAgICAgICAvLyBgbW9udGhFeHRyYWAgaXMgYWxzbyB1c2VkIG9uIHRoZSBDaGluZXNlIGNhbGVuZGFyIHRvIGhhbmRsZSBhIHN1ZmZpeFxuICAgICAgICAgICAgICAgIC8vIFwiYmlzXCIgaW5kaWNhdGluZyBhIGxlYXAgbW9udGguXG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoZXNbMl0pXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5tb250aEV4dHJhID0gbWF0Y2hlc1syXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlID09PSAnZGF5JylcbiAgICAgICAgICAgICAgICByZXN1bHQuZGF5ID0gK3ZhbHVlO1xuICAgICAgICAgICAgaWYgKHRoaXMuaGFzRXJhICYmIHR5cGUgPT09ICdlcmEnICYmIHZhbHVlICE9IG51bGwgJiYgdmFsdWUgIT09ICcnKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIGNvbnZlbnRpb24gZm9yIFRlbXBvcmFsIGVyYSB2YWx1ZXMgaXMgbG93ZXJjYXNlLCBzbyBmb2xsb3dpbmdcbiAgICAgICAgICAgICAgICAvLyB0aGF0IGNvbnZlbnRpb24gaW4gdGhpcyBwcm90b3R5cGUuIFB1bmN0dWF0aW9uIGlzIHJlbW92ZWQsIGFjY2VudGVkXG4gICAgICAgICAgICAgICAgLy8gbGV0dGVycyBhcmUgbm9ybWFsaXplZCwgYW5kIHNwYWNlcyBhcmUgcmVwbGFjZWQgd2l0aCBkYXNoZXMuXG4gICAgICAgICAgICAgICAgLy8gRS5nLjogXCJFUkEwXCIgPT4gXCJlcmEwXCIsIFwiQmVmb3JlIFIuTy5DLlwiID0+IFwiYmVmb3JlLXJvY1wiLCBcIkVu4oCZxY1cIiA9PiBcImVub1wiXG4gICAgICAgICAgICAgICAgLy8gVGhlIGNhbGwgdG8gbm9ybWFsaXplKCkgYW5kIHRoZSByZXBsYWNlbWVudCByZWdleCBkZWFscyB3aXRoIGVyYVxuICAgICAgICAgICAgICAgIC8vIG5hbWVzIHRoYXQgY29udGFpbiBub24tQVNDSUkgY2hhcmFjdGVycyBsaWtlIEphcGFuZXNlIGVyYXMuIEFsc29cbiAgICAgICAgICAgICAgICAvLyBpZ25vcmUgZXh0cmEgY29udGVudCBpbiBwYXJlbnRoZXNlcyBsaWtlIEpQTiBlcmEgZGF0ZSByYW5nZXMuXG4gICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5zcGxpdCgnICgnKVswXTtcbiAgICAgICAgICAgICAgICByZXN1bHQuZXJhID0gdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgLm5vcm1hbGl6ZSgnTkZEJylcbiAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1teLTAtOSBcXHB7TH1dL2d1LCAnJylcbiAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoJyAnLCAnLScpXG4gICAgICAgICAgICAgICAgICAgIC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQuZXJhWWVhciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBOb2RlIDEyIGhhcyBvdXRkYXRlZCBJQ1UgZGF0YSB0aGF0IGxhY2tzIHRoZSBgcmVsYXRlZFllYXJgIGZpZWxkIGluIHRoZVxuICAgICAgICAgICAgLy8gb3V0cHV0IG9mIEludGwuRGF0ZVRpbWVGb3JtYXQuZm9ybWF0VG9QYXJ0cy5cbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBJbnRsLkRhdGVUaW1lRm9ybWF0LmZvcm1hdFRvUGFydHMgbGFja3MgcmVsYXRlZFllYXIgaW4gJHt0aGlzLmlkfSBjYWxlbmRhci4gVHJ5IE5vZGUgMTQrIG9yIG1vZGVybiBicm93c2Vycy5gKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUcmFuc2xhdGUgZXJhcyB0aGF0IG1heSBiZSBoYW5kbGVkIGRpZmZlcmVudGx5IGJ5IFRlbXBvcmFsIHZzLiBieSBJbnRsXG4gICAgICAgIC8vIChlLmcuIEphcGFuZXNlIHByZS1NZWlqaSBlcmFzKS4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLXRlbXBvcmFsL2lzc3Vlcy81MjYuXG4gICAgICAgIGlmICh0aGlzLnJldmlzZUludGxFcmEpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgZXJhLCBlcmFZZWFyIH0gPSB0aGlzLnJldmlzZUludGxFcmEocmVzdWx0LCBpc29EYXRlKTtcbiAgICAgICAgICAgIHJlc3VsdC5lcmEgPSBlcmE7XG4gICAgICAgICAgICByZXN1bHQuZXJhWWVhciA9IGVyYVllYXI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY2hlY2tJY3VCdWdzKVxuICAgICAgICAgICAgdGhpcy5jaGVja0ljdUJ1Z3MoaXNvRGF0ZSk7XG4gICAgICAgIGNvbnN0IGNhbGVuZGFyRGF0ZSA9IHRoaXMuYWRqdXN0Q2FsZW5kYXJEYXRlKHJlc3VsdCwgY2FjaGUsICdjb25zdHJhaW4nLCB0cnVlKTtcbiAgICAgICAgaWYgKGNhbGVuZGFyRGF0ZS55ZWFyID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgTWlzc2luZyB5ZWFyIGNvbnZlcnRpbmcgJHtKU09OLnN0cmluZ2lmeShpc29EYXRlKX1gKTtcbiAgICAgICAgaWYgKGNhbGVuZGFyRGF0ZS5tb250aCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYE1pc3NpbmcgbW9udGggY29udmVydGluZyAke0pTT04uc3RyaW5naWZ5KGlzb0RhdGUpfWApO1xuICAgICAgICBpZiAoY2FsZW5kYXJEYXRlLmRheSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYE1pc3NpbmcgZGF5IGNvbnZlcnRpbmcgJHtKU09OLnN0cmluZ2lmeShpc29EYXRlKX1gKTtcbiAgICAgICAgY2FjaGUuc2V0KGtleSwgY2FsZW5kYXJEYXRlKTtcbiAgICAgICAgLy8gQWxzbyBjYWNoZSB0aGUgcmV2ZXJzZSBtYXBwaW5nXG4gICAgICAgIFsnY29uc3RyYWluJywgJ3JlamVjdCddLmZvckVhY2goKG92ZXJmbG93KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBrZXlSZXZlcnNlID0gSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgIGZ1bmM6ICdjYWxlbmRhclRvSXNvRGF0ZScsXG4gICAgICAgICAgICAgICAgeWVhcjogY2FsZW5kYXJEYXRlLnllYXIsXG4gICAgICAgICAgICAgICAgbW9udGg6IGNhbGVuZGFyRGF0ZS5tb250aCxcbiAgICAgICAgICAgICAgICBkYXk6IGNhbGVuZGFyRGF0ZS5kYXksXG4gICAgICAgICAgICAgICAgb3ZlcmZsb3csXG4gICAgICAgICAgICAgICAgaWQ6IHRoaXMuaWRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY2FjaGUuc2V0KGtleVJldmVyc2UsIGlzb0RhdGUpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGNhbGVuZGFyRGF0ZTtcbiAgICB9XG4gICAgdmFsaWRhdGVDYWxlbmRhckRhdGUoY2FsZW5kYXJEYXRlKSB7XG4gICAgICAgIGNvbnN0IHsgZXJhLCBtb250aCwgeWVhciwgZGF5LCBlcmFZZWFyLCBtb250aENvZGUsIG1vbnRoRXh0cmEgfSA9IGNhbGVuZGFyRGF0ZTtcbiAgICAgICAgLy8gV2hlbiB0aGVyZSdzIGEgc3VmZml4IChlLmcuIFwiNWJpc1wiIGZvciBhIGxlYXAgbW9udGggaW4gQ2hpbmVzZSBjYWxlbmRhcilcbiAgICAgICAgLy8gdGhlIGRlcml2ZWQgY2xhc3MgbXVzdCBkZWFsIHdpdGggaXQuXG4gICAgICAgIGlmIChtb250aEV4dHJhICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVW5leHBlY3RlZCBgbW9udGhFeHRyYWAgdmFsdWUnKTtcbiAgICAgICAgaWYgKHllYXIgPT09IHVuZGVmaW5lZCAmJiBlcmFZZWFyID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd5ZWFyIG9yIGVyYVllYXIgaXMgcmVxdWlyZWQnKTtcbiAgICAgICAgaWYgKG1vbnRoID09PSB1bmRlZmluZWQgJiYgbW9udGhDb2RlID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdtb250aCBvciBtb250aENvZGUgaXMgcmVxdWlyZWQnKTtcbiAgICAgICAgaWYgKGRheSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ01pc3NpbmcgZGF5Jyk7XG4gICAgICAgIGlmIChtb250aENvZGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBtb250aENvZGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYG1vbnRoQ29kZSBtdXN0IGJlIGEgc3RyaW5nLCBub3QgJHt0eXBlb2YgbW9udGhDb2RlfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCEvXk0oWzAxXT9cXGQpKEw/KSQvLnRlc3QobW9udGhDb2RlKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgSW52YWxpZCBtb250aENvZGU6ICR7bW9udGhDb2RlfWApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNvbnN0YW50RXJhKSB7XG4gICAgICAgICAgICBpZiAoZXJhICE9PSB1bmRlZmluZWQgJiYgZXJhICE9PSB0aGlzLmNvbnN0YW50RXJhKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYGVyYSBtdXN0IGJlICR7dGhpcy5jb25zdGFudEVyYX0sIG5vdCAke2VyYX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlcmFZZWFyICE9PSB1bmRlZmluZWQgJiYgeWVhciAhPT0gdW5kZWZpbmVkICYmIGVyYVllYXIgIT09IHllYXIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgZXJhWWVhciAke2VyYVllYXJ9IGRvZXMgbm90IG1hdGNoIHllYXIgJHt5ZWFyfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFsbG93cyBkZXJpdmVkIGNhbGVuZGFycyB0byBhZGQgYWRkaXRpb25hbCBmaWVsZHMgYW5kL29yIHRvIG1ha2VcbiAgICAgKiBhZGp1c3RtZW50cyBlLmcuIHRvIHNldCB0aGUgZXJhIGJhc2VkIG9uIHRoZSBkYXRlIG9yIHRvIHJldmlzZSB0aGUgbW9udGhcbiAgICAgKiBudW1iZXIgaW4gbHVuaXNvbGFyIGNhbGVuZGFycyBwZXJcbiAgICAgKiBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC10ZW1wb3JhbC9pc3N1ZXMvMTIwMy5cbiAgICAgKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIGZpbGxzIGluIG1pc3NpbmcgdmFsdWVzIGJ5IGFzc3VtaW5nIHRoZSBzaW1wbGVzdFxuICAgICAqIHBvc3NpYmxlIGNhbGVuZGFyOlxuICAgICAqIC0gbm8gZXJhcyBvciBhIGNvbnN0YW50IGVyYSBkZWZpbmVkIGluIGAuY29uc3RhbnRFcmFgXG4gICAgICogLSBub24tbHVuaXNvbGFyIGNhbGVuZGFyIChubyBsZWFwIG1vbnRocylcbiAgICAgKiAqL1xuICAgIGFkanVzdENhbGVuZGFyRGF0ZShjYWxlbmRhckRhdGVQYXJhbSwgY2FjaGUgPSB1bmRlZmluZWQsIG92ZXJmbG93ID0gJ2NvbnN0cmFpbicsIFxuICAgIC8vIFRoaXMgcGFyYW0gaXMgb25seSB1c2VkIGJ5IGRlcml2ZWQgY2xhc3Nlc1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICBmcm9tTGVnYWN5RGF0ZSA9IGZhbHNlKSB7XG4gICAgICAgIGlmICh0aGlzLmNhbGVuZGFyVHlwZSA9PT0gJ2x1bmlzb2xhcicpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignT3ZlcnJpZGUgcmVxdWlyZWQgZm9yIGx1bmlzb2xhciBjYWxlbmRhcnMnKTtcbiAgICAgICAgbGV0IGNhbGVuZGFyRGF0ZSA9IGNhbGVuZGFyRGF0ZVBhcmFtO1xuICAgICAgICB0aGlzLnZhbGlkYXRlQ2FsZW5kYXJEYXRlKGNhbGVuZGFyRGF0ZSk7XG4gICAgICAgIC8vIEZvciBjYWxlbmRhcnMgdGhhdCBhbHdheXMgdXNlIHRoZSBzYW1lIGVyYSwgc2V0IGl0IGhlcmUgc28gdGhhdCBkZXJpdmVkXG4gICAgICAgIC8vIGNhbGVuZGFycyB3b24ndCBuZWVkIHRvIGltcGxlbWVudCB0aGlzIG1ldGhvZCBzaW1wbHkgdG8gc2V0IHRoZSBlcmEuXG4gICAgICAgIGlmICh0aGlzLmNvbnN0YW50RXJhKSB7XG4gICAgICAgICAgICAvLyB5ZWFyIGFuZCBlcmFZZWFyIGFsd2F5cyBtYXRjaCB3aGVuIHRoZXJlJ3Mgb25seSBvbmUgcG9zc2libGUgZXJhXG4gICAgICAgICAgICBjb25zdCB7IHllYXIsIGVyYVllYXIgfSA9IGNhbGVuZGFyRGF0ZTtcbiAgICAgICAgICAgIGNhbGVuZGFyRGF0ZSA9IHtcbiAgICAgICAgICAgICAgICAuLi5jYWxlbmRhckRhdGUsXG4gICAgICAgICAgICAgICAgZXJhOiB0aGlzLmNvbnN0YW50RXJhLFxuICAgICAgICAgICAgICAgIHllYXI6IHllYXIgIT09IHVuZGVmaW5lZCA/IHllYXIgOiBlcmFZZWFyLFxuICAgICAgICAgICAgICAgIGVyYVllYXI6IGVyYVllYXIgIT09IHVuZGVmaW5lZCA/IGVyYVllYXIgOiB5ZWFyXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxhcmdlc3RNb250aCA9IHRoaXMubW9udGhzSW5ZZWFyKGNhbGVuZGFyRGF0ZSwgY2FjaGUpO1xuICAgICAgICBsZXQgeyBtb250aCwgbW9udGhDb2RlIH0gPSBjYWxlbmRhckRhdGU7XG4gICAgICAgICh7IG1vbnRoLCBtb250aENvZGUgfSA9IHJlc29sdmVOb25MdW5pc29sYXJNb250aChjYWxlbmRhckRhdGUsIG92ZXJmbG93LCBsYXJnZXN0TW9udGgpKTtcbiAgICAgICAgcmV0dXJuIHsgLi4uY2FsZW5kYXJEYXRlLCBtb250aCwgbW9udGhDb2RlIH07XG4gICAgfVxuICAgIHJlZ3VsYXRlTW9udGhEYXlOYWl2ZShjYWxlbmRhckRhdGUsIG92ZXJmbG93LCBjYWNoZSkge1xuICAgICAgICBjb25zdCBsYXJnZXN0TW9udGggPSB0aGlzLm1vbnRoc0luWWVhcihjYWxlbmRhckRhdGUsIGNhY2hlKTtcbiAgICAgICAgbGV0IHsgbW9udGgsIGRheSB9ID0gY2FsZW5kYXJEYXRlO1xuICAgICAgICBpZiAob3ZlcmZsb3cgPT09ICdyZWplY3QnKSB7XG4gICAgICAgICAgICBSZWplY3RUb1JhbmdlKG1vbnRoLCAxLCBsYXJnZXN0TW9udGgpO1xuICAgICAgICAgICAgUmVqZWN0VG9SYW5nZShkYXksIDEsIHRoaXMubWF4aW11bU1vbnRoTGVuZ3RoKGNhbGVuZGFyRGF0ZSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbW9udGggPSBDb25zdHJhaW5Ub1JhbmdlKG1vbnRoLCAxLCBsYXJnZXN0TW9udGgpO1xuICAgICAgICAgICAgZGF5ID0gQ29uc3RyYWluVG9SYW5nZShkYXksIDEsIHRoaXMubWF4aW11bU1vbnRoTGVuZ3RoKHsgLi4uY2FsZW5kYXJEYXRlLCBtb250aCB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgLi4uY2FsZW5kYXJEYXRlLCBtb250aCwgZGF5IH07XG4gICAgfVxuICAgIGNhbGVuZGFyVG9Jc29EYXRlKGRhdGVQYXJhbSwgb3ZlcmZsb3cgPSAnY29uc3RyYWluJywgY2FjaGUpIHtcbiAgICAgICAgY29uc3Qgb3JpZ2luYWxEYXRlID0gZGF0ZVBhcmFtO1xuICAgICAgICAvLyBGaXJzdCwgbm9ybWFsaXplIHRoZSBjYWxlbmRhciBkYXRlIHRvIGVuc3VyZSB0aGF0ICh5ZWFyLCBtb250aCwgZGF5KVxuICAgICAgICAvLyBhcmUgYWxsIHByZXNlbnQsIGNvbnZlcnRpbmcgbW9udGhDb2RlIGFuZCBlcmFZZWFyIGlmIG5lZWRlZC5cbiAgICAgICAgbGV0IGRhdGUgPSB0aGlzLmFkanVzdENhbGVuZGFyRGF0ZShkYXRlUGFyYW0sIGNhY2hlLCBvdmVyZmxvdywgZmFsc2UpO1xuICAgICAgICAvLyBGaXggb2J2aW91c2x5IG91dC1vZi1ib3VuZHMgdmFsdWVzLiBWYWx1ZXMgdGhhdCBhcmUgdmFsaWQgZ2VuZXJhbGx5LCBidXRcbiAgICAgICAgLy8gbm90IGluIHRoaXMgcGFydGljdWxhciB5ZWFyLCBtYXkgbm90IGJlIGNhdWdodCBoZXJlIGZvciBzb21lIGNhbGVuZGFycy5cbiAgICAgICAgLy8gSWYgc28sIHRoZXNlIHdpbGwgYmUgaGFuZGxlZCBsb3dlciBiZWxvdy5cbiAgICAgICAgZGF0ZSA9IHRoaXMucmVndWxhdGVNb250aERheU5haXZlKGRhdGUsIG92ZXJmbG93LCBjYWNoZSk7XG4gICAgICAgIGNvbnN0IHsgeWVhciwgbW9udGgsIGRheSB9ID0gZGF0ZTtcbiAgICAgICAgY29uc3Qga2V5ID0gSlNPTi5zdHJpbmdpZnkoeyBmdW5jOiAnY2FsZW5kYXJUb0lzb0RhdGUnLCB5ZWFyLCBtb250aCwgZGF5LCBvdmVyZmxvdywgaWQ6IHRoaXMuaWQgfSk7XG4gICAgICAgIGxldCBjYWNoZWQgPSBjYWNoZS5nZXQoa2V5KTtcbiAgICAgICAgaWYgKGNhY2hlZClcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWQ7XG4gICAgICAgIC8vIElmIFlNRCBhcmUgcHJlc2VudCBpbiB0aGUgaW5wdXQgYnV0IHRoZSBpbnB1dCBoYXMgYmVlbiBjb25zdHJhaW5lZFxuICAgICAgICAvLyBhbHJlYWR5LCB0aGVuIGNhY2hlIGJvdGggdGhlIG9yaWdpbmFsIHZhbHVlIGFuZCB0aGUgY29uc3RyYWluZWQgdmFsdWUuXG4gICAgICAgIGxldCBrZXlPcmlnaW5hbDtcbiAgICAgICAgaWYgKG9yaWdpbmFsRGF0ZS55ZWFyICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIG9yaWdpbmFsRGF0ZS5tb250aCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICBvcmlnaW5hbERhdGUuZGF5ICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvcmlnaW5hbERhdGUueWVhciAhPT0gZGF0ZS55ZWFyIHx8IG9yaWdpbmFsRGF0ZS5tb250aCAhPT0gZGF0ZS5tb250aCB8fCBvcmlnaW5hbERhdGUuZGF5ICE9PSBkYXRlLmRheSkpIHtcbiAgICAgICAgICAgIGtleU9yaWdpbmFsID0gSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgIGZ1bmM6ICdjYWxlbmRhclRvSXNvRGF0ZScsXG4gICAgICAgICAgICAgICAgeWVhcjogb3JpZ2luYWxEYXRlLnllYXIsXG4gICAgICAgICAgICAgICAgbW9udGg6IG9yaWdpbmFsRGF0ZS5tb250aCxcbiAgICAgICAgICAgICAgICBkYXk6IG9yaWdpbmFsRGF0ZS5kYXksXG4gICAgICAgICAgICAgICAgb3ZlcmZsb3csXG4gICAgICAgICAgICAgICAgaWQ6IHRoaXMuaWRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY2FjaGVkID0gY2FjaGUuZ2V0KGtleU9yaWdpbmFsKTtcbiAgICAgICAgICAgIGlmIChjYWNoZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhY2hlZDtcbiAgICAgICAgfVxuICAgICAgICAvLyBGaXJzdCwgdHJ5IHRvIHJvdWdobHkgZ3Vlc3MgdGhlIHJlc3VsdFxuICAgICAgICBsZXQgaXNvRXN0aW1hdGUgPSB0aGlzLmVzdGltYXRlSXNvRGF0ZSh7IHllYXIsIG1vbnRoLCBkYXkgfSk7XG4gICAgICAgIGNvbnN0IGNhbGN1bGF0ZVNhbWVNb250aFJlc3VsdCA9IChkaWZmRGF5cykgPT4ge1xuICAgICAgICAgICAgLy8gSWYgdGhlIGVzdGltYXRlIGlzIGluIHRoZSBzYW1lIHllYXIgJiBtb250aCBhcyB0aGUgdGFyZ2V0LCB0aGVuIHdlIGNhblxuICAgICAgICAgICAgLy8gY2FsY3VsYXRlIHRoZSByZXN1bHQgZXhhY3RseSBhbmQgc2hvcnQtY2lyY3VpdCBhbnkgYWRkaXRpb25hbCBsb2dpYy5cbiAgICAgICAgICAgIC8vIFRoaXMgb3B0aW1pemF0aW9uIGFzc3VtZXMgdGhhdCBtb250aHMgYXJlIGNvbnRpbnVvdXMuIEl0IHdvdWxkIGJyZWFrIGlmXG4gICAgICAgICAgICAvLyBhIGNhbGVuZGFyIHNraXBwZWQgZGF5cywgbGlrZSB0aGUgSnVsaWFuLT5HcmVnb3JpYW4gc3dpdGNob3Zlci4gQnV0IHRoZVxuICAgICAgICAgICAgLy8gb25seSBJQ1UgY2FsZW5kYXJzIHRoYXQgY3VycmVudGx5IHNraXAgZGF5cyAoamFwYW5lc2Uvcm9jL2J1ZGRoaXN0KSBpc1xuICAgICAgICAgICAgLy8gYSBidWcgKGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTExNzMxNTgpXG4gICAgICAgICAgICAvLyB0aGF0J3MgY3VycmVudGx5IGRldGVjdGVkIGJ5IGBjaGVja0ljdUJ1Z3MoKWAgd2hpY2ggd2lsbCB0aHJvdy4gU29cbiAgICAgICAgICAgIC8vIHRoaXMgb3B0aW1pemF0aW9uIHNob3VsZCBiZSBzYWZlIGZvciBhbGwgSUNVIGNhbGVuZGFycy5cbiAgICAgICAgICAgIGxldCB0ZXN0SXNvRXN0aW1hdGUgPSB0aGlzLmFkZERheXNJc28oaXNvRXN0aW1hdGUsIGRpZmZEYXlzKTtcbiAgICAgICAgICAgIGlmIChkYXRlLmRheSA+IHRoaXMubWluaW11bU1vbnRoTGVuZ3RoKGRhdGUpKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlcmUncyBhIGNoYW5jZSB0aGF0IHRoZSBjYWxlbmRhciBkYXRlIGlzIG91dCBvZiByYW5nZS4gVGhyb3cgb3JcbiAgICAgICAgICAgICAgICAvLyBjb25zdHJhaW4gaWYgc28uXG4gICAgICAgICAgICAgICAgbGV0IHRlc3RDYWxlbmRhckRhdGUgPSB0aGlzLmlzb1RvQ2FsZW5kYXJEYXRlKHRlc3RJc29Fc3RpbWF0ZSwgY2FjaGUpO1xuICAgICAgICAgICAgICAgIHdoaWxlICh0ZXN0Q2FsZW5kYXJEYXRlLm1vbnRoICE9PSBtb250aCB8fCB0ZXN0Q2FsZW5kYXJEYXRlLnllYXIgIT09IHllYXIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG92ZXJmbG93ID09PSAncmVqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYGRheSAke2RheX0gZG9lcyBub3QgZXhpc3QgaW4gbW9udGggJHttb250aH0gb2YgeWVhciAke3llYXJ9YCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gQmFjayB1cCBhIGRheSBhdCBhIHRpbWUgdW50aWwgd2UncmUgbm90IGhhbmdpbmcgb3ZlciB0aGUgbW9udGggZW5kXG4gICAgICAgICAgICAgICAgICAgIHRlc3RJc29Fc3RpbWF0ZSA9IHRoaXMuYWRkRGF5c0lzbyh0ZXN0SXNvRXN0aW1hdGUsIC0xKTtcbiAgICAgICAgICAgICAgICAgICAgdGVzdENhbGVuZGFyRGF0ZSA9IHRoaXMuaXNvVG9DYWxlbmRhckRhdGUodGVzdElzb0VzdGltYXRlLCBjYWNoZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRlc3RJc29Fc3RpbWF0ZTtcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IHNpZ24gPSAwO1xuICAgICAgICBsZXQgcm91bmR0cmlwRXN0aW1hdGUgPSB0aGlzLmlzb1RvQ2FsZW5kYXJEYXRlKGlzb0VzdGltYXRlLCBjYWNoZSk7XG4gICAgICAgIGxldCBkaWZmID0gc2ltcGxlRGF0ZURpZmYoZGF0ZSwgcm91bmR0cmlwRXN0aW1hdGUpO1xuICAgICAgICBpZiAoZGlmZi55ZWFycyAhPT0gMCB8fCBkaWZmLm1vbnRocyAhPT0gMCB8fCBkaWZmLmRheXMgIT09IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGRpZmZUb3RhbERheXNFc3RpbWF0ZSA9IGRpZmYueWVhcnMgKiAzNjUgKyBkaWZmLm1vbnRocyAqIDMwICsgZGlmZi5kYXlzO1xuICAgICAgICAgICAgaXNvRXN0aW1hdGUgPSB0aGlzLmFkZERheXNJc28oaXNvRXN0aW1hdGUsIGRpZmZUb3RhbERheXNFc3RpbWF0ZSk7XG4gICAgICAgICAgICByb3VuZHRyaXBFc3RpbWF0ZSA9IHRoaXMuaXNvVG9DYWxlbmRhckRhdGUoaXNvRXN0aW1hdGUsIGNhY2hlKTtcbiAgICAgICAgICAgIGRpZmYgPSBzaW1wbGVEYXRlRGlmZihkYXRlLCByb3VuZHRyaXBFc3RpbWF0ZSk7XG4gICAgICAgICAgICBpZiAoZGlmZi55ZWFycyA9PT0gMCAmJiBkaWZmLm1vbnRocyA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGlzb0VzdGltYXRlID0gY2FsY3VsYXRlU2FtZU1vbnRoUmVzdWx0KGRpZmYuZGF5cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzaWduID0gdGhpcy5jb21wYXJlQ2FsZW5kYXJEYXRlcyhkYXRlLCByb3VuZHRyaXBFc3RpbWF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGhlIGluaXRpYWwgZ3Vlc3MgaXMgbm90IGluIHRoZSBzYW1lIG1vbnRoLCB0aGVuIHRoZW4gYmlzZWN0IHRoZVxuICAgICAgICAvLyBkaXN0YW5jZSB0byB0aGUgdGFyZ2V0LCBzdGFydGluZyB3aXRoIDggZGF5cyBwZXIgc3RlcC5cbiAgICAgICAgbGV0IGluY3JlbWVudCA9IDg7XG4gICAgICAgIGxldCBtYXliZUNvbnN0cmFpbmVkID0gZmFsc2U7XG4gICAgICAgIHdoaWxlIChzaWduKSB7XG4gICAgICAgICAgICBpc29Fc3RpbWF0ZSA9IHRoaXMuYWRkRGF5c0lzbyhpc29Fc3RpbWF0ZSwgc2lnbiAqIGluY3JlbWVudCk7XG4gICAgICAgICAgICBjb25zdCBvbGRSb3VuZHRyaXBFc3RpbWF0ZSA9IHJvdW5kdHJpcEVzdGltYXRlO1xuICAgICAgICAgICAgcm91bmR0cmlwRXN0aW1hdGUgPSB0aGlzLmlzb1RvQ2FsZW5kYXJEYXRlKGlzb0VzdGltYXRlLCBjYWNoZSk7XG4gICAgICAgICAgICBjb25zdCBvbGRTaWduID0gc2lnbjtcbiAgICAgICAgICAgIHNpZ24gPSB0aGlzLmNvbXBhcmVDYWxlbmRhckRhdGVzKGRhdGUsIHJvdW5kdHJpcEVzdGltYXRlKTtcbiAgICAgICAgICAgIGlmIChzaWduKSB7XG4gICAgICAgICAgICAgICAgZGlmZiA9IHNpbXBsZURhdGVEaWZmKGRhdGUsIHJvdW5kdHJpcEVzdGltYXRlKTtcbiAgICAgICAgICAgICAgICBpZiAoZGlmZi55ZWFycyA9PT0gMCAmJiBkaWZmLm1vbnRocyA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBpc29Fc3RpbWF0ZSA9IGNhbGN1bGF0ZVNhbWVNb250aFJlc3VsdChkaWZmLmRheXMpO1xuICAgICAgICAgICAgICAgICAgICAvLyBTaWduYWwgdGhlIGxvb3AgY29uZGl0aW9uIHRoYXQgdGhlcmUncyBhIG1hdGNoLlxuICAgICAgICAgICAgICAgICAgICBzaWduID0gMDtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIGNhbGVuZGFyIGRheSBpcyBsYXJnZXIgdGhhbiB0aGUgbWluaW1hbCBsZW5ndGggZm9yIHRoaXNcbiAgICAgICAgICAgICAgICAgICAgLy8gbW9udGgsIHRoZW4gaXQgbWlnaHQgYmUgbGFyZ2VyIHRoYW4gdGhlIGFjdHVhbCBsZW5ndGggb2YgdGhlIG1vbnRoLlxuICAgICAgICAgICAgICAgICAgICAvLyBTbyB3ZSB3b24ndCBjYWNoZSBpdCBhcyB0aGUgY29ycmVjdCBjYWxlbmRhciBkYXRlIGZvciB0aGlzIElTT1xuICAgICAgICAgICAgICAgICAgICAvLyBkYXRlLlxuICAgICAgICAgICAgICAgICAgICBtYXliZUNvbnN0cmFpbmVkID0gZGF0ZS5kYXkgPiB0aGlzLm1pbmltdW1Nb250aExlbmd0aChkYXRlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAob2xkU2lnbiAmJiBzaWduICE9PSBvbGRTaWduKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmNyZW1lbnQgPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgZXN0aW1hdGUgb3ZlcnNob3QgdGhlIHRhcmdldCwgdHJ5IGFnYWluIHdpdGggYSBzbWFsbGVyIGluY3JlbWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW4gdGhlIHJldmVyc2UgZGlyZWN0aW9uLlxuICAgICAgICAgICAgICAgICAgICAgICAgaW5jcmVtZW50IC89IDI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJbmNyZW1lbnQgaXMgMSwgYW5kIG5laXRoZXIgdGhlIHByZXZpb3VzIGVzdGltYXRlIG5vciB0aGUgbmV3XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBlc3RpbWF0ZSBpcyBjb3JyZWN0LiBUaGUgb25seSB3YXkgdGhhdCBjYW4gaGFwcGVuIGlzIGlmIHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gb3JpZ2luYWwgZGF0ZSB3YXMgYW4gaW52YWxpZCB2YWx1ZSB0aGF0IHdpbGwgYmUgY29uc3RyYWluZWQgb3JcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlamVjdGVkIGhlcmUuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3ZlcmZsb3cgPT09ICdyZWplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYENhbid0IGZpbmQgSVNPIGRhdGUgZnJvbSBjYWxlbmRhciBkYXRlOiAke0pTT04uc3RyaW5naWZ5KHsgLi4ub3JpZ2luYWxEYXRlIH0pfWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVG8gY29uc3RyYWluLCBwaWNrIHRoZSBlYXJsaWVzdCB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG9yZGVyID0gdGhpcy5jb21wYXJlQ2FsZW5kYXJEYXRlcyhyb3VuZHRyaXBFc3RpbWF0ZSwgb2xkUm91bmR0cmlwRXN0aW1hdGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIGN1cnJlbnQgdmFsdWUgaXMgbGFyZ2VyLCB0aGVuIGJhY2sgdXAgdG8gdGhlIHByZXZpb3VzIHZhbHVlLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcmRlciA+IDApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzb0VzdGltYXRlID0gdGhpcy5hZGREYXlzSXNvKGlzb0VzdGltYXRlLCAtMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF5YmVDb25zdHJhaW5lZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2lnbiA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2FjaGUuc2V0KGtleSwgaXNvRXN0aW1hdGUpO1xuICAgICAgICBpZiAoa2V5T3JpZ2luYWwpXG4gICAgICAgICAgICBjYWNoZS5zZXQoa2V5T3JpZ2luYWwsIGlzb0VzdGltYXRlKTtcbiAgICAgICAgaWYgKGRhdGUueWVhciA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICBkYXRlLm1vbnRoID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgIGRhdGUuZGF5ID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgIGRhdGUubW9udGhDb2RlID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgICh0aGlzLmhhc0VyYSAmJiAoZGF0ZS5lcmEgPT09IHVuZGVmaW5lZCB8fCBkYXRlLmVyYVllYXIgPT09IHVuZGVmaW5lZCkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVW5leHBlY3RlZCBtaXNzaW5nIHByb3BlcnR5Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFtYXliZUNvbnN0cmFpbmVkKSB7XG4gICAgICAgICAgICAvLyBBbHNvIGNhY2hlIHRoZSByZXZlcnNlIG1hcHBpbmdcbiAgICAgICAgICAgIGNvbnN0IGtleVJldmVyc2UgPSBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgICAgZnVuYzogJ2lzb1RvQ2FsZW5kYXJEYXRlJyxcbiAgICAgICAgICAgICAgICBpc29ZZWFyOiBpc29Fc3RpbWF0ZS55ZWFyLFxuICAgICAgICAgICAgICAgIGlzb01vbnRoOiBpc29Fc3RpbWF0ZS5tb250aCxcbiAgICAgICAgICAgICAgICBpc29EYXk6IGlzb0VzdGltYXRlLmRheSxcbiAgICAgICAgICAgICAgICBpZDogdGhpcy5pZFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjYWNoZS5zZXQoa2V5UmV2ZXJzZSwgZGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlzb0VzdGltYXRlO1xuICAgIH1cbiAgICB0ZW1wb3JhbFRvQ2FsZW5kYXJEYXRlKGRhdGUsIGNhY2hlKSB7XG4gICAgICAgIGNvbnN0IGlzb0RhdGUgPSB7IHllYXI6IEdldFNsb3QoZGF0ZSwgSVNPX1lFQVIpLCBtb250aDogR2V0U2xvdChkYXRlLCBJU09fTU9OVEgpLCBkYXk6IEdldFNsb3QoZGF0ZSwgSVNPX0RBWSkgfTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5pc29Ub0NhbGVuZGFyRGF0ZShpc29EYXRlLCBjYWNoZSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGNvbXBhcmVDYWxlbmRhckRhdGVzKGRhdGUxUGFyYW0sIGRhdGUyUGFyYW0pIHtcbiAgICAgICAgLy8gYGRhdGUxYCBhbmQgYGRhdGUyYCBhcmUgYWxyZWFkeSByZWNvcmRzLiBUaGUgY2FsbHMgYmVsb3cgc2ltcGx5IHZhbGlkYXRlXG4gICAgICAgIC8vIHRoYXQgYWxsIHRocmVlIHJlcXVpcmVkIGZpZWxkcyBhcmUgcHJlc2VudC5cbiAgICAgICAgY29uc3QgZGF0ZTEgPSBQcmVwYXJlVGVtcG9yYWxGaWVsZHMoZGF0ZTFQYXJhbSwgW1snZGF5J10sIFsnbW9udGgnXSwgWyd5ZWFyJ11dKTtcbiAgICAgICAgY29uc3QgZGF0ZTIgPSBQcmVwYXJlVGVtcG9yYWxGaWVsZHMoZGF0ZTJQYXJhbSwgW1snZGF5J10sIFsnbW9udGgnXSwgWyd5ZWFyJ11dKTtcbiAgICAgICAgaWYgKGRhdGUxLnllYXIgIT09IGRhdGUyLnllYXIpXG4gICAgICAgICAgICByZXR1cm4gQ29tcGFyaXNvblJlc3VsdChkYXRlMS55ZWFyIC0gZGF0ZTIueWVhcik7XG4gICAgICAgIGlmIChkYXRlMS5tb250aCAhPT0gZGF0ZTIubW9udGgpXG4gICAgICAgICAgICByZXR1cm4gQ29tcGFyaXNvblJlc3VsdChkYXRlMS5tb250aCAtIGRhdGUyLm1vbnRoKTtcbiAgICAgICAgaWYgKGRhdGUxLmRheSAhPT0gZGF0ZTIuZGF5KVxuICAgICAgICAgICAgcmV0dXJuIENvbXBhcmlzb25SZXN1bHQoZGF0ZTEuZGF5IC0gZGF0ZTIuZGF5KTtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIC8qKiBFbnN1cmUgdGhhdCBhIGNhbGVuZGFyIGRhdGUgYWN0dWFsbHkgZXhpc3RzLiBJZiBub3QsIHJldHVybiB0aGUgY2xvc2VzdCBlYXJsaWVyIGRhdGUuICovXG4gICAgcmVndWxhdGVEYXRlKGNhbGVuZGFyRGF0ZSwgb3ZlcmZsb3cgPSAnY29uc3RyYWluJywgY2FjaGUpIHtcbiAgICAgICAgY29uc3QgaXNvRGF0ZSA9IHRoaXMuY2FsZW5kYXJUb0lzb0RhdGUoY2FsZW5kYXJEYXRlLCBvdmVyZmxvdywgY2FjaGUpO1xuICAgICAgICByZXR1cm4gdGhpcy5pc29Ub0NhbGVuZGFyRGF0ZShpc29EYXRlLCBjYWNoZSk7XG4gICAgfVxuICAgIGFkZERheXNJc28oaXNvRGF0ZSwgZGF5cykge1xuICAgICAgICBjb25zdCBhZGRlZCA9IEFkZElTT0RhdGUoaXNvRGF0ZS55ZWFyLCBpc29EYXRlLm1vbnRoLCBpc29EYXRlLmRheSwgMCwgMCwgMCwgZGF5cywgJ2NvbnN0cmFpbicpO1xuICAgICAgICByZXR1cm4gYWRkZWQ7XG4gICAgfVxuICAgIGFkZERheXNDYWxlbmRhcihjYWxlbmRhckRhdGUsIGRheXMsIGNhY2hlKSB7XG4gICAgICAgIGNvbnN0IGlzb0RhdGUgPSB0aGlzLmNhbGVuZGFyVG9Jc29EYXRlKGNhbGVuZGFyRGF0ZSwgJ2NvbnN0cmFpbicsIGNhY2hlKTtcbiAgICAgICAgY29uc3QgYWRkZWRJc28gPSB0aGlzLmFkZERheXNJc28oaXNvRGF0ZSwgZGF5cyk7XG4gICAgICAgIGNvbnN0IGFkZGVkQ2FsZW5kYXIgPSB0aGlzLmlzb1RvQ2FsZW5kYXJEYXRlKGFkZGVkSXNvLCBjYWNoZSk7XG4gICAgICAgIHJldHVybiBhZGRlZENhbGVuZGFyO1xuICAgIH1cbiAgICBhZGRNb250aHNDYWxlbmRhcihjYWxlbmRhckRhdGVQYXJhbSwgbW9udGhzLCBvdmVyZmxvdywgY2FjaGUpIHtcbiAgICAgICAgbGV0IGNhbGVuZGFyRGF0ZSA9IGNhbGVuZGFyRGF0ZVBhcmFtO1xuICAgICAgICBjb25zdCB7IGRheSB9ID0gY2FsZW5kYXJEYXRlO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgYWJzTW9udGhzID0gTWF0aEFicyQxKG1vbnRocyk7IGkgPCBhYnNNb250aHM7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgeyBtb250aCB9ID0gY2FsZW5kYXJEYXRlO1xuICAgICAgICAgICAgY29uc3Qgb2xkQ2FsZW5kYXJEYXRlID0gY2FsZW5kYXJEYXRlO1xuICAgICAgICAgICAgY29uc3QgZGF5cyA9IG1vbnRocyA8IDBcbiAgICAgICAgICAgICAgICA/IC1NYXRoLm1heChkYXksIHRoaXMuZGF5c0luUHJldmlvdXNNb250aChjYWxlbmRhckRhdGUsIGNhY2hlKSlcbiAgICAgICAgICAgICAgICA6IHRoaXMuZGF5c0luTW9udGgoY2FsZW5kYXJEYXRlLCBjYWNoZSk7XG4gICAgICAgICAgICBjb25zdCBpc29EYXRlID0gdGhpcy5jYWxlbmRhclRvSXNvRGF0ZShjYWxlbmRhckRhdGUsICdjb25zdHJhaW4nLCBjYWNoZSk7XG4gICAgICAgICAgICBsZXQgYWRkZWRJc28gPSB0aGlzLmFkZERheXNJc28oaXNvRGF0ZSwgZGF5cyk7XG4gICAgICAgICAgICBjYWxlbmRhckRhdGUgPSB0aGlzLmlzb1RvQ2FsZW5kYXJEYXRlKGFkZGVkSXNvLCBjYWNoZSk7XG4gICAgICAgICAgICAvLyBOb3JtYWxseSwgd2UgY2FuIGFkdmFuY2Ugb25lIG1vbnRoIGJ5IGFkZGluZyB0aGUgbnVtYmVyIG9mIGRheXMgaW4gdGhlXG4gICAgICAgICAgICAvLyBjdXJyZW50IG1vbnRoLiBIb3dldmVyLCBpZiB3ZSdyZSBhdCB0aGUgZW5kIG9mIHRoZSBjdXJyZW50IG1vbnRoIGFuZFxuICAgICAgICAgICAgLy8gdGhlIG5leHQgbW9udGggaGFzIGZld2VyIGRheXMsIHRoZW4gd2Ugcm9sbGVkIG92ZXIgdG8gdGhlIGFmdGVyLW5leHRcbiAgICAgICAgICAgIC8vIG1vbnRoLiBCZWxvdyB3ZSBkZXRlY3QgdGhpcyBjb25kaXRpb24gYW5kIGJhY2sgdXAgdW50aWwgd2UncmUgYmFjayBpblxuICAgICAgICAgICAgLy8gdGhlIGRlc2lyZWQgbW9udGguXG4gICAgICAgICAgICBpZiAobW9udGhzID4gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1vbnRoc0luT2xkWWVhciA9IHRoaXMubW9udGhzSW5ZZWFyKG9sZENhbGVuZGFyRGF0ZSwgY2FjaGUpO1xuICAgICAgICAgICAgICAgIHdoaWxlIChjYWxlbmRhckRhdGUubW9udGggLSAxICE9PSBtb250aCAlIG1vbnRoc0luT2xkWWVhcikge1xuICAgICAgICAgICAgICAgICAgICBhZGRlZElzbyA9IHRoaXMuYWRkRGF5c0lzbyhhZGRlZElzbywgLTEpO1xuICAgICAgICAgICAgICAgICAgICBjYWxlbmRhckRhdGUgPSB0aGlzLmlzb1RvQ2FsZW5kYXJEYXRlKGFkZGVkSXNvLCBjYWNoZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNhbGVuZGFyRGF0ZS5kYXkgIT09IGRheSkge1xuICAgICAgICAgICAgICAgIC8vIHRyeSB0byByZXRhaW4gdGhlIG9yaWdpbmFsIGRheS1vZi1tb250aCwgaWYgcG9zc2libGVcbiAgICAgICAgICAgICAgICBjYWxlbmRhckRhdGUgPSB0aGlzLnJlZ3VsYXRlRGF0ZSh7IC4uLmNhbGVuZGFyRGF0ZSwgZGF5IH0sICdjb25zdHJhaW4nLCBjYWNoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG92ZXJmbG93ID09PSAncmVqZWN0JyAmJiBjYWxlbmRhckRhdGUuZGF5ICE9PSBkYXkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBEYXkgJHtkYXl9IGRvZXMgbm90IGV4aXN0IGluIHJlc3VsdGluZyBjYWxlbmRhciBtb250aGApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjYWxlbmRhckRhdGU7XG4gICAgfVxuICAgIGFkZENhbGVuZGFyKGNhbGVuZGFyRGF0ZSwgeyB5ZWFycyA9IDAsIG1vbnRocyA9IDAsIHdlZWtzID0gMCwgZGF5cyA9IDAgfSwgb3ZlcmZsb3csIGNhY2hlKSB7XG4gICAgICAgIGNvbnN0IHsgeWVhciwgbW9udGgsIGRheSB9ID0gY2FsZW5kYXJEYXRlO1xuICAgICAgICBjb25zdCBhZGRlZE1vbnRocyA9IHRoaXMuYWRkTW9udGhzQ2FsZW5kYXIoeyB5ZWFyOiB5ZWFyICsgeWVhcnMsIG1vbnRoLCBkYXkgfSwgbW9udGhzLCBvdmVyZmxvdywgY2FjaGUpO1xuICAgICAgICBjb25zdCBpbml0aWFsRGF5cyA9IGRheXMgKyB3ZWVrcyAqIDc7XG4gICAgICAgIGNvbnN0IGFkZGVkRGF5cyA9IHRoaXMuYWRkRGF5c0NhbGVuZGFyKGFkZGVkTW9udGhzLCBpbml0aWFsRGF5cywgY2FjaGUpO1xuICAgICAgICByZXR1cm4gYWRkZWREYXlzO1xuICAgIH1cbiAgICB1bnRpbENhbGVuZGFyKGNhbGVuZGFyT25lLCBjYWxlbmRhclR3bywgbGFyZ2VzdFVuaXQsIGNhY2hlKSB7XG4gICAgICAgIGxldCBkYXlzID0gMDtcbiAgICAgICAgbGV0IHdlZWtzID0gMDtcbiAgICAgICAgbGV0IG1vbnRocyA9IDA7XG4gICAgICAgIGxldCB5ZWFycyA9IDA7XG4gICAgICAgIHN3aXRjaCAobGFyZ2VzdFVuaXQpIHtcbiAgICAgICAgICAgIGNhc2UgJ2RheSc6XG4gICAgICAgICAgICAgICAgZGF5cyA9IHRoaXMuY2FsZW5kYXJEYXlzVW50aWwoY2FsZW5kYXJPbmUsIGNhbGVuZGFyVHdvLCBjYWNoZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICd3ZWVrJzoge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRvdGFsRGF5cyA9IHRoaXMuY2FsZW5kYXJEYXlzVW50aWwoY2FsZW5kYXJPbmUsIGNhbGVuZGFyVHdvLCBjYWNoZSk7XG4gICAgICAgICAgICAgICAgZGF5cyA9IHRvdGFsRGF5cyAlIDc7XG4gICAgICAgICAgICAgICAgd2Vla3MgPSAodG90YWxEYXlzIC0gZGF5cykgLyA3O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnbW9udGgnOlxuICAgICAgICAgICAgY2FzZSAneWVhcic6IHtcbiAgICAgICAgICAgICAgICBjb25zdCBkaWZmWWVhcnMgPSBjYWxlbmRhclR3by55ZWFyIC0gY2FsZW5kYXJPbmUueWVhcjtcbiAgICAgICAgICAgICAgICBjb25zdCBkaWZmTW9udGhzID0gY2FsZW5kYXJUd28ubW9udGggLSBjYWxlbmRhck9uZS5tb250aDtcbiAgICAgICAgICAgICAgICBjb25zdCBkaWZmRGF5cyA9IGNhbGVuZGFyVHdvLmRheSAtIGNhbGVuZGFyT25lLmRheTtcbiAgICAgICAgICAgICAgICBjb25zdCBzaWduID0gdGhpcy5jb21wYXJlQ2FsZW5kYXJEYXRlcyhjYWxlbmRhclR3bywgY2FsZW5kYXJPbmUpO1xuICAgICAgICAgICAgICAgIGlmIChsYXJnZXN0VW5pdCA9PT0gJ3llYXInICYmIGRpZmZZZWFycykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpc09uZUZ1cnRoZXJJblllYXIgPSBkaWZmTW9udGhzICogc2lnbiA8IDAgfHwgKGRpZmZNb250aHMgPT09IDAgJiYgZGlmZkRheXMgKiBzaWduIDwgMCk7XG4gICAgICAgICAgICAgICAgICAgIHllYXJzID0gaXNPbmVGdXJ0aGVySW5ZZWFyID8gZGlmZlllYXJzIC0gc2lnbiA6IGRpZmZZZWFycztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgeWVhcnNBZGRlZCA9IHllYXJzID8gdGhpcy5hZGRDYWxlbmRhcihjYWxlbmRhck9uZSwgeyB5ZWFycyB9LCAnY29uc3RyYWluJywgY2FjaGUpIDogY2FsZW5kYXJPbmU7XG4gICAgICAgICAgICAgICAgLy8gTm93IHdlIGhhdmUgbGVzcyB0aGFuIG9uZSB5ZWFyIHJlbWFpbmluZy4gQWRkIG9uZSBtb250aCBhdCBhIHRpbWVcbiAgICAgICAgICAgICAgICAvLyB1bnRpbCB3ZSBnbyBvdmVyIHRoZSB0YXJnZXQsIHRoZW4gYmFjayB1cCBvbmUgbW9udGggYW5kIGNhbGN1bGF0ZVxuICAgICAgICAgICAgICAgIC8vIHJlbWFpbmluZyBkYXlzIGFuZCB3ZWVrcy5cbiAgICAgICAgICAgICAgICBsZXQgY3VycmVudDtcbiAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IHllYXJzQWRkZWQ7XG4gICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICBtb250aHMgKz0gc2lnbjtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudCA9IG5leHQ7XG4gICAgICAgICAgICAgICAgICAgIG5leHQgPSB0aGlzLmFkZE1vbnRoc0NhbGVuZGFyKGN1cnJlbnQsIHNpZ24sICdjb25zdHJhaW4nLCBjYWNoZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXh0LmRheSAhPT0gY2FsZW5kYXJPbmUuZGF5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJbiBjYXNlIHRoZSBkYXkgd2FzIGNvbnN0cmFpbmVkIGRvd24sIHRyeSB0byB1bi1jb25zdHJhaW4gaXRcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHQgPSB0aGlzLnJlZ3VsYXRlRGF0ZSh7IC4uLm5leHQsIGRheTogY2FsZW5kYXJPbmUuZGF5IH0sICdjb25zdHJhaW4nLCBjYWNoZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IHdoaWxlICh0aGlzLmNvbXBhcmVDYWxlbmRhckRhdGVzKGNhbGVuZGFyVHdvLCBuZXh0KSAqIHNpZ24gPj0gMCk7XG4gICAgICAgICAgICAgICAgbW9udGhzIC09IHNpZ247IC8vIGNvcnJlY3QgZm9yIGxvb3AgYWJvdmUgd2hpY2ggb3ZlcnNob290cyBieSAxXG4gICAgICAgICAgICAgICAgY29uc3QgcmVtYWluaW5nRGF5cyA9IHRoaXMuY2FsZW5kYXJEYXlzVW50aWwoY3VycmVudCwgY2FsZW5kYXJUd28sIGNhY2hlKTtcbiAgICAgICAgICAgICAgICBkYXlzID0gcmVtYWluaW5nRGF5cztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyB5ZWFycywgbW9udGhzLCB3ZWVrcywgZGF5cyB9O1xuICAgIH1cbiAgICBkYXlzSW5Nb250aChjYWxlbmRhckRhdGUsIGNhY2hlKSB7XG4gICAgICAgIC8vIEFkZCBlbm91Z2ggZGF5cyB0byByb2xsIG92ZXIgdG8gdGhlIG5leHQgbW9udGguIE9uZSB3ZSdyZSBpbiB0aGUgbmV4dFxuICAgICAgICAvLyBtb250aCwgd2UgY2FuIGNhbGN1bGF0ZSB0aGUgbGVuZ3RoIG9mIHRoZSBjdXJyZW50IG1vbnRoLiBOT1RFOiBUaGlzXG4gICAgICAgIC8vIGFsZ29yaXRobSBhc3N1bWVzIHRoYXQgbW9udGhzIGFyZSBjb250aW51b3VzLiBJdCB3b3VsZCBicmVhayBpZiBhXG4gICAgICAgIC8vIGNhbGVuZGFyIHNraXBwZWQgZGF5cywgbGlrZSB0aGUgSnVsaWFuLT5HcmVnb3JpYW4gc3dpdGNob3Zlci4gQnV0IHRoZVxuICAgICAgICAvLyBvbmx5IElDVSBjYWxlbmRhcnMgdGhhdCBjdXJyZW50bHkgc2tpcCBkYXlzIChqYXBhbmVzZS9yb2MvYnVkZGhpc3QpIGlzIGFcbiAgICAgICAgLy8gYnVnIChodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0xMTczMTU4KVxuICAgICAgICAvLyB0aGF0J3MgY3VycmVudGx5IGRldGVjdGVkIGJ5IGBjaGVja0ljdUJ1Z3MoKWAgd2hpY2ggd2lsbCB0aHJvdy4gU28gdGhpc1xuICAgICAgICAvLyBjb2RlIHNob3VsZCBiZSBzYWZlIGZvciBhbGwgSUNVIGNhbGVuZGFycy5cbiAgICAgICAgY29uc3QgeyBkYXkgfSA9IGNhbGVuZGFyRGF0ZTtcbiAgICAgICAgY29uc3QgbWF4ID0gdGhpcy5tYXhpbXVtTW9udGhMZW5ndGgoY2FsZW5kYXJEYXRlKTtcbiAgICAgICAgY29uc3QgbWluID0gdGhpcy5taW5pbXVtTW9udGhMZW5ndGgoY2FsZW5kYXJEYXRlKTtcbiAgICAgICAgLy8gZWFzaWVzdCBjYXNlOiB3ZSBhbHJlYWR5IGtub3cgdGhlIG1vbnRoIGxlbmd0aCBpZiBtaW4gYW5kIG1heCBhcmUgdGhlIHNhbWUuXG4gICAgICAgIGlmIChtaW4gPT09IG1heClcbiAgICAgICAgICAgIHJldHVybiBtaW47XG4gICAgICAgIC8vIEFkZCBlbm91Z2ggZGF5cyB0byBnZXQgaW50byB0aGUgbmV4dCBtb250aCwgd2l0aG91dCBza2lwcGluZyBpdFxuICAgICAgICBjb25zdCBpbmNyZW1lbnQgPSBkYXkgPD0gbWF4IC0gbWluID8gbWF4IDogbWluO1xuICAgICAgICBjb25zdCBpc29EYXRlID0gdGhpcy5jYWxlbmRhclRvSXNvRGF0ZShjYWxlbmRhckRhdGUsICdjb25zdHJhaW4nLCBjYWNoZSk7XG4gICAgICAgIGNvbnN0IGFkZGVkSXNvRGF0ZSA9IHRoaXMuYWRkRGF5c0lzbyhpc29EYXRlLCBpbmNyZW1lbnQpO1xuICAgICAgICBjb25zdCBhZGRlZENhbGVuZGFyRGF0ZSA9IHRoaXMuaXNvVG9DYWxlbmRhckRhdGUoYWRkZWRJc29EYXRlLCBjYWNoZSk7XG4gICAgICAgIC8vIE5vdyBiYWNrIHVwIHRvIHRoZSBsYXN0IGRheSBvZiB0aGUgb3JpZ2luYWwgbW9udGhcbiAgICAgICAgY29uc3QgZW5kT2ZNb250aElzbyA9IHRoaXMuYWRkRGF5c0lzbyhhZGRlZElzb0RhdGUsIC1hZGRlZENhbGVuZGFyRGF0ZS5kYXkpO1xuICAgICAgICBjb25zdCBlbmRPZk1vbnRoQ2FsZW5kYXIgPSB0aGlzLmlzb1RvQ2FsZW5kYXJEYXRlKGVuZE9mTW9udGhJc28sIGNhY2hlKTtcbiAgICAgICAgcmV0dXJuIGVuZE9mTW9udGhDYWxlbmRhci5kYXk7XG4gICAgfVxuICAgIGRheXNJblByZXZpb3VzTW9udGgoY2FsZW5kYXJEYXRlLCBjYWNoZSkge1xuICAgICAgICBjb25zdCB7IGRheSwgbW9udGgsIHllYXIgfSA9IGNhbGVuZGFyRGF0ZTtcbiAgICAgICAgLy8gQ2hlY2sgdG8gc2VlIGlmIHdlIGFscmVhZHkga25vdyB0aGUgbW9udGggbGVuZ3RoLCBhbmQgcmV0dXJuIGl0IGlmIHNvXG4gICAgICAgIGNvbnN0IHByZXZpb3VzTW9udGhZZWFyID0gbW9udGggPiAxID8geWVhciA6IHllYXIgLSAxO1xuICAgICAgICBsZXQgcHJldmlvdXNNb250aERhdGUgPSB7IHllYXI6IHByZXZpb3VzTW9udGhZZWFyLCBtb250aCwgZGF5OiAxIH07XG4gICAgICAgIGNvbnN0IHByZXZpb3VzTW9udGggPSBtb250aCA+IDEgPyBtb250aCAtIDEgOiB0aGlzLm1vbnRoc0luWWVhcihwcmV2aW91c01vbnRoRGF0ZSwgY2FjaGUpO1xuICAgICAgICBwcmV2aW91c01vbnRoRGF0ZSA9IHsgLi4ucHJldmlvdXNNb250aERhdGUsIG1vbnRoOiBwcmV2aW91c01vbnRoIH07XG4gICAgICAgIGNvbnN0IG1pbiA9IHRoaXMubWluaW11bU1vbnRoTGVuZ3RoKHByZXZpb3VzTW9udGhEYXRlKTtcbiAgICAgICAgY29uc3QgbWF4ID0gdGhpcy5tYXhpbXVtTW9udGhMZW5ndGgocHJldmlvdXNNb250aERhdGUpO1xuICAgICAgICBpZiAobWluID09PSBtYXgpXG4gICAgICAgICAgICByZXR1cm4gbWF4O1xuICAgICAgICBjb25zdCBpc29EYXRlID0gdGhpcy5jYWxlbmRhclRvSXNvRGF0ZShjYWxlbmRhckRhdGUsICdjb25zdHJhaW4nLCBjYWNoZSk7XG4gICAgICAgIGNvbnN0IGxhc3REYXlPZlByZXZpb3VzTW9udGhJc28gPSB0aGlzLmFkZERheXNJc28oaXNvRGF0ZSwgLWRheSk7XG4gICAgICAgIGNvbnN0IGxhc3REYXlPZlByZXZpb3VzTW9udGhDYWxlbmRhciA9IHRoaXMuaXNvVG9DYWxlbmRhckRhdGUobGFzdERheU9mUHJldmlvdXNNb250aElzbywgY2FjaGUpO1xuICAgICAgICByZXR1cm4gbGFzdERheU9mUHJldmlvdXNNb250aENhbGVuZGFyLmRheTtcbiAgICB9XG4gICAgc3RhcnRPZkNhbGVuZGFyWWVhcihjYWxlbmRhckRhdGUpIHtcbiAgICAgICAgcmV0dXJuIHsgeWVhcjogY2FsZW5kYXJEYXRlLnllYXIsIG1vbnRoOiAxLCBkYXk6IDEgfTtcbiAgICB9XG4gICAgc3RhcnRPZkNhbGVuZGFyTW9udGgoY2FsZW5kYXJEYXRlKSB7XG4gICAgICAgIHJldHVybiB7IHllYXI6IGNhbGVuZGFyRGF0ZS55ZWFyLCBtb250aDogY2FsZW5kYXJEYXRlLm1vbnRoLCBkYXk6IDEgfTtcbiAgICB9XG4gICAgY2FsZW5kYXJEYXlzVW50aWwoY2FsZW5kYXJPbmUsIGNhbGVuZGFyVHdvLCBjYWNoZSkge1xuICAgICAgICBjb25zdCBvbmVJc28gPSB0aGlzLmNhbGVuZGFyVG9Jc29EYXRlKGNhbGVuZGFyT25lLCAnY29uc3RyYWluJywgY2FjaGUpO1xuICAgICAgICBjb25zdCB0d29Jc28gPSB0aGlzLmNhbGVuZGFyVG9Jc29EYXRlKGNhbGVuZGFyVHdvLCAnY29uc3RyYWluJywgY2FjaGUpO1xuICAgICAgICByZXR1cm4gdGhpcy5pc29EYXlzVW50aWwob25lSXNvLCB0d29Jc28pO1xuICAgIH1cbiAgICBpc29EYXlzVW50aWwob25lSXNvLCB0d29Jc28pIHtcbiAgICAgICAgY29uc3QgZHVyYXRpb24gPSBEaWZmZXJlbmNlSVNPRGF0ZShvbmVJc28ueWVhciwgb25lSXNvLm1vbnRoLCBvbmVJc28uZGF5LCB0d29Jc28ueWVhciwgdHdvSXNvLm1vbnRoLCB0d29Jc28uZGF5LCAnZGF5Jyk7XG4gICAgICAgIHJldHVybiBkdXJhdGlvbi5kYXlzO1xuICAgIH1cbiAgICBtb250aERheUZyb21GaWVsZHMoZmllbGRzLCBvdmVyZmxvdywgY2FjaGUpIHtcbiAgICAgICAgbGV0IHsgeWVhciwgbW9udGgsIG1vbnRoQ29kZSwgZGF5LCBlcmEsIGVyYVllYXIgfSA9IGZpZWxkcztcbiAgICAgICAgaWYgKG1vbnRoQ29kZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAoeWVhciA9PT0gdW5kZWZpbmVkICYmIChlcmEgPT09IHVuZGVmaW5lZCB8fCBlcmFZZWFyID09PSB1bmRlZmluZWQpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYG1vbnRoQ29kZWAsIGB5ZWFyYCwgb3IgYGVyYWAgYW5kIGBlcmFZZWFyYCBpcyByZXF1aXJlZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKHsgbW9udGhDb2RlLCB5ZWFyIH0gPSB0aGlzLmFkanVzdENhbGVuZGFyRGF0ZSh7IHllYXIsIG1vbnRoLCBtb250aENvZGUsIGRheSwgZXJhLCBlcmFZZWFyIH0sIGNhY2hlLCBvdmVyZmxvdykpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBpc29ZZWFyLCBpc29Nb250aCwgaXNvRGF5O1xuICAgICAgICBsZXQgY2xvc2VzdENhbGVuZGFyLCBjbG9zZXN0SXNvO1xuICAgICAgICAvLyBMb29rIGJhY2t3YXJkcyBzdGFydGluZyBmcm9tIHRoZSBjYWxlbmRhciB5ZWFyIG9mIDE5NzItMDEtMDEgdXAgdG8gMTAwXG4gICAgICAgIC8vIGNhbGVuZGFyIHllYXJzIHRvIGZpbmQgYSB5ZWFyIHRoYXQgaGFzIHRoaXMgbW9udGggYW5kIGRheS4gTm9ybWFsIG1vbnRoc1xuICAgICAgICAvLyBhbmQgZGF5cyB3aWxsIG1hdGNoIGltbWVkaWF0ZWx5LCBidXQgZm9yIGxlYXAgZGF5cyBhbmQgbGVhcCBtb250aHMgd2UgbWF5XG4gICAgICAgIC8vIGhhdmUgdG8gbG9vayBmb3IgYSB3aGlsZS5cbiAgICAgICAgY29uc3Qgc3RhcnREYXRlSXNvID0geyB5ZWFyOiAxOTcyLCBtb250aDogMSwgZGF5OiAxIH07XG4gICAgICAgIGNvbnN0IHsgeWVhcjogY2FsZW5kYXJZZWFyIH0gPSB0aGlzLmlzb1RvQ2FsZW5kYXJEYXRlKHN0YXJ0RGF0ZUlzbywgY2FjaGUpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDEwMDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCB0ZXN0Q2FsZW5kYXJEYXRlID0gdGhpcy5hZGp1c3RDYWxlbmRhckRhdGUoeyBkYXksIG1vbnRoQ29kZSwgeWVhcjogY2FsZW5kYXJZZWFyIC0gaSB9LCBjYWNoZSk7XG4gICAgICAgICAgICBjb25zdCBpc29EYXRlID0gdGhpcy5jYWxlbmRhclRvSXNvRGF0ZSh0ZXN0Q2FsZW5kYXJEYXRlLCAnY29uc3RyYWluJywgY2FjaGUpO1xuICAgICAgICAgICAgY29uc3Qgcm91bmRUcmlwQ2FsZW5kYXJEYXRlID0gdGhpcy5pc29Ub0NhbGVuZGFyRGF0ZShpc29EYXRlLCBjYWNoZSk7XG4gICAgICAgICAgICAoeyB5ZWFyOiBpc29ZZWFyLCBtb250aDogaXNvTW9udGgsIGRheTogaXNvRGF5IH0gPSBpc29EYXRlKTtcbiAgICAgICAgICAgIGlmIChyb3VuZFRyaXBDYWxlbmRhckRhdGUubW9udGhDb2RlID09PSBtb250aENvZGUgJiYgcm91bmRUcmlwQ2FsZW5kYXJEYXRlLmRheSA9PT0gZGF5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgbW9udGg6IGlzb01vbnRoLCBkYXk6IGlzb0RheSwgeWVhcjogaXNvWWVhciB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAob3ZlcmZsb3cgPT09ICdjb25zdHJhaW4nKSB7XG4gICAgICAgICAgICAgICAgLy8gbm9uLUlTTyBjb25zdHJhaW4gYWxnb3JpdGhtIHRyaWVzIHRvIGZpbmQgdGhlIGNsb3Nlc3QgZGF0ZSBpbiBhIG1hdGNoaW5nIG1vbnRoXG4gICAgICAgICAgICAgICAgaWYgKGNsb3Nlc3RDYWxlbmRhciA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICAgICAgICAgIChyb3VuZFRyaXBDYWxlbmRhckRhdGUubW9udGhDb2RlID09PSBjbG9zZXN0Q2FsZW5kYXIubW9udGhDb2RlICYmXG4gICAgICAgICAgICAgICAgICAgICAgICByb3VuZFRyaXBDYWxlbmRhckRhdGUuZGF5ID4gY2xvc2VzdENhbGVuZGFyLmRheSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xvc2VzdENhbGVuZGFyID0gcm91bmRUcmlwQ2FsZW5kYXJEYXRlO1xuICAgICAgICAgICAgICAgICAgICBjbG9zZXN0SXNvID0gaXNvRGF0ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG92ZXJmbG93ID09PSAnY29uc3RyYWluJyAmJiBjbG9zZXN0SXNvICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXR1cm4gY2xvc2VzdElzbztcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYE5vIHJlY2VudCAke3RoaXMuaWR9IHllYXIgd2l0aCBtb250aENvZGUgJHttb250aENvZGV9IGFuZCBkYXkgJHtkYXl9YCk7XG4gICAgfVxufVxuY2xhc3MgSGVicmV3SGVscGVyIGV4dGVuZHMgSGVscGVyQmFzZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuaWQgPSAnaGVicmV3JztcbiAgICAgICAgdGhpcy5jYWxlbmRhclR5cGUgPSAnbHVuaXNvbGFyJztcbiAgICAgICAgdGhpcy5tb250aHMgPSB7XG4gICAgICAgICAgICBUaXNocmk6IHsgbGVhcDogMSwgcmVndWxhcjogMSwgbW9udGhDb2RlOiAnTTAxJywgZGF5czogMzAgfSxcbiAgICAgICAgICAgIEhlc2h2YW46IHsgbGVhcDogMiwgcmVndWxhcjogMiwgbW9udGhDb2RlOiAnTTAyJywgZGF5czogeyBtaW46IDI5LCBtYXg6IDMwIH0gfSxcbiAgICAgICAgICAgIEtpc2xldjogeyBsZWFwOiAzLCByZWd1bGFyOiAzLCBtb250aENvZGU6ICdNMDMnLCBkYXlzOiB7IG1pbjogMjksIG1heDogMzAgfSB9LFxuICAgICAgICAgICAgVGV2ZXQ6IHsgbGVhcDogNCwgcmVndWxhcjogNCwgbW9udGhDb2RlOiAnTTA0JywgZGF5czogMjkgfSxcbiAgICAgICAgICAgIFNoZXZhdDogeyBsZWFwOiA1LCByZWd1bGFyOiA1LCBtb250aENvZGU6ICdNMDUnLCBkYXlzOiAzMCB9LFxuICAgICAgICAgICAgQWRhcjogeyBsZWFwOiB1bmRlZmluZWQsIHJlZ3VsYXI6IDYsIG1vbnRoQ29kZTogJ00wNicsIGRheXM6IDI5IH0sXG4gICAgICAgICAgICAnQWRhciBJJzogeyBsZWFwOiA2LCByZWd1bGFyOiB1bmRlZmluZWQsIG1vbnRoQ29kZTogJ00wNUwnLCBkYXlzOiAzMCB9LFxuICAgICAgICAgICAgJ0FkYXIgSUknOiB7IGxlYXA6IDcsIHJlZ3VsYXI6IHVuZGVmaW5lZCwgbW9udGhDb2RlOiAnTTA2JywgZGF5czogMjkgfSxcbiAgICAgICAgICAgIE5pc2FuOiB7IGxlYXA6IDgsIHJlZ3VsYXI6IDcsIG1vbnRoQ29kZTogJ00wNycsIGRheXM6IDMwIH0sXG4gICAgICAgICAgICBJeWFyOiB7IGxlYXA6IDksIHJlZ3VsYXI6IDgsIG1vbnRoQ29kZTogJ00wOCcsIGRheXM6IDI5IH0sXG4gICAgICAgICAgICBTaXZhbjogeyBsZWFwOiAxMCwgcmVndWxhcjogOSwgbW9udGhDb2RlOiAnTTA5JywgZGF5czogMzAgfSxcbiAgICAgICAgICAgIFRhbXV6OiB7IGxlYXA6IDExLCByZWd1bGFyOiAxMCwgbW9udGhDb2RlOiAnTTEwJywgZGF5czogMjkgfSxcbiAgICAgICAgICAgIEF2OiB7IGxlYXA6IDEyLCByZWd1bGFyOiAxMSwgbW9udGhDb2RlOiAnTTExJywgZGF5czogMzAgfSxcbiAgICAgICAgICAgIEVsdWw6IHsgbGVhcDogMTMsIHJlZ3VsYXI6IDEyLCBtb250aENvZGU6ICdNMTInLCBkYXlzOiAyOSB9XG4gICAgICAgIH07XG4gICAgICAgIC8vIEFsbCBidWlsdC1pbiBjYWxlbmRhcnMgZXhjZXB0IENoaW5lc2UvRGFuZ2kgYW5kIEhlYnJldyB1c2UgYW4gZXJhXG4gICAgICAgIHRoaXMuaGFzRXJhID0gZmFsc2U7XG4gICAgfVxuICAgIGluTGVhcFllYXIoY2FsZW5kYXJEYXRlKSB7XG4gICAgICAgIGNvbnN0IHsgeWVhciB9ID0gY2FsZW5kYXJEYXRlO1xuICAgICAgICAvLyBGWUk6IEluIGFkZGl0aW9uIHRvIGFkZGluZyBhIG1vbnRoIGluIGxlYXAgeWVhcnMsIHRoZSBIZWJyZXcgY2FsZW5kYXJcbiAgICAgICAgLy8gYWxzbyBoYXMgcGVyLXllYXIgY2hhbmdlcyB0byB0aGUgbnVtYmVyIG9mIGRheXMgb2YgSGVzaHZhbiBhbmQgS2lzbGV2LlxuICAgICAgICAvLyBHaXZlbiB0aGF0IHRoZXNlIGNhbiBiZSBjYWxjdWxhdGVkIGJ5IGNvdW50aW5nIHRoZSBudW1iZXIgb2YgZGF5cyBpblxuICAgICAgICAvLyB0aG9zZSBtb250aHMsIEkgYXNzdW1lIHRoYXQgdGhlc2UgRE8gTk9UIG5lZWQgdG8gYmUgZXhwb3NlZCBhc1xuICAgICAgICAvLyBIZWJyZXctb25seSBwcm90b3R5cGUgZmllbGRzIG9yIG1ldGhvZHMuXG4gICAgICAgIHJldHVybiAoNyAqIHllYXIgKyAxKSAlIDE5IDwgNztcbiAgICB9XG4gICAgbW9udGhzSW5ZZWFyKGNhbGVuZGFyRGF0ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbkxlYXBZZWFyKGNhbGVuZGFyRGF0ZSkgPyAxMyA6IDEyO1xuICAgIH1cbiAgICBtaW5pbXVtTW9udGhMZW5ndGgoY2FsZW5kYXJEYXRlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pbk1heE1vbnRoTGVuZ3RoKGNhbGVuZGFyRGF0ZSwgJ21pbicpO1xuICAgIH1cbiAgICBtYXhpbXVtTW9udGhMZW5ndGgoY2FsZW5kYXJEYXRlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pbk1heE1vbnRoTGVuZ3RoKGNhbGVuZGFyRGF0ZSwgJ21heCcpO1xuICAgIH1cbiAgICBtaW5NYXhNb250aExlbmd0aChjYWxlbmRhckRhdGUsIG1pbk9yTWF4KSB7XG4gICAgICAgIGNvbnN0IHsgbW9udGgsIHllYXIgfSA9IGNhbGVuZGFyRGF0ZTtcbiAgICAgICAgY29uc3QgbW9udGhDb2RlID0gdGhpcy5nZXRNb250aENvZGUoeWVhciwgbW9udGgpO1xuICAgICAgICBjb25zdCBtb250aEluZm8gPSBPYmplY3RFbnRyaWVzKHRoaXMubW9udGhzKS5maW5kKChtKSA9PiBtWzFdLm1vbnRoQ29kZSA9PT0gbW9udGhDb2RlKTtcbiAgICAgICAgaWYgKG1vbnRoSW5mbyA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYHVubWF0Y2hlZCBIZWJyZXcgbW9udGg6ICR7bW9udGh9YCk7XG4gICAgICAgIGNvbnN0IGRheXNJbk1vbnRoID0gbW9udGhJbmZvWzFdLmRheXM7XG4gICAgICAgIHJldHVybiB0eXBlb2YgZGF5c0luTW9udGggPT09ICdudW1iZXInID8gZGF5c0luTW9udGggOiBkYXlzSW5Nb250aFttaW5Pck1heF07XG4gICAgfVxuICAgIC8qKiBUYWtlIGEgZ3Vlc3MgYXQgd2hhdCBJU08gZGF0ZSBhIHBhcnRpY3VsYXIgY2FsZW5kYXIgZGF0ZSBjb3JyZXNwb25kcyB0byAqL1xuICAgIGVzdGltYXRlSXNvRGF0ZShjYWxlbmRhckRhdGUpIHtcbiAgICAgICAgY29uc3QgeyB5ZWFyIH0gPSBjYWxlbmRhckRhdGU7XG4gICAgICAgIHJldHVybiB7IHllYXI6IHllYXIgLSAzNzYwLCBtb250aDogMSwgZGF5OiAxIH07XG4gICAgfVxuICAgIGdldE1vbnRoQ29kZSh5ZWFyLCBtb250aCkge1xuICAgICAgICBpZiAodGhpcy5pbkxlYXBZZWFyKHsgeWVhciB9KSkge1xuICAgICAgICAgICAgcmV0dXJuIG1vbnRoID09PSA2ID8gYnVpbGRNb250aENvZGUoNSwgdHJ1ZSkgOiBidWlsZE1vbnRoQ29kZShtb250aCA8IDYgPyBtb250aCA6IG1vbnRoIC0gMSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gYnVpbGRNb250aENvZGUobW9udGgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFkanVzdENhbGVuZGFyRGF0ZShjYWxlbmRhckRhdGUsIGNhY2hlLCBvdmVyZmxvdyA9ICdjb25zdHJhaW4nLCBmcm9tTGVnYWN5RGF0ZSA9IGZhbHNlKSB7XG4gICAgICAgIC8vIFRoZSBpbmNvbWluZyB0eXBlIGlzIGFjdHVhbGx5IENhbGVuZGFyRGF0ZSAoc2FtZSBhcyBhcmdzIHRvXG4gICAgICAgIC8vIENhbGVuZGFyLmRhdGVGcm9tUGFyYW1zKSBidXQgVFMgaXNuJ3Qgc21hcnQgZW5vdWdoIHRvIGZvbGxvdyBhbGwgdGhlXG4gICAgICAgIC8vIHJlYXNzaWdubWVudHMgYmVsb3csIHNvIGFzIGFuIGFsdGVybmF0aXZlIHRvIDEwKyB0eXBlIGNhc3RzLCB3ZSdsbCBsaWVcbiAgICAgICAgLy8gaGVyZSBhbmQgY2xhaW0gdGhhdCB0aGUgdHlwZSBoYXMgYGRheWAgYW5kIGB5ZWFyYCBmaWxsZWQgaW4gYWxyZWFkeS5cbiAgICAgICAgbGV0IHsgeWVhciwgZXJhWWVhciwgbW9udGgsIG1vbnRoQ29kZSwgZGF5LCBtb250aEV4dHJhIH0gPSBjYWxlbmRhckRhdGU7XG4gICAgICAgIGlmICh5ZWFyID09PSB1bmRlZmluZWQgJiYgZXJhWWVhciAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgeWVhciA9IGVyYVllYXI7XG4gICAgICAgIGlmIChlcmFZZWFyID09PSB1bmRlZmluZWQgJiYgeWVhciAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgZXJhWWVhciA9IHllYXI7XG4gICAgICAgIGlmIChmcm9tTGVnYWN5RGF0ZSkge1xuICAgICAgICAgICAgLy8gSW4gUHJlIE5vZGUtMTQgVjgsIERhdGVUaW1lRm9ybWF0LmZvcm1hdFRvUGFydHMgYG1vbnRoOiAnbnVtZXJpYydgXG4gICAgICAgICAgICAvLyBvdXRwdXQgcmV0dXJucyB0aGUgbnVtZXJpYyBlcXVpdmFsZW50IG9mIGBtb250aGAgYXMgYSBzdHJpbmcsIG1lYW5pbmdcbiAgICAgICAgICAgIC8vIHRoYXQgYCc2J2AgaW4gYSBsZWFwIHllYXIgaXMgQWRhciBJLCB3aGlsZSBgJzYnYCBpbiBhIG5vbi1sZWFwIHllYXJcbiAgICAgICAgICAgIC8vIG1lYW5zIEFkYXIuIEluIHRoaXMgY2FzZSwgYG1vbnRoYCB3aWxsIGFscmVhZHkgYmUgY29ycmVjdCBhbmQgbm8gYWN0aW9uXG4gICAgICAgICAgICAvLyBpcyBuZWVkZWQuIEhvd2V2ZXIsIGluIE5vZGUgMTQgYW5kIGxhdGVyIGZvcm1hdFRvUGFydHMgcmV0dXJucyB0aGUgbmFtZVxuICAgICAgICAgICAgLy8gb2YgdGhlIEhlYnJldyBtb250aCAoZS5nLiBcIlRldmV0XCIpLCBzbyB3ZSdsbCBuZWVkIHRvIGxvb2sgdXAgdGhlXG4gICAgICAgICAgICAvLyBjb3JyZWN0IGBtb250aGAgdXNpbmcgdGhlIHN0cmluZyBuYW1lIGFzIGEga2V5LlxuICAgICAgICAgICAgaWYgKG1vbnRoRXh0cmEpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtb250aEluZm8gPSB0aGlzLm1vbnRoc1ttb250aEV4dHJhXTtcbiAgICAgICAgICAgICAgICBpZiAoIW1vbnRoSW5mbylcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYFVucmVjb2duaXplZCBtb250aCBmcm9tIGZvcm1hdFRvUGFydHM6ICR7bW9udGhFeHRyYX1gKTtcbiAgICAgICAgICAgICAgICBtb250aCA9IHRoaXMuaW5MZWFwWWVhcih7IHllYXIgfSkgPyBtb250aEluZm8ubGVhcCA6IG1vbnRoSW5mby5yZWd1bGFyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQmVjYXVzZSB3ZSdyZSBnZXR0aW5nIGRhdGEgZnJvbSBsZWdhY3kgRGF0ZSwgdGhlbiBgbW9udGhgIHdpbGwgYWx3YXlzIGJlIHByZXNlbnRcbiAgICAgICAgICAgIG1vbnRoQ29kZSA9IHRoaXMuZ2V0TW9udGhDb2RlKHllYXIsIG1vbnRoKTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHsgeWVhciwgbW9udGg6IG1vbnRoLCBkYXksIGVyYTogdW5kZWZpbmVkLCBlcmFZZWFyLCBtb250aENvZGUgfTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBXaGVuIGNhbGxlZCB3aXRob3V0IGlucHV0IGNvbWluZyBmcm9tIGxlZ2FjeSBEYXRlIG91dHB1dCwgc2ltcGx5IGVuc3VyZVxuICAgICAgICAgICAgLy8gdGhhdCBhbGwgZmllbGRzIGFyZSBwcmVzZW50LlxuICAgICAgICAgICAgdGhpcy52YWxpZGF0ZUNhbGVuZGFyRGF0ZShjYWxlbmRhckRhdGUpO1xuICAgICAgICAgICAgaWYgKG1vbnRoID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAobW9udGhDb2RlLmVuZHNXaXRoKCdMJykpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1vbnRoQ29kZSAhPT0gJ00wNUwnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgSGVicmV3IGxlYXAgbW9udGggbXVzdCBoYXZlIG1vbnRoQ29kZSBNMDVMLCBub3QgJHttb250aENvZGV9YCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbW9udGggPSA2O1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuaW5MZWFwWWVhcih7IHllYXIgfSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvdmVyZmxvdyA9PT0gJ3JlamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgSGVicmV3IG1vbnRoQ29kZSBNMDVMIGlzIGludmFsaWQgaW4geWVhciAke3llYXJ9IHdoaWNoIGlzIG5vdCBhIGxlYXAgeWVhcmApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29uc3RyYWluIHRvIGxhc3QgZGF5IG9mIHByZXZpb3VzIG1vbnRoIChBdilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb250aCA9IDU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF5ID0gMzA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9udGhDb2RlID0gJ00wNSc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG1vbnRoID0gbW9udGhDb2RlTnVtYmVyUGFydChtb250aENvZGUpO1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiBsZWFwIG1vbnRoIGlzIGJlZm9yZSB0aGlzIG9uZSwgdGhlIG1vbnRoIGluZGV4IGlzIG9uZSBtb3JlIHRoYW4gdGhlIG1vbnRoIGNvZGVcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaW5MZWFwWWVhcih7IHllYXIgfSkgJiYgbW9udGggPiA2KVxuICAgICAgICAgICAgICAgICAgICAgICAgbW9udGgrKztcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGFyZ2VzdE1vbnRoID0gdGhpcy5tb250aHNJblllYXIoeyB5ZWFyIH0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAobW9udGggPCAxIHx8IG1vbnRoID4gbGFyZ2VzdE1vbnRoKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYEludmFsaWQgbW9udGhDb2RlOiAke21vbnRoQ29kZX1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAob3ZlcmZsb3cgPT09ICdyZWplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgIFJlamVjdFRvUmFuZ2UobW9udGgsIDEsIHRoaXMubW9udGhzSW5ZZWFyKHsgeWVhciB9KSk7XG4gICAgICAgICAgICAgICAgICAgIFJlamVjdFRvUmFuZ2UoZGF5LCAxLCB0aGlzLm1heGltdW1Nb250aExlbmd0aCh7IHllYXIsIG1vbnRoIH0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG1vbnRoID0gQ29uc3RyYWluVG9SYW5nZShtb250aCwgMSwgdGhpcy5tb250aHNJblllYXIoeyB5ZWFyIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgZGF5ID0gQ29uc3RyYWluVG9SYW5nZShkYXksIDEsIHRoaXMubWF4aW11bU1vbnRoTGVuZ3RoKHsgeWVhciwgbW9udGggfSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobW9udGhDb2RlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbW9udGhDb2RlID0gdGhpcy5nZXRNb250aENvZGUoeWVhciwgbW9udGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2FsY3VsYXRlZE1vbnRoQ29kZSA9IHRoaXMuZ2V0TW9udGhDb2RlKHllYXIsIG1vbnRoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNhbGN1bGF0ZWRNb250aENvZGUgIT09IG1vbnRoQ29kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYG1vbnRoQ29kZSAke21vbnRoQ29kZX0gZG9lc24ndCBjb3JyZXNwb25kIHRvIG1vbnRoICR7bW9udGh9IGluIEhlYnJldyB5ZWFyICR7eWVhcn1gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7IC4uLmNhbGVuZGFyRGF0ZSwgZGF5LCBtb250aCwgbW9udGhDb2RlOiBtb250aENvZGUsIHllYXIsIGVyYVllYXIgfTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogRm9yIFRlbXBvcmFsIHB1cnBvc2VzLCB0aGUgSXNsYW1pYyBjYWxlbmRhciBpcyBzaW1wbGUgYmVjYXVzZSBpdCdzIGFsd2F5cyB0aGVcbiAqIHNhbWUgMTIgbW9udGhzIGluIHRoZSBzYW1lIG9yZGVyLlxuICovXG5jbGFzcyBJc2xhbWljQmFzZUhlbHBlciBleHRlbmRzIEhlbHBlckJhc2Uge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLmNhbGVuZGFyVHlwZSA9ICdsdW5hcic7XG4gICAgICAgIHRoaXMuREFZU19QRVJfSVNMQU1JQ19ZRUFSID0gMzU0ICsgMTEgLyAzMDtcbiAgICAgICAgdGhpcy5EQVlTX1BFUl9JU09fWUVBUiA9IDM2NS4yNDI1O1xuICAgICAgICB0aGlzLmNvbnN0YW50RXJhID0gJ2FoJztcbiAgICB9XG4gICAgaW5MZWFwWWVhcihjYWxlbmRhckRhdGUsIGNhY2hlKSB7XG4gICAgICAgIC8vIEluIGxlYXAgeWVhcnMsIHRoZSAxMnRoIG1vbnRoIGhhcyAzMCBkYXlzLiBJbiBub24tbGVhcCB5ZWFyczogMjkuXG4gICAgICAgIGNvbnN0IGRheXMgPSB0aGlzLmRheXNJbk1vbnRoKHsgeWVhcjogY2FsZW5kYXJEYXRlLnllYXIsIG1vbnRoOiAxMiwgZGF5OiAxIH0sIGNhY2hlKTtcbiAgICAgICAgcmV0dXJuIGRheXMgPT09IDMwO1xuICAgIH1cbiAgICBtb250aHNJblllYXIoIC8qIGNhbGVuZGFyWWVhciwgY2FjaGUgKi8pIHtcbiAgICAgICAgcmV0dXJuIDEyO1xuICAgIH1cbiAgICBtaW5pbXVtTW9udGhMZW5ndGgoIC8qIGNhbGVuZGFyRGF0ZSAqLykge1xuICAgICAgICByZXR1cm4gMjk7XG4gICAgfVxuICAgIG1heGltdW1Nb250aExlbmd0aCggLyogY2FsZW5kYXJEYXRlICovKSB7XG4gICAgICAgIHJldHVybiAzMDtcbiAgICB9XG4gICAgZXN0aW1hdGVJc29EYXRlKGNhbGVuZGFyRGF0ZSkge1xuICAgICAgICBjb25zdCB7IHllYXIgfSA9IHRoaXMuYWRqdXN0Q2FsZW5kYXJEYXRlKGNhbGVuZGFyRGF0ZSk7XG4gICAgICAgIHJldHVybiB7IHllYXI6IE1hdGhGbG9vciQxKCh5ZWFyICogdGhpcy5EQVlTX1BFUl9JU0xBTUlDX1lFQVIpIC8gdGhpcy5EQVlTX1BFUl9JU09fWUVBUikgKyA2MjIsIG1vbnRoOiAxLCBkYXk6IDEgfTtcbiAgICB9XG59XG4vLyBUaGVyZSBhcmUgNiBJc2xhbWljIGNhbGVuZGFycyB3aXRoIHRoZSBzYW1lIGltcGxlbWVudGF0aW9uIGluIHRoaXMgcG9seWZpbGwuXG4vLyBUaGV5IHZhcnkgb25seSBpbiB0aGVpciBJRC4gVGhleSBkbyBlbWl0IGRpZmZlcmVudCBvdXRwdXQgZnJvbSB0aGUgdW5kZXJseWluZ1xuLy8gSW50bCBpbXBsZW1lbnRhdGlvbiwgYnV0IG91ciBjb2RlIGZvciBlYWNoIG9mIHRoZW0gaXMgaWRlbnRpY2FsLlxuY2xhc3MgSXNsYW1pY0hlbHBlciBleHRlbmRzIElzbGFtaWNCYXNlSGVscGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5pZCA9ICdpc2xhbWljJztcbiAgICB9XG59XG5jbGFzcyBJc2xhbWljVW1hbHF1cmFIZWxwZXIgZXh0ZW5kcyBJc2xhbWljQmFzZUhlbHBlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuaWQgPSAnaXNsYW1pYy11bWFscXVyYSc7XG4gICAgfVxufVxuY2xhc3MgSXNsYW1pY1RibGFIZWxwZXIgZXh0ZW5kcyBJc2xhbWljQmFzZUhlbHBlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuaWQgPSAnaXNsYW1pYy10YmxhJztcbiAgICB9XG59XG5jbGFzcyBJc2xhbWljQ2l2aWxIZWxwZXIgZXh0ZW5kcyBJc2xhbWljQmFzZUhlbHBlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuaWQgPSAnaXNsYW1pYy1jaXZpbCc7XG4gICAgfVxufVxuY2xhc3MgSXNsYW1pY1Jnc2FIZWxwZXIgZXh0ZW5kcyBJc2xhbWljQmFzZUhlbHBlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuaWQgPSAnaXNsYW1pYy1yZ3NhJztcbiAgICB9XG59XG5jbGFzcyBJc2xhbWljQ2NIZWxwZXIgZXh0ZW5kcyBJc2xhbWljQmFzZUhlbHBlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuaWQgPSAnaXNsYW1pY2MnO1xuICAgIH1cbn1cbmNsYXNzIFBlcnNpYW5IZWxwZXIgZXh0ZW5kcyBIZWxwZXJCYXNlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5pZCA9ICdwZXJzaWFuJztcbiAgICAgICAgdGhpcy5jYWxlbmRhclR5cGUgPSAnc29sYXInO1xuICAgICAgICB0aGlzLmNvbnN0YW50RXJhID0gJ2FwJztcbiAgICB9XG4gICAgaW5MZWFwWWVhcihjYWxlbmRhckRhdGUsIGNhY2hlKSB7XG4gICAgICAgIC8vIFNhbWUgbG9naWMgKGNvdW50IGRheXMgaW4gdGhlIGxhc3QgbW9udGgpIGZvciBQZXJzaWFuIGFzIGZvciBJc2xhbWljLFxuICAgICAgICAvLyBldmVuIHRob3VnaCBQZXJzaWFuIGlzIHNvbGFyIGFuZCBJc2xhbWljIGlzIGx1bmFyLlxuICAgICAgICByZXR1cm4gSXNsYW1pY0hlbHBlci5wcm90b3R5cGUuaW5MZWFwWWVhci5jYWxsKHRoaXMsIGNhbGVuZGFyRGF0ZSwgY2FjaGUpO1xuICAgIH1cbiAgICBtb250aHNJblllYXIoIC8qIGNhbGVuZGFyWWVhciwgY2FjaGUgKi8pIHtcbiAgICAgICAgcmV0dXJuIDEyO1xuICAgIH1cbiAgICBtaW5pbXVtTW9udGhMZW5ndGgoY2FsZW5kYXJEYXRlKSB7XG4gICAgICAgIGNvbnN0IHsgbW9udGggfSA9IGNhbGVuZGFyRGF0ZTtcbiAgICAgICAgaWYgKG1vbnRoID09PSAxMilcbiAgICAgICAgICAgIHJldHVybiAyOTtcbiAgICAgICAgcmV0dXJuIG1vbnRoIDw9IDYgPyAzMSA6IDMwO1xuICAgIH1cbiAgICBtYXhpbXVtTW9udGhMZW5ndGgoY2FsZW5kYXJEYXRlKSB7XG4gICAgICAgIGNvbnN0IHsgbW9udGggfSA9IGNhbGVuZGFyRGF0ZTtcbiAgICAgICAgaWYgKG1vbnRoID09PSAxMilcbiAgICAgICAgICAgIHJldHVybiAzMDtcbiAgICAgICAgcmV0dXJuIG1vbnRoIDw9IDYgPyAzMSA6IDMwO1xuICAgIH1cbiAgICBlc3RpbWF0ZUlzb0RhdGUoY2FsZW5kYXJEYXRlKSB7XG4gICAgICAgIGNvbnN0IHsgeWVhciB9ID0gdGhpcy5hZGp1c3RDYWxlbmRhckRhdGUoY2FsZW5kYXJEYXRlKTtcbiAgICAgICAgcmV0dXJuIHsgeWVhcjogeWVhciArIDYyMSwgbW9udGg6IDEsIGRheTogMSB9O1xuICAgIH1cbn1cbmNsYXNzIEluZGlhbkhlbHBlciBleHRlbmRzIEhlbHBlckJhc2Uge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLmlkID0gJ2luZGlhbic7XG4gICAgICAgIHRoaXMuY2FsZW5kYXJUeXBlID0gJ3NvbGFyJztcbiAgICAgICAgdGhpcy5jb25zdGFudEVyYSA9ICdzYWthJztcbiAgICAgICAgLy8gSW5kaWFuIG1vbnRocyBhbHdheXMgc3RhcnQgYXQgdGhlIHNhbWUgd2VsbC1rbm93biBHcmVnb3JpYW4gbW9udGggYW5kXG4gICAgICAgIC8vIGRheS4gU28gdGhpcyBjb252ZXJzaW9uIGlzIGVhc3kgYW5kIGZhc3QuIFNlZVxuICAgICAgICAvLyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JbmRpYW5fbmF0aW9uYWxfY2FsZW5kYXJcbiAgICAgICAgdGhpcy5tb250aHMgPSB7XG4gICAgICAgICAgICAxOiB7IGxlbmd0aDogMzAsIG1vbnRoOiAzLCBkYXk6IDIyLCBsZWFwOiB7IGxlbmd0aDogMzEsIG1vbnRoOiAzLCBkYXk6IDIxIH0gfSxcbiAgICAgICAgICAgIDI6IHsgbGVuZ3RoOiAzMSwgbW9udGg6IDQsIGRheTogMjEgfSxcbiAgICAgICAgICAgIDM6IHsgbGVuZ3RoOiAzMSwgbW9udGg6IDUsIGRheTogMjIgfSxcbiAgICAgICAgICAgIDQ6IHsgbGVuZ3RoOiAzMSwgbW9udGg6IDYsIGRheTogMjIgfSxcbiAgICAgICAgICAgIDU6IHsgbGVuZ3RoOiAzMSwgbW9udGg6IDcsIGRheTogMjMgfSxcbiAgICAgICAgICAgIDY6IHsgbGVuZ3RoOiAzMSwgbW9udGg6IDgsIGRheTogMjMgfSxcbiAgICAgICAgICAgIDc6IHsgbGVuZ3RoOiAzMCwgbW9udGg6IDksIGRheTogMjMgfSxcbiAgICAgICAgICAgIDg6IHsgbGVuZ3RoOiAzMCwgbW9udGg6IDEwLCBkYXk6IDIzIH0sXG4gICAgICAgICAgICA5OiB7IGxlbmd0aDogMzAsIG1vbnRoOiAxMSwgZGF5OiAyMiB9LFxuICAgICAgICAgICAgMTA6IHsgbGVuZ3RoOiAzMCwgbW9udGg6IDEyLCBkYXk6IDIyIH0sXG4gICAgICAgICAgICAxMTogeyBsZW5ndGg6IDMwLCBtb250aDogMSwgbmV4dFllYXI6IHRydWUsIGRheTogMjEgfSxcbiAgICAgICAgICAgIDEyOiB7IGxlbmd0aDogMzAsIG1vbnRoOiAyLCBuZXh0WWVhcjogdHJ1ZSwgZGF5OiAyMCB9XG4gICAgICAgIH07XG4gICAgICAgIC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTEwNTI5IGNhdXNlcyBJbnRsJ3MgSW5kaWFuXG4gICAgICAgIC8vIGNhbGVuZGFyIG91dHB1dCB0byBmYWlsIGZvciBhbGwgZGF0ZXMgYmVmb3JlIDAwMDEtMDEtMDEgSVNPLiAgRm9yIGV4YW1wbGUsXG4gICAgICAgIC8vIGluIE5vZGUgMTIgMDAwMC0wMS0wMSBpcyBjYWxjdWxhdGVkIGFzIDYxNDYvMTIvLTU4MyBpbnN0ZWFkIG9mIDEwLzExLy03OSBhc1xuICAgICAgICAvLyBleHBlY3RlZC5cbiAgICAgICAgdGhpcy52dWxuZXJhYmxlVG9CY2VCdWcgPSBuZXcgRGF0ZSgnMDAwMC0wMS0wMVQwMDowMFonKS50b0xvY2FsZURhdGVTdHJpbmcoJ2VuLVVTLXUtY2EtaW5kaWFuJywgeyB0aW1lWm9uZTogJ1VUQycgfSkgIT09ICcxMC8xMS8tNzkgU2FrYSc7XG4gICAgfVxuICAgIGluTGVhcFllYXIoY2FsZW5kYXJEYXRlKSB7XG4gICAgICAgIC8vIEZyb20gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSW5kaWFuX25hdGlvbmFsX2NhbGVuZGFyOlxuICAgICAgICAvLyBZZWFycyBhcmUgY291bnRlZCBpbiB0aGUgU2FrYSBlcmEsIHdoaWNoIHN0YXJ0cyBpdHMgeWVhciAwIGluIHRoZSB5ZWFyIDc4XG4gICAgICAgIC8vIG9mIHRoZSBDb21tb24gRXJhLiBUbyBkZXRlcm1pbmUgbGVhcCB5ZWFycywgYWRkIDc4IHRvIHRoZSBTYWthIHllYXIg4oCTIGlmXG4gICAgICAgIC8vIHRoZSByZXN1bHQgaXMgYSBsZWFwIHllYXIgaW4gdGhlIEdyZWdvcmlhbiBjYWxlbmRhciwgdGhlbiB0aGUgU2FrYSB5ZWFyXG4gICAgICAgIC8vIGlzIGEgbGVhcCB5ZWFyIGFzIHdlbGwuXG4gICAgICAgIHJldHVybiBpc0dyZWdvcmlhbkxlYXBZZWFyKGNhbGVuZGFyRGF0ZS55ZWFyICsgNzgpO1xuICAgIH1cbiAgICBtb250aHNJblllYXIoIC8qIGNhbGVuZGFyWWVhciwgY2FjaGUgKi8pIHtcbiAgICAgICAgcmV0dXJuIDEyO1xuICAgIH1cbiAgICBtaW5pbXVtTW9udGhMZW5ndGgoY2FsZW5kYXJEYXRlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldE1vbnRoSW5mbyhjYWxlbmRhckRhdGUpLmxlbmd0aDtcbiAgICB9XG4gICAgbWF4aW11bU1vbnRoTGVuZ3RoKGNhbGVuZGFyRGF0ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRNb250aEluZm8oY2FsZW5kYXJEYXRlKS5sZW5ndGg7XG4gICAgfVxuICAgIGdldE1vbnRoSW5mbyhjYWxlbmRhckRhdGUpIHtcbiAgICAgICAgY29uc3QgeyBtb250aCB9ID0gY2FsZW5kYXJEYXRlO1xuICAgICAgICBsZXQgbW9udGhJbmZvID0gdGhpcy5tb250aHNbbW9udGhdO1xuICAgICAgICBpZiAobW9udGhJbmZvID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgSW52YWxpZCBtb250aDogJHttb250aH1gKTtcbiAgICAgICAgaWYgKHRoaXMuaW5MZWFwWWVhcihjYWxlbmRhckRhdGUpICYmIG1vbnRoSW5mby5sZWFwKVxuICAgICAgICAgICAgbW9udGhJbmZvID0gbW9udGhJbmZvLmxlYXA7XG4gICAgICAgIHJldHVybiBtb250aEluZm87XG4gICAgfVxuICAgIGVzdGltYXRlSXNvRGF0ZShjYWxlbmRhckRhdGVQYXJhbSkge1xuICAgICAgICAvLyBGWUksIHRoaXMgXCJlc3RpbWF0ZVwiIGlzIGFsd2F5cyB0aGUgZXhhY3QgSVNPIGRhdGUsIHdoaWNoIG1ha2VzIHRoZSBJbmRpYW5cbiAgICAgICAgLy8gY2FsZW5kYXIgZmFzdCFcbiAgICAgICAgY29uc3QgY2FsZW5kYXJEYXRlID0gdGhpcy5hZGp1c3RDYWxlbmRhckRhdGUoY2FsZW5kYXJEYXRlUGFyYW0pO1xuICAgICAgICBjb25zdCBtb250aEluZm8gPSB0aGlzLmdldE1vbnRoSW5mbyhjYWxlbmRhckRhdGUpO1xuICAgICAgICBjb25zdCBpc29ZZWFyID0gY2FsZW5kYXJEYXRlLnllYXIgKyA3OCArIChtb250aEluZm8ubmV4dFllYXIgPyAxIDogMCk7XG4gICAgICAgIGNvbnN0IGlzb01vbnRoID0gbW9udGhJbmZvLm1vbnRoO1xuICAgICAgICBjb25zdCBpc29EYXkgPSBtb250aEluZm8uZGF5O1xuICAgICAgICBjb25zdCBpc29EYXRlID0gQWRkSVNPRGF0ZShpc29ZZWFyLCBpc29Nb250aCwgaXNvRGF5LCAwLCAwLCAwLCBjYWxlbmRhckRhdGUuZGF5IC0gMSwgJ2NvbnN0cmFpbicpO1xuICAgICAgICByZXR1cm4gaXNvRGF0ZTtcbiAgICB9XG4gICAgY2hlY2tJY3VCdWdzKGlzb0RhdGUpIHtcbiAgICAgICAgaWYgKHRoaXMudnVsbmVyYWJsZVRvQmNlQnVnICYmIGlzb0RhdGUueWVhciA8IDEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBjYWxlbmRhciAnJHt0aGlzLmlkfScgaXMgYnJva2VuIGZvciBJU08gZGF0ZXMgYmVmb3JlIDAwMDEtMDEtMDFgICtcbiAgICAgICAgICAgICAgICAnIChzZWUgaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MTA1MjkpJyk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gYWRkcyBhZGRpdGlvbmFsIG1ldGFkYXRhIHRoYXQgbWFrZXMgaXQgZWFzaWVyIHRvIHdvcmsgd2l0aFxuICogZXJhcy4gTm90ZSB0aGF0IGl0IG11dGF0ZXMgYW5kIG5vcm1hbGl6ZXMgdGhlIG9yaWdpbmFsIGVyYSBvYmplY3RzLCB3aGljaCBpc1xuICogT0sgYmVjYXVzZSB0aGlzIGlzIG5vbi1vYnNlcnZhYmxlLCBpbnRlcm5hbC1vbmx5IG1ldGFkYXRhLlxuICpcbiAqIFRoZSByZXN1bHQgaXMgYW4gYXJyYXkgb2YgZXJhcyB3aXRoIHRoZSBzaGFwZSBkZWZpbmVkIGFib3ZlLlxuICogKi9cbmZ1bmN0aW9uIGFkanVzdEVyYXMoZXJhc1BhcmFtKSB7XG4gICAgbGV0IGVyYXMgPSBlcmFzUGFyYW07XG4gICAgaWYgKGVyYXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbnZhbGlkIGVyYSBkYXRhOiBlcmFzIGFyZSByZXF1aXJlZCcpO1xuICAgIH1cbiAgICBpZiAoZXJhcy5sZW5ndGggPT09IDEgJiYgZXJhc1swXS5yZXZlcnNlT2YpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0ludmFsaWQgZXJhIGRhdGE6IGFuY2hvciBlcmEgY2Fubm90IGNvdW50IHllYXJzIGJhY2t3YXJkcycpO1xuICAgIH1cbiAgICBpZiAoZXJhcy5sZW5ndGggPT09IDEgJiYgIWVyYXNbMF0ubmFtZSkge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW52YWxpZCBlcmEgZGF0YTogYXQgbGVhc3Qgb25lIG5hbWVkIGVyYSBpcyByZXF1aXJlZCcpO1xuICAgIH1cbiAgICBpZiAoZXJhcy5maWx0ZXIoKGUpID0+IGUucmV2ZXJzZU9mICE9IG51bGwpLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0ludmFsaWQgZXJhIGRhdGE6IG9ubHkgb25lIGVyYSBjYW4gY291bnQgeWVhcnMgYmFja3dhcmRzJyk7XG4gICAgfVxuICAgIC8vIEZpbmQgdGhlIFwiYW5jaG9yIGVyYVwiIHdoaWNoIGlzIHRoZSBlcmEgdXNlZCBmb3IgKGVyYS1sZXNzKSBgeWVhcmAuIFJldmVyc2VkXG4gICAgLy8gZXJhcyBjYW4gbmV2ZXIgYmUgYW5jaG9ycy4gVGhlIGVyYSB3aXRob3V0IGFuIGBhbmNob3JFcG9jaGAgcHJvcGVydHkgaXMgdGhlXG4gICAgLy8gYW5jaG9yLlxuICAgIGxldCBhbmNob3JFcmE7XG4gICAgZXJhcy5mb3JFYWNoKChlKSA9PiB7XG4gICAgICAgIGlmIChlLmlzQW5jaG9yIHx8ICghZS5hbmNob3JFcG9jaCAmJiAhZS5yZXZlcnNlT2YpKSB7XG4gICAgICAgICAgICBpZiAoYW5jaG9yRXJhKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbnZhbGlkIGVyYSBkYXRhOiBjYW5ub3QgaGF2ZSBtdWx0aXBsZSBhbmNob3IgZXJhcycpO1xuICAgICAgICAgICAgYW5jaG9yRXJhID0gZTtcbiAgICAgICAgICAgIGUuYW5jaG9yRXBvY2ggPSB7IHllYXI6IGUuaGFzWWVhclplcm8gPyAwIDogMSB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFlLm5hbWUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdJZiBlcmEgbmFtZSBpcyBibGFuaywgaXQgbXVzdCBiZSB0aGUgYW5jaG9yIGVyYScpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgLy8gSWYgdGhlIGVyYSBuYW1lIGlzIHVuZGVmaW5lZCwgdGhlbiBpdCdzIGFuIGFuY2hvciB0aGF0IGRvZXNuJ3QgaW50ZXJhY3RcbiAgICAvLyB3aXRoIGVyYXMgYXQgYWxsLiBGb3IgZXhhbXBsZSwgSmFwYW5lc2UgYHllYXJgIGlzIGFsd2F5cyB0aGUgc2FtZSBhcyBJU09cbiAgICAvLyBgeWVhcmAuICBTbyB0aGlzIFwiZXJhXCIgaXMgdGhlIGFuY2hvciBlcmEgYnV0IGlzbid0IHVzZWQgZm9yIGVyYSBtYXRjaGluZy5cbiAgICAvLyBTdHJpcCBpdCBmcm9tIHRoZSBsaXN0IHRoYXQncyByZXR1cm5lZC5cbiAgICBlcmFzID0gZXJhcy5maWx0ZXIoKGUpID0+IGUubmFtZSk7XG4gICAgZXJhcy5mb3JFYWNoKChlKSA9PiB7XG4gICAgICAgIC8vIFNvbWUgZXJhcyBhcmUgbWlycm9yIGltYWdlcyBvZiBhbm90aGVyIGVyYSBlLmcuIEIuQy4gaXMgdGhlIHJldmVyc2Ugb2YgQS5ELlxuICAgICAgICAvLyBSZXBsYWNlIHRoZSBzdHJpbmctdmFsdWVkIFwicmV2ZXJzZU9mXCIgcHJvcGVydHkgd2l0aCB0aGUgYWN0dWFsIGVyYSBvYmplY3RcbiAgICAgICAgLy8gdGhhdCdzIHJldmVyc2VkLlxuICAgICAgICBjb25zdCB7IHJldmVyc2VPZiB9ID0gZTtcbiAgICAgICAgaWYgKHJldmVyc2VPZikge1xuICAgICAgICAgICAgY29uc3QgcmV2ZXJzZWRFcmEgPSBlcmFzLmZpbmQoKGVyYSkgPT4gZXJhLm5hbWUgPT09IHJldmVyc2VPZik7XG4gICAgICAgICAgICBpZiAocmV2ZXJzZWRFcmEgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgSW52YWxpZCBlcmEgZGF0YTogdW5tYXRjaGVkIHJldmVyc2VPZiBlcmE6ICR7cmV2ZXJzZU9mfWApO1xuICAgICAgICAgICAgZS5yZXZlcnNlT2YgPSByZXZlcnNlZEVyYTtcbiAgICAgICAgICAgIGUuYW5jaG9yRXBvY2ggPSByZXZlcnNlZEVyYS5hbmNob3JFcG9jaDtcbiAgICAgICAgICAgIGUuaXNvRXBvY2ggPSByZXZlcnNlZEVyYS5pc29FcG9jaDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZS5hbmNob3JFcG9jaC5tb250aCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgZS5hbmNob3JFcG9jaC5tb250aCA9IDE7XG4gICAgICAgIGlmIChlLmFuY2hvckVwb2NoLmRheSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgZS5hbmNob3JFcG9jaC5kYXkgPSAxO1xuICAgIH0pO1xuICAgIC8vIEVuc3VyZSB0aGF0IHRoZSBsYXRlc3QgZXBvY2ggaXMgZmlyc3QgaW4gdGhlIGFycmF5LiBUaGlzIGxldHMgdXMgdHJ5IHRvXG4gICAgLy8gbWF0Y2ggZXJhcyBpbiBpbmRleCBvcmRlciwgd2l0aCB0aGUgbGFzdCBlcmEgZ2V0dGluZyB0aGUgcmVtYWluaW5nIG9sZGVyXG4gICAgLy8geWVhcnMuIEFueSByZXZlcnNlLXNpZ25lZCBlcmEgbXVzdCBiZSBhdCB0aGUgZW5kLlxuICAgIEFycmF5U29ydC5jYWxsKGVyYXMsIChlMSwgZTIpID0+IHtcbiAgICAgICAgaWYgKGUxLnJldmVyc2VPZilcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICBpZiAoZTIucmV2ZXJzZU9mKVxuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICBpZiAoIWUxLmlzb0Vwb2NoIHx8ICFlMi5pc29FcG9jaClcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbnZhbGlkIGVyYSBkYXRhOiBtaXNzaW5nIElTTyBlcG9jaCcpO1xuICAgICAgICByZXR1cm4gZTIuaXNvRXBvY2gueWVhciAtIGUxLmlzb0Vwb2NoLnllYXI7XG4gICAgfSk7XG4gICAgLy8gSWYgdGhlcmUncyBhIHJldmVyc2VkIGVyYSwgdGhlbiB0aGUgb25lIGJlZm9yZSBpdCBtdXN0IGJlIHRoZSBlcmEgdGhhdCdzXG4gICAgLy8gYmVpbmcgcmV2ZXJzZWQuXG4gICAgY29uc3QgbGFzdEVyYVJldmVyc2VkID0gZXJhc1tlcmFzLmxlbmd0aCAtIDFdLnJldmVyc2VPZjtcbiAgICBpZiAobGFzdEVyYVJldmVyc2VkKSB7XG4gICAgICAgIGlmIChsYXN0RXJhUmV2ZXJzZWQgIT09IGVyYXNbZXJhcy5sZW5ndGggLSAyXSlcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbnZhbGlkIGVyYSBkYXRhOiBpbnZhbGlkIHJldmVyc2Utc2lnbiBlcmEnKTtcbiAgICB9XG4gICAgLy8gRmluYWxseSwgYWRkIGEgXCJnZW5lcmljTmFtZVwiIHByb3BlcnR5IGluIHRoZSBmb3JtYXQgXCJlcmF7bn0gd2hlcmUgYG5gIGlzXG4gICAgLy8gemVyby1iYXNlZCBpbmRleCwgd2l0aCB0aGUgb2xkZXN0IGVyYSBiZWluZyB6ZXJvLiBUaGlzIGZvcm1hdCBpcyB1c2VkIGJ5XG4gICAgLy8gb2xkZXIgdmVyc2lvbnMgb2YgSUNVIGRhdGEuXG4gICAgZXJhcy5mb3JFYWNoKChlLCBpKSA9PiB7XG4gICAgICAgIGUuZ2VuZXJpY05hbWUgPSBgZXJhJHtlcmFzLmxlbmd0aCAtIDEgLSBpfWA7XG4gICAgfSk7XG4gICAgcmV0dXJuIHsgZXJhczogZXJhcywgYW5jaG9yRXJhOiAoYW5jaG9yRXJhIHx8IGVyYXNbMF0pIH07XG59XG5mdW5jdGlvbiBpc0dyZWdvcmlhbkxlYXBZZWFyKHllYXIpIHtcbiAgICByZXR1cm4geWVhciAlIDQgPT09IDAgJiYgKHllYXIgJSAxMDAgIT09IDAgfHwgeWVhciAlIDQwMCA9PT0gMCk7XG59XG4vKiogQmFzZSBmb3IgYWxsIEdyZWdvcmlhbi1saWtlIGNhbGVuZGFycy4gKi9cbmNsYXNzIEdyZWdvcmlhbkJhc2VIZWxwZXIgZXh0ZW5kcyBIZWxwZXJCYXNlIHtcbiAgICBjb25zdHJ1Y3RvcihpZCwgb3JpZ2luYWxFcmFzKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuY2FsZW5kYXJUeXBlID0gJ3NvbGFyJztcbiAgICAgICAgLy8gU2V2ZXJhbCBjYWxlbmRhcnMgYmFzZWQgb24gdGhlIEdyZWdvcmlhbiBjYWxlbmRhciB1c2UgSnVsaWFuIGRhdGVzIChub3RcbiAgICAgICAgLy8gcHJvbGVwdGljIEdyZWdvcmlhbiBkYXRlcykgYmVmb3JlIHRoZSBKdWxpYW4gc3dpdGNob3ZlciBpbiBPY3QgMTU4Mi4gU2VlXG4gICAgICAgIC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTExNzMxNTguXG4gICAgICAgIHRoaXMudjhJc1Z1bG5lcmFibGVUb0p1bGlhbkJ1ZyA9IG5ldyBEYXRlKCcrMDAxMDAxLTAxLTAxVDAwOjAwWicpXG4gICAgICAgICAgICAudG9Mb2NhbGVEYXRlU3RyaW5nKCdlbi1VUy11LWNhLWphcGFuZXNlJywgeyB0aW1lWm9uZTogJ1VUQycgfSlcbiAgICAgICAgICAgIC5zdGFydHNXaXRoKCcxMicpO1xuICAgICAgICB0aGlzLmNhbGVuZGFySXNWdWxuZXJhYmxlVG9KdWxpYW5CdWcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pZCA9IGlkO1xuICAgICAgICBjb25zdCB7IGVyYXMsIGFuY2hvckVyYSB9ID0gYWRqdXN0RXJhcyhvcmlnaW5hbEVyYXMpO1xuICAgICAgICB0aGlzLmFuY2hvckVyYSA9IGFuY2hvckVyYTtcbiAgICAgICAgdGhpcy5lcmFzID0gZXJhcztcbiAgICB9XG4gICAgaW5MZWFwWWVhcihjYWxlbmRhckRhdGUpIHtcbiAgICAgICAgLy8gQ2FsZW5kYXJzIHRoYXQgZG9uJ3Qgb3ZlcnJpZGUgdGhpcyBtZXRob2QgdXNlIHRoZSBzYW1lIG1vbnRocyBhbmQgbGVhcFxuICAgICAgICAvLyB5ZWFycyBhcyBHcmVnb3JpYW4uIE9uY2Ugd2Uga25vdyB0aGUgSVNPIHllYXIgY29ycmVzcG9uZGluZyB0byB0aGVcbiAgICAgICAgLy8gY2FsZW5kYXIgeWVhciwgd2UnbGwga25vdyBpZiBpdCdzIGEgbGVhcCB5ZWFyIG9yIG5vdC5cbiAgICAgICAgY29uc3QgeyB5ZWFyIH0gPSB0aGlzLmVzdGltYXRlSXNvRGF0ZSh7IG1vbnRoOiAxLCBkYXk6IDEsIHllYXI6IGNhbGVuZGFyRGF0ZS55ZWFyIH0pO1xuICAgICAgICByZXR1cm4gaXNHcmVnb3JpYW5MZWFwWWVhcih5ZWFyKTtcbiAgICB9XG4gICAgbW9udGhzSW5ZZWFyKCAvKiBjYWxlbmRhckRhdGUgKi8pIHtcbiAgICAgICAgcmV0dXJuIDEyO1xuICAgIH1cbiAgICBtaW5pbXVtTW9udGhMZW5ndGgoY2FsZW5kYXJEYXRlKSB7XG4gICAgICAgIGNvbnN0IHsgbW9udGggfSA9IGNhbGVuZGFyRGF0ZTtcbiAgICAgICAgaWYgKG1vbnRoID09PSAyKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5MZWFwWWVhcihjYWxlbmRhckRhdGUpID8gMjkgOiAyODtcbiAgICAgICAgcmV0dXJuIFs0LCA2LCA5LCAxMV0uaW5kZXhPZihtb250aCkgPj0gMCA/IDMwIDogMzE7XG4gICAgfVxuICAgIG1heGltdW1Nb250aExlbmd0aChjYWxlbmRhckRhdGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWluaW11bU1vbnRoTGVuZ3RoKGNhbGVuZGFyRGF0ZSk7XG4gICAgfVxuICAgIC8qKiBGaWxsIGluIG1pc3NpbmcgcGFydHMgb2YgdGhlICh5ZWFyLCBlcmEsIGVyYVllYXIpIHR1cGxlICovXG4gICAgY29tcGxldGVFcmFZZWFyKGNhbGVuZGFyRGF0ZSkge1xuICAgICAgICBjb25zdCBjaGVja0ZpZWxkID0gKG5hbWUsIHZhbHVlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50VmFsdWUgPSBjYWxlbmRhckRhdGVbbmFtZV07XG4gICAgICAgICAgICBpZiAoY3VycmVudFZhbHVlICE9IG51bGwgJiYgY3VycmVudFZhbHVlICE9IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYElucHV0ICR7bmFtZX0gJHtjdXJyZW50VmFsdWV9IGRvZXNuJ3QgbWF0Y2ggY2FsY3VsYXRlZCB2YWx1ZSAke3ZhbHVlfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBlcmFGcm9tWWVhciA9ICh5ZWFyKSA9PiB7XG4gICAgICAgICAgICBsZXQgZXJhWWVhcjtcbiAgICAgICAgICAgIGNvbnN0IGFkanVzdGVkQ2FsZW5kYXJEYXRlID0geyAuLi5jYWxlbmRhckRhdGUsIHllYXIgfTtcbiAgICAgICAgICAgIGNvbnN0IG1hdGNoaW5nRXJhID0gdGhpcy5lcmFzLmZpbmQoKGUsIGkpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoaSA9PT0gdGhpcy5lcmFzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUucmV2ZXJzZU9mKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIGEgcmV2ZXJzZS1zaWduIGVyYSAobGlrZSBCQ0UpIHdoaWNoIG11c3QgYmUgdGhlIG9sZGVzdFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXJhLiBDb3VudCB5ZWFycyBiYWNrd2FyZHMuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoeWVhciA+IDApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYFNpZ25lZCB5ZWFyICR7eWVhcn0gaXMgaW52YWxpZCBmb3IgZXJhICR7ZS5uYW1lfWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJhWWVhciA9IGUuYW5jaG9yRXBvY2gueWVhciAtIHllYXI7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBsYXN0IGVyYSBhbHdheXMgZ2V0cyBhbGwgXCJsZWZ0b3ZlclwiIChvbGRlciB0aGFuIGVwb2NoKSB5ZWFycyxcbiAgICAgICAgICAgICAgICAgICAgLy8gc28gbm8gbmVlZCBmb3IgYSBjb21wYXJpc29uIGxpa2UgYmVsb3cuXG4gICAgICAgICAgICAgICAgICAgIGVyYVllYXIgPSB5ZWFyIC0gZS5hbmNob3JFcG9jaC55ZWFyICsgKGUuaGFzWWVhclplcm8gPyAwIDogMSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBjb21wYXJpc29uID0gdGhpcy5jb21wYXJlQ2FsZW5kYXJEYXRlcyhhZGp1c3RlZENhbGVuZGFyRGF0ZSwgZS5hbmNob3JFcG9jaCk7XG4gICAgICAgICAgICAgICAgaWYgKGNvbXBhcmlzb24gPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICBlcmFZZWFyID0geWVhciAtIGUuYW5jaG9yRXBvY2gueWVhciArIChlLmhhc1llYXJaZXJvID8gMCA6IDEpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoIW1hdGNoaW5nRXJhKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBZZWFyICR7eWVhcn0gd2FzIG5vdCBtYXRjaGVkIGJ5IGFueSBlcmFgKTtcbiAgICAgICAgICAgIHJldHVybiB7IGVyYVllYXI6IGVyYVllYXIsIGVyYTogbWF0Y2hpbmdFcmEubmFtZSB9O1xuICAgICAgICB9O1xuICAgICAgICBsZXQgeyB5ZWFyLCBlcmFZZWFyLCBlcmEgfSA9IGNhbGVuZGFyRGF0ZTtcbiAgICAgICAgaWYgKHllYXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgKHsgZXJhWWVhciwgZXJhIH0gPSBlcmFGcm9tWWVhcih5ZWFyKSk7XG4gICAgICAgICAgICBjaGVja0ZpZWxkKCdlcmEnLCBlcmEpO1xuICAgICAgICAgICAgY2hlY2tGaWVsZCgnZXJhWWVhcicsIGVyYVllYXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGVyYVllYXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgbWF0Y2hpbmdFcmEgPSBlcmEgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IHRoaXMuZXJhcy5maW5kKChlKSA9PiBlLm5hbWUgPT09IGVyYSB8fCBlLmdlbmVyaWNOYW1lID09PSBlcmEpO1xuICAgICAgICAgICAgaWYgKCFtYXRjaGluZ0VyYSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgRXJhICR7ZXJhfSAoSVNPIHllYXIgJHtlcmFZZWFyfSkgd2FzIG5vdCBtYXRjaGVkIGJ5IGFueSBlcmFgKTtcbiAgICAgICAgICAgIGlmIChlcmFZZWFyIDwgMSAmJiBtYXRjaGluZ0VyYS5yZXZlcnNlT2YpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgWWVhcnMgaW4gJHtlcmF9IGVyYSBtdXN0IGJlIHBvc2l0aXZlLCBub3QgJHt5ZWFyfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1hdGNoaW5nRXJhLnJldmVyc2VPZikge1xuICAgICAgICAgICAgICAgIHllYXIgPSBtYXRjaGluZ0VyYS5hbmNob3JFcG9jaC55ZWFyIC0gZXJhWWVhcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHllYXIgPSBlcmFZZWFyICsgbWF0Y2hpbmdFcmEuYW5jaG9yRXBvY2gueWVhciAtIChtYXRjaGluZ0VyYS5oYXNZZWFyWmVybyA/IDAgOiAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNoZWNrRmllbGQoJ3llYXInLCB5ZWFyKTtcbiAgICAgICAgICAgIC8vIFdlJ2xsIGFjY2VwdCBkYXRlcyB3aGVyZSB0aGUgbW9udGgvZGF5IGlzIGVhcmxpZXIgdGhhbiB0aGUgc3RhcnQgb2ZcbiAgICAgICAgICAgIC8vIHRoZSBlcmEgb3IgYWZ0ZXIgaXRzIGVuZCBhcyBsb25nIGFzIGl0J3MgaW4gdGhlIHNhbWUgeWVhci4gSWYgdGhhdFxuICAgICAgICAgICAgLy8gaGFwcGVucywgd2UnbGwgYWRqdXN0IHRoZSBlcmEvZXJhWWVhciBwYWlyIHRvIGJlIHRoZSBjb3JyZWN0IGVyYSBmb3JcbiAgICAgICAgICAgIC8vIHRoZSBgeWVhcmAuXG4gICAgICAgICAgICAoeyBlcmFZZWFyLCBlcmEgfSA9IGVyYUZyb21ZZWFyKHllYXIpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdFaXRoZXIgYHllYXJgIG9yIGBlcmFZZWFyYCBhbmQgYGVyYWAgYXJlIHJlcXVpcmVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgLi4uY2FsZW5kYXJEYXRlLCB5ZWFyLCBlcmFZZWFyLCBlcmEgfTtcbiAgICB9XG4gICAgYWRqdXN0Q2FsZW5kYXJEYXRlKGNhbGVuZGFyRGF0ZVBhcmFtLCBjYWNoZSwgb3ZlcmZsb3cgPSAnY29uc3RyYWluJykge1xuICAgICAgICBsZXQgY2FsZW5kYXJEYXRlID0gY2FsZW5kYXJEYXRlUGFyYW07XG4gICAgICAgIC8vIEJlY2F1c2UgdGhpcyBpcyBub3QgYSBsdW5pc29sYXIgY2FsZW5kYXIsIGl0J3Mgc2FmZSB0byBjb252ZXJ0IG1vbnRoQ29kZSB0byBhIG51bWJlclxuICAgICAgICBjb25zdCB7IG1vbnRoLCBtb250aENvZGUgfSA9IGNhbGVuZGFyRGF0ZTtcbiAgICAgICAgaWYgKG1vbnRoID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICBjYWxlbmRhckRhdGUgPSB7IC4uLmNhbGVuZGFyRGF0ZSwgbW9udGg6IG1vbnRoQ29kZU51bWJlclBhcnQobW9udGhDb2RlKSB9O1xuICAgICAgICB0aGlzLnZhbGlkYXRlQ2FsZW5kYXJEYXRlKGNhbGVuZGFyRGF0ZSk7XG4gICAgICAgIGNhbGVuZGFyRGF0ZSA9IHRoaXMuY29tcGxldGVFcmFZZWFyKGNhbGVuZGFyRGF0ZSk7XG4gICAgICAgIHJldHVybiBzdXBlci5hZGp1c3RDYWxlbmRhckRhdGUoY2FsZW5kYXJEYXRlLCBjYWNoZSwgb3ZlcmZsb3cpO1xuICAgIH1cbiAgICBlc3RpbWF0ZUlzb0RhdGUoY2FsZW5kYXJEYXRlUGFyYW0pIHtcbiAgICAgICAgY29uc3QgY2FsZW5kYXJEYXRlID0gdGhpcy5hZGp1c3RDYWxlbmRhckRhdGUoY2FsZW5kYXJEYXRlUGFyYW0pO1xuICAgICAgICBjb25zdCB7IHllYXIsIG1vbnRoLCBkYXkgfSA9IGNhbGVuZGFyRGF0ZTtcbiAgICAgICAgY29uc3QgeyBhbmNob3JFcmEgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IGlzb1llYXJFc3RpbWF0ZSA9IHllYXIgKyBhbmNob3JFcmEuaXNvRXBvY2gueWVhciAtIChhbmNob3JFcmEuaGFzWWVhclplcm8gPyAwIDogMSk7XG4gICAgICAgIHJldHVybiBSZWd1bGF0ZUlTT0RhdGUoaXNvWWVhckVzdGltYXRlLCBtb250aCwgZGF5LCAnY29uc3RyYWluJyk7XG4gICAgfVxuICAgIGNoZWNrSWN1QnVncyhpc29EYXRlKSB7XG4gICAgICAgIGlmICh0aGlzLmNhbGVuZGFySXNWdWxuZXJhYmxlVG9KdWxpYW5CdWcgJiYgdGhpcy52OElzVnVsbmVyYWJsZVRvSnVsaWFuQnVnKSB7XG4gICAgICAgICAgICBjb25zdCBiZWZvcmVKdWxpYW5Td2l0Y2ggPSBDb21wYXJlSVNPRGF0ZShpc29EYXRlLnllYXIsIGlzb0RhdGUubW9udGgsIGlzb0RhdGUuZGF5LCAxNTgyLCAxMCwgMTUpIDwgMDtcbiAgICAgICAgICAgIGlmIChiZWZvcmVKdWxpYW5Td2l0Y2gpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgY2FsZW5kYXIgJyR7dGhpcy5pZH0nIGlzIGJyb2tlbiBmb3IgSVNPIGRhdGVzIGJlZm9yZSAxNTgyLTEwLTE1YCArXG4gICAgICAgICAgICAgICAgICAgICcgKHNlZSBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0xMTczMTU4KScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuY2xhc3MgT3J0aG9kb3hCYXNlSGVscGVyIGV4dGVuZHMgR3JlZ29yaWFuQmFzZUhlbHBlciB7XG4gICAgY29uc3RydWN0b3IoaWQsIG9yaWdpbmFsRXJhcykge1xuICAgICAgICBzdXBlcihpZCwgb3JpZ2luYWxFcmFzKTtcbiAgICB9XG4gICAgaW5MZWFwWWVhcihjYWxlbmRhckRhdGUpIHtcbiAgICAgICAgLy8gTGVhcCB5ZWFycyBoYXBwZW4gb25lIHllYXIgYmVmb3JlIHRoZSBKdWxpYW4gbGVhcCB5ZWFyLiBOb3RlIHRoYXQgdGhpc1xuICAgICAgICAvLyBjYWxlbmRhciBpcyBiYXNlZCBvbiB0aGUgSnVsaWFuIGNhbGVuZGFyIHdoaWNoIGhhcyBhIGxlYXAgeWVhciBldmVyeSA0XG4gICAgICAgIC8vIHllYXJzLCB1bmxpa2UgdGhlIEdyZWdvcmlhbiBjYWxlbmRhciB3aGljaCBkb2Vzbid0IGhhdmUgbGVhcCB5ZWFycyBvblxuICAgICAgICAvLyB5ZWFycyBkaXZpc2libGUgYnkgMTAwIGV4Y2VwdCB5ZWFycyBkaXZpc2libGUgYnkgNDAwLlxuICAgICAgICAvL1xuICAgICAgICAvLyBOb3RlIHRoYXQgd2UncmUgYXNzdW1pbmcgdGhhdCBsZWFwIHllYXJzIGluIGJlZm9yZS1lcG9jaCB0aW1lcyBtYXRjaFxuICAgICAgICAvLyBob3cgbGVhcCB5ZWFycyBhcmUgZGVmaW5lZCBub3cuIFRoaXMgaXMgcHJvYmFibHkgbm90IGFjY3VyYXRlIGJ1dCBJJ21cbiAgICAgICAgLy8gbm90IHN1cmUgaG93IGJldHRlciB0byBkbyBpdC5cbiAgICAgICAgY29uc3QgeyB5ZWFyIH0gPSBjYWxlbmRhckRhdGU7XG4gICAgICAgIHJldHVybiAoeWVhciArIDEpICUgNCA9PT0gMDtcbiAgICB9XG4gICAgbW9udGhzSW5ZZWFyKCAvKiBjYWxlbmRhckRhdGUgKi8pIHtcbiAgICAgICAgcmV0dXJuIDEzO1xuICAgIH1cbiAgICBtaW5pbXVtTW9udGhMZW5ndGgoY2FsZW5kYXJEYXRlKSB7XG4gICAgICAgIGNvbnN0IHsgbW9udGggfSA9IGNhbGVuZGFyRGF0ZTtcbiAgICAgICAgLy8gRXRoaW9waWFuL0NvcHRpYyBjYWxlbmRhcnMgaGF2ZSAxMiAzMC1kYXkgbW9udGhzIGFuZCBhbiBleHRyYSA1LTYgZGF5IDEzdGggbW9udGguXG4gICAgICAgIGlmIChtb250aCA9PT0gMTMpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbkxlYXBZZWFyKGNhbGVuZGFyRGF0ZSkgPyA2IDogNTtcbiAgICAgICAgcmV0dXJuIDMwO1xuICAgIH1cbiAgICBtYXhpbXVtTW9udGhMZW5ndGgoY2FsZW5kYXJEYXRlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pbmltdW1Nb250aExlbmd0aChjYWxlbmRhckRhdGUpO1xuICAgIH1cbn1cbi8vIGBjb3B0aWNgIGFuZCBgZXRoaW9waWNgIGNhbGVuZGFycyBhcmUgdmVyeSBzaW1pbGFyIHRvIGBldGhpb2FhYCBjYWxlbmRhcixcbi8vIHdpdGggdGhlIGZvbGxvd2luZyBkaWZmZXJlbmNlczpcbi8vIC0gQ29wdGljIHVzZXMgQkNFLWxpa2UgcG9zaXRpdmUgbnVtYmVycyBmb3IgeWVhcnMgYmVmb3JlIGl0cyBlcG9jaCAodGhlIG90aGVyXG4vLyAgIHR3byB1c2UgbmVnYXRpdmUgeWVhciBudW1iZXJzIGJlZm9yZSBlcG9jaClcbi8vIC0gQ29wdGljIGhhcyBhIGRpZmZlcmVudCBlcG9jaCBkYXRlXG4vLyAtIEV0aGlvcGljIGhhcyBhbiBhZGRpdGlvbmFsIHNlY29uZCBlcmEgdGhhdCBzdGFydHMgYXQgdGhlIHNhbWUgZGF0ZSBhcyB0aGVcbi8vICAgemVybyBlcmEgb2YgZXRoaW9hYS5cbmNsYXNzIEV0aGlvYWFIZWxwZXIgZXh0ZW5kcyBPcnRob2RveEJhc2VIZWxwZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcignZXRoaW9hYScsIFt7IG5hbWU6ICdlcmEwJywgaXNvRXBvY2g6IHsgeWVhcjogLTU0OTIsIG1vbnRoOiA3LCBkYXk6IDE3IH0gfV0pO1xuICAgIH1cbn1cbmNsYXNzIENvcHRpY0hlbHBlciBleHRlbmRzIE9ydGhvZG94QmFzZUhlbHBlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCdjb3B0aWMnLCBbXG4gICAgICAgICAgICB7IG5hbWU6ICdlcmExJywgaXNvRXBvY2g6IHsgeWVhcjogMjg0LCBtb250aDogOCwgZGF5OiAyOSB9IH0sXG4gICAgICAgICAgICB7IG5hbWU6ICdlcmEwJywgcmV2ZXJzZU9mOiAnZXJhMScgfVxuICAgICAgICBdKTtcbiAgICB9XG59XG4vLyBBbmNob3IgaXMgY3VycmVudGx5IHRoZSBvbGRlciBlcmEgdG8gbWF0Y2ggZXRoaW9hYSwgYnV0IHNob3VsZCBpdCBiZSB0aGUgbmV3ZXIgZXJhP1xuLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L2VjbWE0MDIvaXNzdWVzLzUzNCBmb3IgZGlzY3Vzc2lvbi5cbmNsYXNzIEV0aGlvcGljSGVscGVyIGV4dGVuZHMgT3J0aG9kb3hCYXNlSGVscGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoJ2V0aGlvcGljJywgW1xuICAgICAgICAgICAgeyBuYW1lOiAnZXJhMCcsIGlzb0Vwb2NoOiB7IHllYXI6IC01NDkyLCBtb250aDogNywgZGF5OiAxNyB9IH0sXG4gICAgICAgICAgICB7IG5hbWU6ICdlcmExJywgaXNvRXBvY2g6IHsgeWVhcjogOCwgbW9udGg6IDgsIGRheTogMjcgfSwgYW5jaG9yRXBvY2g6IHsgeWVhcjogNTUwMSB9IH1cbiAgICAgICAgXSk7XG4gICAgfVxufVxuY2xhc3MgUm9jSGVscGVyIGV4dGVuZHMgR3JlZ29yaWFuQmFzZUhlbHBlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCdyb2MnLCBbXG4gICAgICAgICAgICB7IG5hbWU6ICdtaW5ndW8nLCBpc29FcG9jaDogeyB5ZWFyOiAxOTEyLCBtb250aDogMSwgZGF5OiAxIH0gfSxcbiAgICAgICAgICAgIHsgbmFtZTogJ2JlZm9yZS1yb2MnLCByZXZlcnNlT2Y6ICdtaW5ndW8nIH1cbiAgICAgICAgXSk7XG4gICAgICAgIHRoaXMuY2FsZW5kYXJJc1Z1bG5lcmFibGVUb0p1bGlhbkJ1ZyA9IHRydWU7XG4gICAgfVxufVxuY2xhc3MgQnVkZGhpc3RIZWxwZXIgZXh0ZW5kcyBHcmVnb3JpYW5CYXNlSGVscGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoJ2J1ZGRoaXN0JywgW3sgbmFtZTogJ2JlJywgaGFzWWVhclplcm86IHRydWUsIGlzb0Vwb2NoOiB7IHllYXI6IC01NDMsIG1vbnRoOiAxLCBkYXk6IDEgfSB9XSk7XG4gICAgICAgIHRoaXMuY2FsZW5kYXJJc1Z1bG5lcmFibGVUb0p1bGlhbkJ1ZyA9IHRydWU7XG4gICAgfVxufVxuY2xhc3MgR3JlZ29yeUhlbHBlciBleHRlbmRzIEdyZWdvcmlhbkJhc2VIZWxwZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcignZ3JlZ29yeScsIFtcbiAgICAgICAgICAgIHsgbmFtZTogJ2NlJywgaXNvRXBvY2g6IHsgeWVhcjogMSwgbW9udGg6IDEsIGRheTogMSB9IH0sXG4gICAgICAgICAgICB7IG5hbWU6ICdiY2UnLCByZXZlcnNlT2Y6ICdjZScgfVxuICAgICAgICBdKTtcbiAgICB9XG4gICAgcmV2aXNlSW50bEVyYShjYWxlbmRhckRhdGUgLyosIGlzb0RhdGU6IElzb0RhdGUqLykge1xuICAgICAgICBsZXQgeyBlcmEsIGVyYVllYXIgfSA9IGNhbGVuZGFyRGF0ZTtcbiAgICAgICAgLy8gRmlyZWZveCA5NiBpbnRyb2R1Y2VkIGEgYnVnIHdoZXJlIHRoZSBgJ3Nob3J0J2AgZm9ybWF0IG9mIHRoZSBlcmFcbiAgICAgICAgLy8gb3B0aW9uIG1pc3Rha2VubHkgcmV0dXJucyB0aGUgb25lLWxldHRlciAobmFycm93KSBmb3JtYXQgaW5zdGVhZC4gVGhlXG4gICAgICAgIC8vIGNvZGUgYmVsb3cgaGFuZGxlcyBlaXRoZXIgdGhlIGNvcnJlY3Qgb3IgRmlyZWZveC1idWdneSBmb3JtYXQuIFNlZVxuICAgICAgICAvLyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0xNzUyMjUzXG4gICAgICAgIGlmIChlcmEgPT09ICdiYycgfHwgZXJhID09PSAnYicpXG4gICAgICAgICAgICBlcmEgPSAnYmNlJztcbiAgICAgICAgaWYgKGVyYSA9PT0gJ2FkJyB8fCBlcmEgPT09ICdhJylcbiAgICAgICAgICAgIGVyYSA9ICdjZSc7XG4gICAgICAgIHJldHVybiB7IGVyYSwgZXJhWWVhciB9O1xuICAgIH1cbn1cbi8vIE5PVEU6IE9ubHkgdGhlIDUgbW9kZXJuIGVyYXMgKE1laWppIGFuZCBsYXRlcikgYXJlIGluY2x1ZGVkLiBGb3IgZGF0ZXNcbi8vIGJlZm9yZSBNZWlqaSAxLCB0aGUgYGNlYCBhbmQgYGJjZWAgZXJhcyBhcmUgdXNlZC4gQ2hhbGxlbmdlcyB3aXRoIHByZS1NZWlqaVxuLy8gZXJhcyBpbmNsdWRlOlxuLy8gLSBTdGFydC9lbmQgZGF0ZXMgb2Ygb2xkZXIgZXJhcyBhcmUgbm90IHByZWNpc2VseSBkZWZpbmVkLCB3aGljaCBpc1xuLy8gICBjaGFsbGVuZ2luZyBnaXZlbiBUZW1wb3JhbCdzIG5lZWQgZm9yIHByZWNpc2lvblxuLy8gLSBTb21lIGVyYSBkYXRlcyBhbmQvb3IgbmFtZXMgYXJlIGRpc3B1dGVkIGJ5IGhpc3RvcmlhbnNcbi8vIC0gQXMgaGlzdG9yaWNhbCByZXNlYXJjaCBwcm9jZWVkcywgbmV3IGVyYXMgYXJlIGRpc2NvdmVyZWQgYW5kIGV4aXN0aW5nIGVyYVxuLy8gICBkYXRlcyBhcmUgbW9kaWZpZWQsIGxlYWRpbmcgdG8gY29uc2lkZXJhYmxlIGNodXJuIHdoaWNoIGlzIG5vdCBnb29kIGZvclxuLy8gICBUZW1wb3JhbCB1c2UuXG4vLyAgLSBUaGUgZWFybGllc3QgZXJhIChpbiA2NDUgQ0UpIG1heSBub3QgZW5kIHVwIGJlaW5nIHRoZSBlYXJsaWVzdCBkZXBlbmRpbmdcbi8vICAgIG9uIGZ1dHVyZSBoaXN0b3JpY2FsIHNjaG9sYXJzaGlwXG4vLyAgLSBCZWZvcmUgTWVpamksIEphcGFuIHVzZWQgYSBsdW5hciAob3IgbHVuaXNvbGFyPykgY2FsZW5kYXIgYnV0IEFGQUlLXG4vLyAgICB0aGF0J3Mgbm90IHJlZmxlY3RlZCBpbiB0aGUgSUNVIGltcGxlbWVudGF0aW9uLlxuLy9cbi8vIEZvciBtb3JlIGRpc2N1c3Npb246IGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLXRlbXBvcmFsL2lzc3Vlcy81MjYuXG4vL1xuLy8gSGVyZSdzIGEgZnVsbCBsaXN0IG9mIENMRFIvSUNVIGVyYXM6XG4vLyBodHRwczovL2dpdGh1Yi5jb20vdW5pY29kZS1vcmcvaWN1L2Jsb2IvbWFzdGVyL2ljdTRjL3NvdXJjZS9kYXRhL2xvY2FsZXMvcm9vdC50eHQjTDE1ODItTDE4MThcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS91bmljb2RlLW9yZy9jbGRyL2Jsb2IvbWFzdGVyL2NvbW1vbi9zdXBwbGVtZW50YWwvc3VwcGxlbWVudGFsRGF0YS54bWwjTDQzMTAtTDQ1NDZcbi8vXG4vLyBOT1RFOiBKYXBhbiBzdGFydGVkIHVzaW5nIHRoZSBHcmVnb3JpYW4gY2FsZW5kYXIgaW4gNiBNZWlqaSwgcmVwbGFjaW5nIGFcbi8vIGx1bmlzb2xhciBjYWxlbmRhci4gU28gdGhlIGRheSBiZWZvcmUgSmFudWFyeSAxIG9mIDYgTWVpamkgKDE4NzMpIHdhcyBub3Rcbi8vIERlY2VtYmVyIDMxLCBidXQgRGVjZW1iZXIgMiwgb2YgNSBNZWlqaSAoMTg3MikuIFRoZSBleGlzdGluZyBFY21hLTQwMlxuLy8gSmFwYW5lc2UgY2FsZW5kYXIgZG9lc24ndCBzZWVtIHRvIHRha2UgdGhpcyBpbnRvIGFjY291bnQsIHNvIG5laXRoZXIgZG8gd2U6XG4vLyA+IGFyZ3MgPSBbJ2VuLWNhLXUtY2EtamFwYW5lc2UnLCB7IGVyYTogJ3Nob3J0JyB9XVxuLy8gPiBuZXcgRGF0ZSgnMTg3My0wMS0wMVQxMjowMCcpLnRvTG9jYWxlU3RyaW5nKC4uLmFyZ3MpXG4vLyAnMSAxLCA2IE1laWppLCAxMjowMDowMCBQTSdcbi8vID4gbmV3IERhdGUoJzE4NzItMTItMzFUMTI6MDAnKS50b0xvY2FsZVN0cmluZyguLi5hcmdzKVxuLy8gJzEyIDMxLCA1IE1laWppLCAxMjowMDowMCBQTSdcbmNsYXNzIEphcGFuZXNlSGVscGVyIGV4dGVuZHMgR3JlZ29yaWFuQmFzZUhlbHBlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCdqYXBhbmVzZScsIFtcbiAgICAgICAgICAgIC8vIFRoZSBKYXBhbmVzZSBjYWxlbmRhciBgeWVhcmAgaXMganVzdCB0aGUgSVNPIHllYXIsIGJlY2F1c2UgKHVubGlrZSBvdGhlclxuICAgICAgICAgICAgLy8gSUNVIGNhbGVuZGFycykgdGhlcmUncyBubyBvYnZpb3VzIFwiZGVmYXVsdCBlcmFcIiwgd2UgdXNlIHRoZSBJU08geWVhci5cbiAgICAgICAgICAgIHsgbmFtZTogJ3JlaXdhJywgaXNvRXBvY2g6IHsgeWVhcjogMjAxOSwgbW9udGg6IDUsIGRheTogMSB9LCBhbmNob3JFcG9jaDogeyB5ZWFyOiAyMDE5LCBtb250aDogNSwgZGF5OiAxIH0gfSxcbiAgICAgICAgICAgIHsgbmFtZTogJ2hlaXNlaScsIGlzb0Vwb2NoOiB7IHllYXI6IDE5ODksIG1vbnRoOiAxLCBkYXk6IDggfSwgYW5jaG9yRXBvY2g6IHsgeWVhcjogMTk4OSwgbW9udGg6IDEsIGRheTogOCB9IH0sXG4gICAgICAgICAgICB7IG5hbWU6ICdzaG93YScsIGlzb0Vwb2NoOiB7IHllYXI6IDE5MjYsIG1vbnRoOiAxMiwgZGF5OiAyNSB9LCBhbmNob3JFcG9jaDogeyB5ZWFyOiAxOTI2LCBtb250aDogMTIsIGRheTogMjUgfSB9LFxuICAgICAgICAgICAgeyBuYW1lOiAndGFpc2hvJywgaXNvRXBvY2g6IHsgeWVhcjogMTkxMiwgbW9udGg6IDcsIGRheTogMzAgfSwgYW5jaG9yRXBvY2g6IHsgeWVhcjogMTkxMiwgbW9udGg6IDcsIGRheTogMzAgfSB9LFxuICAgICAgICAgICAgeyBuYW1lOiAnbWVpamknLCBpc29FcG9jaDogeyB5ZWFyOiAxODY4LCBtb250aDogOSwgZGF5OiA4IH0sIGFuY2hvckVwb2NoOiB7IHllYXI6IDE4NjgsIG1vbnRoOiA5LCBkYXk6IDggfSB9LFxuICAgICAgICAgICAgeyBuYW1lOiAnY2UnLCBpc29FcG9jaDogeyB5ZWFyOiAxLCBtb250aDogMSwgZGF5OiAxIH0gfSxcbiAgICAgICAgICAgIHsgbmFtZTogJ2JjZScsIHJldmVyc2VPZjogJ2NlJyB9XG4gICAgICAgIF0pO1xuICAgICAgICB0aGlzLmNhbGVuZGFySXNWdWxuZXJhYmxlVG9KdWxpYW5CdWcgPSB0cnVlO1xuICAgICAgICAvLyBUaGUgbGFzdCAzIEphcGFuZXNlIGVyYXMgY29uZnVzaW5nbHkgcmV0dXJuIG9ubHkgb25lIGNoYXJhY3RlciBpbiB0aGVcbiAgICAgICAgLy8gZGVmYXVsdCBcInNob3J0XCIgZXJhLCBzbyBuZWVkIHRvIHVzZSB0aGUgbG9uZyBmb3JtYXQuXG4gICAgICAgIHRoaXMuZXJhTGVuZ3RoID0gJ2xvbmcnO1xuICAgIH1cbiAgICByZXZpc2VJbnRsRXJhKGNhbGVuZGFyRGF0ZSwgaXNvRGF0ZSkge1xuICAgICAgICBjb25zdCB7IGVyYSwgZXJhWWVhciB9ID0gY2FsZW5kYXJEYXRlO1xuICAgICAgICBjb25zdCB7IHllYXI6IGlzb1llYXIgfSA9IGlzb0RhdGU7XG4gICAgICAgIGlmICh0aGlzLmVyYXMuZmluZCgoZSkgPT4gZS5uYW1lID09PSBlcmEpKVxuICAgICAgICAgICAgcmV0dXJuIHsgZXJhLCBlcmFZZWFyIH07XG4gICAgICAgIHJldHVybiAoaXNvWWVhciA8IDEgPyB7IGVyYTogJ2JjZScsIGVyYVllYXI6IDEgLSBpc29ZZWFyIH0gOiB7IGVyYTogJ2NlJywgZXJhWWVhcjogaXNvWWVhciB9KTtcbiAgICB9XG59XG5jbGFzcyBDaGluZXNlQmFzZUhlbHBlciBleHRlbmRzIEhlbHBlckJhc2Uge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLmNhbGVuZGFyVHlwZSA9ICdsdW5pc29sYXInO1xuICAgICAgICAvLyBBbGwgYnVpbHQtaW4gY2FsZW5kYXJzIGV4Y2VwdCBDaGluZXNlL0RhbmdpIGFuZCBIZWJyZXcgdXNlIGFuIGVyYVxuICAgICAgICB0aGlzLmhhc0VyYSA9IGZhbHNlO1xuICAgIH1cbiAgICBpbkxlYXBZZWFyKGNhbGVuZGFyRGF0ZSwgY2FjaGUpIHtcbiAgICAgICAgY29uc3QgbW9udGhzID0gdGhpcy5nZXRNb250aExpc3QoY2FsZW5kYXJEYXRlLnllYXIsIGNhY2hlKTtcbiAgICAgICAgcmV0dXJuIE9iamVjdEVudHJpZXMobW9udGhzKS5sZW5ndGggPT09IDEzO1xuICAgIH1cbiAgICBtb250aHNJblllYXIoY2FsZW5kYXJEYXRlLCBjYWNoZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbkxlYXBZZWFyKGNhbGVuZGFyRGF0ZSwgY2FjaGUpID8gMTMgOiAxMjtcbiAgICB9XG4gICAgbWluaW11bU1vbnRoTGVuZ3RoKCAvKiBjYWxlbmRhckRhdGUgKi8pIHtcbiAgICAgICAgcmV0dXJuIDI5O1xuICAgIH1cbiAgICBtYXhpbXVtTW9udGhMZW5ndGgoIC8qIGNhbGVuZGFyRGF0ZSAqLykge1xuICAgICAgICByZXR1cm4gMzA7XG4gICAgfVxuICAgIGdldE1vbnRoTGlzdChjYWxlbmRhclllYXIsIGNhY2hlKSB7XG4gICAgICAgIGlmIChjYWxlbmRhclllYXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignTWlzc2luZyB5ZWFyJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qga2V5ID0gSlNPTi5zdHJpbmdpZnkoeyBmdW5jOiAnZ2V0TW9udGhMaXN0JywgY2FsZW5kYXJZZWFyLCBpZDogdGhpcy5pZCB9KTtcbiAgICAgICAgY29uc3QgY2FjaGVkID0gY2FjaGUuZ2V0KGtleSk7XG4gICAgICAgIGlmIChjYWNoZWQpXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkO1xuICAgICAgICBjb25zdCBkYXRlVGltZUZvcm1hdCA9IHRoaXMuZ2V0Rm9ybWF0dGVyKCk7XG4gICAgICAgIGNvbnN0IGdldENhbGVuZGFyRGF0ZSA9IChpc29ZZWFyLCBkYXlzUGFzdEZlYjEpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGlzb1N0cmluZ0ZlYjEgPSB0b1V0Y0lzb0RhdGVTdHJpbmcoeyBpc29ZZWFyLCBpc29Nb250aDogMiwgaXNvRGF5OiAxIH0pO1xuICAgICAgICAgICAgY29uc3QgbGVnYWN5RGF0ZSA9IG5ldyBEYXRlKGlzb1N0cmluZ0ZlYjEpO1xuICAgICAgICAgICAgLy8gTm93IGFkZCB0aGUgcmVxdWVzdGVkIG51bWJlciBvZiBkYXlzLCB3aGljaCBtYXkgd3JhcCB0byB0aGUgbmV4dCBtb250aC5cbiAgICAgICAgICAgIGxlZ2FjeURhdGUuc2V0VVRDRGF0ZShkYXlzUGFzdEZlYjEgKyAxKTtcbiAgICAgICAgICAgIGNvbnN0IG5ld1llYXJHdWVzcyA9IGRhdGVUaW1lRm9ybWF0LmZvcm1hdFRvUGFydHMobGVnYWN5RGF0ZSk7XG4gICAgICAgICAgICBjb25zdCBjYWxlbmRhck1vbnRoU3RyaW5nID0gbmV3WWVhckd1ZXNzLmZpbmQoKHR2KSA9PiB0di50eXBlID09PSAnbW9udGgnKS52YWx1ZTtcbiAgICAgICAgICAgIGNvbnN0IGNhbGVuZGFyRGF5ID0gK25ld1llYXJHdWVzcy5maW5kKCh0dikgPT4gdHYudHlwZSA9PT0gJ2RheScpLnZhbHVlO1xuICAgICAgICAgICAgbGV0IGNhbGVuZGFyWWVhclRvVmVyaWZ5ID0gbmV3WWVhckd1ZXNzLmZpbmQoKHR2KSA9PiB0di50eXBlID09PSAncmVsYXRlZFllYXInKTtcbiAgICAgICAgICAgIGlmIChjYWxlbmRhclllYXJUb1ZlcmlmeSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgY2FsZW5kYXJZZWFyVG9WZXJpZnkgPSArY2FsZW5kYXJZZWFyVG9WZXJpZnkudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBOb2RlIDEyIGhhcyBvdXRkYXRlZCBJQ1UgZGF0YSB0aGF0IGxhY2tzIHRoZSBgcmVsYXRlZFllYXJgIGZpZWxkIGluIHRoZVxuICAgICAgICAgICAgICAgIC8vIG91dHB1dCBvZiBJbnRsLkRhdGVUaW1lRm9ybWF0LmZvcm1hdFRvUGFydHMuXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYEludGwuRGF0ZVRpbWVGb3JtYXQuZm9ybWF0VG9QYXJ0cyBsYWNrcyByZWxhdGVkWWVhciBpbiAke3RoaXMuaWR9IGNhbGVuZGFyLiBUcnkgTm9kZSAxNCsgb3IgbW9kZXJuIGJyb3dzZXJzLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHsgY2FsZW5kYXJNb250aFN0cmluZywgY2FsZW5kYXJEYXksIGNhbGVuZGFyWWVhclRvVmVyaWZ5IH07XG4gICAgICAgIH07XG4gICAgICAgIC8vIEZpcnN0LCBmaW5kIGEgZGF0ZSBjbG9zZSB0byBDaGluZXNlIE5ldyBZZWFyLiBGZWIgMTcgd2lsbCBlaXRoZXIgYmUgaW5cbiAgICAgICAgLy8gdGhlIGZpcnN0IG1vbnRoIG9yIG5lYXIgdGhlIGVuZCBvZiB0aGUgbGFzdCBtb250aCBvZiB0aGUgcHJldmlvdXMgeWVhci5cbiAgICAgICAgbGV0IGlzb0RheXNEZWx0YSA9IDE3O1xuICAgICAgICBsZXQgeyBjYWxlbmRhck1vbnRoU3RyaW5nLCBjYWxlbmRhckRheSwgY2FsZW5kYXJZZWFyVG9WZXJpZnkgfSA9IGdldENhbGVuZGFyRGF0ZShjYWxlbmRhclllYXIsIGlzb0RheXNEZWx0YSk7XG4gICAgICAgIC8vIElmIHdlIGRpZG4ndCBndWVzcyB0aGUgZmlyc3QgbW9udGggY29ycmVjdGx5LCBhZGQgKGFsbW9zdCBpbiBzb21lIG1vbnRocylcbiAgICAgICAgLy8gYSBsdW5hciBtb250aFxuICAgICAgICBpZiAoY2FsZW5kYXJNb250aFN0cmluZyAhPT0gJzEnKSB7XG4gICAgICAgICAgICBpc29EYXlzRGVsdGEgKz0gMjk7XG4gICAgICAgICAgICAoeyBjYWxlbmRhck1vbnRoU3RyaW5nLCBjYWxlbmRhckRheSB9ID0gZ2V0Q2FsZW5kYXJEYXRlKGNhbGVuZGFyWWVhciwgaXNvRGF5c0RlbHRhKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm93IGJhY2sgdXAgdG8gbmVhciB0aGUgc3RhcnQgb2YgdGhlIGZpcnN0IG1vbnRoLCBidXQgbm90IHRvbyBuZWFyIHRoYXRcbiAgICAgICAgLy8gb2ZmLWJ5LW9uZSBpc3N1ZXMgbWF0dGVyLlxuICAgICAgICBpc29EYXlzRGVsdGEgLT0gY2FsZW5kYXJEYXkgLSA1O1xuICAgICAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICAgICAgbGV0IG1vbnRoSW5kZXggPSAxO1xuICAgICAgICBsZXQgb2xkQ2FsZW5kYXJEYXk7XG4gICAgICAgIGxldCBvbGRNb250aFN0cmluZztcbiAgICAgICAgbGV0IGRvbmUgPSBmYWxzZTtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgKHsgY2FsZW5kYXJNb250aFN0cmluZywgY2FsZW5kYXJEYXksIGNhbGVuZGFyWWVhclRvVmVyaWZ5IH0gPSBnZXRDYWxlbmRhckRhdGUoY2FsZW5kYXJZZWFyLCBpc29EYXlzRGVsdGEpKTtcbiAgICAgICAgICAgIGlmIChvbGRDYWxlbmRhckRheSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdFtvbGRNb250aFN0cmluZ10uZGF5c0luTW9udGggPSBvbGRDYWxlbmRhckRheSArIDMwIC0gY2FsZW5kYXJEYXk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2FsZW5kYXJZZWFyVG9WZXJpZnkgIT09IGNhbGVuZGFyWWVhcikge1xuICAgICAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W2NhbGVuZGFyTW9udGhTdHJpbmddID0geyBtb250aEluZGV4OiBtb250aEluZGV4KysgfTtcbiAgICAgICAgICAgICAgICAvLyBNb3ZlIHRvIHRoZSBuZXh0IG1vbnRoLiBCZWNhdXNlIG1vbnRocyBhcmUgc29tZXRpbWVzIDI5IGRheXMsIHRoZSBkYXkgb2YgdGhlXG4gICAgICAgICAgICAgICAgLy8gY2FsZW5kYXIgbW9udGggd2lsbCBtb3ZlIGZvcndhcmQgc2xvd2x5IGJ1dCBub3QgZW5vdWdoIHRvIGZsaXAgb3ZlciB0byBhIG5ld1xuICAgICAgICAgICAgICAgIC8vIG1vbnRoIGJlZm9yZSB0aGUgbG9vcCBlbmRzIGF0IDEyLTEzIG1vbnRocy5cbiAgICAgICAgICAgICAgICBpc29EYXlzRGVsdGEgKz0gMzA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvbGRDYWxlbmRhckRheSA9IGNhbGVuZGFyRGF5O1xuICAgICAgICAgICAgb2xkTW9udGhTdHJpbmcgPSBjYWxlbmRhck1vbnRoU3RyaW5nO1xuICAgICAgICB9IHdoaWxlICghZG9uZSk7XG4gICAgICAgIHJlc3VsdFtvbGRNb250aFN0cmluZ10uZGF5c0luTW9udGggPSBvbGRDYWxlbmRhckRheSArIDMwIC0gY2FsZW5kYXJEYXk7XG4gICAgICAgIGNhY2hlLnNldChrZXksIHJlc3VsdCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGVzdGltYXRlSXNvRGF0ZShjYWxlbmRhckRhdGUpIHtcbiAgICAgICAgY29uc3QgeyB5ZWFyLCBtb250aCB9ID0gY2FsZW5kYXJEYXRlO1xuICAgICAgICByZXR1cm4geyB5ZWFyLCBtb250aDogbW9udGggPj0gMTIgPyAxMiA6IG1vbnRoICsgMSwgZGF5OiAxIH07XG4gICAgfVxuICAgIGFkanVzdENhbGVuZGFyRGF0ZShjYWxlbmRhckRhdGUsIGNhY2hlLCBvdmVyZmxvdyA9ICdjb25zdHJhaW4nLCBmcm9tTGVnYWN5RGF0ZSA9IGZhbHNlKSB7XG4gICAgICAgIGxldCB7IHllYXIsIG1vbnRoLCBtb250aEV4dHJhLCBkYXksIG1vbnRoQ29kZSwgZXJhWWVhciB9ID0gY2FsZW5kYXJEYXRlO1xuICAgICAgICBpZiAoZnJvbUxlZ2FjeURhdGUpIHtcbiAgICAgICAgICAgIC8vIExlZ2FjeSBEYXRlIG91dHB1dCByZXR1cm5zIGEgc3RyaW5nIHRoYXQncyBhbiBpbnRlZ2VyIHdpdGggYW4gb3B0aW9uYWxcbiAgICAgICAgICAgIC8vIFwiYmlzXCIgc3VmZml4IHVzZWQgb25seSBieSB0aGUgQ2hpbmVzZS9EYW5naSBjYWxlbmRhciB0byBpbmRpY2F0ZSBhIGxlYXBcbiAgICAgICAgICAgIC8vIG1vbnRoLiBCZWxvdyB3ZSdsbCBub3JtYWxpemUgdGhlIG91dHB1dC5cbiAgICAgICAgICAgIHllYXIgPSBlcmFZZWFyO1xuICAgICAgICAgICAgaWYgKG1vbnRoRXh0cmEgJiYgbW9udGhFeHRyYSAhPT0gJ2JpcycpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYFVuZXhwZWN0ZWQgbGVhcCBtb250aCBzdWZmaXg6ICR7bW9udGhFeHRyYX1gKTtcbiAgICAgICAgICAgIGNvbnN0IG1vbnRoQ29kZSA9IGJ1aWxkTW9udGhDb2RlKG1vbnRoLCBtb250aEV4dHJhICE9PSB1bmRlZmluZWQpO1xuICAgICAgICAgICAgY29uc3QgbW9udGhTdHJpbmcgPSBgJHttb250aH0ke21vbnRoRXh0cmEgfHwgJyd9YDtcbiAgICAgICAgICAgIGNvbnN0IG1vbnRocyA9IHRoaXMuZ2V0TW9udGhMaXN0KHllYXIsIGNhY2hlKTtcbiAgICAgICAgICAgIGNvbnN0IG1vbnRoSW5mbyA9IG1vbnRoc1ttb250aFN0cmluZ107XG4gICAgICAgICAgICBpZiAobW9udGhJbmZvID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYFVubWF0Y2hlZCBtb250aCAke21vbnRoU3RyaW5nfSBpbiBDaGluZXNlIHllYXIgJHt5ZWFyfWApO1xuICAgICAgICAgICAgbW9udGggPSBtb250aEluZm8ubW9udGhJbmRleDtcbiAgICAgICAgICAgIHJldHVybiB7IHllYXI6IHllYXIsIG1vbnRoLCBkYXk6IGRheSwgZXJhOiB1bmRlZmluZWQsIGVyYVllYXIsIG1vbnRoQ29kZSB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gV2hlbiBjYWxsZWQgd2l0aG91dCBpbnB1dCBjb21pbmcgZnJvbSBsZWdhY3kgRGF0ZSBvdXRwdXQsXG4gICAgICAgICAgICAvLyBzaW1wbHkgZW5zdXJlIHRoYXQgYWxsIGZpZWxkcyBhcmUgcHJlc2VudC5cbiAgICAgICAgICAgIHRoaXMudmFsaWRhdGVDYWxlbmRhckRhdGUoY2FsZW5kYXJEYXRlKTtcbiAgICAgICAgICAgIGlmICh5ZWFyID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgeWVhciA9IGVyYVllYXI7XG4gICAgICAgICAgICBpZiAoZXJhWWVhciA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIGVyYVllYXIgPSB5ZWFyO1xuICAgICAgICAgICAgaWYgKG1vbnRoID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtb250aHMgPSB0aGlzLmdldE1vbnRoTGlzdCh5ZWFyLCBjYWNoZSk7XG4gICAgICAgICAgICAgICAgbGV0IG51bWJlclBhcnQgPSBtb250aENvZGUucmVwbGFjZSgnTCcsICdiaXMnKS5zbGljZSgxKTtcbiAgICAgICAgICAgICAgICBpZiAobnVtYmVyUGFydFswXSA9PT0gJzAnKVxuICAgICAgICAgICAgICAgICAgICBudW1iZXJQYXJ0ID0gbnVtYmVyUGFydC5zbGljZSgxKTtcbiAgICAgICAgICAgICAgICBsZXQgbW9udGhJbmZvID0gbW9udGhzW251bWJlclBhcnRdO1xuICAgICAgICAgICAgICAgIG1vbnRoID0gbW9udGhJbmZvICYmIG1vbnRoSW5mby5tb250aEluZGV4O1xuICAgICAgICAgICAgICAgIC8vIElmIHRoaXMgbGVhcCBtb250aCBpc24ndCBwcmVzZW50IGluIHRoaXMgeWVhciwgY29uc3RyYWluIGRvd24gdG8gdGhlIGxhc3QgZGF5IG9mIHRoZSBwcmV2aW91cyBtb250aC5cbiAgICAgICAgICAgICAgICBpZiAobW9udGggPT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgICAgICBtb250aENvZGUuZW5kc1dpdGgoJ0wnKSAmJlxuICAgICAgICAgICAgICAgICAgICAhQXJyYXlJbmNsdWRlcy5jYWxsKFsnTTAxTCcsICdNMTJMJywgJ00xM0wnXSwgbW9udGhDb2RlKSAmJlxuICAgICAgICAgICAgICAgICAgICBvdmVyZmxvdyA9PT0gJ2NvbnN0cmFpbicpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHdpdGhvdXRNTCA9IG1vbnRoQ29kZS5zbGljZSgxLCAtMSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh3aXRob3V0TUxbMF0gPT09ICcwJylcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpdGhvdXRNTCA9IHdpdGhvdXRNTC5zbGljZSgxKTtcbiAgICAgICAgICAgICAgICAgICAgbW9udGhJbmZvID0gbW9udGhzW3dpdGhvdXRNTF07XG4gICAgICAgICAgICAgICAgICAgIGlmIChtb250aEluZm8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICh7IGRheXNJbk1vbnRoOiBkYXksIG1vbnRoSW5kZXg6IG1vbnRoIH0gPSBtb250aEluZm8pO1xuICAgICAgICAgICAgICAgICAgICAgICAgbW9udGhDb2RlID0gYnVpbGRNb250aENvZGUod2l0aG91dE1MKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobW9udGggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgVW5tYXRjaGVkIG1vbnRoICR7bW9udGhDb2RlfSBpbiBDaGluZXNlIHllYXIgJHt5ZWFyfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG1vbnRoQ29kZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbW9udGhzID0gdGhpcy5nZXRNb250aExpc3QoeWVhciwgY2FjaGUpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG1vbnRoRW50cmllcyA9IE9iamVjdEVudHJpZXMobW9udGhzKTtcbiAgICAgICAgICAgICAgICBjb25zdCBsYXJnZXN0TW9udGggPSBtb250aEVudHJpZXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGlmIChvdmVyZmxvdyA9PT0gJ3JlamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgUmVqZWN0VG9SYW5nZShtb250aCwgMSwgbGFyZ2VzdE1vbnRoKTtcbiAgICAgICAgICAgICAgICAgICAgUmVqZWN0VG9SYW5nZShkYXksIDEsIHRoaXMubWF4aW11bU1vbnRoTGVuZ3RoKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbW9udGggPSBDb25zdHJhaW5Ub1JhbmdlKG1vbnRoLCAxLCBsYXJnZXN0TW9udGgpO1xuICAgICAgICAgICAgICAgICAgICBkYXkgPSBDb25zdHJhaW5Ub1JhbmdlKGRheSwgMSwgdGhpcy5tYXhpbXVtTW9udGhMZW5ndGgoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IG1hdGNoaW5nTW9udGhFbnRyeSA9IG1vbnRoRW50cmllcy5maW5kKChbLCB2XSkgPT4gdi5tb250aEluZGV4ID09PSBtb250aCk7XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoaW5nTW9udGhFbnRyeSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBJbnZhbGlkIG1vbnRoICR7bW9udGh9IGluIENoaW5lc2UgeWVhciAke3llYXJ9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG1vbnRoQ29kZSA9IGJ1aWxkTW9udGhDb2RlKG1hdGNoaW5nTW9udGhFbnRyeVswXS5yZXBsYWNlKCdiaXMnLCAnJyksIG1hdGNoaW5nTW9udGhFbnRyeVswXS5pbmRleE9mKCdiaXMnKSAhPT0gLTEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gQm90aCBtb250aCBhbmQgbW9udGhDb2RlIGFyZSBwcmVzZW50LiBNYWtlIHN1cmUgdGhleSBkb24ndCBjb25mbGljdC5cbiAgICAgICAgICAgICAgICBjb25zdCBtb250aHMgPSB0aGlzLmdldE1vbnRoTGlzdCh5ZWFyLCBjYWNoZSk7XG4gICAgICAgICAgICAgICAgbGV0IG51bWJlclBhcnQgPSBtb250aENvZGUucmVwbGFjZSgnTCcsICdiaXMnKS5zbGljZSgxKTtcbiAgICAgICAgICAgICAgICBpZiAobnVtYmVyUGFydFswXSA9PT0gJzAnKVxuICAgICAgICAgICAgICAgICAgICBudW1iZXJQYXJ0ID0gbnVtYmVyUGFydC5zbGljZSgxKTtcbiAgICAgICAgICAgICAgICBjb25zdCBtb250aEluZm8gPSBtb250aHNbbnVtYmVyUGFydF07XG4gICAgICAgICAgICAgICAgaWYgKCFtb250aEluZm8pXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBVbm1hdGNoZWQgbW9udGhDb2RlICR7bW9udGhDb2RlfSBpbiBDaGluZXNlIHllYXIgJHt5ZWFyfWApO1xuICAgICAgICAgICAgICAgIGlmIChtb250aCAhPT0gbW9udGhJbmZvLm1vbnRoSW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYG1vbnRoQ29kZSAke21vbnRoQ29kZX0gZG9lc24ndCBjb3JyZXNwb25kIHRvIG1vbnRoICR7bW9udGh9IGluIENoaW5lc2UgeWVhciAke3llYXJ9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAuLi5jYWxlbmRhckRhdGUsXG4gICAgICAgICAgICAgICAgeWVhcjogeWVhcixcbiAgICAgICAgICAgICAgICBlcmFZZWFyLFxuICAgICAgICAgICAgICAgIG1vbnRoLFxuICAgICAgICAgICAgICAgIG1vbnRoQ29kZTogbW9udGhDb2RlLFxuICAgICAgICAgICAgICAgIGRheTogZGF5XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxufVxuY2xhc3MgQ2hpbmVzZUhlbHBlciBleHRlbmRzIENoaW5lc2VCYXNlSGVscGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5pZCA9ICdjaGluZXNlJztcbiAgICB9XG59XG4vLyBEYW5naSAoS29yZWFuKSBjYWxlbmRhciBoYXMgc2FtZSBpbXBsZW1lbnRhdGlvbiBhcyBDaGluZXNlXG5jbGFzcyBEYW5naUhlbHBlciBleHRlbmRzIENoaW5lc2VCYXNlSGVscGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5pZCA9ICdkYW5naSc7XG4gICAgfVxufVxuLyoqXG4gKiBDb21tb24gaW1wbGVtZW50YXRpb24gb2YgYWxsIG5vbi1JU08gY2FsZW5kYXJzLlxuICogUGVyLWNhbGVuZGFyIGlkIGFuZCBsb2dpYyBsaXZlIGluIGBpZGAgYW5kIGBoZWxwZXJgIHByb3BlcnRpZXMgYXR0YWNoZWQgbGF0ZXIuXG4gKiBUaGlzIHNwbGl0IGFsbG93ZWQgYW4gZWFzeSBzZXBhcmF0aW9uIGJldHdlZW4gY29kZSB0aGF0IHdhcyBzaW1pbGFyIGJldHdlZW5cbiAqIElTTyBhbmQgbm9uLUlTTyBpbXBsZW1lbnRhdGlvbnMgdnMuIGNvZGUgdGhhdCB3YXMgdmVyeSBkaWZmZXJlbnQuXG4gKi9cbmNvbnN0IG5vbklzb0ltcGwgPSB7XG4gICAgLy8gYGhlbHBlcmAgaXMgYWRkZWQgd2hlbiB0aGlzIG9iamVjdCBpcyBzcHJlYWQgaW50byBlYWNoIGNhbGVuZGFyJ3NcbiAgICAvLyBpbXBsZW1lbnRhdGlvblxuICAgIGhlbHBlcjogdW5kZWZpbmVkLFxuICAgIGRhdGVGcm9tRmllbGRzKGZpZWxkc1BhcmFtLCBvcHRpb25zLCBjYWxlbmRhcikge1xuICAgICAgICBjb25zdCBvdmVyZmxvdyA9IFRvVGVtcG9yYWxPdmVyZmxvdyhvcHRpb25zKTtcbiAgICAgICAgY29uc3QgY2FjaGUgPSBuZXcgT25lT2JqZWN0Q2FjaGUoKTtcbiAgICAgICAgLy8gSW50ZW50aW9uYWxseSBhbHBoYWJldGljYWxcbiAgICAgICAgY29uc3QgZmllbGRzID0gUHJlcGFyZVRlbXBvcmFsRmllbGRzKGZpZWxkc1BhcmFtLCBbXG4gICAgICAgICAgICBbJ2RheSddLFxuICAgICAgICAgICAgWydlcmEnLCB1bmRlZmluZWRdLFxuICAgICAgICAgICAgWydlcmFZZWFyJywgdW5kZWZpbmVkXSxcbiAgICAgICAgICAgIFsnbW9udGgnLCB1bmRlZmluZWRdLFxuICAgICAgICAgICAgWydtb250aENvZGUnLCB1bmRlZmluZWRdLFxuICAgICAgICAgICAgWyd5ZWFyJywgdW5kZWZpbmVkXVxuICAgICAgICBdKTtcbiAgICAgICAgY29uc3QgeyB5ZWFyLCBtb250aCwgZGF5IH0gPSB0aGlzLmhlbHBlci5jYWxlbmRhclRvSXNvRGF0ZShmaWVsZHMsIG92ZXJmbG93LCBjYWNoZSk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IENyZWF0ZVRlbXBvcmFsRGF0ZSh5ZWFyLCBtb250aCwgZGF5LCBjYWxlbmRhcik7XG4gICAgICAgIGNhY2hlLnNldE9iamVjdChyZXN1bHQpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG4gICAgeWVhck1vbnRoRnJvbUZpZWxkcyhmaWVsZHNQYXJhbSwgb3B0aW9ucywgY2FsZW5kYXIpIHtcbiAgICAgICAgY29uc3Qgb3ZlcmZsb3cgPSBUb1RlbXBvcmFsT3ZlcmZsb3cob3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IGNhY2hlID0gbmV3IE9uZU9iamVjdENhY2hlKCk7XG4gICAgICAgIC8vIEludGVudGlvbmFsbHkgYWxwaGFiZXRpY2FsXG4gICAgICAgIGNvbnN0IGZpZWxkcyA9IFByZXBhcmVUZW1wb3JhbEZpZWxkcyhmaWVsZHNQYXJhbSwgW1xuICAgICAgICAgICAgWydlcmEnLCB1bmRlZmluZWRdLFxuICAgICAgICAgICAgWydlcmFZZWFyJywgdW5kZWZpbmVkXSxcbiAgICAgICAgICAgIFsnbW9udGgnLCB1bmRlZmluZWRdLFxuICAgICAgICAgICAgWydtb250aENvZGUnLCB1bmRlZmluZWRdLFxuICAgICAgICAgICAgWyd5ZWFyJywgdW5kZWZpbmVkXVxuICAgICAgICBdKTtcbiAgICAgICAgY29uc3QgeyB5ZWFyLCBtb250aCwgZGF5IH0gPSB0aGlzLmhlbHBlci5jYWxlbmRhclRvSXNvRGF0ZSh7IC4uLmZpZWxkcywgZGF5OiAxIH0sIG92ZXJmbG93LCBjYWNoZSk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IENyZWF0ZVRlbXBvcmFsWWVhck1vbnRoKHllYXIsIG1vbnRoLCBjYWxlbmRhciwgLyogcmVmZXJlbmNlSVNPRGF5ID0gKi8gZGF5KTtcbiAgICAgICAgY2FjaGUuc2V0T2JqZWN0KHJlc3VsdCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcbiAgICBtb250aERheUZyb21GaWVsZHMoZmllbGRzUGFyYW0sIG9wdGlvbnMsIGNhbGVuZGFyKSB7XG4gICAgICAgIGNvbnN0IG92ZXJmbG93ID0gVG9UZW1wb3JhbE92ZXJmbG93KG9wdGlvbnMpO1xuICAgICAgICAvLyBBbGwgYnVpbHQtaW4gY2FsZW5kYXJzIHJlcXVpcmUgYGRheWAsIGJ1dCBzb21lIGFsbG93IG90aGVyIGZpZWxkcyB0byBiZVxuICAgICAgICAvLyBzdWJzdGl0dXRlZCBmb3IgYG1vbnRoYC4gQW5kIGZvciBsdW5pc29sYXIgY2FsZW5kYXJzLCBlaXRoZXIgYG1vbnRoQ29kZWBcbiAgICAgICAgLy8gb3IgYHllYXJgIG11c3QgYmUgcHJvdmlkZWQgYmVjYXVzZSBgbW9udGhgIGlzIGFtYmlndW91cyB3aXRob3V0IGEgeWVhciBvclxuICAgICAgICAvLyBhIGNvZGUuXG4gICAgICAgIGNvbnN0IGNhY2hlID0gbmV3IE9uZU9iamVjdENhY2hlKCk7XG4gICAgICAgIGNvbnN0IGZpZWxkcyA9IFByZXBhcmVUZW1wb3JhbEZpZWxkcyhmaWVsZHNQYXJhbSwgW1xuICAgICAgICAgICAgWydkYXknXSxcbiAgICAgICAgICAgIFsnZXJhJywgdW5kZWZpbmVkXSxcbiAgICAgICAgICAgIFsnZXJhWWVhcicsIHVuZGVmaW5lZF0sXG4gICAgICAgICAgICBbJ21vbnRoJywgdW5kZWZpbmVkXSxcbiAgICAgICAgICAgIFsnbW9udGhDb2RlJywgdW5kZWZpbmVkXSxcbiAgICAgICAgICAgIFsneWVhcicsIHVuZGVmaW5lZF1cbiAgICAgICAgXSk7XG4gICAgICAgIGNvbnN0IHsgeWVhciwgbW9udGgsIGRheSB9ID0gdGhpcy5oZWxwZXIubW9udGhEYXlGcm9tRmllbGRzKGZpZWxkcywgb3ZlcmZsb3csIGNhY2hlKTtcbiAgICAgICAgLy8gYHllYXJgIGlzIGEgcmVmZXJlbmNlIHllYXIgd2hlcmUgdGhpcyBtb250aC9kYXkgZXhpc3RzIGluIHRoaXMgY2FsZW5kYXJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gQ3JlYXRlVGVtcG9yYWxNb250aERheShtb250aCwgZGF5LCBjYWxlbmRhciwgLyogcmVmZXJlbmNlSVNPWWVhciA9ICovIHllYXIpO1xuICAgICAgICBjYWNoZS5zZXRPYmplY3QocmVzdWx0KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuICAgIGZpZWxkcyhmaWVsZHNQYXJhbSkge1xuICAgICAgICBsZXQgZmllbGRzID0gZmllbGRzUGFyYW07XG4gICAgICAgIGlmIChBcnJheUluY2x1ZGVzLmNhbGwoZmllbGRzLCAneWVhcicpKVxuICAgICAgICAgICAgZmllbGRzID0gWy4uLmZpZWxkcywgJ2VyYScsICdlcmFZZWFyJ107XG4gICAgICAgIHJldHVybiBmaWVsZHM7XG4gICAgfSxcbiAgICBtZXJnZUZpZWxkcyhmaWVsZHMsIGFkZGl0aW9uYWxGaWVsZHMpIHtcbiAgICAgICAgY29uc3QgZmllbGRzQ29weSA9IHsgLi4uZmllbGRzIH07XG4gICAgICAgIGNvbnN0IGFkZGl0aW9uYWxGaWVsZHNDb3B5ID0geyAuLi5hZGRpdGlvbmFsRmllbGRzIH07XG4gICAgICAgIC8vIGVyYSBhbmQgZXJhWWVhciBhcmUgaW50ZW50aW9uYWxseSB1bnVzZWRcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgICAgICBjb25zdCB7IG1vbnRoLCBtb250aENvZGUsIHllYXIsIGVyYSwgZXJhWWVhciwgLi4ub3JpZ2luYWwgfSA9IGZpZWxkc0NvcHk7XG4gICAgICAgIGNvbnN0IHsgbW9udGg6IG5ld01vbnRoLCBtb250aENvZGU6IG5ld01vbnRoQ29kZSwgeWVhcjogbmV3WWVhciwgZXJhOiBuZXdFcmEsIGVyYVllYXI6IG5ld0VyYVllYXIgfSA9IGFkZGl0aW9uYWxGaWVsZHNDb3B5O1xuICAgICAgICBpZiAobmV3TW9udGggPT09IHVuZGVmaW5lZCAmJiBuZXdNb250aENvZGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgb3JpZ2luYWwubW9udGggPSBtb250aDtcbiAgICAgICAgICAgIG9yaWdpbmFsLm1vbnRoQ29kZSA9IG1vbnRoQ29kZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmV3WWVhciA9PT0gdW5kZWZpbmVkICYmIG5ld0VyYSA9PT0gdW5kZWZpbmVkICYmIG5ld0VyYVllYXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gT25seSBgeWVhcmAgaXMgbmVlZGVkLiBXZSBkb24ndCBzZXQgZXJhIGFuZCBlcmFZZWFyIGJlY2F1c2UgaXQnc1xuICAgICAgICAgICAgLy8gcG9zc2libGUgdG8gY3JlYXRlIGEgY29uZmxpY3QgZm9yIGVyYXMgdGhhdCBzdGFydCBvciBlbmQgbWlkLXllYXIuIFNlZVxuICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtdGVtcG9yYWwvaXNzdWVzLzE3ODQuXG4gICAgICAgICAgICBvcmlnaW5hbC55ZWFyID0geWVhcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyAuLi5vcmlnaW5hbCwgLi4uYWRkaXRpb25hbEZpZWxkc0NvcHkgfTtcbiAgICB9LFxuICAgIGRhdGVBZGQoZGF0ZSwgeWVhcnMsIG1vbnRocywgd2Vla3MsIGRheXMsIG92ZXJmbG93LCBjYWxlbmRhcikge1xuICAgICAgICBjb25zdCBjYWNoZSA9IE9uZU9iamVjdENhY2hlLmdldENhY2hlRm9yT2JqZWN0KGRhdGUpO1xuICAgICAgICBjb25zdCBjYWxlbmRhckRhdGUgPSB0aGlzLmhlbHBlci50ZW1wb3JhbFRvQ2FsZW5kYXJEYXRlKGRhdGUsIGNhY2hlKTtcbiAgICAgICAgY29uc3QgYWRkZWQgPSB0aGlzLmhlbHBlci5hZGRDYWxlbmRhcihjYWxlbmRhckRhdGUsIHsgeWVhcnMsIG1vbnRocywgd2Vla3MsIGRheXMgfSwgb3ZlcmZsb3csIGNhY2hlKTtcbiAgICAgICAgY29uc3QgaXNvQWRkZWQgPSB0aGlzLmhlbHBlci5jYWxlbmRhclRvSXNvRGF0ZShhZGRlZCwgJ2NvbnN0cmFpbicsIGNhY2hlKTtcbiAgICAgICAgY29uc3QgeyB5ZWFyLCBtb250aCwgZGF5IH0gPSBpc29BZGRlZDtcbiAgICAgICAgY29uc3QgbmV3VGVtcG9yYWxPYmplY3QgPSBDcmVhdGVUZW1wb3JhbERhdGUoeWVhciwgbW9udGgsIGRheSwgY2FsZW5kYXIpO1xuICAgICAgICAvLyBUaGUgbmV3IG9iamVjdCdzIGNhY2hlIHN0YXJ0cyB3aXRoIHRoZSBjYWNoZSBvZiB0aGUgb2xkIG9iamVjdFxuICAgICAgICBjb25zdCBuZXdDYWNoZSA9IG5ldyBPbmVPYmplY3RDYWNoZShjYWNoZSk7XG4gICAgICAgIG5ld0NhY2hlLnNldE9iamVjdChuZXdUZW1wb3JhbE9iamVjdCk7XG4gICAgICAgIHJldHVybiBuZXdUZW1wb3JhbE9iamVjdDtcbiAgICB9LFxuICAgIGRhdGVVbnRpbChvbmUsIHR3bywgbGFyZ2VzdFVuaXQpIHtcbiAgICAgICAgY29uc3QgY2FjaGVPbmUgPSBPbmVPYmplY3RDYWNoZS5nZXRDYWNoZUZvck9iamVjdChvbmUpO1xuICAgICAgICBjb25zdCBjYWNoZVR3byA9IE9uZU9iamVjdENhY2hlLmdldENhY2hlRm9yT2JqZWN0KHR3byk7XG4gICAgICAgIGNvbnN0IGNhbGVuZGFyT25lID0gdGhpcy5oZWxwZXIudGVtcG9yYWxUb0NhbGVuZGFyRGF0ZShvbmUsIGNhY2hlT25lKTtcbiAgICAgICAgY29uc3QgY2FsZW5kYXJUd28gPSB0aGlzLmhlbHBlci50ZW1wb3JhbFRvQ2FsZW5kYXJEYXRlKHR3bywgY2FjaGVUd28pO1xuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLmhlbHBlci51bnRpbENhbGVuZGFyKGNhbGVuZGFyT25lLCBjYWxlbmRhclR3bywgbGFyZ2VzdFVuaXQsIGNhY2hlT25lKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuICAgIHllYXIoZGF0ZSkge1xuICAgICAgICBjb25zdCBjYWNoZSA9IE9uZU9iamVjdENhY2hlLmdldENhY2hlRm9yT2JqZWN0KGRhdGUpO1xuICAgICAgICBjb25zdCBjYWxlbmRhckRhdGUgPSB0aGlzLmhlbHBlci50ZW1wb3JhbFRvQ2FsZW5kYXJEYXRlKGRhdGUsIGNhY2hlKTtcbiAgICAgICAgcmV0dXJuIGNhbGVuZGFyRGF0ZS55ZWFyO1xuICAgIH0sXG4gICAgbW9udGgoZGF0ZSkge1xuICAgICAgICBjb25zdCBjYWNoZSA9IE9uZU9iamVjdENhY2hlLmdldENhY2hlRm9yT2JqZWN0KGRhdGUpO1xuICAgICAgICBjb25zdCBjYWxlbmRhckRhdGUgPSB0aGlzLmhlbHBlci50ZW1wb3JhbFRvQ2FsZW5kYXJEYXRlKGRhdGUsIGNhY2hlKTtcbiAgICAgICAgcmV0dXJuIGNhbGVuZGFyRGF0ZS5tb250aDtcbiAgICB9LFxuICAgIGRheShkYXRlKSB7XG4gICAgICAgIGNvbnN0IGNhY2hlID0gT25lT2JqZWN0Q2FjaGUuZ2V0Q2FjaGVGb3JPYmplY3QoZGF0ZSk7XG4gICAgICAgIGNvbnN0IGNhbGVuZGFyRGF0ZSA9IHRoaXMuaGVscGVyLnRlbXBvcmFsVG9DYWxlbmRhckRhdGUoZGF0ZSwgY2FjaGUpO1xuICAgICAgICByZXR1cm4gY2FsZW5kYXJEYXRlLmRheTtcbiAgICB9LFxuICAgIGVyYShkYXRlKSB7XG4gICAgICAgIGlmICghdGhpcy5oZWxwZXIuaGFzRXJhKVxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3QgY2FjaGUgPSBPbmVPYmplY3RDYWNoZS5nZXRDYWNoZUZvck9iamVjdChkYXRlKTtcbiAgICAgICAgY29uc3QgY2FsZW5kYXJEYXRlID0gdGhpcy5oZWxwZXIudGVtcG9yYWxUb0NhbGVuZGFyRGF0ZShkYXRlLCBjYWNoZSk7XG4gICAgICAgIHJldHVybiBjYWxlbmRhckRhdGUuZXJhO1xuICAgIH0sXG4gICAgZXJhWWVhcihkYXRlKSB7XG4gICAgICAgIGlmICghdGhpcy5oZWxwZXIuaGFzRXJhKVxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3QgY2FjaGUgPSBPbmVPYmplY3RDYWNoZS5nZXRDYWNoZUZvck9iamVjdChkYXRlKTtcbiAgICAgICAgY29uc3QgY2FsZW5kYXJEYXRlID0gdGhpcy5oZWxwZXIudGVtcG9yYWxUb0NhbGVuZGFyRGF0ZShkYXRlLCBjYWNoZSk7XG4gICAgICAgIHJldHVybiBjYWxlbmRhckRhdGUuZXJhWWVhcjtcbiAgICB9LFxuICAgIG1vbnRoQ29kZShkYXRlKSB7XG4gICAgICAgIGNvbnN0IGNhY2hlID0gT25lT2JqZWN0Q2FjaGUuZ2V0Q2FjaGVGb3JPYmplY3QoZGF0ZSk7XG4gICAgICAgIGNvbnN0IGNhbGVuZGFyRGF0ZSA9IHRoaXMuaGVscGVyLnRlbXBvcmFsVG9DYWxlbmRhckRhdGUoZGF0ZSwgY2FjaGUpO1xuICAgICAgICByZXR1cm4gY2FsZW5kYXJEYXRlLm1vbnRoQ29kZTtcbiAgICB9LFxuICAgIGRheU9mV2VlayhkYXRlKSB7XG4gICAgICAgIHJldHVybiBpbXBsWydpc284NjAxJ10uZGF5T2ZXZWVrKGRhdGUpO1xuICAgIH0sXG4gICAgZGF5T2ZZZWFyKGRhdGUpIHtcbiAgICAgICAgY29uc3QgY2FjaGUgPSBPbmVPYmplY3RDYWNoZS5nZXRDYWNoZUZvck9iamVjdChkYXRlKTtcbiAgICAgICAgY29uc3QgY2FsZW5kYXJEYXRlID0gdGhpcy5oZWxwZXIuaXNvVG9DYWxlbmRhckRhdGUoZGF0ZSwgY2FjaGUpO1xuICAgICAgICBjb25zdCBzdGFydE9mWWVhciA9IHRoaXMuaGVscGVyLnN0YXJ0T2ZDYWxlbmRhclllYXIoY2FsZW5kYXJEYXRlKTtcbiAgICAgICAgY29uc3QgZGlmZkRheXMgPSB0aGlzLmhlbHBlci5jYWxlbmRhckRheXNVbnRpbChzdGFydE9mWWVhciwgY2FsZW5kYXJEYXRlLCBjYWNoZSk7XG4gICAgICAgIHJldHVybiBkaWZmRGF5cyArIDE7XG4gICAgfSxcbiAgICB3ZWVrT2ZZZWFyKGRhdGUpIHtcbiAgICAgICAgcmV0dXJuIGltcGxbJ2lzbzg2MDEnXS53ZWVrT2ZZZWFyKGRhdGUpO1xuICAgIH0sXG4gICAgZGF5c0luV2VlayhkYXRlKSB7XG4gICAgICAgIHJldHVybiBpbXBsWydpc284NjAxJ10uZGF5c0luV2VlayhkYXRlKTtcbiAgICB9LFxuICAgIGRheXNJbk1vbnRoKGRhdGUpIHtcbiAgICAgICAgY29uc3QgY2FjaGUgPSBPbmVPYmplY3RDYWNoZS5nZXRDYWNoZUZvck9iamVjdChkYXRlKTtcbiAgICAgICAgY29uc3QgY2FsZW5kYXJEYXRlID0gdGhpcy5oZWxwZXIudGVtcG9yYWxUb0NhbGVuZGFyRGF0ZShkYXRlLCBjYWNoZSk7XG4gICAgICAgIC8vIEVhc3kgY2FzZTogaWYgdGhlIGhlbHBlciBrbm93cyB0aGUgbGVuZ3RoIHdpdGhvdXQgYW55IGhlYXZ5IGNhbGN1bGF0aW9uLlxuICAgICAgICBjb25zdCBtYXggPSB0aGlzLmhlbHBlci5tYXhpbXVtTW9udGhMZW5ndGgoY2FsZW5kYXJEYXRlKTtcbiAgICAgICAgY29uc3QgbWluID0gdGhpcy5oZWxwZXIubWluaW11bU1vbnRoTGVuZ3RoKGNhbGVuZGFyRGF0ZSk7XG4gICAgICAgIGlmIChtYXggPT09IG1pbilcbiAgICAgICAgICAgIHJldHVybiBtYXg7XG4gICAgICAgIC8vIFRoZSBoYXJkZXIgY2FzZSBpcyB3aGVyZSBtb250aHMgdmFyeSBldmVyeSB5ZWFyLCBlLmcuIGlzbGFtaWMgY2FsZW5kYXJzLlxuICAgICAgICAvLyBGaW5kIHRoZSBhbnN3ZXIgYnkgY2FsY3VsYXRpbmcgdGhlIGRpZmZlcmVuY2UgaW4gZGF5cyBiZXR3ZWVuIHRoZSBmaXJzdFxuICAgICAgICAvLyBkYXkgb2YgdGhlIGN1cnJlbnQgbW9udGggYW5kIHRoZSBmaXJzdCBkYXkgb2YgdGhlIG5leHQgbW9udGguXG4gICAgICAgIGNvbnN0IHN0YXJ0T2ZNb250aENhbGVuZGFyID0gdGhpcy5oZWxwZXIuc3RhcnRPZkNhbGVuZGFyTW9udGgoY2FsZW5kYXJEYXRlKTtcbiAgICAgICAgY29uc3Qgc3RhcnRPZk5leHRNb250aENhbGVuZGFyID0gdGhpcy5oZWxwZXIuYWRkTW9udGhzQ2FsZW5kYXIoc3RhcnRPZk1vbnRoQ2FsZW5kYXIsIDEsICdjb25zdHJhaW4nLCBjYWNoZSk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuaGVscGVyLmNhbGVuZGFyRGF5c1VudGlsKHN0YXJ0T2ZNb250aENhbGVuZGFyLCBzdGFydE9mTmV4dE1vbnRoQ2FsZW5kYXIsIGNhY2hlKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuICAgIGRheXNJblllYXIoZGF0ZVBhcmFtKSB7XG4gICAgICAgIGxldCBkYXRlID0gZGF0ZVBhcmFtO1xuICAgICAgICBpZiAoIUhhc1Nsb3QoZGF0ZSwgSVNPX1lFQVIpKVxuICAgICAgICAgICAgZGF0ZSA9IFRvVGVtcG9yYWxEYXRlKGRhdGUpO1xuICAgICAgICBjb25zdCBjYWNoZSA9IE9uZU9iamVjdENhY2hlLmdldENhY2hlRm9yT2JqZWN0KGRhdGUpO1xuICAgICAgICBjb25zdCBjYWxlbmRhckRhdGUgPSB0aGlzLmhlbHBlci50ZW1wb3JhbFRvQ2FsZW5kYXJEYXRlKGRhdGUsIGNhY2hlKTtcbiAgICAgICAgY29uc3Qgc3RhcnRPZlllYXJDYWxlbmRhciA9IHRoaXMuaGVscGVyLnN0YXJ0T2ZDYWxlbmRhclllYXIoY2FsZW5kYXJEYXRlKTtcbiAgICAgICAgY29uc3Qgc3RhcnRPZk5leHRZZWFyQ2FsZW5kYXIgPSB0aGlzLmhlbHBlci5hZGRDYWxlbmRhcihzdGFydE9mWWVhckNhbGVuZGFyLCB7IHllYXJzOiAxIH0sICdjb25zdHJhaW4nLCBjYWNoZSk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuaGVscGVyLmNhbGVuZGFyRGF5c1VudGlsKHN0YXJ0T2ZZZWFyQ2FsZW5kYXIsIHN0YXJ0T2ZOZXh0WWVhckNhbGVuZGFyLCBjYWNoZSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcbiAgICBtb250aHNJblllYXIoZGF0ZSkge1xuICAgICAgICBjb25zdCBjYWNoZSA9IE9uZU9iamVjdENhY2hlLmdldENhY2hlRm9yT2JqZWN0KGRhdGUpO1xuICAgICAgICBjb25zdCBjYWxlbmRhckRhdGUgPSB0aGlzLmhlbHBlci50ZW1wb3JhbFRvQ2FsZW5kYXJEYXRlKGRhdGUsIGNhY2hlKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5oZWxwZXIubW9udGhzSW5ZZWFyKGNhbGVuZGFyRGF0ZSwgY2FjaGUpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG4gICAgaW5MZWFwWWVhcihkYXRlUGFyYW0pIHtcbiAgICAgICAgbGV0IGRhdGUgPSBkYXRlUGFyYW07XG4gICAgICAgIGlmICghSGFzU2xvdChkYXRlLCBJU09fWUVBUikpXG4gICAgICAgICAgICBkYXRlID0gVG9UZW1wb3JhbERhdGUoZGF0ZSk7XG4gICAgICAgIGNvbnN0IGNhY2hlID0gT25lT2JqZWN0Q2FjaGUuZ2V0Q2FjaGVGb3JPYmplY3QoZGF0ZSk7XG4gICAgICAgIGNvbnN0IGNhbGVuZGFyRGF0ZSA9IHRoaXMuaGVscGVyLnRlbXBvcmFsVG9DYWxlbmRhckRhdGUoZGF0ZSwgY2FjaGUpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLmhlbHBlci5pbkxlYXBZZWFyKGNhbGVuZGFyRGF0ZSwgY2FjaGUpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn07XG5mb3IgKGNvbnN0IEhlbHBlciBvZiBbXG4gICAgSGVicmV3SGVscGVyLFxuICAgIFBlcnNpYW5IZWxwZXIsXG4gICAgRXRoaW9waWNIZWxwZXIsXG4gICAgRXRoaW9hYUhlbHBlcixcbiAgICBDb3B0aWNIZWxwZXIsXG4gICAgQ2hpbmVzZUhlbHBlcixcbiAgICBEYW5naUhlbHBlcixcbiAgICBSb2NIZWxwZXIsXG4gICAgSW5kaWFuSGVscGVyLFxuICAgIEJ1ZGRoaXN0SGVscGVyLFxuICAgIEdyZWdvcnlIZWxwZXIsXG4gICAgSmFwYW5lc2VIZWxwZXIsXG4gICAgSXNsYW1pY0hlbHBlcixcbiAgICBJc2xhbWljVW1hbHF1cmFIZWxwZXIsXG4gICAgSXNsYW1pY1RibGFIZWxwZXIsXG4gICAgSXNsYW1pY0NpdmlsSGVscGVyLFxuICAgIElzbGFtaWNSZ3NhSGVscGVyLFxuICAgIElzbGFtaWNDY0hlbHBlclxuXSkge1xuICAgIGNvbnN0IGhlbHBlciA9IG5ldyBIZWxwZXIoKTtcbiAgICAvLyBDbG9uZSB0aGUgc2luZ2xldG9uIG5vbi1JU08gaW1wbGVtZW50YXRpb24gdGhhdCdzIHRoZSBzYW1lIGZvciBhbGxcbiAgICAvLyBjYWxlbmRhcnMuIFRoZSBgaGVscGVyYCBwcm9wZXJ0eSBjb250YWlucyBwZXItY2FsZW5kYXIgbG9naWMuXG4gICAgaW1wbFtoZWxwZXIuaWRdID0geyAuLi5ub25Jc29JbXBsLCBoZWxwZXIgfTtcbn1cbmNvbnN0IEJVSUxUSU5fQ0FMRU5EQVJfSURTID0gT2JqZWN0LmtleXMoaW1wbCk7XG5mdW5jdGlvbiBJc0J1aWx0aW5DYWxlbmRhcihpZCkge1xuICAgIHJldHVybiBBcnJheUluY2x1ZGVzLmNhbGwoQlVJTFRJTl9DQUxFTkRBUl9JRFMsIGlkKTtcbn1cblxuY29uc3QgdHpDb21wb25lbnQgPSAvXFwuWy1BLVphLXpfXXxcXC5cXC5bLUEtWmEtei5fXXsxLDEyfXxcXC5bLUEtWmEtel9dWy1BLVphLXouX117MCwxMn18W0EtWmEtel9dWy1BLVphLXouX117MCwxM30vO1xuY29uc3Qgb2Zmc2V0Tm9DYXB0dXJlID0gLyg/OlsrXFx1MjIxMi1dWzAtMl1bMC05XSg/Ojo/WzAtNV1bMC05XSg/Ojo/WzAtNV1bMC05XSg/OlsuLF1cXGR7MSw5fSk/KT8pPykvO1xuY29uc3QgdGltZVpvbmVJRCA9IG5ldyBSZWdFeHAoYCg/Oig/OiR7dHpDb21wb25lbnQuc291cmNlfSkoPzpcXFxcLyg/OiR7dHpDb21wb25lbnQuc291cmNlfSkpKnxFdGMvR01UWy0rXVxcXFxkezEsMn18JHtvZmZzZXROb0NhcHR1cmUuc291cmNlfSlgKTtcbmNvbnN0IGNhbENvbXBvbmVudCA9IC9bQS1aYS16MC05XXszLDh9LztcbmNvbnN0IGNhbGVuZGFySUQgPSBuZXcgUmVnRXhwKGAoPzoke2NhbENvbXBvbmVudC5zb3VyY2V9KD86LSR7Y2FsQ29tcG9uZW50LnNvdXJjZX0pKilgKTtcbmNvbnN0IHllYXJwYXJ0ID0gLyg/OlsrXFx1MjIxMi1dXFxkezZ9fFxcZHs0fSkvO1xuY29uc3QgbW9udGhwYXJ0ID0gLyg/OjBbMS05XXwxWzAtMl0pLztcbmNvbnN0IGRheXBhcnQgPSAvKD86MFsxLTldfFsxMl1cXGR8M1swMV0pLztcbmNvbnN0IGRhdGVzcGxpdCA9IG5ldyBSZWdFeHAoYCgke3llYXJwYXJ0LnNvdXJjZX0pKD86LSgke21vbnRocGFydC5zb3VyY2V9KS0oJHtkYXlwYXJ0LnNvdXJjZX0pfCgke21vbnRocGFydC5zb3VyY2V9KSgke2RheXBhcnQuc291cmNlfSkpYCk7XG5jb25zdCB0aW1lc3BsaXQgPSAvKFxcZHsyfSkoPzo6KFxcZHsyfSkoPzo6KFxcZHsyfSkoPzpbLixdKFxcZHsxLDl9KSk/KT98KFxcZHsyfSkoPzooXFxkezJ9KSg/OlsuLF0oXFxkezEsOX0pKT8pPyk/LztcbmNvbnN0IG9mZnNldCA9IC8oWytcXHUyMjEyLV0pKFswMV1bMC05XXwyWzAtM10pKD86Oj8oWzAtNV1bMC05XSkoPzo6PyhbMC01XVswLTldKSg/OlsuLF0oXFxkezEsOX0pKT8pPyk/LztcbmNvbnN0IHpvbmVzcGxpdCA9IG5ldyBSZWdFeHAoYCg/OihbelpdKXwoPzoke29mZnNldC5zb3VyY2V9KT8pKD86XFxcXFsoJHt0aW1lWm9uZUlELnNvdXJjZX0pXFxcXF0pP2ApO1xuY29uc3QgY2FsZW5kYXIgPSBuZXcgUmVnRXhwKGBcXFxcW3UtY2E9KCR7Y2FsZW5kYXJJRC5zb3VyY2V9KVxcXFxdYCk7XG5jb25zdCB6b25lZGRhdGV0aW1lID0gbmV3IFJlZ0V4cChgXiR7ZGF0ZXNwbGl0LnNvdXJjZX0oPzooPzpUfFxcXFxzKykke3RpbWVzcGxpdC5zb3VyY2V9KT8ke3pvbmVzcGxpdC5zb3VyY2V9KD86JHtjYWxlbmRhci5zb3VyY2V9KT8kYCwgJ2knKTtcbmNvbnN0IHRpbWUgPSBuZXcgUmVnRXhwKGBeVD8ke3RpbWVzcGxpdC5zb3VyY2V9KD86JHt6b25lc3BsaXQuc291cmNlfSk/KD86JHtjYWxlbmRhci5zb3VyY2V9KT8kYCwgJ2knKTtcbi8vIFRoZSBzaG9ydCBmb3JtcyBvZiBZZWFyTW9udGggYW5kIE1vbnRoRGF5IGFyZSBvbmx5IGZvciB0aGUgSVNPIGNhbGVuZGFyLlxuLy8gTm9uLUlTTyBjYWxlbmRhciBZZWFyTW9udGggYW5kIE1vbnRoRGF5IGhhdmUgdG8gcGFyc2UgYXMgYSBUZW1wb3JhbC5QbGFpbkRhdGUsXG4vLyB3aXRoIHRoZSByZWZlcmVuY2UgZmllbGRzLlxuLy8gWVlZWU1NIGZvcmJpZGRlbiBieSBJU08gODYwMSBiZWNhdXNlIGFtYmlndW91cyB3aXRoIFlZTU1ERCwgYnV0IGFsbG93ZWQgYnlcbi8vIFJGQyAzMzM5IGFuZCB3ZSBkb24ndCBhbGxvdyAyLWRpZ2l0IHllYXJzLCBzbyB3ZSBhbGxvdyBpdC5cbi8vIE5vdCBhbWJpZ3VvdXMgd2l0aCBISE1NU1MgYmVjYXVzZSB0aGF0IHJlcXVpcmVzIGEgJ1QnIHByZWZpeFxuY29uc3QgeWVhcm1vbnRoID0gbmV3IFJlZ0V4cChgXigke3llYXJwYXJ0LnNvdXJjZX0pLT8oJHttb250aHBhcnQuc291cmNlfSkkYCk7XG5jb25zdCBtb250aGRheSA9IG5ldyBSZWdFeHAoYF4oPzotLSk/KCR7bW9udGhwYXJ0LnNvdXJjZX0pLT8oJHtkYXlwYXJ0LnNvdXJjZX0pJGApO1xuY29uc3QgZnJhY3Rpb24gPSAvKFxcZCspKD86Wy4sXShcXGR7MSw5fSkpPy87XG5jb25zdCBkdXJhdGlvbkRhdGUgPSAvKD86KFxcZCspWSk/KD86KFxcZCspTSk/KD86KFxcZCspVyk/KD86KFxcZCspRCk/LztcbmNvbnN0IGR1cmF0aW9uVGltZSA9IG5ldyBSZWdFeHAoYCg/OiR7ZnJhY3Rpb24uc291cmNlfUgpPyg/OiR7ZnJhY3Rpb24uc291cmNlfU0pPyg/OiR7ZnJhY3Rpb24uc291cmNlfVMpP2ApO1xuY29uc3QgZHVyYXRpb24gPSBuZXcgUmVnRXhwKGBeKFsrXFx1MjIxMi1dKT9QJHtkdXJhdGlvbkRhdGUuc291cmNlfSg/OlQoPyEkKSR7ZHVyYXRpb25UaW1lLnNvdXJjZX0pPyRgLCAnaScpO1xuXG5jb25zdCBBcnJheVByb3RvdHlwZVB1c2gkMSA9IEFycmF5LnByb3RvdHlwZS5wdXNoO1xuY29uc3QgSW50bERhdGVUaW1lRm9ybWF0JDEgPSBnbG9iYWxUaGlzLkludGwuRGF0ZVRpbWVGb3JtYXQ7XG5jb25zdCBNYXRoTWluID0gTWF0aC5taW47XG5jb25zdCBNYXRoTWF4ID0gTWF0aC5tYXg7XG5jb25zdCBNYXRoQWJzID0gTWF0aC5hYnM7XG5jb25zdCBNYXRoRmxvb3IgPSBNYXRoLmZsb29yO1xuY29uc3QgTWF0aFNpZ24gPSBNYXRoLnNpZ247XG5jb25zdCBNYXRoVHJ1bmMgPSBNYXRoLnRydW5jO1xuY29uc3QgTnVtYmVySXNOYU4gPSBOdW1iZXIuaXNOYU47XG5jb25zdCBOdW1iZXJJc0Zpbml0ZSA9IE51bWJlci5pc0Zpbml0ZTtcbmNvbnN0IE51bWJlckN0b3IgPSBOdW1iZXI7XG5jb25zdCBTdHJpbmdDdG9yID0gU3RyaW5nO1xuY29uc3QgTnVtYmVyTWF4U2FmZUludGVnZXIgPSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUjtcbmNvbnN0IE9iamVjdENyZWF0ZSQyID0gT2JqZWN0LmNyZWF0ZTtcbmNvbnN0IE9iamVjdERlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xuY29uc3QgT2JqZWN0SXMgPSBPYmplY3QuaXM7XG5jb25zdCBSZWZsZWN0QXBwbHkkMSA9IFJlZmxlY3QuYXBwbHk7XG5jb25zdCBaRVJPID0gSlNCSS5CaWdJbnQoMCk7XG5jb25zdCBPTkUgPSBKU0JJLkJpZ0ludCgxKTtcbmNvbnN0IFNJWFRZID0gSlNCSS5CaWdJbnQoNjApO1xuY29uc3QgVEhPVVNBTkQgPSBKU0JJLkJpZ0ludCgxZTMpO1xuY29uc3QgTUlMTElPTiA9IEpTQkkuQmlnSW50KDFlNik7XG5jb25zdCBCSUxMSU9OID0gSlNCSS5CaWdJbnQoMWU5KTtcbmNvbnN0IE5FR0FUSVZFX09ORSA9IEpTQkkuQmlnSW50KC0xKTtcbmNvbnN0IERBWV9TRUNPTkRTID0gODY0MDA7XG5jb25zdCBEQVlfTkFOT1MgPSBKU0JJLm11bHRpcGx5KEpTQkkuQmlnSW50KERBWV9TRUNPTkRTKSwgQklMTElPTik7XG5jb25zdCBOU19NSU4gPSBKU0JJLm11bHRpcGx5KEpTQkkuQmlnSW50KC04NjQwMCksIEpTQkkuQmlnSW50KDFlMTcpKTtcbmNvbnN0IE5TX01BWCA9IEpTQkkubXVsdGlwbHkoSlNCSS5CaWdJbnQoODY0MDApLCBKU0JJLkJpZ0ludCgxZTE3KSk7XG5jb25zdCBZRUFSX01JTiA9IC0yNzE4MjE7XG5jb25zdCBZRUFSX01BWCA9IDI3NTc2MDtcbmNvbnN0IEJFRk9SRV9GSVJTVF9PRkZTRVRfVFJBTlNJVElPTiA9IEpTQkkubXVsdGlwbHkoSlNCSS5CaWdJbnQoLTM4ODE1MiksIEpTQkkuQmlnSW50KDFlMTMpKTsgLy8gMTg0Ny0wMS0wMVQwMDowMDowMFpcbmNvbnN0IEFCT1VUX1RFTl9ZRUFSU19OQU5PUyA9IEpTQkkubXVsdGlwbHkoREFZX05BTk9TLCBKU0JJLkJpZ0ludCgzNjYgKiAxMCkpO1xuY29uc3QgQUJPVVRfT05FX1lFQVJfTkFOT1MgPSBKU0JJLm11bHRpcGx5KERBWV9OQU5PUywgSlNCSS5CaWdJbnQoMzY2ICogMSkpO1xuY29uc3QgVFdPX1dFRUtTX05BTk9TID0gSlNCSS5tdWx0aXBseShEQVlfTkFOT1MsIEpTQkkuQmlnSW50KDIgKiA3KSk7XG5mdW5jdGlvbiBJc0ludGVnZXIodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJyB8fCAhTnVtYmVySXNGaW5pdGUodmFsdWUpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgY29uc3QgYWJzID0gTWF0aEFicyh2YWx1ZSk7XG4gICAgcmV0dXJuIE1hdGhGbG9vcihhYnMpID09PSBhYnM7XG59XG5mdW5jdGlvbiBJc09iamVjdCh2YWx1ZSkge1xuICAgIHJldHVybiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAhPT0gbnVsbCkgfHwgdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nO1xufVxuZnVuY3Rpb24gVG9OdW1iZXIodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnYmlnaW50JylcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNvbnZlcnQgQmlnSW50IHRvIG51bWJlcicpO1xuICAgIHJldHVybiBOdW1iZXJDdG9yKHZhbHVlKTtcbn1cbmZ1bmN0aW9uIFRvSW50ZWdlcih2YWx1ZSkge1xuICAgIGNvbnN0IG51bSA9IFRvTnVtYmVyKHZhbHVlKTtcbiAgICBpZiAoTnVtYmVySXNOYU4obnVtKSlcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgY29uc3QgaW50ZWdlciA9IE1hdGhUcnVuYyhudW0pO1xuICAgIGlmIChudW0gPT09IDApXG4gICAgICAgIHJldHVybiAwO1xuICAgIHJldHVybiBpbnRlZ2VyO1xufVxuZnVuY3Rpb24gVG9TdHJpbmcodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3ltYm9sJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY29udmVydCBhIFN5bWJvbCB2YWx1ZSB0byBhIFN0cmluZycpO1xuICAgIH1cbiAgICByZXR1cm4gU3RyaW5nQ3Rvcih2YWx1ZSk7XG59XG5mdW5jdGlvbiBUb0ludGVnZXJUaHJvd09uSW5maW5pdHkodmFsdWUpIHtcbiAgICBjb25zdCBpbnRlZ2VyID0gVG9JbnRlZ2VyKHZhbHVlKTtcbiAgICBpZiAoIU51bWJlcklzRmluaXRlKGludGVnZXIpKSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdpbmZpbml0eSBpcyBvdXQgb2YgcmFuZ2UnKTtcbiAgICB9XG4gICAgcmV0dXJuIGludGVnZXI7XG59XG5mdW5jdGlvbiBUb1Bvc2l0aXZlSW50ZWdlcih2YWx1ZVBhcmFtLCBwcm9wZXJ0eSkge1xuICAgIGNvbnN0IHZhbHVlID0gVG9JbnRlZ2VyKHZhbHVlUGFyYW0pO1xuICAgIGlmICghTnVtYmVySXNGaW5pdGUodmFsdWUpKSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdpbmZpbml0eSBpcyBvdXQgb2YgcmFuZ2UnKTtcbiAgICB9XG4gICAgaWYgKHZhbHVlIDwgMSkge1xuICAgICAgICBpZiAocHJvcGVydHkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYHByb3BlcnR5ICcke3Byb3BlcnR5fScgY2Fubm90IGJlIGEgYSBudW1iZXIgbGVzcyB0aGFuIG9uZWApO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdDYW5ub3QgY29udmVydCBhIG51bWJlciBsZXNzIHRoYW4gb25lIHRvIGEgcG9zaXRpdmUgaW50ZWdlcicpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59XG5mdW5jdGlvbiBUb0ludGVnZXJXaXRob3V0Um91bmRpbmcodmFsdWVQYXJhbSkge1xuICAgIGNvbnN0IHZhbHVlID0gVG9OdW1iZXIodmFsdWVQYXJhbSk7XG4gICAgaWYgKE51bWJlcklzTmFOKHZhbHVlKSlcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgaWYgKCFOdW1iZXJJc0Zpbml0ZSh2YWx1ZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2luZmluaXR5IGlzIG91dCBvZiByYW5nZScpO1xuICAgIH1cbiAgICBpZiAoIUlzSW50ZWdlcih2YWx1ZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYHVuc3VwcG9ydGVkIGZyYWN0aW9uYWwgdmFsdWUgJHt2YWx1ZX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIFRvSW50ZWdlcih2YWx1ZSk7IC8vIOKEnSh2YWx1ZSkgaW4gc3BlYyB0ZXh0OyBjb252ZXJ0cyAtMCB0byAwXG59XG5mdW5jdGlvbiBkaXZtb2QoeCwgeSkge1xuICAgIGNvbnN0IHF1b3RpZW50ID0gSlNCSS5kaXZpZGUoeCwgeSk7XG4gICAgY29uc3QgcmVtYWluZGVyID0gSlNCSS5yZW1haW5kZXIoeCwgeSk7XG4gICAgcmV0dXJuIHsgcXVvdGllbnQsIHJlbWFpbmRlciB9O1xufVxuZnVuY3Rpb24gYWJzKHgpIHtcbiAgICBpZiAoSlNCSS5sZXNzVGhhbih4LCBaRVJPKSlcbiAgICAgICAgcmV0dXJuIEpTQkkubXVsdGlwbHkoeCwgTkVHQVRJVkVfT05FKTtcbiAgICByZXR1cm4geDtcbn1cbmNvbnN0IEJVSUxUSU5fQ0FTVFMgPSBuZXcgTWFwKFtcbiAgICBbJ3llYXInLCBUb0ludGVnZXJUaHJvd09uSW5maW5pdHldLFxuICAgIFsnbW9udGgnLCBUb1Bvc2l0aXZlSW50ZWdlcl0sXG4gICAgWydtb250aENvZGUnLCBUb1N0cmluZ10sXG4gICAgWydkYXknLCBUb1Bvc2l0aXZlSW50ZWdlcl0sXG4gICAgWydob3VyJywgVG9JbnRlZ2VyVGhyb3dPbkluZmluaXR5XSxcbiAgICBbJ21pbnV0ZScsIFRvSW50ZWdlclRocm93T25JbmZpbml0eV0sXG4gICAgWydzZWNvbmQnLCBUb0ludGVnZXJUaHJvd09uSW5maW5pdHldLFxuICAgIFsnbWlsbGlzZWNvbmQnLCBUb0ludGVnZXJUaHJvd09uSW5maW5pdHldLFxuICAgIFsnbWljcm9zZWNvbmQnLCBUb0ludGVnZXJUaHJvd09uSW5maW5pdHldLFxuICAgIFsnbmFub3NlY29uZCcsIFRvSW50ZWdlclRocm93T25JbmZpbml0eV0sXG4gICAgWyd5ZWFycycsIFRvSW50ZWdlcldpdGhvdXRSb3VuZGluZ10sXG4gICAgWydtb250aHMnLCBUb0ludGVnZXJXaXRob3V0Um91bmRpbmddLFxuICAgIFsnd2Vla3MnLCBUb0ludGVnZXJXaXRob3V0Um91bmRpbmddLFxuICAgIFsnZGF5cycsIFRvSW50ZWdlcldpdGhvdXRSb3VuZGluZ10sXG4gICAgWydob3VycycsIFRvSW50ZWdlcldpdGhvdXRSb3VuZGluZ10sXG4gICAgWydtaW51dGVzJywgVG9JbnRlZ2VyV2l0aG91dFJvdW5kaW5nXSxcbiAgICBbJ3NlY29uZHMnLCBUb0ludGVnZXJXaXRob3V0Um91bmRpbmddLFxuICAgIFsnbWlsbGlzZWNvbmRzJywgVG9JbnRlZ2VyV2l0aG91dFJvdW5kaW5nXSxcbiAgICBbJ21pY3Jvc2Vjb25kcycsIFRvSW50ZWdlcldpdGhvdXRSb3VuZGluZ10sXG4gICAgWyduYW5vc2Vjb25kcycsIFRvSW50ZWdlcldpdGhvdXRSb3VuZGluZ10sXG4gICAgWydlcmEnLCBUb1N0cmluZ10sXG4gICAgWydlcmFZZWFyJywgVG9JbnRlZ2VyXSxcbiAgICBbJ29mZnNldCcsIFRvU3RyaW5nXVxuXSk7XG5jb25zdCBBTExPV0VEX1VOSVRTID0gW1xuICAgICd5ZWFyJyxcbiAgICAnbW9udGgnLFxuICAgICd3ZWVrJyxcbiAgICAnZGF5JyxcbiAgICAnaG91cicsXG4gICAgJ21pbnV0ZScsXG4gICAgJ3NlY29uZCcsXG4gICAgJ21pbGxpc2Vjb25kJyxcbiAgICAnbWljcm9zZWNvbmQnLFxuICAgICduYW5vc2Vjb25kJ1xuXTtcbmNvbnN0IFNJTkdVTEFSX1BMVVJBTF9VTklUUyA9IFtcbiAgICBbJ3llYXJzJywgJ3llYXInXSxcbiAgICBbJ21vbnRocycsICdtb250aCddLFxuICAgIFsnd2Vla3MnLCAnd2VlayddLFxuICAgIFsnZGF5cycsICdkYXknXSxcbiAgICBbJ2hvdXJzJywgJ2hvdXInXSxcbiAgICBbJ21pbnV0ZXMnLCAnbWludXRlJ10sXG4gICAgWydzZWNvbmRzJywgJ3NlY29uZCddLFxuICAgIFsnbWlsbGlzZWNvbmRzJywgJ21pbGxpc2Vjb25kJ10sXG4gICAgWydtaWNyb3NlY29uZHMnLCAnbWljcm9zZWNvbmQnXSxcbiAgICBbJ25hbm9zZWNvbmRzJywgJ25hbm9zZWNvbmQnXVxuXTtcbmNvbnN0IEludGxEYXRlVGltZUZvcm1hdEVuVXNDYWNoZSA9IG5ldyBNYXAoKTtcbmZ1bmN0aW9uIGdldEludGxEYXRlVGltZUZvcm1hdEVuVXNGb3JUaW1lWm9uZSh0aW1lWm9uZUlkZW50aWZpZXIpIHtcbiAgICBsZXQgaW5zdGFuY2UgPSBJbnRsRGF0ZVRpbWVGb3JtYXRFblVzQ2FjaGUuZ2V0KHRpbWVab25lSWRlbnRpZmllcik7XG4gICAgaWYgKGluc3RhbmNlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaW5zdGFuY2UgPSBuZXcgSW50bERhdGVUaW1lRm9ybWF0JDEoJ2VuLXVzJywge1xuICAgICAgICAgICAgdGltZVpvbmU6IFN0cmluZ0N0b3IodGltZVpvbmVJZGVudGlmaWVyKSxcbiAgICAgICAgICAgIGhvdXIxMjogZmFsc2UsXG4gICAgICAgICAgICBlcmE6ICdzaG9ydCcsXG4gICAgICAgICAgICB5ZWFyOiAnbnVtZXJpYycsXG4gICAgICAgICAgICBtb250aDogJ251bWVyaWMnLFxuICAgICAgICAgICAgZGF5OiAnbnVtZXJpYycsXG4gICAgICAgICAgICBob3VyOiAnbnVtZXJpYycsXG4gICAgICAgICAgICBtaW51dGU6ICdudW1lcmljJyxcbiAgICAgICAgICAgIHNlY29uZDogJ251bWVyaWMnXG4gICAgICAgIH0pO1xuICAgICAgICBJbnRsRGF0ZVRpbWVGb3JtYXRFblVzQ2FjaGUuc2V0KHRpbWVab25lSWRlbnRpZmllciwgaW5zdGFuY2UpO1xuICAgIH1cbiAgICByZXR1cm4gaW5zdGFuY2U7XG59XG5mdW5jdGlvbiBJc1RlbXBvcmFsSW5zdGFudChpdGVtKSB7XG4gICAgcmV0dXJuIEhhc1Nsb3QoaXRlbSwgRVBPQ0hOQU5PU0VDT05EUykgJiYgIUhhc1Nsb3QoaXRlbSwgVElNRV9aT05FLCBDQUxFTkRBUik7XG59XG5mdW5jdGlvbiBJc1RlbXBvcmFsVGltZVpvbmUoaXRlbSkge1xuICAgIHJldHVybiBIYXNTbG90KGl0ZW0sIFRJTUVaT05FX0lEKTtcbn1cbmZ1bmN0aW9uIElzVGVtcG9yYWxDYWxlbmRhcihpdGVtKSB7XG4gICAgcmV0dXJuIEhhc1Nsb3QoaXRlbSwgQ0FMRU5EQVJfSUQpO1xufVxuZnVuY3Rpb24gSXNUZW1wb3JhbER1cmF0aW9uKGl0ZW0pIHtcbiAgICByZXR1cm4gSGFzU2xvdChpdGVtLCBZRUFSUywgTU9OVEhTLCBEQVlTLCBIT1VSUywgTUlOVVRFUywgU0VDT05EUywgTUlMTElTRUNPTkRTLCBNSUNST1NFQ09ORFMsIE5BTk9TRUNPTkRTKTtcbn1cbmZ1bmN0aW9uIElzVGVtcG9yYWxEYXRlKGl0ZW0pIHtcbiAgICByZXR1cm4gSGFzU2xvdChpdGVtLCBEQVRFX0JSQU5EKTtcbn1cbmZ1bmN0aW9uIElzVGVtcG9yYWxUaW1lKGl0ZW0pIHtcbiAgICByZXR1cm4gKEhhc1Nsb3QoaXRlbSwgSVNPX0hPVVIsIElTT19NSU5VVEUsIElTT19TRUNPTkQsIElTT19NSUxMSVNFQ09ORCwgSVNPX01JQ1JPU0VDT05ELCBJU09fTkFOT1NFQ09ORCkgJiZcbiAgICAgICAgIUhhc1Nsb3QoaXRlbSwgSVNPX1lFQVIsIElTT19NT05USCwgSVNPX0RBWSkpO1xufVxuZnVuY3Rpb24gSXNUZW1wb3JhbERhdGVUaW1lKGl0ZW0pIHtcbiAgICByZXR1cm4gSGFzU2xvdChpdGVtLCBJU09fWUVBUiwgSVNPX01PTlRILCBJU09fREFZLCBJU09fSE9VUiwgSVNPX01JTlVURSwgSVNPX1NFQ09ORCwgSVNPX01JTExJU0VDT05ELCBJU09fTUlDUk9TRUNPTkQsIElTT19OQU5PU0VDT05EKTtcbn1cbmZ1bmN0aW9uIElzVGVtcG9yYWxZZWFyTW9udGgoaXRlbSkge1xuICAgIHJldHVybiBIYXNTbG90KGl0ZW0sIFlFQVJfTU9OVEhfQlJBTkQpO1xufVxuZnVuY3Rpb24gSXNUZW1wb3JhbE1vbnRoRGF5KGl0ZW0pIHtcbiAgICByZXR1cm4gSGFzU2xvdChpdGVtLCBNT05USF9EQVlfQlJBTkQpO1xufVxuZnVuY3Rpb24gSXNUZW1wb3JhbFpvbmVkRGF0ZVRpbWUoaXRlbSkge1xuICAgIHJldHVybiBIYXNTbG90KGl0ZW0sIEVQT0NITkFOT1NFQ09ORFMsIFRJTUVfWk9ORSwgQ0FMRU5EQVIpO1xufVxuZnVuY3Rpb24gUmVqZWN0T2JqZWN0V2l0aENhbGVuZGFyT3JUaW1lWm9uZShpdGVtKSB7XG4gICAgaWYgKEhhc1Nsb3QoaXRlbSwgQ0FMRU5EQVIpIHx8IEhhc1Nsb3QoaXRlbSwgVElNRV9aT05FKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd3aXRoKCkgZG9lcyBub3Qgc3VwcG9ydCBhIGNhbGVuZGFyIG9yIHRpbWVab25lIHByb3BlcnR5Jyk7XG4gICAgfVxuICAgIGlmIChpdGVtLmNhbGVuZGFyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignd2l0aCgpIGRvZXMgbm90IHN1cHBvcnQgYSBjYWxlbmRhciBwcm9wZXJ0eScpO1xuICAgIH1cbiAgICBpZiAoaXRlbS50aW1lWm9uZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3dpdGgoKSBkb2VzIG5vdCBzdXBwb3J0IGEgdGltZVpvbmUgcHJvcGVydHknKTtcbiAgICB9XG59XG5mdW5jdGlvbiBQYXJzZVRlbXBvcmFsVGltZVpvbmUoc3RyaW5nSWRlbnQpIHtcbiAgICBsZXQgeyBpYW5hTmFtZSwgb2Zmc2V0LCB6IH0gPSBQYXJzZVRlbXBvcmFsVGltZVpvbmVTdHJpbmcoc3RyaW5nSWRlbnQpO1xuICAgIGlmIChpYW5hTmFtZSlcbiAgICAgICAgcmV0dXJuIGlhbmFOYW1lO1xuICAgIGlmICh6KVxuICAgICAgICByZXR1cm4gJ1VUQyc7XG4gICAgcmV0dXJuIG9mZnNldDsgLy8gaWYgIWlhbmFOYW1lICYmICF6IHRoZW4gb2Zmc2V0IG11c3QgYmUgcHJlc2VudFxufVxuZnVuY3Rpb24gRm9ybWF0Q2FsZW5kYXJBbm5vdGF0aW9uKGlkLCBzaG93Q2FsZW5kYXIpIHtcbiAgICBpZiAoc2hvd0NhbGVuZGFyID09PSAnbmV2ZXInKVxuICAgICAgICByZXR1cm4gJyc7XG4gICAgaWYgKHNob3dDYWxlbmRhciA9PT0gJ2F1dG8nICYmIGlkID09PSAnaXNvODYwMScpXG4gICAgICAgIHJldHVybiAnJztcbiAgICByZXR1cm4gYFt1LWNhPSR7aWR9XWA7XG59XG5mdW5jdGlvbiBQYXJzZUlTT0RhdGVUaW1lKGlzb1N0cmluZykge1xuICAgIC8vIFpEVCBpcyB0aGUgc3VwZXJzZXQgb2YgZmllbGRzIGZvciBldmVyeSBvdGhlciBUZW1wb3JhbCB0eXBlXG4gICAgY29uc3QgbWF0Y2ggPSB6b25lZGRhdGV0aW1lLmV4ZWMoaXNvU3RyaW5nKTtcbiAgICBpZiAoIW1hdGNoKVxuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgaW52YWxpZCBJU08gODYwMSBzdHJpbmc6ICR7aXNvU3RyaW5nfWApO1xuICAgIGxldCB5ZWFyU3RyaW5nID0gbWF0Y2hbMV07XG4gICAgaWYgKHllYXJTdHJpbmdbMF0gPT09ICdcXHUyMjEyJylcbiAgICAgICAgeWVhclN0cmluZyA9IGAtJHt5ZWFyU3RyaW5nLnNsaWNlKDEpfWA7XG4gICAgaWYgKHllYXJTdHJpbmcgPT09ICctMDAwMDAwJylcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYGludmFsaWQgSVNPIDg2MDEgc3RyaW5nOiAke2lzb1N0cmluZ31gKTtcbiAgICBjb25zdCB5ZWFyID0gVG9JbnRlZ2VyKHllYXJTdHJpbmcpO1xuICAgIGNvbnN0IG1vbnRoID0gVG9JbnRlZ2VyKG1hdGNoWzJdIHx8IG1hdGNoWzRdKTtcbiAgICBjb25zdCBkYXkgPSBUb0ludGVnZXIobWF0Y2hbM10gfHwgbWF0Y2hbNV0pO1xuICAgIGNvbnN0IGhvdXIgPSBUb0ludGVnZXIobWF0Y2hbNl0pO1xuICAgIGNvbnN0IGhhc1RpbWUgPSBtYXRjaFs2XSAhPT0gdW5kZWZpbmVkO1xuICAgIGNvbnN0IG1pbnV0ZSA9IFRvSW50ZWdlcihtYXRjaFs3XSB8fCBtYXRjaFsxMF0pO1xuICAgIGxldCBzZWNvbmQgPSBUb0ludGVnZXIobWF0Y2hbOF0gfHwgbWF0Y2hbMTFdKTtcbiAgICBpZiAoc2Vjb25kID09PSA2MClcbiAgICAgICAgc2Vjb25kID0gNTk7XG4gICAgY29uc3QgZnJhY3Rpb24gPSAobWF0Y2hbOV0gfHwgbWF0Y2hbMTJdKSArICcwMDAwMDAwMDAnO1xuICAgIGNvbnN0IG1pbGxpc2Vjb25kID0gVG9JbnRlZ2VyKGZyYWN0aW9uLnNsaWNlKDAsIDMpKTtcbiAgICBjb25zdCBtaWNyb3NlY29uZCA9IFRvSW50ZWdlcihmcmFjdGlvbi5zbGljZSgzLCA2KSk7XG4gICAgY29uc3QgbmFub3NlY29uZCA9IFRvSW50ZWdlcihmcmFjdGlvbi5zbGljZSg2LCA5KSk7XG4gICAgbGV0IG9mZnNldDtcbiAgICBsZXQgeiA9IGZhbHNlO1xuICAgIGlmIChtYXRjaFsxM10pIHtcbiAgICAgICAgb2Zmc2V0ID0gdW5kZWZpbmVkO1xuICAgICAgICB6ID0gdHJ1ZTtcbiAgICB9XG4gICAgZWxzZSBpZiAobWF0Y2hbMTRdICYmIG1hdGNoWzE1XSkge1xuICAgICAgICBjb25zdCBvZmZzZXRTaWduID0gbWF0Y2hbMTRdID09PSAnLScgfHwgbWF0Y2hbMTRdID09PSAnXFx1MjIxMicgPyAnLScgOiAnKyc7XG4gICAgICAgIGNvbnN0IG9mZnNldEhvdXJzID0gbWF0Y2hbMTVdIHx8ICcwMCc7XG4gICAgICAgIGNvbnN0IG9mZnNldE1pbnV0ZXMgPSBtYXRjaFsxNl0gfHwgJzAwJztcbiAgICAgICAgY29uc3Qgb2Zmc2V0U2Vjb25kcyA9IG1hdGNoWzE3XSB8fCAnMDAnO1xuICAgICAgICBsZXQgb2Zmc2V0RnJhY3Rpb24gPSBtYXRjaFsxOF0gfHwgJzAnO1xuICAgICAgICBvZmZzZXQgPSBgJHtvZmZzZXRTaWdufSR7b2Zmc2V0SG91cnN9OiR7b2Zmc2V0TWludXRlc31gO1xuICAgICAgICBpZiAoK29mZnNldEZyYWN0aW9uKSB7XG4gICAgICAgICAgICB3aGlsZSAob2Zmc2V0RnJhY3Rpb24uZW5kc1dpdGgoJzAnKSlcbiAgICAgICAgICAgICAgICBvZmZzZXRGcmFjdGlvbiA9IG9mZnNldEZyYWN0aW9uLnNsaWNlKDAsIC0xKTtcbiAgICAgICAgICAgIG9mZnNldCArPSBgOiR7b2Zmc2V0U2Vjb25kc30uJHtvZmZzZXRGcmFjdGlvbn1gO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCtvZmZzZXRTZWNvbmRzKSB7XG4gICAgICAgICAgICBvZmZzZXQgKz0gYDoke29mZnNldFNlY29uZHN9YDtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2Zmc2V0ID09PSAnLTAwOjAwJylcbiAgICAgICAgICAgIG9mZnNldCA9ICcrMDA6MDAnO1xuICAgIH1cbiAgICBsZXQgaWFuYU5hbWUgPSBtYXRjaFsxOV07XG4gICAgaWYgKGlhbmFOYW1lKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBDYW5vbmljYWxpemUgbmFtZSBpZiBpdCBpcyBhbiBJQU5BIGxpbmsgbmFtZSBvciBpcyBjYXBpdGFsaXplZCB3cm9uZ1xuICAgICAgICAgICAgaWFuYU5hbWUgPSBHZXRDYW5vbmljYWxUaW1lWm9uZUlkZW50aWZpZXIoaWFuYU5hbWUpLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2gge1xuICAgICAgICAgICAgLy8gTm90IGFuIElBTkEgbmFtZSwgbWF5IGJlIGEgY3VzdG9tIElELCBwYXNzIHRocm91Z2ggdW5jaGFuZ2VkXG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgY2FsZW5kYXIgPSBtYXRjaFsyMF07XG4gICAgcmV0dXJuIHtcbiAgICAgICAgeWVhcixcbiAgICAgICAgbW9udGgsXG4gICAgICAgIGRheSxcbiAgICAgICAgaGFzVGltZSxcbiAgICAgICAgaG91cixcbiAgICAgICAgbWludXRlLFxuICAgICAgICBzZWNvbmQsXG4gICAgICAgIG1pbGxpc2Vjb25kLFxuICAgICAgICBtaWNyb3NlY29uZCxcbiAgICAgICAgbmFub3NlY29uZCxcbiAgICAgICAgaWFuYU5hbWUsXG4gICAgICAgIG9mZnNldCxcbiAgICAgICAgeixcbiAgICAgICAgY2FsZW5kYXJcbiAgICB9O1xufVxuZnVuY3Rpb24gUGFyc2VUZW1wb3JhbEluc3RhbnRTdHJpbmcoaXNvU3RyaW5nKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gUGFyc2VJU09EYXRlVGltZShpc29TdHJpbmcpO1xuICAgIGlmICghcmVzdWx0LnogJiYgIXJlc3VsdC5vZmZzZXQpXG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUZW1wb3JhbC5JbnN0YW50IHJlcXVpcmVzIGEgdGltZSB6b25lIG9mZnNldCcpO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBQYXJzZVRlbXBvcmFsWm9uZWREYXRlVGltZVN0cmluZyhpc29TdHJpbmcpIHtcbiAgICBjb25zdCByZXN1bHQgPSBQYXJzZUlTT0RhdGVUaW1lKGlzb1N0cmluZyk7XG4gICAgaWYgKCFyZXN1bHQuaWFuYU5hbWUpXG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUZW1wb3JhbC5ab25lZERhdGVUaW1lIHJlcXVpcmVzIGEgdGltZSB6b25lIElEIGluIGJyYWNrZXRzJyk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIFBhcnNlVGVtcG9yYWxEYXRlVGltZVN0cmluZyhpc29TdHJpbmcpIHtcbiAgICByZXR1cm4gUGFyc2VJU09EYXRlVGltZShpc29TdHJpbmcpO1xufVxuZnVuY3Rpb24gUGFyc2VUZW1wb3JhbERhdGVTdHJpbmcoaXNvU3RyaW5nKSB7XG4gICAgcmV0dXJuIFBhcnNlSVNPRGF0ZVRpbWUoaXNvU3RyaW5nKTtcbn1cbmZ1bmN0aW9uIFBhcnNlVGVtcG9yYWxUaW1lU3RyaW5nKGlzb1N0cmluZykge1xuICAgIGNvbnN0IG1hdGNoID0gdGltZS5leGVjKGlzb1N0cmluZyk7XG4gICAgbGV0IGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZCwgbWljcm9zZWNvbmQsIG5hbm9zZWNvbmQsIGNhbGVuZGFyO1xuICAgIGlmIChtYXRjaCkge1xuICAgICAgICBob3VyID0gVG9JbnRlZ2VyKG1hdGNoWzFdKTtcbiAgICAgICAgbWludXRlID0gVG9JbnRlZ2VyKG1hdGNoWzJdIHx8IG1hdGNoWzVdKTtcbiAgICAgICAgc2Vjb25kID0gVG9JbnRlZ2VyKG1hdGNoWzNdIHx8IG1hdGNoWzZdKTtcbiAgICAgICAgaWYgKHNlY29uZCA9PT0gNjApXG4gICAgICAgICAgICBzZWNvbmQgPSA1OTtcbiAgICAgICAgY29uc3QgZnJhY3Rpb24gPSAobWF0Y2hbNF0gfHwgbWF0Y2hbN10pICsgJzAwMDAwMDAwMCc7XG4gICAgICAgIG1pbGxpc2Vjb25kID0gVG9JbnRlZ2VyKGZyYWN0aW9uLnNsaWNlKDAsIDMpKTtcbiAgICAgICAgbWljcm9zZWNvbmQgPSBUb0ludGVnZXIoZnJhY3Rpb24uc2xpY2UoMywgNikpO1xuICAgICAgICBuYW5vc2Vjb25kID0gVG9JbnRlZ2VyKGZyYWN0aW9uLnNsaWNlKDYsIDkpKTtcbiAgICAgICAgY2FsZW5kYXIgPSBtYXRjaFsxNV07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBsZXQgeiwgaGFzVGltZTtcbiAgICAgICAgKHsgaGFzVGltZSwgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kLCBtaWNyb3NlY29uZCwgbmFub3NlY29uZCwgY2FsZW5kYXIsIHogfSA9XG4gICAgICAgICAgICBQYXJzZUlTT0RhdGVUaW1lKGlzb1N0cmluZykpO1xuICAgICAgICBpZiAoIWhhc1RpbWUpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgdGltZSBpcyBtaXNzaW5nIGluIHN0cmluZzogJHtpc29TdHJpbmd9YCk7XG4gICAgICAgIGlmICh6KVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1ogZGVzaWduYXRvciBub3Qgc3VwcG9ydGVkIGZvciBQbGFpblRpbWUnKTtcbiAgICB9XG4gICAgLy8gaWYgaXQncyBhIGRhdGUtdGltZSBzdHJpbmcsIE9LXG4gICAgaWYgKC9bdFQgXVswLTldWzAtOV0vLnRlc3QoaXNvU3RyaW5nKSkge1xuICAgICAgICByZXR1cm4geyBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQsIG1pY3Jvc2Vjb25kLCBuYW5vc2Vjb25kLCBjYWxlbmRhciB9O1xuICAgIH1cbiAgICAvLyBzbG93IGJ1dCBub24tZ3JhbW1hci1kZXBlbmRlbnQgd2F5IHRvIGVuc3VyZSB0aGF0IHRpbWUtb25seSBzdHJpbmdzIHRoYXRcbiAgICAvLyBhcmUgYWxzbyB2YWxpZCBQbGFpbk1vbnRoRGF5IGFuZCBQbGFpblllYXJNb250aCB0aHJvdy4gY29ycmVzcG9uZHMgdG9cbiAgICAvLyBhc3NlcnRpb24gaW4gc3BlYyB0ZXh0XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgeyBtb250aCwgZGF5IH0gPSBQYXJzZVRlbXBvcmFsTW9udGhEYXlTdHJpbmcoaXNvU3RyaW5nKTtcbiAgICAgICAgUmVqZWN0SVNPRGF0ZSgxOTcyLCBtb250aCwgZGF5KTtcbiAgICB9XG4gICAgY2F0Y2gge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgeyB5ZWFyLCBtb250aCB9ID0gUGFyc2VUZW1wb3JhbFllYXJNb250aFN0cmluZyhpc29TdHJpbmcpO1xuICAgICAgICAgICAgUmVqZWN0SVNPRGF0ZSh5ZWFyLCBtb250aCwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2gge1xuICAgICAgICAgICAgcmV0dXJuIHsgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kLCBtaWNyb3NlY29uZCwgbmFub3NlY29uZCwgY2FsZW5kYXIgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgaW52YWxpZCBJU08gODYwMSB0aW1lLW9ubHkgc3RyaW5nICR7aXNvU3RyaW5nfTsgbWF5IG5lZWQgYSBUIHByZWZpeGApO1xufVxuZnVuY3Rpb24gUGFyc2VUZW1wb3JhbFllYXJNb250aFN0cmluZyhpc29TdHJpbmcpIHtcbiAgICBjb25zdCBtYXRjaCA9IHllYXJtb250aC5leGVjKGlzb1N0cmluZyk7XG4gICAgbGV0IHllYXIsIG1vbnRoLCBjYWxlbmRhciwgcmVmZXJlbmNlSVNPRGF5O1xuICAgIGlmIChtYXRjaCkge1xuICAgICAgICBsZXQgeWVhclN0cmluZyA9IG1hdGNoWzFdO1xuICAgICAgICBpZiAoeWVhclN0cmluZ1swXSA9PT0gJ1xcdTIyMTInKVxuICAgICAgICAgICAgeWVhclN0cmluZyA9IGAtJHt5ZWFyU3RyaW5nLnNsaWNlKDEpfWA7XG4gICAgICAgIGlmICh5ZWFyU3RyaW5nID09PSAnLTAwMDAwMCcpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgaW52YWxpZCBJU08gODYwMSBzdHJpbmc6ICR7aXNvU3RyaW5nfWApO1xuICAgICAgICB5ZWFyID0gVG9JbnRlZ2VyKHllYXJTdHJpbmcpO1xuICAgICAgICBtb250aCA9IFRvSW50ZWdlcihtYXRjaFsyXSk7XG4gICAgICAgIGNhbGVuZGFyID0gbWF0Y2hbM107XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBsZXQgejtcbiAgICAgICAgKHsgeWVhciwgbW9udGgsIGNhbGVuZGFyLCBkYXk6IHJlZmVyZW5jZUlTT0RheSwgeiB9ID0gUGFyc2VJU09EYXRlVGltZShpc29TdHJpbmcpKTtcbiAgICAgICAgaWYgKHopXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignWiBkZXNpZ25hdG9yIG5vdCBzdXBwb3J0ZWQgZm9yIFBsYWluWWVhck1vbnRoJyk7XG4gICAgfVxuICAgIHJldHVybiB7IHllYXIsIG1vbnRoLCBjYWxlbmRhciwgcmVmZXJlbmNlSVNPRGF5IH07XG59XG5mdW5jdGlvbiBQYXJzZVRlbXBvcmFsTW9udGhEYXlTdHJpbmcoaXNvU3RyaW5nKSB7XG4gICAgY29uc3QgbWF0Y2ggPSBtb250aGRheS5leGVjKGlzb1N0cmluZyk7XG4gICAgbGV0IG1vbnRoLCBkYXksIGNhbGVuZGFyLCByZWZlcmVuY2VJU09ZZWFyO1xuICAgIGlmIChtYXRjaCkge1xuICAgICAgICBtb250aCA9IFRvSW50ZWdlcihtYXRjaFsxXSk7XG4gICAgICAgIGRheSA9IFRvSW50ZWdlcihtYXRjaFsyXSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBsZXQgejtcbiAgICAgICAgKHsgbW9udGgsIGRheSwgY2FsZW5kYXIsIHllYXI6IHJlZmVyZW5jZUlTT1llYXIsIHogfSA9IFBhcnNlSVNPRGF0ZVRpbWUoaXNvU3RyaW5nKSk7XG4gICAgICAgIGlmICh6KVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1ogZGVzaWduYXRvciBub3Qgc3VwcG9ydGVkIGZvciBQbGFpbk1vbnRoRGF5Jyk7XG4gICAgfVxuICAgIHJldHVybiB7IG1vbnRoLCBkYXksIGNhbGVuZGFyLCByZWZlcmVuY2VJU09ZZWFyIH07XG59XG5mdW5jdGlvbiBQYXJzZVRlbXBvcmFsVGltZVpvbmVTdHJpbmcoc3RyaW5nSWRlbnQpIHtcbiAgICB0cnkge1xuICAgICAgICBsZXQgY2Fub25pY2FsSWRlbnQgPSBHZXRDYW5vbmljYWxUaW1lWm9uZUlkZW50aWZpZXIoc3RyaW5nSWRlbnQpO1xuICAgICAgICBpZiAoY2Fub25pY2FsSWRlbnQpIHtcbiAgICAgICAgICAgIGNhbm9uaWNhbElkZW50ID0gY2Fub25pY2FsSWRlbnQudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIGlmIChUZXN0VGltZVpvbmVPZmZzZXRTdHJpbmcoY2Fub25pY2FsSWRlbnQpKVxuICAgICAgICAgICAgICAgIHJldHVybiB7IG9mZnNldDogY2Fub25pY2FsSWRlbnQgfTtcbiAgICAgICAgICAgIHJldHVybiB7IGlhbmFOYW1lOiBjYW5vbmljYWxJZGVudCB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIHtcbiAgICAgICAgLy8gZmFsbCB0aHJvdWdoXG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIFRyeSBwYXJzaW5nIElTTyBzdHJpbmcgaW5zdGVhZFxuICAgICAgICBjb25zdCByZXN1bHQgPSBQYXJzZUlTT0RhdGVUaW1lKHN0cmluZ0lkZW50KTtcbiAgICAgICAgaWYgKHJlc3VsdC56IHx8IHJlc3VsdC5vZmZzZXQgfHwgcmVzdWx0LmlhbmFOYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIHtcbiAgICAgICAgLy8gZmFsbCB0aHJvdWdoXG4gICAgfVxuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBJbnZhbGlkIHRpbWUgem9uZTogJHtzdHJpbmdJZGVudH1gKTtcbn1cbmZ1bmN0aW9uIFBhcnNlVGVtcG9yYWxEdXJhdGlvblN0cmluZyhpc29TdHJpbmcpIHtcbiAgICBjb25zdCBtYXRjaCA9IGR1cmF0aW9uLmV4ZWMoaXNvU3RyaW5nKTtcbiAgICBpZiAoIW1hdGNoKVxuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgaW52YWxpZCBkdXJhdGlvbjogJHtpc29TdHJpbmd9YCk7XG4gICAgaWYgKG1hdGNoLnNsaWNlKDIpLmV2ZXJ5KChlbGVtZW50KSA9PiBlbGVtZW50ID09PSB1bmRlZmluZWQpKSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBpbnZhbGlkIGR1cmF0aW9uOiAke2lzb1N0cmluZ31gKTtcbiAgICB9XG4gICAgY29uc3Qgc2lnbiA9IG1hdGNoWzFdID09PSAnLScgfHwgbWF0Y2hbMV0gPT09ICdcXHUyMjEyJyA/IC0xIDogMTtcbiAgICBjb25zdCB5ZWFycyA9IFRvSW50ZWdlcihtYXRjaFsyXSkgKiBzaWduO1xuICAgIGNvbnN0IG1vbnRocyA9IFRvSW50ZWdlcihtYXRjaFszXSkgKiBzaWduO1xuICAgIGNvbnN0IHdlZWtzID0gVG9JbnRlZ2VyKG1hdGNoWzRdKSAqIHNpZ247XG4gICAgY29uc3QgZGF5cyA9IFRvSW50ZWdlcihtYXRjaFs1XSkgKiBzaWduO1xuICAgIGNvbnN0IGhvdXJzID0gVG9JbnRlZ2VyKG1hdGNoWzZdKSAqIHNpZ247XG4gICAgbGV0IGZIb3VycyA9IG1hdGNoWzddO1xuICAgIGxldCBtaW51dGVzID0gVG9JbnRlZ2VyKG1hdGNoWzhdKSAqIHNpZ247XG4gICAgbGV0IGZNaW51dGVzID0gbWF0Y2hbOV07XG4gICAgbGV0IHNlY29uZHMgPSBUb0ludGVnZXIobWF0Y2hbMTBdKSAqIHNpZ247XG4gICAgY29uc3QgZlNlY29uZHMgPSBtYXRjaFsxMV0gKyAnMDAwMDAwMDAwJztcbiAgICBsZXQgbWlsbGlzZWNvbmRzID0gVG9JbnRlZ2VyKGZTZWNvbmRzLnNsaWNlKDAsIDMpKSAqIHNpZ247XG4gICAgbGV0IG1pY3Jvc2Vjb25kcyA9IFRvSW50ZWdlcihmU2Vjb25kcy5zbGljZSgzLCA2KSkgKiBzaWduO1xuICAgIGxldCBuYW5vc2Vjb25kcyA9IFRvSW50ZWdlcihmU2Vjb25kcy5zbGljZSg2LCA5KSkgKiBzaWduO1xuICAgIGZIb3VycyA9IGZIb3VycyA/IChzaWduICogVG9JbnRlZ2VyKGZIb3VycykpIC8gMTAgKiogZkhvdXJzLmxlbmd0aCA6IDA7XG4gICAgZk1pbnV0ZXMgPSBmTWludXRlcyA/IChzaWduICogVG9JbnRlZ2VyKGZNaW51dGVzKSkgLyAxMCAqKiBmTWludXRlcy5sZW5ndGggOiAwO1xuICAgICh7IG1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc2Vjb25kcywgbWljcm9zZWNvbmRzLCBuYW5vc2Vjb25kcyB9ID0gRHVyYXRpb25IYW5kbGVGcmFjdGlvbnMoZkhvdXJzLCBtaW51dGVzLCBmTWludXRlcywgc2Vjb25kcywgbWlsbGlzZWNvbmRzLCBtaWNyb3NlY29uZHMsIG5hbm9zZWNvbmRzKSk7XG4gICAgcmV0dXJuIHsgeWVhcnMsIG1vbnRocywgd2Vla3MsIGRheXMsIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBtaWxsaXNlY29uZHMsIG1pY3Jvc2Vjb25kcywgbmFub3NlY29uZHMgfTtcbn1cbmZ1bmN0aW9uIFBhcnNlVGVtcG9yYWxJbnN0YW50KGlzb1N0cmluZykge1xuICAgIGNvbnN0IHsgeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kLCBtaWNyb3NlY29uZCwgbmFub3NlY29uZCwgb2Zmc2V0LCB6IH0gPSBQYXJzZVRlbXBvcmFsSW5zdGFudFN0cmluZyhpc29TdHJpbmcpO1xuICAgIGNvbnN0IGVwb2NoTnMgPSBHZXRFcG9jaEZyb21JU09QYXJ0cyh5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQsIG1pY3Jvc2Vjb25kLCBuYW5vc2Vjb25kKTtcbiAgICBpZiAoZXBvY2hOcyA9PT0gbnVsbClcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0RhdGVUaW1lIG91dHNpZGUgb2Ygc3VwcG9ydGVkIHJhbmdlJyk7XG4gICAgY29uc3Qgb2Zmc2V0TnMgPSB6ID8gMCA6IFBhcnNlVGltZVpvbmVPZmZzZXRTdHJpbmcob2Zmc2V0KTtcbiAgICByZXR1cm4gSlNCSS5zdWJ0cmFjdChlcG9jaE5zLCBKU0JJLkJpZ0ludChvZmZzZXROcykpO1xufVxuZnVuY3Rpb24gUmVndWxhdGVJU09EYXRlKHllYXJQYXJhbSwgbW9udGhQYXJhbSwgZGF5UGFyYW0sIG92ZXJmbG93KSB7XG4gICAgbGV0IHllYXIgPSB5ZWFyUGFyYW07XG4gICAgbGV0IG1vbnRoID0gbW9udGhQYXJhbTtcbiAgICBsZXQgZGF5ID0gZGF5UGFyYW07XG4gICAgc3dpdGNoIChvdmVyZmxvdykge1xuICAgICAgICBjYXNlICdyZWplY3QnOlxuICAgICAgICAgICAgUmVqZWN0SVNPRGF0ZSh5ZWFyLCBtb250aCwgZGF5KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdjb25zdHJhaW4nOlxuICAgICAgICAgICAgKHsgeWVhciwgbW9udGgsIGRheSB9ID0gQ29uc3RyYWluSVNPRGF0ZSh5ZWFyLCBtb250aCwgZGF5KSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIHsgeWVhciwgbW9udGgsIGRheSB9O1xufVxuZnVuY3Rpb24gUmVndWxhdGVUaW1lKGhvdXJQYXJhbSwgbWludXRlUGFyYW0sIHNlY29uZFBhcmFtLCBtaWxsaXNlY29uZFBhcmFtLCBtaWNyb3NlY29uZFBhcmFtLCBuYW5vc2Vjb25kUGFyYW0sIG92ZXJmbG93KSB7XG4gICAgbGV0IGhvdXIgPSBob3VyUGFyYW07XG4gICAgbGV0IG1pbnV0ZSA9IG1pbnV0ZVBhcmFtO1xuICAgIGxldCBzZWNvbmQgPSBzZWNvbmRQYXJhbTtcbiAgICBsZXQgbWlsbGlzZWNvbmQgPSBtaWxsaXNlY29uZFBhcmFtO1xuICAgIGxldCBtaWNyb3NlY29uZCA9IG1pY3Jvc2Vjb25kUGFyYW07XG4gICAgbGV0IG5hbm9zZWNvbmQgPSBuYW5vc2Vjb25kUGFyYW07XG4gICAgc3dpdGNoIChvdmVyZmxvdykge1xuICAgICAgICBjYXNlICdyZWplY3QnOlxuICAgICAgICAgICAgUmVqZWN0VGltZShob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQsIG1pY3Jvc2Vjb25kLCBuYW5vc2Vjb25kKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdjb25zdHJhaW4nOlxuICAgICAgICAgICAgKHsgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kLCBtaWNyb3NlY29uZCwgbmFub3NlY29uZCB9ID0gQ29uc3RyYWluVGltZShob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQsIG1pY3Jvc2Vjb25kLCBuYW5vc2Vjb25kKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIHsgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kLCBtaWNyb3NlY29uZCwgbmFub3NlY29uZCB9O1xufVxuZnVuY3Rpb24gUmVndWxhdGVJU09ZZWFyTW9udGgoeWVhclBhcmFtLCBtb250aFBhcmFtLCBvdmVyZmxvdykge1xuICAgIGxldCB5ZWFyID0geWVhclBhcmFtO1xuICAgIGxldCBtb250aCA9IG1vbnRoUGFyYW07XG4gICAgY29uc3QgcmVmZXJlbmNlSVNPRGF5ID0gMTtcbiAgICBzd2l0Y2ggKG92ZXJmbG93KSB7XG4gICAgICAgIGNhc2UgJ3JlamVjdCc6XG4gICAgICAgICAgICBSZWplY3RJU09EYXRlKHllYXIsIG1vbnRoLCByZWZlcmVuY2VJU09EYXkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2NvbnN0cmFpbic6XG4gICAgICAgICAgICAoeyB5ZWFyLCBtb250aCB9ID0gQ29uc3RyYWluSVNPRGF0ZSh5ZWFyLCBtb250aCkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiB7IHllYXIsIG1vbnRoIH07XG59XG5mdW5jdGlvbiBEdXJhdGlvbkhhbmRsZUZyYWN0aW9ucyhmSG91cnNQYXJhbSwgbWludXRlc1BhcmFtLCBmTWludXRlc1BhcmFtLCBzZWNvbmRzUGFyYW0sIG1pbGxpc2Vjb25kc1BhcmFtLCBtaWNyb3NlY29uZHNQYXJhbSwgbmFub3NlY29uZHNQYXJhbSkge1xuICAgIGxldCBmSG91cnMgPSBmSG91cnNQYXJhbTtcbiAgICBsZXQgbWludXRlcyA9IG1pbnV0ZXNQYXJhbTtcbiAgICBsZXQgZk1pbnV0ZXMgPSBmTWludXRlc1BhcmFtO1xuICAgIGxldCBzZWNvbmRzID0gc2Vjb25kc1BhcmFtO1xuICAgIGxldCBtaWxsaXNlY29uZHMgPSBtaWxsaXNlY29uZHNQYXJhbTtcbiAgICBsZXQgbWljcm9zZWNvbmRzID0gbWljcm9zZWNvbmRzUGFyYW07XG4gICAgbGV0IG5hbm9zZWNvbmRzID0gbmFub3NlY29uZHNQYXJhbTtcbiAgICBpZiAoZkhvdXJzICE9PSAwKSB7XG4gICAgICAgIFttaW51dGVzLCBmTWludXRlcywgc2Vjb25kcywgbWlsbGlzZWNvbmRzLCBtaWNyb3NlY29uZHMsIG5hbm9zZWNvbmRzXS5mb3JFYWNoKCh2YWwpID0+IHtcbiAgICAgICAgICAgIGlmICh2YWwgIT09IDApXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ29ubHkgdGhlIHNtYWxsZXN0IHVuaXQgY2FuIGJlIGZyYWN0aW9uYWwnKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IG1pbnMgPSBmSG91cnMgKiA2MDtcbiAgICAgICAgbWludXRlcyA9IE1hdGhUcnVuYyhtaW5zKTtcbiAgICAgICAgZk1pbnV0ZXMgPSBtaW5zICUgMTtcbiAgICB9XG4gICAgaWYgKGZNaW51dGVzICE9PSAwKSB7XG4gICAgICAgIFtzZWNvbmRzLCBtaWxsaXNlY29uZHMsIG1pY3Jvc2Vjb25kcywgbmFub3NlY29uZHNdLmZvckVhY2goKHZhbCkgPT4ge1xuICAgICAgICAgICAgaWYgKHZhbCAhPT0gMClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb25seSB0aGUgc21hbGxlc3QgdW5pdCBjYW4gYmUgZnJhY3Rpb25hbCcpO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3Qgc2VjcyA9IGZNaW51dGVzICogNjA7XG4gICAgICAgIHNlY29uZHMgPSBNYXRoVHJ1bmMoc2Vjcyk7XG4gICAgICAgIGNvbnN0IGZTZWNvbmRzID0gc2VjcyAlIDE7XG4gICAgICAgIGlmIChmU2Vjb25kcyAhPT0gMCkge1xuICAgICAgICAgICAgY29uc3QgbWlscyA9IGZTZWNvbmRzICogMTAwMDtcbiAgICAgICAgICAgIG1pbGxpc2Vjb25kcyA9IE1hdGhUcnVuYyhtaWxzKTtcbiAgICAgICAgICAgIGNvbnN0IGZNaWxsaXNlY29uZHMgPSBtaWxzICUgMTtcbiAgICAgICAgICAgIGlmIChmTWlsbGlzZWNvbmRzICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWljcyA9IGZNaWxsaXNlY29uZHMgKiAxMDAwO1xuICAgICAgICAgICAgICAgIG1pY3Jvc2Vjb25kcyA9IE1hdGhUcnVuYyhtaWNzKTtcbiAgICAgICAgICAgICAgICBjb25zdCBmTWljcm9zZWNvbmRzID0gbWljcyAlIDE7XG4gICAgICAgICAgICAgICAgaWYgKGZNaWNyb3NlY29uZHMgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmFucyA9IGZNaWNyb3NlY29uZHMgKiAxMDAwO1xuICAgICAgICAgICAgICAgICAgICBuYW5vc2Vjb25kcyA9IE1hdGhUcnVuYyhuYW5zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgbWludXRlcywgc2Vjb25kcywgbWlsbGlzZWNvbmRzLCBtaWNyb3NlY29uZHMsIG5hbm9zZWNvbmRzIH07XG59XG5mdW5jdGlvbiBUb1RlbXBvcmFsRHVyYXRpb25SZWNvcmQoaXRlbSkge1xuICAgIGlmIChJc1RlbXBvcmFsRHVyYXRpb24oaXRlbSkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHllYXJzOiBHZXRTbG90KGl0ZW0sIFlFQVJTKSxcbiAgICAgICAgICAgIG1vbnRoczogR2V0U2xvdChpdGVtLCBNT05USFMpLFxuICAgICAgICAgICAgd2Vla3M6IEdldFNsb3QoaXRlbSwgV0VFS1MpLFxuICAgICAgICAgICAgZGF5czogR2V0U2xvdChpdGVtLCBEQVlTKSxcbiAgICAgICAgICAgIGhvdXJzOiBHZXRTbG90KGl0ZW0sIEhPVVJTKSxcbiAgICAgICAgICAgIG1pbnV0ZXM6IEdldFNsb3QoaXRlbSwgTUlOVVRFUyksXG4gICAgICAgICAgICBzZWNvbmRzOiBHZXRTbG90KGl0ZW0sIFNFQ09ORFMpLFxuICAgICAgICAgICAgbWlsbGlzZWNvbmRzOiBHZXRTbG90KGl0ZW0sIE1JTExJU0VDT05EUyksXG4gICAgICAgICAgICBtaWNyb3NlY29uZHM6IEdldFNsb3QoaXRlbSwgTUlDUk9TRUNPTkRTKSxcbiAgICAgICAgICAgIG5hbm9zZWNvbmRzOiBHZXRTbG90KGl0ZW0sIE5BTk9TRUNPTkRTKVxuICAgICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBwcm9wcyA9IFRvUGFydGlhbFJlY29yZChpdGVtLCBbXG4gICAgICAgICdkYXlzJyxcbiAgICAgICAgJ2hvdXJzJyxcbiAgICAgICAgJ21pY3Jvc2Vjb25kcycsXG4gICAgICAgICdtaWxsaXNlY29uZHMnLFxuICAgICAgICAnbWludXRlcycsXG4gICAgICAgICdtb250aHMnLFxuICAgICAgICAnbmFub3NlY29uZHMnLFxuICAgICAgICAnc2Vjb25kcycsXG4gICAgICAgICd3ZWVrcycsXG4gICAgICAgICd5ZWFycydcbiAgICBdKTtcbiAgICBpZiAoIXByb3BzKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIGR1cmF0aW9uLWxpa2UnKTtcbiAgICBjb25zdCB7IHllYXJzID0gMCwgbW9udGhzID0gMCwgd2Vla3MgPSAwLCBkYXlzID0gMCwgaG91cnMgPSAwLCBtaW51dGVzID0gMCwgc2Vjb25kcyA9IDAsIG1pbGxpc2Vjb25kcyA9IDAsIG1pY3Jvc2Vjb25kcyA9IDAsIG5hbm9zZWNvbmRzID0gMCB9ID0gcHJvcHM7XG4gICAgcmV0dXJuIHsgeWVhcnMsIG1vbnRocywgd2Vla3MsIGRheXMsIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBtaWxsaXNlY29uZHMsIG1pY3Jvc2Vjb25kcywgbmFub3NlY29uZHMgfTtcbn1cbmZ1bmN0aW9uIFRvTGltaXRlZFRlbXBvcmFsRHVyYXRpb24oaXRlbSwgZGlzYWxsb3dlZFByb3BlcnRpZXMgPSBbXSkge1xuICAgIGxldCByZWNvcmQ7XG4gICAgaWYgKElzT2JqZWN0KGl0ZW0pKSB7XG4gICAgICAgIHJlY29yZCA9IFRvVGVtcG9yYWxEdXJhdGlvblJlY29yZChpdGVtKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IHN0ciA9IFRvU3RyaW5nKGl0ZW0pO1xuICAgICAgICByZWNvcmQgPSBQYXJzZVRlbXBvcmFsRHVyYXRpb25TdHJpbmcoc3RyKTtcbiAgICB9XG4gICAgY29uc3QgeyB5ZWFycywgbW9udGhzLCB3ZWVrcywgZGF5cywgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc2Vjb25kcywgbWljcm9zZWNvbmRzLCBuYW5vc2Vjb25kcyB9ID0gcmVjb3JkO1xuICAgIFJlamVjdER1cmF0aW9uKHllYXJzLCBtb250aHMsIHdlZWtzLCBkYXlzLCBob3VycywgbWludXRlcywgc2Vjb25kcywgbWlsbGlzZWNvbmRzLCBtaWNyb3NlY29uZHMsIG5hbm9zZWNvbmRzKTtcbiAgICBmb3IgKGNvbnN0IHByb3BlcnR5IG9mIGRpc2FsbG93ZWRQcm9wZXJ0aWVzKSB7XG4gICAgICAgIGlmIChyZWNvcmRbcHJvcGVydHldICE9PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgRHVyYXRpb24gZmllbGQgJHtwcm9wZXJ0eX0gbm90IHN1cHBvcnRlZCBieSBUZW1wb3JhbC5JbnN0YW50LiBUcnkgVGVtcG9yYWwuWm9uZWREYXRlVGltZSBpbnN0ZWFkLmApO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZWNvcmQ7XG59XG5mdW5jdGlvbiBUb1RlbXBvcmFsT3ZlcmZsb3cob3B0aW9ucykge1xuICAgIHJldHVybiBHZXRPcHRpb24ob3B0aW9ucywgJ292ZXJmbG93JywgWydjb25zdHJhaW4nLCAncmVqZWN0J10sICdjb25zdHJhaW4nKTtcbn1cbmZ1bmN0aW9uIFRvVGVtcG9yYWxEaXNhbWJpZ3VhdGlvbihvcHRpb25zKSB7XG4gICAgcmV0dXJuIEdldE9wdGlvbihvcHRpb25zLCAnZGlzYW1iaWd1YXRpb24nLCBbJ2NvbXBhdGlibGUnLCAnZWFybGllcicsICdsYXRlcicsICdyZWplY3QnXSwgJ2NvbXBhdGlibGUnKTtcbn1cbmZ1bmN0aW9uIFRvVGVtcG9yYWxSb3VuZGluZ01vZGUob3B0aW9ucywgZmFsbGJhY2spIHtcbiAgICByZXR1cm4gR2V0T3B0aW9uKG9wdGlvbnMsICdyb3VuZGluZ01vZGUnLCBbJ2NlaWwnLCAnZmxvb3InLCAndHJ1bmMnLCAnaGFsZkV4cGFuZCddLCBmYWxsYmFjayk7XG59XG5mdW5jdGlvbiBOZWdhdGVUZW1wb3JhbFJvdW5kaW5nTW9kZShyb3VuZGluZ01vZGUpIHtcbiAgICBzd2l0Y2ggKHJvdW5kaW5nTW9kZSkge1xuICAgICAgICBjYXNlICdjZWlsJzpcbiAgICAgICAgICAgIHJldHVybiAnZmxvb3InO1xuICAgICAgICBjYXNlICdmbG9vcic6XG4gICAgICAgICAgICByZXR1cm4gJ2NlaWwnO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIHJvdW5kaW5nTW9kZTtcbiAgICB9XG59XG5mdW5jdGlvbiBUb1RlbXBvcmFsT2Zmc2V0KG9wdGlvbnMsIGZhbGxiYWNrKSB7XG4gICAgcmV0dXJuIEdldE9wdGlvbihvcHRpb25zLCAnb2Zmc2V0JywgWydwcmVmZXInLCAndXNlJywgJ2lnbm9yZScsICdyZWplY3QnXSwgZmFsbGJhY2spO1xufVxuZnVuY3Rpb24gVG9TaG93Q2FsZW5kYXJPcHRpb24ob3B0aW9ucykge1xuICAgIHJldHVybiBHZXRPcHRpb24ob3B0aW9ucywgJ2NhbGVuZGFyTmFtZScsIFsnYXV0bycsICdhbHdheXMnLCAnbmV2ZXInXSwgJ2F1dG8nKTtcbn1cbmZ1bmN0aW9uIFRvU2hvd1RpbWVab25lTmFtZU9wdGlvbihvcHRpb25zKSB7XG4gICAgcmV0dXJuIEdldE9wdGlvbihvcHRpb25zLCAndGltZVpvbmVOYW1lJywgWydhdXRvJywgJ25ldmVyJ10sICdhdXRvJyk7XG59XG5mdW5jdGlvbiBUb1Nob3dPZmZzZXRPcHRpb24ob3B0aW9ucykge1xuICAgIHJldHVybiBHZXRPcHRpb24ob3B0aW9ucywgJ29mZnNldCcsIFsnYXV0bycsICduZXZlciddLCAnYXV0bycpO1xufVxuZnVuY3Rpb24gVG9UZW1wb3JhbFJvdW5kaW5nSW5jcmVtZW50KG9wdGlvbnMsIGRpdmlkZW5kLCBpbmNsdXNpdmUpIHtcbiAgICBsZXQgbWF4aW11bSA9IEluZmluaXR5O1xuICAgIGlmIChkaXZpZGVuZCAhPT0gdW5kZWZpbmVkKVxuICAgICAgICBtYXhpbXVtID0gZGl2aWRlbmQ7XG4gICAgaWYgKCFpbmNsdXNpdmUgJiYgZGl2aWRlbmQgIT09IHVuZGVmaW5lZClcbiAgICAgICAgbWF4aW11bSA9IGRpdmlkZW5kID4gMSA/IGRpdmlkZW5kIC0gMSA6IDE7XG4gICAgY29uc3QgaW5jcmVtZW50ID0gR2V0TnVtYmVyT3B0aW9uKG9wdGlvbnMsICdyb3VuZGluZ0luY3JlbWVudCcsIDEsIG1heGltdW0sIDEpO1xuICAgIGlmIChkaXZpZGVuZCAhPT0gdW5kZWZpbmVkICYmIGRpdmlkZW5kICUgaW5jcmVtZW50ICE9PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBSb3VuZGluZyBpbmNyZW1lbnQgbXVzdCBkaXZpZGUgZXZlbmx5IGludG8gJHtkaXZpZGVuZH1gKTtcbiAgICB9XG4gICAgcmV0dXJuIGluY3JlbWVudDtcbn1cbmZ1bmN0aW9uIFRvVGVtcG9yYWxEYXRlVGltZVJvdW5kaW5nSW5jcmVtZW50KG9wdGlvbnMsIHNtYWxsZXN0VW5pdCkge1xuICAgIGNvbnN0IG1heGltdW1JbmNyZW1lbnRzID0ge1xuICAgICAgICB5ZWFyOiB1bmRlZmluZWQsXG4gICAgICAgIG1vbnRoOiB1bmRlZmluZWQsXG4gICAgICAgIHdlZWs6IHVuZGVmaW5lZCxcbiAgICAgICAgZGF5OiB1bmRlZmluZWQsXG4gICAgICAgIGhvdXI6IDI0LFxuICAgICAgICBtaW51dGU6IDYwLFxuICAgICAgICBzZWNvbmQ6IDYwLFxuICAgICAgICBtaWxsaXNlY29uZDogMTAwMCxcbiAgICAgICAgbWljcm9zZWNvbmQ6IDEwMDAsXG4gICAgICAgIG5hbm9zZWNvbmQ6IDEwMDBcbiAgICB9O1xuICAgIHJldHVybiBUb1RlbXBvcmFsUm91bmRpbmdJbmNyZW1lbnQob3B0aW9ucywgbWF4aW11bUluY3JlbWVudHNbc21hbGxlc3RVbml0XSwgZmFsc2UpO1xufVxuZnVuY3Rpb24gVG9TZWNvbmRzU3RyaW5nUHJlY2lzaW9uKG9wdGlvbnMpIHtcbiAgICBjb25zdCBzbWFsbGVzdFVuaXQgPSBUb1NtYWxsZXN0VGVtcG9yYWxVbml0KG9wdGlvbnMsIHVuZGVmaW5lZCwgWyd5ZWFyJywgJ21vbnRoJywgJ3dlZWsnLCAnZGF5JywgJ2hvdXInXSk7XG4gICAgc3dpdGNoIChzbWFsbGVzdFVuaXQpIHtcbiAgICAgICAgY2FzZSAnbWludXRlJzpcbiAgICAgICAgICAgIHJldHVybiB7IHByZWNpc2lvbjogJ21pbnV0ZScsIHVuaXQ6ICdtaW51dGUnLCBpbmNyZW1lbnQ6IDEgfTtcbiAgICAgICAgY2FzZSAnc2Vjb25kJzpcbiAgICAgICAgICAgIHJldHVybiB7IHByZWNpc2lvbjogMCwgdW5pdDogJ3NlY29uZCcsIGluY3JlbWVudDogMSB9O1xuICAgICAgICBjYXNlICdtaWxsaXNlY29uZCc6XG4gICAgICAgICAgICByZXR1cm4geyBwcmVjaXNpb246IDMsIHVuaXQ6ICdtaWxsaXNlY29uZCcsIGluY3JlbWVudDogMSB9O1xuICAgICAgICBjYXNlICdtaWNyb3NlY29uZCc6XG4gICAgICAgICAgICByZXR1cm4geyBwcmVjaXNpb246IDYsIHVuaXQ6ICdtaWNyb3NlY29uZCcsIGluY3JlbWVudDogMSB9O1xuICAgICAgICBjYXNlICduYW5vc2Vjb25kJzpcbiAgICAgICAgICAgIHJldHVybiB7IHByZWNpc2lvbjogOSwgdW5pdDogJ25hbm9zZWNvbmQnLCBpbmNyZW1lbnQ6IDEgfTtcbiAgICB9XG4gICAgbGV0IGRpZ2l0cyA9IG9wdGlvbnMuZnJhY3Rpb25hbFNlY29uZERpZ2l0cztcbiAgICBpZiAoZGlnaXRzID09PSB1bmRlZmluZWQpXG4gICAgICAgIGRpZ2l0cyA9ICdhdXRvJztcbiAgICBpZiAodHlwZW9mIGRpZ2l0cyAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgY29uc3Qgc3RyaW5nRGlnaXRzID0gVG9TdHJpbmcoZGlnaXRzKTtcbiAgICAgICAgaWYgKHN0cmluZ0RpZ2l0cyA9PT0gJ2F1dG8nKVxuICAgICAgICAgICAgcmV0dXJuIHsgcHJlY2lzaW9uOiAnYXV0bycsIHVuaXQ6ICduYW5vc2Vjb25kJywgaW5jcmVtZW50OiAxIH07XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBmcmFjdGlvbmFsU2Vjb25kRGlnaXRzIG11c3QgYmUgJ2F1dG8nIG9yIDAgdGhyb3VnaCA5LCBub3QgJHtzdHJpbmdEaWdpdHN9YCk7XG4gICAgfVxuICAgIGlmIChOdW1iZXJJc05hTihkaWdpdHMpIHx8IGRpZ2l0cyA8IDAgfHwgZGlnaXRzID4gOSkge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgZnJhY3Rpb25hbFNlY29uZERpZ2l0cyBtdXN0IGJlICdhdXRvJyBvciAwIHRocm91Z2ggOSwgbm90ICR7ZGlnaXRzfWApO1xuICAgIH1cbiAgICBjb25zdCBwcmVjaXNpb24gPSBNYXRoRmxvb3IoZGlnaXRzKTtcbiAgICBzd2l0Y2ggKHByZWNpc2lvbikge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICByZXR1cm4geyBwcmVjaXNpb24sIHVuaXQ6ICdzZWNvbmQnLCBpbmNyZW1lbnQ6IDEgfTtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICBjYXNlIDI6XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHJldHVybiB7IHByZWNpc2lvbiwgdW5pdDogJ21pbGxpc2Vjb25kJywgaW5jcmVtZW50OiAxMCAqKiAoMyAtIHByZWNpc2lvbikgfTtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICBjYXNlIDU6XG4gICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgIHJldHVybiB7IHByZWNpc2lvbiwgdW5pdDogJ21pY3Jvc2Vjb25kJywgaW5jcmVtZW50OiAxMCAqKiAoNiAtIHByZWNpc2lvbikgfTtcbiAgICAgICAgY2FzZSA3OlxuICAgICAgICBjYXNlIDg6XG4gICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgIHJldHVybiB7IHByZWNpc2lvbiwgdW5pdDogJ25hbm9zZWNvbmQnLCBpbmNyZW1lbnQ6IDEwICoqICg5IC0gcHJlY2lzaW9uKSB9O1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYGZyYWN0aW9uYWxTZWNvbmREaWdpdHMgbXVzdCBiZSAnYXV0bycgb3IgMCB0aHJvdWdoIDksIG5vdCAke2RpZ2l0c31gKTtcbiAgICB9XG59XG5mdW5jdGlvbiBUb0xhcmdlc3RUZW1wb3JhbFVuaXQob3B0aW9ucywgZmFsbGJhY2ssIGRpc2FsbG93ZWRTdHJpbmdzID0gW10sIGF1dG9WYWx1ZSkge1xuICAgIGNvbnN0IHNpbmd1bGFyID0gbmV3IE1hcChTSU5HVUxBUl9QTFVSQUxfVU5JVFMuZmlsdGVyKChbLCBzaW5nXSkgPT4gIWRpc2FsbG93ZWRTdHJpbmdzLmluY2x1ZGVzKHNpbmcpKSk7XG4gICAgY29uc3QgYWxsb3dlZCA9IG5ldyBTZXQoQUxMT1dFRF9VTklUUyk7XG4gICAgZm9yIChjb25zdCBzIG9mIGRpc2FsbG93ZWRTdHJpbmdzKSB7XG4gICAgICAgIGFsbG93ZWQuZGVsZXRlKHMpO1xuICAgIH1cbiAgICBjb25zdCByZXR2YWwgPSBHZXRPcHRpb24ob3B0aW9ucywgJ2xhcmdlc3RVbml0JywgWydhdXRvJywgLi4uYWxsb3dlZCwgLi4uc2luZ3VsYXIua2V5cygpXSwgZmFsbGJhY2spO1xuICAgIGlmIChyZXR2YWwgPT09ICdhdXRvJyAmJiBhdXRvVmFsdWUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIGF1dG9WYWx1ZTtcbiAgICBpZiAoc2luZ3VsYXIuaGFzKHJldHZhbCkpIHtcbiAgICAgICAgcmV0dXJuIHNpbmd1bGFyLmdldChyZXR2YWwpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0dmFsO1xufVxuZnVuY3Rpb24gVG9TbWFsbGVzdFRlbXBvcmFsVW5pdChvcHRpb25zLCBmYWxsYmFjaywgZGlzYWxsb3dlZFN0cmluZ3MgPSBbXSkge1xuICAgIGNvbnN0IHNpbmd1bGFyID0gbmV3IE1hcChTSU5HVUxBUl9QTFVSQUxfVU5JVFMuZmlsdGVyKChbLCBzaW5nXSkgPT4gIWRpc2FsbG93ZWRTdHJpbmdzLmluY2x1ZGVzKHNpbmcpKSk7XG4gICAgY29uc3QgYWxsb3dlZCA9IG5ldyBTZXQoQUxMT1dFRF9VTklUUyk7XG4gICAgZm9yIChjb25zdCBzIG9mIGRpc2FsbG93ZWRTdHJpbmdzKSB7XG4gICAgICAgIGFsbG93ZWQuZGVsZXRlKHMpO1xuICAgIH1cbiAgICBjb25zdCB2YWx1ZSA9IEdldE9wdGlvbihvcHRpb25zLCAnc21hbGxlc3RVbml0JywgWy4uLmFsbG93ZWQsIC4uLnNpbmd1bGFyLmtleXMoKV0sIGZhbGxiYWNrKTtcbiAgICBpZiAoc2luZ3VsYXIuaGFzKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gc2luZ3VsYXIuZ2V0KHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gVG9UZW1wb3JhbER1cmF0aW9uVG90YWxVbml0KG9wdGlvbnMpIHtcbiAgICAvLyBUaGlzIEFPIGlzIGlkZW50aWNhbCB0byBUb1NtYWxsZXN0VGVtcG9yYWxVbml0LCBleGNlcHQ6XG4gICAgLy8gLSBkZWZhdWx0IGlzIGFsd2F5cyBgdW5kZWZpbmVkYCAoY2FsbGVyIHdpbGwgdGhyb3cgaWYgb21pdHRlZClcbiAgICAvLyAtIG9wdGlvbiBpcyBuYW1lZCBgdW5pdGAgKG5vdCBgc21hbGxlc3RVbml0YClcbiAgICAvLyAtIGFsbCB1bml0cyBhcmUgdmFsaWQgKG5vIGBkaXNhbGxvd2VkU3RyaW5nc2ApXG4gICAgY29uc3Qgc2luZ3VsYXIgPSBuZXcgTWFwKFNJTkdVTEFSX1BMVVJBTF9VTklUUyk7XG4gICAgY29uc3QgdmFsdWUgPSBHZXRPcHRpb24ob3B0aW9ucywgJ3VuaXQnLCBbLi4uc2luZ3VsYXIudmFsdWVzKCksIC4uLnNpbmd1bGFyLmtleXMoKV0sIHVuZGVmaW5lZCk7XG4gICAgaWYgKHNpbmd1bGFyLmhhcyh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHNpbmd1bGFyLmdldCh2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIFRvUmVsYXRpdmVUZW1wb3JhbE9iamVjdChvcHRpb25zKSB7XG4gICAgY29uc3QgcmVsYXRpdmVUbyA9IG9wdGlvbnMucmVsYXRpdmVUbztcbiAgICBpZiAocmVsYXRpdmVUbyA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gcmVsYXRpdmVUbztcbiAgICBsZXQgb2Zmc2V0QmVoYXZpb3VyID0gJ29wdGlvbic7XG4gICAgbGV0IG1hdGNoTWludXRlcyA9IGZhbHNlO1xuICAgIGxldCB5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQsIG1pY3Jvc2Vjb25kLCBuYW5vc2Vjb25kLCBjYWxlbmRhciwgdGltZVpvbmUsIG9mZnNldDtcbiAgICBpZiAoSXNPYmplY3QocmVsYXRpdmVUbykpIHtcbiAgICAgICAgaWYgKElzVGVtcG9yYWxab25lZERhdGVUaW1lKHJlbGF0aXZlVG8pIHx8IElzVGVtcG9yYWxEYXRlKHJlbGF0aXZlVG8pKVxuICAgICAgICAgICAgcmV0dXJuIHJlbGF0aXZlVG87XG4gICAgICAgIGlmIChJc1RlbXBvcmFsRGF0ZVRpbWUocmVsYXRpdmVUbykpXG4gICAgICAgICAgICByZXR1cm4gVGVtcG9yYWxEYXRlVGltZVRvRGF0ZShyZWxhdGl2ZVRvKTtcbiAgICAgICAgY2FsZW5kYXIgPSBHZXRUZW1wb3JhbENhbGVuZGFyV2l0aElTT0RlZmF1bHQocmVsYXRpdmVUbyk7XG4gICAgICAgIGNvbnN0IGZpZWxkTmFtZXMgPSBDYWxlbmRhckZpZWxkcyhjYWxlbmRhciwgW1xuICAgICAgICAgICAgJ2RheScsXG4gICAgICAgICAgICAnaG91cicsXG4gICAgICAgICAgICAnbWljcm9zZWNvbmQnLFxuICAgICAgICAgICAgJ21pbGxpc2Vjb25kJyxcbiAgICAgICAgICAgICdtaW51dGUnLFxuICAgICAgICAgICAgJ21vbnRoJyxcbiAgICAgICAgICAgICdtb250aENvZGUnLFxuICAgICAgICAgICAgJ25hbm9zZWNvbmQnLFxuICAgICAgICAgICAgJ3NlY29uZCcsXG4gICAgICAgICAgICAneWVhcidcbiAgICAgICAgXSk7XG4gICAgICAgIGNvbnN0IGZpZWxkcyA9IFRvVGVtcG9yYWxEYXRlVGltZUZpZWxkcyhyZWxhdGl2ZVRvLCBmaWVsZE5hbWVzKTtcbiAgICAgICAgY29uc3QgZGF0ZU9wdGlvbnMgPSBPYmplY3RDcmVhdGUkMihudWxsKTtcbiAgICAgICAgZGF0ZU9wdGlvbnMub3ZlcmZsb3cgPSAnY29uc3RyYWluJztcbiAgICAgICAgKHsgeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kLCBtaWNyb3NlY29uZCwgbmFub3NlY29uZCB9ID0gSW50ZXJwcmV0VGVtcG9yYWxEYXRlVGltZUZpZWxkcyhjYWxlbmRhciwgZmllbGRzLCBkYXRlT3B0aW9ucykpO1xuICAgICAgICAvLyBUaGUgYG9mZnNldGAgYW5kIGB0aW1lWm9uZWAgcHJvcGVydGllcyBvbmx5IGV4aXN0IG9uIFpvbmVkRGF0ZVRpbWUgKG9yXG4gICAgICAgIC8vIFpvbmVkRGF0ZVRpbWVMaWtlLXByb3BlcnR5IGJhZ3MpLiBUaGUgYXNzZXJ0aW9ucyBiZWxvdyBhcmUgdXNlZCB0byBhdm9pZFxuICAgICAgICAvLyBUUyBlcnJvcnMgd2hpbGUgbm90IGRpdmVyZ2luZyBydW50aW1lIGNvZGUgZnJvbSBwcm9wb3NhbC10ZW1wb3JhbC5cbiAgICAgICAgb2Zmc2V0ID0gcmVsYXRpdmVUby5vZmZzZXQ7XG4gICAgICAgIGlmIChvZmZzZXQgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIG9mZnNldEJlaGF2aW91ciA9ICd3YWxsJztcbiAgICAgICAgdGltZVpvbmUgPSByZWxhdGl2ZVRvLnRpbWVab25lO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbGV0IGlhbmFOYW1lLCB6O1xuICAgICAgICAoeyB5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQsIG1pY3Jvc2Vjb25kLCBuYW5vc2Vjb25kLCBjYWxlbmRhciwgaWFuYU5hbWUsIG9mZnNldCwgeiB9ID1cbiAgICAgICAgICAgIFBhcnNlSVNPRGF0ZVRpbWUoVG9TdHJpbmcocmVsYXRpdmVUbykpKTtcbiAgICAgICAgaWYgKGlhbmFOYW1lKVxuICAgICAgICAgICAgdGltZVpvbmUgPSBpYW5hTmFtZTtcbiAgICAgICAgaWYgKHopIHtcbiAgICAgICAgICAgIG9mZnNldEJlaGF2aW91ciA9ICdleGFjdCc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIW9mZnNldCkge1xuICAgICAgICAgICAgb2Zmc2V0QmVoYXZpb3VyID0gJ3dhbGwnO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY2FsZW5kYXIpXG4gICAgICAgICAgICBjYWxlbmRhciA9IEdldElTTzg2MDFDYWxlbmRhcigpO1xuICAgICAgICBjYWxlbmRhciA9IFRvVGVtcG9yYWxDYWxlbmRhcihjYWxlbmRhcik7XG4gICAgICAgIG1hdGNoTWludXRlcyA9IHRydWU7XG4gICAgfVxuICAgIGlmICh0aW1lWm9uZSkge1xuICAgICAgICB0aW1lWm9uZSA9IFRvVGVtcG9yYWxUaW1lWm9uZSh0aW1lWm9uZSk7XG4gICAgICAgIGxldCBvZmZzZXROcyA9IDA7XG4gICAgICAgIGlmIChvZmZzZXRCZWhhdmlvdXIgPT09ICdvcHRpb24nKVxuICAgICAgICAgICAgb2Zmc2V0TnMgPSBQYXJzZVRpbWVab25lT2Zmc2V0U3RyaW5nKFRvU3RyaW5nKG9mZnNldCkpO1xuICAgICAgICBjb25zdCBlcG9jaE5hbm9zZWNvbmRzID0gSW50ZXJwcmV0SVNPRGF0ZVRpbWVPZmZzZXQoeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kLCBtaWNyb3NlY29uZCwgbmFub3NlY29uZCwgb2Zmc2V0QmVoYXZpb3VyLCBvZmZzZXROcywgdGltZVpvbmUsICdjb21wYXRpYmxlJywgJ3JlamVjdCcsIG1hdGNoTWludXRlcyk7XG4gICAgICAgIHJldHVybiBDcmVhdGVUZW1wb3JhbFpvbmVkRGF0ZVRpbWUoZXBvY2hOYW5vc2Vjb25kcywgdGltZVpvbmUsIGNhbGVuZGFyKTtcbiAgICB9XG4gICAgcmV0dXJuIENyZWF0ZVRlbXBvcmFsRGF0ZSh5ZWFyLCBtb250aCwgZGF5LCBjYWxlbmRhcik7XG59XG5mdW5jdGlvbiBWYWxpZGF0ZVRlbXBvcmFsVW5pdFJhbmdlKGxhcmdlc3RVbml0LCBzbWFsbGVzdFVuaXQpIHtcbiAgICBpZiAoQUxMT1dFRF9VTklUUy5pbmRleE9mKGxhcmdlc3RVbml0KSA+IEFMTE9XRURfVU5JVFMuaW5kZXhPZihzbWFsbGVzdFVuaXQpKSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBsYXJnZXN0VW5pdCAke2xhcmdlc3RVbml0fSBjYW5ub3QgYmUgc21hbGxlciB0aGFuIHNtYWxsZXN0VW5pdCAke3NtYWxsZXN0VW5pdH1gKTtcbiAgICB9XG59XG5mdW5jdGlvbiBEZWZhdWx0VGVtcG9yYWxMYXJnZXN0VW5pdCh5ZWFycywgbW9udGhzLCB3ZWVrcywgZGF5cywgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc2Vjb25kcywgbWljcm9zZWNvbmRzLCBuYW5vc2Vjb25kcykge1xuICAgIGNvbnN0IHNpbmd1bGFyID0gbmV3IE1hcChTSU5HVUxBUl9QTFVSQUxfVU5JVFMpO1xuICAgIGZvciAoY29uc3QgW3Byb3AsIHZdIG9mIFtcbiAgICAgICAgWyd5ZWFycycsIHllYXJzXSxcbiAgICAgICAgWydtb250aHMnLCBtb250aHNdLFxuICAgICAgICBbJ3dlZWtzJywgd2Vla3NdLFxuICAgICAgICBbJ2RheXMnLCBkYXlzXSxcbiAgICAgICAgWydob3VycycsIGhvdXJzXSxcbiAgICAgICAgWydtaW51dGVzJywgbWludXRlc10sXG4gICAgICAgIFsnc2Vjb25kcycsIHNlY29uZHNdLFxuICAgICAgICBbJ21pbGxpc2Vjb25kcycsIG1pbGxpc2Vjb25kc10sXG4gICAgICAgIFsnbWljcm9zZWNvbmRzJywgbWljcm9zZWNvbmRzXSxcbiAgICAgICAgWyduYW5vc2Vjb25kcycsIG5hbm9zZWNvbmRzXVxuICAgIF0pIHtcbiAgICAgICAgaWYgKHYgIT09IDApXG4gICAgICAgICAgICByZXR1cm4gc2luZ3VsYXIuZ2V0KHByb3ApO1xuICAgIH1cbiAgICByZXR1cm4gJ25hbm9zZWNvbmQnO1xufVxuZnVuY3Rpb24gTGFyZ2VyT2ZUd29UZW1wb3JhbFVuaXRzKHVuaXQxLCB1bml0Mikge1xuICAgIGlmIChBTExPV0VEX1VOSVRTLmluZGV4T2YodW5pdDEpID4gQUxMT1dFRF9VTklUUy5pbmRleE9mKHVuaXQyKSlcbiAgICAgICAgcmV0dXJuIHVuaXQyO1xuICAgIHJldHVybiB1bml0MTtcbn1cbmZ1bmN0aW9uIFRvUGFydGlhbFJlY29yZChiYWdQYXJhbSwgZmllbGRzUGFyYW0pIHtcbiAgICAvLyBFeHRlcm5hbCBjYWxsZXJzIGFyZSBsaW1pdGVkIHRvIHNwZWNpZmljIHR5cGVzLCBidXQgdGhpcyBmdW5jdGlvbidzXG4gICAgLy8gaW1wbGVtZW50YXRpb24gdXNlcyBnZW5lcmljIHByb3BlcnR5IHR5cGVzLiBUaGUgY2FzdHMgYmVsb3cgKGFuZCBhdCB0aGVcbiAgICAvLyBlbmQpIGNvbnZlcnQgdG8vZnJvbSBnZW5lcmljIHJlY29yZHMuXG4gICAgY29uc3QgYmFnID0gYmFnUGFyYW07XG4gICAgY29uc3QgZmllbGRzID0gZmllbGRzUGFyYW07XG4gICAgbGV0IGFueSA9IGZhbHNlO1xuICAgIGxldCByZXN1bHQgPSB7fTtcbiAgICBmb3IgKGNvbnN0IHByb3BlcnR5IG9mIGZpZWxkcykge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGJhZ1twcm9wZXJ0eV07XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBhbnkgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKEJVSUxUSU5fQ0FTVFMuaGFzKHByb3BlcnR5KSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdFtwcm9wZXJ0eV0gPSBCVUlMVElOX0NBU1RTLmdldChwcm9wZXJ0eSkodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W3Byb3BlcnR5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhbnkgPyByZXN1bHQgOiBmYWxzZTtcbn1cbmZ1bmN0aW9uIFByZXBhcmVUZW1wb3JhbEZpZWxkcyhiYWdQYXJhbSwgZmllbGRzUGFyYW0pIHtcbiAgICAvLyBFeHRlcm5hbCBjYWxsZXJzIGFyZSBsaW1pdGVkIHRvIHNwZWNpZmljIHR5cGVzLCBidXQgdGhpcyBmdW5jdGlvbidzXG4gICAgLy8gaW1wbGVtZW50YXRpb24gdXNlcyBnZW5lcmljIHByb3BlcnR5IHR5cGVzLiBUaGUgY2FzdHMgYmVsb3cgKGFuZCBhdCB0aGVcbiAgICAvLyBlbmQpIGNvbnZlcnQgdG8vZnJvbSBnZW5lcmljIHJlY29yZHMuXG4gICAgY29uc3QgYmFnID0gYmFnUGFyYW07XG4gICAgY29uc3QgZmllbGRzID0gZmllbGRzUGFyYW07XG4gICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgbGV0IGFueSA9IGZhbHNlO1xuICAgIGZvciAoY29uc3QgZmllbGRSZWNvcmQgb2YgZmllbGRzKSB7XG4gICAgICAgIGNvbnN0IFtwcm9wZXJ0eSwgZGVmYXVsdFZhbHVlXSA9IGZpZWxkUmVjb3JkO1xuICAgICAgICBsZXQgdmFsdWUgPSBiYWdbcHJvcGVydHldO1xuICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKGZpZWxkUmVjb3JkLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYHJlcXVpcmVkIHByb3BlcnR5ICcke3Byb3BlcnR5fScgbWlzc2luZyBvciB1bmRlZmluZWRgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhbHVlID0gZGVmYXVsdFZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYW55ID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChCVUlMVElOX0NBU1RTLmhhcyhwcm9wZXJ0eSkpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IEJVSUxUSU5fQ0FTVFMuZ2V0KHByb3BlcnR5KSh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0W3Byb3BlcnR5XSA9IHZhbHVlO1xuICAgIH1cbiAgICBpZiAoIWFueSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdubyBzdXBwb3J0ZWQgcHJvcGVydGllcyBmb3VuZCcpO1xuICAgIH1cbiAgICBpZiAoKHJlc3VsdFsnZXJhJ10gPT09IHVuZGVmaW5lZCkgIT09XG4gICAgICAgIChyZXN1bHRbJ2VyYVllYXInXSA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcInByb3BlcnRpZXMgJ2VyYScgYW5kICdlcmFZZWFyJyBtdXN0IGJlIHByb3ZpZGVkIHRvZ2V0aGVyXCIpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLy8gZmllbGQgYWNjZXNzIGluIHRoZSBmb2xsb3dpbmcgb3BlcmF0aW9ucyBpcyBpbnRlbnRpb25hbGx5IGFscGhhYmV0aWNhbFxuZnVuY3Rpb24gVG9UZW1wb3JhbERhdGVGaWVsZHMoYmFnLCBmaWVsZE5hbWVzKSB7XG4gICAgY29uc3QgZW50cmllcyA9IFtcbiAgICAgICAgWydkYXknLCB1bmRlZmluZWRdLFxuICAgICAgICBbJ21vbnRoJywgdW5kZWZpbmVkXSxcbiAgICAgICAgWydtb250aENvZGUnLCB1bmRlZmluZWRdLFxuICAgICAgICBbJ3llYXInLCB1bmRlZmluZWRdXG4gICAgXTtcbiAgICAvLyBBZGQgZXh0cmEgZmllbGRzIGZyb20gdGhlIGNhbGVuZGFyIGF0IHRoZSBlbmRcbiAgICBmaWVsZE5hbWVzLmZvckVhY2goKGZpZWxkTmFtZSkgPT4ge1xuICAgICAgICBpZiAoIWVudHJpZXMuc29tZSgoW25hbWVdKSA9PiBuYW1lID09PSBmaWVsZE5hbWUpKSB7XG4gICAgICAgICAgICBlbnRyaWVzLnB1c2goW2ZpZWxkTmFtZSwgdW5kZWZpbmVkXSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gUHJlcGFyZVRlbXBvcmFsRmllbGRzKGJhZywgZW50cmllcyk7XG59XG5mdW5jdGlvbiBUb1RlbXBvcmFsRGF0ZVRpbWVGaWVsZHMoYmFnLCBmaWVsZE5hbWVzKSB7XG4gICAgY29uc3QgZW50cmllcyA9IFtcbiAgICAgICAgWydkYXknLCB1bmRlZmluZWRdLFxuICAgICAgICBbJ2hvdXInLCAwXSxcbiAgICAgICAgWydtaWNyb3NlY29uZCcsIDBdLFxuICAgICAgICBbJ21pbGxpc2Vjb25kJywgMF0sXG4gICAgICAgIFsnbWludXRlJywgMF0sXG4gICAgICAgIFsnbW9udGgnLCB1bmRlZmluZWRdLFxuICAgICAgICBbJ21vbnRoQ29kZScsIHVuZGVmaW5lZF0sXG4gICAgICAgIFsnbmFub3NlY29uZCcsIDBdLFxuICAgICAgICBbJ3NlY29uZCcsIDBdLFxuICAgICAgICBbJ3llYXInLCB1bmRlZmluZWRdXG4gICAgXTtcbiAgICAvLyBBZGQgZXh0cmEgZmllbGRzIGZyb20gdGhlIGNhbGVuZGFyIGF0IHRoZSBlbmRcbiAgICBmaWVsZE5hbWVzLmZvckVhY2goKGZpZWxkTmFtZSkgPT4ge1xuICAgICAgICBpZiAoIWVudHJpZXMuc29tZSgoW25hbWVdKSA9PiBuYW1lID09PSBmaWVsZE5hbWUpKSB7XG4gICAgICAgICAgICBlbnRyaWVzLnB1c2goW2ZpZWxkTmFtZSwgdW5kZWZpbmVkXSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gUHJlcGFyZVRlbXBvcmFsRmllbGRzKGJhZywgZW50cmllcyk7XG59XG5mdW5jdGlvbiBUb1RlbXBvcmFsTW9udGhEYXlGaWVsZHMoYmFnLCBmaWVsZE5hbWVzKSB7XG4gICAgY29uc3QgZW50cmllcyA9IFtcbiAgICAgICAgWydkYXknLCB1bmRlZmluZWRdLFxuICAgICAgICBbJ21vbnRoJywgdW5kZWZpbmVkXSxcbiAgICAgICAgWydtb250aENvZGUnLCB1bmRlZmluZWRdLFxuICAgICAgICBbJ3llYXInLCB1bmRlZmluZWRdXG4gICAgXTtcbiAgICAvLyBBZGQgZXh0cmEgZmllbGRzIGZyb20gdGhlIGNhbGVuZGFyIGF0IHRoZSBlbmRcbiAgICBmaWVsZE5hbWVzLmZvckVhY2goKGZpZWxkTmFtZSkgPT4ge1xuICAgICAgICBpZiAoIWVudHJpZXMuc29tZSgoW25hbWVdKSA9PiBuYW1lID09PSBmaWVsZE5hbWUpKSB7XG4gICAgICAgICAgICBlbnRyaWVzLnB1c2goW2ZpZWxkTmFtZSwgdW5kZWZpbmVkXSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gUHJlcGFyZVRlbXBvcmFsRmllbGRzKGJhZywgZW50cmllcyk7XG59XG5mdW5jdGlvbiBUb1RlbXBvcmFsVGltZVJlY29yZChiYWcpIHtcbiAgICByZXR1cm4gUHJlcGFyZVRlbXBvcmFsRmllbGRzKGJhZywgW1xuICAgICAgICBbJ2hvdXInLCAwXSxcbiAgICAgICAgWydtaWNyb3NlY29uZCcsIDBdLFxuICAgICAgICBbJ21pbGxpc2Vjb25kJywgMF0sXG4gICAgICAgIFsnbWludXRlJywgMF0sXG4gICAgICAgIFsnbmFub3NlY29uZCcsIDBdLFxuICAgICAgICBbJ3NlY29uZCcsIDBdXG4gICAgXSk7XG59XG5mdW5jdGlvbiBUb1RlbXBvcmFsWWVhck1vbnRoRmllbGRzKGJhZywgZmllbGROYW1lcykge1xuICAgIGNvbnN0IGVudHJpZXMgPSBbXG4gICAgICAgIFsnbW9udGgnLCB1bmRlZmluZWRdLFxuICAgICAgICBbJ21vbnRoQ29kZScsIHVuZGVmaW5lZF0sXG4gICAgICAgIFsneWVhcicsIHVuZGVmaW5lZF1cbiAgICBdO1xuICAgIC8vIEFkZCBleHRyYSBmaWVsZHMgZnJvbSB0aGUgY2FsZW5kYXIgYXQgdGhlIGVuZFxuICAgIGZpZWxkTmFtZXMuZm9yRWFjaCgoZmllbGROYW1lKSA9PiB7XG4gICAgICAgIGlmICghZW50cmllcy5zb21lKChbbmFtZV0pID0+IG5hbWUgPT09IGZpZWxkTmFtZSkpIHtcbiAgICAgICAgICAgIGVudHJpZXMucHVzaChbZmllbGROYW1lLCB1bmRlZmluZWRdKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBQcmVwYXJlVGVtcG9yYWxGaWVsZHMoYmFnLCBlbnRyaWVzKTtcbn1cbmZ1bmN0aW9uIFRvVGVtcG9yYWxab25lZERhdGVUaW1lRmllbGRzKGJhZywgZmllbGROYW1lcykge1xuICAgIGNvbnN0IGVudHJpZXMgPSBbXG4gICAgICAgIFsnZGF5JywgdW5kZWZpbmVkXSxcbiAgICAgICAgWydob3VyJywgMF0sXG4gICAgICAgIFsnbWljcm9zZWNvbmQnLCAwXSxcbiAgICAgICAgWydtaWxsaXNlY29uZCcsIDBdLFxuICAgICAgICBbJ21pbnV0ZScsIDBdLFxuICAgICAgICBbJ21vbnRoJywgdW5kZWZpbmVkXSxcbiAgICAgICAgWydtb250aENvZGUnLCB1bmRlZmluZWRdLFxuICAgICAgICBbJ25hbm9zZWNvbmQnLCAwXSxcbiAgICAgICAgWydzZWNvbmQnLCAwXSxcbiAgICAgICAgWyd5ZWFyJywgdW5kZWZpbmVkXSxcbiAgICAgICAgWydvZmZzZXQnLCB1bmRlZmluZWRdLFxuICAgICAgICBbJ3RpbWVab25lJ11cbiAgICBdO1xuICAgIC8vIEFkZCBleHRyYSBmaWVsZHMgZnJvbSB0aGUgY2FsZW5kYXIgYXQgdGhlIGVuZFxuICAgIGZpZWxkTmFtZXMuZm9yRWFjaCgoZmllbGROYW1lKSA9PiB7XG4gICAgICAgIGlmICghZW50cmllcy5zb21lKChbbmFtZV0pID0+IG5hbWUgPT09IGZpZWxkTmFtZSkpIHtcbiAgICAgICAgICAgIGVudHJpZXMucHVzaChbZmllbGROYW1lLCB1bmRlZmluZWRdKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBQcmVwYXJlVGVtcG9yYWxGaWVsZHMoYmFnLCBlbnRyaWVzKTtcbn1cbmZ1bmN0aW9uIFRvVGVtcG9yYWxEYXRlKGl0ZW1QYXJhbSwgb3B0aW9ucyA9IE9iamVjdENyZWF0ZSQyKG51bGwpKSB7XG4gICAgbGV0IGl0ZW0gPSBpdGVtUGFyYW07XG4gICAgaWYgKElzT2JqZWN0KGl0ZW0pKSB7XG4gICAgICAgIGlmIChJc1RlbXBvcmFsRGF0ZShpdGVtKSlcbiAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICBpZiAoSXNUZW1wb3JhbFpvbmVkRGF0ZVRpbWUoaXRlbSkpIHtcbiAgICAgICAgICAgIGl0ZW0gPSBCdWlsdGluVGltZVpvbmVHZXRQbGFpbkRhdGVUaW1lRm9yKEdldFNsb3QoaXRlbSwgVElNRV9aT05FKSwgR2V0U2xvdChpdGVtLCBJTlNUQU5UKSwgR2V0U2xvdChpdGVtLCBDQUxFTkRBUikpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChJc1RlbXBvcmFsRGF0ZVRpbWUoaXRlbSkpIHtcbiAgICAgICAgICAgIHJldHVybiBDcmVhdGVUZW1wb3JhbERhdGUoR2V0U2xvdChpdGVtLCBJU09fWUVBUiksIEdldFNsb3QoaXRlbSwgSVNPX01PTlRIKSwgR2V0U2xvdChpdGVtLCBJU09fREFZKSwgR2V0U2xvdChpdGVtLCBDQUxFTkRBUikpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNhbGVuZGFyID0gR2V0VGVtcG9yYWxDYWxlbmRhcldpdGhJU09EZWZhdWx0KGl0ZW0pO1xuICAgICAgICBjb25zdCBmaWVsZE5hbWVzID0gQ2FsZW5kYXJGaWVsZHMoY2FsZW5kYXIsIFsnZGF5JywgJ21vbnRoJywgJ21vbnRoQ29kZScsICd5ZWFyJ10pO1xuICAgICAgICBjb25zdCBmaWVsZHMgPSBUb1RlbXBvcmFsRGF0ZUZpZWxkcyhpdGVtLCBmaWVsZE5hbWVzKTtcbiAgICAgICAgcmV0dXJuIERhdGVGcm9tRmllbGRzKGNhbGVuZGFyLCBmaWVsZHMsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBUb1RlbXBvcmFsT3ZlcmZsb3cob3B0aW9ucyk7IC8vIHZhbGlkYXRlIGFuZCBpZ25vcmVcbiAgICBjb25zdCB7IHllYXIsIG1vbnRoLCBkYXksIGNhbGVuZGFyLCB6IH0gPSBQYXJzZVRlbXBvcmFsRGF0ZVN0cmluZyhUb1N0cmluZyhpdGVtKSk7XG4gICAgaWYgKHopXG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdaIGRlc2lnbmF0b3Igbm90IHN1cHBvcnRlZCBmb3IgUGxhaW5EYXRlJyk7XG4gICAgY29uc3QgVGVtcG9yYWxQbGFpbkRhdGUgPSBHZXRJbnRyaW5zaWMoJyVUZW1wb3JhbC5QbGFpbkRhdGUlJyk7XG4gICAgcmV0dXJuIG5ldyBUZW1wb3JhbFBsYWluRGF0ZSh5ZWFyLCBtb250aCwgZGF5LCBjYWxlbmRhcik7IC8vIGluY2x1ZGUgdmFsaWRhdGlvblxufVxuZnVuY3Rpb24gSW50ZXJwcmV0VGVtcG9yYWxEYXRlVGltZUZpZWxkcyhjYWxlbmRhciwgZmllbGRzLCBvcHRpb25zKSB7XG4gICAgbGV0IHsgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kLCBtaWNyb3NlY29uZCwgbmFub3NlY29uZCB9ID0gVG9UZW1wb3JhbFRpbWVSZWNvcmQoZmllbGRzKTtcbiAgICBjb25zdCBvdmVyZmxvdyA9IFRvVGVtcG9yYWxPdmVyZmxvdyhvcHRpb25zKTtcbiAgICBjb25zdCBkYXRlID0gRGF0ZUZyb21GaWVsZHMoY2FsZW5kYXIsIGZpZWxkcywgb3B0aW9ucyk7XG4gICAgY29uc3QgeWVhciA9IEdldFNsb3QoZGF0ZSwgSVNPX1lFQVIpO1xuICAgIGNvbnN0IG1vbnRoID0gR2V0U2xvdChkYXRlLCBJU09fTU9OVEgpO1xuICAgIGNvbnN0IGRheSA9IEdldFNsb3QoZGF0ZSwgSVNPX0RBWSk7XG4gICAgKHsgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kLCBtaWNyb3NlY29uZCwgbmFub3NlY29uZCB9ID0gUmVndWxhdGVUaW1lKGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZCwgbWljcm9zZWNvbmQsIG5hbm9zZWNvbmQsIG92ZXJmbG93KSk7XG4gICAgcmV0dXJuIHsgeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kLCBtaWNyb3NlY29uZCwgbmFub3NlY29uZCB9O1xufVxuZnVuY3Rpb24gVG9UZW1wb3JhbERhdGVUaW1lKGl0ZW0sIG9wdGlvbnMgPSBPYmplY3RDcmVhdGUkMihudWxsKSkge1xuICAgIGxldCB5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQsIG1pY3Jvc2Vjb25kLCBuYW5vc2Vjb25kLCBjYWxlbmRhcjtcbiAgICBpZiAoSXNPYmplY3QoaXRlbSkpIHtcbiAgICAgICAgaWYgKElzVGVtcG9yYWxEYXRlVGltZShpdGVtKSlcbiAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICBpZiAoSXNUZW1wb3JhbFpvbmVkRGF0ZVRpbWUoaXRlbSkpIHtcbiAgICAgICAgICAgIHJldHVybiBCdWlsdGluVGltZVpvbmVHZXRQbGFpbkRhdGVUaW1lRm9yKEdldFNsb3QoaXRlbSwgVElNRV9aT05FKSwgR2V0U2xvdChpdGVtLCBJTlNUQU5UKSwgR2V0U2xvdChpdGVtLCBDQUxFTkRBUikpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChJc1RlbXBvcmFsRGF0ZShpdGVtKSkge1xuICAgICAgICAgICAgcmV0dXJuIENyZWF0ZVRlbXBvcmFsRGF0ZVRpbWUoR2V0U2xvdChpdGVtLCBJU09fWUVBUiksIEdldFNsb3QoaXRlbSwgSVNPX01PTlRIKSwgR2V0U2xvdChpdGVtLCBJU09fREFZKSwgMCwgMCwgMCwgMCwgMCwgMCwgR2V0U2xvdChpdGVtLCBDQUxFTkRBUikpO1xuICAgICAgICB9XG4gICAgICAgIGNhbGVuZGFyID0gR2V0VGVtcG9yYWxDYWxlbmRhcldpdGhJU09EZWZhdWx0KGl0ZW0pO1xuICAgICAgICBjb25zdCBmaWVsZE5hbWVzID0gQ2FsZW5kYXJGaWVsZHMoY2FsZW5kYXIsIFtcbiAgICAgICAgICAgICdkYXknLFxuICAgICAgICAgICAgJ2hvdXInLFxuICAgICAgICAgICAgJ21pY3Jvc2Vjb25kJyxcbiAgICAgICAgICAgICdtaWxsaXNlY29uZCcsXG4gICAgICAgICAgICAnbWludXRlJyxcbiAgICAgICAgICAgICdtb250aCcsXG4gICAgICAgICAgICAnbW9udGhDb2RlJyxcbiAgICAgICAgICAgICduYW5vc2Vjb25kJyxcbiAgICAgICAgICAgICdzZWNvbmQnLFxuICAgICAgICAgICAgJ3llYXInXG4gICAgICAgIF0pO1xuICAgICAgICBjb25zdCBmaWVsZHMgPSBUb1RlbXBvcmFsRGF0ZVRpbWVGaWVsZHMoaXRlbSwgZmllbGROYW1lcyk7XG4gICAgICAgICh7IHllYXIsIG1vbnRoLCBkYXksIGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZCwgbWljcm9zZWNvbmQsIG5hbm9zZWNvbmQgfSA9IEludGVycHJldFRlbXBvcmFsRGF0ZVRpbWVGaWVsZHMoY2FsZW5kYXIsIGZpZWxkcywgb3B0aW9ucykpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgVG9UZW1wb3JhbE92ZXJmbG93KG9wdGlvbnMpOyAvLyB2YWxpZGF0ZSBhbmQgaWdub3JlXG4gICAgICAgIGxldCB6O1xuICAgICAgICAoeyB5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQsIG1pY3Jvc2Vjb25kLCBuYW5vc2Vjb25kLCBjYWxlbmRhciwgeiB9ID1cbiAgICAgICAgICAgIFBhcnNlVGVtcG9yYWxEYXRlVGltZVN0cmluZyhUb1N0cmluZyhpdGVtKSkpO1xuICAgICAgICBpZiAoeilcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdaIGRlc2lnbmF0b3Igbm90IHN1cHBvcnRlZCBmb3IgUGxhaW5EYXRlVGltZScpO1xuICAgICAgICBSZWplY3REYXRlVGltZSh5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQsIG1pY3Jvc2Vjb25kLCBuYW5vc2Vjb25kKTtcbiAgICAgICAgaWYgKGNhbGVuZGFyID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICBjYWxlbmRhciA9IEdldElTTzg2MDFDYWxlbmRhcigpO1xuICAgICAgICBjYWxlbmRhciA9IFRvVGVtcG9yYWxDYWxlbmRhcihjYWxlbmRhcik7XG4gICAgfVxuICAgIHJldHVybiBDcmVhdGVUZW1wb3JhbERhdGVUaW1lKHllYXIsIG1vbnRoLCBkYXksIGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZCwgbWljcm9zZWNvbmQsIG5hbm9zZWNvbmQsIGNhbGVuZGFyKTtcbn1cbmZ1bmN0aW9uIFRvVGVtcG9yYWxEdXJhdGlvbihpdGVtKSB7XG4gICAgbGV0IHllYXJzLCBtb250aHMsIHdlZWtzLCBkYXlzLCBob3VycywgbWludXRlcywgc2Vjb25kcywgbWlsbGlzZWNvbmRzLCBtaWNyb3NlY29uZHMsIG5hbm9zZWNvbmRzO1xuICAgIGlmIChJc09iamVjdChpdGVtKSkge1xuICAgICAgICBpZiAoSXNUZW1wb3JhbER1cmF0aW9uKGl0ZW0pKVxuICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgICh7IHllYXJzLCBtb250aHMsIHdlZWtzLCBkYXlzLCBob3VycywgbWludXRlcywgc2Vjb25kcywgbWlsbGlzZWNvbmRzLCBtaWNyb3NlY29uZHMsIG5hbm9zZWNvbmRzIH0gPVxuICAgICAgICAgICAgVG9UZW1wb3JhbER1cmF0aW9uUmVjb3JkKGl0ZW0pKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgICh7IHllYXJzLCBtb250aHMsIHdlZWtzLCBkYXlzLCBob3VycywgbWludXRlcywgc2Vjb25kcywgbWlsbGlzZWNvbmRzLCBtaWNyb3NlY29uZHMsIG5hbm9zZWNvbmRzIH0gPVxuICAgICAgICAgICAgUGFyc2VUZW1wb3JhbER1cmF0aW9uU3RyaW5nKFRvU3RyaW5nKGl0ZW0pKSk7XG4gICAgfVxuICAgIGNvbnN0IFRlbXBvcmFsRHVyYXRpb24gPSBHZXRJbnRyaW5zaWMoJyVUZW1wb3JhbC5EdXJhdGlvbiUnKTtcbiAgICByZXR1cm4gbmV3IFRlbXBvcmFsRHVyYXRpb24oeWVhcnMsIG1vbnRocywgd2Vla3MsIGRheXMsIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBtaWxsaXNlY29uZHMsIG1pY3Jvc2Vjb25kcywgbmFub3NlY29uZHMpO1xufVxuZnVuY3Rpb24gVG9UZW1wb3JhbEluc3RhbnQoaXRlbSkge1xuICAgIGlmIChJc1RlbXBvcmFsSW5zdGFudChpdGVtKSlcbiAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgaWYgKElzVGVtcG9yYWxab25lZERhdGVUaW1lKGl0ZW0pKSB7XG4gICAgICAgIGNvbnN0IFRlbXBvcmFsSW5zdGFudCA9IEdldEludHJpbnNpYygnJVRlbXBvcmFsLkluc3RhbnQlJyk7XG4gICAgICAgIHJldHVybiBuZXcgVGVtcG9yYWxJbnN0YW50KEdldFNsb3QoaXRlbSwgRVBPQ0hOQU5PU0VDT05EUykpO1xuICAgIH1cbiAgICBjb25zdCBucyA9IFBhcnNlVGVtcG9yYWxJbnN0YW50KFRvU3RyaW5nKGl0ZW0pKTtcbiAgICBjb25zdCBUZW1wb3JhbEluc3RhbnQgPSBHZXRJbnRyaW5zaWMoJyVUZW1wb3JhbC5JbnN0YW50JScpO1xuICAgIHJldHVybiBuZXcgVGVtcG9yYWxJbnN0YW50KG5zKTtcbn1cbmZ1bmN0aW9uIFRvVGVtcG9yYWxNb250aERheShpdGVtLCBvcHRpb25zID0gT2JqZWN0Q3JlYXRlJDIobnVsbCkpIHtcbiAgICBpZiAoSXNPYmplY3QoaXRlbSkpIHtcbiAgICAgICAgaWYgKElzVGVtcG9yYWxNb250aERheShpdGVtKSlcbiAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICBsZXQgY2FsZW5kYXIsIGNhbGVuZGFyQWJzZW50O1xuICAgICAgICBpZiAoSGFzU2xvdChpdGVtLCBDQUxFTkRBUikpIHtcbiAgICAgICAgICAgIGNhbGVuZGFyID0gR2V0U2xvdChpdGVtLCBDQUxFTkRBUik7XG4gICAgICAgICAgICBjYWxlbmRhckFic2VudCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IG1heWJlU3RyaW5nQ2FsZW5kYXIgPSBpdGVtLmNhbGVuZGFyO1xuICAgICAgICAgICAgY2FsZW5kYXJBYnNlbnQgPSBtYXliZVN0cmluZ0NhbGVuZGFyID09PSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAobWF5YmVTdHJpbmdDYWxlbmRhciA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIG1heWJlU3RyaW5nQ2FsZW5kYXIgPSBHZXRJU084NjAxQ2FsZW5kYXIoKTtcbiAgICAgICAgICAgIGNhbGVuZGFyID0gVG9UZW1wb3JhbENhbGVuZGFyKG1heWJlU3RyaW5nQ2FsZW5kYXIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZpZWxkTmFtZXMgPSBDYWxlbmRhckZpZWxkcyhjYWxlbmRhciwgWydkYXknLCAnbW9udGgnLCAnbW9udGhDb2RlJywgJ3llYXInXSk7XG4gICAgICAgIGNvbnN0IGZpZWxkcyA9IFRvVGVtcG9yYWxNb250aERheUZpZWxkcyhpdGVtLCBmaWVsZE5hbWVzKTtcbiAgICAgICAgLy8gQ2FsbGVycyB3aG8gb21pdCB0aGUgY2FsZW5kYXIgYXJlIG5vdCB3cml0aW5nIGNhbGVuZGFyLWluZGVwZW5kZW50XG4gICAgICAgIC8vIGNvZGUuIEluIHRoYXQgY2FzZSwgYG1vbnRoQ29kZWAvYHllYXJgIGNhbiBiZSBvbWl0dGVkOyBgbW9udGhgIGFuZFxuICAgICAgICAvLyBgZGF5YCBhcmUgc3VmZmljaWVudC4gQWRkIGEgYHllYXJgIHRvIHNhdGlzZnkgY2FsZW5kYXIgdmFsaWRhdGlvbi5cbiAgICAgICAgaWYgKGNhbGVuZGFyQWJzZW50ICYmIGZpZWxkcy5tb250aCAhPT0gdW5kZWZpbmVkICYmIGZpZWxkcy5tb250aENvZGUgPT09IHVuZGVmaW5lZCAmJiBmaWVsZHMueWVhciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBmaWVsZHMueWVhciA9IDE5NzI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE1vbnRoRGF5RnJvbUZpZWxkcyhjYWxlbmRhciwgZmllbGRzLCBvcHRpb25zKTtcbiAgICB9XG4gICAgVG9UZW1wb3JhbE92ZXJmbG93KG9wdGlvbnMpOyAvLyB2YWxpZGF0ZSBhbmQgaWdub3JlXG4gICAgbGV0IHsgbW9udGgsIGRheSwgcmVmZXJlbmNlSVNPWWVhciwgY2FsZW5kYXI6IG1heWJlU3RyaW5nQ2FsZW5kYXIgfSA9IFBhcnNlVGVtcG9yYWxNb250aERheVN0cmluZyhUb1N0cmluZyhpdGVtKSk7XG4gICAgbGV0IGNhbGVuZGFyID0gbWF5YmVTdHJpbmdDYWxlbmRhcjtcbiAgICBpZiAoY2FsZW5kYXIgPT09IHVuZGVmaW5lZClcbiAgICAgICAgY2FsZW5kYXIgPSBHZXRJU084NjAxQ2FsZW5kYXIoKTtcbiAgICBjYWxlbmRhciA9IFRvVGVtcG9yYWxDYWxlbmRhcihjYWxlbmRhcik7XG4gICAgaWYgKHJlZmVyZW5jZUlTT1llYXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBSZWplY3RJU09EYXRlKDE5NzIsIG1vbnRoLCBkYXkpO1xuICAgICAgICByZXR1cm4gQ3JlYXRlVGVtcG9yYWxNb250aERheShtb250aCwgZGF5LCBjYWxlbmRhcik7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IENyZWF0ZVRlbXBvcmFsTW9udGhEYXkobW9udGgsIGRheSwgY2FsZW5kYXIsIHJlZmVyZW5jZUlTT1llYXIpO1xuICAgIGNvbnN0IGNhbm9uaWNhbE9wdGlvbnMgPSBPYmplY3RDcmVhdGUkMihudWxsKTtcbiAgICByZXR1cm4gTW9udGhEYXlGcm9tRmllbGRzKGNhbGVuZGFyLCByZXN1bHQsIGNhbm9uaWNhbE9wdGlvbnMpO1xufVxuZnVuY3Rpb24gVG9UZW1wb3JhbFRpbWUoaXRlbVBhcmFtLCBvdmVyZmxvdyA9ICdjb25zdHJhaW4nKSB7XG4gICAgbGV0IGl0ZW0gPSBpdGVtUGFyYW07XG4gICAgbGV0IGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZCwgbWljcm9zZWNvbmQsIG5hbm9zZWNvbmQsIGNhbGVuZGFyO1xuICAgIGlmIChJc09iamVjdChpdGVtKSkge1xuICAgICAgICBpZiAoSXNUZW1wb3JhbFRpbWUoaXRlbSkpXG4gICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgaWYgKElzVGVtcG9yYWxab25lZERhdGVUaW1lKGl0ZW0pKSB7XG4gICAgICAgICAgICBpdGVtID0gQnVpbHRpblRpbWVab25lR2V0UGxhaW5EYXRlVGltZUZvcihHZXRTbG90KGl0ZW0sIFRJTUVfWk9ORSksIEdldFNsb3QoaXRlbSwgSU5TVEFOVCksIEdldFNsb3QoaXRlbSwgQ0FMRU5EQVIpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoSXNUZW1wb3JhbERhdGVUaW1lKGl0ZW0pKSB7XG4gICAgICAgICAgICBjb25zdCBUZW1wb3JhbFBsYWluVGltZSA9IEdldEludHJpbnNpYygnJVRlbXBvcmFsLlBsYWluVGltZSUnKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVGVtcG9yYWxQbGFpblRpbWUoR2V0U2xvdChpdGVtLCBJU09fSE9VUiksIEdldFNsb3QoaXRlbSwgSVNPX01JTlVURSksIEdldFNsb3QoaXRlbSwgSVNPX1NFQ09ORCksIEdldFNsb3QoaXRlbSwgSVNPX01JTExJU0VDT05EKSwgR2V0U2xvdChpdGVtLCBJU09fTUlDUk9TRUNPTkQpLCBHZXRTbG90KGl0ZW0sIElTT19OQU5PU0VDT05EKSk7XG4gICAgICAgIH1cbiAgICAgICAgY2FsZW5kYXIgPSBHZXRUZW1wb3JhbENhbGVuZGFyV2l0aElTT0RlZmF1bHQoaXRlbSk7XG4gICAgICAgIGlmIChUb1N0cmluZyhjYWxlbmRhcikgIT09ICdpc284NjAxJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1BsYWluVGltZSBjYW4gb25seSBoYXZlIGlzbzg2MDEgY2FsZW5kYXInKTtcbiAgICAgICAgfVxuICAgICAgICAoeyBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQsIG1pY3Jvc2Vjb25kLCBuYW5vc2Vjb25kIH0gPSBUb1RlbXBvcmFsVGltZVJlY29yZChpdGVtKSk7XG4gICAgICAgICh7IGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZCwgbWljcm9zZWNvbmQsIG5hbm9zZWNvbmQgfSA9IFJlZ3VsYXRlVGltZShob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQsIG1pY3Jvc2Vjb25kLCBuYW5vc2Vjb25kLCBvdmVyZmxvdykpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgKHsgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kLCBtaWNyb3NlY29uZCwgbmFub3NlY29uZCwgY2FsZW5kYXIgfSA9IFBhcnNlVGVtcG9yYWxUaW1lU3RyaW5nKFRvU3RyaW5nKGl0ZW0pKSk7XG4gICAgICAgIFJlamVjdFRpbWUoaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kLCBtaWNyb3NlY29uZCwgbmFub3NlY29uZCk7XG4gICAgICAgIGlmIChjYWxlbmRhciAhPT0gdW5kZWZpbmVkICYmIGNhbGVuZGFyICE9PSAnaXNvODYwMScpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdQbGFpblRpbWUgY2FuIG9ubHkgaGF2ZSBpc284NjAxIGNhbGVuZGFyJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgVGVtcG9yYWxQbGFpblRpbWUgPSBHZXRJbnRyaW5zaWMoJyVUZW1wb3JhbC5QbGFpblRpbWUlJyk7XG4gICAgcmV0dXJuIG5ldyBUZW1wb3JhbFBsYWluVGltZShob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQsIG1pY3Jvc2Vjb25kLCBuYW5vc2Vjb25kKTtcbn1cbmZ1bmN0aW9uIFRvVGVtcG9yYWxZZWFyTW9udGgoaXRlbSwgb3B0aW9ucyA9IE9iamVjdENyZWF0ZSQyKG51bGwpKSB7XG4gICAgaWYgKElzT2JqZWN0KGl0ZW0pKSB7XG4gICAgICAgIGlmIChJc1RlbXBvcmFsWWVhck1vbnRoKGl0ZW0pKVxuICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgIGNvbnN0IGNhbGVuZGFyID0gR2V0VGVtcG9yYWxDYWxlbmRhcldpdGhJU09EZWZhdWx0KGl0ZW0pO1xuICAgICAgICBjb25zdCBmaWVsZE5hbWVzID0gQ2FsZW5kYXJGaWVsZHMoY2FsZW5kYXIsIFsnbW9udGgnLCAnbW9udGhDb2RlJywgJ3llYXInXSk7XG4gICAgICAgIGNvbnN0IGZpZWxkcyA9IFRvVGVtcG9yYWxZZWFyTW9udGhGaWVsZHMoaXRlbSwgZmllbGROYW1lcyk7XG4gICAgICAgIHJldHVybiBZZWFyTW9udGhGcm9tRmllbGRzKGNhbGVuZGFyLCBmaWVsZHMsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBUb1RlbXBvcmFsT3ZlcmZsb3cob3B0aW9ucyk7IC8vIHZhbGlkYXRlIGFuZCBpZ25vcmVcbiAgICBsZXQgeyB5ZWFyLCBtb250aCwgcmVmZXJlbmNlSVNPRGF5LCBjYWxlbmRhcjogbWF5YmVTdHJpbmdDYWxlbmRhciB9ID0gUGFyc2VUZW1wb3JhbFllYXJNb250aFN0cmluZyhUb1N0cmluZyhpdGVtKSk7XG4gICAgLy8gVE9ETzogcmVwbGFjZSB3aXRoIHRlcm5hcnk/XG4gICAgbGV0IGNhbGVuZGFyID0gbWF5YmVTdHJpbmdDYWxlbmRhcjtcbiAgICBpZiAoY2FsZW5kYXIgPT09IHVuZGVmaW5lZClcbiAgICAgICAgY2FsZW5kYXIgPSBHZXRJU084NjAxQ2FsZW5kYXIoKTtcbiAgICBjYWxlbmRhciA9IFRvVGVtcG9yYWxDYWxlbmRhcihjYWxlbmRhcik7XG4gICAgaWYgKHJlZmVyZW5jZUlTT0RheSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIFJlamVjdElTT0RhdGUoeWVhciwgbW9udGgsIDEpO1xuICAgICAgICByZXR1cm4gQ3JlYXRlVGVtcG9yYWxZZWFyTW9udGgoeWVhciwgbW9udGgsIGNhbGVuZGFyKTtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gQ3JlYXRlVGVtcG9yYWxZZWFyTW9udGgoeWVhciwgbW9udGgsIGNhbGVuZGFyLCByZWZlcmVuY2VJU09EYXkpO1xuICAgIGNvbnN0IGNhbm9uaWNhbE9wdGlvbnMgPSBPYmplY3RDcmVhdGUkMihudWxsKTtcbiAgICByZXR1cm4gWWVhck1vbnRoRnJvbUZpZWxkcyhjYWxlbmRhciwgcmVzdWx0LCBjYW5vbmljYWxPcHRpb25zKTtcbn1cbmZ1bmN0aW9uIEludGVycHJldElTT0RhdGVUaW1lT2Zmc2V0KHllYXIsIG1vbnRoLCBkYXksIGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZCwgbWljcm9zZWNvbmQsIG5hbm9zZWNvbmQsIG9mZnNldEJlaGF2aW91ciwgb2Zmc2V0TnMsIHRpbWVab25lLCBkaXNhbWJpZ3VhdGlvbiwgb2Zmc2V0T3B0LCBtYXRjaE1pbnV0ZSkge1xuICAgIGNvbnN0IERhdGVUaW1lID0gR2V0SW50cmluc2ljKCclVGVtcG9yYWwuUGxhaW5EYXRlVGltZSUnKTtcbiAgICBjb25zdCBkdCA9IG5ldyBEYXRlVGltZSh5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQsIG1pY3Jvc2Vjb25kLCBuYW5vc2Vjb25kKTtcbiAgICBpZiAob2Zmc2V0QmVoYXZpb3VyID09PSAnd2FsbCcgfHwgb2Zmc2V0T3B0ID09PSAnaWdub3JlJykge1xuICAgICAgICAvLyBTaW1wbGUgY2FzZTogSVNPIHN0cmluZyB3aXRob3V0IGEgVFogb2Zmc2V0IChvciBjYWxsZXIgd2FudHMgdG8gaWdub3JlXG4gICAgICAgIC8vIHRoZSBvZmZzZXQpLCBzbyBqdXN0IGNvbnZlcnQgRGF0ZVRpbWUgdG8gSW5zdGFudCBpbiB0aGUgZ2l2ZW4gdGltZSB6b25lXG4gICAgICAgIGNvbnN0IGluc3RhbnQgPSBCdWlsdGluVGltZVpvbmVHZXRJbnN0YW50Rm9yKHRpbWVab25lLCBkdCwgZGlzYW1iaWd1YXRpb24pO1xuICAgICAgICByZXR1cm4gR2V0U2xvdChpbnN0YW50LCBFUE9DSE5BTk9TRUNPTkRTKTtcbiAgICB9XG4gICAgLy8gVGhlIGNhbGxlciB3YW50cyB0aGUgb2Zmc2V0IHRvIGFsd2F5cyB3aW4gKCd1c2UnKSBPUiB0aGUgY2FsbGVyIGlzIE9LXG4gICAgLy8gd2l0aCB0aGUgb2Zmc2V0IHdpbm5pbmcgKCdwcmVmZXInIG9yICdyZWplY3QnKSBhcyBsb25nIGFzIGl0J3MgdmFsaWRcbiAgICAvLyBmb3IgdGhpcyB0aW1lem9uZSBhbmQgZGF0ZS90aW1lLlxuICAgIGlmIChvZmZzZXRCZWhhdmlvdXIgPT09ICdleGFjdCcgfHwgb2Zmc2V0T3B0ID09PSAndXNlJykge1xuICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIGluc3RhbnQgZm9yIHRoZSBpbnB1dCdzIGRhdGUvdGltZSBhbmQgb2Zmc2V0XG4gICAgICAgIGNvbnN0IGVwb2NoTnMgPSBHZXRFcG9jaEZyb21JU09QYXJ0cyh5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQsIG1pY3Jvc2Vjb25kLCBuYW5vc2Vjb25kKTtcbiAgICAgICAgaWYgKGVwb2NoTnMgPT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignWm9uZWREYXRlVGltZSBvdXRzaWRlIG9mIHN1cHBvcnRlZCByYW5nZScpO1xuICAgICAgICByZXR1cm4gSlNCSS5zdWJ0cmFjdChlcG9jaE5zLCBKU0JJLkJpZ0ludChvZmZzZXROcykpO1xuICAgIH1cbiAgICAvLyBcInByZWZlclwiIG9yIFwicmVqZWN0XCJcbiAgICBjb25zdCBwb3NzaWJsZUluc3RhbnRzID0gR2V0UG9zc2libGVJbnN0YW50c0Zvcih0aW1lWm9uZSwgZHQpO1xuICAgIGZvciAoY29uc3QgY2FuZGlkYXRlIG9mIHBvc3NpYmxlSW5zdGFudHMpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlT2Zmc2V0ID0gR2V0T2Zmc2V0TmFub3NlY29uZHNGb3IodGltZVpvbmUsIGNhbmRpZGF0ZSk7XG4gICAgICAgIGNvbnN0IHJvdW5kZWRDYW5kaWRhdGVPZmZzZXQgPSBKU0JJLnRvTnVtYmVyKFJvdW5kTnVtYmVyVG9JbmNyZW1lbnQoSlNCSS5CaWdJbnQoY2FuZGlkYXRlT2Zmc2V0KSwgNjBlOSwgJ2hhbGZFeHBhbmQnKSk7XG4gICAgICAgIGlmIChjYW5kaWRhdGVPZmZzZXQgPT09IG9mZnNldE5zIHx8IChtYXRjaE1pbnV0ZSAmJiByb3VuZGVkQ2FuZGlkYXRlT2Zmc2V0ID09PSBvZmZzZXROcykpIHtcbiAgICAgICAgICAgIHJldHVybiBHZXRTbG90KGNhbmRpZGF0ZSwgRVBPQ0hOQU5PU0VDT05EUyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gdGhlIHVzZXItcHJvdmlkZWQgb2Zmc2V0IGRvZXNuJ3QgbWF0Y2ggYW55IGluc3RhbnRzIGZvciB0aGlzIHRpbWVcbiAgICAvLyB6b25lIGFuZCBkYXRlL3RpbWUuXG4gICAgaWYgKG9mZnNldE9wdCA9PT0gJ3JlamVjdCcpIHtcbiAgICAgICAgY29uc3Qgb2Zmc2V0U3RyID0gRm9ybWF0VGltZVpvbmVPZmZzZXRTdHJpbmcob2Zmc2V0TnMpO1xuICAgICAgICBjb25zdCB0aW1lWm9uZVN0cmluZyA9IElzVGVtcG9yYWxUaW1lWm9uZSh0aW1lWm9uZSkgPyBHZXRTbG90KHRpbWVab25lLCBUSU1FWk9ORV9JRCkgOiAndGltZSB6b25lJztcbiAgICAgICAgLy8gVGhlIHRzYyBlbWl0IGZvciB0aGlzIGxpbmUgcmV3cml0ZXMgdG8gaW52b2tlIHRoZSBQbGFpbkRhdGVUaW1lJ3MgdmFsdWVPZiBtZXRob2QsIE5PVFxuICAgICAgICAvLyB0b1N0cmluZyAod2hpY2ggaXMgaW52b2tlZCBieSBOb2RlIHdoZW4gdXNpbmcgdGVtcGxhdGUgbGl0ZXJhbHMgZGlyZWN0bHkpLlxuICAgICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL21pY3Jvc29mdC9UeXBlU2NyaXB0L2lzc3Vlcy8zOTc0NCBmb3IgdGhlIHByb3Bvc2VkIGZpeCBpbiB0c2MgZW1pdFxuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgT2Zmc2V0ICR7b2Zmc2V0U3RyfSBpcyBpbnZhbGlkIGZvciAke2R0LnRvU3RyaW5nKCl9IGluICR7dGltZVpvbmVTdHJpbmd9YCk7XG4gICAgfVxuICAgIC8vIGZhbGwgdGhyb3VnaDogb2Zmc2V0T3B0ID09PSAncHJlZmVyJywgYnV0IHRoZSBvZmZzZXQgZG9lc24ndCBtYXRjaFxuICAgIC8vIHNvIGZhbGwgYmFjayB0byB1c2UgdGhlIHRpbWUgem9uZSBpbnN0ZWFkLlxuICAgIGNvbnN0IGluc3RhbnQgPSBEaXNhbWJpZ3VhdGVQb3NzaWJsZUluc3RhbnRzKHBvc3NpYmxlSW5zdGFudHMsIHRpbWVab25lLCBkdCwgZGlzYW1iaWd1YXRpb24pO1xuICAgIHJldHVybiBHZXRTbG90KGluc3RhbnQsIEVQT0NITkFOT1NFQ09ORFMpO1xufVxuZnVuY3Rpb24gVG9UZW1wb3JhbFpvbmVkRGF0ZVRpbWUoaXRlbSwgb3B0aW9ucyA9IE9iamVjdENyZWF0ZSQyKG51bGwpKSB7XG4gICAgbGV0IHllYXIsIG1vbnRoLCBkYXksIGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZCwgbWljcm9zZWNvbmQsIG5hbm9zZWNvbmQsIHRpbWVab25lLCBvZmZzZXQsIGNhbGVuZGFyO1xuICAgIGxldCBtYXRjaE1pbnV0ZSA9IGZhbHNlO1xuICAgIGxldCBvZmZzZXRCZWhhdmlvdXIgPSAnb3B0aW9uJztcbiAgICBpZiAoSXNPYmplY3QoaXRlbSkpIHtcbiAgICAgICAgaWYgKElzVGVtcG9yYWxab25lZERhdGVUaW1lKGl0ZW0pKVxuICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgIGNhbGVuZGFyID0gR2V0VGVtcG9yYWxDYWxlbmRhcldpdGhJU09EZWZhdWx0KGl0ZW0pO1xuICAgICAgICBjb25zdCBmaWVsZE5hbWVzID0gQ2FsZW5kYXJGaWVsZHMoY2FsZW5kYXIsIFtcbiAgICAgICAgICAgICdkYXknLFxuICAgICAgICAgICAgJ2hvdXInLFxuICAgICAgICAgICAgJ21pY3Jvc2Vjb25kJyxcbiAgICAgICAgICAgICdtaWxsaXNlY29uZCcsXG4gICAgICAgICAgICAnbWludXRlJyxcbiAgICAgICAgICAgICdtb250aCcsXG4gICAgICAgICAgICAnbW9udGhDb2RlJyxcbiAgICAgICAgICAgICduYW5vc2Vjb25kJyxcbiAgICAgICAgICAgICdzZWNvbmQnLFxuICAgICAgICAgICAgJ3llYXInXG4gICAgICAgIF0pO1xuICAgICAgICBjb25zdCBmaWVsZHMgPSBUb1RlbXBvcmFsWm9uZWREYXRlVGltZUZpZWxkcyhpdGVtLCBmaWVsZE5hbWVzKTtcbiAgICAgICAgKHsgeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kLCBtaWNyb3NlY29uZCwgbmFub3NlY29uZCB9ID0gSW50ZXJwcmV0VGVtcG9yYWxEYXRlVGltZUZpZWxkcyhjYWxlbmRhciwgZmllbGRzLCBvcHRpb25zKSk7XG4gICAgICAgIHRpbWVab25lID0gVG9UZW1wb3JhbFRpbWVab25lKGZpZWxkcy50aW1lWm9uZSk7XG4gICAgICAgIG9mZnNldCA9IGZpZWxkcy5vZmZzZXQ7XG4gICAgICAgIGlmIChvZmZzZXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgb2Zmc2V0QmVoYXZpb3VyID0gJ3dhbGwnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb2Zmc2V0ID0gVG9TdHJpbmcob2Zmc2V0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgVG9UZW1wb3JhbE92ZXJmbG93KG9wdGlvbnMpOyAvLyB2YWxpZGF0ZSBhbmQgaWdub3JlXG4gICAgICAgIGxldCBpYW5hTmFtZSwgejtcbiAgICAgICAgKHsgeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kLCBtaWNyb3NlY29uZCwgbmFub3NlY29uZCwgaWFuYU5hbWUsIG9mZnNldCwgeiwgY2FsZW5kYXIgfSA9XG4gICAgICAgICAgICBQYXJzZVRlbXBvcmFsWm9uZWREYXRlVGltZVN0cmluZyhUb1N0cmluZyhpdGVtKSkpO1xuICAgICAgICBpZiAoIWlhbmFOYW1lKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3RpbWUgem9uZSBJRCByZXF1aXJlZCBpbiBicmFja2V0cycpO1xuICAgICAgICBpZiAoeikge1xuICAgICAgICAgICAgb2Zmc2V0QmVoYXZpb3VyID0gJ2V4YWN0JztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghb2Zmc2V0KSB7XG4gICAgICAgICAgICBvZmZzZXRCZWhhdmlvdXIgPSAnd2FsbCc7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgVGVtcG9yYWxUaW1lWm9uZSA9IEdldEludHJpbnNpYygnJVRlbXBvcmFsLlRpbWVab25lJScpO1xuICAgICAgICB0aW1lWm9uZSA9IG5ldyBUZW1wb3JhbFRpbWVab25lKGlhbmFOYW1lKTtcbiAgICAgICAgaWYgKCFjYWxlbmRhcilcbiAgICAgICAgICAgIGNhbGVuZGFyID0gR2V0SVNPODYwMUNhbGVuZGFyKCk7XG4gICAgICAgIGNhbGVuZGFyID0gVG9UZW1wb3JhbENhbGVuZGFyKGNhbGVuZGFyKTtcbiAgICAgICAgbWF0Y2hNaW51dGUgPSB0cnVlOyAvLyBJU08gc3RyaW5ncyBtYXkgc3BlY2lmeSBvZmZzZXQgd2l0aCBsZXNzIHByZWNpc2lvblxuICAgIH1cbiAgICBsZXQgb2Zmc2V0TnMgPSAwO1xuICAgIC8vIFRoZSBjb2RlIGFib3ZlIGd1YXJhbnRlZXMgdGhhdCBpZiBvZmZzZXRCZWhhdmlvdXIgPT09ICdvcHRpb24nLCB0aGVuXG4gICAgLy8gYG9mZnNldGAgaXMgbm90IHVuZGVmaW5lZC5cbiAgICBpZiAob2Zmc2V0QmVoYXZpb3VyID09PSAnb3B0aW9uJylcbiAgICAgICAgb2Zmc2V0TnMgPSBQYXJzZVRpbWVab25lT2Zmc2V0U3RyaW5nKG9mZnNldCk7XG4gICAgY29uc3QgZGlzYW1iaWd1YXRpb24gPSBUb1RlbXBvcmFsRGlzYW1iaWd1YXRpb24ob3B0aW9ucyk7XG4gICAgY29uc3Qgb2Zmc2V0T3B0ID0gVG9UZW1wb3JhbE9mZnNldChvcHRpb25zLCAncmVqZWN0Jyk7XG4gICAgY29uc3QgZXBvY2hOYW5vc2Vjb25kcyA9IEludGVycHJldElTT0RhdGVUaW1lT2Zmc2V0KHllYXIsIG1vbnRoLCBkYXksIGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZCwgbWljcm9zZWNvbmQsIG5hbm9zZWNvbmQsIG9mZnNldEJlaGF2aW91ciwgb2Zmc2V0TnMsIHRpbWVab25lLCBkaXNhbWJpZ3VhdGlvbiwgb2Zmc2V0T3B0LCBtYXRjaE1pbnV0ZSk7XG4gICAgcmV0dXJuIENyZWF0ZVRlbXBvcmFsWm9uZWREYXRlVGltZShlcG9jaE5hbm9zZWNvbmRzLCB0aW1lWm9uZSwgY2FsZW5kYXIpO1xufVxuZnVuY3Rpb24gQ3JlYXRlVGVtcG9yYWxEYXRlU2xvdHMocmVzdWx0LCBpc29ZZWFyLCBpc29Nb250aCwgaXNvRGF5LCBjYWxlbmRhcikge1xuICAgIFJlamVjdElTT0RhdGUoaXNvWWVhciwgaXNvTW9udGgsIGlzb0RheSk7XG4gICAgUmVqZWN0RGF0ZVJhbmdlKGlzb1llYXIsIGlzb01vbnRoLCBpc29EYXkpO1xuICAgIENyZWF0ZVNsb3RzKHJlc3VsdCk7XG4gICAgU2V0U2xvdChyZXN1bHQsIElTT19ZRUFSLCBpc29ZZWFyKTtcbiAgICBTZXRTbG90KHJlc3VsdCwgSVNPX01PTlRILCBpc29Nb250aCk7XG4gICAgU2V0U2xvdChyZXN1bHQsIElTT19EQVksIGlzb0RheSk7XG4gICAgU2V0U2xvdChyZXN1bHQsIENBTEVOREFSLCBjYWxlbmRhcik7XG4gICAgU2V0U2xvdChyZXN1bHQsIERBVEVfQlJBTkQsIHRydWUpO1xuICAgIHtcbiAgICAgICAgT2JqZWN0RGVmaW5lUHJvcGVydHkocmVzdWx0LCAnX3JlcHJfJywge1xuICAgICAgICAgICAgdmFsdWU6IGAke3Jlc3VsdFtTeW1ib2wudG9TdHJpbmdUYWddfSA8JHtUZW1wb3JhbERhdGVUb1N0cmluZyhyZXN1bHQpfT5gLFxuICAgICAgICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIENyZWF0ZVRlbXBvcmFsRGF0ZShpc29ZZWFyLCBpc29Nb250aCwgaXNvRGF5LCBjYWxlbmRhciA9IEdldElTTzg2MDFDYWxlbmRhcigpKSB7XG4gICAgY29uc3QgVGVtcG9yYWxQbGFpbkRhdGUgPSBHZXRJbnRyaW5zaWMoJyVUZW1wb3JhbC5QbGFpbkRhdGUlJyk7XG4gICAgY29uc3QgcmVzdWx0ID0gT2JqZWN0Q3JlYXRlJDIoVGVtcG9yYWxQbGFpbkRhdGUucHJvdG90eXBlKTtcbiAgICBDcmVhdGVUZW1wb3JhbERhdGVTbG90cyhyZXN1bHQsIGlzb1llYXIsIGlzb01vbnRoLCBpc29EYXksIGNhbGVuZGFyKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gQ3JlYXRlVGVtcG9yYWxEYXRlVGltZVNsb3RzKHJlc3VsdCwgaXNvWWVhciwgaXNvTW9udGgsIGlzb0RheSwgaCwgbWluLCBzLCBtcywgwrVzLCBucywgY2FsZW5kYXIpIHtcbiAgICBSZWplY3REYXRlVGltZShpc29ZZWFyLCBpc29Nb250aCwgaXNvRGF5LCBoLCBtaW4sIHMsIG1zLCDCtXMsIG5zKTtcbiAgICBSZWplY3REYXRlVGltZVJhbmdlKGlzb1llYXIsIGlzb01vbnRoLCBpc29EYXksIGgsIG1pbiwgcywgbXMsIMK1cywgbnMpO1xuICAgIENyZWF0ZVNsb3RzKHJlc3VsdCk7XG4gICAgU2V0U2xvdChyZXN1bHQsIElTT19ZRUFSLCBpc29ZZWFyKTtcbiAgICBTZXRTbG90KHJlc3VsdCwgSVNPX01PTlRILCBpc29Nb250aCk7XG4gICAgU2V0U2xvdChyZXN1bHQsIElTT19EQVksIGlzb0RheSk7XG4gICAgU2V0U2xvdChyZXN1bHQsIElTT19IT1VSLCBoKTtcbiAgICBTZXRTbG90KHJlc3VsdCwgSVNPX01JTlVURSwgbWluKTtcbiAgICBTZXRTbG90KHJlc3VsdCwgSVNPX1NFQ09ORCwgcyk7XG4gICAgU2V0U2xvdChyZXN1bHQsIElTT19NSUxMSVNFQ09ORCwgbXMpO1xuICAgIFNldFNsb3QocmVzdWx0LCBJU09fTUlDUk9TRUNPTkQsIMK1cyk7XG4gICAgU2V0U2xvdChyZXN1bHQsIElTT19OQU5PU0VDT05ELCBucyk7XG4gICAgU2V0U2xvdChyZXN1bHQsIENBTEVOREFSLCBjYWxlbmRhcik7XG4gICAge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVzdWx0LCAnX3JlcHJfJywge1xuICAgICAgICAgICAgdmFsdWU6IGAke3Jlc3VsdFtTeW1ib2wudG9TdHJpbmdUYWddfSA8JHtUZW1wb3JhbERhdGVUaW1lVG9TdHJpbmcocmVzdWx0LCAnYXV0bycpfT5gLFxuICAgICAgICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIENyZWF0ZVRlbXBvcmFsRGF0ZVRpbWUoaXNvWWVhciwgaXNvTW9udGgsIGlzb0RheSwgaCwgbWluLCBzLCBtcywgwrVzLCBucywgY2FsZW5kYXIgPSBHZXRJU084NjAxQ2FsZW5kYXIoKSkge1xuICAgIGNvbnN0IFRlbXBvcmFsUGxhaW5EYXRlVGltZSA9IEdldEludHJpbnNpYygnJVRlbXBvcmFsLlBsYWluRGF0ZVRpbWUlJyk7XG4gICAgY29uc3QgcmVzdWx0ID0gT2JqZWN0Q3JlYXRlJDIoVGVtcG9yYWxQbGFpbkRhdGVUaW1lLnByb3RvdHlwZSk7XG4gICAgQ3JlYXRlVGVtcG9yYWxEYXRlVGltZVNsb3RzKHJlc3VsdCwgaXNvWWVhciwgaXNvTW9udGgsIGlzb0RheSwgaCwgbWluLCBzLCBtcywgwrVzLCBucywgY2FsZW5kYXIpO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBDcmVhdGVUZW1wb3JhbE1vbnRoRGF5U2xvdHMocmVzdWx0LCBpc29Nb250aCwgaXNvRGF5LCBjYWxlbmRhciwgcmVmZXJlbmNlSVNPWWVhcikge1xuICAgIFJlamVjdElTT0RhdGUocmVmZXJlbmNlSVNPWWVhciwgaXNvTW9udGgsIGlzb0RheSk7XG4gICAgUmVqZWN0RGF0ZVJhbmdlKHJlZmVyZW5jZUlTT1llYXIsIGlzb01vbnRoLCBpc29EYXkpO1xuICAgIENyZWF0ZVNsb3RzKHJlc3VsdCk7XG4gICAgU2V0U2xvdChyZXN1bHQsIElTT19NT05USCwgaXNvTW9udGgpO1xuICAgIFNldFNsb3QocmVzdWx0LCBJU09fREFZLCBpc29EYXkpO1xuICAgIFNldFNsb3QocmVzdWx0LCBJU09fWUVBUiwgcmVmZXJlbmNlSVNPWWVhcik7XG4gICAgU2V0U2xvdChyZXN1bHQsIENBTEVOREFSLCBjYWxlbmRhcik7XG4gICAgU2V0U2xvdChyZXN1bHQsIE1PTlRIX0RBWV9CUkFORCwgdHJ1ZSk7XG4gICAge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVzdWx0LCAnX3JlcHJfJywge1xuICAgICAgICAgICAgdmFsdWU6IGAke3Jlc3VsdFtTeW1ib2wudG9TdHJpbmdUYWddfSA8JHtUZW1wb3JhbE1vbnRoRGF5VG9TdHJpbmcocmVzdWx0KX0+YCxcbiAgICAgICAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICB9XG59XG5mdW5jdGlvbiBDcmVhdGVUZW1wb3JhbE1vbnRoRGF5KGlzb01vbnRoLCBpc29EYXksIGNhbGVuZGFyID0gR2V0SVNPODYwMUNhbGVuZGFyKCksIHJlZmVyZW5jZUlTT1llYXIgPSAxOTcyKSB7XG4gICAgY29uc3QgVGVtcG9yYWxQbGFpbk1vbnRoRGF5ID0gR2V0SW50cmluc2ljKCclVGVtcG9yYWwuUGxhaW5Nb250aERheSUnKTtcbiAgICBjb25zdCByZXN1bHQgPSBPYmplY3RDcmVhdGUkMihUZW1wb3JhbFBsYWluTW9udGhEYXkucHJvdG90eXBlKTtcbiAgICBDcmVhdGVUZW1wb3JhbE1vbnRoRGF5U2xvdHMocmVzdWx0LCBpc29Nb250aCwgaXNvRGF5LCBjYWxlbmRhciwgcmVmZXJlbmNlSVNPWWVhcik7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIENyZWF0ZVRlbXBvcmFsWWVhck1vbnRoU2xvdHMocmVzdWx0LCBpc29ZZWFyLCBpc29Nb250aCwgY2FsZW5kYXIsIHJlZmVyZW5jZUlTT0RheSkge1xuICAgIFJlamVjdElTT0RhdGUoaXNvWWVhciwgaXNvTW9udGgsIHJlZmVyZW5jZUlTT0RheSk7XG4gICAgUmVqZWN0WWVhck1vbnRoUmFuZ2UoaXNvWWVhciwgaXNvTW9udGgpO1xuICAgIENyZWF0ZVNsb3RzKHJlc3VsdCk7XG4gICAgU2V0U2xvdChyZXN1bHQsIElTT19ZRUFSLCBpc29ZZWFyKTtcbiAgICBTZXRTbG90KHJlc3VsdCwgSVNPX01PTlRILCBpc29Nb250aCk7XG4gICAgU2V0U2xvdChyZXN1bHQsIElTT19EQVksIHJlZmVyZW5jZUlTT0RheSk7XG4gICAgU2V0U2xvdChyZXN1bHQsIENBTEVOREFSLCBjYWxlbmRhcik7XG4gICAgU2V0U2xvdChyZXN1bHQsIFlFQVJfTU9OVEhfQlJBTkQsIHRydWUpO1xuICAgIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlc3VsdCwgJ19yZXByXycsIHtcbiAgICAgICAgICAgIHZhbHVlOiBgJHtyZXN1bHRbU3ltYm9sLnRvU3RyaW5nVGFnXX0gPCR7VGVtcG9yYWxZZWFyTW9udGhUb1N0cmluZyhyZXN1bHQpfT5gLFxuICAgICAgICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIENyZWF0ZVRlbXBvcmFsWWVhck1vbnRoKGlzb1llYXIsIGlzb01vbnRoLCBjYWxlbmRhciA9IEdldElTTzg2MDFDYWxlbmRhcigpLCByZWZlcmVuY2VJU09EYXkgPSAxKSB7XG4gICAgY29uc3QgVGVtcG9yYWxQbGFpblllYXJNb250aCA9IEdldEludHJpbnNpYygnJVRlbXBvcmFsLlBsYWluWWVhck1vbnRoJScpO1xuICAgIGNvbnN0IHJlc3VsdCA9IE9iamVjdENyZWF0ZSQyKFRlbXBvcmFsUGxhaW5ZZWFyTW9udGgucHJvdG90eXBlKTtcbiAgICBDcmVhdGVUZW1wb3JhbFllYXJNb250aFNsb3RzKHJlc3VsdCwgaXNvWWVhciwgaXNvTW9udGgsIGNhbGVuZGFyLCByZWZlcmVuY2VJU09EYXkpO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBDcmVhdGVUZW1wb3JhbFpvbmVkRGF0ZVRpbWVTbG90cyhyZXN1bHQsIGVwb2NoTmFub3NlY29uZHMsIHRpbWVab25lLCBjYWxlbmRhcikge1xuICAgIFZhbGlkYXRlRXBvY2hOYW5vc2Vjb25kcyhlcG9jaE5hbm9zZWNvbmRzKTtcbiAgICBDcmVhdGVTbG90cyhyZXN1bHQpO1xuICAgIFNldFNsb3QocmVzdWx0LCBFUE9DSE5BTk9TRUNPTkRTLCBlcG9jaE5hbm9zZWNvbmRzKTtcbiAgICBTZXRTbG90KHJlc3VsdCwgVElNRV9aT05FLCB0aW1lWm9uZSk7XG4gICAgU2V0U2xvdChyZXN1bHQsIENBTEVOREFSLCBjYWxlbmRhcik7XG4gICAgY29uc3QgVGVtcG9yYWxJbnN0YW50ID0gR2V0SW50cmluc2ljKCclVGVtcG9yYWwuSW5zdGFudCUnKTtcbiAgICBjb25zdCBpbnN0YW50ID0gbmV3IFRlbXBvcmFsSW5zdGFudChHZXRTbG90KHJlc3VsdCwgRVBPQ0hOQU5PU0VDT05EUykpO1xuICAgIFNldFNsb3QocmVzdWx0LCBJTlNUQU5ULCBpbnN0YW50KTtcbiAgICB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZXN1bHQsICdfcmVwcl8nLCB7XG4gICAgICAgICAgICB2YWx1ZTogYCR7cmVzdWx0W1N5bWJvbC50b1N0cmluZ1RhZ119IDwke1RlbXBvcmFsWm9uZWREYXRlVGltZVRvU3RyaW5nKHJlc3VsdCwgJ2F1dG8nKX0+YCxcbiAgICAgICAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICB9XG59XG5mdW5jdGlvbiBDcmVhdGVUZW1wb3JhbFpvbmVkRGF0ZVRpbWUoZXBvY2hOYW5vc2Vjb25kcywgdGltZVpvbmUsIGNhbGVuZGFyID0gR2V0SVNPODYwMUNhbGVuZGFyKCkpIHtcbiAgICBjb25zdCBUZW1wb3JhbFpvbmVkRGF0ZVRpbWUgPSBHZXRJbnRyaW5zaWMoJyVUZW1wb3JhbC5ab25lZERhdGVUaW1lJScpO1xuICAgIGNvbnN0IHJlc3VsdCA9IE9iamVjdENyZWF0ZSQyKFRlbXBvcmFsWm9uZWREYXRlVGltZS5wcm90b3R5cGUpO1xuICAgIENyZWF0ZVRlbXBvcmFsWm9uZWREYXRlVGltZVNsb3RzKHJlc3VsdCwgZXBvY2hOYW5vc2Vjb25kcywgdGltZVpvbmUsIGNhbGVuZGFyKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gR2V0SVNPODYwMUNhbGVuZGFyKCkge1xuICAgIGNvbnN0IFRlbXBvcmFsQ2FsZW5kYXIgPSBHZXRJbnRyaW5zaWMoJyVUZW1wb3JhbC5DYWxlbmRhciUnKTtcbiAgICByZXR1cm4gbmV3IFRlbXBvcmFsQ2FsZW5kYXIoJ2lzbzg2MDEnKTtcbn1cbi8vIFRPRE86IHNob3VsZCAoY2FuPykgd2UgbWFrZSB0aGlzIGdlbmVyaWMgc28gdGhlIGZpZWxkIG5hbWVzIGFyZSBjaGVja2VkXG4vLyBhZ2FpbnN0IHRoZSB0eXBlIHRoYXQgdGhlIGNhbGVuZGFyIGlzIGEgcHJvcGVydHkgb2Y/XG5mdW5jdGlvbiBDYWxlbmRhckZpZWxkcyhjYWxlbmRhciwgZmllbGROYW1lc1BhcmFtKSB7XG4gICAgbGV0IGZpZWxkTmFtZXMgPSBmaWVsZE5hbWVzUGFyYW07XG4gICAgaWYgKGNhbGVuZGFyLmZpZWxkcykge1xuICAgICAgICBmaWVsZE5hbWVzID0gY2FsZW5kYXIuZmllbGRzKGZpZWxkTmFtZXMpO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBmb3IgKGNvbnN0IG5hbWUgb2YgZmllbGROYW1lcykge1xuICAgICAgICBpZiAodHlwZW9mIG5hbWUgIT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYmFkIHJldHVybiBmcm9tIGNhbGVuZGFyLmZpZWxkcygpJyk7XG4gICAgICAgIEFycmF5UHJvdG90eXBlUHVzaCQxLmNhbGwocmVzdWx0LCBuYW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIENhbGVuZGFyTWVyZ2VGaWVsZHMoY2FsZW5kYXIsIGZpZWxkcywgYWRkaXRpb25hbEZpZWxkcykge1xuICAgIGNvbnN0IGNhbE1lcmdlRmllbGRzID0gY2FsZW5kYXIubWVyZ2VGaWVsZHM7XG4gICAgaWYgKCFjYWxNZXJnZUZpZWxkcykge1xuICAgICAgICByZXR1cm4geyAuLi5maWVsZHMsIC4uLmFkZGl0aW9uYWxGaWVsZHMgfTtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gUmVmbGVjdC5hcHBseShjYWxNZXJnZUZpZWxkcywgY2FsZW5kYXIsIFtmaWVsZHMsIGFkZGl0aW9uYWxGaWVsZHNdKTtcbiAgICBpZiAoIUlzT2JqZWN0KHJlc3VsdCkpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2JhZCByZXR1cm4gZnJvbSBjYWxlbmRhci5tZXJnZUZpZWxkcygpJyk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIENhbGVuZGFyRGF0ZUFkZChjYWxlbmRhciwgZGF0ZSwgZHVyYXRpb24sIG9wdGlvbnMsIGRhdGVBZGRQYXJhbSkge1xuICAgIGxldCBkYXRlQWRkID0gZGF0ZUFkZFBhcmFtO1xuICAgIGlmIChkYXRlQWRkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZGF0ZUFkZCA9IGNhbGVuZGFyLmRhdGVBZGQ7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IFJlZmxlY3RBcHBseSQxKGRhdGVBZGQsIGNhbGVuZGFyLCBbZGF0ZSwgZHVyYXRpb24sIG9wdGlvbnNdKTtcbiAgICBpZiAoIUlzVGVtcG9yYWxEYXRlKHJlc3VsdCkpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVzdWx0Jyk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIENhbGVuZGFyRGF0ZVVudGlsKGNhbGVuZGFyLCBkYXRlLCBvdGhlckRhdGUsIG9wdGlvbnMsIGRhdGVVbnRpbFBhcmFtKSB7XG4gICAgbGV0IGRhdGVVbnRpbCA9IGRhdGVVbnRpbFBhcmFtO1xuICAgIGlmIChkYXRlVW50aWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBkYXRlVW50aWwgPSBjYWxlbmRhci5kYXRlVW50aWw7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IFJlZmxlY3RBcHBseSQxKGRhdGVVbnRpbCwgY2FsZW5kYXIsIFtkYXRlLCBvdGhlckRhdGUsIG9wdGlvbnNdKTtcbiAgICBpZiAoIUlzVGVtcG9yYWxEdXJhdGlvbihyZXN1bHQpKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlc3VsdCcpO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBDYWxlbmRhclllYXIoY2FsZW5kYXIsIGRhdGVMaWtlKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gY2FsZW5kYXIueWVhcihkYXRlTGlrZSk7XG4gICAgaWYgKHJlc3VsdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdjYWxlbmRhciB5ZWFyIHJlc3VsdCBtdXN0IGJlIGFuIGludGVnZXInKTtcbiAgICB9XG4gICAgcmV0dXJuIFRvSW50ZWdlclRocm93T25JbmZpbml0eShyZXN1bHQpO1xufVxuZnVuY3Rpb24gQ2FsZW5kYXJNb250aChjYWxlbmRhciwgZGF0ZUxpa2UpIHtcbiAgICBjb25zdCByZXN1bHQgPSBjYWxlbmRhci5tb250aChkYXRlTGlrZSk7XG4gICAgaWYgKHJlc3VsdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdjYWxlbmRhciBtb250aCByZXN1bHQgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXInKTtcbiAgICB9XG4gICAgcmV0dXJuIFRvUG9zaXRpdmVJbnRlZ2VyKHJlc3VsdCk7XG59XG5mdW5jdGlvbiBDYWxlbmRhck1vbnRoQ29kZShjYWxlbmRhciwgZGF0ZUxpa2UpIHtcbiAgICBjb25zdCByZXN1bHQgPSBjYWxlbmRhci5tb250aENvZGUoZGF0ZUxpa2UpO1xuICAgIGlmIChyZXN1bHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignY2FsZW5kYXIgbW9udGhDb2RlIHJlc3VsdCBtdXN0IGJlIGEgc3RyaW5nJyk7XG4gICAgfVxuICAgIHJldHVybiBUb1N0cmluZyhyZXN1bHQpO1xufVxuZnVuY3Rpb24gQ2FsZW5kYXJEYXkoY2FsZW5kYXIsIGRhdGVMaWtlKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gY2FsZW5kYXIuZGF5KGRhdGVMaWtlKTtcbiAgICBpZiAocmVzdWx0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2NhbGVuZGFyIGRheSByZXN1bHQgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXInKTtcbiAgICB9XG4gICAgcmV0dXJuIFRvUG9zaXRpdmVJbnRlZ2VyKHJlc3VsdCk7XG59XG5mdW5jdGlvbiBDYWxlbmRhckVyYShjYWxlbmRhciwgZGF0ZUxpa2UpIHtcbiAgICBsZXQgcmVzdWx0ID0gY2FsZW5kYXIuZXJhKGRhdGVMaWtlKTtcbiAgICBpZiAocmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmVzdWx0ID0gVG9TdHJpbmcocmVzdWx0KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIENhbGVuZGFyRXJhWWVhcihjYWxlbmRhciwgZGF0ZUxpa2UpIHtcbiAgICBsZXQgcmVzdWx0ID0gY2FsZW5kYXIuZXJhWWVhcihkYXRlTGlrZSk7XG4gICAgaWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJlc3VsdCA9IFRvSW50ZWdlclRocm93T25JbmZpbml0eShyZXN1bHQpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gQ2FsZW5kYXJEYXlPZldlZWsoY2FsZW5kYXIsIGRhdGVMaWtlKSB7XG4gICAgcmV0dXJuIGNhbGVuZGFyLmRheU9mV2VlayhkYXRlTGlrZSk7XG59XG5mdW5jdGlvbiBDYWxlbmRhckRheU9mWWVhcihjYWxlbmRhciwgZGF0ZUxpa2UpIHtcbiAgICByZXR1cm4gY2FsZW5kYXIuZGF5T2ZZZWFyKGRhdGVMaWtlKTtcbn1cbmZ1bmN0aW9uIENhbGVuZGFyV2Vla09mWWVhcihjYWxlbmRhciwgZGF0ZUxpa2UpIHtcbiAgICByZXR1cm4gY2FsZW5kYXIud2Vla09mWWVhcihkYXRlTGlrZSk7XG59XG5mdW5jdGlvbiBDYWxlbmRhckRheXNJbldlZWsoY2FsZW5kYXIsIGRhdGVMaWtlKSB7XG4gICAgcmV0dXJuIGNhbGVuZGFyLmRheXNJbldlZWsoZGF0ZUxpa2UpO1xufVxuZnVuY3Rpb24gQ2FsZW5kYXJEYXlzSW5Nb250aChjYWxlbmRhciwgZGF0ZUxpa2UpIHtcbiAgICByZXR1cm4gY2FsZW5kYXIuZGF5c0luTW9udGgoZGF0ZUxpa2UpO1xufVxuZnVuY3Rpb24gQ2FsZW5kYXJEYXlzSW5ZZWFyKGNhbGVuZGFyLCBkYXRlTGlrZSkge1xuICAgIHJldHVybiBjYWxlbmRhci5kYXlzSW5ZZWFyKGRhdGVMaWtlKTtcbn1cbmZ1bmN0aW9uIENhbGVuZGFyTW9udGhzSW5ZZWFyKGNhbGVuZGFyLCBkYXRlTGlrZSkge1xuICAgIHJldHVybiBjYWxlbmRhci5tb250aHNJblllYXIoZGF0ZUxpa2UpO1xufVxuZnVuY3Rpb24gQ2FsZW5kYXJJbkxlYXBZZWFyKGNhbGVuZGFyLCBkYXRlTGlrZSkge1xuICAgIHJldHVybiBjYWxlbmRhci5pbkxlYXBZZWFyKGRhdGVMaWtlKTtcbn1cbmZ1bmN0aW9uIFRvVGVtcG9yYWxDYWxlbmRhcihjYWxlbmRhckxpa2VQYXJhbSkge1xuICAgIGxldCBjYWxlbmRhckxpa2UgPSBjYWxlbmRhckxpa2VQYXJhbTtcbiAgICBpZiAoSXNPYmplY3QoY2FsZW5kYXJMaWtlKSkge1xuICAgICAgICBpZiAoSGFzU2xvdChjYWxlbmRhckxpa2UsIENBTEVOREFSKSlcbiAgICAgICAgICAgIHJldHVybiBHZXRTbG90KGNhbGVuZGFyTGlrZSwgQ0FMRU5EQVIpO1xuICAgICAgICBpZiAoISgnY2FsZW5kYXInIGluIGNhbGVuZGFyTGlrZSkpXG4gICAgICAgICAgICByZXR1cm4gY2FsZW5kYXJMaWtlO1xuICAgICAgICBjYWxlbmRhckxpa2UgPSBjYWxlbmRhckxpa2UuY2FsZW5kYXI7XG4gICAgICAgIGlmIChJc09iamVjdChjYWxlbmRhckxpa2UpICYmICEoJ2NhbGVuZGFyJyBpbiBjYWxlbmRhckxpa2UpKVxuICAgICAgICAgICAgcmV0dXJuIGNhbGVuZGFyTGlrZTtcbiAgICB9XG4gICAgY29uc3QgaWRlbnRpZmllciA9IFRvU3RyaW5nKGNhbGVuZGFyTGlrZSk7XG4gICAgY29uc3QgVGVtcG9yYWxDYWxlbmRhciA9IEdldEludHJpbnNpYygnJVRlbXBvcmFsLkNhbGVuZGFyJScpO1xuICAgIGlmIChJc0J1aWx0aW5DYWxlbmRhcihpZGVudGlmaWVyKSlcbiAgICAgICAgcmV0dXJuIG5ldyBUZW1wb3JhbENhbGVuZGFyKGlkZW50aWZpZXIpO1xuICAgIGxldCBjYWxlbmRhcjtcbiAgICB0cnkge1xuICAgICAgICAoeyBjYWxlbmRhciB9ID0gUGFyc2VJU09EYXRlVGltZShpZGVudGlmaWVyKSk7XG4gICAgfVxuICAgIGNhdGNoIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYEludmFsaWQgY2FsZW5kYXI6ICR7aWRlbnRpZmllcn1gKTtcbiAgICB9XG4gICAgaWYgKCFjYWxlbmRhcilcbiAgICAgICAgY2FsZW5kYXIgPSAnaXNvODYwMSc7XG4gICAgcmV0dXJuIG5ldyBUZW1wb3JhbENhbGVuZGFyKGNhbGVuZGFyKTtcbn1cbmZ1bmN0aW9uIEdldFRlbXBvcmFsQ2FsZW5kYXJXaXRoSVNPRGVmYXVsdChpdGVtKSB7XG4gICAgaWYgKEhhc1Nsb3QoaXRlbSwgQ0FMRU5EQVIpKVxuICAgICAgICByZXR1cm4gR2V0U2xvdChpdGVtLCBDQUxFTkRBUik7XG4gICAgY29uc3QgeyBjYWxlbmRhciB9ID0gaXRlbTtcbiAgICBpZiAoY2FsZW5kYXIgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIEdldElTTzg2MDFDYWxlbmRhcigpO1xuICAgIHJldHVybiBUb1RlbXBvcmFsQ2FsZW5kYXIoY2FsZW5kYXIpO1xufVxuZnVuY3Rpb24gQ2FsZW5kYXJFcXVhbHMob25lLCB0d28pIHtcbiAgICBpZiAob25lID09PSB0d28pXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIGNvbnN0IGNhbDEgPSBUb1N0cmluZyhvbmUpO1xuICAgIGNvbnN0IGNhbDIgPSBUb1N0cmluZyh0d28pO1xuICAgIHJldHVybiBjYWwxID09PSBjYWwyO1xufVxuZnVuY3Rpb24gQ29uc29saWRhdGVDYWxlbmRhcnMob25lLCB0d28pIHtcbiAgICBpZiAob25lID09PSB0d28pXG4gICAgICAgIHJldHVybiB0d287XG4gICAgY29uc3Qgc09uZSA9IFRvU3RyaW5nKG9uZSk7XG4gICAgY29uc3Qgc1R3byA9IFRvU3RyaW5nKHR3byk7XG4gICAgaWYgKHNPbmUgPT09IHNUd28gfHwgc09uZSA9PT0gJ2lzbzg2MDEnKSB7XG4gICAgICAgIHJldHVybiB0d287XG4gICAgfVxuICAgIGVsc2UgaWYgKHNUd28gPT09ICdpc284NjAxJykge1xuICAgICAgICByZXR1cm4gb25lO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2lycmVjb25jaWxhYmxlIGNhbGVuZGFycycpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIERhdGVGcm9tRmllbGRzKGNhbGVuZGFyLCBmaWVsZHMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCByZXN1bHQgPSBjYWxlbmRhci5kYXRlRnJvbUZpZWxkcyhmaWVsZHMsIG9wdGlvbnMpO1xuICAgIGlmICghSXNUZW1wb3JhbERhdGUocmVzdWx0KSlcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZXN1bHQnKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gWWVhck1vbnRoRnJvbUZpZWxkcyhjYWxlbmRhciwgZmllbGRzLCBvcHRpb25zKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gY2FsZW5kYXIueWVhck1vbnRoRnJvbUZpZWxkcyhmaWVsZHMsIG9wdGlvbnMpO1xuICAgIGlmICghSXNUZW1wb3JhbFllYXJNb250aChyZXN1bHQpKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlc3VsdCcpO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBNb250aERheUZyb21GaWVsZHMoY2FsZW5kYXIsIGZpZWxkcywgb3B0aW9ucykge1xuICAgIGNvbnN0IHJlc3VsdCA9IGNhbGVuZGFyLm1vbnRoRGF5RnJvbUZpZWxkcyhmaWVsZHMsIG9wdGlvbnMpO1xuICAgIGlmICghSXNUZW1wb3JhbE1vbnRoRGF5KHJlc3VsdCkpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVzdWx0Jyk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIFRvVGVtcG9yYWxUaW1lWm9uZSh0ZW1wb3JhbFRpbWVab25lTGlrZVBhcmFtKSB7XG4gICAgbGV0IHRlbXBvcmFsVGltZVpvbmVMaWtlID0gdGVtcG9yYWxUaW1lWm9uZUxpa2VQYXJhbTtcbiAgICBpZiAoSXNPYmplY3QodGVtcG9yYWxUaW1lWm9uZUxpa2UpKSB7XG4gICAgICAgIGlmIChJc1RlbXBvcmFsWm9uZWREYXRlVGltZSh0ZW1wb3JhbFRpbWVab25lTGlrZSkpXG4gICAgICAgICAgICByZXR1cm4gR2V0U2xvdCh0ZW1wb3JhbFRpbWVab25lTGlrZSwgVElNRV9aT05FKTtcbiAgICAgICAgaWYgKCEoJ3RpbWVab25lJyBpbiB0ZW1wb3JhbFRpbWVab25lTGlrZSkpXG4gICAgICAgICAgICByZXR1cm4gdGVtcG9yYWxUaW1lWm9uZUxpa2U7XG4gICAgICAgIHRlbXBvcmFsVGltZVpvbmVMaWtlID0gdGVtcG9yYWxUaW1lWm9uZUxpa2UudGltZVpvbmU7XG4gICAgICAgIGlmIChJc09iamVjdCh0ZW1wb3JhbFRpbWVab25lTGlrZSkgJiYgISgndGltZVpvbmUnIGluIHRlbXBvcmFsVGltZVpvbmVMaWtlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRlbXBvcmFsVGltZVpvbmVMaWtlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGlkZW50aWZpZXIgPSBUb1N0cmluZyh0ZW1wb3JhbFRpbWVab25lTGlrZSk7XG4gICAgY29uc3QgdGltZVpvbmUgPSBQYXJzZVRlbXBvcmFsVGltZVpvbmUoaWRlbnRpZmllcik7XG4gICAgY29uc3QgVGVtcG9yYWxUaW1lWm9uZSA9IEdldEludHJpbnNpYygnJVRlbXBvcmFsLlRpbWVab25lJScpO1xuICAgIHJldHVybiBuZXcgVGVtcG9yYWxUaW1lWm9uZSh0aW1lWm9uZSk7XG59XG5mdW5jdGlvbiBUaW1lWm9uZUVxdWFscyhvbmUsIHR3bykge1xuICAgIGlmIChvbmUgPT09IHR3bylcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgY29uc3QgdHoxID0gVG9TdHJpbmcob25lKTtcbiAgICBjb25zdCB0ejIgPSBUb1N0cmluZyh0d28pO1xuICAgIHJldHVybiB0ejEgPT09IHR6Mjtcbn1cbmZ1bmN0aW9uIFRlbXBvcmFsRGF0ZVRpbWVUb0RhdGUoZGF0ZVRpbWUpIHtcbiAgICByZXR1cm4gQ3JlYXRlVGVtcG9yYWxEYXRlKEdldFNsb3QoZGF0ZVRpbWUsIElTT19ZRUFSKSwgR2V0U2xvdChkYXRlVGltZSwgSVNPX01PTlRIKSwgR2V0U2xvdChkYXRlVGltZSwgSVNPX0RBWSksIEdldFNsb3QoZGF0ZVRpbWUsIENBTEVOREFSKSk7XG59XG5mdW5jdGlvbiBUZW1wb3JhbERhdGVUaW1lVG9UaW1lKGRhdGVUaW1lKSB7XG4gICAgY29uc3QgVGltZSA9IEdldEludHJpbnNpYygnJVRlbXBvcmFsLlBsYWluVGltZSUnKTtcbiAgICByZXR1cm4gbmV3IFRpbWUoR2V0U2xvdChkYXRlVGltZSwgSVNPX0hPVVIpLCBHZXRTbG90KGRhdGVUaW1lLCBJU09fTUlOVVRFKSwgR2V0U2xvdChkYXRlVGltZSwgSVNPX1NFQ09ORCksIEdldFNsb3QoZGF0ZVRpbWUsIElTT19NSUxMSVNFQ09ORCksIEdldFNsb3QoZGF0ZVRpbWUsIElTT19NSUNST1NFQ09ORCksIEdldFNsb3QoZGF0ZVRpbWUsIElTT19OQU5PU0VDT05EKSk7XG59XG5mdW5jdGlvbiBHZXRPZmZzZXROYW5vc2Vjb25kc0Zvcih0aW1lWm9uZSwgaW5zdGFudCkge1xuICAgIGxldCBnZXRPZmZzZXROYW5vc2Vjb25kc0ZvciA9IHRpbWVab25lLmdldE9mZnNldE5hbm9zZWNvbmRzRm9yO1xuICAgIGlmICh0eXBlb2YgZ2V0T2Zmc2V0TmFub3NlY29uZHNGb3IgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZ2V0T2Zmc2V0TmFub3NlY29uZHNGb3Igbm90IGNhbGxhYmxlJyk7XG4gICAgfVxuICAgIGNvbnN0IG9mZnNldE5zID0gUmVmbGVjdC5hcHBseShnZXRPZmZzZXROYW5vc2Vjb25kc0ZvciwgdGltZVpvbmUsIFtpbnN0YW50XSk7XG4gICAgaWYgKHR5cGVvZiBvZmZzZXROcyAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYmFkIHJldHVybiBmcm9tIGdldE9mZnNldE5hbm9zZWNvbmRzRm9yJyk7XG4gICAgfVxuICAgIGlmICghSXNJbnRlZ2VyKG9mZnNldE5zKSB8fCBNYXRoQWJzKG9mZnNldE5zKSA+IDg2NDAwZTkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ291dC1vZi1yYW5nZSByZXR1cm4gZnJvbSBnZXRPZmZzZXROYW5vc2Vjb25kc0ZvcicpO1xuICAgIH1cbiAgICByZXR1cm4gb2Zmc2V0TnM7XG59XG5mdW5jdGlvbiBCdWlsdGluVGltZVpvbmVHZXRPZmZzZXRTdHJpbmdGb3IodGltZVpvbmUsIGluc3RhbnQpIHtcbiAgICBjb25zdCBvZmZzZXROcyA9IEdldE9mZnNldE5hbm9zZWNvbmRzRm9yKHRpbWVab25lLCBpbnN0YW50KTtcbiAgICByZXR1cm4gRm9ybWF0VGltZVpvbmVPZmZzZXRTdHJpbmcob2Zmc2V0TnMpO1xufVxuZnVuY3Rpb24gQnVpbHRpblRpbWVab25lR2V0UGxhaW5EYXRlVGltZUZvcih0aW1lWm9uZSwgaW5zdGFudCwgY2FsZW5kYXIpIHtcbiAgICBjb25zdCBucyA9IEdldFNsb3QoaW5zdGFudCwgRVBPQ0hOQU5PU0VDT05EUyk7XG4gICAgY29uc3Qgb2Zmc2V0TnMgPSBHZXRPZmZzZXROYW5vc2Vjb25kc0Zvcih0aW1lWm9uZSwgaW5zdGFudCk7XG4gICAgbGV0IHsgeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kLCBtaWNyb3NlY29uZCwgbmFub3NlY29uZCB9ID0gR2V0SVNPUGFydHNGcm9tRXBvY2gobnMpO1xuICAgICh7IHllYXIsIG1vbnRoLCBkYXksIGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZCwgbWljcm9zZWNvbmQsIG5hbm9zZWNvbmQgfSA9IEJhbGFuY2VJU09EYXRlVGltZSh5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQsIG1pY3Jvc2Vjb25kLCBuYW5vc2Vjb25kICsgb2Zmc2V0TnMpKTtcbiAgICByZXR1cm4gQ3JlYXRlVGVtcG9yYWxEYXRlVGltZSh5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQsIG1pY3Jvc2Vjb25kLCBuYW5vc2Vjb25kLCBjYWxlbmRhcik7XG59XG5mdW5jdGlvbiBCdWlsdGluVGltZVpvbmVHZXRJbnN0YW50Rm9yKHRpbWVab25lLCBkYXRlVGltZSwgZGlzYW1iaWd1YXRpb24pIHtcbiAgICBjb25zdCBwb3NzaWJsZUluc3RhbnRzID0gR2V0UG9zc2libGVJbnN0YW50c0Zvcih0aW1lWm9uZSwgZGF0ZVRpbWUpO1xuICAgIHJldHVybiBEaXNhbWJpZ3VhdGVQb3NzaWJsZUluc3RhbnRzKHBvc3NpYmxlSW5zdGFudHMsIHRpbWVab25lLCBkYXRlVGltZSwgZGlzYW1iaWd1YXRpb24pO1xufVxuZnVuY3Rpb24gRGlzYW1iaWd1YXRlUG9zc2libGVJbnN0YW50cyhwb3NzaWJsZUluc3RhbnRzLCB0aW1lWm9uZSwgZGF0ZVRpbWUsIGRpc2FtYmlndWF0aW9uKSB7XG4gICAgY29uc3QgSW5zdGFudCA9IEdldEludHJpbnNpYygnJVRlbXBvcmFsLkluc3RhbnQlJyk7XG4gICAgY29uc3QgbnVtSW5zdGFudHMgPSBwb3NzaWJsZUluc3RhbnRzLmxlbmd0aDtcbiAgICBpZiAobnVtSW5zdGFudHMgPT09IDEpXG4gICAgICAgIHJldHVybiBwb3NzaWJsZUluc3RhbnRzWzBdO1xuICAgIGlmIChudW1JbnN0YW50cykge1xuICAgICAgICBzd2l0Y2ggKGRpc2FtYmlndWF0aW9uKSB7XG4gICAgICAgICAgICBjYXNlICdjb21wYXRpYmxlJzpcbiAgICAgICAgICAgIC8vIGZhbGwgdGhyb3VnaCBiZWNhdXNlICdjb21wYXRpYmxlJyBtZWFucyAnZWFybGllcicgZm9yIFwiZmFsbCBiYWNrXCIgdHJhbnNpdGlvbnNcbiAgICAgICAgICAgIGNhc2UgJ2VhcmxpZXInOlxuICAgICAgICAgICAgICAgIHJldHVybiBwb3NzaWJsZUluc3RhbnRzWzBdO1xuICAgICAgICAgICAgY2FzZSAnbGF0ZXInOlxuICAgICAgICAgICAgICAgIHJldHVybiBwb3NzaWJsZUluc3RhbnRzW251bUluc3RhbnRzIC0gMV07XG4gICAgICAgICAgICBjYXNlICdyZWplY3QnOiB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ211bHRpcGxlIGluc3RhbnRzIGZvdW5kJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgeWVhciA9IEdldFNsb3QoZGF0ZVRpbWUsIElTT19ZRUFSKTtcbiAgICBjb25zdCBtb250aCA9IEdldFNsb3QoZGF0ZVRpbWUsIElTT19NT05USCk7XG4gICAgY29uc3QgZGF5ID0gR2V0U2xvdChkYXRlVGltZSwgSVNPX0RBWSk7XG4gICAgY29uc3QgaG91ciA9IEdldFNsb3QoZGF0ZVRpbWUsIElTT19IT1VSKTtcbiAgICBjb25zdCBtaW51dGUgPSBHZXRTbG90KGRhdGVUaW1lLCBJU09fTUlOVVRFKTtcbiAgICBjb25zdCBzZWNvbmQgPSBHZXRTbG90KGRhdGVUaW1lLCBJU09fU0VDT05EKTtcbiAgICBjb25zdCBtaWxsaXNlY29uZCA9IEdldFNsb3QoZGF0ZVRpbWUsIElTT19NSUxMSVNFQ09ORCk7XG4gICAgY29uc3QgbWljcm9zZWNvbmQgPSBHZXRTbG90KGRhdGVUaW1lLCBJU09fTUlDUk9TRUNPTkQpO1xuICAgIGNvbnN0IG5hbm9zZWNvbmQgPSBHZXRTbG90KGRhdGVUaW1lLCBJU09fTkFOT1NFQ09ORCk7XG4gICAgY29uc3QgdXRjbnMgPSBHZXRFcG9jaEZyb21JU09QYXJ0cyh5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQsIG1pY3Jvc2Vjb25kLCBuYW5vc2Vjb25kKTtcbiAgICBpZiAodXRjbnMgPT09IG51bGwpXG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdEYXRlVGltZSBvdXRzaWRlIG9mIHN1cHBvcnRlZCByYW5nZScpO1xuICAgIGNvbnN0IGRheUJlZm9yZSA9IG5ldyBJbnN0YW50KEpTQkkuc3VidHJhY3QodXRjbnMsIERBWV9OQU5PUykpO1xuICAgIGNvbnN0IGRheUFmdGVyID0gbmV3IEluc3RhbnQoSlNCSS5hZGQodXRjbnMsIERBWV9OQU5PUykpO1xuICAgIGNvbnN0IG9mZnNldEJlZm9yZSA9IEdldE9mZnNldE5hbm9zZWNvbmRzRm9yKHRpbWVab25lLCBkYXlCZWZvcmUpO1xuICAgIGNvbnN0IG9mZnNldEFmdGVyID0gR2V0T2Zmc2V0TmFub3NlY29uZHNGb3IodGltZVpvbmUsIGRheUFmdGVyKTtcbiAgICBjb25zdCBuYW5vc2Vjb25kcyA9IG9mZnNldEFmdGVyIC0gb2Zmc2V0QmVmb3JlO1xuICAgIHN3aXRjaCAoZGlzYW1iaWd1YXRpb24pIHtcbiAgICAgICAgY2FzZSAnZWFybGllcic6IHtcbiAgICAgICAgICAgIGNvbnN0IGNhbGVuZGFyID0gR2V0U2xvdChkYXRlVGltZSwgQ0FMRU5EQVIpO1xuICAgICAgICAgICAgY29uc3QgUGxhaW5EYXRlVGltZSA9IEdldEludHJpbnNpYygnJVRlbXBvcmFsLlBsYWluRGF0ZVRpbWUlJyk7XG4gICAgICAgICAgICBjb25zdCBlYXJsaWVyID0gQWRkRGF0ZVRpbWUoeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kLCBtaWNyb3NlY29uZCwgbmFub3NlY29uZCwgY2FsZW5kYXIsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIC1uYW5vc2Vjb25kcywgdW5kZWZpbmVkKTtcbiAgICAgICAgICAgIGNvbnN0IGVhcmxpZXJQbGFpbkRhdGVUaW1lID0gbmV3IFBsYWluRGF0ZVRpbWUoZWFybGllci55ZWFyLCBlYXJsaWVyLm1vbnRoLCBlYXJsaWVyLmRheSwgZWFybGllci5ob3VyLCBlYXJsaWVyLm1pbnV0ZSwgZWFybGllci5zZWNvbmQsIGVhcmxpZXIubWlsbGlzZWNvbmQsIGVhcmxpZXIubWljcm9zZWNvbmQsIGVhcmxpZXIubmFub3NlY29uZCwgY2FsZW5kYXIpO1xuICAgICAgICAgICAgcmV0dXJuIEdldFBvc3NpYmxlSW5zdGFudHNGb3IodGltZVpvbmUsIGVhcmxpZXJQbGFpbkRhdGVUaW1lKVswXTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdjb21wYXRpYmxlJzpcbiAgICAgICAgLy8gZmFsbCB0aHJvdWdoIGJlY2F1c2UgJ2NvbXBhdGlibGUnIG1lYW5zICdsYXRlcicgZm9yIFwic3ByaW5nIGZvcndhcmRcIiB0cmFuc2l0aW9uc1xuICAgICAgICBjYXNlICdsYXRlcic6IHtcbiAgICAgICAgICAgIGNvbnN0IGNhbGVuZGFyID0gR2V0U2xvdChkYXRlVGltZSwgQ0FMRU5EQVIpO1xuICAgICAgICAgICAgY29uc3QgUGxhaW5EYXRlVGltZSA9IEdldEludHJpbnNpYygnJVRlbXBvcmFsLlBsYWluRGF0ZVRpbWUlJyk7XG4gICAgICAgICAgICBjb25zdCBsYXRlciA9IEFkZERhdGVUaW1lKHllYXIsIG1vbnRoLCBkYXksIGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZCwgbWljcm9zZWNvbmQsIG5hbm9zZWNvbmQsIGNhbGVuZGFyLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCBuYW5vc2Vjb25kcywgdW5kZWZpbmVkKTtcbiAgICAgICAgICAgIGNvbnN0IGxhdGVyUGxhaW5EYXRlVGltZSA9IG5ldyBQbGFpbkRhdGVUaW1lKGxhdGVyLnllYXIsIGxhdGVyLm1vbnRoLCBsYXRlci5kYXksIGxhdGVyLmhvdXIsIGxhdGVyLm1pbnV0ZSwgbGF0ZXIuc2Vjb25kLCBsYXRlci5taWxsaXNlY29uZCwgbGF0ZXIubWljcm9zZWNvbmQsIGxhdGVyLm5hbm9zZWNvbmQsIGNhbGVuZGFyKTtcbiAgICAgICAgICAgIGNvbnN0IHBvc3NpYmxlID0gR2V0UG9zc2libGVJbnN0YW50c0Zvcih0aW1lWm9uZSwgbGF0ZXJQbGFpbkRhdGVUaW1lKTtcbiAgICAgICAgICAgIHJldHVybiBwb3NzaWJsZVtwb3NzaWJsZS5sZW5ndGggLSAxXTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdyZWplY3QnOiB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignbm8gc3VjaCBpbnN0YW50IGZvdW5kJyk7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBHZXRQb3NzaWJsZUluc3RhbnRzRm9yKHRpbWVab25lLCBkYXRlVGltZSkge1xuICAgIGNvbnN0IHBvc3NpYmxlSW5zdGFudHMgPSB0aW1lWm9uZS5nZXRQb3NzaWJsZUluc3RhbnRzRm9yKGRhdGVUaW1lKTtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGluc3RhbnQgb2YgcG9zc2libGVJbnN0YW50cykge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxJbnN0YW50KGluc3RhbnQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdiYWQgcmV0dXJuIGZyb20gZ2V0UG9zc2libGVJbnN0YW50c0ZvcicpO1xuICAgICAgICB9XG4gICAgICAgIEFycmF5UHJvdG90eXBlUHVzaCQxLmNhbGwocmVzdWx0LCBpbnN0YW50KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIElTT1llYXJTdHJpbmcoeWVhcikge1xuICAgIGxldCB5ZWFyU3RyaW5nO1xuICAgIGlmICh5ZWFyIDwgMTAwMCB8fCB5ZWFyID4gOTk5OSkge1xuICAgICAgICBjb25zdCBzaWduID0geWVhciA8IDAgPyAnLScgOiAnKyc7XG4gICAgICAgIGNvbnN0IHllYXJOdW1iZXIgPSBNYXRoQWJzKHllYXIpO1xuICAgICAgICB5ZWFyU3RyaW5nID0gc2lnbiArIGAwMDAwMDAke3llYXJOdW1iZXJ9YC5zbGljZSgtNik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB5ZWFyU3RyaW5nID0gYCR7eWVhcn1gO1xuICAgIH1cbiAgICByZXR1cm4geWVhclN0cmluZztcbn1cbmZ1bmN0aW9uIElTT0RhdGVUaW1lUGFydFN0cmluZyhwYXJ0KSB7XG4gICAgcmV0dXJuIGAwMCR7cGFydH1gLnNsaWNlKC0yKTtcbn1cbmZ1bmN0aW9uIEZvcm1hdFNlY29uZHNTdHJpbmdQYXJ0KHNlY29uZCwgbWlsbGlzZWNvbmQsIG1pY3Jvc2Vjb25kLCBuYW5vc2Vjb25kLCBwcmVjaXNpb24pIHtcbiAgICBpZiAocHJlY2lzaW9uID09PSAnbWludXRlJylcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIGNvbnN0IHNlY3MgPSBgOiR7SVNPRGF0ZVRpbWVQYXJ0U3RyaW5nKHNlY29uZCl9YDtcbiAgICBsZXQgZnJhY3Rpb25OdW1iZXIgPSBtaWxsaXNlY29uZCAqIDFlNiArIG1pY3Jvc2Vjb25kICogMWUzICsgbmFub3NlY29uZDtcbiAgICBsZXQgZnJhY3Rpb247XG4gICAgaWYgKHByZWNpc2lvbiA9PT0gJ2F1dG8nKSB7XG4gICAgICAgIGlmIChmcmFjdGlvbk51bWJlciA9PT0gMClcbiAgICAgICAgICAgIHJldHVybiBzZWNzO1xuICAgICAgICBmcmFjdGlvbiA9IGAke2ZyYWN0aW9uTnVtYmVyfWAucGFkU3RhcnQoOSwgJzAnKTtcbiAgICAgICAgd2hpbGUgKGZyYWN0aW9uW2ZyYWN0aW9uLmxlbmd0aCAtIDFdID09PSAnMCcpXG4gICAgICAgICAgICBmcmFjdGlvbiA9IGZyYWN0aW9uLnNsaWNlKDAsIC0xKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmIChwcmVjaXNpb24gPT09IDApXG4gICAgICAgICAgICByZXR1cm4gc2VjcztcbiAgICAgICAgZnJhY3Rpb24gPSBgJHtmcmFjdGlvbk51bWJlcn1gLnBhZFN0YXJ0KDksICcwJykuc2xpY2UoMCwgcHJlY2lzaW9uKTtcbiAgICB9XG4gICAgcmV0dXJuIGAke3NlY3N9LiR7ZnJhY3Rpb259YDtcbn1cbmZ1bmN0aW9uIFRlbXBvcmFsSW5zdGFudFRvU3RyaW5nKGluc3RhbnQsIHRpbWVab25lLCBwcmVjaXNpb24pIHtcbiAgICBsZXQgb3V0cHV0VGltZVpvbmUgPSB0aW1lWm9uZTtcbiAgICBpZiAob3V0cHV0VGltZVpvbmUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCBUZW1wb3JhbFRpbWVab25lID0gR2V0SW50cmluc2ljKCclVGVtcG9yYWwuVGltZVpvbmUlJyk7XG4gICAgICAgIG91dHB1dFRpbWVab25lID0gbmV3IFRlbXBvcmFsVGltZVpvbmUoJ1VUQycpO1xuICAgIH1cbiAgICBjb25zdCBpc28gPSBHZXRJU084NjAxQ2FsZW5kYXIoKTtcbiAgICBjb25zdCBkYXRlVGltZSA9IEJ1aWx0aW5UaW1lWm9uZUdldFBsYWluRGF0ZVRpbWVGb3Iob3V0cHV0VGltZVpvbmUsIGluc3RhbnQsIGlzbyk7XG4gICAgY29uc3QgeWVhciA9IElTT1llYXJTdHJpbmcoR2V0U2xvdChkYXRlVGltZSwgSVNPX1lFQVIpKTtcbiAgICBjb25zdCBtb250aCA9IElTT0RhdGVUaW1lUGFydFN0cmluZyhHZXRTbG90KGRhdGVUaW1lLCBJU09fTU9OVEgpKTtcbiAgICBjb25zdCBkYXkgPSBJU09EYXRlVGltZVBhcnRTdHJpbmcoR2V0U2xvdChkYXRlVGltZSwgSVNPX0RBWSkpO1xuICAgIGNvbnN0IGhvdXIgPSBJU09EYXRlVGltZVBhcnRTdHJpbmcoR2V0U2xvdChkYXRlVGltZSwgSVNPX0hPVVIpKTtcbiAgICBjb25zdCBtaW51dGUgPSBJU09EYXRlVGltZVBhcnRTdHJpbmcoR2V0U2xvdChkYXRlVGltZSwgSVNPX01JTlVURSkpO1xuICAgIGNvbnN0IHNlY29uZHMgPSBGb3JtYXRTZWNvbmRzU3RyaW5nUGFydChHZXRTbG90KGRhdGVUaW1lLCBJU09fU0VDT05EKSwgR2V0U2xvdChkYXRlVGltZSwgSVNPX01JTExJU0VDT05EKSwgR2V0U2xvdChkYXRlVGltZSwgSVNPX01JQ1JPU0VDT05EKSwgR2V0U2xvdChkYXRlVGltZSwgSVNPX05BTk9TRUNPTkQpLCBwcmVjaXNpb24pO1xuICAgIGxldCB0aW1lWm9uZVN0cmluZyA9ICdaJztcbiAgICBpZiAodGltZVpvbmUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCBvZmZzZXROcyA9IEdldE9mZnNldE5hbm9zZWNvbmRzRm9yKG91dHB1dFRpbWVab25lLCBpbnN0YW50KTtcbiAgICAgICAgdGltZVpvbmVTdHJpbmcgPSBGb3JtYXRJU09UaW1lWm9uZU9mZnNldFN0cmluZyhvZmZzZXROcyk7XG4gICAgfVxuICAgIHJldHVybiBgJHt5ZWFyfS0ke21vbnRofS0ke2RheX1UJHtob3VyfToke21pbnV0ZX0ke3NlY29uZHN9JHt0aW1lWm9uZVN0cmluZ31gO1xufVxuZnVuY3Rpb24gVGVtcG9yYWxEdXJhdGlvblRvU3RyaW5nKGR1cmF0aW9uLCBwcmVjaXNpb24gPSAnYXV0bycsIG9wdGlvbnMgPSB1bmRlZmluZWQpIHtcbiAgICBmdW5jdGlvbiBmb3JtYXROdW1iZXIobnVtKSB7XG4gICAgICAgIGlmIChudW0gPD0gTnVtYmVyTWF4U2FmZUludGVnZXIpXG4gICAgICAgICAgICByZXR1cm4gbnVtLnRvU3RyaW5nKDEwKTtcbiAgICAgICAgcmV0dXJuIEpTQkkuQmlnSW50KG51bSkudG9TdHJpbmcoMTApO1xuICAgIH1cbiAgICBjb25zdCB5ZWFycyA9IEdldFNsb3QoZHVyYXRpb24sIFlFQVJTKTtcbiAgICBjb25zdCBtb250aHMgPSBHZXRTbG90KGR1cmF0aW9uLCBNT05USFMpO1xuICAgIGNvbnN0IHdlZWtzID0gR2V0U2xvdChkdXJhdGlvbiwgV0VFS1MpO1xuICAgIGNvbnN0IGRheXMgPSBHZXRTbG90KGR1cmF0aW9uLCBEQVlTKTtcbiAgICBjb25zdCBob3VycyA9IEdldFNsb3QoZHVyYXRpb24sIEhPVVJTKTtcbiAgICBjb25zdCBtaW51dGVzID0gR2V0U2xvdChkdXJhdGlvbiwgTUlOVVRFUyk7XG4gICAgbGV0IHNlY29uZHMgPSBHZXRTbG90KGR1cmF0aW9uLCBTRUNPTkRTKTtcbiAgICBsZXQgbXMgPSBHZXRTbG90KGR1cmF0aW9uLCBNSUxMSVNFQ09ORFMpO1xuICAgIGxldCDCtXMgPSBHZXRTbG90KGR1cmF0aW9uLCBNSUNST1NFQ09ORFMpO1xuICAgIGxldCBucyA9IEdldFNsb3QoZHVyYXRpb24sIE5BTk9TRUNPTkRTKTtcbiAgICBjb25zdCBzaWduID0gRHVyYXRpb25TaWduKHllYXJzLCBtb250aHMsIHdlZWtzLCBkYXlzLCBob3VycywgbWludXRlcywgc2Vjb25kcywgbXMsIMK1cywgbnMpO1xuICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHsgdW5pdCwgaW5jcmVtZW50LCByb3VuZGluZ01vZGUgfSA9IG9wdGlvbnM7XG4gICAgICAgICh7XG4gICAgICAgICAgICBzZWNvbmRzLFxuICAgICAgICAgICAgbWlsbGlzZWNvbmRzOiBtcyxcbiAgICAgICAgICAgIG1pY3Jvc2Vjb25kczogwrVzLFxuICAgICAgICAgICAgbmFub3NlY29uZHM6IG5zXG4gICAgICAgIH0gPSBSb3VuZER1cmF0aW9uKDAsIDAsIDAsIDAsIDAsIDAsIHNlY29uZHMsIG1zLCDCtXMsIG5zLCBpbmNyZW1lbnQsIHVuaXQsIHJvdW5kaW5nTW9kZSkpO1xuICAgIH1cbiAgICBjb25zdCBkYXRlUGFydHMgPSBbXTtcbiAgICBpZiAoeWVhcnMpXG4gICAgICAgIGRhdGVQYXJ0cy5wdXNoKGAke2Zvcm1hdE51bWJlcihNYXRoQWJzKHllYXJzKSl9WWApO1xuICAgIGlmIChtb250aHMpXG4gICAgICAgIGRhdGVQYXJ0cy5wdXNoKGAke2Zvcm1hdE51bWJlcihNYXRoQWJzKG1vbnRocykpfU1gKTtcbiAgICBpZiAod2Vla3MpXG4gICAgICAgIGRhdGVQYXJ0cy5wdXNoKGAke2Zvcm1hdE51bWJlcihNYXRoQWJzKHdlZWtzKSl9V2ApO1xuICAgIGlmIChkYXlzKVxuICAgICAgICBkYXRlUGFydHMucHVzaChgJHtmb3JtYXROdW1iZXIoTWF0aEFicyhkYXlzKSl9RGApO1xuICAgIGNvbnN0IHRpbWVQYXJ0cyA9IFtdO1xuICAgIGlmIChob3VycylcbiAgICAgICAgdGltZVBhcnRzLnB1c2goYCR7Zm9ybWF0TnVtYmVyKE1hdGhBYnMoaG91cnMpKX1IYCk7XG4gICAgaWYgKG1pbnV0ZXMpXG4gICAgICAgIHRpbWVQYXJ0cy5wdXNoKGAke2Zvcm1hdE51bWJlcihNYXRoQWJzKG1pbnV0ZXMpKX1NYCk7XG4gICAgY29uc3Qgc2Vjb25kUGFydHMgPSBbXTtcbiAgICBsZXQgdG90YWwgPSBUb3RhbER1cmF0aW9uTmFub3NlY29uZHMoMCwgMCwgMCwgc2Vjb25kcywgbXMsIMK1cywgbnMsIDApO1xuICAgIGxldCBuc0JpZ0ludCwgwrVzQmlnSW50LCBtc0JpZ0ludCwgc2Vjb25kc0JpZ0ludDtcbiAgICAoeyBxdW90aWVudDogdG90YWwsIHJlbWFpbmRlcjogbnNCaWdJbnQgfSA9IGRpdm1vZCh0b3RhbCwgVEhPVVNBTkQpKTtcbiAgICAoeyBxdW90aWVudDogdG90YWwsIHJlbWFpbmRlcjogwrVzQmlnSW50IH0gPSBkaXZtb2QodG90YWwsIFRIT1VTQU5EKSk7XG4gICAgKHsgcXVvdGllbnQ6IHNlY29uZHNCaWdJbnQsIHJlbWFpbmRlcjogbXNCaWdJbnQgfSA9IGRpdm1vZCh0b3RhbCwgVEhPVVNBTkQpKTtcbiAgICBjb25zdCBmcmFjdGlvbiA9IE1hdGhBYnMoSlNCSS50b051bWJlcihtc0JpZ0ludCkpICogMWU2ICsgTWF0aEFicyhKU0JJLnRvTnVtYmVyKMK1c0JpZ0ludCkpICogMWUzICsgTWF0aEFicyhKU0JJLnRvTnVtYmVyKG5zQmlnSW50KSk7XG4gICAgbGV0IGRlY2ltYWxQYXJ0O1xuICAgIGlmIChwcmVjaXNpb24gPT09ICdhdXRvJykge1xuICAgICAgICBpZiAoZnJhY3Rpb24gIT09IDApIHtcbiAgICAgICAgICAgIGRlY2ltYWxQYXJ0ID0gYCR7ZnJhY3Rpb259YC5wYWRTdGFydCg5LCAnMCcpO1xuICAgICAgICAgICAgd2hpbGUgKGRlY2ltYWxQYXJ0W2RlY2ltYWxQYXJ0Lmxlbmd0aCAtIDFdID09PSAnMCcpIHtcbiAgICAgICAgICAgICAgICBkZWNpbWFsUGFydCA9IGRlY2ltYWxQYXJ0LnNsaWNlKDAsIC0xKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChwcmVjaXNpb24gIT09IDApIHtcbiAgICAgICAgZGVjaW1hbFBhcnQgPSBgJHtmcmFjdGlvbn1gLnBhZFN0YXJ0KDksICcwJykuc2xpY2UoMCwgcHJlY2lzaW9uKTtcbiAgICB9XG4gICAgaWYgKGRlY2ltYWxQYXJ0KVxuICAgICAgICBzZWNvbmRQYXJ0cy51bnNoaWZ0KCcuJywgZGVjaW1hbFBhcnQpO1xuICAgIGlmICghSlNCSS5lcXVhbChzZWNvbmRzQmlnSW50LCBaRVJPKSB8fCBzZWNvbmRQYXJ0cy5sZW5ndGggfHwgcHJlY2lzaW9uICE9PSAnYXV0bycpIHtcbiAgICAgICAgc2Vjb25kUGFydHMudW5zaGlmdChhYnMoc2Vjb25kc0JpZ0ludCkudG9TdHJpbmcoKSk7XG4gICAgfVxuICAgIGlmIChzZWNvbmRQYXJ0cy5sZW5ndGgpXG4gICAgICAgIHRpbWVQYXJ0cy5wdXNoKGAke3NlY29uZFBhcnRzLmpvaW4oJycpfVNgKTtcbiAgICBpZiAodGltZVBhcnRzLmxlbmd0aClcbiAgICAgICAgdGltZVBhcnRzLnVuc2hpZnQoJ1QnKTtcbiAgICBpZiAoIWRhdGVQYXJ0cy5sZW5ndGggJiYgIXRpbWVQYXJ0cy5sZW5ndGgpXG4gICAgICAgIHJldHVybiAnUFQwUyc7XG4gICAgcmV0dXJuIGAke3NpZ24gPCAwID8gJy0nIDogJyd9UCR7ZGF0ZVBhcnRzLmpvaW4oJycpfSR7dGltZVBhcnRzLmpvaW4oJycpfWA7XG59XG5mdW5jdGlvbiBUZW1wb3JhbERhdGVUb1N0cmluZyhkYXRlLCBzaG93Q2FsZW5kYXIgPSAnYXV0bycpIHtcbiAgICBjb25zdCB5ZWFyID0gSVNPWWVhclN0cmluZyhHZXRTbG90KGRhdGUsIElTT19ZRUFSKSk7XG4gICAgY29uc3QgbW9udGggPSBJU09EYXRlVGltZVBhcnRTdHJpbmcoR2V0U2xvdChkYXRlLCBJU09fTU9OVEgpKTtcbiAgICBjb25zdCBkYXkgPSBJU09EYXRlVGltZVBhcnRTdHJpbmcoR2V0U2xvdChkYXRlLCBJU09fREFZKSk7XG4gICAgY29uc3QgY2FsZW5kYXJJRCA9IFRvU3RyaW5nKEdldFNsb3QoZGF0ZSwgQ0FMRU5EQVIpKTtcbiAgICBjb25zdCBjYWxlbmRhciA9IEZvcm1hdENhbGVuZGFyQW5ub3RhdGlvbihjYWxlbmRhcklELCBzaG93Q2FsZW5kYXIpO1xuICAgIHJldHVybiBgJHt5ZWFyfS0ke21vbnRofS0ke2RheX0ke2NhbGVuZGFyfWA7XG59XG5mdW5jdGlvbiBUZW1wb3JhbERhdGVUaW1lVG9TdHJpbmcoZGF0ZVRpbWUsIHByZWNpc2lvbiwgc2hvd0NhbGVuZGFyID0gJ2F1dG8nLCBvcHRpb25zID0gdW5kZWZpbmVkKSB7XG4gICAgbGV0IHllYXIgPSBHZXRTbG90KGRhdGVUaW1lLCBJU09fWUVBUik7XG4gICAgbGV0IG1vbnRoID0gR2V0U2xvdChkYXRlVGltZSwgSVNPX01PTlRIKTtcbiAgICBsZXQgZGF5ID0gR2V0U2xvdChkYXRlVGltZSwgSVNPX0RBWSk7XG4gICAgbGV0IGhvdXIgPSBHZXRTbG90KGRhdGVUaW1lLCBJU09fSE9VUik7XG4gICAgbGV0IG1pbnV0ZSA9IEdldFNsb3QoZGF0ZVRpbWUsIElTT19NSU5VVEUpO1xuICAgIGxldCBzZWNvbmQgPSBHZXRTbG90KGRhdGVUaW1lLCBJU09fU0VDT05EKTtcbiAgICBsZXQgbWlsbGlzZWNvbmQgPSBHZXRTbG90KGRhdGVUaW1lLCBJU09fTUlMTElTRUNPTkQpO1xuICAgIGxldCBtaWNyb3NlY29uZCA9IEdldFNsb3QoZGF0ZVRpbWUsIElTT19NSUNST1NFQ09ORCk7XG4gICAgbGV0IG5hbm9zZWNvbmQgPSBHZXRTbG90KGRhdGVUaW1lLCBJU09fTkFOT1NFQ09ORCk7XG4gICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgeyB1bml0LCBpbmNyZW1lbnQsIHJvdW5kaW5nTW9kZSB9ID0gb3B0aW9ucztcbiAgICAgICAgKHsgeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kLCBtaWNyb3NlY29uZCwgbmFub3NlY29uZCB9ID0gUm91bmRJU09EYXRlVGltZSh5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQsIG1pY3Jvc2Vjb25kLCBuYW5vc2Vjb25kLCBpbmNyZW1lbnQsIHVuaXQsIHJvdW5kaW5nTW9kZSkpO1xuICAgIH1cbiAgICBjb25zdCB5ZWFyU3RyaW5nID0gSVNPWWVhclN0cmluZyh5ZWFyKTtcbiAgICBjb25zdCBtb250aFN0cmluZyA9IElTT0RhdGVUaW1lUGFydFN0cmluZyhtb250aCk7XG4gICAgY29uc3QgZGF5U3RyaW5nID0gSVNPRGF0ZVRpbWVQYXJ0U3RyaW5nKGRheSk7XG4gICAgY29uc3QgaG91clN0cmluZyA9IElTT0RhdGVUaW1lUGFydFN0cmluZyhob3VyKTtcbiAgICBjb25zdCBtaW51dGVTdHJpbmcgPSBJU09EYXRlVGltZVBhcnRTdHJpbmcobWludXRlKTtcbiAgICBjb25zdCBzZWNvbmRzU3RyaW5nID0gRm9ybWF0U2Vjb25kc1N0cmluZ1BhcnQoc2Vjb25kLCBtaWxsaXNlY29uZCwgbWljcm9zZWNvbmQsIG5hbm9zZWNvbmQsIHByZWNpc2lvbik7XG4gICAgY29uc3QgY2FsZW5kYXJJRCA9IFRvU3RyaW5nKEdldFNsb3QoZGF0ZVRpbWUsIENBTEVOREFSKSk7XG4gICAgY29uc3QgY2FsZW5kYXIgPSBGb3JtYXRDYWxlbmRhckFubm90YXRpb24oY2FsZW5kYXJJRCwgc2hvd0NhbGVuZGFyKTtcbiAgICByZXR1cm4gYCR7eWVhclN0cmluZ30tJHttb250aFN0cmluZ30tJHtkYXlTdHJpbmd9VCR7aG91clN0cmluZ306JHttaW51dGVTdHJpbmd9JHtzZWNvbmRzU3RyaW5nfSR7Y2FsZW5kYXJ9YDtcbn1cbmZ1bmN0aW9uIFRlbXBvcmFsTW9udGhEYXlUb1N0cmluZyhtb250aERheSwgc2hvd0NhbGVuZGFyID0gJ2F1dG8nKSB7XG4gICAgY29uc3QgbW9udGggPSBJU09EYXRlVGltZVBhcnRTdHJpbmcoR2V0U2xvdChtb250aERheSwgSVNPX01PTlRIKSk7XG4gICAgY29uc3QgZGF5ID0gSVNPRGF0ZVRpbWVQYXJ0U3RyaW5nKEdldFNsb3QobW9udGhEYXksIElTT19EQVkpKTtcbiAgICBsZXQgcmVzdWx0U3RyaW5nID0gYCR7bW9udGh9LSR7ZGF5fWA7XG4gICAgY29uc3QgY2FsZW5kYXIgPSBHZXRTbG90KG1vbnRoRGF5LCBDQUxFTkRBUik7XG4gICAgY29uc3QgY2FsZW5kYXJJRCA9IFRvU3RyaW5nKGNhbGVuZGFyKTtcbiAgICBpZiAoY2FsZW5kYXJJRCAhPT0gJ2lzbzg2MDEnKSB7XG4gICAgICAgIGNvbnN0IHllYXIgPSBJU09ZZWFyU3RyaW5nKEdldFNsb3QobW9udGhEYXksIElTT19ZRUFSKSk7XG4gICAgICAgIHJlc3VsdFN0cmluZyA9IGAke3llYXJ9LSR7cmVzdWx0U3RyaW5nfWA7XG4gICAgfVxuICAgIGNvbnN0IGNhbGVuZGFyU3RyaW5nID0gRm9ybWF0Q2FsZW5kYXJBbm5vdGF0aW9uKGNhbGVuZGFySUQsIHNob3dDYWxlbmRhcik7XG4gICAgaWYgKGNhbGVuZGFyU3RyaW5nKVxuICAgICAgICByZXN1bHRTdHJpbmcgKz0gY2FsZW5kYXJTdHJpbmc7XG4gICAgcmV0dXJuIHJlc3VsdFN0cmluZztcbn1cbmZ1bmN0aW9uIFRlbXBvcmFsWWVhck1vbnRoVG9TdHJpbmcoeWVhck1vbnRoLCBzaG93Q2FsZW5kYXIgPSAnYXV0bycpIHtcbiAgICBjb25zdCB5ZWFyID0gSVNPWWVhclN0cmluZyhHZXRTbG90KHllYXJNb250aCwgSVNPX1lFQVIpKTtcbiAgICBjb25zdCBtb250aCA9IElTT0RhdGVUaW1lUGFydFN0cmluZyhHZXRTbG90KHllYXJNb250aCwgSVNPX01PTlRIKSk7XG4gICAgbGV0IHJlc3VsdFN0cmluZyA9IGAke3llYXJ9LSR7bW9udGh9YDtcbiAgICBjb25zdCBjYWxlbmRhciA9IEdldFNsb3QoeWVhck1vbnRoLCBDQUxFTkRBUik7XG4gICAgY29uc3QgY2FsZW5kYXJJRCA9IFRvU3RyaW5nKGNhbGVuZGFyKTtcbiAgICBpZiAoY2FsZW5kYXJJRCAhPT0gJ2lzbzg2MDEnKSB7XG4gICAgICAgIGNvbnN0IGRheSA9IElTT0RhdGVUaW1lUGFydFN0cmluZyhHZXRTbG90KHllYXJNb250aCwgSVNPX0RBWSkpO1xuICAgICAgICByZXN1bHRTdHJpbmcgKz0gYC0ke2RheX1gO1xuICAgIH1cbiAgICBjb25zdCBjYWxlbmRhclN0cmluZyA9IEZvcm1hdENhbGVuZGFyQW5ub3RhdGlvbihjYWxlbmRhcklELCBzaG93Q2FsZW5kYXIpO1xuICAgIGlmIChjYWxlbmRhclN0cmluZylcbiAgICAgICAgcmVzdWx0U3RyaW5nICs9IGNhbGVuZGFyU3RyaW5nO1xuICAgIHJldHVybiByZXN1bHRTdHJpbmc7XG59XG5mdW5jdGlvbiBUZW1wb3JhbFpvbmVkRGF0ZVRpbWVUb1N0cmluZyh6ZHQsIHByZWNpc2lvbiwgc2hvd0NhbGVuZGFyID0gJ2F1dG8nLCBzaG93VGltZVpvbmUgPSAnYXV0bycsIHNob3dPZmZzZXQgPSAnYXV0bycsIG9wdGlvbnMgPSB1bmRlZmluZWQpIHtcbiAgICBsZXQgaW5zdGFudCA9IEdldFNsb3QoemR0LCBJTlNUQU5UKTtcbiAgICBpZiAob3B0aW9ucykge1xuICAgICAgICBjb25zdCB7IHVuaXQsIGluY3JlbWVudCwgcm91bmRpbmdNb2RlIH0gPSBvcHRpb25zO1xuICAgICAgICBjb25zdCBucyA9IFJvdW5kSW5zdGFudChHZXRTbG90KHpkdCwgRVBPQ0hOQU5PU0VDT05EUyksIGluY3JlbWVudCwgdW5pdCwgcm91bmRpbmdNb2RlKTtcbiAgICAgICAgY29uc3QgVGVtcG9yYWxJbnN0YW50ID0gR2V0SW50cmluc2ljKCclVGVtcG9yYWwuSW5zdGFudCUnKTtcbiAgICAgICAgaW5zdGFudCA9IG5ldyBUZW1wb3JhbEluc3RhbnQobnMpO1xuICAgIH1cbiAgICBjb25zdCB0eiA9IEdldFNsb3QoemR0LCBUSU1FX1pPTkUpO1xuICAgIGNvbnN0IGlzbyA9IEdldElTTzg2MDFDYWxlbmRhcigpO1xuICAgIGNvbnN0IGRhdGVUaW1lID0gQnVpbHRpblRpbWVab25lR2V0UGxhaW5EYXRlVGltZUZvcih0eiwgaW5zdGFudCwgaXNvKTtcbiAgICBjb25zdCB5ZWFyID0gSVNPWWVhclN0cmluZyhHZXRTbG90KGRhdGVUaW1lLCBJU09fWUVBUikpO1xuICAgIGNvbnN0IG1vbnRoID0gSVNPRGF0ZVRpbWVQYXJ0U3RyaW5nKEdldFNsb3QoZGF0ZVRpbWUsIElTT19NT05USCkpO1xuICAgIGNvbnN0IGRheSA9IElTT0RhdGVUaW1lUGFydFN0cmluZyhHZXRTbG90KGRhdGVUaW1lLCBJU09fREFZKSk7XG4gICAgY29uc3QgaG91ciA9IElTT0RhdGVUaW1lUGFydFN0cmluZyhHZXRTbG90KGRhdGVUaW1lLCBJU09fSE9VUikpO1xuICAgIGNvbnN0IG1pbnV0ZSA9IElTT0RhdGVUaW1lUGFydFN0cmluZyhHZXRTbG90KGRhdGVUaW1lLCBJU09fTUlOVVRFKSk7XG4gICAgY29uc3Qgc2Vjb25kcyA9IEZvcm1hdFNlY29uZHNTdHJpbmdQYXJ0KEdldFNsb3QoZGF0ZVRpbWUsIElTT19TRUNPTkQpLCBHZXRTbG90KGRhdGVUaW1lLCBJU09fTUlMTElTRUNPTkQpLCBHZXRTbG90KGRhdGVUaW1lLCBJU09fTUlDUk9TRUNPTkQpLCBHZXRTbG90KGRhdGVUaW1lLCBJU09fTkFOT1NFQ09ORCksIHByZWNpc2lvbik7XG4gICAgbGV0IHJlc3VsdCA9IGAke3llYXJ9LSR7bW9udGh9LSR7ZGF5fVQke2hvdXJ9OiR7bWludXRlfSR7c2Vjb25kc31gO1xuICAgIGlmIChzaG93T2Zmc2V0ICE9PSAnbmV2ZXInKSB7XG4gICAgICAgIGNvbnN0IG9mZnNldE5zID0gR2V0T2Zmc2V0TmFub3NlY29uZHNGb3IodHosIGluc3RhbnQpO1xuICAgICAgICByZXN1bHQgKz0gRm9ybWF0SVNPVGltZVpvbmVPZmZzZXRTdHJpbmcob2Zmc2V0TnMpO1xuICAgIH1cbiAgICBpZiAoc2hvd1RpbWVab25lICE9PSAnbmV2ZXInKVxuICAgICAgICByZXN1bHQgKz0gYFske3R6fV1gO1xuICAgIGNvbnN0IGNhbGVuZGFySUQgPSBUb1N0cmluZyhHZXRTbG90KHpkdCwgQ0FMRU5EQVIpKTtcbiAgICByZXN1bHQgKz0gRm9ybWF0Q2FsZW5kYXJBbm5vdGF0aW9uKGNhbGVuZGFySUQsIHNob3dDYWxlbmRhcik7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIFRlc3RUaW1lWm9uZU9mZnNldFN0cmluZyhzdHJpbmcpIHtcbiAgICByZXR1cm4gT0ZGU0VULnRlc3QoU3RyaW5nQ3RvcihzdHJpbmcpKTtcbn1cbmZ1bmN0aW9uIFBhcnNlVGltZVpvbmVPZmZzZXRTdHJpbmcoc3RyaW5nKSB7XG4gICAgY29uc3QgbWF0Y2ggPSBPRkZTRVQuZXhlYyhTdHJpbmdDdG9yKHN0cmluZykpO1xuICAgIGlmICghbWF0Y2gpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYGludmFsaWQgdGltZSB6b25lIG9mZnNldDogJHtzdHJpbmd9YCk7XG4gICAgfVxuICAgIGNvbnN0IHNpZ24gPSBtYXRjaFsxXSA9PT0gJy0nIHx8IG1hdGNoWzFdID09PSAnXFx1MjIxMicgPyAtMSA6ICsxO1xuICAgIGNvbnN0IGhvdXJzID0gK21hdGNoWzJdO1xuICAgIGNvbnN0IG1pbnV0ZXMgPSArKG1hdGNoWzNdIHx8IDApO1xuICAgIGNvbnN0IHNlY29uZHMgPSArKG1hdGNoWzRdIHx8IDApO1xuICAgIGNvbnN0IG5hbm9zZWNvbmRzID0gKygobWF0Y2hbNV0gfHwgMCkgKyAnMDAwMDAwMDAwJykuc2xpY2UoMCwgOSk7XG4gICAgcmV0dXJuIHNpZ24gKiAoKChob3VycyAqIDYwICsgbWludXRlcykgKiA2MCArIHNlY29uZHMpICogMWU5ICsgbmFub3NlY29uZHMpO1xufVxuZnVuY3Rpb24gR2V0Q2Fub25pY2FsVGltZVpvbmVJZGVudGlmaWVyKHRpbWVab25lSWRlbnRpZmllcikge1xuICAgIGlmIChUZXN0VGltZVpvbmVPZmZzZXRTdHJpbmcodGltZVpvbmVJZGVudGlmaWVyKSkge1xuICAgICAgICBjb25zdCBvZmZzZXROcyA9IFBhcnNlVGltZVpvbmVPZmZzZXRTdHJpbmcodGltZVpvbmVJZGVudGlmaWVyKTtcbiAgICAgICAgcmV0dXJuIEZvcm1hdFRpbWVab25lT2Zmc2V0U3RyaW5nKG9mZnNldE5zKTtcbiAgICB9XG4gICAgY29uc3QgZm9ybWF0dGVyID0gZ2V0SW50bERhdGVUaW1lRm9ybWF0RW5Vc0ZvclRpbWVab25lKFN0cmluZ0N0b3IodGltZVpvbmVJZGVudGlmaWVyKSk7XG4gICAgcmV0dXJuIGZvcm1hdHRlci5yZXNvbHZlZE9wdGlvbnMoKS50aW1lWm9uZTtcbn1cbmZ1bmN0aW9uIEdldElBTkFUaW1lWm9uZU9mZnNldE5hbm9zZWNvbmRzKGVwb2NoTmFub3NlY29uZHMsIGlkKSB7XG4gICAgY29uc3QgeyB5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQsIG1pY3Jvc2Vjb25kLCBuYW5vc2Vjb25kIH0gPSBHZXRJQU5BVGltZVpvbmVEYXRlVGltZVBhcnRzKGVwb2NoTmFub3NlY29uZHMsIGlkKTtcbiAgICBjb25zdCB1dGMgPSBHZXRFcG9jaEZyb21JU09QYXJ0cyh5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQsIG1pY3Jvc2Vjb25kLCBuYW5vc2Vjb25kKTtcbiAgICBpZiAodXRjID09PSBudWxsKVxuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignRGF0ZSBvdXRzaWRlIG9mIHN1cHBvcnRlZCByYW5nZScpO1xuICAgIHJldHVybiBKU0JJLnRvTnVtYmVyKEpTQkkuc3VidHJhY3QodXRjLCBlcG9jaE5hbm9zZWNvbmRzKSk7XG59XG5mdW5jdGlvbiBGb3JtYXRUaW1lWm9uZU9mZnNldFN0cmluZyhvZmZzZXROYW5vc2Vjb25kc1BhcmFtKSB7XG4gICAgY29uc3Qgc2lnbiA9IG9mZnNldE5hbm9zZWNvbmRzUGFyYW0gPCAwID8gJy0nIDogJysnO1xuICAgIGNvbnN0IG9mZnNldE5hbm9zZWNvbmRzID0gTWF0aEFicyhvZmZzZXROYW5vc2Vjb25kc1BhcmFtKTtcbiAgICBjb25zdCBuYW5vc2Vjb25kcyA9IG9mZnNldE5hbm9zZWNvbmRzICUgMWU5O1xuICAgIGNvbnN0IHNlY29uZHMgPSBNYXRoRmxvb3Iob2Zmc2V0TmFub3NlY29uZHMgLyAxZTkpICUgNjA7XG4gICAgY29uc3QgbWludXRlcyA9IE1hdGhGbG9vcihvZmZzZXROYW5vc2Vjb25kcyAvIDYwZTkpICUgNjA7XG4gICAgY29uc3QgaG91cnMgPSBNYXRoRmxvb3Iob2Zmc2V0TmFub3NlY29uZHMgLyAzNjAwZTkpO1xuICAgIGNvbnN0IGhvdXJTdHJpbmcgPSBJU09EYXRlVGltZVBhcnRTdHJpbmcoaG91cnMpO1xuICAgIGNvbnN0IG1pbnV0ZVN0cmluZyA9IElTT0RhdGVUaW1lUGFydFN0cmluZyhtaW51dGVzKTtcbiAgICBjb25zdCBzZWNvbmRTdHJpbmcgPSBJU09EYXRlVGltZVBhcnRTdHJpbmcoc2Vjb25kcyk7XG4gICAgbGV0IHBvc3QgPSAnJztcbiAgICBpZiAobmFub3NlY29uZHMpIHtcbiAgICAgICAgbGV0IGZyYWN0aW9uID0gYCR7bmFub3NlY29uZHN9YC5wYWRTdGFydCg5LCAnMCcpO1xuICAgICAgICB3aGlsZSAoZnJhY3Rpb25bZnJhY3Rpb24ubGVuZ3RoIC0gMV0gPT09ICcwJylcbiAgICAgICAgICAgIGZyYWN0aW9uID0gZnJhY3Rpb24uc2xpY2UoMCwgLTEpO1xuICAgICAgICBwb3N0ID0gYDoke3NlY29uZFN0cmluZ30uJHtmcmFjdGlvbn1gO1xuICAgIH1cbiAgICBlbHNlIGlmIChzZWNvbmRzKSB7XG4gICAgICAgIHBvc3QgPSBgOiR7c2Vjb25kU3RyaW5nfWA7XG4gICAgfVxuICAgIHJldHVybiBgJHtzaWdufSR7aG91clN0cmluZ306JHttaW51dGVTdHJpbmd9JHtwb3N0fWA7XG59XG5mdW5jdGlvbiBGb3JtYXRJU09UaW1lWm9uZU9mZnNldFN0cmluZyhvZmZzZXROYW5vc2Vjb25kc1BhcmFtKSB7XG4gICAgbGV0IG9mZnNldE5hbm9zZWNvbmRzID0gSlNCSS50b051bWJlcihSb3VuZE51bWJlclRvSW5jcmVtZW50KEpTQkkuQmlnSW50KG9mZnNldE5hbm9zZWNvbmRzUGFyYW0pLCA2MGU5LCAnaGFsZkV4cGFuZCcpKTtcbiAgICBjb25zdCBzaWduID0gb2Zmc2V0TmFub3NlY29uZHMgPCAwID8gJy0nIDogJysnO1xuICAgIG9mZnNldE5hbm9zZWNvbmRzID0gTWF0aEFicyhvZmZzZXROYW5vc2Vjb25kcyk7XG4gICAgY29uc3QgbWludXRlcyA9IChvZmZzZXROYW5vc2Vjb25kcyAvIDYwZTkpICUgNjA7XG4gICAgY29uc3QgaG91cnMgPSBNYXRoRmxvb3Iob2Zmc2V0TmFub3NlY29uZHMgLyAzNjAwZTkpO1xuICAgIGNvbnN0IGhvdXJTdHJpbmcgPSBJU09EYXRlVGltZVBhcnRTdHJpbmcoaG91cnMpO1xuICAgIGNvbnN0IG1pbnV0ZVN0cmluZyA9IElTT0RhdGVUaW1lUGFydFN0cmluZyhtaW51dGVzKTtcbiAgICByZXR1cm4gYCR7c2lnbn0ke2hvdXJTdHJpbmd9OiR7bWludXRlU3RyaW5nfWA7XG59XG5mdW5jdGlvbiBHZXRFcG9jaEZyb21JU09QYXJ0cyh5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQsIG1pY3Jvc2Vjb25kLCBuYW5vc2Vjb25kKSB7XG4gICAgLy8gTm90ZTogRGF0ZS5VVEMoKSBpbnRlcnByZXRzIG9uZSBhbmQgdHdvLWRpZ2l0IHllYXJzIGFzIGJlaW5nIGluIHRoZVxuICAgIC8vIDIwdGggY2VudHVyeSwgc28gZG9uJ3QgdXNlIGl0XG4gICAgY29uc3QgbGVnYWN5RGF0ZSA9IG5ldyBEYXRlKCk7XG4gICAgbGVnYWN5RGF0ZS5zZXRVVENIb3Vycyhob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQpO1xuICAgIGxlZ2FjeURhdGUuc2V0VVRDRnVsbFllYXIoeWVhciwgbW9udGggLSAxLCBkYXkpO1xuICAgIGNvbnN0IG1zID0gbGVnYWN5RGF0ZS5nZXRUaW1lKCk7XG4gICAgaWYgKE51bWJlcklzTmFOKG1zKSlcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0IG5zID0gSlNCSS5tdWx0aXBseShKU0JJLkJpZ0ludChtcyksIE1JTExJT04pO1xuICAgIG5zID0gSlNCSS5hZGQobnMsIEpTQkkubXVsdGlwbHkoSlNCSS5CaWdJbnQobWljcm9zZWNvbmQpLCBUSE9VU0FORCkpO1xuICAgIG5zID0gSlNCSS5hZGQobnMsIEpTQkkuQmlnSW50KG5hbm9zZWNvbmQpKTtcbiAgICBpZiAoSlNCSS5sZXNzVGhhbihucywgTlNfTUlOKSB8fCBKU0JJLmdyZWF0ZXJUaGFuKG5zLCBOU19NQVgpKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gbnM7XG59XG5mdW5jdGlvbiBHZXRJU09QYXJ0c0Zyb21FcG9jaChlcG9jaE5hbm9zZWNvbmRzKSB7XG4gICAgY29uc3QgeyBxdW90aWVudCwgcmVtYWluZGVyIH0gPSBkaXZtb2QoZXBvY2hOYW5vc2Vjb25kcywgTUlMTElPTik7XG4gICAgbGV0IGVwb2NoTWlsbGlzZWNvbmRzID0gSlNCSS50b051bWJlcihxdW90aWVudCk7XG4gICAgbGV0IG5hbm9zID0gSlNCSS50b051bWJlcihyZW1haW5kZXIpO1xuICAgIGlmIChuYW5vcyA8IDApIHtcbiAgICAgICAgbmFub3MgKz0gMWU2O1xuICAgICAgICBlcG9jaE1pbGxpc2Vjb25kcyAtPSAxO1xuICAgIH1cbiAgICBjb25zdCBtaWNyb3NlY29uZCA9IE1hdGhGbG9vcihuYW5vcyAvIDFlMykgJSAxZTM7XG4gICAgY29uc3QgbmFub3NlY29uZCA9IG5hbm9zICUgMWUzO1xuICAgIGNvbnN0IGl0ZW0gPSBuZXcgRGF0ZShlcG9jaE1pbGxpc2Vjb25kcyk7XG4gICAgY29uc3QgeWVhciA9IGl0ZW0uZ2V0VVRDRnVsbFllYXIoKTtcbiAgICBjb25zdCBtb250aCA9IGl0ZW0uZ2V0VVRDTW9udGgoKSArIDE7XG4gICAgY29uc3QgZGF5ID0gaXRlbS5nZXRVVENEYXRlKCk7XG4gICAgY29uc3QgaG91ciA9IGl0ZW0uZ2V0VVRDSG91cnMoKTtcbiAgICBjb25zdCBtaW51dGUgPSBpdGVtLmdldFVUQ01pbnV0ZXMoKTtcbiAgICBjb25zdCBzZWNvbmQgPSBpdGVtLmdldFVUQ1NlY29uZHMoKTtcbiAgICBjb25zdCBtaWxsaXNlY29uZCA9IGl0ZW0uZ2V0VVRDTWlsbGlzZWNvbmRzKCk7XG4gICAgcmV0dXJuIHsgZXBvY2hNaWxsaXNlY29uZHMsIHllYXIsIG1vbnRoLCBkYXksIGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZCwgbWljcm9zZWNvbmQsIG5hbm9zZWNvbmQgfTtcbn1cbi8vIHRzLXBydW5lLWlnbm9yZS1uZXh0IFRPRE86IHJlbW92ZSB0aGlzIGFmdGVyIHRlc3RzIGFyZSBjb252ZXJ0ZWQgdG8gVFNcbmZ1bmN0aW9uIEdldElBTkFUaW1lWm9uZURhdGVUaW1lUGFydHMoZXBvY2hOYW5vc2Vjb25kcywgaWQpIHtcbiAgICBjb25zdCB7IGVwb2NoTWlsbGlzZWNvbmRzLCBtaWxsaXNlY29uZCwgbWljcm9zZWNvbmQsIG5hbm9zZWNvbmQgfSA9IEdldElTT1BhcnRzRnJvbUVwb2NoKGVwb2NoTmFub3NlY29uZHMpO1xuICAgIGNvbnN0IHsgeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQgfSA9IEdldEZvcm1hdHRlclBhcnRzKGlkLCBlcG9jaE1pbGxpc2Vjb25kcyk7XG4gICAgcmV0dXJuIEJhbGFuY2VJU09EYXRlVGltZSh5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQsIG1pY3Jvc2Vjb25kLCBuYW5vc2Vjb25kKTtcbn1cbmZ1bmN0aW9uIG1heEpTQkkob25lLCB0d28pIHtcbiAgICByZXR1cm4gSlNCSS5sZXNzVGhhbihvbmUsIHR3bykgPyB0d28gOiBvbmU7XG59XG4vKipcbiAqIE91ciBiZXN0IGd1ZXNzIGF0IGhvdyBmYXIgaW4gYWR2YW5jZSBuZXcgcnVsZXMgd2lsbCBiZSBwdXQgaW50byB0aGUgVFpEQiBmb3JcbiAqIGZ1dHVyZSBvZmZzZXQgdHJhbnNpdGlvbnMuIFdlJ2xsIHBpY2sgMTAgeWVhcnMgYnV0IGNhbiBhbHdheXMgcmV2aXNlIGl0IGlmXG4gKiB3ZSBmaW5kIHRoYXQgY291bnRyaWVzIGFyZSBiZWluZyB1bnVzdWFsbHkgcHJvYWN0aXZlIGluIHRoZWlyIGFubm91bmNpbmdcbiAqIG9mIG9mZnNldCBjaGFuZ2VzLlxuICovXG5mdW5jdGlvbiBhZnRlckxhdGVzdFBvc3NpYmxlVHpkYlJ1bGVDaGFuZ2UoKSB7XG4gICAgcmV0dXJuIEpTQkkuYWRkKFN5c3RlbVVUQ0Vwb2NoTmFub1NlY29uZHMoKSwgQUJPVVRfVEVOX1lFQVJTX05BTk9TKTtcbn1cbmZ1bmN0aW9uIEdldElBTkFUaW1lWm9uZU5leHRUcmFuc2l0aW9uKGVwb2NoTmFub3NlY29uZHMsIGlkKSB7XG4gICAgLy8gRGVjaWRlIGhvdyBmYXIgaW4gdGhlIGZ1dHVyZSBhZnRlciBgZXBvY2hOYW5vc2Vjb25kc2Agd2UnbGwgbG9vayBmb3IgYW5cbiAgICAvLyBvZmZzZXQgY2hhbmdlLiBUaGVyZSBhcmUgdHdvIGNhc2VzOlxuICAgIC8vIDEuIElmIGl0J3MgYSBwYXN0IGRhdGUgKG9yIGEgZGF0ZSBpbiB0aGUgbmVhciBmdXR1cmUpIHRoZW4gaXQncyBwb3NzaWJsZVxuICAgIC8vICAgIHRoYXQgdGhlIHRpbWUgem9uZSBtYXkgaGF2ZSBuZXdseSBhZGRlZCBEU1QgaW4gdGhlIG5leHQgZmV3IHllYXJzLiBTb1xuICAgIC8vICAgIHdlJ2xsIGhhdmUgdG8gbG9vayBmcm9tIHRoZSBwcm92aWRlZCB0aW1lIHVudGlsIGEgZmV3IHllYXJzIGFmdGVyIHRoZVxuICAgIC8vICAgIGN1cnJlbnQgc3lzdGVtIHRpbWUuIChDaGFuZ2VzIHRvIERTVCBwb2xpY3kgYXJlIHVzdWFsbHkgYW5ub3VuY2VkIGEgZmV3XG4gICAgLy8gICAgeWVhcnMgaW4gdGhlIGZ1dHVyZS4pIE5vdGUgdGhhdCB0aGUgZmlyc3QgRFNUIGFueXdoZXJlIHN0YXJ0ZWQgaW4gMTg0NyxcbiAgICAvLyAgICBzbyB3ZSdsbCBzdGFydCBjaGVja3MgaW4gMTg0NyBpbnN0ZWFkIG9mIHdhc3RpbmcgY3ljbGVzIG9uIHllYXJzIHdoZXJlXG4gICAgLy8gICAgdGhlcmUgd2lsbCBuZXZlciBiZSB0cmFuc2l0aW9ucy5cbiAgICAvLyAyLiBJZiBpdCdzIGEgZnV0dXJlIGRhdGUgYmV5b25kIHRoZSBuZXh0IGZldyB5ZWFycywgdGhlbiB3ZSdsbCBqdXN0IGFzc3VtZVxuICAgIC8vICAgIHRoYXQgdGhlIGxhdGVzdCBEU1QgcG9saWN5IGluIFRaREIgd2lsbCBzdGlsbCBiZSBpbiBlZmZlY3QuICBJbiB0aGlzXG4gICAgLy8gICAgY2FzZSwgd2Ugb25seSBuZWVkIHRvIGxvb2sgb25lIHllYXIgaW4gdGhlIGZ1dHVyZSB0byBzZWUgaWYgdGhlcmUgYXJlXG4gICAgLy8gICAgYW55IERTVCB0cmFuc2l0aW9ucy4gIFdlIGFjdHVhbGx5IG9ubHkgbmVlZCB0byBsb29rIDktMTAgbW9udGhzIGJlY2F1c2VcbiAgICAvLyAgICBEU1QgaGFzIHR3byB0cmFuc2l0aW9ucyBwZXIgeWVhciwgYnV0IHdlJ2xsIHVzZSBhIHllYXIganVzdCB0byBiZSBzYWZlLlxuICAgIGNvbnN0IG9uZVllYXJMYXRlciA9IEpTQkkuYWRkKGVwb2NoTmFub3NlY29uZHMsIEFCT1VUX09ORV9ZRUFSX05BTk9TKTtcbiAgICBjb25zdCB1cHBlcmNhcCA9IG1heEpTQkkoYWZ0ZXJMYXRlc3RQb3NzaWJsZVR6ZGJSdWxlQ2hhbmdlKCksIG9uZVllYXJMYXRlcik7XG4gICAgLy8gVGhlIGZpcnN0IHRyYW5zaXRpb24gKGluIGFueSB0aW1lem9uZSkgcmVjb3JkZWQgaW4gdGhlIFRaREIgd2FzIGluIDE4NDcsIHNvXG4gICAgLy8gc3RhcnQgdGhlcmUgaWYgYW4gZWFybGllciBkYXRlIGlzIHN1cHBsaWVkLlxuICAgIGxldCBsZWZ0TmFub3MgPSBtYXhKU0JJKEJFRk9SRV9GSVJTVF9PRkZTRVRfVFJBTlNJVElPTiwgZXBvY2hOYW5vc2Vjb25kcyk7XG4gICAgY29uc3QgbGVmdE9mZnNldE5zID0gR2V0SUFOQVRpbWVab25lT2Zmc2V0TmFub3NlY29uZHMobGVmdE5hbm9zLCBpZCk7XG4gICAgbGV0IHJpZ2h0TmFub3MgPSBsZWZ0TmFub3M7XG4gICAgbGV0IHJpZ2h0T2Zmc2V0TnMgPSBsZWZ0T2Zmc2V0TnM7XG4gICAgd2hpbGUgKGxlZnRPZmZzZXROcyA9PT0gcmlnaHRPZmZzZXROcyAmJiBKU0JJLmxlc3NUaGFuKEpTQkkuQmlnSW50KGxlZnROYW5vcyksIHVwcGVyY2FwKSkge1xuICAgICAgICByaWdodE5hbm9zID0gSlNCSS5hZGQobGVmdE5hbm9zLCBUV09fV0VFS1NfTkFOT1MpO1xuICAgICAgICByaWdodE9mZnNldE5zID0gR2V0SUFOQVRpbWVab25lT2Zmc2V0TmFub3NlY29uZHMocmlnaHROYW5vcywgaWQpO1xuICAgICAgICBpZiAobGVmdE9mZnNldE5zID09PSByaWdodE9mZnNldE5zKSB7XG4gICAgICAgICAgICBsZWZ0TmFub3MgPSByaWdodE5hbm9zO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChsZWZ0T2Zmc2V0TnMgPT09IHJpZ2h0T2Zmc2V0TnMpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGNvbnN0IHJlc3VsdCA9IGJpc2VjdCgoZXBvY2hOcykgPT4gR2V0SUFOQVRpbWVab25lT2Zmc2V0TmFub3NlY29uZHMoZXBvY2hOcywgaWQpLCBsZWZ0TmFub3MsIHJpZ2h0TmFub3MsIGxlZnRPZmZzZXROcywgcmlnaHRPZmZzZXROcyk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIEdldElBTkFUaW1lWm9uZVByZXZpb3VzVHJhbnNpdGlvbihlcG9jaE5hbm9zZWNvbmRzLCBpZCkge1xuICAgIC8vIElmIGEgdGltZSB6b25lIHVzZXMgRFNUIChhdCB0aGUgdGltZSBvZiBgZXBvY2hOYW5vc2Vjb25kc2ApLCB0aGVuIHdlIG9ubHlcbiAgICAvLyBoYXZlIHRvIGxvb2sgYmFjayBvbmUgeWVhciB0byBmaW5kIGEgdHJhbnNpdGlvbi4gQnV0IGlmIGl0IGRvZXNuJ3QgdXNlIERTVCxcbiAgICAvLyB0aGVuIHdlIG5lZWQgdG8gbG9vayBhbGwgdGhlIHdheSBiYWNrIHRvIDE4NDcgKHRoZSBlYXJsaWVzdCBydWxlIGluIHRoZVxuICAgIC8vIFRaREIpIHRvIHNlZSBpZiBpdCBoYWQgb3RoZXIgb2Zmc2V0IHRyYW5zaXRpb25zIGluIHRoZSBwYXN0LiBMb29waW5nIGJhY2tcbiAgICAvLyBmcm9tIGEgZmFyLWZ1dHVyZSBkYXRlIHRvIDE4NDcgaXMgdmVyeSBzbG93IChtaW51dGVzIG9mIDEwMCUgQ1BVISksIGFuZCBpc1xuICAgIC8vIGFsc28gdW5uZWNlc3NhcnkgYmVjYXVzZSBEU1QgcnVsZXMgYXJlbid0IHB1dCBpbnRvIHRoZSBUWkRCIG1vcmUgdGhhbiBhIGZld1xuICAgIC8vIHllYXJzIGluIHRoZSBmdXR1cmUgYmVjYXVzZSB0aGUgcG9saXRpY2FsIGNoYW5nZXMgaW4gdGltZSB6b25lcyBoYXBwZW4gd2l0aFxuICAgIC8vIG9ubHkgYSBmZXcgeWVhcnMnIHdhcm5pbmcuIFRoZXJlZm9yZSwgaWYgYSBmYXItZnV0dXJlIGRhdGUgaXMgcHJvdmlkZWQsXG4gICAgLy8gdGhlbiB3ZSdsbCBydW4gdGhlIGNoZWNrIGluIHR3byBwYXJ0czpcbiAgICAvLyAxLiBGaXJzdCwgd2UnbGwgbG9vayBiYWNrIGZvciB1cCB0byBvbmUgeWVhciB0byBzZWUgaWYgdGhlIGxhdGVzdCBUWkRCXG4gICAgLy8gICAgcnVsZXMgaGF2ZSBEU1QuXG4gICAgLy8gMi4gSWYgbm90LCB0aGVuIHdlJ2xsIFwiZmFzdC1yZXZlcnNlXCIgYmFjayB0byBhIGZldyB5ZWFycyBsYXRlciB0aGFuIHRoZVxuICAgIC8vICAgIGN1cnJlbnQgc3lzdGVtIHRpbWUsIGFuZCB0aGVuIGxvb2sgYmFjayB0byAxODQ3LiBUaGlzIHJlZHVjZXMgdGhlXG4gICAgLy8gICAgd29yc3QtY2FzZSBsb29wIGZyb20gMjczSyB5ZWFycyB0byAxNzUgeWVhcnMsIGZvciBhIH4xNTAweCBpbXByb3ZlbWVudFxuICAgIC8vICAgIGluIHdvcnN0LWNhc2UgcGVyZi5cbiAgICBjb25zdCBhZnRlckxhdGVzdFJ1bGUgPSBhZnRlckxhdGVzdFBvc3NpYmxlVHpkYlJ1bGVDaGFuZ2UoKTtcbiAgICBjb25zdCBpc0ZhckZ1dHVyZSA9IEpTQkkuZ3JlYXRlclRoYW4oZXBvY2hOYW5vc2Vjb25kcywgYWZ0ZXJMYXRlc3RSdWxlKTtcbiAgICBjb25zdCBsb3dlcmNhcCA9IGlzRmFyRnV0dXJlID8gSlNCSS5zdWJ0cmFjdChlcG9jaE5hbm9zZWNvbmRzLCBBQk9VVF9PTkVfWUVBUl9OQU5PUykgOiBCRUZPUkVfRklSU1RfT0ZGU0VUX1RSQU5TSVRJT047XG4gICAgbGV0IHJpZ2h0TmFub3MgPSBKU0JJLnN1YnRyYWN0KGVwb2NoTmFub3NlY29uZHMsIE9ORSk7XG4gICAgY29uc3QgcmlnaHRPZmZzZXROcyA9IEdldElBTkFUaW1lWm9uZU9mZnNldE5hbm9zZWNvbmRzKHJpZ2h0TmFub3MsIGlkKTtcbiAgICBsZXQgbGVmdE5hbm9zID0gcmlnaHROYW5vcztcbiAgICBsZXQgbGVmdE9mZnNldE5zID0gcmlnaHRPZmZzZXROcztcbiAgICB3aGlsZSAocmlnaHRPZmZzZXROcyA9PT0gbGVmdE9mZnNldE5zICYmIEpTQkkuZ3JlYXRlclRoYW4ocmlnaHROYW5vcywgbG93ZXJjYXApKSB7XG4gICAgICAgIGxlZnROYW5vcyA9IEpTQkkuc3VidHJhY3QocmlnaHROYW5vcywgVFdPX1dFRUtTX05BTk9TKTtcbiAgICAgICAgbGVmdE9mZnNldE5zID0gR2V0SUFOQVRpbWVab25lT2Zmc2V0TmFub3NlY29uZHMobGVmdE5hbm9zLCBpZCk7XG4gICAgICAgIGlmIChyaWdodE9mZnNldE5zID09PSBsZWZ0T2Zmc2V0TnMpIHtcbiAgICAgICAgICAgIHJpZ2h0TmFub3MgPSBsZWZ0TmFub3M7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHJpZ2h0T2Zmc2V0TnMgPT09IGxlZnRPZmZzZXROcykge1xuICAgICAgICBpZiAoaXNGYXJGdXR1cmUpIHtcbiAgICAgICAgICAgIC8vIFRoZXJlIHdhcyBubyBEU1QgYWZ0ZXIgbG9va2luZyBiYWNrIG9uZSB5ZWFyLCB3aGljaCBtZWFucyB0aGF0IHRoZSBtb3N0XG4gICAgICAgICAgICAvLyByZWNlbnQgVFpEQiBydWxlcyBkb24ndCBoYXZlIGFueSByZWN1cnJpbmcgdHJhbnNpdGlvbnMuIFRvIGNoZWNrIGZvclxuICAgICAgICAgICAgLy8gdHJhbnNpdGlvbnMgaW4gb2xkZXIgcnVsZXMsIGJhY2sgdXAgdG8gYSBmZXcgeWVhcnMgYWZ0ZXIgdGhlIGN1cnJlbnRcbiAgICAgICAgICAgIC8vIGRhdGUgYW5kIHRoZW4gbG9vayBhbGwgdGhlIHdheSBiYWNrIHRvIDE4NDcuIE5vdGUgdGhhdCB3ZSBtb3ZlIGJhY2sgb25lXG4gICAgICAgICAgICAvLyBkYXkgZnJvbSB0aGUgbGF0ZXN0IHBvc3NpYmxlIHJ1bGUgc28gdGhhdCB3aGVuIHRoZSByZWN1cnNpb24gcnVucyBpdFxuICAgICAgICAgICAgLy8gd29uJ3QgY29uc2lkZXIgdGhlIG5ldyB0aW1lIHRvIGJlIFwiZmFyIGZ1dHVyZVwiIGJlY2F1c2UgdGhlIHN5c3RlbSBjbG9ja1xuICAgICAgICAgICAgLy8gaGFzIGFkdmFuY2VkIGluIHRoZSBtZWFudGltZS5cbiAgICAgICAgICAgIGNvbnN0IG5ld1RpbWVUb0NoZWNrID0gSlNCSS5zdWJ0cmFjdChhZnRlckxhdGVzdFJ1bGUsIERBWV9OQU5PUyk7XG4gICAgICAgICAgICByZXR1cm4gR2V0SUFOQVRpbWVab25lUHJldmlvdXNUcmFuc2l0aW9uKG5ld1RpbWVUb0NoZWNrLCBpZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IGJpc2VjdCgoZXBvY2hOcykgPT4gR2V0SUFOQVRpbWVab25lT2Zmc2V0TmFub3NlY29uZHMoZXBvY2hOcywgaWQpLCBsZWZ0TmFub3MsIHJpZ2h0TmFub3MsIGxlZnRPZmZzZXROcywgcmlnaHRPZmZzZXROcyk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8vIHRzLXBydW5lLWlnbm9yZS1uZXh0IFRPRE86IHJlbW92ZSB0aGlzIGFmdGVyIHRlc3RzIGFyZSBjb252ZXJ0ZWQgdG8gVFNcbmZ1bmN0aW9uIHBhcnNlRnJvbUVuVXNGb3JtYXQoZGF0ZXRpbWUpIHtcbiAgICBjb25zdCBwYXJ0cyA9IGRhdGV0aW1lLnNwbGl0KC9bXlxcd10rLyk7XG4gICAgaWYgKHBhcnRzLmxlbmd0aCAhPT0gNykge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgZXhwZWN0ZWQgNyBwYXJ0cyBpbiBcIiR7ZGF0ZXRpbWV9YCk7XG4gICAgfVxuICAgIGNvbnN0IG1vbnRoID0gK3BhcnRzWzBdO1xuICAgIGNvbnN0IGRheSA9ICtwYXJ0c1sxXTtcbiAgICBsZXQgeWVhciA9ICtwYXJ0c1syXTtcbiAgICBjb25zdCBlcmEgPSBwYXJ0c1szXS50b1VwcGVyQ2FzZSgpO1xuICAgIGlmIChlcmEgPT09ICdCJyB8fCBlcmEgPT09ICdCQycpIHtcbiAgICAgICAgeWVhciA9IC15ZWFyICsgMTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZXJhICE9PSAnQScgJiYgZXJhICE9PSAnQUQnKSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBVbmtub3duIGVyYSAke2VyYX0gaW4gXCIke2RhdGV0aW1lfWApO1xuICAgIH1cbiAgICBsZXQgaG91ciA9ICtwYXJ0c1s0XTtcbiAgICBpZiAoaG91ciA9PT0gMjQpIHtcbiAgICAgICAgLy8gYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTEwNDU3OTFcbiAgICAgICAgaG91ciA9IDA7XG4gICAgfVxuICAgIGNvbnN0IG1pbnV0ZSA9ICtwYXJ0c1s1XTtcbiAgICBjb25zdCBzZWNvbmQgPSArcGFydHNbNl07XG4gICAgaWYgKCFOdW1iZXJJc0Zpbml0ZSh5ZWFyKSB8fFxuICAgICAgICAhTnVtYmVySXNGaW5pdGUobW9udGgpIHx8XG4gICAgICAgICFOdW1iZXJJc0Zpbml0ZShkYXkpIHx8XG4gICAgICAgICFOdW1iZXJJc0Zpbml0ZShob3VyKSB8fFxuICAgICAgICAhTnVtYmVySXNGaW5pdGUobWludXRlKSB8fFxuICAgICAgICAhTnVtYmVySXNGaW5pdGUoc2Vjb25kKSkge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgSW52YWxpZCBudW1iZXIgaW4gXCIke2RhdGV0aW1lfWApO1xuICAgIH1cbiAgICByZXR1cm4geyB5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW51dGUsIHNlY29uZCB9O1xufVxuLy8gdHMtcHJ1bmUtaWdub3JlLW5leHQgVE9ETzogcmVtb3ZlIHRoaXMgYWZ0ZXIgdGVzdHMgYXJlIGNvbnZlcnRlZCB0byBUU1xuZnVuY3Rpb24gR2V0Rm9ybWF0dGVyUGFydHModGltZVpvbmUsIGVwb2NoTWlsbGlzZWNvbmRzKSB7XG4gICAgY29uc3QgZm9ybWF0dGVyID0gZ2V0SW50bERhdGVUaW1lRm9ybWF0RW5Vc0ZvclRpbWVab25lKHRpbWVab25lKTtcbiAgICAvLyBVc2luZyBgZm9ybWF0YCBpbnN0ZWFkIG9mIGBmb3JtYXRUb1BhcnRzYCBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG9sZGVyIGNsaWVudHNcbiAgICBjb25zdCBkYXRldGltZSA9IGZvcm1hdHRlci5mb3JtYXQobmV3IERhdGUoZXBvY2hNaWxsaXNlY29uZHMpKTtcbiAgICByZXR1cm4gcGFyc2VGcm9tRW5Vc0Zvcm1hdChkYXRldGltZSk7XG59XG5mdW5jdGlvbiBHZXRJQU5BVGltZVpvbmVFcG9jaFZhbHVlKGlkLCB5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQsIG1pY3Jvc2Vjb25kLCBuYW5vc2Vjb25kKSB7XG4gICAgY29uc3QgbnMgPSBHZXRFcG9jaEZyb21JU09QYXJ0cyh5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQsIG1pY3Jvc2Vjb25kLCBuYW5vc2Vjb25kKTtcbiAgICBpZiAobnMgPT09IG51bGwpXG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdEYXRlVGltZSBvdXRzaWRlIG9mIHN1cHBvcnRlZCByYW5nZScpO1xuICAgIGxldCBuc0VhcmxpZXIgPSBKU0JJLnN1YnRyYWN0KG5zLCBEQVlfTkFOT1MpO1xuICAgIGlmIChKU0JJLmxlc3NUaGFuKG5zRWFybGllciwgTlNfTUlOKSlcbiAgICAgICAgbnNFYXJsaWVyID0gbnM7XG4gICAgbGV0IG5zTGF0ZXIgPSBKU0JJLmFkZChucywgREFZX05BTk9TKTtcbiAgICBpZiAoSlNCSS5ncmVhdGVyVGhhbihuc0xhdGVyLCBOU19NQVgpKVxuICAgICAgICBuc0xhdGVyID0gbnM7XG4gICAgY29uc3QgZWFybGllc3QgPSBHZXRJQU5BVGltZVpvbmVPZmZzZXROYW5vc2Vjb25kcyhuc0VhcmxpZXIsIGlkKTtcbiAgICBjb25zdCBsYXRlc3QgPSBHZXRJQU5BVGltZVpvbmVPZmZzZXROYW5vc2Vjb25kcyhuc0xhdGVyLCBpZCk7XG4gICAgY29uc3QgZm91bmQgPSBlYXJsaWVzdCA9PT0gbGF0ZXN0ID8gW2VhcmxpZXN0XSA6IFtlYXJsaWVzdCwgbGF0ZXN0XTtcbiAgICByZXR1cm4gZm91bmRcbiAgICAgICAgLm1hcCgob2Zmc2V0TmFub3NlY29uZHMpID0+IHtcbiAgICAgICAgY29uc3QgZXBvY2hOYW5vc2Vjb25kcyA9IEpTQkkuc3VidHJhY3QobnMsIEpTQkkuQmlnSW50KG9mZnNldE5hbm9zZWNvbmRzKSk7XG4gICAgICAgIGNvbnN0IHBhcnRzID0gR2V0SUFOQVRpbWVab25lRGF0ZVRpbWVQYXJ0cyhlcG9jaE5hbm9zZWNvbmRzLCBpZCk7XG4gICAgICAgIGlmICh5ZWFyICE9PSBwYXJ0cy55ZWFyIHx8XG4gICAgICAgICAgICBtb250aCAhPT0gcGFydHMubW9udGggfHxcbiAgICAgICAgICAgIGRheSAhPT0gcGFydHMuZGF5IHx8XG4gICAgICAgICAgICBob3VyICE9PSBwYXJ0cy5ob3VyIHx8XG4gICAgICAgICAgICBtaW51dGUgIT09IHBhcnRzLm1pbnV0ZSB8fFxuICAgICAgICAgICAgc2Vjb25kICE9PSBwYXJ0cy5zZWNvbmQgfHxcbiAgICAgICAgICAgIG1pbGxpc2Vjb25kICE9PSBwYXJ0cy5taWxsaXNlY29uZCB8fFxuICAgICAgICAgICAgbWljcm9zZWNvbmQgIT09IHBhcnRzLm1pY3Jvc2Vjb25kIHx8XG4gICAgICAgICAgICBuYW5vc2Vjb25kICE9PSBwYXJ0cy5uYW5vc2Vjb25kKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlcG9jaE5hbm9zZWNvbmRzO1xuICAgIH0pXG4gICAgICAgIC5maWx0ZXIoKHgpID0+IHggIT09IHVuZGVmaW5lZCk7XG59XG5mdW5jdGlvbiBMZWFwWWVhcih5ZWFyKSB7XG4gICAgaWYgKHVuZGVmaW5lZCA9PT0geWVhcilcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGNvbnN0IGlzRGl2NCA9IHllYXIgJSA0ID09PSAwO1xuICAgIGNvbnN0IGlzRGl2MTAwID0geWVhciAlIDEwMCA9PT0gMDtcbiAgICBjb25zdCBpc0RpdjQwMCA9IHllYXIgJSA0MDAgPT09IDA7XG4gICAgcmV0dXJuIGlzRGl2NCAmJiAoIWlzRGl2MTAwIHx8IGlzRGl2NDAwKTtcbn1cbmZ1bmN0aW9uIElTT0RheXNJbk1vbnRoKHllYXIsIG1vbnRoKSB7XG4gICAgY29uc3QgRG9NID0ge1xuICAgICAgICBzdGFuZGFyZDogWzMxLCAyOCwgMzEsIDMwLCAzMSwgMzAsIDMxLCAzMSwgMzAsIDMxLCAzMCwgMzFdLFxuICAgICAgICBsZWFweWVhcjogWzMxLCAyOSwgMzEsIDMwLCAzMSwgMzAsIDMxLCAzMSwgMzAsIDMxLCAzMCwgMzFdXG4gICAgfTtcbiAgICByZXR1cm4gRG9NW0xlYXBZZWFyKHllYXIpID8gJ2xlYXB5ZWFyJyA6ICdzdGFuZGFyZCddW21vbnRoIC0gMV07XG59XG5mdW5jdGlvbiBEYXlPZldlZWsoeWVhciwgbW9udGgsIGRheSkge1xuICAgIGNvbnN0IG0gPSBtb250aCArIChtb250aCA8IDMgPyAxMCA6IC0yKTtcbiAgICBjb25zdCBZID0geWVhciAtIChtb250aCA8IDMgPyAxIDogMCk7XG4gICAgY29uc3QgYyA9IE1hdGhGbG9vcihZIC8gMTAwKTtcbiAgICBjb25zdCB5ID0gWSAtIGMgKiAxMDA7XG4gICAgY29uc3QgZCA9IGRheTtcbiAgICBjb25zdCBwRCA9IGQ7XG4gICAgY29uc3QgcE0gPSBNYXRoRmxvb3IoMi42ICogbSAtIDAuMik7XG4gICAgY29uc3QgcFkgPSB5ICsgTWF0aEZsb29yKHkgLyA0KTtcbiAgICBjb25zdCBwQyA9IE1hdGhGbG9vcihjIC8gNCkgLSAyICogYztcbiAgICBjb25zdCBkb3cgPSAocEQgKyBwTSArIHBZICsgcEMpICUgNztcbiAgICByZXR1cm4gZG93ICsgKGRvdyA8PSAwID8gNyA6IDApO1xufVxuZnVuY3Rpb24gRGF5T2ZZZWFyKHllYXIsIG1vbnRoLCBkYXkpIHtcbiAgICBsZXQgZGF5cyA9IGRheTtcbiAgICBmb3IgKGxldCBtID0gbW9udGggLSAxOyBtID4gMDsgbS0tKSB7XG4gICAgICAgIGRheXMgKz0gSVNPRGF5c0luTW9udGgoeWVhciwgbSk7XG4gICAgfVxuICAgIHJldHVybiBkYXlzO1xufVxuZnVuY3Rpb24gV2Vla09mWWVhcih5ZWFyLCBtb250aCwgZGF5KSB7XG4gICAgY29uc3QgZG95ID0gRGF5T2ZZZWFyKHllYXIsIG1vbnRoLCBkYXkpO1xuICAgIGNvbnN0IGRvdyA9IERheU9mV2Vlayh5ZWFyLCBtb250aCwgZGF5KSB8fCA3O1xuICAgIGNvbnN0IGRvaiA9IERheU9mV2Vlayh5ZWFyLCAxLCAxKTtcbiAgICBjb25zdCB3ZWVrID0gTWF0aEZsb29yKChkb3kgLSBkb3cgKyAxMCkgLyA3KTtcbiAgICBpZiAod2VlayA8IDEpIHtcbiAgICAgICAgaWYgKGRvaiA9PT0gNSB8fCAoZG9qID09PSA2ICYmIExlYXBZZWFyKHllYXIgLSAxKSkpIHtcbiAgICAgICAgICAgIHJldHVybiA1MztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiA1MjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAod2VlayA9PT0gNTMpIHtcbiAgICAgICAgaWYgKChMZWFwWWVhcih5ZWFyKSA/IDM2NiA6IDM2NSkgLSBkb3kgPCA0IC0gZG93KSB7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gd2Vlaztcbn1cbmZ1bmN0aW9uIER1cmF0aW9uU2lnbih5LCBtb24sIHcsIGQsIGgsIG1pbiwgcywgbXMsIMK1cywgbnMpIHtcbiAgICBmb3IgKGNvbnN0IHByb3Agb2YgW3ksIG1vbiwgdywgZCwgaCwgbWluLCBzLCBtcywgwrVzLCBuc10pIHtcbiAgICAgICAgaWYgKHByb3AgIT09IDApXG4gICAgICAgICAgICByZXR1cm4gcHJvcCA8IDAgPyAtMSA6IDE7XG4gICAgfVxuICAgIHJldHVybiAwO1xufVxuZnVuY3Rpb24gQmFsYW5jZUlTT1llYXJNb250aCh5ZWFyUGFyYW0sIG1vbnRoUGFyYW0pIHtcbiAgICBsZXQgeWVhciA9IHllYXJQYXJhbTtcbiAgICBsZXQgbW9udGggPSBtb250aFBhcmFtO1xuICAgIGlmICghTnVtYmVySXNGaW5pdGUoeWVhcikgfHwgIU51bWJlcklzRmluaXRlKG1vbnRoKSlcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2luZmluaXR5IGlzIG91dCBvZiByYW5nZScpO1xuICAgIG1vbnRoIC09IDE7XG4gICAgeWVhciArPSBNYXRoRmxvb3IobW9udGggLyAxMik7XG4gICAgbW9udGggJT0gMTI7XG4gICAgaWYgKG1vbnRoIDwgMClcbiAgICAgICAgbW9udGggKz0gMTI7XG4gICAgbW9udGggKz0gMTtcbiAgICByZXR1cm4geyB5ZWFyLCBtb250aCB9O1xufVxuZnVuY3Rpb24gQmFsYW5jZUlTT0RhdGUoeWVhclBhcmFtLCBtb250aFBhcmFtLCBkYXlQYXJhbSkge1xuICAgIGxldCB5ZWFyID0geWVhclBhcmFtO1xuICAgIGxldCBtb250aCA9IG1vbnRoUGFyYW07XG4gICAgbGV0IGRheSA9IGRheVBhcmFtO1xuICAgIGlmICghTnVtYmVySXNGaW5pdGUoZGF5KSlcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2luZmluaXR5IGlzIG91dCBvZiByYW5nZScpO1xuICAgICh7IHllYXIsIG1vbnRoIH0gPSBCYWxhbmNlSVNPWWVhck1vbnRoKHllYXIsIG1vbnRoKSk7XG4gICAgbGV0IGRheXNJblllYXIgPSAwO1xuICAgIGxldCB0ZXN0WWVhciA9IG1vbnRoID4gMiA/IHllYXIgOiB5ZWFyIC0gMTtcbiAgICB3aGlsZSAoKChkYXlzSW5ZZWFyID0gTGVhcFllYXIodGVzdFllYXIpID8gMzY2IDogMzY1KSwgZGF5IDwgLWRheXNJblllYXIpKSB7XG4gICAgICAgIHllYXIgLT0gMTtcbiAgICAgICAgdGVzdFllYXIgLT0gMTtcbiAgICAgICAgZGF5ICs9IGRheXNJblllYXI7XG4gICAgfVxuICAgIHRlc3RZZWFyICs9IDE7XG4gICAgd2hpbGUgKCgoZGF5c0luWWVhciA9IExlYXBZZWFyKHRlc3RZZWFyKSA/IDM2NiA6IDM2NSksIGRheSA+IGRheXNJblllYXIpKSB7XG4gICAgICAgIHllYXIgKz0gMTtcbiAgICAgICAgdGVzdFllYXIgKz0gMTtcbiAgICAgICAgZGF5IC09IGRheXNJblllYXI7XG4gICAgfVxuICAgIHdoaWxlIChkYXkgPCAxKSB7XG4gICAgICAgICh7IHllYXIsIG1vbnRoIH0gPSBCYWxhbmNlSVNPWWVhck1vbnRoKHllYXIsIG1vbnRoIC0gMSkpO1xuICAgICAgICBkYXkgKz0gSVNPRGF5c0luTW9udGgoeWVhciwgbW9udGgpO1xuICAgIH1cbiAgICB3aGlsZSAoZGF5ID4gSVNPRGF5c0luTW9udGgoeWVhciwgbW9udGgpKSB7XG4gICAgICAgIGRheSAtPSBJU09EYXlzSW5Nb250aCh5ZWFyLCBtb250aCk7XG4gICAgICAgICh7IHllYXIsIG1vbnRoIH0gPSBCYWxhbmNlSVNPWWVhck1vbnRoKHllYXIsIG1vbnRoICsgMSkpO1xuICAgIH1cbiAgICByZXR1cm4geyB5ZWFyLCBtb250aCwgZGF5IH07XG59XG5mdW5jdGlvbiBCYWxhbmNlSVNPRGF0ZVRpbWUoeWVhclBhcmFtLCBtb250aFBhcmFtLCBkYXlQYXJhbSwgaG91clBhcmFtLCBtaW51dGVQYXJhbSwgc2Vjb25kUGFyYW0sIG1pbGxpc2Vjb25kUGFyYW0sIG1pY3Jvc2Vjb25kUGFyYW0sIG5hbm9zZWNvbmRQYXJhbSkge1xuICAgIGNvbnN0IHsgZGVsdGFEYXlzLCBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQsIG1pY3Jvc2Vjb25kLCBuYW5vc2Vjb25kIH0gPSBCYWxhbmNlVGltZShob3VyUGFyYW0sIG1pbnV0ZVBhcmFtLCBzZWNvbmRQYXJhbSwgbWlsbGlzZWNvbmRQYXJhbSwgbWljcm9zZWNvbmRQYXJhbSwgbmFub3NlY29uZFBhcmFtKTtcbiAgICBjb25zdCB7IHllYXIsIG1vbnRoLCBkYXkgfSA9IEJhbGFuY2VJU09EYXRlKHllYXJQYXJhbSwgbW9udGhQYXJhbSwgZGF5UGFyYW0gKyBkZWx0YURheXMpO1xuICAgIHJldHVybiB7IHllYXIsIG1vbnRoLCBkYXksIGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZCwgbWljcm9zZWNvbmQsIG5hbm9zZWNvbmQgfTtcbn1cbmZ1bmN0aW9uIEJhbGFuY2VUaW1lKGhvdXJQYXJhbSwgbWludXRlUGFyYW0sIHNlY29uZFBhcmFtLCBtaWxsaXNlY29uZFBhcmFtLCBtaWNyb3NlY29uZFBhcmFtLCBuYW5vc2Vjb25kUGFyYW0pIHtcbiAgICBsZXQgaG91ciA9IGhvdXJQYXJhbTtcbiAgICBsZXQgbWludXRlID0gbWludXRlUGFyYW07XG4gICAgbGV0IHNlY29uZCA9IHNlY29uZFBhcmFtO1xuICAgIGxldCBtaWxsaXNlY29uZCA9IG1pbGxpc2Vjb25kUGFyYW07XG4gICAgbGV0IG1pY3Jvc2Vjb25kID0gbWljcm9zZWNvbmRQYXJhbTtcbiAgICBsZXQgbmFub3NlY29uZCA9IG5hbm9zZWNvbmRQYXJhbTtcbiAgICBpZiAoIU51bWJlcklzRmluaXRlKGhvdXIpIHx8XG4gICAgICAgICFOdW1iZXJJc0Zpbml0ZShtaW51dGUpIHx8XG4gICAgICAgICFOdW1iZXJJc0Zpbml0ZShzZWNvbmQpIHx8XG4gICAgICAgICFOdW1iZXJJc0Zpbml0ZShtaWxsaXNlY29uZCkgfHxcbiAgICAgICAgIU51bWJlcklzRmluaXRlKG1pY3Jvc2Vjb25kKSB8fFxuICAgICAgICAhTnVtYmVySXNGaW5pdGUobmFub3NlY29uZCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2luZmluaXR5IGlzIG91dCBvZiByYW5nZScpO1xuICAgIH1cbiAgICBtaWNyb3NlY29uZCArPSBNYXRoRmxvb3IobmFub3NlY29uZCAvIDEwMDApO1xuICAgIG5hbm9zZWNvbmQgPSBOb25OZWdhdGl2ZU1vZHVsbyhuYW5vc2Vjb25kLCAxMDAwKTtcbiAgICBtaWxsaXNlY29uZCArPSBNYXRoRmxvb3IobWljcm9zZWNvbmQgLyAxMDAwKTtcbiAgICBtaWNyb3NlY29uZCA9IE5vbk5lZ2F0aXZlTW9kdWxvKG1pY3Jvc2Vjb25kLCAxMDAwKTtcbiAgICBzZWNvbmQgKz0gTWF0aEZsb29yKG1pbGxpc2Vjb25kIC8gMTAwMCk7XG4gICAgbWlsbGlzZWNvbmQgPSBOb25OZWdhdGl2ZU1vZHVsbyhtaWxsaXNlY29uZCwgMTAwMCk7XG4gICAgbWludXRlICs9IE1hdGhGbG9vcihzZWNvbmQgLyA2MCk7XG4gICAgc2Vjb25kID0gTm9uTmVnYXRpdmVNb2R1bG8oc2Vjb25kLCA2MCk7XG4gICAgaG91ciArPSBNYXRoRmxvb3IobWludXRlIC8gNjApO1xuICAgIG1pbnV0ZSA9IE5vbk5lZ2F0aXZlTW9kdWxvKG1pbnV0ZSwgNjApO1xuICAgIGNvbnN0IGRlbHRhRGF5cyA9IE1hdGhGbG9vcihob3VyIC8gMjQpO1xuICAgIGhvdXIgPSBOb25OZWdhdGl2ZU1vZHVsbyhob3VyLCAyNCk7XG4gICAgcmV0dXJuIHsgZGVsdGFEYXlzLCBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQsIG1pY3Jvc2Vjb25kLCBuYW5vc2Vjb25kIH07XG59XG5mdW5jdGlvbiBUb3RhbER1cmF0aW9uTmFub3NlY29uZHMoZGF5c1BhcmFtLCBob3Vyc1BhcmFtLCBtaW51dGVzUGFyYW0sIHNlY29uZHNQYXJhbSwgbWlsbGlzZWNvbmRzUGFyYW0sIG1pY3Jvc2Vjb25kc1BhcmFtLCBuYW5vc2Vjb25kc1BhcmFtLCBvZmZzZXRTaGlmdCkge1xuICAgIGNvbnN0IGRheXMgPSBKU0JJLkJpZ0ludChkYXlzUGFyYW0pO1xuICAgIGxldCBuYW5vc2Vjb25kcyA9IEpTQkkuQmlnSW50KG5hbm9zZWNvbmRzUGFyYW0pO1xuICAgIGlmIChkYXlzUGFyYW0gIT09IDApXG4gICAgICAgIG5hbm9zZWNvbmRzID0gSlNCSS5zdWJ0cmFjdChKU0JJLkJpZ0ludChuYW5vc2Vjb25kc1BhcmFtKSwgSlNCSS5CaWdJbnQob2Zmc2V0U2hpZnQpKTtcbiAgICBjb25zdCBob3VycyA9IEpTQkkuYWRkKEpTQkkuQmlnSW50KGhvdXJzUGFyYW0pLCBKU0JJLm11bHRpcGx5KGRheXMsIEpTQkkuQmlnSW50KDI0KSkpO1xuICAgIGNvbnN0IG1pbnV0ZXMgPSBKU0JJLmFkZChKU0JJLkJpZ0ludChtaW51dGVzUGFyYW0pLCBKU0JJLm11bHRpcGx5KGhvdXJzLCBTSVhUWSkpO1xuICAgIGNvbnN0IHNlY29uZHMgPSBKU0JJLmFkZChKU0JJLkJpZ0ludChzZWNvbmRzUGFyYW0pLCBKU0JJLm11bHRpcGx5KG1pbnV0ZXMsIFNJWFRZKSk7XG4gICAgY29uc3QgbWlsbGlzZWNvbmRzID0gSlNCSS5hZGQoSlNCSS5CaWdJbnQobWlsbGlzZWNvbmRzUGFyYW0pLCBKU0JJLm11bHRpcGx5KHNlY29uZHMsIFRIT1VTQU5EKSk7XG4gICAgY29uc3QgbWljcm9zZWNvbmRzID0gSlNCSS5hZGQoSlNCSS5CaWdJbnQobWljcm9zZWNvbmRzUGFyYW0pLCBKU0JJLm11bHRpcGx5KG1pbGxpc2Vjb25kcywgVEhPVVNBTkQpKTtcbiAgICByZXR1cm4gSlNCSS5hZGQoSlNCSS5CaWdJbnQobmFub3NlY29uZHMpLCBKU0JJLm11bHRpcGx5KG1pY3Jvc2Vjb25kcywgVEhPVVNBTkQpKTtcbn1cbmZ1bmN0aW9uIE5hbm9zZWNvbmRzVG9EYXlzKG5hbm9zZWNvbmRzUGFyYW0sIHJlbGF0aXZlVG8pIHtcbiAgICBjb25zdCBUZW1wb3JhbEluc3RhbnQgPSBHZXRJbnRyaW5zaWMoJyVUZW1wb3JhbC5JbnN0YW50JScpO1xuICAgIGNvbnN0IHNpZ24gPSBNYXRoU2lnbihKU0JJLnRvTnVtYmVyKG5hbm9zZWNvbmRzUGFyYW0pKTtcbiAgICBsZXQgbmFub3NlY29uZHMgPSBKU0JJLkJpZ0ludChuYW5vc2Vjb25kc1BhcmFtKTtcbiAgICBsZXQgZGF5TGVuZ3RoTnMgPSA4NjQwMGU5O1xuICAgIGlmIChzaWduID09PSAwKVxuICAgICAgICByZXR1cm4geyBkYXlzOiAwLCBuYW5vc2Vjb25kczogWkVSTywgZGF5TGVuZ3RoTnMgfTtcbiAgICBpZiAoIUlzVGVtcG9yYWxab25lZERhdGVUaW1lKHJlbGF0aXZlVG8pKSB7XG4gICAgICAgIGxldCBkYXlzO1xuICAgICAgICAoeyBxdW90aWVudDogZGF5cywgcmVtYWluZGVyOiBuYW5vc2Vjb25kcyB9ID0gZGl2bW9kKG5hbm9zZWNvbmRzLCBKU0JJLkJpZ0ludChkYXlMZW5ndGhOcykpKTtcbiAgICAgICAgcmV0dXJuIHsgZGF5czogSlNCSS50b051bWJlcihkYXlzKSwgbmFub3NlY29uZHMsIGRheUxlbmd0aE5zIH07XG4gICAgfVxuICAgIGNvbnN0IHN0YXJ0TnMgPSBHZXRTbG90KHJlbGF0aXZlVG8sIEVQT0NITkFOT1NFQ09ORFMpO1xuICAgIGNvbnN0IHN0YXJ0ID0gR2V0U2xvdChyZWxhdGl2ZVRvLCBJTlNUQU5UKTtcbiAgICBjb25zdCBlbmROcyA9IEpTQkkuYWRkKHN0YXJ0TnMsIG5hbm9zZWNvbmRzKTtcbiAgICBjb25zdCBlbmQgPSBuZXcgVGVtcG9yYWxJbnN0YW50KGVuZE5zKTtcbiAgICBjb25zdCB0aW1lWm9uZSA9IEdldFNsb3QocmVsYXRpdmVUbywgVElNRV9aT05FKTtcbiAgICBjb25zdCBjYWxlbmRhciA9IEdldFNsb3QocmVsYXRpdmVUbywgQ0FMRU5EQVIpO1xuICAgIC8vIEZpbmQgdGhlIGRpZmZlcmVuY2UgaW4gZGF5cyBvbmx5LlxuICAgIGNvbnN0IGR0U3RhcnQgPSBCdWlsdGluVGltZVpvbmVHZXRQbGFpbkRhdGVUaW1lRm9yKHRpbWVab25lLCBzdGFydCwgY2FsZW5kYXIpO1xuICAgIGNvbnN0IGR0RW5kID0gQnVpbHRpblRpbWVab25lR2V0UGxhaW5EYXRlVGltZUZvcih0aW1lWm9uZSwgZW5kLCBjYWxlbmRhcik7XG4gICAgbGV0IHsgZGF5cyB9ID0gRGlmZmVyZW5jZUlTT0RhdGVUaW1lKEdldFNsb3QoZHRTdGFydCwgSVNPX1lFQVIpLCBHZXRTbG90KGR0U3RhcnQsIElTT19NT05USCksIEdldFNsb3QoZHRTdGFydCwgSVNPX0RBWSksIEdldFNsb3QoZHRTdGFydCwgSVNPX0hPVVIpLCBHZXRTbG90KGR0U3RhcnQsIElTT19NSU5VVEUpLCBHZXRTbG90KGR0U3RhcnQsIElTT19TRUNPTkQpLCBHZXRTbG90KGR0U3RhcnQsIElTT19NSUxMSVNFQ09ORCksIEdldFNsb3QoZHRTdGFydCwgSVNPX01JQ1JPU0VDT05EKSwgR2V0U2xvdChkdFN0YXJ0LCBJU09fTkFOT1NFQ09ORCksIEdldFNsb3QoZHRFbmQsIElTT19ZRUFSKSwgR2V0U2xvdChkdEVuZCwgSVNPX01PTlRIKSwgR2V0U2xvdChkdEVuZCwgSVNPX0RBWSksIEdldFNsb3QoZHRFbmQsIElTT19IT1VSKSwgR2V0U2xvdChkdEVuZCwgSVNPX01JTlVURSksIEdldFNsb3QoZHRFbmQsIElTT19TRUNPTkQpLCBHZXRTbG90KGR0RW5kLCBJU09fTUlMTElTRUNPTkQpLCBHZXRTbG90KGR0RW5kLCBJU09fTUlDUk9TRUNPTkQpLCBHZXRTbG90KGR0RW5kLCBJU09fTkFOT1NFQ09ORCksIGNhbGVuZGFyLCAnZGF5Jyk7XG4gICAgbGV0IGludGVybWVkaWF0ZU5zID0gQWRkWm9uZWREYXRlVGltZShzdGFydCwgdGltZVpvbmUsIGNhbGVuZGFyLCAwLCAwLCAwLCBkYXlzLCAwLCAwLCAwLCAwLCAwLCAwKTtcbiAgICAvLyBtYXkgZGlzYW1iaWd1YXRlXG4gICAgLy8gSWYgY2xvY2sgdGltZSBhZnRlciBhZGRpdGlvbiB3YXMgaW4gdGhlIG1pZGRsZSBvZiBhIHNraXBwZWQgcGVyaW9kLCB0aGVcbiAgICAvLyBlbmRwb2ludCB3YXMgZGlzYW1iaWd1YXRlZCB0byBhIGxhdGVyIGNsb2NrIHRpbWUuIFNvIGl0J3MgcG9zc2libGUgdGhhdFxuICAgIC8vIHRoZSByZXN1bHRpbmcgZGlzYW1iaWd1YXRlZCByZXN1bHQgaXMgbGF0ZXIgdGhhbiBlbmROcy4gSWYgc28sIHRoZW4gYmFja1xuICAgIC8vIHVwIG9uZSBkYXkgYW5kIHRyeSBhZ2Fpbi4gUmVwZWF0IGlmIG5lY2Vzc2FyeSAoc29tZSB0cmFuc2l0aW9ucyBhcmVcbiAgICAvLyA+IDI0IGhvdXJzKSB1bnRpbCBlaXRoZXIgdGhlcmUncyB6ZXJvIGRheXMgbGVmdCBvciB0aGUgZGF0ZSBkdXJhdGlvbiBpc1xuICAgIC8vIGJhY2sgaW5zaWRlIHRoZSBwZXJpb2Qgd2hlcmUgaXQgYmVsb25ncy4gTm90ZSB0aGF0IHRoaXMgY2FzZSBvbmx5IGNhblxuICAgIC8vIGhhcHBlbiBmb3IgcG9zaXRpdmUgZHVyYXRpb25zIGJlY2F1c2UgdGhlIG9ubHkgZGlyZWN0aW9uIHRoYXRcbiAgICAvLyBgZGlzYW1iaWd1YXRpb246ICdjb21wYXRpYmxlJ2AgY2FuIGNoYW5nZSBjbG9jayB0aW1lIGlzIGZvcndhcmRzLlxuICAgIGlmIChzaWduID09PSAxKSB7XG4gICAgICAgIHdoaWxlIChkYXlzID4gMCAmJiBKU0JJLmdyZWF0ZXJUaGFuKGludGVybWVkaWF0ZU5zLCBlbmROcykpIHtcbiAgICAgICAgICAgIC0tZGF5cztcbiAgICAgICAgICAgIGludGVybWVkaWF0ZU5zID0gQWRkWm9uZWREYXRlVGltZShzdGFydCwgdGltZVpvbmUsIGNhbGVuZGFyLCAwLCAwLCAwLCBkYXlzLCAwLCAwLCAwLCAwLCAwLCAwKTtcbiAgICAgICAgICAgIC8vIG1heSBkbyBkaXNhbWJpZ3VhdGlvblxuICAgICAgICB9XG4gICAgfVxuICAgIG5hbm9zZWNvbmRzID0gSlNCSS5zdWJ0cmFjdChlbmROcywgaW50ZXJtZWRpYXRlTnMpO1xuICAgIGxldCBpc092ZXJmbG93ID0gZmFsc2U7XG4gICAgbGV0IHJlbGF0aXZlSW5zdGFudCA9IG5ldyBUZW1wb3JhbEluc3RhbnQoaW50ZXJtZWRpYXRlTnMpO1xuICAgIGRvIHtcbiAgICAgICAgLy8gY2FsY3VsYXRlIGxlbmd0aCBvZiB0aGUgbmV4dCBkYXkgKGRheSB0aGF0IGNvbnRhaW5zIHRoZSB0aW1lIHJlbWFpbmRlcilcbiAgICAgICAgY29uc3Qgb25lRGF5RmFydGhlck5zID0gQWRkWm9uZWREYXRlVGltZShyZWxhdGl2ZUluc3RhbnQsIHRpbWVab25lLCBjYWxlbmRhciwgMCwgMCwgMCwgc2lnbiwgMCwgMCwgMCwgMCwgMCwgMCk7XG4gICAgICAgIGNvbnN0IHJlbGF0aXZlTnMgPSBHZXRTbG90KHJlbGF0aXZlSW5zdGFudCwgRVBPQ0hOQU5PU0VDT05EUyk7XG4gICAgICAgIGRheUxlbmd0aE5zID0gSlNCSS50b051bWJlcihKU0JJLnN1YnRyYWN0KG9uZURheUZhcnRoZXJOcywgcmVsYXRpdmVOcykpO1xuICAgICAgICBpc092ZXJmbG93ID0gSlNCSS5ncmVhdGVyVGhhbihKU0JJLm11bHRpcGx5KEpTQkkuc3VidHJhY3QobmFub3NlY29uZHMsIEpTQkkuQmlnSW50KGRheUxlbmd0aE5zKSksIEpTQkkuQmlnSW50KHNpZ24pKSwgWkVSTyk7XG4gICAgICAgIGlmIChpc092ZXJmbG93KSB7XG4gICAgICAgICAgICBuYW5vc2Vjb25kcyA9IEpTQkkuc3VidHJhY3QobmFub3NlY29uZHMsIEpTQkkuQmlnSW50KGRheUxlbmd0aE5zKSk7XG4gICAgICAgICAgICByZWxhdGl2ZUluc3RhbnQgPSBuZXcgVGVtcG9yYWxJbnN0YW50KG9uZURheUZhcnRoZXJOcyk7XG4gICAgICAgICAgICBkYXlzICs9IHNpZ247XG4gICAgICAgIH1cbiAgICB9IHdoaWxlIChpc092ZXJmbG93KTtcbiAgICByZXR1cm4geyBkYXlzLCBuYW5vc2Vjb25kcywgZGF5TGVuZ3RoTnM6IE1hdGhBYnMoZGF5TGVuZ3RoTnMpIH07XG59XG5mdW5jdGlvbiBCYWxhbmNlRHVyYXRpb24oZGF5c1BhcmFtLCBob3Vyc1BhcmFtLCBtaW51dGVzUGFyYW0sIHNlY29uZHNQYXJhbSwgbWlsbGlzZWNvbmRzUGFyYW0sIG1pY3Jvc2Vjb25kc1BhcmFtLCBuYW5vc2Vjb25kc1BhcmFtLCBsYXJnZXN0VW5pdCwgcmVsYXRpdmVUbyA9IHVuZGVmaW5lZCkge1xuICAgIGxldCBkYXlzID0gZGF5c1BhcmFtO1xuICAgIGxldCBuYW5vc2Vjb25kc0JpZ0ludCwgbWljcm9zZWNvbmRzQmlnSW50LCBtaWxsaXNlY29uZHNCaWdJbnQsIHNlY29uZHNCaWdJbnQsIG1pbnV0ZXNCaWdJbnQsIGhvdXJzQmlnSW50O1xuICAgIGlmIChJc1RlbXBvcmFsWm9uZWREYXRlVGltZShyZWxhdGl2ZVRvKSkge1xuICAgICAgICBjb25zdCBlbmROcyA9IEFkZFpvbmVkRGF0ZVRpbWUoR2V0U2xvdChyZWxhdGl2ZVRvLCBJTlNUQU5UKSwgR2V0U2xvdChyZWxhdGl2ZVRvLCBUSU1FX1pPTkUpLCBHZXRTbG90KHJlbGF0aXZlVG8sIENBTEVOREFSKSwgMCwgMCwgMCwgZGF5cywgaG91cnNQYXJhbSwgbWludXRlc1BhcmFtLCBzZWNvbmRzUGFyYW0sIG1pbGxpc2Vjb25kc1BhcmFtLCBtaWNyb3NlY29uZHNQYXJhbSwgbmFub3NlY29uZHNQYXJhbSk7XG4gICAgICAgIGNvbnN0IHN0YXJ0TnMgPSBHZXRTbG90KHJlbGF0aXZlVG8sIEVQT0NITkFOT1NFQ09ORFMpO1xuICAgICAgICBuYW5vc2Vjb25kc0JpZ0ludCA9IEpTQkkuc3VidHJhY3QoZW5kTnMsIHN0YXJ0TnMpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbmFub3NlY29uZHNCaWdJbnQgPSBUb3RhbER1cmF0aW9uTmFub3NlY29uZHMoZGF5cywgaG91cnNQYXJhbSwgbWludXRlc1BhcmFtLCBzZWNvbmRzUGFyYW0sIG1pbGxpc2Vjb25kc1BhcmFtLCBtaWNyb3NlY29uZHNQYXJhbSwgbmFub3NlY29uZHNQYXJhbSwgMCk7XG4gICAgfVxuICAgIGlmIChsYXJnZXN0VW5pdCA9PT0gJ3llYXInIHx8IGxhcmdlc3RVbml0ID09PSAnbW9udGgnIHx8IGxhcmdlc3RVbml0ID09PSAnd2VlaycgfHwgbGFyZ2VzdFVuaXQgPT09ICdkYXknKSB7XG4gICAgICAgICh7IGRheXMsIG5hbm9zZWNvbmRzOiBuYW5vc2Vjb25kc0JpZ0ludCB9ID0gTmFub3NlY29uZHNUb0RheXMobmFub3NlY29uZHNCaWdJbnQsIHJlbGF0aXZlVG8pKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGRheXMgPSAwO1xuICAgIH1cbiAgICBjb25zdCBzaWduID0gSlNCSS5sZXNzVGhhbihuYW5vc2Vjb25kc0JpZ0ludCwgWkVSTykgPyAtMSA6IDE7XG4gICAgbmFub3NlY29uZHNCaWdJbnQgPSBhYnMobmFub3NlY29uZHNCaWdJbnQpO1xuICAgIG1pY3Jvc2Vjb25kc0JpZ0ludCA9IG1pbGxpc2Vjb25kc0JpZ0ludCA9IHNlY29uZHNCaWdJbnQgPSBtaW51dGVzQmlnSW50ID0gaG91cnNCaWdJbnQgPSBaRVJPO1xuICAgIHN3aXRjaCAobGFyZ2VzdFVuaXQpIHtcbiAgICAgICAgY2FzZSAneWVhcic6XG4gICAgICAgIGNhc2UgJ21vbnRoJzpcbiAgICAgICAgY2FzZSAnd2Vlayc6XG4gICAgICAgIGNhc2UgJ2RheSc6XG4gICAgICAgIGNhc2UgJ2hvdXInOlxuICAgICAgICAgICAgKHsgcXVvdGllbnQ6IG1pY3Jvc2Vjb25kc0JpZ0ludCwgcmVtYWluZGVyOiBuYW5vc2Vjb25kc0JpZ0ludCB9ID0gZGl2bW9kKG5hbm9zZWNvbmRzQmlnSW50LCBUSE9VU0FORCkpO1xuICAgICAgICAgICAgKHsgcXVvdGllbnQ6IG1pbGxpc2Vjb25kc0JpZ0ludCwgcmVtYWluZGVyOiBtaWNyb3NlY29uZHNCaWdJbnQgfSA9IGRpdm1vZChtaWNyb3NlY29uZHNCaWdJbnQsIFRIT1VTQU5EKSk7XG4gICAgICAgICAgICAoeyBxdW90aWVudDogc2Vjb25kc0JpZ0ludCwgcmVtYWluZGVyOiBtaWxsaXNlY29uZHNCaWdJbnQgfSA9IGRpdm1vZChtaWxsaXNlY29uZHNCaWdJbnQsIFRIT1VTQU5EKSk7XG4gICAgICAgICAgICAoeyBxdW90aWVudDogbWludXRlc0JpZ0ludCwgcmVtYWluZGVyOiBzZWNvbmRzQmlnSW50IH0gPSBkaXZtb2Qoc2Vjb25kc0JpZ0ludCwgU0lYVFkpKTtcbiAgICAgICAgICAgICh7IHF1b3RpZW50OiBob3Vyc0JpZ0ludCwgcmVtYWluZGVyOiBtaW51dGVzQmlnSW50IH0gPSBkaXZtb2QobWludXRlc0JpZ0ludCwgU0lYVFkpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdtaW51dGUnOlxuICAgICAgICAgICAgKHsgcXVvdGllbnQ6IG1pY3Jvc2Vjb25kc0JpZ0ludCwgcmVtYWluZGVyOiBuYW5vc2Vjb25kc0JpZ0ludCB9ID0gZGl2bW9kKG5hbm9zZWNvbmRzQmlnSW50LCBUSE9VU0FORCkpO1xuICAgICAgICAgICAgKHsgcXVvdGllbnQ6IG1pbGxpc2Vjb25kc0JpZ0ludCwgcmVtYWluZGVyOiBtaWNyb3NlY29uZHNCaWdJbnQgfSA9IGRpdm1vZChtaWNyb3NlY29uZHNCaWdJbnQsIFRIT1VTQU5EKSk7XG4gICAgICAgICAgICAoeyBxdW90aWVudDogc2Vjb25kc0JpZ0ludCwgcmVtYWluZGVyOiBtaWxsaXNlY29uZHNCaWdJbnQgfSA9IGRpdm1vZChtaWxsaXNlY29uZHNCaWdJbnQsIFRIT1VTQU5EKSk7XG4gICAgICAgICAgICAoeyBxdW90aWVudDogbWludXRlc0JpZ0ludCwgcmVtYWluZGVyOiBzZWNvbmRzQmlnSW50IH0gPSBkaXZtb2Qoc2Vjb25kc0JpZ0ludCwgU0lYVFkpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdzZWNvbmQnOlxuICAgICAgICAgICAgKHsgcXVvdGllbnQ6IG1pY3Jvc2Vjb25kc0JpZ0ludCwgcmVtYWluZGVyOiBuYW5vc2Vjb25kc0JpZ0ludCB9ID0gZGl2bW9kKG5hbm9zZWNvbmRzQmlnSW50LCBUSE9VU0FORCkpO1xuICAgICAgICAgICAgKHsgcXVvdGllbnQ6IG1pbGxpc2Vjb25kc0JpZ0ludCwgcmVtYWluZGVyOiBtaWNyb3NlY29uZHNCaWdJbnQgfSA9IGRpdm1vZChtaWNyb3NlY29uZHNCaWdJbnQsIFRIT1VTQU5EKSk7XG4gICAgICAgICAgICAoeyBxdW90aWVudDogc2Vjb25kc0JpZ0ludCwgcmVtYWluZGVyOiBtaWxsaXNlY29uZHNCaWdJbnQgfSA9IGRpdm1vZChtaWxsaXNlY29uZHNCaWdJbnQsIFRIT1VTQU5EKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnbWlsbGlzZWNvbmQnOlxuICAgICAgICAgICAgKHsgcXVvdGllbnQ6IG1pY3Jvc2Vjb25kc0JpZ0ludCwgcmVtYWluZGVyOiBuYW5vc2Vjb25kc0JpZ0ludCB9ID0gZGl2bW9kKG5hbm9zZWNvbmRzQmlnSW50LCBUSE9VU0FORCkpO1xuICAgICAgICAgICAgKHsgcXVvdGllbnQ6IG1pbGxpc2Vjb25kc0JpZ0ludCwgcmVtYWluZGVyOiBtaWNyb3NlY29uZHNCaWdJbnQgfSA9IGRpdm1vZChtaWNyb3NlY29uZHNCaWdJbnQsIFRIT1VTQU5EKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnbWljcm9zZWNvbmQnOlxuICAgICAgICAgICAgKHsgcXVvdGllbnQ6IG1pY3Jvc2Vjb25kc0JpZ0ludCwgcmVtYWluZGVyOiBuYW5vc2Vjb25kc0JpZ0ludCB9ID0gZGl2bW9kKG5hbm9zZWNvbmRzQmlnSW50LCBUSE9VU0FORCkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ25hbm9zZWNvbmQnOlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Fzc2VydCBub3QgcmVhY2hlZCcpO1xuICAgIH1cbiAgICBjb25zdCBob3VycyA9IEpTQkkudG9OdW1iZXIoaG91cnNCaWdJbnQpICogc2lnbjtcbiAgICBjb25zdCBtaW51dGVzID0gSlNCSS50b051bWJlcihtaW51dGVzQmlnSW50KSAqIHNpZ247XG4gICAgY29uc3Qgc2Vjb25kcyA9IEpTQkkudG9OdW1iZXIoc2Vjb25kc0JpZ0ludCkgKiBzaWduO1xuICAgIGNvbnN0IG1pbGxpc2Vjb25kcyA9IEpTQkkudG9OdW1iZXIobWlsbGlzZWNvbmRzQmlnSW50KSAqIHNpZ247XG4gICAgY29uc3QgbWljcm9zZWNvbmRzID0gSlNCSS50b051bWJlcihtaWNyb3NlY29uZHNCaWdJbnQpICogc2lnbjtcbiAgICBjb25zdCBuYW5vc2Vjb25kcyA9IEpTQkkudG9OdW1iZXIobmFub3NlY29uZHNCaWdJbnQpICogc2lnbjtcbiAgICByZXR1cm4geyBkYXlzLCBob3VycywgbWludXRlcywgc2Vjb25kcywgbWlsbGlzZWNvbmRzLCBtaWNyb3NlY29uZHMsIG5hbm9zZWNvbmRzIH07XG59XG5mdW5jdGlvbiBVbmJhbGFuY2VEdXJhdGlvblJlbGF0aXZlKHllYXJzUGFyYW0sIG1vbnRoc1BhcmFtLCB3ZWVrc1BhcmFtLCBkYXlzUGFyYW0sIGxhcmdlc3RVbml0LCByZWxhdGl2ZVRvUGFyYW0pIHtcbiAgICBsZXQgeWVhcnMgPSB5ZWFyc1BhcmFtO1xuICAgIGxldCBtb250aHMgPSBtb250aHNQYXJhbTtcbiAgICBsZXQgd2Vla3MgPSB3ZWVrc1BhcmFtO1xuICAgIGxldCBkYXlzID0gZGF5c1BhcmFtO1xuICAgIGNvbnN0IFRlbXBvcmFsRHVyYXRpb24gPSBHZXRJbnRyaW5zaWMoJyVUZW1wb3JhbC5EdXJhdGlvbiUnKTtcbiAgICBjb25zdCBzaWduID0gRHVyYXRpb25TaWduKHllYXJzLCBtb250aHMsIHdlZWtzLCBkYXlzLCAwLCAwLCAwLCAwLCAwLCAwKTtcbiAgICBsZXQgY2FsZW5kYXI7XG4gICAgbGV0IHJlbGF0aXZlVG87XG4gICAgaWYgKHJlbGF0aXZlVG9QYXJhbSkge1xuICAgICAgICByZWxhdGl2ZVRvID0gVG9UZW1wb3JhbERhdGUocmVsYXRpdmVUb1BhcmFtKTtcbiAgICAgICAgY2FsZW5kYXIgPSBHZXRTbG90KHJlbGF0aXZlVG8sIENBTEVOREFSKTtcbiAgICB9XG4gICAgY29uc3Qgb25lWWVhciA9IG5ldyBUZW1wb3JhbER1cmF0aW9uKHNpZ24pO1xuICAgIGNvbnN0IG9uZU1vbnRoID0gbmV3IFRlbXBvcmFsRHVyYXRpb24oMCwgc2lnbik7XG4gICAgY29uc3Qgb25lV2VlayA9IG5ldyBUZW1wb3JhbER1cmF0aW9uKDAsIDAsIHNpZ24pO1xuICAgIHN3aXRjaCAobGFyZ2VzdFVuaXQpIHtcbiAgICAgICAgY2FzZSAneWVhcic6XG4gICAgICAgICAgICAvLyBuby1vcFxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ21vbnRoJzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpZiAoIWNhbGVuZGFyKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignYSBzdGFydGluZyBwb2ludCBpcyByZXF1aXJlZCBmb3IgbW9udGhzIGJhbGFuY2luZycpO1xuICAgICAgICAgICAgICAgIC8vIGJhbGFuY2UgeWVhcnMgZG93biB0byBtb250aHNcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRlQWRkID0gY2FsZW5kYXIuZGF0ZUFkZDtcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRlVW50aWwgPSBjYWxlbmRhci5kYXRlVW50aWw7XG4gICAgICAgICAgICAgICAgbGV0IHJlbGF0aXZlVG9EYXRlT25seSA9IHJlbGF0aXZlVG87XG4gICAgICAgICAgICAgICAgd2hpbGUgKE1hdGhBYnMoeWVhcnMpID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhZGRPcHRpb25zID0gT2JqZWN0Q3JlYXRlJDIobnVsbCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld1JlbGF0aXZlVG8gPSBDYWxlbmRhckRhdGVBZGQoY2FsZW5kYXIsIHJlbGF0aXZlVG9EYXRlT25seSwgb25lWWVhciwgYWRkT3B0aW9ucywgZGF0ZUFkZCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHVudGlsT3B0aW9ucyA9IE9iamVjdENyZWF0ZSQyKG51bGwpO1xuICAgICAgICAgICAgICAgICAgICB1bnRpbE9wdGlvbnMubGFyZ2VzdFVuaXQgPSAnbW9udGgnO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB1bnRpbFJlc3VsdCA9IENhbGVuZGFyRGF0ZVVudGlsKGNhbGVuZGFyLCByZWxhdGl2ZVRvRGF0ZU9ubHksIG5ld1JlbGF0aXZlVG8sIHVudGlsT3B0aW9ucywgZGF0ZVVudGlsKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb25lWWVhck1vbnRocyA9IEdldFNsb3QodW50aWxSZXN1bHQsIE1PTlRIUyk7XG4gICAgICAgICAgICAgICAgICAgIHJlbGF0aXZlVG9EYXRlT25seSA9IG5ld1JlbGF0aXZlVG87XG4gICAgICAgICAgICAgICAgICAgIG1vbnRocyArPSBvbmVZZWFyTW9udGhzO1xuICAgICAgICAgICAgICAgICAgICB5ZWFycyAtPSBzaWduO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICd3ZWVrJzpcbiAgICAgICAgICAgIGlmICghY2FsZW5kYXIpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2Egc3RhcnRpbmcgcG9pbnQgaXMgcmVxdWlyZWQgZm9yIHdlZWtzIGJhbGFuY2luZycpO1xuICAgICAgICAgICAgLy8gYmFsYW5jZSB5ZWFycyBkb3duIHRvIGRheXNcbiAgICAgICAgICAgIHdoaWxlIChNYXRoQWJzKHllYXJzKSA+IDApIHtcbiAgICAgICAgICAgICAgICBsZXQgb25lWWVhckRheXM7XG4gICAgICAgICAgICAgICAgKHsgcmVsYXRpdmVUbywgZGF5czogb25lWWVhckRheXMgfSA9IE1vdmVSZWxhdGl2ZURhdGUoY2FsZW5kYXIsIHJlbGF0aXZlVG8sIG9uZVllYXIpKTtcbiAgICAgICAgICAgICAgICBkYXlzICs9IG9uZVllYXJEYXlzO1xuICAgICAgICAgICAgICAgIHllYXJzIC09IHNpZ247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBiYWxhbmNlIG1vbnRocyBkb3duIHRvIGRheXNcbiAgICAgICAgICAgIHdoaWxlIChNYXRoQWJzKG1vbnRocykgPiAwKSB7XG4gICAgICAgICAgICAgICAgbGV0IG9uZU1vbnRoRGF5cztcbiAgICAgICAgICAgICAgICAoeyByZWxhdGl2ZVRvLCBkYXlzOiBvbmVNb250aERheXMgfSA9IE1vdmVSZWxhdGl2ZURhdGUoY2FsZW5kYXIsIHJlbGF0aXZlVG8sIG9uZU1vbnRoKSk7XG4gICAgICAgICAgICAgICAgZGF5cyArPSBvbmVNb250aERheXM7XG4gICAgICAgICAgICAgICAgbW9udGhzIC09IHNpZ247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIC8vIGJhbGFuY2UgeWVhcnMgZG93biB0byBkYXlzXG4gICAgICAgICAgICB3aGlsZSAoTWF0aEFicyh5ZWFycykgPiAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFjYWxlbmRhcilcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2Egc3RhcnRpbmcgcG9pbnQgaXMgcmVxdWlyZWQgZm9yIGJhbGFuY2luZyBjYWxlbmRhciB1bml0cycpO1xuICAgICAgICAgICAgICAgIGxldCBvbmVZZWFyRGF5cztcbiAgICAgICAgICAgICAgICAoeyByZWxhdGl2ZVRvLCBkYXlzOiBvbmVZZWFyRGF5cyB9ID0gTW92ZVJlbGF0aXZlRGF0ZShjYWxlbmRhciwgcmVsYXRpdmVUbywgb25lWWVhcikpO1xuICAgICAgICAgICAgICAgIGRheXMgKz0gb25lWWVhckRheXM7XG4gICAgICAgICAgICAgICAgeWVhcnMgLT0gc2lnbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGJhbGFuY2UgbW9udGhzIGRvd24gdG8gZGF5c1xuICAgICAgICAgICAgd2hpbGUgKE1hdGhBYnMobW9udGhzKSA+IDApIHtcbiAgICAgICAgICAgICAgICBpZiAoIWNhbGVuZGFyKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignYSBzdGFydGluZyBwb2ludCBpcyByZXF1aXJlZCBmb3IgYmFsYW5jaW5nIGNhbGVuZGFyIHVuaXRzJyk7XG4gICAgICAgICAgICAgICAgbGV0IG9uZU1vbnRoRGF5cztcbiAgICAgICAgICAgICAgICAoeyByZWxhdGl2ZVRvLCBkYXlzOiBvbmVNb250aERheXMgfSA9IE1vdmVSZWxhdGl2ZURhdGUoY2FsZW5kYXIsIHJlbGF0aXZlVG8sIG9uZU1vbnRoKSk7XG4gICAgICAgICAgICAgICAgZGF5cyArPSBvbmVNb250aERheXM7XG4gICAgICAgICAgICAgICAgbW9udGhzIC09IHNpZ247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBiYWxhbmNlIHdlZWtzIGRvd24gdG8gZGF5c1xuICAgICAgICAgICAgd2hpbGUgKE1hdGhBYnMod2Vla3MpID4gMCkge1xuICAgICAgICAgICAgICAgIGlmICghY2FsZW5kYXIpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdhIHN0YXJ0aW5nIHBvaW50IGlzIHJlcXVpcmVkIGZvciBiYWxhbmNpbmcgY2FsZW5kYXIgdW5pdHMnKTtcbiAgICAgICAgICAgICAgICBsZXQgb25lV2Vla0RheXM7XG4gICAgICAgICAgICAgICAgKHsgcmVsYXRpdmVUbywgZGF5czogb25lV2Vla0RheXMgfSA9IE1vdmVSZWxhdGl2ZURhdGUoY2FsZW5kYXIsIHJlbGF0aXZlVG8sIG9uZVdlZWspKTtcbiAgICAgICAgICAgICAgICBkYXlzICs9IG9uZVdlZWtEYXlzO1xuICAgICAgICAgICAgICAgIHdlZWtzIC09IHNpZ247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIHsgeWVhcnMsIG1vbnRocywgd2Vla3MsIGRheXMgfTtcbn1cbmZ1bmN0aW9uIEJhbGFuY2VEdXJhdGlvblJlbGF0aXZlKHllYXJzUGFyYW0sIG1vbnRoc1BhcmFtLCB3ZWVrc1BhcmFtLCBkYXlzUGFyYW0sIGxhcmdlc3RVbml0LCByZWxhdGl2ZVRvUGFyYW0pIHtcbiAgICBsZXQgeWVhcnMgPSB5ZWFyc1BhcmFtO1xuICAgIGxldCBtb250aHMgPSBtb250aHNQYXJhbTtcbiAgICBsZXQgd2Vla3MgPSB3ZWVrc1BhcmFtO1xuICAgIGxldCBkYXlzID0gZGF5c1BhcmFtO1xuICAgIGNvbnN0IFRlbXBvcmFsRHVyYXRpb24gPSBHZXRJbnRyaW5zaWMoJyVUZW1wb3JhbC5EdXJhdGlvbiUnKTtcbiAgICBjb25zdCBzaWduID0gRHVyYXRpb25TaWduKHllYXJzLCBtb250aHMsIHdlZWtzLCBkYXlzLCAwLCAwLCAwLCAwLCAwLCAwKTtcbiAgICBpZiAoc2lnbiA9PT0gMClcbiAgICAgICAgcmV0dXJuIHsgeWVhcnMsIG1vbnRocywgd2Vla3MsIGRheXMgfTtcbiAgICBsZXQgY2FsZW5kYXI7XG4gICAgbGV0IHJlbGF0aXZlVG87XG4gICAgaWYgKHJlbGF0aXZlVG9QYXJhbSkge1xuICAgICAgICByZWxhdGl2ZVRvID0gVG9UZW1wb3JhbERhdGUocmVsYXRpdmVUb1BhcmFtKTtcbiAgICAgICAgY2FsZW5kYXIgPSBHZXRTbG90KHJlbGF0aXZlVG8sIENBTEVOREFSKTtcbiAgICB9XG4gICAgY29uc3Qgb25lWWVhciA9IG5ldyBUZW1wb3JhbER1cmF0aW9uKHNpZ24pO1xuICAgIGNvbnN0IG9uZU1vbnRoID0gbmV3IFRlbXBvcmFsRHVyYXRpb24oMCwgc2lnbik7XG4gICAgY29uc3Qgb25lV2VlayA9IG5ldyBUZW1wb3JhbER1cmF0aW9uKDAsIDAsIHNpZ24pO1xuICAgIHN3aXRjaCAobGFyZ2VzdFVuaXQpIHtcbiAgICAgICAgY2FzZSAneWVhcic6IHtcbiAgICAgICAgICAgIGlmICghY2FsZW5kYXIpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2Egc3RhcnRpbmcgcG9pbnQgaXMgcmVxdWlyZWQgZm9yIHllYXJzIGJhbGFuY2luZycpO1xuICAgICAgICAgICAgLy8gYmFsYW5jZSBkYXlzIHVwIHRvIHllYXJzXG4gICAgICAgICAgICBsZXQgbmV3UmVsYXRpdmVUbywgb25lWWVhckRheXM7XG4gICAgICAgICAgICAoeyByZWxhdGl2ZVRvOiBuZXdSZWxhdGl2ZVRvLCBkYXlzOiBvbmVZZWFyRGF5cyB9ID0gTW92ZVJlbGF0aXZlRGF0ZShjYWxlbmRhciwgcmVsYXRpdmVUbywgb25lWWVhcikpO1xuICAgICAgICAgICAgd2hpbGUgKE1hdGhBYnMoZGF5cykgPj0gTWF0aEFicyhvbmVZZWFyRGF5cykpIHtcbiAgICAgICAgICAgICAgICBkYXlzIC09IG9uZVllYXJEYXlzO1xuICAgICAgICAgICAgICAgIHllYXJzICs9IHNpZ247XG4gICAgICAgICAgICAgICAgcmVsYXRpdmVUbyA9IG5ld1JlbGF0aXZlVG87XG4gICAgICAgICAgICAgICAgKHsgcmVsYXRpdmVUbzogbmV3UmVsYXRpdmVUbywgZGF5czogb25lWWVhckRheXMgfSA9IE1vdmVSZWxhdGl2ZURhdGUoY2FsZW5kYXIsIHJlbGF0aXZlVG8sIG9uZVllYXIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGJhbGFuY2UgZGF5cyB1cCB0byBtb250aHNcbiAgICAgICAgICAgIGxldCBvbmVNb250aERheXM7XG4gICAgICAgICAgICAoeyByZWxhdGl2ZVRvOiBuZXdSZWxhdGl2ZVRvLCBkYXlzOiBvbmVNb250aERheXMgfSA9IE1vdmVSZWxhdGl2ZURhdGUoY2FsZW5kYXIsIHJlbGF0aXZlVG8sIG9uZU1vbnRoKSk7XG4gICAgICAgICAgICB3aGlsZSAoTWF0aEFicyhkYXlzKSA+PSBNYXRoQWJzKG9uZU1vbnRoRGF5cykpIHtcbiAgICAgICAgICAgICAgICBkYXlzIC09IG9uZU1vbnRoRGF5cztcbiAgICAgICAgICAgICAgICBtb250aHMgKz0gc2lnbjtcbiAgICAgICAgICAgICAgICByZWxhdGl2ZVRvID0gbmV3UmVsYXRpdmVUbztcbiAgICAgICAgICAgICAgICAoeyByZWxhdGl2ZVRvOiBuZXdSZWxhdGl2ZVRvLCBkYXlzOiBvbmVNb250aERheXMgfSA9IE1vdmVSZWxhdGl2ZURhdGUoY2FsZW5kYXIsIHJlbGF0aXZlVG8sIG9uZU1vbnRoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBiYWxhbmNlIG1vbnRocyB1cCB0byB5ZWFyc1xuICAgICAgICAgICAgY29uc3QgZGF0ZUFkZCA9IGNhbGVuZGFyLmRhdGVBZGQ7XG4gICAgICAgICAgICBjb25zdCBhZGRPcHRpb25zID0gT2JqZWN0Q3JlYXRlJDIobnVsbCk7XG4gICAgICAgICAgICBuZXdSZWxhdGl2ZVRvID0gQ2FsZW5kYXJEYXRlQWRkKGNhbGVuZGFyLCByZWxhdGl2ZVRvLCBvbmVZZWFyLCBhZGRPcHRpb25zLCBkYXRlQWRkKTtcbiAgICAgICAgICAgIGNvbnN0IGRhdGVVbnRpbCA9IGNhbGVuZGFyLmRhdGVVbnRpbDtcbiAgICAgICAgICAgIGNvbnN0IHVudGlsT3B0aW9ucyA9IE9iamVjdENyZWF0ZSQyKG51bGwpO1xuICAgICAgICAgICAgdW50aWxPcHRpb25zLmxhcmdlc3RVbml0ID0gJ21vbnRoJztcbiAgICAgICAgICAgIGxldCB1bnRpbFJlc3VsdCA9IENhbGVuZGFyRGF0ZVVudGlsKGNhbGVuZGFyLCByZWxhdGl2ZVRvLCBuZXdSZWxhdGl2ZVRvLCB1bnRpbE9wdGlvbnMsIGRhdGVVbnRpbCk7XG4gICAgICAgICAgICBsZXQgb25lWWVhck1vbnRocyA9IEdldFNsb3QodW50aWxSZXN1bHQsIE1PTlRIUyk7XG4gICAgICAgICAgICB3aGlsZSAoTWF0aEFicyhtb250aHMpID49IE1hdGhBYnMob25lWWVhck1vbnRocykpIHtcbiAgICAgICAgICAgICAgICBtb250aHMgLT0gb25lWWVhck1vbnRocztcbiAgICAgICAgICAgICAgICB5ZWFycyArPSBzaWduO1xuICAgICAgICAgICAgICAgIHJlbGF0aXZlVG8gPSBuZXdSZWxhdGl2ZVRvO1xuICAgICAgICAgICAgICAgIGNvbnN0IGFkZE9wdGlvbnMgPSBPYmplY3RDcmVhdGUkMihudWxsKTtcbiAgICAgICAgICAgICAgICBuZXdSZWxhdGl2ZVRvID0gQ2FsZW5kYXJEYXRlQWRkKGNhbGVuZGFyLCByZWxhdGl2ZVRvLCBvbmVZZWFyLCBhZGRPcHRpb25zLCBkYXRlQWRkKTtcbiAgICAgICAgICAgICAgICBjb25zdCB1bnRpbE9wdGlvbnMgPSBPYmplY3RDcmVhdGUkMihudWxsKTtcbiAgICAgICAgICAgICAgICB1bnRpbE9wdGlvbnMubGFyZ2VzdFVuaXQgPSAnbW9udGgnO1xuICAgICAgICAgICAgICAgIHVudGlsUmVzdWx0ID0gQ2FsZW5kYXJEYXRlVW50aWwoY2FsZW5kYXIsIHJlbGF0aXZlVG8sIG5ld1JlbGF0aXZlVG8sIHVudGlsT3B0aW9ucywgZGF0ZVVudGlsKTtcbiAgICAgICAgICAgICAgICBvbmVZZWFyTW9udGhzID0gR2V0U2xvdCh1bnRpbFJlc3VsdCwgTU9OVEhTKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ21vbnRoJzoge1xuICAgICAgICAgICAgaWYgKCFjYWxlbmRhcilcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignYSBzdGFydGluZyBwb2ludCBpcyByZXF1aXJlZCBmb3IgbW9udGhzIGJhbGFuY2luZycpO1xuICAgICAgICAgICAgLy8gYmFsYW5jZSBkYXlzIHVwIHRvIG1vbnRoc1xuICAgICAgICAgICAgbGV0IG5ld1JlbGF0aXZlVG8sIG9uZU1vbnRoRGF5cztcbiAgICAgICAgICAgICh7IHJlbGF0aXZlVG86IG5ld1JlbGF0aXZlVG8sIGRheXM6IG9uZU1vbnRoRGF5cyB9ID0gTW92ZVJlbGF0aXZlRGF0ZShjYWxlbmRhciwgcmVsYXRpdmVUbywgb25lTW9udGgpKTtcbiAgICAgICAgICAgIHdoaWxlIChNYXRoQWJzKGRheXMpID49IE1hdGhBYnMob25lTW9udGhEYXlzKSkge1xuICAgICAgICAgICAgICAgIGRheXMgLT0gb25lTW9udGhEYXlzO1xuICAgICAgICAgICAgICAgIG1vbnRocyArPSBzaWduO1xuICAgICAgICAgICAgICAgIHJlbGF0aXZlVG8gPSBuZXdSZWxhdGl2ZVRvO1xuICAgICAgICAgICAgICAgICh7IHJlbGF0aXZlVG86IG5ld1JlbGF0aXZlVG8sIGRheXM6IG9uZU1vbnRoRGF5cyB9ID0gTW92ZVJlbGF0aXZlRGF0ZShjYWxlbmRhciwgcmVsYXRpdmVUbywgb25lTW9udGgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ3dlZWsnOiB7XG4gICAgICAgICAgICBpZiAoIWNhbGVuZGFyKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdhIHN0YXJ0aW5nIHBvaW50IGlzIHJlcXVpcmVkIGZvciB3ZWVrcyBiYWxhbmNpbmcnKTtcbiAgICAgICAgICAgIC8vIGJhbGFuY2UgZGF5cyB1cCB0byB3ZWVrc1xuICAgICAgICAgICAgbGV0IG5ld1JlbGF0aXZlVG8sIG9uZVdlZWtEYXlzO1xuICAgICAgICAgICAgKHsgcmVsYXRpdmVUbzogbmV3UmVsYXRpdmVUbywgZGF5czogb25lV2Vla0RheXMgfSA9IE1vdmVSZWxhdGl2ZURhdGUoY2FsZW5kYXIsIHJlbGF0aXZlVG8sIG9uZVdlZWspKTtcbiAgICAgICAgICAgIHdoaWxlIChNYXRoQWJzKGRheXMpID49IE1hdGhBYnMob25lV2Vla0RheXMpKSB7XG4gICAgICAgICAgICAgICAgZGF5cyAtPSBvbmVXZWVrRGF5cztcbiAgICAgICAgICAgICAgICB3ZWVrcyArPSBzaWduO1xuICAgICAgICAgICAgICAgIHJlbGF0aXZlVG8gPSBuZXdSZWxhdGl2ZVRvO1xuICAgICAgICAgICAgICAgICh7IHJlbGF0aXZlVG86IG5ld1JlbGF0aXZlVG8sIGRheXM6IG9uZVdlZWtEYXlzIH0gPSBNb3ZlUmVsYXRpdmVEYXRlKGNhbGVuZGFyLCByZWxhdGl2ZVRvLCBvbmVXZWVrKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyB5ZWFycywgbW9udGhzLCB3ZWVrcywgZGF5cyB9O1xufVxuZnVuY3Rpb24gQ2FsY3VsYXRlT2Zmc2V0U2hpZnQocmVsYXRpdmVUbywgeSwgbW9uLCB3LCBkLCBoLCBtaW4sIHMsIG1zLCDCtXMsIG5zKSB7XG4gICAgaWYgKElzVGVtcG9yYWxab25lZERhdGVUaW1lKHJlbGF0aXZlVG8pKSB7XG4gICAgICAgIGNvbnN0IGluc3RhbnQgPSBHZXRTbG90KHJlbGF0aXZlVG8sIElOU1RBTlQpO1xuICAgICAgICBjb25zdCB0aW1lWm9uZSA9IEdldFNsb3QocmVsYXRpdmVUbywgVElNRV9aT05FKTtcbiAgICAgICAgY29uc3QgY2FsZW5kYXIgPSBHZXRTbG90KHJlbGF0aXZlVG8sIENBTEVOREFSKTtcbiAgICAgICAgY29uc3Qgb2Zmc2V0QmVmb3JlID0gR2V0T2Zmc2V0TmFub3NlY29uZHNGb3IodGltZVpvbmUsIGluc3RhbnQpO1xuICAgICAgICBjb25zdCBhZnRlciA9IEFkZFpvbmVkRGF0ZVRpbWUoaW5zdGFudCwgdGltZVpvbmUsIGNhbGVuZGFyLCB5LCBtb24sIHcsIGQsIGgsIG1pbiwgcywgbXMsIMK1cywgbnMpO1xuICAgICAgICBjb25zdCBUZW1wb3JhbEluc3RhbnQgPSBHZXRJbnRyaW5zaWMoJyVUZW1wb3JhbC5JbnN0YW50JScpO1xuICAgICAgICBjb25zdCBpbnN0YW50QWZ0ZXIgPSBuZXcgVGVtcG9yYWxJbnN0YW50KGFmdGVyKTtcbiAgICAgICAgY29uc3Qgb2Zmc2V0QWZ0ZXIgPSBHZXRPZmZzZXROYW5vc2Vjb25kc0Zvcih0aW1lWm9uZSwgaW5zdGFudEFmdGVyKTtcbiAgICAgICAgcmV0dXJuIG9mZnNldEFmdGVyIC0gb2Zmc2V0QmVmb3JlO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbn1cbmZ1bmN0aW9uIENyZWF0ZU5lZ2F0ZWRUZW1wb3JhbER1cmF0aW9uKGR1cmF0aW9uKSB7XG4gICAgY29uc3QgVGVtcG9yYWxEdXJhdGlvbiA9IEdldEludHJpbnNpYygnJVRlbXBvcmFsLkR1cmF0aW9uJScpO1xuICAgIHJldHVybiBuZXcgVGVtcG9yYWxEdXJhdGlvbigtR2V0U2xvdChkdXJhdGlvbiwgWUVBUlMpLCAtR2V0U2xvdChkdXJhdGlvbiwgTU9OVEhTKSwgLUdldFNsb3QoZHVyYXRpb24sIFdFRUtTKSwgLUdldFNsb3QoZHVyYXRpb24sIERBWVMpLCAtR2V0U2xvdChkdXJhdGlvbiwgSE9VUlMpLCAtR2V0U2xvdChkdXJhdGlvbiwgTUlOVVRFUyksIC1HZXRTbG90KGR1cmF0aW9uLCBTRUNPTkRTKSwgLUdldFNsb3QoZHVyYXRpb24sIE1JTExJU0VDT05EUyksIC1HZXRTbG90KGR1cmF0aW9uLCBNSUNST1NFQ09ORFMpLCAtR2V0U2xvdChkdXJhdGlvbiwgTkFOT1NFQ09ORFMpKTtcbn1cbmZ1bmN0aW9uIENvbnN0cmFpblRvUmFuZ2UodmFsdWUsIG1pbiwgbWF4KSB7XG4gICAgLy8gTWF0aC5NYXggYWNjZXB0cyB1bmRlZmluZWQgdmFsdWVzIGFuZCByZXR1cm5zIE5hTi4gVW5kZWZpbmVkIHZhbHVlcyBhcmVcbiAgICAvLyB1c2VkIGZvciBvcHRpb25hbCBwYXJhbXMgaW4gdGhlIG1ldGhvZCBiZWxvdy5cbiAgICByZXR1cm4gTWF0aE1pbihtYXgsIE1hdGhNYXgobWluLCB2YWx1ZSkpO1xufVxuZnVuY3Rpb24gQ29uc3RyYWluSVNPRGF0ZSh5ZWFyLCBtb250aFBhcmFtLCBkYXlQYXJhbSkge1xuICAgIGNvbnN0IG1vbnRoID0gQ29uc3RyYWluVG9SYW5nZShtb250aFBhcmFtLCAxLCAxMik7XG4gICAgY29uc3QgZGF5ID0gQ29uc3RyYWluVG9SYW5nZShkYXlQYXJhbSwgMSwgSVNPRGF5c0luTW9udGgoeWVhciwgbW9udGgpKTtcbiAgICByZXR1cm4geyB5ZWFyLCBtb250aCwgZGF5IH07XG59XG5mdW5jdGlvbiBDb25zdHJhaW5UaW1lKGhvdXJQYXJhbSwgbWludXRlUGFyYW0sIHNlY29uZFBhcmFtLCBtaWxsaXNlY29uZFBhcmFtLCBtaWNyb3NlY29uZFBhcmFtLCBuYW5vc2Vjb25kUGFyYW0pIHtcbiAgICBjb25zdCBob3VyID0gQ29uc3RyYWluVG9SYW5nZShob3VyUGFyYW0sIDAsIDIzKTtcbiAgICBjb25zdCBtaW51dGUgPSBDb25zdHJhaW5Ub1JhbmdlKG1pbnV0ZVBhcmFtLCAwLCA1OSk7XG4gICAgY29uc3Qgc2Vjb25kID0gQ29uc3RyYWluVG9SYW5nZShzZWNvbmRQYXJhbSwgMCwgNTkpO1xuICAgIGNvbnN0IG1pbGxpc2Vjb25kID0gQ29uc3RyYWluVG9SYW5nZShtaWxsaXNlY29uZFBhcmFtLCAwLCA5OTkpO1xuICAgIGNvbnN0IG1pY3Jvc2Vjb25kID0gQ29uc3RyYWluVG9SYW5nZShtaWNyb3NlY29uZFBhcmFtLCAwLCA5OTkpO1xuICAgIGNvbnN0IG5hbm9zZWNvbmQgPSBDb25zdHJhaW5Ub1JhbmdlKG5hbm9zZWNvbmRQYXJhbSwgMCwgOTk5KTtcbiAgICByZXR1cm4geyBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQsIG1pY3Jvc2Vjb25kLCBuYW5vc2Vjb25kIH07XG59XG5mdW5jdGlvbiBSZWplY3RUb1JhbmdlKHZhbHVlLCBtaW4sIG1heCkge1xuICAgIGlmICh2YWx1ZSA8IG1pbiB8fCB2YWx1ZSA+IG1heClcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYHZhbHVlIG91dCBvZiByYW5nZTogJHttaW59IDw9ICR7dmFsdWV9IDw9ICR7bWF4fWApO1xufVxuZnVuY3Rpb24gUmVqZWN0SVNPRGF0ZSh5ZWFyLCBtb250aCwgZGF5KSB7XG4gICAgUmVqZWN0VG9SYW5nZShtb250aCwgMSwgMTIpO1xuICAgIFJlamVjdFRvUmFuZ2UoZGF5LCAxLCBJU09EYXlzSW5Nb250aCh5ZWFyLCBtb250aCkpO1xufVxuZnVuY3Rpb24gUmVqZWN0RGF0ZVJhbmdlKHllYXIsIG1vbnRoLCBkYXkpIHtcbiAgICAvLyBOb29uIGF2b2lkcyB0cm91YmxlIGF0IGVkZ2VzIG9mIERhdGVUaW1lIHJhbmdlIChleGNsdWRlcyBtaWRuaWdodClcbiAgICBSZWplY3REYXRlVGltZVJhbmdlKHllYXIsIG1vbnRoLCBkYXksIDEyLCAwLCAwLCAwLCAwLCAwKTtcbn1cbmZ1bmN0aW9uIFJlamVjdFRpbWUoaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kLCBtaWNyb3NlY29uZCwgbmFub3NlY29uZCkge1xuICAgIFJlamVjdFRvUmFuZ2UoaG91ciwgMCwgMjMpO1xuICAgIFJlamVjdFRvUmFuZ2UobWludXRlLCAwLCA1OSk7XG4gICAgUmVqZWN0VG9SYW5nZShzZWNvbmQsIDAsIDU5KTtcbiAgICBSZWplY3RUb1JhbmdlKG1pbGxpc2Vjb25kLCAwLCA5OTkpO1xuICAgIFJlamVjdFRvUmFuZ2UobWljcm9zZWNvbmQsIDAsIDk5OSk7XG4gICAgUmVqZWN0VG9SYW5nZShuYW5vc2Vjb25kLCAwLCA5OTkpO1xufVxuZnVuY3Rpb24gUmVqZWN0RGF0ZVRpbWUoeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kLCBtaWNyb3NlY29uZCwgbmFub3NlY29uZCkge1xuICAgIFJlamVjdElTT0RhdGUoeWVhciwgbW9udGgsIGRheSk7XG4gICAgUmVqZWN0VGltZShob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQsIG1pY3Jvc2Vjb25kLCBuYW5vc2Vjb25kKTtcbn1cbmZ1bmN0aW9uIFJlamVjdERhdGVUaW1lUmFuZ2UoeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kLCBtaWNyb3NlY29uZCwgbmFub3NlY29uZCkge1xuICAgIFJlamVjdFRvUmFuZ2UoeWVhciwgWUVBUl9NSU4sIFlFQVJfTUFYKTtcbiAgICAvLyBSZWplY3QgYW55IERhdGVUaW1lIDI0IGhvdXJzIG9yIG1vcmUgb3V0c2lkZSB0aGUgSW5zdGFudCByYW5nZVxuICAgIGlmICgoeWVhciA9PT0gWUVBUl9NSU4gJiZcbiAgICAgICAgbnVsbCA9PVxuICAgICAgICAgICAgR2V0RXBvY2hGcm9tSVNPUGFydHMoeWVhciwgbW9udGgsIGRheSArIDEsIGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZCwgbWljcm9zZWNvbmQsIG5hbm9zZWNvbmQgLSAxKSkgfHxcbiAgICAgICAgKHllYXIgPT09IFlFQVJfTUFYICYmXG4gICAgICAgICAgICBudWxsID09XG4gICAgICAgICAgICAgICAgR2V0RXBvY2hGcm9tSVNPUGFydHMoeWVhciwgbW9udGgsIGRheSAtIDEsIGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZCwgbWljcm9zZWNvbmQsIG5hbm9zZWNvbmQgKyAxKSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0RhdGVUaW1lIG91dHNpZGUgb2Ygc3VwcG9ydGVkIHJhbmdlJyk7XG4gICAgfVxufVxuZnVuY3Rpb24gVmFsaWRhdGVFcG9jaE5hbm9zZWNvbmRzKGVwb2NoTmFub3NlY29uZHMpIHtcbiAgICBpZiAoSlNCSS5sZXNzVGhhbihlcG9jaE5hbm9zZWNvbmRzLCBOU19NSU4pIHx8IEpTQkkuZ3JlYXRlclRoYW4oZXBvY2hOYW5vc2Vjb25kcywgTlNfTUFYKSkge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5zdGFudCBvdXRzaWRlIG9mIHN1cHBvcnRlZCByYW5nZScpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIFJlamVjdFllYXJNb250aFJhbmdlKHllYXIsIG1vbnRoKSB7XG4gICAgUmVqZWN0VG9SYW5nZSh5ZWFyLCBZRUFSX01JTiwgWUVBUl9NQVgpO1xuICAgIGlmICh5ZWFyID09PSBZRUFSX01JTikge1xuICAgICAgICBSZWplY3RUb1JhbmdlKG1vbnRoLCA0LCAxMik7XG4gICAgfVxuICAgIGVsc2UgaWYgKHllYXIgPT09IFlFQVJfTUFYKSB7XG4gICAgICAgIFJlamVjdFRvUmFuZ2UobW9udGgsIDEsIDkpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIFJlamVjdER1cmF0aW9uKHksIG1vbiwgdywgZCwgaCwgbWluLCBzLCBtcywgwrVzLCBucykge1xuICAgIGNvbnN0IHNpZ24gPSBEdXJhdGlvblNpZ24oeSwgbW9uLCB3LCBkLCBoLCBtaW4sIHMsIG1zLCDCtXMsIG5zKTtcbiAgICBmb3IgKGNvbnN0IHByb3Agb2YgW3ksIG1vbiwgdywgZCwgaCwgbWluLCBzLCBtcywgwrVzLCBuc10pIHtcbiAgICAgICAgaWYgKCFOdW1iZXJJc0Zpbml0ZShwcm9wKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdpbmZpbml0ZSB2YWx1ZXMgbm90IGFsbG93ZWQgYXMgZHVyYXRpb24gZmllbGRzJyk7XG4gICAgICAgIGNvbnN0IHByb3BTaWduID0gTWF0aFNpZ24ocHJvcCk7XG4gICAgICAgIGlmIChwcm9wU2lnbiAhPT0gMCAmJiBwcm9wU2lnbiAhPT0gc2lnbilcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdtaXhlZC1zaWduIHZhbHVlcyBub3QgYWxsb3dlZCBhcyBkdXJhdGlvbiBmaWVsZHMnKTtcbiAgICB9XG59XG5mdW5jdGlvbiBEaWZmZXJlbmNlSVNPRGF0ZSh5MSwgbTEsIGQxLCB5MiwgbTIsIGQyLCBsYXJnZXN0VW5pdCkge1xuICAgIHN3aXRjaCAobGFyZ2VzdFVuaXQpIHtcbiAgICAgICAgY2FzZSAneWVhcic6XG4gICAgICAgIGNhc2UgJ21vbnRoJzoge1xuICAgICAgICAgICAgY29uc3Qgc2lnbiA9IC1Db21wYXJlSVNPRGF0ZSh5MSwgbTEsIGQxLCB5MiwgbTIsIGQyKTtcbiAgICAgICAgICAgIGlmIChzaWduID09PSAwKVxuICAgICAgICAgICAgICAgIHJldHVybiB7IHllYXJzOiAwLCBtb250aHM6IDAsIHdlZWtzOiAwLCBkYXlzOiAwIH07XG4gICAgICAgICAgICBjb25zdCBzdGFydCA9IHsgeWVhcjogeTEsIG1vbnRoOiBtMSwgZGF5OiBkMSB9O1xuICAgICAgICAgICAgY29uc3QgZW5kID0geyB5ZWFyOiB5MiwgbW9udGg6IG0yLCBkYXk6IGQyIH07XG4gICAgICAgICAgICBsZXQgeWVhcnMgPSBlbmQueWVhciAtIHN0YXJ0LnllYXI7XG4gICAgICAgICAgICBsZXQgbWlkID0gQWRkSVNPRGF0ZSh5MSwgbTEsIGQxLCB5ZWFycywgMCwgMCwgMCwgJ2NvbnN0cmFpbicpO1xuICAgICAgICAgICAgbGV0IG1pZFNpZ24gPSAtQ29tcGFyZUlTT0RhdGUobWlkLnllYXIsIG1pZC5tb250aCwgbWlkLmRheSwgeTIsIG0yLCBkMik7XG4gICAgICAgICAgICBpZiAobWlkU2lnbiA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBsYXJnZXN0VW5pdCA9PT0gJ3llYXInXG4gICAgICAgICAgICAgICAgICAgID8geyB5ZWFycywgbW9udGhzOiAwLCB3ZWVrczogMCwgZGF5czogMCB9XG4gICAgICAgICAgICAgICAgICAgIDogeyB5ZWFyczogMCwgbW9udGhzOiB5ZWFycyAqIDEyLCB3ZWVrczogMCwgZGF5czogMCB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IG1vbnRocyA9IGVuZC5tb250aCAtIHN0YXJ0Lm1vbnRoO1xuICAgICAgICAgICAgaWYgKG1pZFNpZ24gIT09IHNpZ24pIHtcbiAgICAgICAgICAgICAgICB5ZWFycyAtPSBzaWduO1xuICAgICAgICAgICAgICAgIG1vbnRocyArPSBzaWduICogMTI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtaWQgPSBBZGRJU09EYXRlKHkxLCBtMSwgZDEsIHllYXJzLCBtb250aHMsIDAsIDAsICdjb25zdHJhaW4nKTtcbiAgICAgICAgICAgIG1pZFNpZ24gPSAtQ29tcGFyZUlTT0RhdGUobWlkLnllYXIsIG1pZC5tb250aCwgbWlkLmRheSwgeTIsIG0yLCBkMik7XG4gICAgICAgICAgICBpZiAobWlkU2lnbiA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBsYXJnZXN0VW5pdCA9PT0gJ3llYXInXG4gICAgICAgICAgICAgICAgICAgID8geyB5ZWFycywgbW9udGhzLCB3ZWVrczogMCwgZGF5czogMCB9XG4gICAgICAgICAgICAgICAgICAgIDogeyB5ZWFyczogMCwgbW9udGhzOiBtb250aHMgKyB5ZWFycyAqIDEyLCB3ZWVrczogMCwgZGF5czogMCB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1pZFNpZ24gIT09IHNpZ24pIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgZW5kIGRhdGUgaXMgbGF0ZXIgaW4gdGhlIG1vbnRoIHRoYW4gbWlkIGRhdGUgKG9yIGVhcmxpZXIgZm9yXG4gICAgICAgICAgICAgICAgLy8gbmVnYXRpdmUgZHVyYXRpb25zKS4gQmFjayB1cCBvbmUgbW9udGguXG4gICAgICAgICAgICAgICAgbW9udGhzIC09IHNpZ247XG4gICAgICAgICAgICAgICAgaWYgKG1vbnRocyA9PT0gLXNpZ24pIHtcbiAgICAgICAgICAgICAgICAgICAgeWVhcnMgLT0gc2lnbjtcbiAgICAgICAgICAgICAgICAgICAgbW9udGhzID0gMTEgKiBzaWduO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtaWQgPSBBZGRJU09EYXRlKHkxLCBtMSwgZDEsIHllYXJzLCBtb250aHMsIDAsIDAsICdjb25zdHJhaW4nKTtcbiAgICAgICAgICAgICAgICBtaWRTaWduID0gLUNvbXBhcmVJU09EYXRlKHkxLCBtMSwgZDEsIG1pZC55ZWFyLCBtaWQubW9udGgsIG1pZC5kYXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGRheXMgPSAwO1xuICAgICAgICAgICAgLy8gSWYgd2UgZ2V0IGhlcmUsIG1vbnRocyBhbmQgeWVhcnMgYXJlIGNvcnJlY3QgKG5vIG92ZXJmbG93KSwgYW5kIGBtaWRgXG4gICAgICAgICAgICAvLyBpcyB3aXRoaW4gdGhlIHJhbmdlIGZyb20gYHN0YXJ0YCB0byBgZW5kYC4gVG8gY291bnQgdGhlIGRheXMgYmV0d2VlblxuICAgICAgICAgICAgLy8gYG1pZGAgYW5kIGBlbmRgLCB0aGVyZSBhcmUgMyBjYXNlczpcbiAgICAgICAgICAgIC8vIDEpIHNhbWUgbW9udGg6IHVzZSBzaW1wbGUgc3VidHJhY3Rpb25cbiAgICAgICAgICAgIC8vIDIpIGVuZCBpcyBwcmV2aW91cyBtb250aCBmcm9tIGludGVybWVkaWF0ZSAobmVnYXRpdmUgZHVyYXRpb24pXG4gICAgICAgICAgICAvLyAzKSBlbmQgaXMgbmV4dCBtb250aCBmcm9tIGludGVybWVkaWF0ZSAocG9zaXRpdmUgZHVyYXRpb24pXG4gICAgICAgICAgICBpZiAobWlkLm1vbnRoID09PSBlbmQubW9udGgpIHtcbiAgICAgICAgICAgICAgICAvLyAxKSBzYW1lIG1vbnRoOiB1c2Ugc2ltcGxlIHN1YnRyYWN0aW9uXG4gICAgICAgICAgICAgICAgZGF5cyA9IGVuZC5kYXkgLSBtaWQuZGF5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc2lnbiA8IDApIHtcbiAgICAgICAgICAgICAgICAvLyAyKSBlbmQgaXMgcHJldmlvdXMgbW9udGggZnJvbSBpbnRlcm1lZGlhdGUgKG5lZ2F0aXZlIGR1cmF0aW9uKVxuICAgICAgICAgICAgICAgIC8vIEV4YW1wbGU6IGludGVybWVkaWF0ZTogRmViIDEsIGVuZDogSmFuIDMwLCBEYXlzSW5Nb250aCA9IDMxLCBkYXlzID0gLTJcbiAgICAgICAgICAgICAgICBkYXlzID0gLW1pZC5kYXkgLSAoSVNPRGF5c0luTW9udGgoZW5kLnllYXIsIGVuZC5tb250aCkgLSBlbmQuZGF5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIDMpIGVuZCBpcyBuZXh0IG1vbnRoIGZyb20gaW50ZXJtZWRpYXRlIChwb3NpdGl2ZSBkdXJhdGlvbilcbiAgICAgICAgICAgICAgICAvLyBFeGFtcGxlOiBpbnRlcm1lZGlhdGU6IEphbiAyOSwgZW5kOiBGZWIgMSwgRGF5c0luTW9udGggPSAzMSwgZGF5cyA9IDNcbiAgICAgICAgICAgICAgICBkYXlzID0gZW5kLmRheSArIChJU09EYXlzSW5Nb250aChtaWQueWVhciwgbWlkLm1vbnRoKSAtIG1pZC5kYXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxhcmdlc3RVbml0ID09PSAnbW9udGgnKSB7XG4gICAgICAgICAgICAgICAgbW9udGhzICs9IHllYXJzICogMTI7XG4gICAgICAgICAgICAgICAgeWVhcnMgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHsgeWVhcnMsIG1vbnRocywgd2Vla3M6IDAsIGRheXMgfTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlICd3ZWVrJzpcbiAgICAgICAgY2FzZSAnZGF5Jzoge1xuICAgICAgICAgICAgbGV0IGxhcmdlciwgc21hbGxlciwgc2lnbjtcbiAgICAgICAgICAgIGlmIChDb21wYXJlSVNPRGF0ZSh5MSwgbTEsIGQxLCB5MiwgbTIsIGQyKSA8IDApIHtcbiAgICAgICAgICAgICAgICBzbWFsbGVyID0geyB5ZWFyOiB5MSwgbW9udGg6IG0xLCBkYXk6IGQxIH07XG4gICAgICAgICAgICAgICAgbGFyZ2VyID0geyB5ZWFyOiB5MiwgbW9udGg6IG0yLCBkYXk6IGQyIH07XG4gICAgICAgICAgICAgICAgc2lnbiA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzbWFsbGVyID0geyB5ZWFyOiB5MiwgbW9udGg6IG0yLCBkYXk6IGQyIH07XG4gICAgICAgICAgICAgICAgbGFyZ2VyID0geyB5ZWFyOiB5MSwgbW9udGg6IG0xLCBkYXk6IGQxIH07XG4gICAgICAgICAgICAgICAgc2lnbiA9IC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGRheXMgPSBEYXlPZlllYXIobGFyZ2VyLnllYXIsIGxhcmdlci5tb250aCwgbGFyZ2VyLmRheSkgLSBEYXlPZlllYXIoc21hbGxlci55ZWFyLCBzbWFsbGVyLm1vbnRoLCBzbWFsbGVyLmRheSk7XG4gICAgICAgICAgICBmb3IgKGxldCB5ZWFyID0gc21hbGxlci55ZWFyOyB5ZWFyIDwgbGFyZ2VyLnllYXI7ICsreWVhcikge1xuICAgICAgICAgICAgICAgIGRheXMgKz0gTGVhcFllYXIoeWVhcikgPyAzNjYgOiAzNjU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgd2Vla3MgPSAwO1xuICAgICAgICAgICAgaWYgKGxhcmdlc3RVbml0ID09PSAnd2VlaycpIHtcbiAgICAgICAgICAgICAgICB3ZWVrcyA9IE1hdGhGbG9vcihkYXlzIC8gNyk7XG4gICAgICAgICAgICAgICAgZGF5cyAlPSA3O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2Vla3MgKj0gc2lnbjtcbiAgICAgICAgICAgIGRheXMgKj0gc2lnbjtcbiAgICAgICAgICAgIHJldHVybiB7IHllYXJzOiAwLCBtb250aHM6IDAsIHdlZWtzLCBkYXlzIH07XG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYXNzZXJ0IG5vdCByZWFjaGVkJyk7XG4gICAgfVxufVxuZnVuY3Rpb24gRGlmZmVyZW5jZVRpbWUoaDEsIG1pbjEsIHMxLCBtczEsIMK1czEsIG5zMSwgaDIsIG1pbjIsIHMyLCBtczIsIMK1czIsIG5zMikge1xuICAgIGxldCBob3VycyA9IGgyIC0gaDE7XG4gICAgbGV0IG1pbnV0ZXMgPSBtaW4yIC0gbWluMTtcbiAgICBsZXQgc2Vjb25kcyA9IHMyIC0gczE7XG4gICAgbGV0IG1pbGxpc2Vjb25kcyA9IG1zMiAtIG1zMTtcbiAgICBsZXQgbWljcm9zZWNvbmRzID0gwrVzMiAtIMK1czE7XG4gICAgbGV0IG5hbm9zZWNvbmRzID0gbnMyIC0gbnMxO1xuICAgIGNvbnN0IHNpZ24gPSBEdXJhdGlvblNpZ24oMCwgMCwgMCwgMCwgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc2Vjb25kcywgbWljcm9zZWNvbmRzLCBuYW5vc2Vjb25kcyk7XG4gICAgaG91cnMgKj0gc2lnbjtcbiAgICBtaW51dGVzICo9IHNpZ247XG4gICAgc2Vjb25kcyAqPSBzaWduO1xuICAgIG1pbGxpc2Vjb25kcyAqPSBzaWduO1xuICAgIG1pY3Jvc2Vjb25kcyAqPSBzaWduO1xuICAgIG5hbm9zZWNvbmRzICo9IHNpZ247XG4gICAgbGV0IGRlbHRhRGF5cyA9IDA7XG4gICAgKHtcbiAgICAgICAgZGVsdGFEYXlzLFxuICAgICAgICBob3VyOiBob3VycyxcbiAgICAgICAgbWludXRlOiBtaW51dGVzLFxuICAgICAgICBzZWNvbmQ6IHNlY29uZHMsXG4gICAgICAgIG1pbGxpc2Vjb25kOiBtaWxsaXNlY29uZHMsXG4gICAgICAgIG1pY3Jvc2Vjb25kOiBtaWNyb3NlY29uZHMsXG4gICAgICAgIG5hbm9zZWNvbmQ6IG5hbm9zZWNvbmRzXG4gICAgfSA9IEJhbGFuY2VUaW1lKGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBtaWxsaXNlY29uZHMsIG1pY3Jvc2Vjb25kcywgbmFub3NlY29uZHMpKTtcbiAgICBkZWx0YURheXMgKj0gc2lnbjtcbiAgICBob3VycyAqPSBzaWduO1xuICAgIG1pbnV0ZXMgKj0gc2lnbjtcbiAgICBzZWNvbmRzICo9IHNpZ247XG4gICAgbWlsbGlzZWNvbmRzICo9IHNpZ247XG4gICAgbWljcm9zZWNvbmRzICo9IHNpZ247XG4gICAgbmFub3NlY29uZHMgKj0gc2lnbjtcbiAgICByZXR1cm4geyBkZWx0YURheXMsIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBtaWxsaXNlY29uZHMsIG1pY3Jvc2Vjb25kcywgbmFub3NlY29uZHMgfTtcbn1cbmZ1bmN0aW9uIERpZmZlcmVuY2VJbnN0YW50KG5zMSwgbnMyLCBpbmNyZW1lbnQsIHVuaXQsIHJvdW5kaW5nTW9kZSkge1xuICAgIGNvbnN0IGRpZmYgPSBKU0JJLnN1YnRyYWN0KG5zMiwgbnMxKTtcbiAgICBjb25zdCByZW1haW5kZXIgPSBKU0JJLnJlbWFpbmRlcihkaWZmLCBKU0JJLkJpZ0ludCg4NjQwMGU5KSk7XG4gICAgY29uc3Qgd2hvbGVEYXlzID0gSlNCSS5zdWJ0cmFjdChkaWZmLCByZW1haW5kZXIpO1xuICAgIGNvbnN0IHJvdW5kZWRSZW1haW5kZXIgPSBSb3VuZE51bWJlclRvSW5jcmVtZW50KHJlbWFpbmRlciwgbnNQZXJUaW1lVW5pdFt1bml0XSAqIGluY3JlbWVudCwgcm91bmRpbmdNb2RlKTtcbiAgICBjb25zdCByb3VuZGVkRGlmZiA9IEpTQkkuYWRkKHdob2xlRGF5cywgcm91bmRlZFJlbWFpbmRlcik7XG4gICAgY29uc3QgbmFub3NlY29uZHMgPSBKU0JJLnRvTnVtYmVyKEpTQkkucmVtYWluZGVyKHJvdW5kZWREaWZmLCBUSE9VU0FORCkpO1xuICAgIGNvbnN0IG1pY3Jvc2Vjb25kcyA9IEpTQkkudG9OdW1iZXIoSlNCSS5yZW1haW5kZXIoSlNCSS5kaXZpZGUocm91bmRlZERpZmYsIFRIT1VTQU5EKSwgVEhPVVNBTkQpKTtcbiAgICBjb25zdCBtaWxsaXNlY29uZHMgPSBKU0JJLnRvTnVtYmVyKEpTQkkucmVtYWluZGVyKEpTQkkuZGl2aWRlKHJvdW5kZWREaWZmLCBNSUxMSU9OKSwgVEhPVVNBTkQpKTtcbiAgICBjb25zdCBzZWNvbmRzID0gSlNCSS50b051bWJlcihKU0JJLmRpdmlkZShyb3VuZGVkRGlmZiwgQklMTElPTikpO1xuICAgIHJldHVybiB7IHNlY29uZHMsIG1pbGxpc2Vjb25kcywgbWljcm9zZWNvbmRzLCBuYW5vc2Vjb25kcyB9O1xufVxuZnVuY3Rpb24gRGlmZmVyZW5jZUlTT0RhdGVUaW1lKHkxUGFyYW0sIG1vbjFQYXJhbSwgZDFQYXJhbSwgaDEsIG1pbjEsIHMxLCBtczEsIMK1czEsIG5zMSwgeTIsIG1vbjIsIGQyLCBoMiwgbWluMiwgczIsIG1zMiwgwrVzMiwgbnMyLCBjYWxlbmRhciwgbGFyZ2VzdFVuaXQsIG9wdGlvbnMgPSBPYmplY3RDcmVhdGUkMihudWxsKSkge1xuICAgIGxldCB5MSA9IHkxUGFyYW07XG4gICAgbGV0IG1vbjEgPSBtb24xUGFyYW07XG4gICAgbGV0IGQxID0gZDFQYXJhbTtcbiAgICBsZXQgeyBkZWx0YURheXMsIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBtaWxsaXNlY29uZHMsIG1pY3Jvc2Vjb25kcywgbmFub3NlY29uZHMgfSA9IERpZmZlcmVuY2VUaW1lKGgxLCBtaW4xLCBzMSwgbXMxLCDCtXMxLCBuczEsIGgyLCBtaW4yLCBzMiwgbXMyLCDCtXMyLCBuczIpO1xuICAgIGNvbnN0IHRpbWVTaWduID0gRHVyYXRpb25TaWduKDAsIDAsIDAsIGRlbHRhRGF5cywgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc2Vjb25kcywgbWljcm9zZWNvbmRzLCBuYW5vc2Vjb25kcyk7XG4gICAgKHsgeWVhcjogeTEsIG1vbnRoOiBtb24xLCBkYXk6IGQxIH0gPSBCYWxhbmNlSVNPRGF0ZSh5MSwgbW9uMSwgZDEgKyBkZWx0YURheXMpKTtcbiAgICBjb25zdCBkYXRlU2lnbiA9IENvbXBhcmVJU09EYXRlKHkyLCBtb24yLCBkMiwgeTEsIG1vbjEsIGQxKTtcbiAgICBpZiAoZGF0ZVNpZ24gPT09IC10aW1lU2lnbikge1xuICAgICAgICAoeyB5ZWFyOiB5MSwgbW9udGg6IG1vbjEsIGRheTogZDEgfSA9IEJhbGFuY2VJU09EYXRlKHkxLCBtb24xLCBkMSAtIHRpbWVTaWduKSk7XG4gICAgICAgICh7IGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBtaWxsaXNlY29uZHMsIG1pY3Jvc2Vjb25kcywgbmFub3NlY29uZHMgfSA9IEJhbGFuY2VEdXJhdGlvbigtdGltZVNpZ24sIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBtaWxsaXNlY29uZHMsIG1pY3Jvc2Vjb25kcywgbmFub3NlY29uZHMsIGxhcmdlc3RVbml0KSk7XG4gICAgfVxuICAgIGNvbnN0IGRhdGUxID0gQ3JlYXRlVGVtcG9yYWxEYXRlKHkxLCBtb24xLCBkMSwgY2FsZW5kYXIpO1xuICAgIGNvbnN0IGRhdGUyID0gQ3JlYXRlVGVtcG9yYWxEYXRlKHkyLCBtb24yLCBkMiwgY2FsZW5kYXIpO1xuICAgIGNvbnN0IGRhdGVMYXJnZXN0VW5pdCA9IExhcmdlck9mVHdvVGVtcG9yYWxVbml0cygnZGF5JywgbGFyZ2VzdFVuaXQpO1xuICAgIGNvbnN0IHVudGlsT3B0aW9ucyA9IHsgLi4ub3B0aW9ucywgbGFyZ2VzdFVuaXQ6IGRhdGVMYXJnZXN0VW5pdCB9O1xuICAgIGxldCB7IHllYXJzLCBtb250aHMsIHdlZWtzLCBkYXlzIH0gPSBDYWxlbmRhckRhdGVVbnRpbChjYWxlbmRhciwgZGF0ZTEsIGRhdGUyLCB1bnRpbE9wdGlvbnMpO1xuICAgIC8vIFNpZ25zIG9mIGRhdGUgcGFydCBhbmQgdGltZSBwYXJ0IG1heSBub3QgYWdyZWU7IGJhbGFuY2UgdGhlbSB0b2dldGhlclxuICAgICh7IGRheXMsIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBtaWxsaXNlY29uZHMsIG1pY3Jvc2Vjb25kcywgbmFub3NlY29uZHMgfSA9IEJhbGFuY2VEdXJhdGlvbihkYXlzLCBob3VycywgbWludXRlcywgc2Vjb25kcywgbWlsbGlzZWNvbmRzLCBtaWNyb3NlY29uZHMsIG5hbm9zZWNvbmRzLCBsYXJnZXN0VW5pdCkpO1xuICAgIHJldHVybiB7IHllYXJzLCBtb250aHMsIHdlZWtzLCBkYXlzLCBob3VycywgbWludXRlcywgc2Vjb25kcywgbWlsbGlzZWNvbmRzLCBtaWNyb3NlY29uZHMsIG5hbm9zZWNvbmRzIH07XG59XG5mdW5jdGlvbiBEaWZmZXJlbmNlWm9uZWREYXRlVGltZShuczEsIG5zMiwgdGltZVpvbmUsIGNhbGVuZGFyLCBsYXJnZXN0VW5pdCwgb3B0aW9ucykge1xuICAgIGNvbnN0IG5zRGlmZiA9IEpTQkkuc3VidHJhY3QobnMyLCBuczEpO1xuICAgIGlmIChKU0JJLmVxdWFsKG5zRGlmZiwgWkVSTykpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHllYXJzOiAwLFxuICAgICAgICAgICAgbW9udGhzOiAwLFxuICAgICAgICAgICAgd2Vla3M6IDAsXG4gICAgICAgICAgICBkYXlzOiAwLFxuICAgICAgICAgICAgaG91cnM6IDAsXG4gICAgICAgICAgICBtaW51dGVzOiAwLFxuICAgICAgICAgICAgc2Vjb25kczogMCxcbiAgICAgICAgICAgIG1pbGxpc2Vjb25kczogMCxcbiAgICAgICAgICAgIG1pY3Jvc2Vjb25kczogMCxcbiAgICAgICAgICAgIG5hbm9zZWNvbmRzOiAwXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIEZpbmQgdGhlIGRpZmZlcmVuY2UgaW4gZGF0ZXMgb25seS5cbiAgICBjb25zdCBUZW1wb3JhbEluc3RhbnQgPSBHZXRJbnRyaW5zaWMoJyVUZW1wb3JhbC5JbnN0YW50JScpO1xuICAgIGNvbnN0IHN0YXJ0ID0gbmV3IFRlbXBvcmFsSW5zdGFudChuczEpO1xuICAgIGNvbnN0IGVuZCA9IG5ldyBUZW1wb3JhbEluc3RhbnQobnMyKTtcbiAgICBjb25zdCBkdFN0YXJ0ID0gQnVpbHRpblRpbWVab25lR2V0UGxhaW5EYXRlVGltZUZvcih0aW1lWm9uZSwgc3RhcnQsIGNhbGVuZGFyKTtcbiAgICBjb25zdCBkdEVuZCA9IEJ1aWx0aW5UaW1lWm9uZUdldFBsYWluRGF0ZVRpbWVGb3IodGltZVpvbmUsIGVuZCwgY2FsZW5kYXIpO1xuICAgIGxldCB7IHllYXJzLCBtb250aHMsIHdlZWtzLCBkYXlzIH0gPSBEaWZmZXJlbmNlSVNPRGF0ZVRpbWUoR2V0U2xvdChkdFN0YXJ0LCBJU09fWUVBUiksIEdldFNsb3QoZHRTdGFydCwgSVNPX01PTlRIKSwgR2V0U2xvdChkdFN0YXJ0LCBJU09fREFZKSwgR2V0U2xvdChkdFN0YXJ0LCBJU09fSE9VUiksIEdldFNsb3QoZHRTdGFydCwgSVNPX01JTlVURSksIEdldFNsb3QoZHRTdGFydCwgSVNPX1NFQ09ORCksIEdldFNsb3QoZHRTdGFydCwgSVNPX01JTExJU0VDT05EKSwgR2V0U2xvdChkdFN0YXJ0LCBJU09fTUlDUk9TRUNPTkQpLCBHZXRTbG90KGR0U3RhcnQsIElTT19OQU5PU0VDT05EKSwgR2V0U2xvdChkdEVuZCwgSVNPX1lFQVIpLCBHZXRTbG90KGR0RW5kLCBJU09fTU9OVEgpLCBHZXRTbG90KGR0RW5kLCBJU09fREFZKSwgR2V0U2xvdChkdEVuZCwgSVNPX0hPVVIpLCBHZXRTbG90KGR0RW5kLCBJU09fTUlOVVRFKSwgR2V0U2xvdChkdEVuZCwgSVNPX1NFQ09ORCksIEdldFNsb3QoZHRFbmQsIElTT19NSUxMSVNFQ09ORCksIEdldFNsb3QoZHRFbmQsIElTT19NSUNST1NFQ09ORCksIEdldFNsb3QoZHRFbmQsIElTT19OQU5PU0VDT05EKSwgY2FsZW5kYXIsIGxhcmdlc3RVbml0LCBvcHRpb25zKTtcbiAgICBjb25zdCBpbnRlcm1lZGlhdGVOcyA9IEFkZFpvbmVkRGF0ZVRpbWUoc3RhcnQsIHRpbWVab25lLCBjYWxlbmRhciwgeWVhcnMsIG1vbnRocywgd2Vla3MsIDAsIDAsIDAsIDAsIDAsIDAsIDApO1xuICAgIC8vIG1heSBkaXNhbWJpZ3VhdGVcbiAgICBsZXQgdGltZVJlbWFpbmRlck5zID0gSlNCSS5zdWJ0cmFjdChuczIsIGludGVybWVkaWF0ZU5zKTtcbiAgICBjb25zdCBpbnRlcm1lZGlhdGUgPSBDcmVhdGVUZW1wb3JhbFpvbmVkRGF0ZVRpbWUoaW50ZXJtZWRpYXRlTnMsIHRpbWVab25lLCBjYWxlbmRhcik7XG4gICAgKHsgbmFub3NlY29uZHM6IHRpbWVSZW1haW5kZXJOcywgZGF5cyB9ID0gTmFub3NlY29uZHNUb0RheXModGltZVJlbWFpbmRlck5zLCBpbnRlcm1lZGlhdGUpKTtcbiAgICAvLyBGaW5hbGx5LCBtZXJnZSB0aGUgZGF0ZSBhbmQgdGltZSBkdXJhdGlvbnMgYW5kIHJldHVybiB0aGUgbWVyZ2VkIHJlc3VsdC5cbiAgICBjb25zdCB7IGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBtaWxsaXNlY29uZHMsIG1pY3Jvc2Vjb25kcywgbmFub3NlY29uZHMgfSA9IEJhbGFuY2VEdXJhdGlvbigwLCAwLCAwLCAwLCAwLCAwLCBKU0JJLnRvTnVtYmVyKHRpbWVSZW1haW5kZXJOcyksICdob3VyJyk7XG4gICAgcmV0dXJuIHsgeWVhcnMsIG1vbnRocywgd2Vla3MsIGRheXMsIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBtaWxsaXNlY29uZHMsIG1pY3Jvc2Vjb25kcywgbmFub3NlY29uZHMgfTtcbn1cbmZ1bmN0aW9uIEFkZElTT0RhdGUoeWVhclBhcmFtLCBtb250aFBhcmFtLCBkYXlQYXJhbSwgeWVhcnNQYXJhbSwgbW9udGhzUGFyYW0sIHdlZWtzUGFyYW0sIGRheXNQYXJhbSwgb3ZlcmZsb3cpIHtcbiAgICBsZXQgeWVhciA9IHllYXJQYXJhbTtcbiAgICBsZXQgbW9udGggPSBtb250aFBhcmFtO1xuICAgIGxldCBkYXkgPSBkYXlQYXJhbTtcbiAgICBsZXQgeWVhcnMgPSB5ZWFyc1BhcmFtO1xuICAgIGxldCBtb250aHMgPSBtb250aHNQYXJhbTtcbiAgICBsZXQgd2Vla3MgPSB3ZWVrc1BhcmFtO1xuICAgIGxldCBkYXlzID0gZGF5c1BhcmFtO1xuICAgIHllYXIgKz0geWVhcnM7XG4gICAgbW9udGggKz0gbW9udGhzO1xuICAgICh7IHllYXIsIG1vbnRoIH0gPSBCYWxhbmNlSVNPWWVhck1vbnRoKHllYXIsIG1vbnRoKSk7XG4gICAgKHsgeWVhciwgbW9udGgsIGRheSB9ID0gUmVndWxhdGVJU09EYXRlKHllYXIsIG1vbnRoLCBkYXksIG92ZXJmbG93KSk7XG4gICAgZGF5cyArPSA3ICogd2Vla3M7XG4gICAgZGF5ICs9IGRheXM7XG4gICAgKHsgeWVhciwgbW9udGgsIGRheSB9ID0gQmFsYW5jZUlTT0RhdGUoeWVhciwgbW9udGgsIGRheSkpO1xuICAgIHJldHVybiB7IHllYXIsIG1vbnRoLCBkYXkgfTtcbn1cbmZ1bmN0aW9uIEFkZFRpbWUoaG91clBhcmFtLCBtaW51dGVQYXJhbSwgc2Vjb25kUGFyYW0sIG1pbGxpc2Vjb25kUGFyYW0sIG1pY3Jvc2Vjb25kUGFyYW0sIG5hbm9zZWNvbmRQYXJhbSwgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc2Vjb25kcywgbWljcm9zZWNvbmRzLCBuYW5vc2Vjb25kcykge1xuICAgIGxldCBob3VyID0gaG91clBhcmFtO1xuICAgIGxldCBtaW51dGUgPSBtaW51dGVQYXJhbTtcbiAgICBsZXQgc2Vjb25kID0gc2Vjb25kUGFyYW07XG4gICAgbGV0IG1pbGxpc2Vjb25kID0gbWlsbGlzZWNvbmRQYXJhbTtcbiAgICBsZXQgbWljcm9zZWNvbmQgPSBtaWNyb3NlY29uZFBhcmFtO1xuICAgIGxldCBuYW5vc2Vjb25kID0gbmFub3NlY29uZFBhcmFtO1xuICAgIGhvdXIgKz0gaG91cnM7XG4gICAgbWludXRlICs9IG1pbnV0ZXM7XG4gICAgc2Vjb25kICs9IHNlY29uZHM7XG4gICAgbWlsbGlzZWNvbmQgKz0gbWlsbGlzZWNvbmRzO1xuICAgIG1pY3Jvc2Vjb25kICs9IG1pY3Jvc2Vjb25kcztcbiAgICBuYW5vc2Vjb25kICs9IG5hbm9zZWNvbmRzO1xuICAgIGxldCBkZWx0YURheXMgPSAwO1xuICAgICh7IGRlbHRhRGF5cywgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kLCBtaWNyb3NlY29uZCwgbmFub3NlY29uZCB9ID0gQmFsYW5jZVRpbWUoaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kLCBtaWNyb3NlY29uZCwgbmFub3NlY29uZCkpO1xuICAgIHJldHVybiB7IGRlbHRhRGF5cywgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kLCBtaWNyb3NlY29uZCwgbmFub3NlY29uZCB9O1xufVxuZnVuY3Rpb24gQWRkRHVyYXRpb24oeTEsIG1vbjEsIHcxLCBkMSwgaDEsIG1pbjEsIHMxLCBtczEsIMK1czEsIG5zMSwgeTIsIG1vbjIsIHcyLCBkMiwgaDIsIG1pbjIsIHMyLCBtczIsIMK1czIsIG5zMiwgcmVsYXRpdmVUbykge1xuICAgIGNvbnN0IGxhcmdlc3RVbml0MSA9IERlZmF1bHRUZW1wb3JhbExhcmdlc3RVbml0KHkxLCBtb24xLCB3MSwgZDEsIGgxLCBtaW4xLCBzMSwgbXMxLCDCtXMxLCBuczEpO1xuICAgIGNvbnN0IGxhcmdlc3RVbml0MiA9IERlZmF1bHRUZW1wb3JhbExhcmdlc3RVbml0KHkyLCBtb24yLCB3MiwgZDIsIGgyLCBtaW4yLCBzMiwgbXMyLCDCtXMyLCBuczIpO1xuICAgIGNvbnN0IGxhcmdlc3RVbml0ID0gTGFyZ2VyT2ZUd29UZW1wb3JhbFVuaXRzKGxhcmdlc3RVbml0MSwgbGFyZ2VzdFVuaXQyKTtcbiAgICBsZXQgeWVhcnMsIG1vbnRocywgd2Vla3MsIGRheXMsIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBtaWxsaXNlY29uZHMsIG1pY3Jvc2Vjb25kcywgbmFub3NlY29uZHM7XG4gICAgaWYgKCFyZWxhdGl2ZVRvKSB7XG4gICAgICAgIGlmIChsYXJnZXN0VW5pdCA9PT0gJ3llYXInIHx8IGxhcmdlc3RVbml0ID09PSAnbW9udGgnIHx8IGxhcmdlc3RVbml0ID09PSAnd2VlaycpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdyZWxhdGl2ZVRvIGlzIHJlcXVpcmVkIGZvciB5ZWFycywgbW9udGhzLCBvciB3ZWVrcyBhcml0aG1ldGljJyk7XG4gICAgICAgIH1cbiAgICAgICAgeWVhcnMgPSBtb250aHMgPSB3ZWVrcyA9IDA7XG4gICAgICAgICh7IGRheXMsIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBtaWxsaXNlY29uZHMsIG1pY3Jvc2Vjb25kcywgbmFub3NlY29uZHMgfSA9IEJhbGFuY2VEdXJhdGlvbihkMSArIGQyLCBoMSArIGgyLCBtaW4xICsgbWluMiwgczEgKyBzMiwgbXMxICsgbXMyLCDCtXMxICsgwrVzMiwgbnMxICsgbnMyLCBsYXJnZXN0VW5pdCkpO1xuICAgIH1cbiAgICBlbHNlIGlmIChJc1RlbXBvcmFsRGF0ZShyZWxhdGl2ZVRvKSkge1xuICAgICAgICBjb25zdCBUZW1wb3JhbER1cmF0aW9uID0gR2V0SW50cmluc2ljKCclVGVtcG9yYWwuRHVyYXRpb24lJyk7XG4gICAgICAgIGNvbnN0IGNhbGVuZGFyID0gR2V0U2xvdChyZWxhdGl2ZVRvLCBDQUxFTkRBUik7XG4gICAgICAgIGNvbnN0IGRhdGVEdXJhdGlvbjEgPSBuZXcgVGVtcG9yYWxEdXJhdGlvbih5MSwgbW9uMSwgdzEsIGQxLCAwLCAwLCAwLCAwLCAwLCAwKTtcbiAgICAgICAgY29uc3QgZGF0ZUR1cmF0aW9uMiA9IG5ldyBUZW1wb3JhbER1cmF0aW9uKHkyLCBtb24yLCB3MiwgZDIsIDAsIDAsIDAsIDAsIDAsIDApO1xuICAgICAgICBjb25zdCBkYXRlQWRkID0gY2FsZW5kYXIuZGF0ZUFkZDtcbiAgICAgICAgY29uc3QgZmlyc3RBZGRPcHRpb25zID0gT2JqZWN0Q3JlYXRlJDIobnVsbCk7XG4gICAgICAgIGNvbnN0IGludGVybWVkaWF0ZSA9IENhbGVuZGFyRGF0ZUFkZChjYWxlbmRhciwgcmVsYXRpdmVUbywgZGF0ZUR1cmF0aW9uMSwgZmlyc3RBZGRPcHRpb25zLCBkYXRlQWRkKTtcbiAgICAgICAgY29uc3Qgc2Vjb25kQWRkT3B0aW9ucyA9IE9iamVjdENyZWF0ZSQyKG51bGwpO1xuICAgICAgICBjb25zdCBlbmQgPSBDYWxlbmRhckRhdGVBZGQoY2FsZW5kYXIsIGludGVybWVkaWF0ZSwgZGF0ZUR1cmF0aW9uMiwgc2Vjb25kQWRkT3B0aW9ucywgZGF0ZUFkZCk7XG4gICAgICAgIGNvbnN0IGRhdGVMYXJnZXN0VW5pdCA9IExhcmdlck9mVHdvVGVtcG9yYWxVbml0cygnZGF5JywgbGFyZ2VzdFVuaXQpO1xuICAgICAgICBjb25zdCBkaWZmZXJlbmNlT3B0aW9ucyA9IE9iamVjdENyZWF0ZSQyKG51bGwpO1xuICAgICAgICBkaWZmZXJlbmNlT3B0aW9ucy5sYXJnZXN0VW5pdCA9IGRhdGVMYXJnZXN0VW5pdDtcbiAgICAgICAgKHsgeWVhcnMsIG1vbnRocywgd2Vla3MsIGRheXMgfSA9IENhbGVuZGFyRGF0ZVVudGlsKGNhbGVuZGFyLCByZWxhdGl2ZVRvLCBlbmQsIGRpZmZlcmVuY2VPcHRpb25zKSk7XG4gICAgICAgIC8vIFNpZ25zIG9mIGRhdGUgcGFydCBhbmQgdGltZSBwYXJ0IG1heSBub3QgYWdyZWU7IGJhbGFuY2UgdGhlbSB0b2dldGhlclxuICAgICAgICAoeyBkYXlzLCBob3VycywgbWludXRlcywgc2Vjb25kcywgbWlsbGlzZWNvbmRzLCBtaWNyb3NlY29uZHMsIG5hbm9zZWNvbmRzIH0gPSBCYWxhbmNlRHVyYXRpb24oZGF5cywgaDEgKyBoMiwgbWluMSArIG1pbjIsIHMxICsgczIsIG1zMSArIG1zMiwgwrVzMSArIMK1czIsIG5zMSArIG5zMiwgbGFyZ2VzdFVuaXQpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIHJlbGF0aXZlVG8gaXMgYSBab25lZERhdGVUaW1lXG4gICAgICAgIGNvbnN0IFRlbXBvcmFsSW5zdGFudCA9IEdldEludHJpbnNpYygnJVRlbXBvcmFsLkluc3RhbnQlJyk7XG4gICAgICAgIGNvbnN0IHRpbWVab25lID0gR2V0U2xvdChyZWxhdGl2ZVRvLCBUSU1FX1pPTkUpO1xuICAgICAgICBjb25zdCBjYWxlbmRhciA9IEdldFNsb3QocmVsYXRpdmVUbywgQ0FMRU5EQVIpO1xuICAgICAgICBjb25zdCBpbnRlcm1lZGlhdGVOcyA9IEFkZFpvbmVkRGF0ZVRpbWUoR2V0U2xvdChyZWxhdGl2ZVRvLCBJTlNUQU5UKSwgdGltZVpvbmUsIGNhbGVuZGFyLCB5MSwgbW9uMSwgdzEsIGQxLCBoMSwgbWluMSwgczEsIG1zMSwgwrVzMSwgbnMxKTtcbiAgICAgICAgY29uc3QgZW5kTnMgPSBBZGRab25lZERhdGVUaW1lKG5ldyBUZW1wb3JhbEluc3RhbnQoaW50ZXJtZWRpYXRlTnMpLCB0aW1lWm9uZSwgY2FsZW5kYXIsIHkyLCBtb24yLCB3MiwgZDIsIGgyLCBtaW4yLCBzMiwgbXMyLCDCtXMyLCBuczIpO1xuICAgICAgICBpZiAobGFyZ2VzdFVuaXQgIT09ICd5ZWFyJyAmJiBsYXJnZXN0VW5pdCAhPT0gJ21vbnRoJyAmJiBsYXJnZXN0VW5pdCAhPT0gJ3dlZWsnICYmIGxhcmdlc3RVbml0ICE9PSAnZGF5Jykge1xuICAgICAgICAgICAgLy8gVGhlIHVzZXIgaXMgb25seSBhc2tpbmcgZm9yIGEgdGltZSBkaWZmZXJlbmNlLCBzbyByZXR1cm4gZGlmZmVyZW5jZSBvZiBpbnN0YW50cy5cbiAgICAgICAgICAgIHllYXJzID0gMDtcbiAgICAgICAgICAgIG1vbnRocyA9IDA7XG4gICAgICAgICAgICB3ZWVrcyA9IDA7XG4gICAgICAgICAgICBkYXlzID0gMDtcbiAgICAgICAgICAgICh7IHNlY29uZHMsIG1pbGxpc2Vjb25kcywgbWljcm9zZWNvbmRzLCBuYW5vc2Vjb25kcyB9ID0gRGlmZmVyZW5jZUluc3RhbnQoR2V0U2xvdChyZWxhdGl2ZVRvLCBFUE9DSE5BTk9TRUNPTkRTKSwgZW5kTnMsIDEsICduYW5vc2Vjb25kJywgJ2hhbGZFeHBhbmQnKSk7XG4gICAgICAgICAgICAoeyBob3VycywgbWludXRlcywgc2Vjb25kcywgbWlsbGlzZWNvbmRzLCBtaWNyb3NlY29uZHMsIG5hbm9zZWNvbmRzIH0gPSBCYWxhbmNlRHVyYXRpb24oMCwgMCwgMCwgc2Vjb25kcywgbWlsbGlzZWNvbmRzLCBtaWNyb3NlY29uZHMsIG5hbm9zZWNvbmRzLCBsYXJnZXN0VW5pdCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgKHsgeWVhcnMsIG1vbnRocywgd2Vla3MsIGRheXMsIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBtaWxsaXNlY29uZHMsIG1pY3Jvc2Vjb25kcywgbmFub3NlY29uZHMgfSA9XG4gICAgICAgICAgICAgICAgRGlmZmVyZW5jZVpvbmVkRGF0ZVRpbWUoR2V0U2xvdChyZWxhdGl2ZVRvLCBFUE9DSE5BTk9TRUNPTkRTKSwgZW5kTnMsIHRpbWVab25lLCBjYWxlbmRhciwgbGFyZ2VzdFVuaXQpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBSZWplY3REdXJhdGlvbih5ZWFycywgbW9udGhzLCB3ZWVrcywgZGF5cywgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc2Vjb25kcywgbWljcm9zZWNvbmRzLCBuYW5vc2Vjb25kcyk7XG4gICAgcmV0dXJuIHsgeWVhcnMsIG1vbnRocywgd2Vla3MsIGRheXMsIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBtaWxsaXNlY29uZHMsIG1pY3Jvc2Vjb25kcywgbmFub3NlY29uZHMgfTtcbn1cbmZ1bmN0aW9uIEFkZEluc3RhbnQoZXBvY2hOYW5vc2Vjb25kcywgaCwgbWluLCBzLCBtcywgwrVzLCBucykge1xuICAgIGxldCBzdW0gPSBaRVJPO1xuICAgIHN1bSA9IEpTQkkuYWRkKHN1bSwgSlNCSS5CaWdJbnQobnMpKTtcbiAgICBzdW0gPSBKU0JJLmFkZChzdW0sIEpTQkkubXVsdGlwbHkoSlNCSS5CaWdJbnQowrVzKSwgVEhPVVNBTkQpKTtcbiAgICBzdW0gPSBKU0JJLmFkZChzdW0sIEpTQkkubXVsdGlwbHkoSlNCSS5CaWdJbnQobXMpLCBNSUxMSU9OKSk7XG4gICAgc3VtID0gSlNCSS5hZGQoc3VtLCBKU0JJLm11bHRpcGx5KEpTQkkuQmlnSW50KHMpLCBCSUxMSU9OKSk7XG4gICAgc3VtID0gSlNCSS5hZGQoc3VtLCBKU0JJLm11bHRpcGx5KEpTQkkuQmlnSW50KG1pbiksIEpTQkkuQmlnSW50KDYwICogMWU5KSkpO1xuICAgIHN1bSA9IEpTQkkuYWRkKHN1bSwgSlNCSS5tdWx0aXBseShKU0JJLkJpZ0ludChoKSwgSlNCSS5CaWdJbnQoNjAgKiA2MCAqIDFlOSkpKTtcbiAgICBjb25zdCByZXN1bHQgPSBKU0JJLmFkZChlcG9jaE5hbm9zZWNvbmRzLCBzdW0pO1xuICAgIFZhbGlkYXRlRXBvY2hOYW5vc2Vjb25kcyhyZXN1bHQpO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBBZGREYXRlVGltZSh5ZWFyLCBtb250aCwgZGF5LCBob3VyUGFyYW0sIG1pbnV0ZVBhcmFtLCBzZWNvbmRQYXJhbSwgbWlsbGlzZWNvbmRQYXJhbSwgbWljcm9zZWNvbmRQYXJhbSwgbmFub3NlY29uZFBhcmFtLCBjYWxlbmRhciwgeWVhcnMsIG1vbnRocywgd2Vla3MsIGRheXNQYXJhbSwgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc2Vjb25kcywgbWljcm9zZWNvbmRzLCBuYW5vc2Vjb25kcywgb3B0aW9ucykge1xuICAgIGxldCBkYXlzID0gZGF5c1BhcmFtO1xuICAgIC8vIEFkZCB0aGUgdGltZSBwYXJ0XG4gICAgbGV0IHsgZGVsdGFEYXlzLCBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQsIG1pY3Jvc2Vjb25kLCBuYW5vc2Vjb25kIH0gPSBBZGRUaW1lKGhvdXJQYXJhbSwgbWludXRlUGFyYW0sIHNlY29uZFBhcmFtLCBtaWxsaXNlY29uZFBhcmFtLCBtaWNyb3NlY29uZFBhcmFtLCBuYW5vc2Vjb25kUGFyYW0sIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBtaWxsaXNlY29uZHMsIG1pY3Jvc2Vjb25kcywgbmFub3NlY29uZHMpO1xuICAgIGRheXMgKz0gZGVsdGFEYXlzO1xuICAgIC8vIERlbGVnYXRlIHRoZSBkYXRlIHBhcnQgYWRkaXRpb24gdG8gdGhlIGNhbGVuZGFyXG4gICAgY29uc3QgVGVtcG9yYWxEdXJhdGlvbiA9IEdldEludHJpbnNpYygnJVRlbXBvcmFsLkR1cmF0aW9uJScpO1xuICAgIGNvbnN0IGRhdGVQYXJ0ID0gQ3JlYXRlVGVtcG9yYWxEYXRlKHllYXIsIG1vbnRoLCBkYXksIGNhbGVuZGFyKTtcbiAgICBjb25zdCBkYXRlRHVyYXRpb24gPSBuZXcgVGVtcG9yYWxEdXJhdGlvbih5ZWFycywgbW9udGhzLCB3ZWVrcywgZGF5cywgMCwgMCwgMCwgMCwgMCwgMCk7XG4gICAgY29uc3QgYWRkZWREYXRlID0gQ2FsZW5kYXJEYXRlQWRkKGNhbGVuZGFyLCBkYXRlUGFydCwgZGF0ZUR1cmF0aW9uLCBvcHRpb25zKTtcbiAgICByZXR1cm4ge1xuICAgICAgICB5ZWFyOiBHZXRTbG90KGFkZGVkRGF0ZSwgSVNPX1lFQVIpLFxuICAgICAgICBtb250aDogR2V0U2xvdChhZGRlZERhdGUsIElTT19NT05USCksXG4gICAgICAgIGRheTogR2V0U2xvdChhZGRlZERhdGUsIElTT19EQVkpLFxuICAgICAgICBob3VyLFxuICAgICAgICBtaW51dGUsXG4gICAgICAgIHNlY29uZCxcbiAgICAgICAgbWlsbGlzZWNvbmQsXG4gICAgICAgIG1pY3Jvc2Vjb25kLFxuICAgICAgICBuYW5vc2Vjb25kXG4gICAgfTtcbn1cbmZ1bmN0aW9uIEFkZFpvbmVkRGF0ZVRpbWUoaW5zdGFudCwgdGltZVpvbmUsIGNhbGVuZGFyLCB5ZWFycywgbW9udGhzLCB3ZWVrcywgZGF5cywgaCwgbWluLCBzLCBtcywgwrVzLCBucywgb3B0aW9ucykge1xuICAgIC8vIElmIG9ubHkgdGltZSBpcyB0byBiZSBhZGRlZCwgdGhlbiB1c2UgSW5zdGFudCBtYXRoLiBJdCdzIG5vdCBPSyB0byBmYWxsXG4gICAgLy8gdGhyb3VnaCB0byB0aGUgZGF0ZS90aW1lIGNvZGUgYmVsb3cgYmVjYXVzZSBjb21wYXRpYmxlIGRpc2FtYmlndWF0aW9uIGluXG4gICAgLy8gdGhlIFBsYWluRGF0ZVRpbWU9Pkluc3RhbnQgY29udmVyc2lvbiB3aWxsIGNoYW5nZSB0aGUgb2Zmc2V0IG9mIGFueVxuICAgIC8vIFpvbmVkRGF0ZVRpbWUgaW4gdGhlIHJlcGVhdGVkIGNsb2NrIHRpbWUgYWZ0ZXIgYSBiYWNrd2FyZHMgdHJhbnNpdGlvbi5cbiAgICAvLyBXaGVuIGFkZGluZy9zdWJ0cmFjdGluZyB0aW1lIHVuaXRzIGFuZCBub3QgZGF0ZXMsIHRoaXMgZGlzYW1iaWd1YXRpb24gaXNcbiAgICAvLyBub3QgZXhwZWN0ZWQgYW5kIHNvIGlzIGF2b2lkZWQgYmVsb3cgdmlhIGEgZmFzdCBwYXRoIGZvciB0aW1lLW9ubHlcbiAgICAvLyBhcml0aG1ldGljLlxuICAgIC8vIEJUVywgdGhpcyBiZWhhdmlvciBpcyBzaW1pbGFyIGluIHNwaXJpdCB0byBvZmZzZXQ6ICdwcmVmZXInIGluIGB3aXRoYC5cbiAgICBjb25zdCBUZW1wb3JhbER1cmF0aW9uID0gR2V0SW50cmluc2ljKCclVGVtcG9yYWwuRHVyYXRpb24lJyk7XG4gICAgaWYgKER1cmF0aW9uU2lnbih5ZWFycywgbW9udGhzLCB3ZWVrcywgZGF5cywgMCwgMCwgMCwgMCwgMCwgMCkgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIEFkZEluc3RhbnQoR2V0U2xvdChpbnN0YW50LCBFUE9DSE5BTk9TRUNPTkRTKSwgaCwgbWluLCBzLCBtcywgwrVzLCBucyk7XG4gICAgfVxuICAgIC8vIFJGQyA1NTQ1IHJlcXVpcmVzIHRoZSBkYXRlIHBvcnRpb24gdG8gYmUgYWRkZWQgaW4gY2FsZW5kYXIgZGF5cyBhbmQgdGhlXG4gICAgLy8gdGltZSBwb3J0aW9uIHRvIGJlIGFkZGVkIGluIGV4YWN0IHRpbWUuXG4gICAgY29uc3QgZHQgPSBCdWlsdGluVGltZVpvbmVHZXRQbGFpbkRhdGVUaW1lRm9yKHRpbWVab25lLCBpbnN0YW50LCBjYWxlbmRhcik7XG4gICAgY29uc3QgZGF0ZVBhcnQgPSBDcmVhdGVUZW1wb3JhbERhdGUoR2V0U2xvdChkdCwgSVNPX1lFQVIpLCBHZXRTbG90KGR0LCBJU09fTU9OVEgpLCBHZXRTbG90KGR0LCBJU09fREFZKSwgY2FsZW5kYXIpO1xuICAgIGNvbnN0IGRhdGVEdXJhdGlvbiA9IG5ldyBUZW1wb3JhbER1cmF0aW9uKHllYXJzLCBtb250aHMsIHdlZWtzLCBkYXlzLCAwLCAwLCAwLCAwLCAwLCAwKTtcbiAgICBjb25zdCBhZGRlZERhdGUgPSBDYWxlbmRhckRhdGVBZGQoY2FsZW5kYXIsIGRhdGVQYXJ0LCBkYXRlRHVyYXRpb24sIG9wdGlvbnMpO1xuICAgIGNvbnN0IGR0SW50ZXJtZWRpYXRlID0gQ3JlYXRlVGVtcG9yYWxEYXRlVGltZShHZXRTbG90KGFkZGVkRGF0ZSwgSVNPX1lFQVIpLCBHZXRTbG90KGFkZGVkRGF0ZSwgSVNPX01PTlRIKSwgR2V0U2xvdChhZGRlZERhdGUsIElTT19EQVkpLCBHZXRTbG90KGR0LCBJU09fSE9VUiksIEdldFNsb3QoZHQsIElTT19NSU5VVEUpLCBHZXRTbG90KGR0LCBJU09fU0VDT05EKSwgR2V0U2xvdChkdCwgSVNPX01JTExJU0VDT05EKSwgR2V0U2xvdChkdCwgSVNPX01JQ1JPU0VDT05EKSwgR2V0U2xvdChkdCwgSVNPX05BTk9TRUNPTkQpLCBjYWxlbmRhcik7XG4gICAgLy8gTm90ZSB0aGF0ICdjb21wYXRpYmxlJyBpcyB1c2VkIGJlbG93IGJlY2F1c2UgdGhpcyBkaXNhbWJpZ3VhdGlvbiBiZWhhdmlvclxuICAgIC8vIGlzIHJlcXVpcmVkIGJ5IFJGQyA1NTQ1LlxuICAgIGNvbnN0IGluc3RhbnRJbnRlcm1lZGlhdGUgPSBCdWlsdGluVGltZVpvbmVHZXRJbnN0YW50Rm9yKHRpbWVab25lLCBkdEludGVybWVkaWF0ZSwgJ2NvbXBhdGlibGUnKTtcbiAgICByZXR1cm4gQWRkSW5zdGFudChHZXRTbG90KGluc3RhbnRJbnRlcm1lZGlhdGUsIEVQT0NITkFOT1NFQ09ORFMpLCBoLCBtaW4sIHMsIG1zLCDCtXMsIG5zKTtcbn1cbmZ1bmN0aW9uIFJvdW5kTnVtYmVyVG9JbmNyZW1lbnQocXVhbnRpdHksIGluY3JlbWVudCwgbW9kZSkge1xuICAgIGlmIChpbmNyZW1lbnQgPT09IDEpXG4gICAgICAgIHJldHVybiBxdWFudGl0eTtcbiAgICBsZXQgeyBxdW90aWVudCwgcmVtYWluZGVyIH0gPSBkaXZtb2QocXVhbnRpdHksIEpTQkkuQmlnSW50KGluY3JlbWVudCkpO1xuICAgIGlmIChKU0JJLmVxdWFsKHJlbWFpbmRlciwgWkVSTykpXG4gICAgICAgIHJldHVybiBxdWFudGl0eTtcbiAgICBjb25zdCBzaWduID0gSlNCSS5sZXNzVGhhbihyZW1haW5kZXIsIFpFUk8pID8gLTEgOiAxO1xuICAgIHN3aXRjaCAobW9kZSkge1xuICAgICAgICBjYXNlICdjZWlsJzpcbiAgICAgICAgICAgIGlmIChzaWduID4gMClcbiAgICAgICAgICAgICAgICBxdW90aWVudCA9IEpTQkkuYWRkKHF1b3RpZW50LCBKU0JJLkJpZ0ludChzaWduKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnZmxvb3InOlxuICAgICAgICAgICAgaWYgKHNpZ24gPCAwKVxuICAgICAgICAgICAgICAgIHF1b3RpZW50ID0gSlNCSS5hZGQocXVvdGllbnQsIEpTQkkuQmlnSW50KHNpZ24pKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICd0cnVuYyc6XG4gICAgICAgICAgICAvLyBubyBjaGFuZ2UgbmVlZGVkLCBiZWNhdXNlIGRpdm1vZCBpcyBhIHRydW5jYXRpb25cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdoYWxmRXhwYW5kJzpcbiAgICAgICAgICAgIC8vIFwiaGFsZiB1cCBhd2F5IGZyb20gemVyb1wiXG4gICAgICAgICAgICBpZiAoSlNCSS50b051bWJlcihhYnMoSlNCSS5tdWx0aXBseShyZW1haW5kZXIsIEpTQkkuQmlnSW50KDIpKSkpID49IGluY3JlbWVudCkge1xuICAgICAgICAgICAgICAgIHF1b3RpZW50ID0gSlNCSS5hZGQocXVvdGllbnQsIEpTQkkuQmlnSW50KHNpZ24pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gSlNCSS5tdWx0aXBseShxdW90aWVudCwgSlNCSS5CaWdJbnQoaW5jcmVtZW50KSk7XG59XG5mdW5jdGlvbiBSb3VuZEluc3RhbnQoZXBvY2hOcywgaW5jcmVtZW50LCB1bml0LCByb3VuZGluZ01vZGUpIHtcbiAgICAvLyBOb3RlOiBOb25OZWdhdGl2ZU1vZHVsbywgYnV0IHdpdGggQmlnSW50XG4gICAgbGV0IHJlbWFpbmRlciA9IEpTQkkucmVtYWluZGVyKGVwb2NoTnMsIEpTQkkuQmlnSW50KDg2NDAwZTkpKTtcbiAgICBpZiAoSlNCSS5sZXNzVGhhbihyZW1haW5kZXIsIFpFUk8pKVxuICAgICAgICByZW1haW5kZXIgPSBKU0JJLmFkZChyZW1haW5kZXIsIEpTQkkuQmlnSW50KDg2NDAwZTkpKTtcbiAgICBjb25zdCB3aG9sZURheXMgPSBKU0JJLnN1YnRyYWN0KGVwb2NoTnMsIHJlbWFpbmRlcik7XG4gICAgY29uc3Qgcm91bmRlZFJlbWFpbmRlciA9IFJvdW5kTnVtYmVyVG9JbmNyZW1lbnQocmVtYWluZGVyLCBuc1BlclRpbWVVbml0W3VuaXRdICogaW5jcmVtZW50LCByb3VuZGluZ01vZGUpO1xuICAgIHJldHVybiBKU0JJLmFkZCh3aG9sZURheXMsIHJvdW5kZWRSZW1haW5kZXIpO1xufVxuZnVuY3Rpb24gUm91bmRJU09EYXRlVGltZSh5ZWFyUGFyYW0sIG1vbnRoUGFyYW0sIGRheVBhcmFtLCBob3VyUGFyYW0sIG1pbnV0ZVBhcmFtLCBzZWNvbmRQYXJhbSwgbWlsbGlzZWNvbmRQYXJhbSwgbWljcm9zZWNvbmRQYXJhbSwgbmFub3NlY29uZFBhcmFtLCBpbmNyZW1lbnQsIHVuaXQsIHJvdW5kaW5nTW9kZSwgZGF5TGVuZ3RoTnMgPSA4NjQwMGU5KSB7XG4gICAgY29uc3QgeyBkZWx0YURheXMsIGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZCwgbWljcm9zZWNvbmQsIG5hbm9zZWNvbmQgfSA9IFJvdW5kVGltZShob3VyUGFyYW0sIG1pbnV0ZVBhcmFtLCBzZWNvbmRQYXJhbSwgbWlsbGlzZWNvbmRQYXJhbSwgbWljcm9zZWNvbmRQYXJhbSwgbmFub3NlY29uZFBhcmFtLCBpbmNyZW1lbnQsIHVuaXQsIHJvdW5kaW5nTW9kZSwgZGF5TGVuZ3RoTnMpO1xuICAgIGNvbnN0IHsgeWVhciwgbW9udGgsIGRheSB9ID0gQmFsYW5jZUlTT0RhdGUoeWVhclBhcmFtLCBtb250aFBhcmFtLCBkYXlQYXJhbSArIGRlbHRhRGF5cyk7XG4gICAgcmV0dXJuIHsgeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kLCBtaWNyb3NlY29uZCwgbmFub3NlY29uZCB9O1xufVxuZnVuY3Rpb24gUm91bmRUaW1lKGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZCwgbWljcm9zZWNvbmQsIG5hbm9zZWNvbmQsIGluY3JlbWVudCwgdW5pdCwgcm91bmRpbmdNb2RlLCBkYXlMZW5ndGhOcyA9IDg2NDAwZTkpIHtcbiAgICBsZXQgcXVhbnRpdHkgPSBaRVJPO1xuICAgIHN3aXRjaCAodW5pdCkge1xuICAgICAgICBjYXNlICdkYXknOlxuICAgICAgICBjYXNlICdob3VyJzpcbiAgICAgICAgICAgIHF1YW50aXR5ID0gSlNCSS5CaWdJbnQoaG91cik7XG4gICAgICAgIC8vIGZhbGwgdGhyb3VnaFxuICAgICAgICBjYXNlICdtaW51dGUnOlxuICAgICAgICAgICAgcXVhbnRpdHkgPSBKU0JJLmFkZChKU0JJLm11bHRpcGx5KHF1YW50aXR5LCBTSVhUWSksIEpTQkkuQmlnSW50KG1pbnV0ZSkpO1xuICAgICAgICAvLyBmYWxsIHRocm91Z2hcbiAgICAgICAgY2FzZSAnc2Vjb25kJzpcbiAgICAgICAgICAgIHF1YW50aXR5ID0gSlNCSS5hZGQoSlNCSS5tdWx0aXBseShxdWFudGl0eSwgU0lYVFkpLCBKU0JJLkJpZ0ludChzZWNvbmQpKTtcbiAgICAgICAgLy8gZmFsbCB0aHJvdWdoXG4gICAgICAgIGNhc2UgJ21pbGxpc2Vjb25kJzpcbiAgICAgICAgICAgIHF1YW50aXR5ID0gSlNCSS5hZGQoSlNCSS5tdWx0aXBseShxdWFudGl0eSwgVEhPVVNBTkQpLCBKU0JJLkJpZ0ludChtaWxsaXNlY29uZCkpO1xuICAgICAgICAvLyBmYWxsIHRocm91Z2hcbiAgICAgICAgY2FzZSAnbWljcm9zZWNvbmQnOlxuICAgICAgICAgICAgcXVhbnRpdHkgPSBKU0JJLmFkZChKU0JJLm11bHRpcGx5KHF1YW50aXR5LCBUSE9VU0FORCksIEpTQkkuQmlnSW50KG1pY3Jvc2Vjb25kKSk7XG4gICAgICAgIC8vIGZhbGwgdGhyb3VnaFxuICAgICAgICBjYXNlICduYW5vc2Vjb25kJzpcbiAgICAgICAgICAgIHF1YW50aXR5ID0gSlNCSS5hZGQoSlNCSS5tdWx0aXBseShxdWFudGl0eSwgVEhPVVNBTkQpLCBKU0JJLkJpZ0ludChuYW5vc2Vjb25kKSk7XG4gICAgfVxuICAgIGNvbnN0IG5zUGVyVW5pdCA9IHVuaXQgPT09ICdkYXknID8gZGF5TGVuZ3RoTnMgOiBuc1BlclRpbWVVbml0W3VuaXRdO1xuICAgIGNvbnN0IHJvdW5kZWQgPSBSb3VuZE51bWJlclRvSW5jcmVtZW50KHF1YW50aXR5LCBuc1BlclVuaXQgKiBpbmNyZW1lbnQsIHJvdW5kaW5nTW9kZSk7XG4gICAgY29uc3QgcmVzdWx0ID0gSlNCSS50b051bWJlcihKU0JJLmRpdmlkZShyb3VuZGVkLCBKU0JJLkJpZ0ludChuc1BlclVuaXQpKSk7XG4gICAgc3dpdGNoICh1bml0KSB7XG4gICAgICAgIGNhc2UgJ2RheSc6XG4gICAgICAgICAgICByZXR1cm4geyBkZWx0YURheXM6IHJlc3VsdCwgaG91cjogMCwgbWludXRlOiAwLCBzZWNvbmQ6IDAsIG1pbGxpc2Vjb25kOiAwLCBtaWNyb3NlY29uZDogMCwgbmFub3NlY29uZDogMCB9O1xuICAgICAgICBjYXNlICdob3VyJzpcbiAgICAgICAgICAgIHJldHVybiBCYWxhbmNlVGltZShyZXN1bHQsIDAsIDAsIDAsIDAsIDApO1xuICAgICAgICBjYXNlICdtaW51dGUnOlxuICAgICAgICAgICAgcmV0dXJuIEJhbGFuY2VUaW1lKGhvdXIsIHJlc3VsdCwgMCwgMCwgMCwgMCk7XG4gICAgICAgIGNhc2UgJ3NlY29uZCc6XG4gICAgICAgICAgICByZXR1cm4gQmFsYW5jZVRpbWUoaG91ciwgbWludXRlLCByZXN1bHQsIDAsIDAsIDApO1xuICAgICAgICBjYXNlICdtaWxsaXNlY29uZCc6XG4gICAgICAgICAgICByZXR1cm4gQmFsYW5jZVRpbWUoaG91ciwgbWludXRlLCBzZWNvbmQsIHJlc3VsdCwgMCwgMCk7XG4gICAgICAgIGNhc2UgJ21pY3Jvc2Vjb25kJzpcbiAgICAgICAgICAgIHJldHVybiBCYWxhbmNlVGltZShob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQsIHJlc3VsdCwgMCk7XG4gICAgICAgIGNhc2UgJ25hbm9zZWNvbmQnOlxuICAgICAgICAgICAgcmV0dXJuIEJhbGFuY2VUaW1lKGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZCwgbWljcm9zZWNvbmQsIHJlc3VsdCk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgdW5pdCAke3VuaXR9YCk7XG4gICAgfVxufVxuZnVuY3Rpb24gRGF5c1VudGlsKGVhcmxpZXIsIGxhdGVyKSB7XG4gICAgcmV0dXJuIERpZmZlcmVuY2VJU09EYXRlKEdldFNsb3QoZWFybGllciwgSVNPX1lFQVIpLCBHZXRTbG90KGVhcmxpZXIsIElTT19NT05USCksIEdldFNsb3QoZWFybGllciwgSVNPX0RBWSksIEdldFNsb3QobGF0ZXIsIElTT19ZRUFSKSwgR2V0U2xvdChsYXRlciwgSVNPX01PTlRIKSwgR2V0U2xvdChsYXRlciwgSVNPX0RBWSksICdkYXknKS5kYXlzO1xufVxuZnVuY3Rpb24gTW92ZVJlbGF0aXZlRGF0ZShjYWxlbmRhciwgcmVsYXRpdmVUb1BhcmFtLCBkdXJhdGlvbikge1xuICAgIGNvbnN0IG9wdGlvbnMgPSBPYmplY3RDcmVhdGUkMihudWxsKTtcbiAgICBjb25zdCBsYXRlciA9IENhbGVuZGFyRGF0ZUFkZChjYWxlbmRhciwgcmVsYXRpdmVUb1BhcmFtLCBkdXJhdGlvbiwgb3B0aW9ucyk7XG4gICAgY29uc3QgZGF5cyA9IERheXNVbnRpbChyZWxhdGl2ZVRvUGFyYW0sIGxhdGVyKTtcbiAgICByZXR1cm4geyByZWxhdGl2ZVRvOiBsYXRlciwgZGF5cyB9O1xufVxuZnVuY3Rpb24gTW92ZVJlbGF0aXZlWm9uZWREYXRlVGltZShyZWxhdGl2ZVRvLCB5ZWFycywgbW9udGhzLCB3ZWVrcywgZGF5cykge1xuICAgIGNvbnN0IHRpbWVab25lID0gR2V0U2xvdChyZWxhdGl2ZVRvLCBUSU1FX1pPTkUpO1xuICAgIGNvbnN0IGNhbGVuZGFyID0gR2V0U2xvdChyZWxhdGl2ZVRvLCBDQUxFTkRBUik7XG4gICAgY29uc3QgaW50ZXJtZWRpYXRlTnMgPSBBZGRab25lZERhdGVUaW1lKEdldFNsb3QocmVsYXRpdmVUbywgSU5TVEFOVCksIHRpbWVab25lLCBjYWxlbmRhciwgeWVhcnMsIG1vbnRocywgd2Vla3MsIGRheXMsIDAsIDAsIDAsIDAsIDAsIDApO1xuICAgIHJldHVybiBDcmVhdGVUZW1wb3JhbFpvbmVkRGF0ZVRpbWUoaW50ZXJtZWRpYXRlTnMsIHRpbWVab25lLCBjYWxlbmRhcik7XG59XG5mdW5jdGlvbiBBZGp1c3RSb3VuZGVkRHVyYXRpb25EYXlzKHllYXJzUGFyYW0sIG1vbnRoc1BhcmFtLCB3ZWVrc1BhcmFtLCBkYXlzUGFyYW0sIGhvdXJzUGFyYW0sIG1pbnV0ZXNQYXJhbSwgc2Vjb25kc1BhcmFtLCBtaWxsaXNlY29uZHNQYXJhbSwgbWljcm9zZWNvbmRzUGFyYW0sIG5hbm9zZWNvbmRzUGFyYW0sIGluY3JlbWVudCwgdW5pdCwgcm91bmRpbmdNb2RlLCByZWxhdGl2ZVRvKSB7XG4gICAgbGV0IHllYXJzID0geWVhcnNQYXJhbTtcbiAgICBsZXQgbW9udGhzID0gbW9udGhzUGFyYW07XG4gICAgbGV0IHdlZWtzID0gd2Vla3NQYXJhbTtcbiAgICBsZXQgZGF5cyA9IGRheXNQYXJhbTtcbiAgICBsZXQgaG91cnMgPSBob3Vyc1BhcmFtO1xuICAgIGxldCBtaW51dGVzID0gbWludXRlc1BhcmFtO1xuICAgIGxldCBzZWNvbmRzID0gc2Vjb25kc1BhcmFtO1xuICAgIGxldCBtaWxsaXNlY29uZHMgPSBtaWxsaXNlY29uZHNQYXJhbTtcbiAgICBsZXQgbWljcm9zZWNvbmRzID0gbWljcm9zZWNvbmRzUGFyYW07XG4gICAgbGV0IG5hbm9zZWNvbmRzID0gbmFub3NlY29uZHNQYXJhbTtcbiAgICBpZiAoIUlzVGVtcG9yYWxab25lZERhdGVUaW1lKHJlbGF0aXZlVG8pIHx8XG4gICAgICAgIHVuaXQgPT09ICd5ZWFyJyB8fFxuICAgICAgICB1bml0ID09PSAnbW9udGgnIHx8XG4gICAgICAgIHVuaXQgPT09ICd3ZWVrJyB8fFxuICAgICAgICB1bml0ID09PSAnZGF5JyB8fFxuICAgICAgICAodW5pdCA9PT0gJ25hbm9zZWNvbmQnICYmIGluY3JlbWVudCA9PT0gMSkpIHtcbiAgICAgICAgcmV0dXJuIHsgeWVhcnMsIG1vbnRocywgd2Vla3MsIGRheXMsIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBtaWxsaXNlY29uZHMsIG1pY3Jvc2Vjb25kcywgbmFub3NlY29uZHMgfTtcbiAgICB9XG4gICAgLy8gVGhlcmUncyBvbmUgbW9yZSByb3VuZCBvZiByb3VuZGluZyBwb3NzaWJsZTogaWYgcmVsYXRpdmVUbyBpcyBhXG4gICAgLy8gWm9uZWREYXRlVGltZSwgdGhlIHRpbWUgdW5pdHMgY291bGQgaGF2ZSByb3VuZGVkIHVwIGludG8gZW5vdWdoIGhvdXJzXG4gICAgLy8gdG8gZXhjZWVkIHRoZSBkYXkgbGVuZ3RoLiBJZiB0aGlzIGhhcHBlbnMsIGdyb3cgdGhlIGRhdGUgcGFydCBieSBhXG4gICAgLy8gc2luZ2xlIGRheSBhbmQgcmUtcnVuIGV4YWN0IHRpbWUgcm91bmRpbmcgb24gdGhlIHNtYWxsZXIgcmVtYWluZGVyLiBET1xuICAgIC8vIE5PVCBSRUNVUlNFLCBiZWNhdXNlIG9uY2UgdGhlIGV4dHJhIGhvdXJzIGFyZSBzdWNrZWQgdXAgaW50byB0aGUgZGF0ZVxuICAgIC8vIGR1cmF0aW9uLCB0aGVyZSdzIG5vIHdheSBmb3IgYW5vdGhlciBmdWxsIGRheSB0byBjb21lIGZyb20gdGhlIG5leHRcbiAgICAvLyByb3VuZCBvZiByb3VuZGluZy4gQW5kIGlmIGl0IHdlcmUgcG9zc2libGUgKGUuZy4gY29udHJpdmVkIGNhbGVuZGFyXG4gICAgLy8gd2l0aCAzMC1taW51dGUtbG9uZyBcImRheXNcIikgdGhlbiBpdCdkIHJpc2sgYW4gaW5maW5pdGUgbG9vcC5cbiAgICBsZXQgdGltZVJlbWFpbmRlck5zID0gVG90YWxEdXJhdGlvbk5hbm9zZWNvbmRzKDAsIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBtaWxsaXNlY29uZHMsIG1pY3Jvc2Vjb25kcywgbmFub3NlY29uZHMsIDApO1xuICAgIGNvbnN0IGRpcmVjdGlvbiA9IE1hdGhTaWduKEpTQkkudG9OdW1iZXIodGltZVJlbWFpbmRlck5zKSk7XG4gICAgY29uc3QgdGltZVpvbmUgPSBHZXRTbG90KHJlbGF0aXZlVG8sIFRJTUVfWk9ORSk7XG4gICAgY29uc3QgY2FsZW5kYXIgPSBHZXRTbG90KHJlbGF0aXZlVG8sIENBTEVOREFSKTtcbiAgICBjb25zdCBkYXlTdGFydCA9IEFkZFpvbmVkRGF0ZVRpbWUoR2V0U2xvdChyZWxhdGl2ZVRvLCBJTlNUQU5UKSwgdGltZVpvbmUsIGNhbGVuZGFyLCB5ZWFycywgbW9udGhzLCB3ZWVrcywgZGF5cywgMCwgMCwgMCwgMCwgMCwgMCk7XG4gICAgY29uc3QgVGVtcG9yYWxJbnN0YW50ID0gR2V0SW50cmluc2ljKCclVGVtcG9yYWwuSW5zdGFudCUnKTtcbiAgICBjb25zdCBkYXlFbmQgPSBBZGRab25lZERhdGVUaW1lKG5ldyBUZW1wb3JhbEluc3RhbnQoZGF5U3RhcnQpLCB0aW1lWm9uZSwgY2FsZW5kYXIsIDAsIDAsIDAsIGRpcmVjdGlvbiwgMCwgMCwgMCwgMCwgMCwgMCk7XG4gICAgY29uc3QgZGF5TGVuZ3RoTnMgPSBKU0JJLnN1YnRyYWN0KGRheUVuZCwgZGF5U3RhcnQpO1xuICAgIGlmIChKU0JJLmdyZWF0ZXJUaGFuT3JFcXVhbChKU0JJLm11bHRpcGx5KEpTQkkuc3VidHJhY3QodGltZVJlbWFpbmRlck5zLCBkYXlMZW5ndGhOcyksIEpTQkkuQmlnSW50KGRpcmVjdGlvbikpLCBaRVJPKSkge1xuICAgICAgICAoeyB5ZWFycywgbW9udGhzLCB3ZWVrcywgZGF5cyB9ID0gQWRkRHVyYXRpb24oeWVhcnMsIG1vbnRocywgd2Vla3MsIGRheXMsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIGRpcmVjdGlvbiwgMCwgMCwgMCwgMCwgMCwgMCwgcmVsYXRpdmVUbykpO1xuICAgICAgICB0aW1lUmVtYWluZGVyTnMgPSBSb3VuZEluc3RhbnQoSlNCSS5zdWJ0cmFjdCh0aW1lUmVtYWluZGVyTnMsIGRheUxlbmd0aE5zKSwgaW5jcmVtZW50LCB1bml0LCByb3VuZGluZ01vZGUpO1xuICAgICAgICAoeyBob3VycywgbWludXRlcywgc2Vjb25kcywgbWlsbGlzZWNvbmRzLCBtaWNyb3NlY29uZHMsIG5hbm9zZWNvbmRzIH0gPSBCYWxhbmNlRHVyYXRpb24oMCwgMCwgMCwgMCwgMCwgMCwgSlNCSS50b051bWJlcih0aW1lUmVtYWluZGVyTnMpLCAnaG91cicpKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgeWVhcnMsIG1vbnRocywgd2Vla3MsIGRheXMsIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBtaWxsaXNlY29uZHMsIG1pY3Jvc2Vjb25kcywgbmFub3NlY29uZHMgfTtcbn1cbmZ1bmN0aW9uIFJvdW5kRHVyYXRpb24oeWVhcnNQYXJhbSwgbW9udGhzUGFyYW0sIHdlZWtzUGFyYW0sIGRheXNQYXJhbSwgaG91cnNQYXJhbSwgbWludXRlc1BhcmFtLCBzZWNvbmRzUGFyYW0sIG1pbGxpc2Vjb25kc1BhcmFtLCBtaWNyb3NlY29uZHNQYXJhbSwgbmFub3NlY29uZHNQYXJhbSwgaW5jcmVtZW50LCB1bml0LCByb3VuZGluZ01vZGUsIHJlbGF0aXZlVG9QYXJhbSA9IHVuZGVmaW5lZCkge1xuICAgIGxldCB5ZWFycyA9IHllYXJzUGFyYW07XG4gICAgbGV0IG1vbnRocyA9IG1vbnRoc1BhcmFtO1xuICAgIGxldCB3ZWVrcyA9IHdlZWtzUGFyYW07XG4gICAgbGV0IGRheXMgPSBkYXlzUGFyYW07XG4gICAgbGV0IGhvdXJzID0gaG91cnNQYXJhbTtcbiAgICBsZXQgbWludXRlcyA9IG1pbnV0ZXNQYXJhbTtcbiAgICBsZXQgc2Vjb25kcyA9IHNlY29uZHNQYXJhbTtcbiAgICBsZXQgbWlsbGlzZWNvbmRzID0gbWlsbGlzZWNvbmRzUGFyYW07XG4gICAgbGV0IG1pY3Jvc2Vjb25kcyA9IG1pY3Jvc2Vjb25kc1BhcmFtO1xuICAgIGxldCBuYW5vc2Vjb25kcyA9IEpTQkkuQmlnSW50KG5hbm9zZWNvbmRzUGFyYW0pO1xuICAgIGNvbnN0IFRlbXBvcmFsRHVyYXRpb24gPSBHZXRJbnRyaW5zaWMoJyVUZW1wb3JhbC5EdXJhdGlvbiUnKTtcbiAgICBsZXQgY2FsZW5kYXIsIHpkdFJlbGF0aXZlO1xuICAgIC8vIEEgY2FzdCBpcyB1c2VkIGJlbG93IGJlY2F1c2UgcmVsYXRpdmVUbyB3aWxsIGJlIGVpdGhlciBQbGFpbkRhdGUgb3JcbiAgICAvLyB1bmRlZmluZWQgZm9yIHRoZSByZXN0IG9mIHRoaXMgbG9uZyBtZXRob2QgKGFmdGVyIGFueSBaRFQ9PlBsYWluRGF0ZVxuICAgIC8vIGNvbnZlcnNpb24gYmVsb3cpLCBhbmQgVFMgaXNuJ3Qgc21hcnQgZW5vdWdoIHRvIGtub3cgdGhhdCB0aGUgdHlwZSBoYXNcbiAgICAvLyBjaGFuZ2VkLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL21pY3Jvc29mdC9UeXBlU2NyaXB0L2lzc3Vlcy8yNzcwNi5cbiAgICBsZXQgcmVsYXRpdmVUbyA9IHJlbGF0aXZlVG9QYXJhbTtcbiAgICBpZiAocmVsYXRpdmVUbykge1xuICAgICAgICBpZiAoSXNUZW1wb3JhbFpvbmVkRGF0ZVRpbWUocmVsYXRpdmVUbykpIHtcbiAgICAgICAgICAgIHpkdFJlbGF0aXZlID0gcmVsYXRpdmVUbztcbiAgICAgICAgICAgIHJlbGF0aXZlVG8gPSBUb1RlbXBvcmFsRGF0ZShyZWxhdGl2ZVRvKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghSXNUZW1wb3JhbERhdGUocmVsYXRpdmVUbykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3N0YXJ0aW5nIHBvaW50IG11c3QgYmUgUGxhaW5EYXRlIG9yIFpvbmVkRGF0ZVRpbWUnKTtcbiAgICAgICAgfVxuICAgICAgICBjYWxlbmRhciA9IEdldFNsb3QocmVsYXRpdmVUbywgQ0FMRU5EQVIpO1xuICAgIH1cbiAgICAvLyBGaXJzdCBjb252ZXJ0IHRpbWUgdW5pdHMgdXAgdG8gZGF5cywgaWYgcm91bmRpbmcgdG8gZGF5cyBvciBoaWdoZXIgdW5pdHMuXG4gICAgLy8gSWYgcm91bmRpbmcgcmVsYXRpdmUgdG8gYSBab25lZERhdGVUaW1lLCB0aGVuIHNvbWUgZGF5cyBtYXkgbm90IGJlIDI0aC5cbiAgICAvLyBUUyBkb2Vzbid0IGtub3cgdGhhdCBgZGF5TGVuZ3RoTnNgIGlzIG9ubHkgdXNlZCBpZiB0aGUgdW5pdCBpcyBkYXkgb3JcbiAgICAvLyBsYXJnZXIuIFdlJ2xsIGNhc3QgYXdheSBgdW5kZWZpbmVkYCB3aGVuIGl0J3MgdXNlZCBsb3dlciBkb3duIGJlbG93LlxuICAgIGxldCBkYXlMZW5ndGhOcztcbiAgICBpZiAodW5pdCA9PT0gJ3llYXInIHx8IHVuaXQgPT09ICdtb250aCcgfHwgdW5pdCA9PT0gJ3dlZWsnIHx8IHVuaXQgPT09ICdkYXknKSB7XG4gICAgICAgIG5hbm9zZWNvbmRzID0gVG90YWxEdXJhdGlvbk5hbm9zZWNvbmRzKDAsIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBtaWxsaXNlY29uZHMsIG1pY3Jvc2Vjb25kcywgbmFub3NlY29uZHNQYXJhbSwgMCk7XG4gICAgICAgIGxldCBpbnRlcm1lZGlhdGU7XG4gICAgICAgIGlmICh6ZHRSZWxhdGl2ZSkge1xuICAgICAgICAgICAgaW50ZXJtZWRpYXRlID0gTW92ZVJlbGF0aXZlWm9uZWREYXRlVGltZSh6ZHRSZWxhdGl2ZSwgeWVhcnMsIG1vbnRocywgd2Vla3MsIGRheXMpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBkZWx0YURheXM7XG4gICAgICAgIGxldCBkYXlMZW5ndGg7XG4gICAgICAgICh7IGRheXM6IGRlbHRhRGF5cywgbmFub3NlY29uZHMsIGRheUxlbmd0aE5zOiBkYXlMZW5ndGggfSA9IE5hbm9zZWNvbmRzVG9EYXlzKG5hbm9zZWNvbmRzLCBpbnRlcm1lZGlhdGUpKTtcbiAgICAgICAgZGF5TGVuZ3RoTnMgPSBKU0JJLkJpZ0ludChkYXlMZW5ndGgpO1xuICAgICAgICBkYXlzICs9IGRlbHRhRGF5cztcbiAgICAgICAgaG91cnMgPSBtaW51dGVzID0gc2Vjb25kcyA9IG1pbGxpc2Vjb25kcyA9IG1pY3Jvc2Vjb25kcyA9IDA7XG4gICAgfVxuICAgIGxldCB0b3RhbDtcbiAgICBzd2l0Y2ggKHVuaXQpIHtcbiAgICAgICAgY2FzZSAneWVhcic6IHtcbiAgICAgICAgICAgIGlmICghY2FsZW5kYXIpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0Egc3RhcnRpbmcgcG9pbnQgaXMgcmVxdWlyZWQgZm9yIHllYXJzIHJvdW5kaW5nJyk7XG4gICAgICAgICAgICAvLyBjb252ZXJ0IG1vbnRocyBhbmQgd2Vla3MgdG8gZGF5cyBieSBjYWxjdWxhdGluZyBkaWZmZXJlbmNlKFxuICAgICAgICAgICAgLy8gcmVsYXRpdmVUbyArIHllYXJzLCByZWxhdGl2ZVRvICsgeyB5ZWFycywgbW9udGhzLCB3ZWVrcyB9KVxuICAgICAgICAgICAgY29uc3QgeWVhcnNEdXJhdGlvbiA9IG5ldyBUZW1wb3JhbER1cmF0aW9uKHllYXJzKTtcbiAgICAgICAgICAgIGNvbnN0IGRhdGVBZGQgPSBjYWxlbmRhci5kYXRlQWRkO1xuICAgICAgICAgICAgY29uc3QgZmlyc3RBZGRPcHRpb25zID0gT2JqZWN0Q3JlYXRlJDIobnVsbCk7XG4gICAgICAgICAgICBjb25zdCB5ZWFyc0xhdGVyID0gQ2FsZW5kYXJEYXRlQWRkKGNhbGVuZGFyLCByZWxhdGl2ZVRvLCB5ZWFyc0R1cmF0aW9uLCBmaXJzdEFkZE9wdGlvbnMsIGRhdGVBZGQpO1xuICAgICAgICAgICAgY29uc3QgeWVhcnNNb250aHNXZWVrcyA9IG5ldyBUZW1wb3JhbER1cmF0aW9uKHllYXJzLCBtb250aHMsIHdlZWtzKTtcbiAgICAgICAgICAgIGNvbnN0IHNlY29uZEFkZE9wdGlvbnMgPSBPYmplY3RDcmVhdGUkMihudWxsKTtcbiAgICAgICAgICAgIGNvbnN0IHllYXJzTW9udGhzV2Vla3NMYXRlciA9IENhbGVuZGFyRGF0ZUFkZChjYWxlbmRhciwgcmVsYXRpdmVUbywgeWVhcnNNb250aHNXZWVrcywgc2Vjb25kQWRkT3B0aW9ucywgZGF0ZUFkZCk7XG4gICAgICAgICAgICBjb25zdCBtb250aHNXZWVrc0luRGF5cyA9IERheXNVbnRpbCh5ZWFyc0xhdGVyLCB5ZWFyc01vbnRoc1dlZWtzTGF0ZXIpO1xuICAgICAgICAgICAgcmVsYXRpdmVUbyA9IHllYXJzTGF0ZXI7XG4gICAgICAgICAgICBkYXlzICs9IG1vbnRoc1dlZWtzSW5EYXlzO1xuICAgICAgICAgICAgY29uc3QgdGhpcmRBZGRPcHRpb25zID0gT2JqZWN0Q3JlYXRlJDIobnVsbCk7XG4gICAgICAgICAgICBjb25zdCBkYXlzTGF0ZXIgPSBDYWxlbmRhckRhdGVBZGQoY2FsZW5kYXIsIHJlbGF0aXZlVG8sIHsgZGF5cyB9LCB0aGlyZEFkZE9wdGlvbnMsIGRhdGVBZGQpO1xuICAgICAgICAgICAgY29uc3QgdW50aWxPcHRpb25zID0gT2JqZWN0Q3JlYXRlJDIobnVsbCk7XG4gICAgICAgICAgICB1bnRpbE9wdGlvbnMubGFyZ2VzdFVuaXQgPSAneWVhcic7XG4gICAgICAgICAgICBjb25zdCB5ZWFyc1Bhc3NlZCA9IENhbGVuZGFyRGF0ZVVudGlsKGNhbGVuZGFyLCByZWxhdGl2ZVRvLCBkYXlzTGF0ZXIsIHVudGlsT3B0aW9ucykueWVhcnM7XG4gICAgICAgICAgICB5ZWFycyArPSB5ZWFyc1Bhc3NlZDtcbiAgICAgICAgICAgIGNvbnN0IG9sZFJlbGF0aXZlVG8gPSByZWxhdGl2ZVRvO1xuICAgICAgICAgICAgY29uc3QgZm91cnRoQWRkT3B0aW9ucyA9IE9iamVjdENyZWF0ZSQyKG51bGwpO1xuICAgICAgICAgICAgcmVsYXRpdmVUbyA9IENhbGVuZGFyRGF0ZUFkZChjYWxlbmRhciwgcmVsYXRpdmVUbywgeyB5ZWFyczogeWVhcnNQYXNzZWQgfSwgZm91cnRoQWRkT3B0aW9ucywgZGF0ZUFkZCk7XG4gICAgICAgICAgICBjb25zdCBkYXlzUGFzc2VkID0gRGF5c1VudGlsKG9sZFJlbGF0aXZlVG8sIHJlbGF0aXZlVG8pO1xuICAgICAgICAgICAgZGF5cyAtPSBkYXlzUGFzc2VkO1xuICAgICAgICAgICAgY29uc3Qgb25lWWVhciA9IG5ldyBUZW1wb3JhbER1cmF0aW9uKGRheXMgPCAwID8gLTEgOiAxKTtcbiAgICAgICAgICAgIGxldCB7IGRheXM6IG9uZVllYXJEYXlzIH0gPSBNb3ZlUmVsYXRpdmVEYXRlKGNhbGVuZGFyLCByZWxhdGl2ZVRvLCBvbmVZZWFyKTtcbiAgICAgICAgICAgIC8vIE5vdGUgdGhhdCBgbmFub3NlY29uZHNgIGJlbG93IChoZXJlIGFuZCBpbiBzaW1pbGFyIGNvZGUgZm9yIG1vbnRocyxcbiAgICAgICAgICAgIC8vIHdlZWtzLCBhbmQgZGF5cyBmdXJ0aGVyIGJlbG93KSBpc24ndCBhY3R1YWxseSBuYW5vc2Vjb25kcyBmb3IgdGhlXG4gICAgICAgICAgICAvLyBmdWxsIGRhdGUgcmFuZ2UuICBJbnN0ZWFkLCBpdCdzIGEgQmlnSW50IHJlcHJlc2VudGF0aW9uIG9mIHRvdGFsXG4gICAgICAgICAgICAvLyBkYXlzIG11bHRpcGxpZWQgYnkgdGhlIG51bWJlciBvZiBuYW5vc2Vjb25kcyBpbiB0aGUgbGFzdCBkYXkgb2ZcbiAgICAgICAgICAgIC8vIHRoZSBkdXJhdGlvbi4gVGhpcyBsZXRzIHVzIGRvIGRheXMtb3ItbGFyZ2VyIHJvdW5kaW5nIHVzaW5nIEJpZ0ludFxuICAgICAgICAgICAgLy8gbWF0aCB3aGljaCByZWR1Y2VzIHByZWNpc2lvbiBsb3NzLlxuICAgICAgICAgICAgb25lWWVhckRheXMgPSBNYXRoQWJzKG9uZVllYXJEYXlzKTtcbiAgICAgICAgICAgIC8vIGRheUxlbmd0aE5zIGlzIG5ldmVyIHVuZGVmaW5lZCBpZiB1bml0IGlzIGBkYXlgIG9yIGxhcmdlci5cbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICAgICAgICBjb25zdCBkaXZpc29yID0gSlNCSS5tdWx0aXBseShKU0JJLkJpZ0ludChvbmVZZWFyRGF5cyksIGRheUxlbmd0aE5zKTtcbiAgICAgICAgICAgIG5hbm9zZWNvbmRzID0gSlNCSS5hZGQoXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgICAgICAgSlNCSS5hZGQoSlNCSS5tdWx0aXBseShkaXZpc29yLCBKU0JJLkJpZ0ludCh5ZWFycykpLCBKU0JJLm11bHRpcGx5KEpTQkkuQmlnSW50KGRheXMpLCBkYXlMZW5ndGhOcykpLCBuYW5vc2Vjb25kcyk7XG4gICAgICAgICAgICBjb25zdCByb3VuZGVkID0gUm91bmROdW1iZXJUb0luY3JlbWVudChuYW5vc2Vjb25kcywgSlNCSS50b051bWJlcihKU0JJLm11bHRpcGx5KGRpdmlzb3IsIEpTQkkuQmlnSW50KGluY3JlbWVudCkpKSwgcm91bmRpbmdNb2RlKTtcbiAgICAgICAgICAgIHRvdGFsID0gSlNCSS50b051bWJlcihuYW5vc2Vjb25kcykgLyBKU0JJLnRvTnVtYmVyKGRpdmlzb3IpO1xuICAgICAgICAgICAgeWVhcnMgPSBKU0JJLnRvTnVtYmVyKEpTQkkuZGl2aWRlKHJvdW5kZWQsIGRpdmlzb3IpKTtcbiAgICAgICAgICAgIG5hbm9zZWNvbmRzID0gWkVSTztcbiAgICAgICAgICAgIG1vbnRocyA9IHdlZWtzID0gZGF5cyA9IDA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdtb250aCc6IHtcbiAgICAgICAgICAgIGlmICghY2FsZW5kYXIpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0Egc3RhcnRpbmcgcG9pbnQgaXMgcmVxdWlyZWQgZm9yIG1vbnRocyByb3VuZGluZycpO1xuICAgICAgICAgICAgLy8gY29udmVydCB3ZWVrcyB0byBkYXlzIGJ5IGNhbGN1bGF0aW5nIGRpZmZlcmVuY2UocmVsYXRpdmVUbyArXG4gICAgICAgICAgICAvLyAgIHsgeWVhcnMsIG1vbnRocyB9LCByZWxhdGl2ZVRvICsgeyB5ZWFycywgbW9udGhzLCB3ZWVrcyB9KVxuICAgICAgICAgICAgY29uc3QgeWVhcnNNb250aHMgPSBuZXcgVGVtcG9yYWxEdXJhdGlvbih5ZWFycywgbW9udGhzKTtcbiAgICAgICAgICAgIGNvbnN0IGRhdGVBZGQgPSBjYWxlbmRhci5kYXRlQWRkO1xuICAgICAgICAgICAgY29uc3QgZmlyc3RBZGRPcHRpb25zID0gT2JqZWN0Q3JlYXRlJDIobnVsbCk7XG4gICAgICAgICAgICBjb25zdCB5ZWFyc01vbnRoc0xhdGVyID0gQ2FsZW5kYXJEYXRlQWRkKGNhbGVuZGFyLCByZWxhdGl2ZVRvLCB5ZWFyc01vbnRocywgZmlyc3RBZGRPcHRpb25zLCBkYXRlQWRkKTtcbiAgICAgICAgICAgIGNvbnN0IHllYXJzTW9udGhzV2Vla3MgPSBuZXcgVGVtcG9yYWxEdXJhdGlvbih5ZWFycywgbW9udGhzLCB3ZWVrcyk7XG4gICAgICAgICAgICBjb25zdCBzZWNvbmRBZGRPcHRpb25zID0gT2JqZWN0Q3JlYXRlJDIobnVsbCk7XG4gICAgICAgICAgICBjb25zdCB5ZWFyc01vbnRoc1dlZWtzTGF0ZXIgPSBDYWxlbmRhckRhdGVBZGQoY2FsZW5kYXIsIHJlbGF0aXZlVG8sIHllYXJzTW9udGhzV2Vla3MsIHNlY29uZEFkZE9wdGlvbnMsIGRhdGVBZGQpO1xuICAgICAgICAgICAgY29uc3Qgd2Vla3NJbkRheXMgPSBEYXlzVW50aWwoeWVhcnNNb250aHNMYXRlciwgeWVhcnNNb250aHNXZWVrc0xhdGVyKTtcbiAgICAgICAgICAgIHJlbGF0aXZlVG8gPSB5ZWFyc01vbnRoc0xhdGVyO1xuICAgICAgICAgICAgZGF5cyArPSB3ZWVrc0luRGF5cztcbiAgICAgICAgICAgIC8vIE1vbnRocyBtYXkgYmUgZGlmZmVyZW50IGxlbmd0aHMgb2YgZGF5cyBkZXBlbmRpbmcgb24gdGhlIGNhbGVuZGFyLFxuICAgICAgICAgICAgLy8gY29udmVydCBkYXlzIHRvIG1vbnRocyBpbiBhIGxvb3AgYXMgZGVzY3JpYmVkIGFib3ZlIHVuZGVyICd5ZWFycycuXG4gICAgICAgICAgICBjb25zdCBzaWduID0gTWF0aFNpZ24oZGF5cyk7XG4gICAgICAgICAgICBjb25zdCBvbmVNb250aCA9IG5ldyBUZW1wb3JhbER1cmF0aW9uKDAsIGRheXMgPCAwID8gLTEgOiAxKTtcbiAgICAgICAgICAgIGxldCBvbmVNb250aERheXM7XG4gICAgICAgICAgICAoeyByZWxhdGl2ZVRvLCBkYXlzOiBvbmVNb250aERheXMgfSA9IE1vdmVSZWxhdGl2ZURhdGUoY2FsZW5kYXIsIHJlbGF0aXZlVG8sIG9uZU1vbnRoKSk7XG4gICAgICAgICAgICB3aGlsZSAoTWF0aEFicyhkYXlzKSA+PSBNYXRoQWJzKG9uZU1vbnRoRGF5cykpIHtcbiAgICAgICAgICAgICAgICBtb250aHMgKz0gc2lnbjtcbiAgICAgICAgICAgICAgICBkYXlzIC09IG9uZU1vbnRoRGF5cztcbiAgICAgICAgICAgICAgICAoeyByZWxhdGl2ZVRvLCBkYXlzOiBvbmVNb250aERheXMgfSA9IE1vdmVSZWxhdGl2ZURhdGUoY2FsZW5kYXIsIHJlbGF0aXZlVG8sIG9uZU1vbnRoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvbmVNb250aERheXMgPSBNYXRoQWJzKG9uZU1vbnRoRGF5cyk7XG4gICAgICAgICAgICAvLyBkYXlMZW5ndGhOcyBpcyBuZXZlciB1bmRlZmluZWQgaWYgdW5pdCBpcyBgZGF5YCBvciBsYXJnZXIuXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgICAgICAgY29uc3QgZGl2aXNvciA9IEpTQkkubXVsdGlwbHkoSlNCSS5CaWdJbnQob25lTW9udGhEYXlzKSwgZGF5TGVuZ3RoTnMpO1xuICAgICAgICAgICAgbmFub3NlY29uZHMgPSBKU0JJLmFkZChcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICAgICAgICBKU0JJLmFkZChKU0JJLm11bHRpcGx5KGRpdmlzb3IsIEpTQkkuQmlnSW50KG1vbnRocykpLCBKU0JJLm11bHRpcGx5KEpTQkkuQmlnSW50KGRheXMpLCBkYXlMZW5ndGhOcykpLCBuYW5vc2Vjb25kcyk7XG4gICAgICAgICAgICBjb25zdCByb3VuZGVkID0gUm91bmROdW1iZXJUb0luY3JlbWVudChuYW5vc2Vjb25kcywgSlNCSS50b051bWJlcihKU0JJLm11bHRpcGx5KGRpdmlzb3IsIEpTQkkuQmlnSW50KGluY3JlbWVudCkpKSwgcm91bmRpbmdNb2RlKTtcbiAgICAgICAgICAgIHRvdGFsID0gSlNCSS50b051bWJlcihuYW5vc2Vjb25kcykgLyBKU0JJLnRvTnVtYmVyKGRpdmlzb3IpO1xuICAgICAgICAgICAgbW9udGhzID0gSlNCSS50b051bWJlcihKU0JJLmRpdmlkZShyb3VuZGVkLCBkaXZpc29yKSk7XG4gICAgICAgICAgICBuYW5vc2Vjb25kcyA9IFpFUk87XG4gICAgICAgICAgICB3ZWVrcyA9IGRheXMgPSAwO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnd2Vlayc6IHtcbiAgICAgICAgICAgIGlmICghY2FsZW5kYXIpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0Egc3RhcnRpbmcgcG9pbnQgaXMgcmVxdWlyZWQgZm9yIHdlZWtzIHJvdW5kaW5nJyk7XG4gICAgICAgICAgICAvLyBXZWVrcyBtYXkgYmUgZGlmZmVyZW50IGxlbmd0aHMgb2YgZGF5cyBkZXBlbmRpbmcgb24gdGhlIGNhbGVuZGFyLFxuICAgICAgICAgICAgLy8gY29udmVydCBkYXlzIHRvIHdlZWtzIGluIGEgbG9vcCBhcyBkZXNjcmliZWQgYWJvdmUgdW5kZXIgJ3llYXJzJy5cbiAgICAgICAgICAgIGNvbnN0IHNpZ24gPSBNYXRoU2lnbihkYXlzKTtcbiAgICAgICAgICAgIGNvbnN0IG9uZVdlZWsgPSBuZXcgVGVtcG9yYWxEdXJhdGlvbigwLCAwLCBkYXlzIDwgMCA/IC0xIDogMSk7XG4gICAgICAgICAgICBsZXQgb25lV2Vla0RheXM7XG4gICAgICAgICAgICAoeyByZWxhdGl2ZVRvLCBkYXlzOiBvbmVXZWVrRGF5cyB9ID0gTW92ZVJlbGF0aXZlRGF0ZShjYWxlbmRhciwgcmVsYXRpdmVUbywgb25lV2VlaykpO1xuICAgICAgICAgICAgd2hpbGUgKE1hdGhBYnMoZGF5cykgPj0gTWF0aEFicyhvbmVXZWVrRGF5cykpIHtcbiAgICAgICAgICAgICAgICB3ZWVrcyArPSBzaWduO1xuICAgICAgICAgICAgICAgIGRheXMgLT0gb25lV2Vla0RheXM7XG4gICAgICAgICAgICAgICAgKHsgcmVsYXRpdmVUbywgZGF5czogb25lV2Vla0RheXMgfSA9IE1vdmVSZWxhdGl2ZURhdGUoY2FsZW5kYXIsIHJlbGF0aXZlVG8sIG9uZVdlZWspKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9uZVdlZWtEYXlzID0gTWF0aEFicyhvbmVXZWVrRGF5cyk7XG4gICAgICAgICAgICAvLyBkYXlMZW5ndGhOcyBpcyBuZXZlciB1bmRlZmluZWQgaWYgdW5pdCBpcyBgZGF5YCBvciBsYXJnZXIuXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgICAgICAgY29uc3QgZGl2aXNvciA9IEpTQkkubXVsdGlwbHkoSlNCSS5CaWdJbnQob25lV2Vla0RheXMpLCBkYXlMZW5ndGhOcyk7XG4gICAgICAgICAgICBuYW5vc2Vjb25kcyA9IEpTQkkuYWRkKFxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICAgICAgICAgIEpTQkkuYWRkKEpTQkkubXVsdGlwbHkoZGl2aXNvciwgSlNCSS5CaWdJbnQod2Vla3MpKSwgSlNCSS5tdWx0aXBseShKU0JJLkJpZ0ludChkYXlzKSwgZGF5TGVuZ3RoTnMpKSwgbmFub3NlY29uZHMpO1xuICAgICAgICAgICAgY29uc3Qgcm91bmRlZCA9IFJvdW5kTnVtYmVyVG9JbmNyZW1lbnQobmFub3NlY29uZHMsIEpTQkkudG9OdW1iZXIoSlNCSS5tdWx0aXBseShkaXZpc29yLCBKU0JJLkJpZ0ludChpbmNyZW1lbnQpKSksIHJvdW5kaW5nTW9kZSk7XG4gICAgICAgICAgICB0b3RhbCA9IEpTQkkudG9OdW1iZXIobmFub3NlY29uZHMpIC8gSlNCSS50b051bWJlcihkaXZpc29yKTtcbiAgICAgICAgICAgIHdlZWtzID0gSlNCSS50b051bWJlcihKU0JJLmRpdmlkZShyb3VuZGVkLCBkaXZpc29yKSk7XG4gICAgICAgICAgICBuYW5vc2Vjb25kcyA9IFpFUk87XG4gICAgICAgICAgICBkYXlzID0gMDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ2RheSc6IHtcbiAgICAgICAgICAgIC8vIGRheUxlbmd0aE5zIGlzIG5ldmVyIHVuZGVmaW5lZCBpZiB1bml0IGlzIGBkYXlgIG9yIGxhcmdlci5cbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICAgICAgICBjb25zdCBkaXZpc29yID0gZGF5TGVuZ3RoTnM7XG4gICAgICAgICAgICBuYW5vc2Vjb25kcyA9IEpTQkkuYWRkKEpTQkkubXVsdGlwbHkoZGl2aXNvciwgSlNCSS5CaWdJbnQoZGF5cykpLCBuYW5vc2Vjb25kcyk7XG4gICAgICAgICAgICBjb25zdCByb3VuZGVkID0gUm91bmROdW1iZXJUb0luY3JlbWVudChuYW5vc2Vjb25kcywgSlNCSS50b051bWJlcihKU0JJLm11bHRpcGx5KGRpdmlzb3IsIEpTQkkuQmlnSW50KGluY3JlbWVudCkpKSwgcm91bmRpbmdNb2RlKTtcbiAgICAgICAgICAgIHRvdGFsID0gSlNCSS50b051bWJlcihuYW5vc2Vjb25kcykgLyBKU0JJLnRvTnVtYmVyKGRpdmlzb3IpO1xuICAgICAgICAgICAgZGF5cyA9IEpTQkkudG9OdW1iZXIoSlNCSS5kaXZpZGUocm91bmRlZCwgZGl2aXNvcikpO1xuICAgICAgICAgICAgbmFub3NlY29uZHMgPSBaRVJPO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnaG91cic6IHtcbiAgICAgICAgICAgIGNvbnN0IGRpdmlzb3IgPSAzNjAwZTk7XG4gICAgICAgICAgICBsZXQgYWxsTmFub3NlY29uZHMgPSBKU0JJLm11bHRpcGx5KEpTQkkuQmlnSW50KGhvdXJzKSwgSlNCSS5CaWdJbnQoMzYwMGU5KSk7XG4gICAgICAgICAgICBhbGxOYW5vc2Vjb25kcyA9IEpTQkkuYWRkKGFsbE5hbm9zZWNvbmRzLCBKU0JJLm11bHRpcGx5KEpTQkkuQmlnSW50KG1pbnV0ZXMpLCBKU0JJLkJpZ0ludCg2MGU5KSkpO1xuICAgICAgICAgICAgYWxsTmFub3NlY29uZHMgPSBKU0JJLmFkZChhbGxOYW5vc2Vjb25kcywgSlNCSS5tdWx0aXBseShKU0JJLkJpZ0ludChzZWNvbmRzKSwgQklMTElPTikpO1xuICAgICAgICAgICAgYWxsTmFub3NlY29uZHMgPSBKU0JJLmFkZChhbGxOYW5vc2Vjb25kcywgSlNCSS5tdWx0aXBseShKU0JJLkJpZ0ludChtaWxsaXNlY29uZHMpLCBNSUxMSU9OKSk7XG4gICAgICAgICAgICBhbGxOYW5vc2Vjb25kcyA9IEpTQkkuYWRkKGFsbE5hbm9zZWNvbmRzLCBKU0JJLm11bHRpcGx5KEpTQkkuQmlnSW50KG1pY3Jvc2Vjb25kcyksIFRIT1VTQU5EKSk7XG4gICAgICAgICAgICBhbGxOYW5vc2Vjb25kcyA9IEpTQkkuYWRkKGFsbE5hbm9zZWNvbmRzLCBuYW5vc2Vjb25kcyk7XG4gICAgICAgICAgICB0b3RhbCA9IEpTQkkudG9OdW1iZXIoYWxsTmFub3NlY29uZHMpIC8gZGl2aXNvcjtcbiAgICAgICAgICAgIGNvbnN0IHJvdW5kZWQgPSBSb3VuZE51bWJlclRvSW5jcmVtZW50KGFsbE5hbm9zZWNvbmRzLCBkaXZpc29yICogaW5jcmVtZW50LCByb3VuZGluZ01vZGUpO1xuICAgICAgICAgICAgaG91cnMgPSBKU0JJLnRvTnVtYmVyKEpTQkkuZGl2aWRlKHJvdW5kZWQsIEpTQkkuQmlnSW50KGRpdmlzb3IpKSk7XG4gICAgICAgICAgICBuYW5vc2Vjb25kcyA9IFpFUk87XG4gICAgICAgICAgICBtaW51dGVzID0gc2Vjb25kcyA9IG1pbGxpc2Vjb25kcyA9IG1pY3Jvc2Vjb25kcyA9IDA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdtaW51dGUnOiB7XG4gICAgICAgICAgICBjb25zdCBkaXZpc29yID0gNjBlOTtcbiAgICAgICAgICAgIGxldCBhbGxOYW5vc2Vjb25kcyA9IEpTQkkubXVsdGlwbHkoSlNCSS5CaWdJbnQobWludXRlcyksIEpTQkkuQmlnSW50KDYwZTkpKTtcbiAgICAgICAgICAgIGFsbE5hbm9zZWNvbmRzID0gSlNCSS5hZGQoYWxsTmFub3NlY29uZHMsIEpTQkkubXVsdGlwbHkoSlNCSS5CaWdJbnQoc2Vjb25kcyksIEJJTExJT04pKTtcbiAgICAgICAgICAgIGFsbE5hbm9zZWNvbmRzID0gSlNCSS5hZGQoYWxsTmFub3NlY29uZHMsIEpTQkkubXVsdGlwbHkoSlNCSS5CaWdJbnQobWlsbGlzZWNvbmRzKSwgTUlMTElPTikpO1xuICAgICAgICAgICAgYWxsTmFub3NlY29uZHMgPSBKU0JJLmFkZChhbGxOYW5vc2Vjb25kcywgSlNCSS5tdWx0aXBseShKU0JJLkJpZ0ludChtaWNyb3NlY29uZHMpLCBUSE9VU0FORCkpO1xuICAgICAgICAgICAgYWxsTmFub3NlY29uZHMgPSBKU0JJLmFkZChhbGxOYW5vc2Vjb25kcywgbmFub3NlY29uZHMpO1xuICAgICAgICAgICAgdG90YWwgPSBKU0JJLnRvTnVtYmVyKGFsbE5hbm9zZWNvbmRzKSAvIGRpdmlzb3I7XG4gICAgICAgICAgICBjb25zdCByb3VuZGVkID0gUm91bmROdW1iZXJUb0luY3JlbWVudChhbGxOYW5vc2Vjb25kcywgZGl2aXNvciAqIGluY3JlbWVudCwgcm91bmRpbmdNb2RlKTtcbiAgICAgICAgICAgIG1pbnV0ZXMgPSBKU0JJLnRvTnVtYmVyKEpTQkkuZGl2aWRlKHJvdW5kZWQsIEpTQkkuQmlnSW50KGRpdmlzb3IpKSk7XG4gICAgICAgICAgICBuYW5vc2Vjb25kcyA9IFpFUk87XG4gICAgICAgICAgICBzZWNvbmRzID0gbWlsbGlzZWNvbmRzID0gbWljcm9zZWNvbmRzID0gMDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ3NlY29uZCc6IHtcbiAgICAgICAgICAgIGNvbnN0IGRpdmlzb3IgPSAxZTk7XG4gICAgICAgICAgICBsZXQgYWxsTmFub3NlY29uZHMgPSBKU0JJLm11bHRpcGx5KEpTQkkuQmlnSW50KHNlY29uZHMpLCBCSUxMSU9OKTtcbiAgICAgICAgICAgIGFsbE5hbm9zZWNvbmRzID0gSlNCSS5hZGQoYWxsTmFub3NlY29uZHMsIEpTQkkubXVsdGlwbHkoSlNCSS5CaWdJbnQobWlsbGlzZWNvbmRzKSwgTUlMTElPTikpO1xuICAgICAgICAgICAgYWxsTmFub3NlY29uZHMgPSBKU0JJLmFkZChhbGxOYW5vc2Vjb25kcywgSlNCSS5tdWx0aXBseShKU0JJLkJpZ0ludChtaWNyb3NlY29uZHMpLCBUSE9VU0FORCkpO1xuICAgICAgICAgICAgYWxsTmFub3NlY29uZHMgPSBKU0JJLmFkZChhbGxOYW5vc2Vjb25kcywgbmFub3NlY29uZHMpO1xuICAgICAgICAgICAgdG90YWwgPSBKU0JJLnRvTnVtYmVyKGFsbE5hbm9zZWNvbmRzKSAvIGRpdmlzb3I7XG4gICAgICAgICAgICBjb25zdCByb3VuZGVkID0gUm91bmROdW1iZXJUb0luY3JlbWVudChhbGxOYW5vc2Vjb25kcywgZGl2aXNvciAqIGluY3JlbWVudCwgcm91bmRpbmdNb2RlKTtcbiAgICAgICAgICAgIHNlY29uZHMgPSBKU0JJLnRvTnVtYmVyKEpTQkkuZGl2aWRlKHJvdW5kZWQsIEpTQkkuQmlnSW50KGRpdmlzb3IpKSk7XG4gICAgICAgICAgICBuYW5vc2Vjb25kcyA9IFpFUk87XG4gICAgICAgICAgICBtaWxsaXNlY29uZHMgPSBtaWNyb3NlY29uZHMgPSAwO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnbWlsbGlzZWNvbmQnOiB7XG4gICAgICAgICAgICBjb25zdCBkaXZpc29yID0gMWU2O1xuICAgICAgICAgICAgbGV0IGFsbE5hbm9zZWNvbmRzID0gSlNCSS5tdWx0aXBseShKU0JJLkJpZ0ludChtaWxsaXNlY29uZHMpLCBNSUxMSU9OKTtcbiAgICAgICAgICAgIGFsbE5hbm9zZWNvbmRzID0gSlNCSS5hZGQoYWxsTmFub3NlY29uZHMsIEpTQkkubXVsdGlwbHkoSlNCSS5CaWdJbnQobWljcm9zZWNvbmRzKSwgVEhPVVNBTkQpKTtcbiAgICAgICAgICAgIGFsbE5hbm9zZWNvbmRzID0gSlNCSS5hZGQoYWxsTmFub3NlY29uZHMsIG5hbm9zZWNvbmRzKTtcbiAgICAgICAgICAgIHRvdGFsID0gSlNCSS50b051bWJlcihhbGxOYW5vc2Vjb25kcykgLyBkaXZpc29yO1xuICAgICAgICAgICAgY29uc3Qgcm91bmRlZCA9IFJvdW5kTnVtYmVyVG9JbmNyZW1lbnQoYWxsTmFub3NlY29uZHMsIGRpdmlzb3IgKiBpbmNyZW1lbnQsIHJvdW5kaW5nTW9kZSk7XG4gICAgICAgICAgICBtaWxsaXNlY29uZHMgPSBKU0JJLnRvTnVtYmVyKEpTQkkuZGl2aWRlKHJvdW5kZWQsIEpTQkkuQmlnSW50KGRpdmlzb3IpKSk7XG4gICAgICAgICAgICBuYW5vc2Vjb25kcyA9IFpFUk87XG4gICAgICAgICAgICBtaWNyb3NlY29uZHMgPSAwO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnbWljcm9zZWNvbmQnOiB7XG4gICAgICAgICAgICBjb25zdCBkaXZpc29yID0gMWUzO1xuICAgICAgICAgICAgbGV0IGFsbE5hbm9zZWNvbmRzID0gSlNCSS5tdWx0aXBseShKU0JJLkJpZ0ludChtaWNyb3NlY29uZHMpLCBUSE9VU0FORCk7XG4gICAgICAgICAgICBhbGxOYW5vc2Vjb25kcyA9IEpTQkkuYWRkKGFsbE5hbm9zZWNvbmRzLCBuYW5vc2Vjb25kcyk7XG4gICAgICAgICAgICB0b3RhbCA9IEpTQkkudG9OdW1iZXIoYWxsTmFub3NlY29uZHMpIC8gZGl2aXNvcjtcbiAgICAgICAgICAgIGNvbnN0IHJvdW5kZWQgPSBSb3VuZE51bWJlclRvSW5jcmVtZW50KGFsbE5hbm9zZWNvbmRzLCBkaXZpc29yICogaW5jcmVtZW50LCByb3VuZGluZ01vZGUpO1xuICAgICAgICAgICAgbWljcm9zZWNvbmRzID0gSlNCSS50b051bWJlcihKU0JJLmRpdmlkZShyb3VuZGVkLCBKU0JJLkJpZ0ludChkaXZpc29yKSkpO1xuICAgICAgICAgICAgbmFub3NlY29uZHMgPSBaRVJPO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnbmFub3NlY29uZCc6IHtcbiAgICAgICAgICAgIHRvdGFsID0gSlNCSS50b051bWJlcihuYW5vc2Vjb25kcyk7XG4gICAgICAgICAgICBuYW5vc2Vjb25kcyA9IFJvdW5kTnVtYmVyVG9JbmNyZW1lbnQobmFub3NlY29uZHMsIGluY3JlbWVudCwgcm91bmRpbmdNb2RlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHllYXJzLFxuICAgICAgICBtb250aHMsXG4gICAgICAgIHdlZWtzLFxuICAgICAgICBkYXlzLFxuICAgICAgICBob3VycyxcbiAgICAgICAgbWludXRlcyxcbiAgICAgICAgc2Vjb25kcyxcbiAgICAgICAgbWlsbGlzZWNvbmRzLFxuICAgICAgICBtaWNyb3NlY29uZHMsXG4gICAgICAgIG5hbm9zZWNvbmRzOiBKU0JJLnRvTnVtYmVyKG5hbm9zZWNvbmRzKSxcbiAgICAgICAgdG90YWxcbiAgICB9O1xufVxuZnVuY3Rpb24gQ29tcGFyZUlTT0RhdGUoeTEsIG0xLCBkMSwgeTIsIG0yLCBkMikge1xuICAgIGZvciAoY29uc3QgW3gsIHldIG9mIFtcbiAgICAgICAgW3kxLCB5Ml0sXG4gICAgICAgIFttMSwgbTJdLFxuICAgICAgICBbZDEsIGQyXVxuICAgIF0pIHtcbiAgICAgICAgaWYgKHggIT09IHkpXG4gICAgICAgICAgICByZXR1cm4gQ29tcGFyaXNvblJlc3VsdCh4IC0geSk7XG4gICAgfVxuICAgIHJldHVybiAwO1xufVxuZnVuY3Rpb24gTm9uTmVnYXRpdmVNb2R1bG8oeCwgeSkge1xuICAgIGxldCByZXN1bHQgPSB4ICUgeTtcbiAgICBpZiAoT2JqZWN0SXMocmVzdWx0LCAtMCkpXG4gICAgICAgIHJldHVybiAwO1xuICAgIGlmIChyZXN1bHQgPCAwKVxuICAgICAgICByZXN1bHQgKz0geTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gVG9CaWdJbnRFeHRlcm5hbChhcmcpIHtcbiAgICBjb25zdCBqc2JpQkkgPSBUb0JpZ0ludChhcmcpO1xuICAgIGlmICh0eXBlb2YgZ2xvYmFsVGhpcy5CaWdJbnQgIT09ICd1bmRlZmluZWQnKVxuICAgICAgICByZXR1cm4gZ2xvYmFsVGhpcy5CaWdJbnQoanNiaUJJLnRvU3RyaW5nKDEwKSk7XG4gICAgcmV0dXJuIGpzYmlCSTtcbn1cbmZ1bmN0aW9uIFRvQmlnSW50KGFyZykge1xuICAgIGlmIChhcmcgaW5zdGFuY2VvZiBKU0JJKSB7XG4gICAgICAgIHJldHVybiBhcmc7XG4gICAgfVxuICAgIGxldCBwcmltID0gYXJnO1xuICAgIGlmICh0eXBlb2YgYXJnID09PSAnb2JqZWN0Jykge1xuICAgICAgICBjb25zdCB0b1ByaW1GbiA9IGFyZ1tTeW1ib2wudG9QcmltaXRpdmVdO1xuICAgICAgICBpZiAodG9QcmltRm4gJiYgdHlwZW9mIHRvUHJpbUZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBwcmltID0gUmVmbGVjdEFwcGx5JDEodG9QcmltRm4sIGFyZywgWydudW1iZXInXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3dpdGNoICh0eXBlb2YgcHJpbSkge1xuICAgICAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICBjYXNlICdzeW1ib2wnOlxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgY2Fubm90IGNvbnZlcnQgJHt0eXBlb2YgYXJnfSB0byBiaWdpbnRgKTtcbiAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgIGlmICghcHJpbS5tYXRjaCgvXlxccyooPzpbKy1dP1xcZCtcXHMqKT8kLykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ2ludmFsaWQgQmlnSW50IHN5bnRheCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAvLyBlc2xpbnQ6IG5vLWZhbGx0aHJvdWdoOiBmYWxzZVxuICAgICAgICBjYXNlICdiaWdpbnQnOlxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gSlNCSS5CaWdJbnQocHJpbS50b1N0cmluZygpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBFcnJvciAmJiBlLm1lc3NhZ2Uuc3RhcnRzV2l0aCgnSW52YWxpZCBpbnRlZ2VyJykpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihlLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAgaWYgKHByaW0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gT05FO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFpFUk87XG4gICAgICAgICAgICB9XG4gICAgfVxufVxuLy8gTm90ZTogVGhpcyBtZXRob2QgcmV0dXJucyB2YWx1ZXMgd2l0aCBib2d1cyBuYW5vc2Vjb25kcyBiYXNlZCBvbiB0aGUgcHJldmlvdXMgaXRlcmF0aW9uJ3Ncbi8vIG1pbGxpc2Vjb25kcy4gVGhhdCB3YXkgdGhlcmUgaXMgYSBndWFyYW50ZWUgdGhhdCB0aGUgZnVsbCBuYW5vc2Vjb25kcyBhcmUgYWx3YXlzIGdvaW5nIHRvIGJlXG4vLyBpbmNyZWFzaW5nIGF0IGxlYXN0IGFuZCB0aGF0IHRoZSBtaWNyb3NlY29uZCBhbmQgbmFub3NlY29uZCBmaWVsZHMgYXJlIGxpa2VseSB0byBiZSBub24temVyby5cbmNvbnN0IFN5c3RlbVVUQ0Vwb2NoTmFub1NlY29uZHMgPSAoKCkgPT4ge1xuICAgIGxldCBucyA9IEpTQkkuQmlnSW50KERhdGUubm93KCkgJSAxZTYpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGNvbnN0IG1zID0gSlNCSS5CaWdJbnQoRGF0ZS5ub3coKSk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IEpTQkkuYWRkKEpTQkkubXVsdGlwbHkobXMsIE1JTExJT04pLCBucyk7XG4gICAgICAgIG5zID0gSlNCSS5kaXZpZGUobXMsIE1JTExJT04pO1xuICAgICAgICBpZiAoSlNCSS5ncmVhdGVyVGhhbihyZXN1bHQsIE5TX01BWCkpXG4gICAgICAgICAgICByZXR1cm4gTlNfTUFYO1xuICAgICAgICBpZiAoSlNCSS5sZXNzVGhhbihyZXN1bHQsIE5TX01JTikpXG4gICAgICAgICAgICByZXR1cm4gTlNfTUlOO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG59KSgpO1xuZnVuY3Rpb24gU3lzdGVtVGltZVpvbmUoKSB7XG4gICAgY29uc3QgZm10ID0gbmV3IEludGxEYXRlVGltZUZvcm1hdCQxKCdlbi11cycpO1xuICAgIGNvbnN0IFRlbXBvcmFsVGltZVpvbmUgPSBHZXRJbnRyaW5zaWMoJyVUZW1wb3JhbC5UaW1lWm9uZSUnKTtcbiAgICByZXR1cm4gbmV3IFRlbXBvcmFsVGltZVpvbmUoUGFyc2VUZW1wb3JhbFRpbWVab25lKGZtdC5yZXNvbHZlZE9wdGlvbnMoKS50aW1lWm9uZSkpO1xufVxuZnVuY3Rpb24gQ29tcGFyaXNvblJlc3VsdCh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA8IDAgPyAtMSA6IHZhbHVlID4gMCA/IDEgOiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIEdldE9wdGlvbnNPYmplY3Qob3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiBPYmplY3RDcmVhdGUkMihudWxsKTtcbiAgICBpZiAoSXNPYmplY3Qob3B0aW9ucykgJiYgb3B0aW9ucyAhPT0gbnVsbClcbiAgICAgICAgcmV0dXJuIG9wdGlvbnM7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgT3B0aW9ucyBwYXJhbWV0ZXIgbXVzdCBiZSBhbiBvYmplY3QsIG5vdCAke29wdGlvbnMgPT09IG51bGwgPyAnbnVsbCcgOiBgJHt0eXBlb2Ygb3B0aW9uc31gfWApO1xufVxuZnVuY3Rpb24gQ3JlYXRlT25lUHJvcE9iamVjdChwcm9wTmFtZSwgcHJvcFZhbHVlKSB7XG4gICAgY29uc3QgbyA9IE9iamVjdENyZWF0ZSQyKG51bGwpO1xuICAgIG9bcHJvcE5hbWVdID0gcHJvcFZhbHVlO1xuICAgIHJldHVybiBvO1xufVxuZnVuY3Rpb24gR2V0T3B0aW9uKG9wdGlvbnMsIHByb3BlcnR5LCBhbGxvd2VkVmFsdWVzLCBmYWxsYmFjaykge1xuICAgIGxldCB2YWx1ZSA9IG9wdGlvbnNbcHJvcGVydHldO1xuICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhbHVlID0gVG9TdHJpbmcodmFsdWUpO1xuICAgICAgICBpZiAoIWFsbG93ZWRWYWx1ZXMuaW5jbHVkZXModmFsdWUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgJHtwcm9wZXJ0eX0gbXVzdCBiZSBvbmUgb2YgJHthbGxvd2VkVmFsdWVzLmpvaW4oJywgJyl9LCBub3QgJHt2YWx1ZX1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxsYmFjaztcbn1cbmZ1bmN0aW9uIEdldE51bWJlck9wdGlvbihvcHRpb25zLCBwcm9wZXJ0eSwgbWluaW11bSwgbWF4aW11bSwgZmFsbGJhY2spIHtcbiAgICBsZXQgdmFsdWVSYXcgPSBvcHRpb25zW3Byb3BlcnR5XTtcbiAgICBpZiAodmFsdWVSYXcgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIGZhbGxiYWNrO1xuICAgIGNvbnN0IHZhbHVlID0gVG9OdW1iZXIodmFsdWVSYXcpO1xuICAgIGlmIChOdW1iZXJJc05hTih2YWx1ZSkgfHwgdmFsdWUgPCBtaW5pbXVtIHx8IHZhbHVlID4gbWF4aW11bSkge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgJHtwcm9wZXJ0eX0gbXVzdCBiZSBiZXR3ZWVuICR7bWluaW11bX0gYW5kICR7bWF4aW11bX0sIG5vdCAke3ZhbHVlfWApO1xuICAgIH1cbiAgICByZXR1cm4gTWF0aEZsb29yKHZhbHVlKTtcbn1cbmNvbnN0IE9GRlNFVCA9IG5ldyBSZWdFeHAoYF4ke29mZnNldC5zb3VyY2V9JGApO1xuZnVuY3Rpb24gYmlzZWN0KGdldFN0YXRlLCBsZWZ0UGFyYW0sIHJpZ2h0UGFyYW0sIGxzdGF0ZVBhcmFtID0gZ2V0U3RhdGUobGVmdFBhcmFtKSwgcnN0YXRlUGFyYW0gPSBnZXRTdGF0ZShyaWdodFBhcmFtKSkge1xuICAgIC8vIFRoaXMgZG9lc24ndCBtYWtlIG11Y2ggc2Vuc2UgLSB3aHkgZG8gdGhlc2UgZ2V0IGNvbnZlcnRlZCB1bm5lY2Vzc2FyaWx5P1xuICAgIGxldCBsZWZ0ID0gSlNCSS5CaWdJbnQobGVmdFBhcmFtKTtcbiAgICBsZXQgcmlnaHQgPSBKU0JJLkJpZ0ludChyaWdodFBhcmFtKTtcbiAgICBsZXQgbHN0YXRlID0gbHN0YXRlUGFyYW07XG4gICAgbGV0IHJzdGF0ZSA9IHJzdGF0ZVBhcmFtO1xuICAgIHdoaWxlIChKU0JJLmdyZWF0ZXJUaGFuKEpTQkkuc3VidHJhY3QocmlnaHQsIGxlZnQpLCBPTkUpKSB7XG4gICAgICAgIGNvbnN0IG1pZGRsZSA9IEpTQkkuZGl2aWRlKEpTQkkuYWRkKGxlZnQsIHJpZ2h0KSwgSlNCSS5CaWdJbnQoMikpO1xuICAgICAgICBjb25zdCBtc3RhdGUgPSBnZXRTdGF0ZShtaWRkbGUpO1xuICAgICAgICBpZiAobXN0YXRlID09PSBsc3RhdGUpIHtcbiAgICAgICAgICAgIGxlZnQgPSBtaWRkbGU7XG4gICAgICAgICAgICBsc3RhdGUgPSBtc3RhdGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobXN0YXRlID09PSByc3RhdGUpIHtcbiAgICAgICAgICAgIHJpZ2h0ID0gbWlkZGxlO1xuICAgICAgICAgICAgcnN0YXRlID0gbXN0YXRlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIHN0YXRlIGluIGJpc2VjdGlvbiAke2xzdGF0ZX0gLSAke21zdGF0ZX0gLSAke3JzdGF0ZX1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmlnaHQ7XG59XG5jb25zdCBuc1BlclRpbWVVbml0ID0ge1xuICAgIGhvdXI6IDM2MDBlOSxcbiAgICBtaW51dGU6IDYwZTksXG4gICAgc2Vjb25kOiAxZTksXG4gICAgbWlsbGlzZWNvbmQ6IDFlNixcbiAgICBtaWNyb3NlY29uZDogMWUzLFxuICAgIG5hbm9zZWNvbmQ6IDFcbn07XG5cbmNvbnN0IERBVEUgPSBTeW1ib2woJ2RhdGUnKTtcbmNvbnN0IFlNID0gU3ltYm9sKCd5bScpO1xuY29uc3QgTUQgPSBTeW1ib2woJ21kJyk7XG5jb25zdCBUSU1FID0gU3ltYm9sKCd0aW1lJyk7XG5jb25zdCBEQVRFVElNRSA9IFN5bWJvbCgnZGF0ZXRpbWUnKTtcbmNvbnN0IFpPTkVEID0gU3ltYm9sKCd6b25lZGRhdGV0aW1lJyk7XG5jb25zdCBJTlNUID0gU3ltYm9sKCdpbnN0YW50Jyk7XG5jb25zdCBPUklHSU5BTCA9IFN5bWJvbCgnb3JpZ2luYWwnKTtcbmNvbnN0IFRaX1JFU09MVkVEID0gU3ltYm9sKCd0aW1lem9uZScpO1xuY29uc3QgVFpfR0lWRU4gPSBTeW1ib2woJ3RpbWV6b25lLWlkLWdpdmVuJyk7XG5jb25zdCBDQUxfSUQgPSBTeW1ib2woJ2NhbGVuZGFyLWlkJyk7XG5jb25zdCBMT0NBTEUgPSBTeW1ib2woJ2xvY2FsZScpO1xuY29uc3QgT1BUSU9OUyA9IFN5bWJvbCgnb3B0aW9ucycpO1xuY29uc3QgZGVzY3JpcHRvciA9ICh2YWx1ZSkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH07XG59O1xuY29uc3QgSW50bERhdGVUaW1lRm9ybWF0ID0gZ2xvYmFsVGhpcy5JbnRsLkRhdGVUaW1lRm9ybWF0O1xuY29uc3QgT2JqZWN0QXNzaWduJDEgPSBPYmplY3QuYXNzaWduO1xuY29uc3QgT2JqZWN0SGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuY29uc3QgUmVmbGVjdEFwcGx5ID0gUmVmbGVjdC5hcHBseTtcbi8vIENvbnN0cnVjdGlvbiBvZiBidWlsdC1pbiBJbnRsLkRhdGVUaW1lRm9ybWF0IG9iamVjdHMgaXMgc2xvb29vb293LFxuLy8gc28gd2UnbGwgb25seSBjcmVhdGUgdGhvc2UgaW5zdGFuY2VzIHdoZW4gd2UgbmVlZCB0aGVtLlxuLy8gU2VlIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTY1MjhcbmZ1bmN0aW9uIGdldFByb3BMYXp5KG9iaiwgcHJvcCkge1xuICAgIGxldCB2YWwgPSBvYmpbcHJvcF07XG4gICAgaWYgKHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gSWYgd2UgZ2V0IGhlcmUsIGB2YWxgIGlzIGFuIFwiYW1lbmRlciBmdW5jdGlvblwiLiBJdCB3aWxsIHRha2UgdGhlIHVzZXInc1xuICAgICAgICAvLyBvcHRpb25zIGFuZCB0cmFuc2Zvcm0gdGhlbSBpbnRvIHN1aXRhYmxlIG9wdGlvbnMgdG8gYmUgcGFzc2VkIGludG8gdGhlXG4gICAgICAgIC8vIGJ1aWx0LWluIChub24tcG9seWZpbGwpIEludGwuRGF0ZVRpbWVGb3JtYXQgY29uc3RydWN0b3IuIFRoZXNlIG9wdGlvbnNcbiAgICAgICAgLy8gd2lsbCB2YXJ5IGRlcGVuZGluZyBvbiB0aGUgVGVtcG9yYWwgdHlwZSwgc28gdGhhdCdzIHdoeSB3ZSBzdG9yZSBzZXBhcmF0ZVxuICAgICAgICAvLyBmb3JtYXR0ZXJzIGluIHNlcGFyYXRlIHByb3BzIG9uIHRoZSBwb2x5ZmlsbCdzIERhdGVUaW1lRm9ybWF0IGluc3RhbmNlcy5cbiAgICAgICAgLy8gVGhlIGVmZmljaWVuY3kgaGFwcGVucyBiZWNhdXNlIHdlIGRvbid0IGNyZWF0ZSBhbiAoZXhwZW5zaXZlKSBmb3JtYXR0ZXJcbiAgICAgICAgLy8gdW50aWwgdGhlIHVzZXIgY2FsbHMgdG9Mb2NhbGVTdHJpbmcgZm9yIHRoYXQgVGVtcG9yYWwgdHlwZS5cbiAgICAgICAgdmFsID0gbmV3IEludGxEYXRlVGltZUZvcm1hdChvYmpbTE9DQUxFXSwgdmFsKG9ialtPUFRJT05TXSkpO1xuICAgICAgICAvLyBUT0RPOiBjYW4gdGhpcyBiZSB0eXBlZCBtb3JlIGNsZWFubHk/XG4gICAgICAgIG9ialtwcm9wXSA9IHZhbDtcbiAgICB9XG4gICAgcmV0dXJuIHZhbDtcbn1cbi8vIFNpbWlsYXJseSwgbGF6eS1pbml0IFRpbWVab25lIGluc3RhbmNlcy5cbmZ1bmN0aW9uIGdldFJlc29sdmVkVGltZVpvbmVMYXp5KG9iaikge1xuICAgIGxldCB2YWwgPSBvYmpbVFpfUkVTT0xWRURdO1xuICAgIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgICAgICB2YWwgPSBUb1RlbXBvcmFsVGltZVpvbmUodmFsKTtcbiAgICAgICAgb2JqW1RaX1JFU09MVkVEXSA9IHZhbDtcbiAgICB9XG4gICAgcmV0dXJuIHZhbDtcbn1cbmZ1bmN0aW9uIERhdGVUaW1lRm9ybWF0SW1wbChsb2NhbGUgPSB1bmRlZmluZWQsIG9wdGlvbnNQYXJhbSA9IHt9KSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIERhdGVUaW1lRm9ybWF0SW1wbCkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlVGltZUZvcm1hdEltcGwobG9jYWxlLCBvcHRpb25zUGFyYW0pO1xuICAgIH1cbiAgICBjb25zdCBoYXNPcHRpb25zID0gdHlwZW9mIG9wdGlvbnNQYXJhbSAhPT0gJ3VuZGVmaW5lZCc7XG4gICAgY29uc3Qgb3B0aW9ucyA9IGhhc09wdGlvbnMgPyBPYmplY3RBc3NpZ24kMSh7fSwgb3B0aW9uc1BhcmFtKSA6IHt9O1xuICAgIC8vIFRPRE86IHJlbW92ZSB0eXBlIGFzc2VydGlvbiBhZnRlciBUZW1wb3JhbCB0eXBlcyBsYW5kIGluIFRTIGxpYiB0eXBlc1xuICAgIGNvbnN0IG9yaWdpbmFsID0gbmV3IEludGxEYXRlVGltZUZvcm1hdChsb2NhbGUsIG9wdGlvbnMpO1xuICAgIGNvbnN0IHJvID0gb3JpZ2luYWwucmVzb2x2ZWRPcHRpb25zKCk7XG4gICAgLy8gRGF0ZVRpbWVGb3JtYXQgaW5zdGFuY2VzIGFyZSB2ZXJ5IGV4cGVuc2l2ZSB0byBjcmVhdGUuIFRoZXJlZm9yZSwgdGhleSB3aWxsXG4gICAgLy8gYmUgbGF6aWx5IGNyZWF0ZWQgb25seSB3aGVuIG5lZWRlZCwgdXNpbmcgdGhlIGxvY2FsZSBhbmQgb3B0aW9ucyBwcm92aWRlZC5cbiAgICAvLyBCdXQgaXQncyBwb3NzaWJsZSBmb3IgY2FsbGVycyB0byBtdXRhdGUgdGhvc2UgaW5wdXRzIGJlZm9yZSBsYXp5IGNyZWF0aW9uXG4gICAgLy8gaGFwcGVucy4gRm9yIHRoaXMgcmVhc29uLCB3ZSBjbG9uZSB0aGUgaW5wdXRzIGluc3RlYWQgb2YgY2FjaGluZyB0aGVcbiAgICAvLyBvcmlnaW5hbCBvYmplY3RzLiBUbyBhdm9pZCB0aGUgY29tcGxleGl0eSBvZiBkZWVwIGNsb25pbmcgYW55IGlucHV0cyB0aGF0XG4gICAgLy8gYXJlIHRoZW1zZWx2ZXMgb2JqZWN0cyAoZS5nLiB0aGUgbG9jYWxlcyBhcnJheSwgb3Igb3B0aW9ucyBwcm9wZXJ0eSB2YWx1ZXNcbiAgICAvLyB0aGF0IHdpbGwgYmUgY29lcmNlZCB0byBzdHJpbmdzKSwgd2UgcmVseSBvbiBgcmVzb2x2ZWRPcHRpb25zKClgIHRvIGRvIHRoZVxuICAgIC8vIGNvZXJjaW9uIGFuZCBjbG9uaW5nIGZvciB1cy4gVW5mb3J0dW5hdGVseSwgd2UgY2FuJ3QganVzdCB1c2UgdGhlIHJlc29sdmVkXG4gICAgLy8gb3B0aW9ucyBhcy1pcyBiZWNhdXNlIG91ciBvcHRpb25zLWFtZW5kaW5nIGxvZ2ljIGFkZHMgYWRkaXRpb25hbCBmaWVsZHMgaWZcbiAgICAvLyB0aGUgdXNlciBkb2Vzbid0IHN1cHBseSBhbnkgdW5pdCBmaWVsZHMgbGlrZSB5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBldGMuXG4gICAgLy8gVGhlcmVmb3JlLCB3ZSBsaW1pdCB0aGUgcHJvcGVydGllcyBpbiB0aGUgY2xvbmUgdG8gcHJvcGVydGllcyB0aGF0IHdlcmVcbiAgICAvLyBwcmVzZW50IGluIHRoZSBvcmlnaW5hbCBpbnB1dC5cbiAgICBpZiAoaGFzT3B0aW9ucykge1xuICAgICAgICBjb25zdCBjbG9uZWRSZXNvbHZlZCA9IE9iamVjdEFzc2lnbiQxKHt9LCBybyk7XG4gICAgICAgIGZvciAoY29uc3QgcHJvcCBpbiBjbG9uZWRSZXNvbHZlZCkge1xuICAgICAgICAgICAgaWYgKCFSZWZsZWN0QXBwbHkoT2JqZWN0SGFzT3duUHJvcGVydHksIG9wdGlvbnMsIFtwcm9wXSkpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgY2xvbmVkUmVzb2x2ZWRbcHJvcF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpc1tPUFRJT05TXSA9IGNsb25lZFJlc29sdmVkO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhpc1tPUFRJT05TXSA9IG9wdGlvbnM7XG4gICAgfVxuICAgIHRoaXNbVFpfR0lWRU5dID0gb3B0aW9ucy50aW1lWm9uZSA/IG9wdGlvbnMudGltZVpvbmUgOiBudWxsO1xuICAgIHRoaXNbTE9DQUxFXSA9IHJvLmxvY2FsZTtcbiAgICB0aGlzW09SSUdJTkFMXSA9IG9yaWdpbmFsO1xuICAgIHRoaXNbVFpfUkVTT0xWRURdID0gcm8udGltZVpvbmU7XG4gICAgdGhpc1tDQUxfSURdID0gcm8uY2FsZW5kYXI7XG4gICAgdGhpc1tEQVRFXSA9IGRhdGVBbWVuZDtcbiAgICB0aGlzW1lNXSA9IHllYXJNb250aEFtZW5kO1xuICAgIHRoaXNbTURdID0gbW9udGhEYXlBbWVuZDtcbiAgICB0aGlzW1RJTUVdID0gdGltZUFtZW5kO1xuICAgIHRoaXNbREFURVRJTUVdID0gZGF0ZXRpbWVBbWVuZDtcbiAgICB0aGlzW1pPTkVEXSA9IHpvbmVkRGF0ZVRpbWVBbWVuZDtcbiAgICB0aGlzW0lOU1RdID0gaW5zdGFudEFtZW5kO1xuICAgIHJldHVybiB1bmRlZmluZWQ7IC8vIFRPRE86IEkgY291bGRuJ3Qgc2F0aXNmeSBUUyB3aXRob3V0IGFkZGluZyB0aGlzLiBJcyB0aGVyZSBhbm90aGVyIHdheT9cbn1cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShEYXRlVGltZUZvcm1hdEltcGwsICduYW1lJywge1xuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiAnRGF0ZVRpbWVGb3JtYXQnXG59KTtcbkRhdGVUaW1lRm9ybWF0SW1wbC5zdXBwb3J0ZWRMb2NhbGVzT2YgPSBmdW5jdGlvbiAobG9jYWxlcywgb3B0aW9ucykge1xuICAgIHJldHVybiBJbnRsRGF0ZVRpbWVGb3JtYXQuc3VwcG9ydGVkTG9jYWxlc09mKGxvY2FsZXMsIG9wdGlvbnMpO1xufTtcbmNvbnN0IHByb3BlcnRpZXMgPSB7XG4gICAgcmVzb2x2ZWRPcHRpb25zOiBkZXNjcmlwdG9yKHJlc29sdmVkT3B0aW9ucyksXG4gICAgZm9ybWF0OiBkZXNjcmlwdG9yKGZvcm1hdCksXG4gICAgZm9ybWF0UmFuZ2U6IGRlc2NyaXB0b3IoZm9ybWF0UmFuZ2UpXG59O1xuaWYgKCdmb3JtYXRUb1BhcnRzJyBpbiBJbnRsRGF0ZVRpbWVGb3JtYXQucHJvdG90eXBlKSB7XG4gICAgcHJvcGVydGllcy5mb3JtYXRUb1BhcnRzID0gZGVzY3JpcHRvcihmb3JtYXRUb1BhcnRzKTtcbn1cbmlmICgnZm9ybWF0UmFuZ2VUb1BhcnRzJyBpbiBJbnRsRGF0ZVRpbWVGb3JtYXQucHJvdG90eXBlKSB7XG4gICAgcHJvcGVydGllcy5mb3JtYXRSYW5nZVRvUGFydHMgPSBkZXNjcmlwdG9yKGZvcm1hdFJhbmdlVG9QYXJ0cyk7XG59XG5EYXRlVGltZUZvcm1hdEltcGwucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShJbnRsRGF0ZVRpbWVGb3JtYXQucHJvdG90eXBlLCBwcm9wZXJ0aWVzKTtcbi8vIEVuc3VyZSB0aGF0IHRoZSBwcm90b3R5cGUgaXNuJ3Qgd3JpdGVhYmxlLlxuT2JqZWN0LmRlZmluZVByb3BlcnR5KERhdGVUaW1lRm9ybWF0SW1wbCwgJ3Byb3RvdHlwZScsIHtcbiAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiBmYWxzZVxufSk7XG5jb25zdCBEYXRlVGltZUZvcm1hdCA9IERhdGVUaW1lRm9ybWF0SW1wbDtcbmZ1bmN0aW9uIHJlc29sdmVkT3B0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpc1tPUklHSU5BTF0ucmVzb2x2ZWRPcHRpb25zKCk7XG59XG5mdW5jdGlvbiBhZGp1c3RGb3JtYXR0ZXJUaW1lWm9uZShmb3JtYXR0ZXIsIHRpbWVab25lKSB7XG4gICAgaWYgKCF0aW1lWm9uZSlcbiAgICAgICAgcmV0dXJuIGZvcm1hdHRlcjtcbiAgICBjb25zdCBvcHRpb25zID0gZm9ybWF0dGVyLnJlc29sdmVkT3B0aW9ucygpO1xuICAgIGlmIChvcHRpb25zLnRpbWVab25lID09PSB0aW1lWm9uZSlcbiAgICAgICAgcmV0dXJuIGZvcm1hdHRlcjtcbiAgICAvLyBFeGlzdGluZyBJbnRsIGlzbid0IHR5cGVkIHRvIGFjY2VwdCBUZW1wb3JhbC1zcGVjaWZpYyBvcHRpb25zLCBidXQgd2lsbCBub3RcbiAgICAvLyBicmVhayBhdCBydW50aW1lIGlmIHdlIHBhc3MgdGhlbS4gQWxzbywgdGhlIGxpYiB0eXBlcyBmb3IgcmVzb2x2ZWQgb3B0aW9uc1xuICAgIC8vIGFyZSBsZXNzIHJlc3RyaWN0aXZlIHRoYW4gdGhlIHR5cGVzIGZvciBvcHRpb25zLiBGb3IgZXhhbXBsZSwgYHdlZWtkYXlgIGlzXG4gICAgLy8gYCdsb25nJyB8ICdzaG9ydCcgfCAnbmFycm93J2AgaW4gb3B0aW9ucyBidXQgYHN0cmluZ2AgaW4gcmVzb2x2ZWQgb3B0aW9ucy5cbiAgICAvLyBUT0RPOiBpbnZlc3RpZ2F0ZSB3aHksIGFuZCBmaWxlIGFuIGlzc3VlIGFnYWluc3QgVFMgaWYgaXQncyBhIGJ1Zy5cbiAgICByZXR1cm4gbmV3IEludGxEYXRlVGltZUZvcm1hdChvcHRpb25zLmxvY2FsZSwgeyAuLi5vcHRpb25zLCB0aW1lWm9uZSB9KTtcbn1cbi8vIFRPRE86IGludmVzdGlnYXRlIHdoeSB0aGVyZSdzIGEgcmVzdCBwYXJhbWV0ZXIgaGVyZS4gRG9lcyB0aGlzIGZ1bmN0aW9uIHJlYWxseSBuZWVkIHRvIGFjY2VwdCBleHRyYSBwYXJhbXM/XG4vLyBBbmQgaWYgc28sIHdoeSBkb2Vzbid0IGZvcm1hdFJhbmdlIGFsc28gYWNjZXB0IGV4dHJhIHBhcmFtcz9cbmZ1bmN0aW9uIGZvcm1hdChkYXRldGltZSwgLi4ucmVzdCkge1xuICAgIGxldCB7IGluc3RhbnQsIGZvcm1hdHRlciwgdGltZVpvbmUgfSA9IGV4dHJhY3RPdmVycmlkZXMoZGF0ZXRpbWUsIHRoaXMpO1xuICAgIGlmIChpbnN0YW50ICYmIGZvcm1hdHRlcikge1xuICAgICAgICBmb3JtYXR0ZXIgPSBhZGp1c3RGb3JtYXR0ZXJUaW1lWm9uZShmb3JtYXR0ZXIsIHRpbWVab25lKTtcbiAgICAgICAgcmV0dXJuIGZvcm1hdHRlci5mb3JtYXQoaW5zdGFudC5lcG9jaE1pbGxpc2Vjb25kcyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzW09SSUdJTkFMXS5mb3JtYXQoZGF0ZXRpbWUsIC4uLnJlc3QpO1xufVxuZnVuY3Rpb24gZm9ybWF0VG9QYXJ0cyhkYXRldGltZSwgLi4ucmVzdCkge1xuICAgIGxldCB7IGluc3RhbnQsIGZvcm1hdHRlciwgdGltZVpvbmUgfSA9IGV4dHJhY3RPdmVycmlkZXMoZGF0ZXRpbWUsIHRoaXMpO1xuICAgIGlmIChpbnN0YW50ICYmIGZvcm1hdHRlcikge1xuICAgICAgICBmb3JtYXR0ZXIgPSBhZGp1c3RGb3JtYXR0ZXJUaW1lWm9uZShmb3JtYXR0ZXIsIHRpbWVab25lKTtcbiAgICAgICAgcmV0dXJuIGZvcm1hdHRlci5mb3JtYXRUb1BhcnRzKGluc3RhbnQuZXBvY2hNaWxsaXNlY29uZHMpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpc1tPUklHSU5BTF0uZm9ybWF0VG9QYXJ0cyhkYXRldGltZSwgLi4ucmVzdCk7XG59XG5mdW5jdGlvbiBmb3JtYXRSYW5nZShhLCBiKSB7XG4gICAgaWYgKGlzVGVtcG9yYWxPYmplY3QoYSkgfHwgaXNUZW1wb3JhbE9iamVjdChiKSkge1xuICAgICAgICBpZiAoIXNhbWVUZW1wb3JhbFR5cGUoYSwgYikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludGwuRGF0ZVRpbWVGb3JtYXQuZm9ybWF0UmFuZ2UgYWNjZXB0cyB0d28gdmFsdWVzIG9mIHRoZSBzYW1lIHR5cGUnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IGluc3RhbnQ6IGFhLCBmb3JtYXR0ZXI6IGFmb3JtYXR0ZXIsIHRpbWVab25lOiBhdHogfSA9IGV4dHJhY3RPdmVycmlkZXMoYSwgdGhpcyk7XG4gICAgICAgIGNvbnN0IHsgaW5zdGFudDogYmIsIGZvcm1hdHRlcjogYmZvcm1hdHRlciwgdGltZVpvbmU6IGJ0eiB9ID0gZXh0cmFjdE92ZXJyaWRlcyhiLCB0aGlzKTtcbiAgICAgICAgaWYgKGF0eiAmJiBidHogJiYgYXR6ICE9PSBidHopIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdjYW5ub3QgZm9ybWF0IHJhbmdlIGJldHdlZW4gZGlmZmVyZW50IHRpbWUgem9uZXMnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYWEgJiYgYmIgJiYgYWZvcm1hdHRlciAmJiBiZm9ybWF0dGVyICYmIGFmb3JtYXR0ZXIgPT09IGJmb3JtYXR0ZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IGZvcm1hdHRlciA9IGFkanVzdEZvcm1hdHRlclRpbWVab25lKGFmb3JtYXR0ZXIsIGF0eik7XG4gICAgICAgICAgICAvLyBUT0RPOiBSZW1vdmUgdHlwZSBhc3NlcnRpb24gYWZ0ZXIgdGhpcyBtZXRob2QgbGFuZHMgaW4gVFMgbGliIHR5cGVzXG4gICAgICAgICAgICByZXR1cm4gZm9ybWF0dGVyLmZvcm1hdFJhbmdlKGFhLmVwb2NoTWlsbGlzZWNvbmRzLCBiYi5lcG9jaE1pbGxpc2Vjb25kcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gVE9ETzogUmVtb3ZlIHR5cGUgYXNzZXJ0aW9uIGFmdGVyIHRoaXMgbWV0aG9kIGxhbmRzIGluIFRTIGxpYiB0eXBlc1xuICAgIHJldHVybiB0aGlzW09SSUdJTkFMXS5mb3JtYXRSYW5nZShhLCBiKTtcbn1cbmZ1bmN0aW9uIGZvcm1hdFJhbmdlVG9QYXJ0cyhhLCBiKSB7XG4gICAgaWYgKGlzVGVtcG9yYWxPYmplY3QoYSkgfHwgaXNUZW1wb3JhbE9iamVjdChiKSkge1xuICAgICAgICBpZiAoIXNhbWVUZW1wb3JhbFR5cGUoYSwgYikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludGwuRGF0ZVRpbWVGb3JtYXQuZm9ybWF0UmFuZ2VUb1BhcnRzIGFjY2VwdHMgdHdvIHZhbHVlcyBvZiB0aGUgc2FtZSB0eXBlJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBpbnN0YW50OiBhYSwgZm9ybWF0dGVyOiBhZm9ybWF0dGVyLCB0aW1lWm9uZTogYXR6IH0gPSBleHRyYWN0T3ZlcnJpZGVzKGEsIHRoaXMpO1xuICAgICAgICBjb25zdCB7IGluc3RhbnQ6IGJiLCBmb3JtYXR0ZXI6IGJmb3JtYXR0ZXIsIHRpbWVab25lOiBidHogfSA9IGV4dHJhY3RPdmVycmlkZXMoYiwgdGhpcyk7XG4gICAgICAgIGlmIChhdHogJiYgYnR6ICYmIGF0eiAhPT0gYnR6KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignY2Fubm90IGZvcm1hdCByYW5nZSBiZXR3ZWVuIGRpZmZlcmVudCB0aW1lIHpvbmVzJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFhICYmIGJiICYmIGFmb3JtYXR0ZXIgJiYgYmZvcm1hdHRlciAmJiBhZm9ybWF0dGVyID09PSBiZm9ybWF0dGVyKSB7XG4gICAgICAgICAgICBjb25zdCBmb3JtYXR0ZXIgPSBhZGp1c3RGb3JtYXR0ZXJUaW1lWm9uZShhZm9ybWF0dGVyLCBhdHopO1xuICAgICAgICAgICAgLy8gVE9ETzogUmVtb3ZlIHR5cGUgYXNzZXJ0aW9uIGFmdGVyIHRoaXMgbWV0aG9kIGxhbmRzIGluIFRTIGxpYiB0eXBlc1xuICAgICAgICAgICAgcmV0dXJuIGZvcm1hdHRlci5mb3JtYXRSYW5nZVRvUGFydHMoYWEuZXBvY2hNaWxsaXNlY29uZHMsIGJiLmVwb2NoTWlsbGlzZWNvbmRzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBUT0RPOiBSZW1vdmUgdHlwZSBhc3NlcnRpb24gYWZ0ZXIgdGhpcyBtZXRob2QgbGFuZHMgaW4gVFMgbGliIHR5cGVzXG4gICAgcmV0dXJuIHRoaXNbT1JJR0lOQUxdLmZvcm1hdFJhbmdlVG9QYXJ0cyhhLCBiKTtcbn1cbmZ1bmN0aW9uIGFtZW5kKG9wdGlvbnNQYXJhbSA9IHt9LCBhbWVuZGVkID0ge30pIHtcbiAgICBjb25zdCBvcHRpb25zID0gT2JqZWN0QXNzaWduJDEoe30sIG9wdGlvbnNQYXJhbSk7XG4gICAgZm9yIChjb25zdCBvcHQgb2YgW1xuICAgICAgICAneWVhcicsXG4gICAgICAgICdtb250aCcsXG4gICAgICAgICdkYXknLFxuICAgICAgICAnaG91cicsXG4gICAgICAgICdtaW51dGUnLFxuICAgICAgICAnc2Vjb25kJyxcbiAgICAgICAgJ3dlZWtkYXknLFxuICAgICAgICAnZGF5UGVyaW9kJyxcbiAgICAgICAgJ3RpbWVab25lTmFtZScsXG4gICAgICAgICdkYXRlU3R5bGUnLFxuICAgICAgICAndGltZVN0eWxlJ1xuICAgIF0pIHtcbiAgICAgICAgb3B0aW9uc1tvcHRdID0gb3B0IGluIGFtZW5kZWQgPyBhbWVuZGVkW29wdF0gOiBvcHRpb25zW29wdF07XG4gICAgICAgIGlmIChvcHRpb25zW29wdF0gPT09IGZhbHNlIHx8IG9wdGlvbnNbb3B0XSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgZGVsZXRlIG9wdGlvbnNbb3B0XTtcbiAgICB9XG4gICAgcmV0dXJuIG9wdGlvbnM7XG59XG5mdW5jdGlvbiB0aW1lQW1lbmQob3B0aW9uc1BhcmFtKSB7XG4gICAgbGV0IG9wdGlvbnMgPSBhbWVuZChvcHRpb25zUGFyYW0sIHtcbiAgICAgICAgeWVhcjogZmFsc2UsXG4gICAgICAgIG1vbnRoOiBmYWxzZSxcbiAgICAgICAgZGF5OiBmYWxzZSxcbiAgICAgICAgd2Vla2RheTogZmFsc2UsXG4gICAgICAgIHRpbWVab25lTmFtZTogZmFsc2UsXG4gICAgICAgIGRhdGVTdHlsZTogZmFsc2VcbiAgICB9KTtcbiAgICBpZiAoIWhhc1RpbWVPcHRpb25zKG9wdGlvbnMpKSB7XG4gICAgICAgIG9wdGlvbnMgPSBPYmplY3RBc3NpZ24kMSh7fSwgb3B0aW9ucywge1xuICAgICAgICAgICAgaG91cjogJ251bWVyaWMnLFxuICAgICAgICAgICAgbWludXRlOiAnbnVtZXJpYycsXG4gICAgICAgICAgICBzZWNvbmQ6ICdudW1lcmljJ1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG9wdGlvbnM7XG59XG5mdW5jdGlvbiB5ZWFyTW9udGhBbWVuZChvcHRpb25zUGFyYW0pIHtcbiAgICBsZXQgb3B0aW9ucyA9IGFtZW5kKG9wdGlvbnNQYXJhbSwge1xuICAgICAgICBkYXk6IGZhbHNlLFxuICAgICAgICBob3VyOiBmYWxzZSxcbiAgICAgICAgbWludXRlOiBmYWxzZSxcbiAgICAgICAgc2Vjb25kOiBmYWxzZSxcbiAgICAgICAgd2Vla2RheTogZmFsc2UsXG4gICAgICAgIGRheVBlcmlvZDogZmFsc2UsXG4gICAgICAgIHRpbWVab25lTmFtZTogZmFsc2UsXG4gICAgICAgIGRhdGVTdHlsZTogZmFsc2UsXG4gICAgICAgIHRpbWVTdHlsZTogZmFsc2VcbiAgICB9KTtcbiAgICBpZiAoISgneWVhcicgaW4gb3B0aW9ucyB8fCAnbW9udGgnIGluIG9wdGlvbnMpKSB7XG4gICAgICAgIG9wdGlvbnMgPSBPYmplY3RBc3NpZ24kMShvcHRpb25zLCB7IHllYXI6ICdudW1lcmljJywgbW9udGg6ICdudW1lcmljJyB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG9wdGlvbnM7XG59XG5mdW5jdGlvbiBtb250aERheUFtZW5kKG9wdGlvbnNQYXJhbSkge1xuICAgIGxldCBvcHRpb25zID0gYW1lbmQob3B0aW9uc1BhcmFtLCB7XG4gICAgICAgIHllYXI6IGZhbHNlLFxuICAgICAgICBob3VyOiBmYWxzZSxcbiAgICAgICAgbWludXRlOiBmYWxzZSxcbiAgICAgICAgc2Vjb25kOiBmYWxzZSxcbiAgICAgICAgd2Vla2RheTogZmFsc2UsXG4gICAgICAgIGRheVBlcmlvZDogZmFsc2UsXG4gICAgICAgIHRpbWVab25lTmFtZTogZmFsc2UsXG4gICAgICAgIGRhdGVTdHlsZTogZmFsc2UsXG4gICAgICAgIHRpbWVTdHlsZTogZmFsc2VcbiAgICB9KTtcbiAgICBpZiAoISgnbW9udGgnIGluIG9wdGlvbnMgfHwgJ2RheScgaW4gb3B0aW9ucykpIHtcbiAgICAgICAgb3B0aW9ucyA9IE9iamVjdEFzc2lnbiQxKHt9LCBvcHRpb25zLCB7IG1vbnRoOiAnbnVtZXJpYycsIGRheTogJ251bWVyaWMnIH0pO1xuICAgIH1cbiAgICByZXR1cm4gb3B0aW9ucztcbn1cbmZ1bmN0aW9uIGRhdGVBbWVuZChvcHRpb25zUGFyYW0pIHtcbiAgICBsZXQgb3B0aW9ucyA9IGFtZW5kKG9wdGlvbnNQYXJhbSwge1xuICAgICAgICBob3VyOiBmYWxzZSxcbiAgICAgICAgbWludXRlOiBmYWxzZSxcbiAgICAgICAgc2Vjb25kOiBmYWxzZSxcbiAgICAgICAgZGF5UGVyaW9kOiBmYWxzZSxcbiAgICAgICAgdGltZVpvbmVOYW1lOiBmYWxzZSxcbiAgICAgICAgdGltZVN0eWxlOiBmYWxzZVxuICAgIH0pO1xuICAgIGlmICghaGFzRGF0ZU9wdGlvbnMob3B0aW9ucykpIHtcbiAgICAgICAgb3B0aW9ucyA9IE9iamVjdEFzc2lnbiQxKHt9LCBvcHRpb25zLCB7XG4gICAgICAgICAgICB5ZWFyOiAnbnVtZXJpYycsXG4gICAgICAgICAgICBtb250aDogJ251bWVyaWMnLFxuICAgICAgICAgICAgZGF5OiAnbnVtZXJpYydcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBvcHRpb25zO1xufVxuZnVuY3Rpb24gZGF0ZXRpbWVBbWVuZChvcHRpb25zUGFyYW0pIHtcbiAgICBsZXQgb3B0aW9ucyA9IGFtZW5kKG9wdGlvbnNQYXJhbSwgeyB0aW1lWm9uZU5hbWU6IGZhbHNlIH0pO1xuICAgIGlmICghaGFzVGltZU9wdGlvbnMob3B0aW9ucykgJiYgIWhhc0RhdGVPcHRpb25zKG9wdGlvbnMpKSB7XG4gICAgICAgIG9wdGlvbnMgPSBPYmplY3RBc3NpZ24kMSh7fSwgb3B0aW9ucywge1xuICAgICAgICAgICAgeWVhcjogJ251bWVyaWMnLFxuICAgICAgICAgICAgbW9udGg6ICdudW1lcmljJyxcbiAgICAgICAgICAgIGRheTogJ251bWVyaWMnLFxuICAgICAgICAgICAgaG91cjogJ251bWVyaWMnLFxuICAgICAgICAgICAgbWludXRlOiAnbnVtZXJpYycsXG4gICAgICAgICAgICBzZWNvbmQ6ICdudW1lcmljJ1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG9wdGlvbnM7XG59XG5mdW5jdGlvbiB6b25lZERhdGVUaW1lQW1lbmQob3B0aW9uc1BhcmFtKSB7XG4gICAgbGV0IG9wdGlvbnMgPSBvcHRpb25zUGFyYW07XG4gICAgaWYgKCFoYXNUaW1lT3B0aW9ucyhvcHRpb25zKSAmJiAhaGFzRGF0ZU9wdGlvbnMob3B0aW9ucykpIHtcbiAgICAgICAgb3B0aW9ucyA9IE9iamVjdEFzc2lnbiQxKHt9LCBvcHRpb25zLCB7XG4gICAgICAgICAgICB5ZWFyOiAnbnVtZXJpYycsXG4gICAgICAgICAgICBtb250aDogJ251bWVyaWMnLFxuICAgICAgICAgICAgZGF5OiAnbnVtZXJpYycsXG4gICAgICAgICAgICBob3VyOiAnbnVtZXJpYycsXG4gICAgICAgICAgICBtaW51dGU6ICdudW1lcmljJyxcbiAgICAgICAgICAgIHNlY29uZDogJ251bWVyaWMnXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAob3B0aW9ucy50aW1lWm9uZU5hbWUgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIG9wdGlvbnMudGltZVpvbmVOYW1lID0gJ3Nob3J0JztcbiAgICB9XG4gICAgcmV0dXJuIG9wdGlvbnM7XG59XG5mdW5jdGlvbiBpbnN0YW50QW1lbmQob3B0aW9uc1BhcmFtKSB7XG4gICAgbGV0IG9wdGlvbnMgPSBvcHRpb25zUGFyYW07XG4gICAgaWYgKCFoYXNUaW1lT3B0aW9ucyhvcHRpb25zKSAmJiAhaGFzRGF0ZU9wdGlvbnMob3B0aW9ucykpIHtcbiAgICAgICAgb3B0aW9ucyA9IE9iamVjdEFzc2lnbiQxKHt9LCBvcHRpb25zLCB7XG4gICAgICAgICAgICB5ZWFyOiAnbnVtZXJpYycsXG4gICAgICAgICAgICBtb250aDogJ251bWVyaWMnLFxuICAgICAgICAgICAgZGF5OiAnbnVtZXJpYycsXG4gICAgICAgICAgICBob3VyOiAnbnVtZXJpYycsXG4gICAgICAgICAgICBtaW51dGU6ICdudW1lcmljJyxcbiAgICAgICAgICAgIHNlY29uZDogJ251bWVyaWMnXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gb3B0aW9ucztcbn1cbmZ1bmN0aW9uIGhhc0RhdGVPcHRpb25zKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gJ3llYXInIGluIG9wdGlvbnMgfHwgJ21vbnRoJyBpbiBvcHRpb25zIHx8ICdkYXknIGluIG9wdGlvbnMgfHwgJ3dlZWtkYXknIGluIG9wdGlvbnMgfHwgJ2RhdGVTdHlsZScgaW4gb3B0aW9ucztcbn1cbmZ1bmN0aW9uIGhhc1RpbWVPcHRpb25zKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gKCdob3VyJyBpbiBvcHRpb25zIHx8ICdtaW51dGUnIGluIG9wdGlvbnMgfHwgJ3NlY29uZCcgaW4gb3B0aW9ucyB8fCAndGltZVN0eWxlJyBpbiBvcHRpb25zIHx8ICdkYXlQZXJpb2QnIGluIG9wdGlvbnMpO1xufVxuZnVuY3Rpb24gaXNUZW1wb3JhbE9iamVjdChvYmopIHtcbiAgICByZXR1cm4gKElzVGVtcG9yYWxEYXRlKG9iaikgfHxcbiAgICAgICAgSXNUZW1wb3JhbFRpbWUob2JqKSB8fFxuICAgICAgICBJc1RlbXBvcmFsRGF0ZVRpbWUob2JqKSB8fFxuICAgICAgICBJc1RlbXBvcmFsWm9uZWREYXRlVGltZShvYmopIHx8XG4gICAgICAgIElzVGVtcG9yYWxZZWFyTW9udGgob2JqKSB8fFxuICAgICAgICBJc1RlbXBvcmFsTW9udGhEYXkob2JqKSB8fFxuICAgICAgICBJc1RlbXBvcmFsSW5zdGFudChvYmopKTtcbn1cbmZ1bmN0aW9uIHNhbWVUZW1wb3JhbFR5cGUoeCwgeSkge1xuICAgIGlmICghaXNUZW1wb3JhbE9iamVjdCh4KSB8fCAhaXNUZW1wb3JhbE9iamVjdCh5KSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChJc1RlbXBvcmFsVGltZSh4KSAmJiAhSXNUZW1wb3JhbFRpbWUoeSkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoSXNUZW1wb3JhbERhdGUoeCkgJiYgIUlzVGVtcG9yYWxEYXRlKHkpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKElzVGVtcG9yYWxEYXRlVGltZSh4KSAmJiAhSXNUZW1wb3JhbERhdGVUaW1lKHkpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKElzVGVtcG9yYWxab25lZERhdGVUaW1lKHgpICYmICFJc1RlbXBvcmFsWm9uZWREYXRlVGltZSh5KSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChJc1RlbXBvcmFsWWVhck1vbnRoKHgpICYmICFJc1RlbXBvcmFsWWVhck1vbnRoKHkpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKElzVGVtcG9yYWxNb250aERheSh4KSAmJiAhSXNUZW1wb3JhbE1vbnRoRGF5KHkpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKElzVGVtcG9yYWxJbnN0YW50KHgpICYmICFJc1RlbXBvcmFsSW5zdGFudCh5KSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gZXh0cmFjdE92ZXJyaWRlcyh0ZW1wb3JhbE9iaiwgbWFpbikge1xuICAgIGNvbnN0IERhdGVUaW1lID0gR2V0SW50cmluc2ljKCclVGVtcG9yYWwuUGxhaW5EYXRlVGltZSUnKTtcbiAgICBpZiAoSXNUZW1wb3JhbFRpbWUodGVtcG9yYWxPYmopKSB7XG4gICAgICAgIGNvbnN0IGhvdXIgPSBHZXRTbG90KHRlbXBvcmFsT2JqLCBJU09fSE9VUik7XG4gICAgICAgIGNvbnN0IG1pbnV0ZSA9IEdldFNsb3QodGVtcG9yYWxPYmosIElTT19NSU5VVEUpO1xuICAgICAgICBjb25zdCBzZWNvbmQgPSBHZXRTbG90KHRlbXBvcmFsT2JqLCBJU09fU0VDT05EKTtcbiAgICAgICAgY29uc3QgbWlsbGlzZWNvbmQgPSBHZXRTbG90KHRlbXBvcmFsT2JqLCBJU09fTUlMTElTRUNPTkQpO1xuICAgICAgICBjb25zdCBtaWNyb3NlY29uZCA9IEdldFNsb3QodGVtcG9yYWxPYmosIElTT19NSUNST1NFQ09ORCk7XG4gICAgICAgIGNvbnN0IG5hbm9zZWNvbmQgPSBHZXRTbG90KHRlbXBvcmFsT2JqLCBJU09fTkFOT1NFQ09ORCk7XG4gICAgICAgIGNvbnN0IGRhdGV0aW1lID0gbmV3IERhdGVUaW1lKDE5NzAsIDEsIDEsIGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZCwgbWljcm9zZWNvbmQsIG5hbm9zZWNvbmQsIG1haW5bQ0FMX0lEXSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpbnN0YW50OiBCdWlsdGluVGltZVpvbmVHZXRJbnN0YW50Rm9yKGdldFJlc29sdmVkVGltZVpvbmVMYXp5KG1haW4pLCBkYXRldGltZSwgJ2NvbXBhdGlibGUnKSxcbiAgICAgICAgICAgIGZvcm1hdHRlcjogZ2V0UHJvcExhenkobWFpbiwgVElNRSlcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKElzVGVtcG9yYWxZZWFyTW9udGgodGVtcG9yYWxPYmopKSB7XG4gICAgICAgIGNvbnN0IGlzb1llYXIgPSBHZXRTbG90KHRlbXBvcmFsT2JqLCBJU09fWUVBUik7XG4gICAgICAgIGNvbnN0IGlzb01vbnRoID0gR2V0U2xvdCh0ZW1wb3JhbE9iaiwgSVNPX01PTlRIKTtcbiAgICAgICAgY29uc3QgcmVmZXJlbmNlSVNPRGF5ID0gR2V0U2xvdCh0ZW1wb3JhbE9iaiwgSVNPX0RBWSk7XG4gICAgICAgIGNvbnN0IGNhbGVuZGFyID0gVG9TdHJpbmcoR2V0U2xvdCh0ZW1wb3JhbE9iaiwgQ0FMRU5EQVIpKTtcbiAgICAgICAgaWYgKGNhbGVuZGFyICE9PSBtYWluW0NBTF9JRF0pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBjYW5ub3QgZm9ybWF0IFBsYWluWWVhck1vbnRoIHdpdGggY2FsZW5kYXIgJHtjYWxlbmRhcn0gaW4gbG9jYWxlIHdpdGggY2FsZW5kYXIgJHttYWluW0NBTF9JRF19YCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGF0ZXRpbWUgPSBuZXcgRGF0ZVRpbWUoaXNvWWVhciwgaXNvTW9udGgsIHJlZmVyZW5jZUlTT0RheSwgMTIsIDAsIDAsIDAsIDAsIDAsIGNhbGVuZGFyKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGluc3RhbnQ6IEJ1aWx0aW5UaW1lWm9uZUdldEluc3RhbnRGb3IoZ2V0UmVzb2x2ZWRUaW1lWm9uZUxhenkobWFpbiksIGRhdGV0aW1lLCAnY29tcGF0aWJsZScpLFxuICAgICAgICAgICAgZm9ybWF0dGVyOiBnZXRQcm9wTGF6eShtYWluLCBZTSlcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKElzVGVtcG9yYWxNb250aERheSh0ZW1wb3JhbE9iaikpIHtcbiAgICAgICAgY29uc3QgcmVmZXJlbmNlSVNPWWVhciA9IEdldFNsb3QodGVtcG9yYWxPYmosIElTT19ZRUFSKTtcbiAgICAgICAgY29uc3QgaXNvTW9udGggPSBHZXRTbG90KHRlbXBvcmFsT2JqLCBJU09fTU9OVEgpO1xuICAgICAgICBjb25zdCBpc29EYXkgPSBHZXRTbG90KHRlbXBvcmFsT2JqLCBJU09fREFZKTtcbiAgICAgICAgY29uc3QgY2FsZW5kYXIgPSBUb1N0cmluZyhHZXRTbG90KHRlbXBvcmFsT2JqLCBDQUxFTkRBUikpO1xuICAgICAgICBpZiAoY2FsZW5kYXIgIT09IG1haW5bQ0FMX0lEXSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYGNhbm5vdCBmb3JtYXQgUGxhaW5Nb250aERheSB3aXRoIGNhbGVuZGFyICR7Y2FsZW5kYXJ9IGluIGxvY2FsZSB3aXRoIGNhbGVuZGFyICR7bWFpbltDQUxfSURdfWApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRhdGV0aW1lID0gbmV3IERhdGVUaW1lKHJlZmVyZW5jZUlTT1llYXIsIGlzb01vbnRoLCBpc29EYXksIDEyLCAwLCAwLCAwLCAwLCAwLCBjYWxlbmRhcik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpbnN0YW50OiBCdWlsdGluVGltZVpvbmVHZXRJbnN0YW50Rm9yKGdldFJlc29sdmVkVGltZVpvbmVMYXp5KG1haW4pLCBkYXRldGltZSwgJ2NvbXBhdGlibGUnKSxcbiAgICAgICAgICAgIGZvcm1hdHRlcjogZ2V0UHJvcExhenkobWFpbiwgTUQpXG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmIChJc1RlbXBvcmFsRGF0ZSh0ZW1wb3JhbE9iaikpIHtcbiAgICAgICAgY29uc3QgaXNvWWVhciA9IEdldFNsb3QodGVtcG9yYWxPYmosIElTT19ZRUFSKTtcbiAgICAgICAgY29uc3QgaXNvTW9udGggPSBHZXRTbG90KHRlbXBvcmFsT2JqLCBJU09fTU9OVEgpO1xuICAgICAgICBjb25zdCBpc29EYXkgPSBHZXRTbG90KHRlbXBvcmFsT2JqLCBJU09fREFZKTtcbiAgICAgICAgY29uc3QgY2FsZW5kYXIgPSBUb1N0cmluZyhHZXRTbG90KHRlbXBvcmFsT2JqLCBDQUxFTkRBUikpO1xuICAgICAgICBpZiAoY2FsZW5kYXIgIT09ICdpc284NjAxJyAmJiBjYWxlbmRhciAhPT0gbWFpbltDQUxfSURdKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgY2Fubm90IGZvcm1hdCBQbGFpbkRhdGUgd2l0aCBjYWxlbmRhciAke2NhbGVuZGFyfSBpbiBsb2NhbGUgd2l0aCBjYWxlbmRhciAke21haW5bQ0FMX0lEXX1gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkYXRldGltZSA9IG5ldyBEYXRlVGltZShpc29ZZWFyLCBpc29Nb250aCwgaXNvRGF5LCAxMiwgMCwgMCwgMCwgMCwgMCwgbWFpbltDQUxfSURdKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGluc3RhbnQ6IEJ1aWx0aW5UaW1lWm9uZUdldEluc3RhbnRGb3IoZ2V0UmVzb2x2ZWRUaW1lWm9uZUxhenkobWFpbiksIGRhdGV0aW1lLCAnY29tcGF0aWJsZScpLFxuICAgICAgICAgICAgZm9ybWF0dGVyOiBnZXRQcm9wTGF6eShtYWluLCBEQVRFKVxuICAgICAgICB9O1xuICAgIH1cbiAgICBpZiAoSXNUZW1wb3JhbERhdGVUaW1lKHRlbXBvcmFsT2JqKSkge1xuICAgICAgICBjb25zdCBpc29ZZWFyID0gR2V0U2xvdCh0ZW1wb3JhbE9iaiwgSVNPX1lFQVIpO1xuICAgICAgICBjb25zdCBpc29Nb250aCA9IEdldFNsb3QodGVtcG9yYWxPYmosIElTT19NT05USCk7XG4gICAgICAgIGNvbnN0IGlzb0RheSA9IEdldFNsb3QodGVtcG9yYWxPYmosIElTT19EQVkpO1xuICAgICAgICBjb25zdCBob3VyID0gR2V0U2xvdCh0ZW1wb3JhbE9iaiwgSVNPX0hPVVIpO1xuICAgICAgICBjb25zdCBtaW51dGUgPSBHZXRTbG90KHRlbXBvcmFsT2JqLCBJU09fTUlOVVRFKTtcbiAgICAgICAgY29uc3Qgc2Vjb25kID0gR2V0U2xvdCh0ZW1wb3JhbE9iaiwgSVNPX1NFQ09ORCk7XG4gICAgICAgIGNvbnN0IG1pbGxpc2Vjb25kID0gR2V0U2xvdCh0ZW1wb3JhbE9iaiwgSVNPX01JTExJU0VDT05EKTtcbiAgICAgICAgY29uc3QgbWljcm9zZWNvbmQgPSBHZXRTbG90KHRlbXBvcmFsT2JqLCBJU09fTUlDUk9TRUNPTkQpO1xuICAgICAgICBjb25zdCBuYW5vc2Vjb25kID0gR2V0U2xvdCh0ZW1wb3JhbE9iaiwgSVNPX05BTk9TRUNPTkQpO1xuICAgICAgICBjb25zdCBjYWxlbmRhciA9IFRvU3RyaW5nKEdldFNsb3QodGVtcG9yYWxPYmosIENBTEVOREFSKSk7XG4gICAgICAgIGlmIChjYWxlbmRhciAhPT0gJ2lzbzg2MDEnICYmIGNhbGVuZGFyICE9PSBtYWluW0NBTF9JRF0pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBjYW5ub3QgZm9ybWF0IFBsYWluRGF0ZVRpbWUgd2l0aCBjYWxlbmRhciAke2NhbGVuZGFyfSBpbiBsb2NhbGUgd2l0aCBjYWxlbmRhciAke21haW5bQ0FMX0lEXX1gKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZGF0ZXRpbWUgPSB0ZW1wb3JhbE9iajtcbiAgICAgICAgaWYgKGNhbGVuZGFyID09PSAnaXNvODYwMScpIHtcbiAgICAgICAgICAgIGRhdGV0aW1lID0gbmV3IERhdGVUaW1lKGlzb1llYXIsIGlzb01vbnRoLCBpc29EYXksIGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZCwgbWljcm9zZWNvbmQsIG5hbm9zZWNvbmQsIG1haW5bQ0FMX0lEXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGluc3RhbnQ6IEJ1aWx0aW5UaW1lWm9uZUdldEluc3RhbnRGb3IoZ2V0UmVzb2x2ZWRUaW1lWm9uZUxhenkobWFpbiksIGRhdGV0aW1lLCAnY29tcGF0aWJsZScpLFxuICAgICAgICAgICAgZm9ybWF0dGVyOiBnZXRQcm9wTGF6eShtYWluLCBEQVRFVElNRSlcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKElzVGVtcG9yYWxab25lZERhdGVUaW1lKHRlbXBvcmFsT2JqKSkge1xuICAgICAgICBjb25zdCBjYWxlbmRhciA9IFRvU3RyaW5nKEdldFNsb3QodGVtcG9yYWxPYmosIENBTEVOREFSKSk7XG4gICAgICAgIGlmIChjYWxlbmRhciAhPT0gJ2lzbzg2MDEnICYmIGNhbGVuZGFyICE9PSBtYWluW0NBTF9JRF0pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBjYW5ub3QgZm9ybWF0IFpvbmVkRGF0ZVRpbWUgd2l0aCBjYWxlbmRhciAke2NhbGVuZGFyfSBpbiBsb2NhbGUgd2l0aCBjYWxlbmRhciAke21haW5bQ0FMX0lEXX1gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0aW1lWm9uZSA9IEdldFNsb3QodGVtcG9yYWxPYmosIFRJTUVfWk9ORSk7XG4gICAgICAgIGNvbnN0IG9ialRpbWVab25lID0gVG9TdHJpbmcodGltZVpvbmUpO1xuICAgICAgICBpZiAobWFpbltUWl9HSVZFTl0gJiYgbWFpbltUWl9HSVZFTl0gIT09IG9ialRpbWVab25lKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgdGltZVpvbmUgb3B0aW9uICR7bWFpbltUWl9HSVZFTl19IGRvZXNuJ3QgbWF0Y2ggYWN0dWFsIHRpbWUgem9uZSAke29ialRpbWVab25lfWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpbnN0YW50OiBHZXRTbG90KHRlbXBvcmFsT2JqLCBJTlNUQU5UKSxcbiAgICAgICAgICAgIGZvcm1hdHRlcjogZ2V0UHJvcExhenkobWFpbiwgWk9ORUQpLFxuICAgICAgICAgICAgdGltZVpvbmU6IG9ialRpbWVab25lXG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmIChJc1RlbXBvcmFsSW5zdGFudCh0ZW1wb3JhbE9iaikpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGluc3RhbnQ6IHRlbXBvcmFsT2JqLFxuICAgICAgICAgICAgZm9ybWF0dGVyOiBnZXRQcm9wTGF6eShtYWluLCBJTlNUKVxuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4ge307XG59XG5cbnZhciBpbnRsID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICBEYXRlVGltZUZvcm1hdDogRGF0ZVRpbWVGb3JtYXRcbn0pO1xuXG5jb25zdCBESVNBTExPV0VEX1VOSVRTJDMgPSBbJ3llYXInLCAnbW9udGgnLCAnd2VlaycsICdkYXknXTtcbmNvbnN0IE1BWF9ESUZGRVJFTkNFX0lOQ1JFTUVOVFMgPSB7XG4gICAgaG91cjogMjQsXG4gICAgbWludXRlOiA2MCxcbiAgICBzZWNvbmQ6IDYwLFxuICAgIG1pbGxpc2Vjb25kOiAxMDAwLFxuICAgIG1pY3Jvc2Vjb25kOiAxMDAwLFxuICAgIG5hbm9zZWNvbmQ6IDEwMDBcbn07XG5jbGFzcyBJbnN0YW50IHtcbiAgICBjb25zdHJ1Y3RvcihlcG9jaE5hbm9zZWNvbmRzKSB7XG4gICAgICAgIC8vIE5vdGU6IGlmIHRoZSBhcmd1bWVudCBpcyBub3QgcGFzc2VkLCBUb0JpZ0ludCh1bmRlZmluZWQpIHdpbGwgdGhyb3cuIFRoaXMgY2hlY2sgZXhpc3RzIG9ubHlcbiAgICAgICAgLy8gICAgICAgdG8gaW1wcm92ZSB0aGUgZXJyb3IgbWVzc2FnZS5cbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAxKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdtaXNzaW5nIGFyZ3VtZW50OiBlcG9jaE5hbm9zZWNvbmRzIGlzIHJlcXVpcmVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbnMgPSBUb0JpZ0ludChlcG9jaE5hbm9zZWNvbmRzKTtcbiAgICAgICAgVmFsaWRhdGVFcG9jaE5hbm9zZWNvbmRzKG5zKTtcbiAgICAgICAgQ3JlYXRlU2xvdHModGhpcyk7XG4gICAgICAgIFNldFNsb3QodGhpcywgRVBPQ0hOQU5PU0VDT05EUywgbnMpO1xuICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCByZXByID0gVGVtcG9yYWxJbnN0YW50VG9TdHJpbmcodGhpcywgdW5kZWZpbmVkLCAnYXV0bycpO1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdfcmVwcl8nLCB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IGAke3RoaXNbU3ltYm9sLnRvU3RyaW5nVGFnXX0gPCR7cmVwcn0+YCxcbiAgICAgICAgICAgICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGVwb2NoU2Vjb25kcygpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsSW5zdGFudCh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBHZXRTbG90KHRoaXMsIEVQT0NITkFOT1NFQ09ORFMpO1xuICAgICAgICByZXR1cm4gSlNCSS50b051bWJlcihKU0JJLmRpdmlkZSh2YWx1ZSwgQklMTElPTikpO1xuICAgIH1cbiAgICBnZXQgZXBvY2hNaWxsaXNlY29uZHMoKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbEluc3RhbnQodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gSlNCSS5CaWdJbnQoR2V0U2xvdCh0aGlzLCBFUE9DSE5BTk9TRUNPTkRTKSk7XG4gICAgICAgIHJldHVybiBKU0JJLnRvTnVtYmVyKEpTQkkuZGl2aWRlKHZhbHVlLCBNSUxMSU9OKSk7XG4gICAgfVxuICAgIGdldCBlcG9jaE1pY3Jvc2Vjb25kcygpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsSW5zdGFudCh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBKU0JJLkJpZ0ludChHZXRTbG90KHRoaXMsIEVQT0NITkFOT1NFQ09ORFMpKTtcbiAgICAgICAgcmV0dXJuIFRvQmlnSW50RXh0ZXJuYWwoSlNCSS5kaXZpZGUodmFsdWUsIFRIT1VTQU5EKSk7XG4gICAgfVxuICAgIGdldCBlcG9jaE5hbm9zZWNvbmRzKCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxJbnN0YW50KHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICByZXR1cm4gVG9CaWdJbnRFeHRlcm5hbChKU0JJLkJpZ0ludChHZXRTbG90KHRoaXMsIEVQT0NITkFOT1NFQ09ORFMpKSk7XG4gICAgfVxuICAgIGFkZCh0ZW1wb3JhbER1cmF0aW9uTGlrZSkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxJbnN0YW50KHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICBjb25zdCB7IGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBtaWxsaXNlY29uZHMsIG1pY3Jvc2Vjb25kcywgbmFub3NlY29uZHMgfSA9IFRvTGltaXRlZFRlbXBvcmFsRHVyYXRpb24odGVtcG9yYWxEdXJhdGlvbkxpa2UsIFsneWVhcnMnLCAnbW9udGhzJywgJ3dlZWtzJywgJ2RheXMnXSk7XG4gICAgICAgIGNvbnN0IG5zID0gQWRkSW5zdGFudChHZXRTbG90KHRoaXMsIEVQT0NITkFOT1NFQ09ORFMpLCBob3VycywgbWludXRlcywgc2Vjb25kcywgbWlsbGlzZWNvbmRzLCBtaWNyb3NlY29uZHMsIG5hbm9zZWNvbmRzKTtcbiAgICAgICAgcmV0dXJuIG5ldyBJbnN0YW50KG5zKTtcbiAgICB9XG4gICAgc3VidHJhY3QodGVtcG9yYWxEdXJhdGlvbkxpa2UpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsSW5zdGFudCh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgY29uc3QgeyBob3VycywgbWludXRlcywgc2Vjb25kcywgbWlsbGlzZWNvbmRzLCBtaWNyb3NlY29uZHMsIG5hbm9zZWNvbmRzIH0gPSBUb0xpbWl0ZWRUZW1wb3JhbER1cmF0aW9uKHRlbXBvcmFsRHVyYXRpb25MaWtlLCBbJ3llYXJzJywgJ21vbnRocycsICd3ZWVrcycsICdkYXlzJ10pO1xuICAgICAgICBjb25zdCBucyA9IEFkZEluc3RhbnQoR2V0U2xvdCh0aGlzLCBFUE9DSE5BTk9TRUNPTkRTKSwgLWhvdXJzLCAtbWludXRlcywgLXNlY29uZHMsIC1taWxsaXNlY29uZHMsIC1taWNyb3NlY29uZHMsIC1uYW5vc2Vjb25kcyk7XG4gICAgICAgIHJldHVybiBuZXcgSW5zdGFudChucyk7XG4gICAgfVxuICAgIHVudGlsKG90aGVyUGFyYW0sIG9wdGlvbnNQYXJhbSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxJbnN0YW50KHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICBjb25zdCBvdGhlciA9IFRvVGVtcG9yYWxJbnN0YW50KG90aGVyUGFyYW0pO1xuICAgICAgICBjb25zdCBvcHRpb25zID0gR2V0T3B0aW9uc09iamVjdChvcHRpb25zUGFyYW0pO1xuICAgICAgICBjb25zdCBzbWFsbGVzdFVuaXQgPSBUb1NtYWxsZXN0VGVtcG9yYWxVbml0KG9wdGlvbnMsICduYW5vc2Vjb25kJywgRElTQUxMT1dFRF9VTklUUyQzKTtcbiAgICAgICAgY29uc3QgZGVmYXVsdExhcmdlc3RVbml0ID0gTGFyZ2VyT2ZUd29UZW1wb3JhbFVuaXRzKCdzZWNvbmQnLCBzbWFsbGVzdFVuaXQpO1xuICAgICAgICBjb25zdCBsYXJnZXN0VW5pdCA9IFRvTGFyZ2VzdFRlbXBvcmFsVW5pdChvcHRpb25zLCAnYXV0bycsIERJU0FMTE9XRURfVU5JVFMkMywgZGVmYXVsdExhcmdlc3RVbml0KTtcbiAgICAgICAgVmFsaWRhdGVUZW1wb3JhbFVuaXRSYW5nZShsYXJnZXN0VW5pdCwgc21hbGxlc3RVbml0KTtcbiAgICAgICAgY29uc3Qgcm91bmRpbmdNb2RlID0gVG9UZW1wb3JhbFJvdW5kaW5nTW9kZShvcHRpb25zLCAndHJ1bmMnKTtcbiAgICAgICAgY29uc3Qgcm91bmRpbmdJbmNyZW1lbnQgPSBUb1RlbXBvcmFsUm91bmRpbmdJbmNyZW1lbnQob3B0aW9ucywgTUFYX0RJRkZFUkVOQ0VfSU5DUkVNRU5UU1tzbWFsbGVzdFVuaXRdLCBmYWxzZSk7XG4gICAgICAgIGNvbnN0IG9uZW5zID0gR2V0U2xvdCh0aGlzLCBFUE9DSE5BTk9TRUNPTkRTKTtcbiAgICAgICAgY29uc3QgdHdvbnMgPSBHZXRTbG90KG90aGVyLCBFUE9DSE5BTk9TRUNPTkRTKTtcbiAgICAgICAgbGV0IHsgc2Vjb25kcywgbWlsbGlzZWNvbmRzLCBtaWNyb3NlY29uZHMsIG5hbm9zZWNvbmRzIH0gPSBEaWZmZXJlbmNlSW5zdGFudChvbmVucywgdHdvbnMsIHJvdW5kaW5nSW5jcmVtZW50LCBzbWFsbGVzdFVuaXQsIHJvdW5kaW5nTW9kZSk7XG4gICAgICAgIGxldCBob3VycywgbWludXRlcztcbiAgICAgICAgKHsgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc2Vjb25kcywgbWljcm9zZWNvbmRzLCBuYW5vc2Vjb25kcyB9ID0gQmFsYW5jZUR1cmF0aW9uKDAsIDAsIDAsIHNlY29uZHMsIG1pbGxpc2Vjb25kcywgbWljcm9zZWNvbmRzLCBuYW5vc2Vjb25kcywgbGFyZ2VzdFVuaXQpKTtcbiAgICAgICAgY29uc3QgRHVyYXRpb24gPSBHZXRJbnRyaW5zaWMoJyVUZW1wb3JhbC5EdXJhdGlvbiUnKTtcbiAgICAgICAgcmV0dXJuIG5ldyBEdXJhdGlvbigwLCAwLCAwLCAwLCBob3VycywgbWludXRlcywgc2Vjb25kcywgbWlsbGlzZWNvbmRzLCBtaWNyb3NlY29uZHMsIG5hbm9zZWNvbmRzKTtcbiAgICB9XG4gICAgc2luY2Uob3RoZXJQYXJhbSwgb3B0aW9uc1BhcmFtID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbEluc3RhbnQodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIGNvbnN0IG90aGVyID0gVG9UZW1wb3JhbEluc3RhbnQob3RoZXJQYXJhbSk7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSBHZXRPcHRpb25zT2JqZWN0KG9wdGlvbnNQYXJhbSk7XG4gICAgICAgIGNvbnN0IHNtYWxsZXN0VW5pdCA9IFRvU21hbGxlc3RUZW1wb3JhbFVuaXQob3B0aW9ucywgJ25hbm9zZWNvbmQnLCBESVNBTExPV0VEX1VOSVRTJDMpO1xuICAgICAgICBjb25zdCBkZWZhdWx0TGFyZ2VzdFVuaXQgPSBMYXJnZXJPZlR3b1RlbXBvcmFsVW5pdHMoJ3NlY29uZCcsIHNtYWxsZXN0VW5pdCk7XG4gICAgICAgIGNvbnN0IGxhcmdlc3RVbml0ID0gVG9MYXJnZXN0VGVtcG9yYWxVbml0KG9wdGlvbnMsICdhdXRvJywgRElTQUxMT1dFRF9VTklUUyQzLCBkZWZhdWx0TGFyZ2VzdFVuaXQpO1xuICAgICAgICBWYWxpZGF0ZVRlbXBvcmFsVW5pdFJhbmdlKGxhcmdlc3RVbml0LCBzbWFsbGVzdFVuaXQpO1xuICAgICAgICBjb25zdCByb3VuZGluZ01vZGUgPSBUb1RlbXBvcmFsUm91bmRpbmdNb2RlKG9wdGlvbnMsICd0cnVuYycpO1xuICAgICAgICBjb25zdCByb3VuZGluZ0luY3JlbWVudCA9IFRvVGVtcG9yYWxSb3VuZGluZ0luY3JlbWVudChvcHRpb25zLCBNQVhfRElGRkVSRU5DRV9JTkNSRU1FTlRTW3NtYWxsZXN0VW5pdF0sIGZhbHNlKTtcbiAgICAgICAgY29uc3Qgb25lbnMgPSBHZXRTbG90KG90aGVyLCBFUE9DSE5BTk9TRUNPTkRTKTtcbiAgICAgICAgY29uc3QgdHdvbnMgPSBHZXRTbG90KHRoaXMsIEVQT0NITkFOT1NFQ09ORFMpO1xuICAgICAgICBsZXQgeyBzZWNvbmRzLCBtaWxsaXNlY29uZHMsIG1pY3Jvc2Vjb25kcywgbmFub3NlY29uZHMgfSA9IERpZmZlcmVuY2VJbnN0YW50KG9uZW5zLCB0d29ucywgcm91bmRpbmdJbmNyZW1lbnQsIHNtYWxsZXN0VW5pdCwgcm91bmRpbmdNb2RlKTtcbiAgICAgICAgbGV0IGhvdXJzLCBtaW51dGVzO1xuICAgICAgICAoeyBob3VycywgbWludXRlcywgc2Vjb25kcywgbWlsbGlzZWNvbmRzLCBtaWNyb3NlY29uZHMsIG5hbm9zZWNvbmRzIH0gPSBCYWxhbmNlRHVyYXRpb24oMCwgMCwgMCwgc2Vjb25kcywgbWlsbGlzZWNvbmRzLCBtaWNyb3NlY29uZHMsIG5hbm9zZWNvbmRzLCBsYXJnZXN0VW5pdCkpO1xuICAgICAgICBjb25zdCBEdXJhdGlvbiA9IEdldEludHJpbnNpYygnJVRlbXBvcmFsLkR1cmF0aW9uJScpO1xuICAgICAgICByZXR1cm4gbmV3IER1cmF0aW9uKDAsIDAsIDAsIDAsIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBtaWxsaXNlY29uZHMsIG1pY3Jvc2Vjb25kcywgbmFub3NlY29uZHMpO1xuICAgIH1cbiAgICByb3VuZChvcHRpb25zUGFyYW0pIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsSW5zdGFudCh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgaWYgKG9wdGlvbnNQYXJhbSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignb3B0aW9ucyBwYXJhbWV0ZXIgaXMgcmVxdWlyZWQnKTtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHR5cGVvZiBvcHRpb25zUGFyYW0gPT09ICdzdHJpbmcnXG4gICAgICAgICAgICA/IENyZWF0ZU9uZVByb3BPYmplY3QoJ3NtYWxsZXN0VW5pdCcsIG9wdGlvbnNQYXJhbSlcbiAgICAgICAgICAgIDogR2V0T3B0aW9uc09iamVjdChvcHRpb25zUGFyYW0pO1xuICAgICAgICBjb25zdCBzbWFsbGVzdFVuaXQgPSBUb1NtYWxsZXN0VGVtcG9yYWxVbml0KG9wdGlvbnMsIHVuZGVmaW5lZCwgRElTQUxMT1dFRF9VTklUUyQzKTtcbiAgICAgICAgaWYgKHNtYWxsZXN0VW5pdCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NtYWxsZXN0VW5pdCBpcyByZXF1aXJlZCcpO1xuICAgICAgICBjb25zdCByb3VuZGluZ01vZGUgPSBUb1RlbXBvcmFsUm91bmRpbmdNb2RlKG9wdGlvbnMsICdoYWxmRXhwYW5kJyk7XG4gICAgICAgIGNvbnN0IG1heGltdW1JbmNyZW1lbnRzID0ge1xuICAgICAgICAgICAgaG91cjogMjQsXG4gICAgICAgICAgICBtaW51dGU6IDE0NDAsXG4gICAgICAgICAgICBzZWNvbmQ6IDg2NDAwLFxuICAgICAgICAgICAgbWlsbGlzZWNvbmQ6IDg2NDAwZTMsXG4gICAgICAgICAgICBtaWNyb3NlY29uZDogODY0MDBlNixcbiAgICAgICAgICAgIG5hbm9zZWNvbmQ6IDg2NDAwZTlcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgcm91bmRpbmdJbmNyZW1lbnQgPSBUb1RlbXBvcmFsUm91bmRpbmdJbmNyZW1lbnQob3B0aW9ucywgbWF4aW11bUluY3JlbWVudHNbc21hbGxlc3RVbml0XSwgdHJ1ZSk7XG4gICAgICAgIGNvbnN0IG5zID0gR2V0U2xvdCh0aGlzLCBFUE9DSE5BTk9TRUNPTkRTKTtcbiAgICAgICAgY29uc3Qgcm91bmRlZE5zID0gUm91bmRJbnN0YW50KG5zLCByb3VuZGluZ0luY3JlbWVudCwgc21hbGxlc3RVbml0LCByb3VuZGluZ01vZGUpO1xuICAgICAgICByZXR1cm4gbmV3IEluc3RhbnQocm91bmRlZE5zKTtcbiAgICB9XG4gICAgZXF1YWxzKG90aGVyUGFyYW0pIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsSW5zdGFudCh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgY29uc3Qgb3RoZXIgPSBUb1RlbXBvcmFsSW5zdGFudChvdGhlclBhcmFtKTtcbiAgICAgICAgY29uc3Qgb25lID0gR2V0U2xvdCh0aGlzLCBFUE9DSE5BTk9TRUNPTkRTKTtcbiAgICAgICAgY29uc3QgdHdvID0gR2V0U2xvdChvdGhlciwgRVBPQ0hOQU5PU0VDT05EUyk7XG4gICAgICAgIHJldHVybiBKU0JJLmVxdWFsKEpTQkkuQmlnSW50KG9uZSksIEpTQkkuQmlnSW50KHR3bykpO1xuICAgIH1cbiAgICB0b1N0cmluZyhvcHRpb25zUGFyYW0gPSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsSW5zdGFudCh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IEdldE9wdGlvbnNPYmplY3Qob3B0aW9uc1BhcmFtKTtcbiAgICAgICAgbGV0IHRpbWVab25lID0gb3B0aW9ucy50aW1lWm9uZTtcbiAgICAgICAgaWYgKHRpbWVab25lICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICB0aW1lWm9uZSA9IFRvVGVtcG9yYWxUaW1lWm9uZSh0aW1lWm9uZSk7XG4gICAgICAgIC8vIEFsdGhvdWdoIFRTIGRvZXNuJ3QgYWNrbm93bGVkZ2UgaXQsIGJlbG93IGhlcmUgYHRpbWVab25lYCBpcyBhIFRlbXBvcmFsLlRpbWVab25lUHJvdG9jb2xcbiAgICAgICAgY29uc3QgeyBwcmVjaXNpb24sIHVuaXQsIGluY3JlbWVudCB9ID0gVG9TZWNvbmRzU3RyaW5nUHJlY2lzaW9uKG9wdGlvbnMpO1xuICAgICAgICBjb25zdCByb3VuZGluZ01vZGUgPSBUb1RlbXBvcmFsUm91bmRpbmdNb2RlKG9wdGlvbnMsICd0cnVuYycpO1xuICAgICAgICBjb25zdCBucyA9IEdldFNsb3QodGhpcywgRVBPQ0hOQU5PU0VDT05EUyk7XG4gICAgICAgIGNvbnN0IHJvdW5kZWROcyA9IFJvdW5kSW5zdGFudChucywgaW5jcmVtZW50LCB1bml0LCByb3VuZGluZ01vZGUpO1xuICAgICAgICBjb25zdCByb3VuZGVkSW5zdGFudCA9IG5ldyBJbnN0YW50KHJvdW5kZWROcyk7XG4gICAgICAgIHJldHVybiBUZW1wb3JhbEluc3RhbnRUb1N0cmluZyhyb3VuZGVkSW5zdGFudCwgdGltZVpvbmUsIHByZWNpc2lvbik7XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsSW5zdGFudCh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgcmV0dXJuIFRlbXBvcmFsSW5zdGFudFRvU3RyaW5nKHRoaXMsIHVuZGVmaW5lZCwgJ2F1dG8nKTtcbiAgICB9XG4gICAgdG9Mb2NhbGVTdHJpbmcobG9jYWxlcyA9IHVuZGVmaW5lZCwgb3B0aW9ucyA9IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxJbnN0YW50KHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICByZXR1cm4gbmV3IERhdGVUaW1lRm9ybWF0KGxvY2FsZXMsIG9wdGlvbnMpLmZvcm1hdCh0aGlzKTtcbiAgICB9XG4gICAgdmFsdWVPZigpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigndXNlIGNvbXBhcmUoKSBvciBlcXVhbHMoKSB0byBjb21wYXJlIFRlbXBvcmFsLkluc3RhbnQnKTtcbiAgICB9XG4gICAgdG9ab25lZERhdGVUaW1lKGl0ZW0pIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsSW5zdGFudCh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgaWYgKCFJc09iamVjdChpdGVtKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBhcmd1bWVudCBpbiB0b1pvbmVkRGF0ZVRpbWUnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjYWxlbmRhckxpa2UgPSBpdGVtLmNhbGVuZGFyO1xuICAgICAgICBpZiAoY2FsZW5kYXJMaWtlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ21pc3NpbmcgY2FsZW5kYXIgcHJvcGVydHkgaW4gdG9ab25lZERhdGVUaW1lJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2FsZW5kYXIgPSBUb1RlbXBvcmFsQ2FsZW5kYXIoY2FsZW5kYXJMaWtlKTtcbiAgICAgICAgY29uc3QgdGVtcG9yYWxUaW1lWm9uZUxpa2UgPSBpdGVtLnRpbWVab25lO1xuICAgICAgICBpZiAodGVtcG9yYWxUaW1lWm9uZUxpa2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbWlzc2luZyB0aW1lWm9uZSBwcm9wZXJ0eSBpbiB0b1pvbmVkRGF0ZVRpbWUnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0aW1lWm9uZSA9IFRvVGVtcG9yYWxUaW1lWm9uZSh0ZW1wb3JhbFRpbWVab25lTGlrZSk7XG4gICAgICAgIHJldHVybiBDcmVhdGVUZW1wb3JhbFpvbmVkRGF0ZVRpbWUoR2V0U2xvdCh0aGlzLCBFUE9DSE5BTk9TRUNPTkRTKSwgdGltZVpvbmUsIGNhbGVuZGFyKTtcbiAgICB9XG4gICAgdG9ab25lZERhdGVUaW1lSVNPKGl0ZW1QYXJhbSkge1xuICAgICAgICBsZXQgaXRlbSA9IGl0ZW1QYXJhbTtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsSW5zdGFudCh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgaWYgKElzT2JqZWN0KGl0ZW0pKSB7XG4gICAgICAgICAgICBjb25zdCB0aW1lWm9uZVByb3BlcnR5ID0gaXRlbS50aW1lWm9uZTtcbiAgICAgICAgICAgIGlmICh0aW1lWm9uZVByb3BlcnR5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBpdGVtID0gdGltZVpvbmVQcm9wZXJ0eTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0aW1lWm9uZSA9IFRvVGVtcG9yYWxUaW1lWm9uZShpdGVtKTtcbiAgICAgICAgY29uc3QgY2FsZW5kYXIgPSBHZXRJU084NjAxQ2FsZW5kYXIoKTtcbiAgICAgICAgcmV0dXJuIENyZWF0ZVRlbXBvcmFsWm9uZWREYXRlVGltZShHZXRTbG90KHRoaXMsIEVQT0NITkFOT1NFQ09ORFMpLCB0aW1lWm9uZSwgY2FsZW5kYXIpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUVwb2NoU2Vjb25kcyhlcG9jaFNlY29uZHNQYXJhbSkge1xuICAgICAgICBjb25zdCBlcG9jaFNlY29uZHMgPSBUb051bWJlcihlcG9jaFNlY29uZHNQYXJhbSk7XG4gICAgICAgIGNvbnN0IGVwb2NoTmFub3NlY29uZHMgPSBKU0JJLm11bHRpcGx5KEpTQkkuQmlnSW50KGVwb2NoU2Vjb25kcyksIEJJTExJT04pO1xuICAgICAgICBWYWxpZGF0ZUVwb2NoTmFub3NlY29uZHMoZXBvY2hOYW5vc2Vjb25kcyk7XG4gICAgICAgIHJldHVybiBuZXcgSW5zdGFudChlcG9jaE5hbm9zZWNvbmRzKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21FcG9jaE1pbGxpc2Vjb25kcyhlcG9jaE1pbGxpc2Vjb25kc1BhcmFtKSB7XG4gICAgICAgIGNvbnN0IGVwb2NoTWlsbGlzZWNvbmRzID0gVG9OdW1iZXIoZXBvY2hNaWxsaXNlY29uZHNQYXJhbSk7XG4gICAgICAgIGNvbnN0IGVwb2NoTmFub3NlY29uZHMgPSBKU0JJLm11bHRpcGx5KEpTQkkuQmlnSW50KGVwb2NoTWlsbGlzZWNvbmRzKSwgTUlMTElPTik7XG4gICAgICAgIFZhbGlkYXRlRXBvY2hOYW5vc2Vjb25kcyhlcG9jaE5hbm9zZWNvbmRzKTtcbiAgICAgICAgcmV0dXJuIG5ldyBJbnN0YW50KGVwb2NoTmFub3NlY29uZHMpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUVwb2NoTWljcm9zZWNvbmRzKGVwb2NoTWljcm9zZWNvbmRzUGFyYW0pIHtcbiAgICAgICAgY29uc3QgZXBvY2hNaWNyb3NlY29uZHMgPSBUb0JpZ0ludChlcG9jaE1pY3Jvc2Vjb25kc1BhcmFtKTtcbiAgICAgICAgY29uc3QgZXBvY2hOYW5vc2Vjb25kcyA9IEpTQkkubXVsdGlwbHkoZXBvY2hNaWNyb3NlY29uZHMsIFRIT1VTQU5EKTtcbiAgICAgICAgVmFsaWRhdGVFcG9jaE5hbm9zZWNvbmRzKGVwb2NoTmFub3NlY29uZHMpO1xuICAgICAgICByZXR1cm4gbmV3IEluc3RhbnQoZXBvY2hOYW5vc2Vjb25kcyk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tRXBvY2hOYW5vc2Vjb25kcyhlcG9jaE5hbm9zZWNvbmRzUGFyYW0pIHtcbiAgICAgICAgY29uc3QgZXBvY2hOYW5vc2Vjb25kcyA9IFRvQmlnSW50KGVwb2NoTmFub3NlY29uZHNQYXJhbSk7XG4gICAgICAgIFZhbGlkYXRlRXBvY2hOYW5vc2Vjb25kcyhlcG9jaE5hbm9zZWNvbmRzKTtcbiAgICAgICAgcmV0dXJuIG5ldyBJbnN0YW50KGVwb2NoTmFub3NlY29uZHMpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbShpdGVtKSB7XG4gICAgICAgIGlmIChJc1RlbXBvcmFsSW5zdGFudChpdGVtKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBJbnN0YW50KEdldFNsb3QoaXRlbSwgRVBPQ0hOQU5PU0VDT05EUykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBUb1RlbXBvcmFsSW5zdGFudChpdGVtKTtcbiAgICB9XG4gICAgc3RhdGljIGNvbXBhcmUob25lUGFyYW0sIHR3b1BhcmFtKSB7XG4gICAgICAgIGNvbnN0IG9uZSA9IFRvVGVtcG9yYWxJbnN0YW50KG9uZVBhcmFtKTtcbiAgICAgICAgY29uc3QgdHdvID0gVG9UZW1wb3JhbEluc3RhbnQodHdvUGFyYW0pO1xuICAgICAgICBjb25zdCBvbmVOcyA9IEdldFNsb3Qob25lLCBFUE9DSE5BTk9TRUNPTkRTKTtcbiAgICAgICAgY29uc3QgdHdvTnMgPSBHZXRTbG90KHR3bywgRVBPQ0hOQU5PU0VDT05EUyk7XG4gICAgICAgIGlmIChKU0JJLmxlc3NUaGFuKG9uZU5zLCB0d29OcykpXG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIGlmIChKU0JJLmdyZWF0ZXJUaGFuKG9uZU5zLCB0d29OcykpXG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxufVxuTWFrZUludHJpbnNpY0NsYXNzKEluc3RhbnQsICdUZW1wb3JhbC5JbnN0YW50Jyk7XG5cbmNvbnN0IERJU0FMTE9XRURfVU5JVFMkMiA9IFsnaG91cicsICdtaW51dGUnLCAnc2Vjb25kJywgJ21pbGxpc2Vjb25kJywgJ21pY3Jvc2Vjb25kJywgJ25hbm9zZWNvbmQnXTtcbmNsYXNzIFBsYWluRGF0ZSB7XG4gICAgY29uc3RydWN0b3IoaXNvWWVhclBhcmFtLCBpc29Nb250aFBhcmFtLCBpc29EYXlQYXJhbSwgY2FsZW5kYXJQYXJhbSA9IEdldElTTzg2MDFDYWxlbmRhcigpKSB7XG4gICAgICAgIGNvbnN0IGlzb1llYXIgPSBUb0ludGVnZXJUaHJvd09uSW5maW5pdHkoaXNvWWVhclBhcmFtKTtcbiAgICAgICAgY29uc3QgaXNvTW9udGggPSBUb0ludGVnZXJUaHJvd09uSW5maW5pdHkoaXNvTW9udGhQYXJhbSk7XG4gICAgICAgIGNvbnN0IGlzb0RheSA9IFRvSW50ZWdlclRocm93T25JbmZpbml0eShpc29EYXlQYXJhbSk7XG4gICAgICAgIGNvbnN0IGNhbGVuZGFyID0gVG9UZW1wb3JhbENhbGVuZGFyKGNhbGVuZGFyUGFyYW0pO1xuICAgICAgICAvLyBOb3RlOiBpZiB0aGUgYXJndW1lbnRzIGFyZSBub3QgcGFzc2VkLFxuICAgICAgICAvLyAgICAgICBUb0ludGVnZXJUaHJvd09uSW5maW5pdHkodW5kZWZpbmVkKSB3aWxsIGhhdmUgcmV0dXJuZWQgMCwgd2hpY2ggd2lsbFxuICAgICAgICAvLyAgICAgICBiZSByZWplY3RlZCBieSBSZWplY3RJU09EYXRlIGluIENyZWF0ZVRlbXBvcmFsRGF0ZVNsb3RzLiBUaGlzIGNoZWNrXG4gICAgICAgIC8vICAgICAgIGV4aXN0cyBvbmx5IHRvIGltcHJvdmUgdGhlIGVycm9yIG1lc3NhZ2UuXG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ21pc3NpbmcgYXJndW1lbnQ6IGlzb1llYXIsIGlzb01vbnRoIGFuZCBpc29EYXkgYXJlIHJlcXVpcmVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgQ3JlYXRlVGVtcG9yYWxEYXRlU2xvdHModGhpcywgaXNvWWVhciwgaXNvTW9udGgsIGlzb0RheSwgY2FsZW5kYXIpO1xuICAgIH1cbiAgICBnZXQgY2FsZW5kYXIoKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbERhdGUodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIHJldHVybiBHZXRTbG90KHRoaXMsIENBTEVOREFSKTtcbiAgICB9XG4gICAgZ2V0IGVyYSgpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsRGF0ZSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgcmV0dXJuIENhbGVuZGFyRXJhKEdldFNsb3QodGhpcywgQ0FMRU5EQVIpLCB0aGlzKTtcbiAgICB9XG4gICAgZ2V0IGVyYVllYXIoKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbERhdGUodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIHJldHVybiBDYWxlbmRhckVyYVllYXIoR2V0U2xvdCh0aGlzLCBDQUxFTkRBUiksIHRoaXMpO1xuICAgIH1cbiAgICBnZXQgeWVhcigpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsRGF0ZSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgcmV0dXJuIENhbGVuZGFyWWVhcihHZXRTbG90KHRoaXMsIENBTEVOREFSKSwgdGhpcyk7XG4gICAgfVxuICAgIGdldCBtb250aCgpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsRGF0ZSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgcmV0dXJuIENhbGVuZGFyTW9udGgoR2V0U2xvdCh0aGlzLCBDQUxFTkRBUiksIHRoaXMpO1xuICAgIH1cbiAgICBnZXQgbW9udGhDb2RlKCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxEYXRlKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICByZXR1cm4gQ2FsZW5kYXJNb250aENvZGUoR2V0U2xvdCh0aGlzLCBDQUxFTkRBUiksIHRoaXMpO1xuICAgIH1cbiAgICBnZXQgZGF5KCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxEYXRlKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICByZXR1cm4gQ2FsZW5kYXJEYXkoR2V0U2xvdCh0aGlzLCBDQUxFTkRBUiksIHRoaXMpO1xuICAgIH1cbiAgICBnZXQgZGF5T2ZXZWVrKCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxEYXRlKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICByZXR1cm4gQ2FsZW5kYXJEYXlPZldlZWsoR2V0U2xvdCh0aGlzLCBDQUxFTkRBUiksIHRoaXMpO1xuICAgIH1cbiAgICBnZXQgZGF5T2ZZZWFyKCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxEYXRlKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICByZXR1cm4gQ2FsZW5kYXJEYXlPZlllYXIoR2V0U2xvdCh0aGlzLCBDQUxFTkRBUiksIHRoaXMpO1xuICAgIH1cbiAgICBnZXQgd2Vla09mWWVhcigpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsRGF0ZSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgcmV0dXJuIENhbGVuZGFyV2Vla09mWWVhcihHZXRTbG90KHRoaXMsIENBTEVOREFSKSwgdGhpcyk7XG4gICAgfVxuICAgIGdldCBkYXlzSW5XZWVrKCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxEYXRlKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICByZXR1cm4gQ2FsZW5kYXJEYXlzSW5XZWVrKEdldFNsb3QodGhpcywgQ0FMRU5EQVIpLCB0aGlzKTtcbiAgICB9XG4gICAgZ2V0IGRheXNJbk1vbnRoKCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxEYXRlKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICByZXR1cm4gQ2FsZW5kYXJEYXlzSW5Nb250aChHZXRTbG90KHRoaXMsIENBTEVOREFSKSwgdGhpcyk7XG4gICAgfVxuICAgIGdldCBkYXlzSW5ZZWFyKCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxEYXRlKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICByZXR1cm4gQ2FsZW5kYXJEYXlzSW5ZZWFyKEdldFNsb3QodGhpcywgQ0FMRU5EQVIpLCB0aGlzKTtcbiAgICB9XG4gICAgZ2V0IG1vbnRoc0luWWVhcigpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsRGF0ZSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgcmV0dXJuIENhbGVuZGFyTW9udGhzSW5ZZWFyKEdldFNsb3QodGhpcywgQ0FMRU5EQVIpLCB0aGlzKTtcbiAgICB9XG4gICAgZ2V0IGluTGVhcFllYXIoKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbERhdGUodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIHJldHVybiBDYWxlbmRhckluTGVhcFllYXIoR2V0U2xvdCh0aGlzLCBDQUxFTkRBUiksIHRoaXMpO1xuICAgIH1cbiAgICB3aXRoKHRlbXBvcmFsRGF0ZUxpa2UsIG9wdGlvbnNQYXJhbSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxEYXRlKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICBpZiAoIUlzT2JqZWN0KHRlbXBvcmFsRGF0ZUxpa2UpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIGFyZ3VtZW50Jyk7XG4gICAgICAgIH1cbiAgICAgICAgUmVqZWN0T2JqZWN0V2l0aENhbGVuZGFyT3JUaW1lWm9uZSh0ZW1wb3JhbERhdGVMaWtlKTtcbiAgICAgICAgY29uc3QgY2FsZW5kYXIgPSBHZXRTbG90KHRoaXMsIENBTEVOREFSKTtcbiAgICAgICAgY29uc3QgZmllbGROYW1lcyA9IENhbGVuZGFyRmllbGRzKGNhbGVuZGFyLCBbJ2RheScsICdtb250aCcsICdtb250aENvZGUnLCAneWVhciddKTtcbiAgICAgICAgY29uc3QgcHJvcHMgPSBUb1BhcnRpYWxSZWNvcmQodGVtcG9yYWxEYXRlTGlrZSwgZmllbGROYW1lcyk7XG4gICAgICAgIGlmICghcHJvcHMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgZGF0ZS1saWtlJyk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGZpZWxkcyA9IFRvVGVtcG9yYWxEYXRlRmllbGRzKHRoaXMsIGZpZWxkTmFtZXMpO1xuICAgICAgICBmaWVsZHMgPSBDYWxlbmRhck1lcmdlRmllbGRzKGNhbGVuZGFyLCBmaWVsZHMsIHByb3BzKTtcbiAgICAgICAgZmllbGRzID0gVG9UZW1wb3JhbERhdGVGaWVsZHMoZmllbGRzLCBmaWVsZE5hbWVzKTtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IEdldE9wdGlvbnNPYmplY3Qob3B0aW9uc1BhcmFtKTtcbiAgICAgICAgcmV0dXJuIERhdGVGcm9tRmllbGRzKGNhbGVuZGFyLCBmaWVsZHMsIG9wdGlvbnMpO1xuICAgIH1cbiAgICB3aXRoQ2FsZW5kYXIoY2FsZW5kYXJQYXJhbSkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxEYXRlKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICBjb25zdCBjYWxlbmRhciA9IFRvVGVtcG9yYWxDYWxlbmRhcihjYWxlbmRhclBhcmFtKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQbGFpbkRhdGUoR2V0U2xvdCh0aGlzLCBJU09fWUVBUiksIEdldFNsb3QodGhpcywgSVNPX01PTlRIKSwgR2V0U2xvdCh0aGlzLCBJU09fREFZKSwgY2FsZW5kYXIpO1xuICAgIH1cbiAgICBhZGQodGVtcG9yYWxEdXJhdGlvbkxpa2UsIG9wdGlvbnNQYXJhbSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxEYXRlKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICBjb25zdCBkdXJhdGlvbiA9IFRvVGVtcG9yYWxEdXJhdGlvbih0ZW1wb3JhbER1cmF0aW9uTGlrZSk7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSBHZXRPcHRpb25zT2JqZWN0KG9wdGlvbnNQYXJhbSk7XG4gICAgICAgIHJldHVybiBDYWxlbmRhckRhdGVBZGQoR2V0U2xvdCh0aGlzLCBDQUxFTkRBUiksIHRoaXMsIGR1cmF0aW9uLCBvcHRpb25zKTtcbiAgICB9XG4gICAgc3VidHJhY3QodGVtcG9yYWxEdXJhdGlvbkxpa2UsIG9wdGlvbnNQYXJhbSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxEYXRlKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICBjb25zdCBkdXJhdGlvbiA9IENyZWF0ZU5lZ2F0ZWRUZW1wb3JhbER1cmF0aW9uKFRvVGVtcG9yYWxEdXJhdGlvbih0ZW1wb3JhbER1cmF0aW9uTGlrZSkpO1xuICAgICAgICBjb25zdCBvcHRpb25zID0gR2V0T3B0aW9uc09iamVjdChvcHRpb25zUGFyYW0pO1xuICAgICAgICByZXR1cm4gQ2FsZW5kYXJEYXRlQWRkKEdldFNsb3QodGhpcywgQ0FMRU5EQVIpLCB0aGlzLCBkdXJhdGlvbiwgb3B0aW9ucyk7XG4gICAgfVxuICAgIHVudGlsKG90aGVyUGFyYW0sIG9wdGlvbnNQYXJhbSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxEYXRlKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICBjb25zdCBvdGhlciA9IFRvVGVtcG9yYWxEYXRlKG90aGVyUGFyYW0pO1xuICAgICAgICBjb25zdCBjYWxlbmRhciA9IEdldFNsb3QodGhpcywgQ0FMRU5EQVIpO1xuICAgICAgICBjb25zdCBvdGhlckNhbGVuZGFyID0gR2V0U2xvdChvdGhlciwgQ0FMRU5EQVIpO1xuICAgICAgICBjb25zdCBjYWxlbmRhcklkID0gVG9TdHJpbmcoY2FsZW5kYXIpO1xuICAgICAgICBjb25zdCBvdGhlckNhbGVuZGFySWQgPSBUb1N0cmluZyhvdGhlckNhbGVuZGFyKTtcbiAgICAgICAgaWYgKGNhbGVuZGFySWQgIT09IG90aGVyQ2FsZW5kYXJJZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYGNhbm5vdCBjb21wdXRlIGRpZmZlcmVuY2UgYmV0d2VlbiBkYXRlcyBvZiAke2NhbGVuZGFySWR9IGFuZCAke290aGVyQ2FsZW5kYXJJZH0gY2FsZW5kYXJzYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IEdldE9wdGlvbnNPYmplY3Qob3B0aW9uc1BhcmFtKTtcbiAgICAgICAgY29uc3Qgc21hbGxlc3RVbml0ID0gVG9TbWFsbGVzdFRlbXBvcmFsVW5pdChvcHRpb25zLCAnZGF5JywgRElTQUxMT1dFRF9VTklUUyQyKTtcbiAgICAgICAgY29uc3QgZGVmYXVsdExhcmdlc3RVbml0ID0gTGFyZ2VyT2ZUd29UZW1wb3JhbFVuaXRzKCdkYXknLCBzbWFsbGVzdFVuaXQpO1xuICAgICAgICBjb25zdCBsYXJnZXN0VW5pdCA9IFRvTGFyZ2VzdFRlbXBvcmFsVW5pdChvcHRpb25zLCAnYXV0bycsIERJU0FMTE9XRURfVU5JVFMkMiwgZGVmYXVsdExhcmdlc3RVbml0KTtcbiAgICAgICAgVmFsaWRhdGVUZW1wb3JhbFVuaXRSYW5nZShsYXJnZXN0VW5pdCwgc21hbGxlc3RVbml0KTtcbiAgICAgICAgY29uc3Qgcm91bmRpbmdNb2RlID0gVG9UZW1wb3JhbFJvdW5kaW5nTW9kZShvcHRpb25zLCAndHJ1bmMnKTtcbiAgICAgICAgY29uc3Qgcm91bmRpbmdJbmNyZW1lbnQgPSBUb1RlbXBvcmFsUm91bmRpbmdJbmNyZW1lbnQob3B0aW9ucywgdW5kZWZpbmVkLCBmYWxzZSk7XG4gICAgICAgIGNvbnN0IHVudGlsT3B0aW9ucyA9IHsgLi4ub3B0aW9ucywgbGFyZ2VzdFVuaXQgfTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gQ2FsZW5kYXJEYXRlVW50aWwoY2FsZW5kYXIsIHRoaXMsIG90aGVyLCB1bnRpbE9wdGlvbnMpO1xuICAgICAgICBpZiAoc21hbGxlc3RVbml0ID09PSAnZGF5JyAmJiByb3VuZGluZ0luY3JlbWVudCA9PT0gMSlcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIGxldCB7IHllYXJzLCBtb250aHMsIHdlZWtzLCBkYXlzIH0gPSByZXN1bHQ7XG4gICAgICAgICh7IHllYXJzLCBtb250aHMsIHdlZWtzLCBkYXlzIH0gPSBSb3VuZER1cmF0aW9uKHllYXJzLCBtb250aHMsIHdlZWtzLCBkYXlzLCAwLCAwLCAwLCAwLCAwLCAwLCByb3VuZGluZ0luY3JlbWVudCwgc21hbGxlc3RVbml0LCByb3VuZGluZ01vZGUsIHRoaXMpKTtcbiAgICAgICAgY29uc3QgRHVyYXRpb24gPSBHZXRJbnRyaW5zaWMoJyVUZW1wb3JhbC5EdXJhdGlvbiUnKTtcbiAgICAgICAgcmV0dXJuIG5ldyBEdXJhdGlvbih5ZWFycywgbW9udGhzLCB3ZWVrcywgZGF5cywgMCwgMCwgMCwgMCwgMCwgMCk7XG4gICAgfVxuICAgIHNpbmNlKG90aGVyUGFyYW0sIG9wdGlvbnNQYXJhbSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxEYXRlKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICBjb25zdCBvdGhlciA9IFRvVGVtcG9yYWxEYXRlKG90aGVyUGFyYW0pO1xuICAgICAgICBjb25zdCBjYWxlbmRhciA9IEdldFNsb3QodGhpcywgQ0FMRU5EQVIpO1xuICAgICAgICBjb25zdCBvdGhlckNhbGVuZGFyID0gR2V0U2xvdChvdGhlciwgQ0FMRU5EQVIpO1xuICAgICAgICBjb25zdCBjYWxlbmRhcklkID0gVG9TdHJpbmcoY2FsZW5kYXIpO1xuICAgICAgICBjb25zdCBvdGhlckNhbGVuZGFySWQgPSBUb1N0cmluZyhvdGhlckNhbGVuZGFyKTtcbiAgICAgICAgaWYgKGNhbGVuZGFySWQgIT09IG90aGVyQ2FsZW5kYXJJZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYGNhbm5vdCBjb21wdXRlIGRpZmZlcmVuY2UgYmV0d2VlbiBkYXRlcyBvZiAke2NhbGVuZGFySWR9IGFuZCAke290aGVyQ2FsZW5kYXJJZH0gY2FsZW5kYXJzYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IEdldE9wdGlvbnNPYmplY3Qob3B0aW9uc1BhcmFtKTtcbiAgICAgICAgY29uc3Qgc21hbGxlc3RVbml0ID0gVG9TbWFsbGVzdFRlbXBvcmFsVW5pdChvcHRpb25zLCAnZGF5JywgRElTQUxMT1dFRF9VTklUUyQyKTtcbiAgICAgICAgY29uc3QgZGVmYXVsdExhcmdlc3RVbml0ID0gTGFyZ2VyT2ZUd29UZW1wb3JhbFVuaXRzKCdkYXknLCBzbWFsbGVzdFVuaXQpO1xuICAgICAgICBjb25zdCBsYXJnZXN0VW5pdCA9IFRvTGFyZ2VzdFRlbXBvcmFsVW5pdChvcHRpb25zLCAnYXV0bycsIERJU0FMTE9XRURfVU5JVFMkMiwgZGVmYXVsdExhcmdlc3RVbml0KTtcbiAgICAgICAgVmFsaWRhdGVUZW1wb3JhbFVuaXRSYW5nZShsYXJnZXN0VW5pdCwgc21hbGxlc3RVbml0KTtcbiAgICAgICAgY29uc3Qgcm91bmRpbmdNb2RlID0gVG9UZW1wb3JhbFJvdW5kaW5nTW9kZShvcHRpb25zLCAndHJ1bmMnKTtcbiAgICAgICAgY29uc3Qgcm91bmRpbmdJbmNyZW1lbnQgPSBUb1RlbXBvcmFsUm91bmRpbmdJbmNyZW1lbnQob3B0aW9ucywgdW5kZWZpbmVkLCBmYWxzZSk7XG4gICAgICAgIGNvbnN0IHVudGlsT3B0aW9ucyA9IHsgLi4ub3B0aW9ucywgbGFyZ2VzdFVuaXQgfTtcbiAgICAgICAgbGV0IHsgeWVhcnMsIG1vbnRocywgd2Vla3MsIGRheXMgfSA9IENhbGVuZGFyRGF0ZVVudGlsKGNhbGVuZGFyLCB0aGlzLCBvdGhlciwgdW50aWxPcHRpb25zKTtcbiAgICAgICAgY29uc3QgRHVyYXRpb24gPSBHZXRJbnRyaW5zaWMoJyVUZW1wb3JhbC5EdXJhdGlvbiUnKTtcbiAgICAgICAgaWYgKHNtYWxsZXN0VW5pdCA9PT0gJ2RheScgJiYgcm91bmRpbmdJbmNyZW1lbnQgPT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRHVyYXRpb24oLXllYXJzLCAtbW9udGhzLCAtd2Vla3MsIC1kYXlzLCAwLCAwLCAwLCAwLCAwLCAwKTtcbiAgICAgICAgfVxuICAgICAgICAoeyB5ZWFycywgbW9udGhzLCB3ZWVrcywgZGF5cyB9ID0gUm91bmREdXJhdGlvbih5ZWFycywgbW9udGhzLCB3ZWVrcywgZGF5cywgMCwgMCwgMCwgMCwgMCwgMCwgcm91bmRpbmdJbmNyZW1lbnQsIHNtYWxsZXN0VW5pdCwgTmVnYXRlVGVtcG9yYWxSb3VuZGluZ01vZGUocm91bmRpbmdNb2RlKSwgdGhpcykpO1xuICAgICAgICByZXR1cm4gbmV3IER1cmF0aW9uKC15ZWFycywgLW1vbnRocywgLXdlZWtzLCAtZGF5cywgMCwgMCwgMCwgMCwgMCwgMCk7XG4gICAgfVxuICAgIGVxdWFscyhvdGhlclBhcmFtKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbERhdGUodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIGNvbnN0IG90aGVyID0gVG9UZW1wb3JhbERhdGUob3RoZXJQYXJhbSk7XG4gICAgICAgIGZvciAoY29uc3Qgc2xvdCBvZiBbSVNPX1lFQVIsIElTT19NT05USCwgSVNPX0RBWV0pIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbDEgPSBHZXRTbG90KHRoaXMsIHNsb3QpO1xuICAgICAgICAgICAgY29uc3QgdmFsMiA9IEdldFNsb3Qob3RoZXIsIHNsb3QpO1xuICAgICAgICAgICAgaWYgKHZhbDEgIT09IHZhbDIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBDYWxlbmRhckVxdWFscyhHZXRTbG90KHRoaXMsIENBTEVOREFSKSwgR2V0U2xvdChvdGhlciwgQ0FMRU5EQVIpKTtcbiAgICB9XG4gICAgdG9TdHJpbmcob3B0aW9uc1BhcmFtID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbERhdGUodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSBHZXRPcHRpb25zT2JqZWN0KG9wdGlvbnNQYXJhbSk7XG4gICAgICAgIGNvbnN0IHNob3dDYWxlbmRhciA9IFRvU2hvd0NhbGVuZGFyT3B0aW9uKG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gVGVtcG9yYWxEYXRlVG9TdHJpbmcodGhpcywgc2hvd0NhbGVuZGFyKTtcbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxEYXRlKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICByZXR1cm4gVGVtcG9yYWxEYXRlVG9TdHJpbmcodGhpcyk7XG4gICAgfVxuICAgIHRvTG9jYWxlU3RyaW5nKGxvY2FsZXMgPSB1bmRlZmluZWQsIG9wdGlvbnMgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsRGF0ZSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlVGltZUZvcm1hdChsb2NhbGVzLCBvcHRpb25zKS5mb3JtYXQodGhpcyk7XG4gICAgfVxuICAgIHZhbHVlT2YoKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3VzZSBjb21wYXJlKCkgb3IgZXF1YWxzKCkgdG8gY29tcGFyZSBUZW1wb3JhbC5QbGFpbkRhdGUnKTtcbiAgICB9XG4gICAgdG9QbGFpbkRhdGVUaW1lKHRlbXBvcmFsVGltZVBhcmFtID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbERhdGUodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIGNvbnN0IHllYXIgPSBHZXRTbG90KHRoaXMsIElTT19ZRUFSKTtcbiAgICAgICAgY29uc3QgbW9udGggPSBHZXRTbG90KHRoaXMsIElTT19NT05USCk7XG4gICAgICAgIGNvbnN0IGRheSA9IEdldFNsb3QodGhpcywgSVNPX0RBWSk7XG4gICAgICAgIGNvbnN0IGNhbGVuZGFyID0gR2V0U2xvdCh0aGlzLCBDQUxFTkRBUik7XG4gICAgICAgIGlmICh0ZW1wb3JhbFRpbWVQYXJhbSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmV0dXJuIENyZWF0ZVRlbXBvcmFsRGF0ZVRpbWUoeWVhciwgbW9udGgsIGRheSwgMCwgMCwgMCwgMCwgMCwgMCwgY2FsZW5kYXIpO1xuICAgICAgICBjb25zdCB0ZW1wb3JhbFRpbWUgPSBUb1RlbXBvcmFsVGltZSh0ZW1wb3JhbFRpbWVQYXJhbSk7XG4gICAgICAgIGNvbnN0IGhvdXIgPSBHZXRTbG90KHRlbXBvcmFsVGltZSwgSVNPX0hPVVIpO1xuICAgICAgICBjb25zdCBtaW51dGUgPSBHZXRTbG90KHRlbXBvcmFsVGltZSwgSVNPX01JTlVURSk7XG4gICAgICAgIGNvbnN0IHNlY29uZCA9IEdldFNsb3QodGVtcG9yYWxUaW1lLCBJU09fU0VDT05EKTtcbiAgICAgICAgY29uc3QgbWlsbGlzZWNvbmQgPSBHZXRTbG90KHRlbXBvcmFsVGltZSwgSVNPX01JTExJU0VDT05EKTtcbiAgICAgICAgY29uc3QgbWljcm9zZWNvbmQgPSBHZXRTbG90KHRlbXBvcmFsVGltZSwgSVNPX01JQ1JPU0VDT05EKTtcbiAgICAgICAgY29uc3QgbmFub3NlY29uZCA9IEdldFNsb3QodGVtcG9yYWxUaW1lLCBJU09fTkFOT1NFQ09ORCk7XG4gICAgICAgIHJldHVybiBDcmVhdGVUZW1wb3JhbERhdGVUaW1lKHllYXIsIG1vbnRoLCBkYXksIGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZCwgbWljcm9zZWNvbmQsIG5hbm9zZWNvbmQsIGNhbGVuZGFyKTtcbiAgICB9XG4gICAgdG9ab25lZERhdGVUaW1lKGl0ZW0pIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsRGF0ZSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgbGV0IHRpbWVab25lLCB0ZW1wb3JhbFRpbWU7XG4gICAgICAgIGlmIChJc09iamVjdChpdGVtKSkge1xuICAgICAgICAgICAgY29uc3QgdGltZVpvbmVMaWtlID0gaXRlbS50aW1lWm9uZTtcbiAgICAgICAgICAgIGlmICh0aW1lWm9uZUxpa2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIC8vIFRoZSBjYXN0IGJlbG93IGlzIG5lZWRlZCBiZWNhdXNlIGl0J3MgcG9zc2libGUgaGVyZSBmb3JcbiAgICAgICAgICAgICAgICAvLyBgdGltZVpvbmVMaWtlYCBoZXJlIHRvIGJlIGB7IHBsYWluVGltZTogVGVtcG9yYWwuUGxhaW5UaW1lTGlrZSB9YCxcbiAgICAgICAgICAgICAgICAvLyBub3QgYSBUaW1lWm9uZVByb3RvY29sLlxuICAgICAgICAgICAgICAgIC8vIFRPRE86IHNob3VsZCB3ZSBjaGVjayBmb3IgdGhhdCBzaGFwZSB0byBpbXByb3ZlIG9uIHRoZSAoYmFkKSBlcnJvclxuICAgICAgICAgICAgICAgIC8vIG1lc3NhZ2UgdGhhdCB0aGUgY2FsbGVyIHdpbGwgZ2V0IGZyb20gVG9UZW1wb3JhbFRpbWVab25lP1xuICAgICAgICAgICAgICAgIHRpbWVab25lID0gVG9UZW1wb3JhbFRpbWVab25lKGl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGltZVpvbmUgPSBUb1RlbXBvcmFsVGltZVpvbmUodGltZVpvbmVMaWtlKTtcbiAgICAgICAgICAgICAgICB0ZW1wb3JhbFRpbWUgPSBpdGVtLnBsYWluVGltZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRpbWVab25lID0gVG9UZW1wb3JhbFRpbWVab25lKGl0ZW0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHllYXIgPSBHZXRTbG90KHRoaXMsIElTT19ZRUFSKTtcbiAgICAgICAgY29uc3QgbW9udGggPSBHZXRTbG90KHRoaXMsIElTT19NT05USCk7XG4gICAgICAgIGNvbnN0IGRheSA9IEdldFNsb3QodGhpcywgSVNPX0RBWSk7XG4gICAgICAgIGNvbnN0IGNhbGVuZGFyID0gR2V0U2xvdCh0aGlzLCBDQUxFTkRBUik7XG4gICAgICAgIGxldCBob3VyID0gMCwgbWludXRlID0gMCwgc2Vjb25kID0gMCwgbWlsbGlzZWNvbmQgPSAwLCBtaWNyb3NlY29uZCA9IDAsIG5hbm9zZWNvbmQgPSAwO1xuICAgICAgICBpZiAodGVtcG9yYWxUaW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRlbXBvcmFsVGltZSA9IFRvVGVtcG9yYWxUaW1lKHRlbXBvcmFsVGltZSk7XG4gICAgICAgICAgICBob3VyID0gR2V0U2xvdCh0ZW1wb3JhbFRpbWUsIElTT19IT1VSKTtcbiAgICAgICAgICAgIG1pbnV0ZSA9IEdldFNsb3QodGVtcG9yYWxUaW1lLCBJU09fTUlOVVRFKTtcbiAgICAgICAgICAgIHNlY29uZCA9IEdldFNsb3QodGVtcG9yYWxUaW1lLCBJU09fU0VDT05EKTtcbiAgICAgICAgICAgIG1pbGxpc2Vjb25kID0gR2V0U2xvdCh0ZW1wb3JhbFRpbWUsIElTT19NSUxMSVNFQ09ORCk7XG4gICAgICAgICAgICBtaWNyb3NlY29uZCA9IEdldFNsb3QodGVtcG9yYWxUaW1lLCBJU09fTUlDUk9TRUNPTkQpO1xuICAgICAgICAgICAgbmFub3NlY29uZCA9IEdldFNsb3QodGVtcG9yYWxUaW1lLCBJU09fTkFOT1NFQ09ORCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZHQgPSBDcmVhdGVUZW1wb3JhbERhdGVUaW1lKHllYXIsIG1vbnRoLCBkYXksIGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZCwgbWljcm9zZWNvbmQsIG5hbm9zZWNvbmQsIGNhbGVuZGFyKTtcbiAgICAgICAgY29uc3QgaW5zdGFudCA9IEJ1aWx0aW5UaW1lWm9uZUdldEluc3RhbnRGb3IodGltZVpvbmUsIGR0LCAnY29tcGF0aWJsZScpO1xuICAgICAgICByZXR1cm4gQ3JlYXRlVGVtcG9yYWxab25lZERhdGVUaW1lKEdldFNsb3QoaW5zdGFudCwgRVBPQ0hOQU5PU0VDT05EUyksIHRpbWVab25lLCBjYWxlbmRhcik7XG4gICAgfVxuICAgIHRvUGxhaW5ZZWFyTW9udGgoKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbERhdGUodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIGNvbnN0IGNhbGVuZGFyID0gR2V0U2xvdCh0aGlzLCBDQUxFTkRBUik7XG4gICAgICAgIGNvbnN0IGZpZWxkTmFtZXMgPSBDYWxlbmRhckZpZWxkcyhjYWxlbmRhciwgWydtb250aENvZGUnLCAneWVhciddKTtcbiAgICAgICAgY29uc3QgZmllbGRzID0gVG9UZW1wb3JhbFllYXJNb250aEZpZWxkcyh0aGlzLCBmaWVsZE5hbWVzKTtcbiAgICAgICAgcmV0dXJuIFllYXJNb250aEZyb21GaWVsZHMoY2FsZW5kYXIsIGZpZWxkcyk7XG4gICAgfVxuICAgIHRvUGxhaW5Nb250aERheSgpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsRGF0ZSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgY29uc3QgY2FsZW5kYXIgPSBHZXRTbG90KHRoaXMsIENBTEVOREFSKTtcbiAgICAgICAgY29uc3QgZmllbGROYW1lcyA9IENhbGVuZGFyRmllbGRzKGNhbGVuZGFyLCBbJ2RheScsICdtb250aENvZGUnXSk7XG4gICAgICAgIGNvbnN0IGZpZWxkcyA9IFRvVGVtcG9yYWxNb250aERheUZpZWxkcyh0aGlzLCBmaWVsZE5hbWVzKTtcbiAgICAgICAgcmV0dXJuIE1vbnRoRGF5RnJvbUZpZWxkcyhjYWxlbmRhciwgZmllbGRzKTtcbiAgICB9XG4gICAgZ2V0SVNPRmllbGRzKCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxEYXRlKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY2FsZW5kYXI6IEdldFNsb3QodGhpcywgQ0FMRU5EQVIpLFxuICAgICAgICAgICAgaXNvRGF5OiBHZXRTbG90KHRoaXMsIElTT19EQVkpLFxuICAgICAgICAgICAgaXNvTW9udGg6IEdldFNsb3QodGhpcywgSVNPX01PTlRIKSxcbiAgICAgICAgICAgIGlzb1llYXI6IEdldFNsb3QodGhpcywgSVNPX1lFQVIpXG4gICAgICAgIH07XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tKGl0ZW0sIG9wdGlvbnNQYXJhbSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCBvcHRpb25zID0gR2V0T3B0aW9uc09iamVjdChvcHRpb25zUGFyYW0pO1xuICAgICAgICBpZiAoSXNUZW1wb3JhbERhdGUoaXRlbSkpIHtcbiAgICAgICAgICAgIFRvVGVtcG9yYWxPdmVyZmxvdyhvcHRpb25zKTsgLy8gdmFsaWRhdGUgYW5kIGlnbm9yZVxuICAgICAgICAgICAgcmV0dXJuIENyZWF0ZVRlbXBvcmFsRGF0ZShHZXRTbG90KGl0ZW0sIElTT19ZRUFSKSwgR2V0U2xvdChpdGVtLCBJU09fTU9OVEgpLCBHZXRTbG90KGl0ZW0sIElTT19EQVkpLCBHZXRTbG90KGl0ZW0sIENBTEVOREFSKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFRvVGVtcG9yYWxEYXRlKGl0ZW0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBzdGF0aWMgY29tcGFyZShvbmVQYXJhbSwgdHdvUGFyYW0pIHtcbiAgICAgICAgY29uc3Qgb25lID0gVG9UZW1wb3JhbERhdGUob25lUGFyYW0pO1xuICAgICAgICBjb25zdCB0d28gPSBUb1RlbXBvcmFsRGF0ZSh0d29QYXJhbSk7XG4gICAgICAgIHJldHVybiBDb21wYXJlSVNPRGF0ZShHZXRTbG90KG9uZSwgSVNPX1lFQVIpLCBHZXRTbG90KG9uZSwgSVNPX01PTlRIKSwgR2V0U2xvdChvbmUsIElTT19EQVkpLCBHZXRTbG90KHR3bywgSVNPX1lFQVIpLCBHZXRTbG90KHR3bywgSVNPX01PTlRIKSwgR2V0U2xvdCh0d28sIElTT19EQVkpKTtcbiAgICB9XG59XG5NYWtlSW50cmluc2ljQ2xhc3MoUGxhaW5EYXRlLCAnVGVtcG9yYWwuUGxhaW5EYXRlJyk7XG5cbmNsYXNzIFBsYWluRGF0ZVRpbWUge1xuICAgIGNvbnN0cnVjdG9yKGlzb1llYXJQYXJhbSwgaXNvTW9udGhQYXJhbSwgaXNvRGF5UGFyYW0sIGhvdXJQYXJhbSA9IDAsIG1pbnV0ZVBhcmFtID0gMCwgc2Vjb25kUGFyYW0gPSAwLCBtaWxsaXNlY29uZFBhcmFtID0gMCwgbWljcm9zZWNvbmRQYXJhbSA9IDAsIG5hbm9zZWNvbmRQYXJhbSA9IDAsIGNhbGVuZGFyUGFyYW0gPSBHZXRJU084NjAxQ2FsZW5kYXIoKSkge1xuICAgICAgICBjb25zdCBpc29ZZWFyID0gVG9JbnRlZ2VyVGhyb3dPbkluZmluaXR5KGlzb1llYXJQYXJhbSk7XG4gICAgICAgIGNvbnN0IGlzb01vbnRoID0gVG9JbnRlZ2VyVGhyb3dPbkluZmluaXR5KGlzb01vbnRoUGFyYW0pO1xuICAgICAgICBjb25zdCBpc29EYXkgPSBUb0ludGVnZXJUaHJvd09uSW5maW5pdHkoaXNvRGF5UGFyYW0pO1xuICAgICAgICBjb25zdCBob3VyID0gVG9JbnRlZ2VyVGhyb3dPbkluZmluaXR5KGhvdXJQYXJhbSk7XG4gICAgICAgIGNvbnN0IG1pbnV0ZSA9IFRvSW50ZWdlclRocm93T25JbmZpbml0eShtaW51dGVQYXJhbSk7XG4gICAgICAgIGNvbnN0IHNlY29uZCA9IFRvSW50ZWdlclRocm93T25JbmZpbml0eShzZWNvbmRQYXJhbSk7XG4gICAgICAgIGNvbnN0IG1pbGxpc2Vjb25kID0gVG9JbnRlZ2VyVGhyb3dPbkluZmluaXR5KG1pbGxpc2Vjb25kUGFyYW0pO1xuICAgICAgICBjb25zdCBtaWNyb3NlY29uZCA9IFRvSW50ZWdlclRocm93T25JbmZpbml0eShtaWNyb3NlY29uZFBhcmFtKTtcbiAgICAgICAgY29uc3QgbmFub3NlY29uZCA9IFRvSW50ZWdlclRocm93T25JbmZpbml0eShuYW5vc2Vjb25kUGFyYW0pO1xuICAgICAgICBjb25zdCBjYWxlbmRhciA9IFRvVGVtcG9yYWxDYWxlbmRhcihjYWxlbmRhclBhcmFtKTtcbiAgICAgICAgLy8gTm90ZTogaWYgdGhlIGFyZ3VtZW50cyBhcmUgbm90IHBhc3NlZCxcbiAgICAgICAgLy8gICAgICAgVG9JbnRlZ2VyVGhyb3dPbkluZmluaXR5KHVuZGVmaW5lZCkgd2lsbCBoYXZlIHJldHVybmVkIDAsIHdoaWNoIHdpbGxcbiAgICAgICAgLy8gICAgICAgYmUgcmVqZWN0ZWQgYnkgUmVqZWN0RGF0ZVRpbWUgaW4gQ3JlYXRlVGVtcG9yYWxEYXRlVGltZVNsb3RzLiBUaGlzXG4gICAgICAgIC8vICAgICAgIGNoZWNrIGV4aXN0cyBvbmx5IHRvIGltcHJvdmUgdGhlIGVycm9yIG1lc3NhZ2UuXG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ21pc3NpbmcgYXJndW1lbnQ6IGlzb1llYXIsIGlzb01vbnRoIGFuZCBpc29EYXkgYXJlIHJlcXVpcmVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgQ3JlYXRlVGVtcG9yYWxEYXRlVGltZVNsb3RzKHRoaXMsIGlzb1llYXIsIGlzb01vbnRoLCBpc29EYXksIGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZCwgbWljcm9zZWNvbmQsIG5hbm9zZWNvbmQsIGNhbGVuZGFyKTtcbiAgICB9XG4gICAgZ2V0IGNhbGVuZGFyKCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxEYXRlVGltZSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgcmV0dXJuIEdldFNsb3QodGhpcywgQ0FMRU5EQVIpO1xuICAgIH1cbiAgICBnZXQgeWVhcigpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsRGF0ZVRpbWUodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIHJldHVybiBDYWxlbmRhclllYXIoR2V0U2xvdCh0aGlzLCBDQUxFTkRBUiksIHRoaXMpO1xuICAgIH1cbiAgICBnZXQgbW9udGgoKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbERhdGVUaW1lKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICByZXR1cm4gQ2FsZW5kYXJNb250aChHZXRTbG90KHRoaXMsIENBTEVOREFSKSwgdGhpcyk7XG4gICAgfVxuICAgIGdldCBtb250aENvZGUoKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbERhdGVUaW1lKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICByZXR1cm4gQ2FsZW5kYXJNb250aENvZGUoR2V0U2xvdCh0aGlzLCBDQUxFTkRBUiksIHRoaXMpO1xuICAgIH1cbiAgICBnZXQgZGF5KCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxEYXRlVGltZSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgcmV0dXJuIENhbGVuZGFyRGF5KEdldFNsb3QodGhpcywgQ0FMRU5EQVIpLCB0aGlzKTtcbiAgICB9XG4gICAgZ2V0IGhvdXIoKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbERhdGVUaW1lKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICByZXR1cm4gR2V0U2xvdCh0aGlzLCBJU09fSE9VUik7XG4gICAgfVxuICAgIGdldCBtaW51dGUoKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbERhdGVUaW1lKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICByZXR1cm4gR2V0U2xvdCh0aGlzLCBJU09fTUlOVVRFKTtcbiAgICB9XG4gICAgZ2V0IHNlY29uZCgpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsRGF0ZVRpbWUodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIHJldHVybiBHZXRTbG90KHRoaXMsIElTT19TRUNPTkQpO1xuICAgIH1cbiAgICBnZXQgbWlsbGlzZWNvbmQoKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbERhdGVUaW1lKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICByZXR1cm4gR2V0U2xvdCh0aGlzLCBJU09fTUlMTElTRUNPTkQpO1xuICAgIH1cbiAgICBnZXQgbWljcm9zZWNvbmQoKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbERhdGVUaW1lKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICByZXR1cm4gR2V0U2xvdCh0aGlzLCBJU09fTUlDUk9TRUNPTkQpO1xuICAgIH1cbiAgICBnZXQgbmFub3NlY29uZCgpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsRGF0ZVRpbWUodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIHJldHVybiBHZXRTbG90KHRoaXMsIElTT19OQU5PU0VDT05EKTtcbiAgICB9XG4gICAgZ2V0IGVyYSgpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsRGF0ZVRpbWUodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIHJldHVybiBDYWxlbmRhckVyYShHZXRTbG90KHRoaXMsIENBTEVOREFSKSwgdGhpcyk7XG4gICAgfVxuICAgIGdldCBlcmFZZWFyKCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxEYXRlVGltZSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgcmV0dXJuIENhbGVuZGFyRXJhWWVhcihHZXRTbG90KHRoaXMsIENBTEVOREFSKSwgdGhpcyk7XG4gICAgfVxuICAgIGdldCBkYXlPZldlZWsoKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbERhdGVUaW1lKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICByZXR1cm4gQ2FsZW5kYXJEYXlPZldlZWsoR2V0U2xvdCh0aGlzLCBDQUxFTkRBUiksIHRoaXMpO1xuICAgIH1cbiAgICBnZXQgZGF5T2ZZZWFyKCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxEYXRlVGltZSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgcmV0dXJuIENhbGVuZGFyRGF5T2ZZZWFyKEdldFNsb3QodGhpcywgQ0FMRU5EQVIpLCB0aGlzKTtcbiAgICB9XG4gICAgZ2V0IHdlZWtPZlllYXIoKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbERhdGVUaW1lKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICByZXR1cm4gQ2FsZW5kYXJXZWVrT2ZZZWFyKEdldFNsb3QodGhpcywgQ0FMRU5EQVIpLCB0aGlzKTtcbiAgICB9XG4gICAgZ2V0IGRheXNJbldlZWsoKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbERhdGVUaW1lKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICByZXR1cm4gQ2FsZW5kYXJEYXlzSW5XZWVrKEdldFNsb3QodGhpcywgQ0FMRU5EQVIpLCB0aGlzKTtcbiAgICB9XG4gICAgZ2V0IGRheXNJblllYXIoKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbERhdGVUaW1lKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICByZXR1cm4gQ2FsZW5kYXJEYXlzSW5ZZWFyKEdldFNsb3QodGhpcywgQ0FMRU5EQVIpLCB0aGlzKTtcbiAgICB9XG4gICAgZ2V0IGRheXNJbk1vbnRoKCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxEYXRlVGltZSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgcmV0dXJuIENhbGVuZGFyRGF5c0luTW9udGgoR2V0U2xvdCh0aGlzLCBDQUxFTkRBUiksIHRoaXMpO1xuICAgIH1cbiAgICBnZXQgbW9udGhzSW5ZZWFyKCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxEYXRlVGltZSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgcmV0dXJuIENhbGVuZGFyTW9udGhzSW5ZZWFyKEdldFNsb3QodGhpcywgQ0FMRU5EQVIpLCB0aGlzKTtcbiAgICB9XG4gICAgZ2V0IGluTGVhcFllYXIoKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbERhdGVUaW1lKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICByZXR1cm4gQ2FsZW5kYXJJbkxlYXBZZWFyKEdldFNsb3QodGhpcywgQ0FMRU5EQVIpLCB0aGlzKTtcbiAgICB9XG4gICAgd2l0aCh0ZW1wb3JhbERhdGVUaW1lTGlrZSwgb3B0aW9uc1BhcmFtID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbERhdGVUaW1lKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICBpZiAoIUlzT2JqZWN0KHRlbXBvcmFsRGF0ZVRpbWVMaWtlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBhcmd1bWVudCcpO1xuICAgICAgICB9XG4gICAgICAgIFJlamVjdE9iamVjdFdpdGhDYWxlbmRhck9yVGltZVpvbmUodGVtcG9yYWxEYXRlVGltZUxpa2UpO1xuICAgICAgICBjb25zdCBvcHRpb25zID0gR2V0T3B0aW9uc09iamVjdChvcHRpb25zUGFyYW0pO1xuICAgICAgICBjb25zdCBjYWxlbmRhciA9IEdldFNsb3QodGhpcywgQ0FMRU5EQVIpO1xuICAgICAgICBjb25zdCBmaWVsZE5hbWVzID0gQ2FsZW5kYXJGaWVsZHMoY2FsZW5kYXIsIFtcbiAgICAgICAgICAgICdkYXknLFxuICAgICAgICAgICAgJ2hvdXInLFxuICAgICAgICAgICAgJ21pY3Jvc2Vjb25kJyxcbiAgICAgICAgICAgICdtaWxsaXNlY29uZCcsXG4gICAgICAgICAgICAnbWludXRlJyxcbiAgICAgICAgICAgICdtb250aCcsXG4gICAgICAgICAgICAnbW9udGhDb2RlJyxcbiAgICAgICAgICAgICduYW5vc2Vjb25kJyxcbiAgICAgICAgICAgICdzZWNvbmQnLFxuICAgICAgICAgICAgJ3llYXInXG4gICAgICAgIF0pO1xuICAgICAgICBjb25zdCBwcm9wcyA9IFRvUGFydGlhbFJlY29yZCh0ZW1wb3JhbERhdGVUaW1lTGlrZSwgZmllbGROYW1lcyk7XG4gICAgICAgIGlmICghcHJvcHMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgZGF0ZS10aW1lLWxpa2UnKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZmllbGRzID0gVG9UZW1wb3JhbERhdGVUaW1lRmllbGRzKHRoaXMsIGZpZWxkTmFtZXMpO1xuICAgICAgICBmaWVsZHMgPSBDYWxlbmRhck1lcmdlRmllbGRzKGNhbGVuZGFyLCBmaWVsZHMsIHByb3BzKTtcbiAgICAgICAgZmllbGRzID0gVG9UZW1wb3JhbERhdGVUaW1lRmllbGRzKGZpZWxkcywgZmllbGROYW1lcyk7XG4gICAgICAgIGNvbnN0IHsgeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kLCBtaWNyb3NlY29uZCwgbmFub3NlY29uZCB9ID0gSW50ZXJwcmV0VGVtcG9yYWxEYXRlVGltZUZpZWxkcyhjYWxlbmRhciwgZmllbGRzLCBvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIENyZWF0ZVRlbXBvcmFsRGF0ZVRpbWUoeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kLCBtaWNyb3NlY29uZCwgbmFub3NlY29uZCwgY2FsZW5kYXIpO1xuICAgIH1cbiAgICB3aXRoUGxhaW5UaW1lKHRlbXBvcmFsVGltZVBhcmFtID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbERhdGVUaW1lKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICBjb25zdCB5ZWFyID0gR2V0U2xvdCh0aGlzLCBJU09fWUVBUik7XG4gICAgICAgIGNvbnN0IG1vbnRoID0gR2V0U2xvdCh0aGlzLCBJU09fTU9OVEgpO1xuICAgICAgICBjb25zdCBkYXkgPSBHZXRTbG90KHRoaXMsIElTT19EQVkpO1xuICAgICAgICBjb25zdCBjYWxlbmRhciA9IEdldFNsb3QodGhpcywgQ0FMRU5EQVIpO1xuICAgICAgICBpZiAodGVtcG9yYWxUaW1lUGFyYW0gPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJldHVybiBDcmVhdGVUZW1wb3JhbERhdGVUaW1lKHllYXIsIG1vbnRoLCBkYXksIDAsIDAsIDAsIDAsIDAsIDAsIGNhbGVuZGFyKTtcbiAgICAgICAgY29uc3QgdGVtcG9yYWxUaW1lID0gVG9UZW1wb3JhbFRpbWUodGVtcG9yYWxUaW1lUGFyYW0pO1xuICAgICAgICBjb25zdCBob3VyID0gR2V0U2xvdCh0ZW1wb3JhbFRpbWUsIElTT19IT1VSKTtcbiAgICAgICAgY29uc3QgbWludXRlID0gR2V0U2xvdCh0ZW1wb3JhbFRpbWUsIElTT19NSU5VVEUpO1xuICAgICAgICBjb25zdCBzZWNvbmQgPSBHZXRTbG90KHRlbXBvcmFsVGltZSwgSVNPX1NFQ09ORCk7XG4gICAgICAgIGNvbnN0IG1pbGxpc2Vjb25kID0gR2V0U2xvdCh0ZW1wb3JhbFRpbWUsIElTT19NSUxMSVNFQ09ORCk7XG4gICAgICAgIGNvbnN0IG1pY3Jvc2Vjb25kID0gR2V0U2xvdCh0ZW1wb3JhbFRpbWUsIElTT19NSUNST1NFQ09ORCk7XG4gICAgICAgIGNvbnN0IG5hbm9zZWNvbmQgPSBHZXRTbG90KHRlbXBvcmFsVGltZSwgSVNPX05BTk9TRUNPTkQpO1xuICAgICAgICByZXR1cm4gQ3JlYXRlVGVtcG9yYWxEYXRlVGltZSh5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQsIG1pY3Jvc2Vjb25kLCBuYW5vc2Vjb25kLCBjYWxlbmRhcik7XG4gICAgfVxuICAgIHdpdGhQbGFpbkRhdGUodGVtcG9yYWxEYXRlUGFyYW0pIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsRGF0ZVRpbWUodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIGNvbnN0IHRlbXBvcmFsRGF0ZSA9IFRvVGVtcG9yYWxEYXRlKHRlbXBvcmFsRGF0ZVBhcmFtKTtcbiAgICAgICAgY29uc3QgeWVhciA9IEdldFNsb3QodGVtcG9yYWxEYXRlLCBJU09fWUVBUik7XG4gICAgICAgIGNvbnN0IG1vbnRoID0gR2V0U2xvdCh0ZW1wb3JhbERhdGUsIElTT19NT05USCk7XG4gICAgICAgIGNvbnN0IGRheSA9IEdldFNsb3QodGVtcG9yYWxEYXRlLCBJU09fREFZKTtcbiAgICAgICAgbGV0IGNhbGVuZGFyID0gR2V0U2xvdCh0ZW1wb3JhbERhdGUsIENBTEVOREFSKTtcbiAgICAgICAgY29uc3QgaG91ciA9IEdldFNsb3QodGhpcywgSVNPX0hPVVIpO1xuICAgICAgICBjb25zdCBtaW51dGUgPSBHZXRTbG90KHRoaXMsIElTT19NSU5VVEUpO1xuICAgICAgICBjb25zdCBzZWNvbmQgPSBHZXRTbG90KHRoaXMsIElTT19TRUNPTkQpO1xuICAgICAgICBjb25zdCBtaWxsaXNlY29uZCA9IEdldFNsb3QodGhpcywgSVNPX01JTExJU0VDT05EKTtcbiAgICAgICAgY29uc3QgbWljcm9zZWNvbmQgPSBHZXRTbG90KHRoaXMsIElTT19NSUNST1NFQ09ORCk7XG4gICAgICAgIGNvbnN0IG5hbm9zZWNvbmQgPSBHZXRTbG90KHRoaXMsIElTT19OQU5PU0VDT05EKTtcbiAgICAgICAgY2FsZW5kYXIgPSBDb25zb2xpZGF0ZUNhbGVuZGFycyhHZXRTbG90KHRoaXMsIENBTEVOREFSKSwgY2FsZW5kYXIpO1xuICAgICAgICByZXR1cm4gQ3JlYXRlVGVtcG9yYWxEYXRlVGltZSh5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQsIG1pY3Jvc2Vjb25kLCBuYW5vc2Vjb25kLCBjYWxlbmRhcik7XG4gICAgfVxuICAgIHdpdGhDYWxlbmRhcihjYWxlbmRhclBhcmFtKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbERhdGVUaW1lKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICBjb25zdCBjYWxlbmRhciA9IFRvVGVtcG9yYWxDYWxlbmRhcihjYWxlbmRhclBhcmFtKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQbGFpbkRhdGVUaW1lKEdldFNsb3QodGhpcywgSVNPX1lFQVIpLCBHZXRTbG90KHRoaXMsIElTT19NT05USCksIEdldFNsb3QodGhpcywgSVNPX0RBWSksIEdldFNsb3QodGhpcywgSVNPX0hPVVIpLCBHZXRTbG90KHRoaXMsIElTT19NSU5VVEUpLCBHZXRTbG90KHRoaXMsIElTT19TRUNPTkQpLCBHZXRTbG90KHRoaXMsIElTT19NSUxMSVNFQ09ORCksIEdldFNsb3QodGhpcywgSVNPX01JQ1JPU0VDT05EKSwgR2V0U2xvdCh0aGlzLCBJU09fTkFOT1NFQ09ORCksIGNhbGVuZGFyKTtcbiAgICB9XG4gICAgYWRkKHRlbXBvcmFsRHVyYXRpb25MaWtlLCBvcHRpb25zUGFyYW0gPSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsRGF0ZVRpbWUodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIGNvbnN0IGR1cmF0aW9uID0gVG9MaW1pdGVkVGVtcG9yYWxEdXJhdGlvbih0ZW1wb3JhbER1cmF0aW9uTGlrZSk7XG4gICAgICAgIGNvbnN0IHsgeWVhcnMsIG1vbnRocywgd2Vla3MsIGRheXMsIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBtaWxsaXNlY29uZHMsIG1pY3Jvc2Vjb25kcywgbmFub3NlY29uZHMgfSA9IGR1cmF0aW9uO1xuICAgICAgICBjb25zdCBvcHRpb25zID0gR2V0T3B0aW9uc09iamVjdChvcHRpb25zUGFyYW0pO1xuICAgICAgICBjb25zdCBjYWxlbmRhciA9IEdldFNsb3QodGhpcywgQ0FMRU5EQVIpO1xuICAgICAgICBjb25zdCB7IHllYXIsIG1vbnRoLCBkYXksIGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZCwgbWljcm9zZWNvbmQsIG5hbm9zZWNvbmQgfSA9IEFkZERhdGVUaW1lKEdldFNsb3QodGhpcywgSVNPX1lFQVIpLCBHZXRTbG90KHRoaXMsIElTT19NT05USCksIEdldFNsb3QodGhpcywgSVNPX0RBWSksIEdldFNsb3QodGhpcywgSVNPX0hPVVIpLCBHZXRTbG90KHRoaXMsIElTT19NSU5VVEUpLCBHZXRTbG90KHRoaXMsIElTT19TRUNPTkQpLCBHZXRTbG90KHRoaXMsIElTT19NSUxMSVNFQ09ORCksIEdldFNsb3QodGhpcywgSVNPX01JQ1JPU0VDT05EKSwgR2V0U2xvdCh0aGlzLCBJU09fTkFOT1NFQ09ORCksIGNhbGVuZGFyLCB5ZWFycywgbW9udGhzLCB3ZWVrcywgZGF5cywgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc2Vjb25kcywgbWljcm9zZWNvbmRzLCBuYW5vc2Vjb25kcywgb3B0aW9ucyk7XG4gICAgICAgIHJldHVybiBDcmVhdGVUZW1wb3JhbERhdGVUaW1lKHllYXIsIG1vbnRoLCBkYXksIGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZCwgbWljcm9zZWNvbmQsIG5hbm9zZWNvbmQsIGNhbGVuZGFyKTtcbiAgICB9XG4gICAgc3VidHJhY3QodGVtcG9yYWxEdXJhdGlvbkxpa2UsIG9wdGlvbnNQYXJhbSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxEYXRlVGltZSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgY29uc3QgZHVyYXRpb24gPSBUb0xpbWl0ZWRUZW1wb3JhbER1cmF0aW9uKHRlbXBvcmFsRHVyYXRpb25MaWtlKTtcbiAgICAgICAgY29uc3QgeyB5ZWFycywgbW9udGhzLCB3ZWVrcywgZGF5cywgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc2Vjb25kcywgbWljcm9zZWNvbmRzLCBuYW5vc2Vjb25kcyB9ID0gZHVyYXRpb247XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSBHZXRPcHRpb25zT2JqZWN0KG9wdGlvbnNQYXJhbSk7XG4gICAgICAgIGNvbnN0IGNhbGVuZGFyID0gR2V0U2xvdCh0aGlzLCBDQUxFTkRBUik7XG4gICAgICAgIGNvbnN0IHsgeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kLCBtaWNyb3NlY29uZCwgbmFub3NlY29uZCB9ID0gQWRkRGF0ZVRpbWUoR2V0U2xvdCh0aGlzLCBJU09fWUVBUiksIEdldFNsb3QodGhpcywgSVNPX01PTlRIKSwgR2V0U2xvdCh0aGlzLCBJU09fREFZKSwgR2V0U2xvdCh0aGlzLCBJU09fSE9VUiksIEdldFNsb3QodGhpcywgSVNPX01JTlVURSksIEdldFNsb3QodGhpcywgSVNPX1NFQ09ORCksIEdldFNsb3QodGhpcywgSVNPX01JTExJU0VDT05EKSwgR2V0U2xvdCh0aGlzLCBJU09fTUlDUk9TRUNPTkQpLCBHZXRTbG90KHRoaXMsIElTT19OQU5PU0VDT05EKSwgY2FsZW5kYXIsIC15ZWFycywgLW1vbnRocywgLXdlZWtzLCAtZGF5cywgLWhvdXJzLCAtbWludXRlcywgLXNlY29uZHMsIC1taWxsaXNlY29uZHMsIC1taWNyb3NlY29uZHMsIC1uYW5vc2Vjb25kcywgb3B0aW9ucyk7XG4gICAgICAgIHJldHVybiBDcmVhdGVUZW1wb3JhbERhdGVUaW1lKHllYXIsIG1vbnRoLCBkYXksIGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZCwgbWljcm9zZWNvbmQsIG5hbm9zZWNvbmQsIGNhbGVuZGFyKTtcbiAgICB9XG4gICAgdW50aWwob3RoZXJQYXJhbSwgb3B0aW9uc1BhcmFtID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbERhdGVUaW1lKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICBjb25zdCBvdGhlciA9IFRvVGVtcG9yYWxEYXRlVGltZShvdGhlclBhcmFtKTtcbiAgICAgICAgY29uc3QgY2FsZW5kYXIgPSBHZXRTbG90KHRoaXMsIENBTEVOREFSKTtcbiAgICAgICAgY29uc3Qgb3RoZXJDYWxlbmRhciA9IEdldFNsb3Qob3RoZXIsIENBTEVOREFSKTtcbiAgICAgICAgY29uc3QgY2FsZW5kYXJJZCA9IFRvU3RyaW5nKGNhbGVuZGFyKTtcbiAgICAgICAgY29uc3Qgb3RoZXJDYWxlbmRhcklkID0gVG9TdHJpbmcob3RoZXJDYWxlbmRhcik7XG4gICAgICAgIGlmIChjYWxlbmRhcklkICE9PSBvdGhlckNhbGVuZGFySWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBjYW5ub3QgY29tcHV0ZSBkaWZmZXJlbmNlIGJldHdlZW4gZGF0ZXMgb2YgJHtjYWxlbmRhcklkfSBhbmQgJHtvdGhlckNhbGVuZGFySWR9IGNhbGVuZGFyc2ApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSBHZXRPcHRpb25zT2JqZWN0KG9wdGlvbnNQYXJhbSk7XG4gICAgICAgIGNvbnN0IHNtYWxsZXN0VW5pdCA9IFRvU21hbGxlc3RUZW1wb3JhbFVuaXQob3B0aW9ucywgJ25hbm9zZWNvbmQnKTtcbiAgICAgICAgY29uc3QgZGVmYXVsdExhcmdlc3RVbml0ID0gTGFyZ2VyT2ZUd29UZW1wb3JhbFVuaXRzKCdkYXknLCBzbWFsbGVzdFVuaXQpO1xuICAgICAgICBjb25zdCBsYXJnZXN0VW5pdCA9IFRvTGFyZ2VzdFRlbXBvcmFsVW5pdChvcHRpb25zLCAnYXV0bycsIFtdLCBkZWZhdWx0TGFyZ2VzdFVuaXQpO1xuICAgICAgICBWYWxpZGF0ZVRlbXBvcmFsVW5pdFJhbmdlKGxhcmdlc3RVbml0LCBzbWFsbGVzdFVuaXQpO1xuICAgICAgICBjb25zdCByb3VuZGluZ01vZGUgPSBUb1RlbXBvcmFsUm91bmRpbmdNb2RlKG9wdGlvbnMsICd0cnVuYycpO1xuICAgICAgICBjb25zdCByb3VuZGluZ0luY3JlbWVudCA9IFRvVGVtcG9yYWxEYXRlVGltZVJvdW5kaW5nSW5jcmVtZW50KG9wdGlvbnMsIHNtYWxsZXN0VW5pdCk7XG4gICAgICAgIGxldCB7IHllYXJzLCBtb250aHMsIHdlZWtzLCBkYXlzLCBob3VycywgbWludXRlcywgc2Vjb25kcywgbWlsbGlzZWNvbmRzLCBtaWNyb3NlY29uZHMsIG5hbm9zZWNvbmRzIH0gPSBEaWZmZXJlbmNlSVNPRGF0ZVRpbWUoR2V0U2xvdCh0aGlzLCBJU09fWUVBUiksIEdldFNsb3QodGhpcywgSVNPX01PTlRIKSwgR2V0U2xvdCh0aGlzLCBJU09fREFZKSwgR2V0U2xvdCh0aGlzLCBJU09fSE9VUiksIEdldFNsb3QodGhpcywgSVNPX01JTlVURSksIEdldFNsb3QodGhpcywgSVNPX1NFQ09ORCksIEdldFNsb3QodGhpcywgSVNPX01JTExJU0VDT05EKSwgR2V0U2xvdCh0aGlzLCBJU09fTUlDUk9TRUNPTkQpLCBHZXRTbG90KHRoaXMsIElTT19OQU5PU0VDT05EKSwgR2V0U2xvdChvdGhlciwgSVNPX1lFQVIpLCBHZXRTbG90KG90aGVyLCBJU09fTU9OVEgpLCBHZXRTbG90KG90aGVyLCBJU09fREFZKSwgR2V0U2xvdChvdGhlciwgSVNPX0hPVVIpLCBHZXRTbG90KG90aGVyLCBJU09fTUlOVVRFKSwgR2V0U2xvdChvdGhlciwgSVNPX1NFQ09ORCksIEdldFNsb3Qob3RoZXIsIElTT19NSUxMSVNFQ09ORCksIEdldFNsb3Qob3RoZXIsIElTT19NSUNST1NFQ09ORCksIEdldFNsb3Qob3RoZXIsIElTT19OQU5PU0VDT05EKSwgY2FsZW5kYXIsIGxhcmdlc3RVbml0LCBvcHRpb25zKTtcbiAgICAgICAgY29uc3QgcmVsYXRpdmVUbyA9IFRlbXBvcmFsRGF0ZVRpbWVUb0RhdGUodGhpcyk7XG4gICAgICAgICh7IHllYXJzLCBtb250aHMsIHdlZWtzLCBkYXlzLCBob3VycywgbWludXRlcywgc2Vjb25kcywgbWlsbGlzZWNvbmRzLCBtaWNyb3NlY29uZHMsIG5hbm9zZWNvbmRzIH0gPVxuICAgICAgICAgICAgUm91bmREdXJhdGlvbih5ZWFycywgbW9udGhzLCB3ZWVrcywgZGF5cywgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc2Vjb25kcywgbWljcm9zZWNvbmRzLCBuYW5vc2Vjb25kcywgcm91bmRpbmdJbmNyZW1lbnQsIHNtYWxsZXN0VW5pdCwgcm91bmRpbmdNb2RlLCByZWxhdGl2ZVRvKSk7XG4gICAgICAgICh7IGRheXMsIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBtaWxsaXNlY29uZHMsIG1pY3Jvc2Vjb25kcywgbmFub3NlY29uZHMgfSA9IEJhbGFuY2VEdXJhdGlvbihkYXlzLCBob3VycywgbWludXRlcywgc2Vjb25kcywgbWlsbGlzZWNvbmRzLCBtaWNyb3NlY29uZHMsIG5hbm9zZWNvbmRzLCBsYXJnZXN0VW5pdCkpO1xuICAgICAgICBjb25zdCBEdXJhdGlvbiA9IEdldEludHJpbnNpYygnJVRlbXBvcmFsLkR1cmF0aW9uJScpO1xuICAgICAgICByZXR1cm4gbmV3IER1cmF0aW9uKHllYXJzLCBtb250aHMsIHdlZWtzLCBkYXlzLCBob3VycywgbWludXRlcywgc2Vjb25kcywgbWlsbGlzZWNvbmRzLCBtaWNyb3NlY29uZHMsIG5hbm9zZWNvbmRzKTtcbiAgICB9XG4gICAgc2luY2Uob3RoZXJQYXJhbSwgb3B0aW9uc1BhcmFtID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbERhdGVUaW1lKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICBjb25zdCBvdGhlciA9IFRvVGVtcG9yYWxEYXRlVGltZShvdGhlclBhcmFtKTtcbiAgICAgICAgY29uc3QgY2FsZW5kYXIgPSBHZXRTbG90KHRoaXMsIENBTEVOREFSKTtcbiAgICAgICAgY29uc3Qgb3RoZXJDYWxlbmRhciA9IEdldFNsb3Qob3RoZXIsIENBTEVOREFSKTtcbiAgICAgICAgY29uc3QgY2FsZW5kYXJJZCA9IFRvU3RyaW5nKGNhbGVuZGFyKTtcbiAgICAgICAgY29uc3Qgb3RoZXJDYWxlbmRhcklkID0gVG9TdHJpbmcob3RoZXJDYWxlbmRhcik7XG4gICAgICAgIGlmIChjYWxlbmRhcklkICE9PSBvdGhlckNhbGVuZGFySWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBjYW5ub3QgY29tcHV0ZSBkaWZmZXJlbmNlIGJldHdlZW4gZGF0ZXMgb2YgJHtjYWxlbmRhcklkfSBhbmQgJHtvdGhlckNhbGVuZGFySWR9IGNhbGVuZGFyc2ApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSBHZXRPcHRpb25zT2JqZWN0KG9wdGlvbnNQYXJhbSk7XG4gICAgICAgIGNvbnN0IHNtYWxsZXN0VW5pdCA9IFRvU21hbGxlc3RUZW1wb3JhbFVuaXQob3B0aW9ucywgJ25hbm9zZWNvbmQnKTtcbiAgICAgICAgY29uc3QgZGVmYXVsdExhcmdlc3RVbml0ID0gTGFyZ2VyT2ZUd29UZW1wb3JhbFVuaXRzKCdkYXknLCBzbWFsbGVzdFVuaXQpO1xuICAgICAgICBjb25zdCBsYXJnZXN0VW5pdCA9IFRvTGFyZ2VzdFRlbXBvcmFsVW5pdChvcHRpb25zLCAnYXV0bycsIFtdLCBkZWZhdWx0TGFyZ2VzdFVuaXQpO1xuICAgICAgICBWYWxpZGF0ZVRlbXBvcmFsVW5pdFJhbmdlKGxhcmdlc3RVbml0LCBzbWFsbGVzdFVuaXQpO1xuICAgICAgICBjb25zdCByb3VuZGluZ01vZGUgPSBUb1RlbXBvcmFsUm91bmRpbmdNb2RlKG9wdGlvbnMsICd0cnVuYycpO1xuICAgICAgICBjb25zdCByb3VuZGluZ0luY3JlbWVudCA9IFRvVGVtcG9yYWxEYXRlVGltZVJvdW5kaW5nSW5jcmVtZW50KG9wdGlvbnMsIHNtYWxsZXN0VW5pdCk7XG4gICAgICAgIGxldCB7IHllYXJzLCBtb250aHMsIHdlZWtzLCBkYXlzLCBob3VycywgbWludXRlcywgc2Vjb25kcywgbWlsbGlzZWNvbmRzLCBtaWNyb3NlY29uZHMsIG5hbm9zZWNvbmRzIH0gPSBEaWZmZXJlbmNlSVNPRGF0ZVRpbWUoR2V0U2xvdCh0aGlzLCBJU09fWUVBUiksIEdldFNsb3QodGhpcywgSVNPX01PTlRIKSwgR2V0U2xvdCh0aGlzLCBJU09fREFZKSwgR2V0U2xvdCh0aGlzLCBJU09fSE9VUiksIEdldFNsb3QodGhpcywgSVNPX01JTlVURSksIEdldFNsb3QodGhpcywgSVNPX1NFQ09ORCksIEdldFNsb3QodGhpcywgSVNPX01JTExJU0VDT05EKSwgR2V0U2xvdCh0aGlzLCBJU09fTUlDUk9TRUNPTkQpLCBHZXRTbG90KHRoaXMsIElTT19OQU5PU0VDT05EKSwgR2V0U2xvdChvdGhlciwgSVNPX1lFQVIpLCBHZXRTbG90KG90aGVyLCBJU09fTU9OVEgpLCBHZXRTbG90KG90aGVyLCBJU09fREFZKSwgR2V0U2xvdChvdGhlciwgSVNPX0hPVVIpLCBHZXRTbG90KG90aGVyLCBJU09fTUlOVVRFKSwgR2V0U2xvdChvdGhlciwgSVNPX1NFQ09ORCksIEdldFNsb3Qob3RoZXIsIElTT19NSUxMSVNFQ09ORCksIEdldFNsb3Qob3RoZXIsIElTT19NSUNST1NFQ09ORCksIEdldFNsb3Qob3RoZXIsIElTT19OQU5PU0VDT05EKSwgY2FsZW5kYXIsIGxhcmdlc3RVbml0LCBvcHRpb25zKTtcbiAgICAgICAgY29uc3QgcmVsYXRpdmVUbyA9IFRlbXBvcmFsRGF0ZVRpbWVUb0RhdGUodGhpcyk7XG4gICAgICAgICh7IHllYXJzLCBtb250aHMsIHdlZWtzLCBkYXlzLCBob3VycywgbWludXRlcywgc2Vjb25kcywgbWlsbGlzZWNvbmRzLCBtaWNyb3NlY29uZHMsIG5hbm9zZWNvbmRzIH0gPVxuICAgICAgICAgICAgUm91bmREdXJhdGlvbih5ZWFycywgbW9udGhzLCB3ZWVrcywgZGF5cywgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc2Vjb25kcywgbWljcm9zZWNvbmRzLCBuYW5vc2Vjb25kcywgcm91bmRpbmdJbmNyZW1lbnQsIHNtYWxsZXN0VW5pdCwgTmVnYXRlVGVtcG9yYWxSb3VuZGluZ01vZGUocm91bmRpbmdNb2RlKSwgcmVsYXRpdmVUbykpO1xuICAgICAgICAoeyBkYXlzLCBob3VycywgbWludXRlcywgc2Vjb25kcywgbWlsbGlzZWNvbmRzLCBtaWNyb3NlY29uZHMsIG5hbm9zZWNvbmRzIH0gPSBCYWxhbmNlRHVyYXRpb24oZGF5cywgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc2Vjb25kcywgbWljcm9zZWNvbmRzLCBuYW5vc2Vjb25kcywgbGFyZ2VzdFVuaXQpKTtcbiAgICAgICAgY29uc3QgRHVyYXRpb24gPSBHZXRJbnRyaW5zaWMoJyVUZW1wb3JhbC5EdXJhdGlvbiUnKTtcbiAgICAgICAgcmV0dXJuIG5ldyBEdXJhdGlvbigteWVhcnMsIC1tb250aHMsIC13ZWVrcywgLWRheXMsIC1ob3VycywgLW1pbnV0ZXMsIC1zZWNvbmRzLCAtbWlsbGlzZWNvbmRzLCAtbWljcm9zZWNvbmRzLCAtbmFub3NlY29uZHMpO1xuICAgIH1cbiAgICByb3VuZChvcHRpb25zUGFyYW0pIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsRGF0ZVRpbWUodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIGlmIChvcHRpb25zUGFyYW0gPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ29wdGlvbnMgcGFyYW1ldGVyIGlzIHJlcXVpcmVkJyk7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB0eXBlb2Ygb3B0aW9uc1BhcmFtID09PSAnc3RyaW5nJ1xuICAgICAgICAgICAgPyBDcmVhdGVPbmVQcm9wT2JqZWN0KCdzbWFsbGVzdFVuaXQnLCBvcHRpb25zUGFyYW0pXG4gICAgICAgICAgICA6IEdldE9wdGlvbnNPYmplY3Qob3B0aW9uc1BhcmFtKTtcbiAgICAgICAgY29uc3Qgc21hbGxlc3RVbml0ID0gVG9TbWFsbGVzdFRlbXBvcmFsVW5pdChvcHRpb25zLCB1bmRlZmluZWQsIFsneWVhcicsICdtb250aCcsICd3ZWVrJ10pO1xuICAgICAgICBpZiAoc21hbGxlc3RVbml0ID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc21hbGxlc3RVbml0IGlzIHJlcXVpcmVkJyk7XG4gICAgICAgIGNvbnN0IHJvdW5kaW5nTW9kZSA9IFRvVGVtcG9yYWxSb3VuZGluZ01vZGUob3B0aW9ucywgJ2hhbGZFeHBhbmQnKTtcbiAgICAgICAgY29uc3QgbWF4aW11bUluY3JlbWVudHMgPSB7XG4gICAgICAgICAgICBkYXk6IDEsXG4gICAgICAgICAgICBob3VyOiAyNCxcbiAgICAgICAgICAgIG1pbnV0ZTogNjAsXG4gICAgICAgICAgICBzZWNvbmQ6IDYwLFxuICAgICAgICAgICAgbWlsbGlzZWNvbmQ6IDEwMDAsXG4gICAgICAgICAgICBtaWNyb3NlY29uZDogMTAwMCxcbiAgICAgICAgICAgIG5hbm9zZWNvbmQ6IDEwMDBcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgcm91bmRpbmdJbmNyZW1lbnQgPSBUb1RlbXBvcmFsUm91bmRpbmdJbmNyZW1lbnQob3B0aW9ucywgbWF4aW11bUluY3JlbWVudHNbc21hbGxlc3RVbml0XSwgZmFsc2UpO1xuICAgICAgICBsZXQgeWVhciA9IEdldFNsb3QodGhpcywgSVNPX1lFQVIpO1xuICAgICAgICBsZXQgbW9udGggPSBHZXRTbG90KHRoaXMsIElTT19NT05USCk7XG4gICAgICAgIGxldCBkYXkgPSBHZXRTbG90KHRoaXMsIElTT19EQVkpO1xuICAgICAgICBsZXQgaG91ciA9IEdldFNsb3QodGhpcywgSVNPX0hPVVIpO1xuICAgICAgICBsZXQgbWludXRlID0gR2V0U2xvdCh0aGlzLCBJU09fTUlOVVRFKTtcbiAgICAgICAgbGV0IHNlY29uZCA9IEdldFNsb3QodGhpcywgSVNPX1NFQ09ORCk7XG4gICAgICAgIGxldCBtaWxsaXNlY29uZCA9IEdldFNsb3QodGhpcywgSVNPX01JTExJU0VDT05EKTtcbiAgICAgICAgbGV0IG1pY3Jvc2Vjb25kID0gR2V0U2xvdCh0aGlzLCBJU09fTUlDUk9TRUNPTkQpO1xuICAgICAgICBsZXQgbmFub3NlY29uZCA9IEdldFNsb3QodGhpcywgSVNPX05BTk9TRUNPTkQpO1xuICAgICAgICAoeyB5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQsIG1pY3Jvc2Vjb25kLCBuYW5vc2Vjb25kIH0gPSBSb3VuZElTT0RhdGVUaW1lKHllYXIsIG1vbnRoLCBkYXksIGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZCwgbWljcm9zZWNvbmQsIG5hbm9zZWNvbmQsIHJvdW5kaW5nSW5jcmVtZW50LCBzbWFsbGVzdFVuaXQsIHJvdW5kaW5nTW9kZSkpO1xuICAgICAgICByZXR1cm4gQ3JlYXRlVGVtcG9yYWxEYXRlVGltZSh5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQsIG1pY3Jvc2Vjb25kLCBuYW5vc2Vjb25kLCBHZXRTbG90KHRoaXMsIENBTEVOREFSKSk7XG4gICAgfVxuICAgIGVxdWFscyhvdGhlclBhcmFtKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbERhdGVUaW1lKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICBjb25zdCBvdGhlciA9IFRvVGVtcG9yYWxEYXRlVGltZShvdGhlclBhcmFtKTtcbiAgICAgICAgZm9yIChjb25zdCBzbG90IG9mIFtcbiAgICAgICAgICAgIElTT19ZRUFSLFxuICAgICAgICAgICAgSVNPX01PTlRILFxuICAgICAgICAgICAgSVNPX0RBWSxcbiAgICAgICAgICAgIElTT19IT1VSLFxuICAgICAgICAgICAgSVNPX01JTlVURSxcbiAgICAgICAgICAgIElTT19TRUNPTkQsXG4gICAgICAgICAgICBJU09fTUlMTElTRUNPTkQsXG4gICAgICAgICAgICBJU09fTUlDUk9TRUNPTkQsXG4gICAgICAgICAgICBJU09fTkFOT1NFQ09ORFxuICAgICAgICBdKSB7XG4gICAgICAgICAgICBjb25zdCB2YWwxID0gR2V0U2xvdCh0aGlzLCBzbG90KTtcbiAgICAgICAgICAgIGNvbnN0IHZhbDIgPSBHZXRTbG90KG90aGVyLCBzbG90KTtcbiAgICAgICAgICAgIGlmICh2YWwxICE9PSB2YWwyKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQ2FsZW5kYXJFcXVhbHMoR2V0U2xvdCh0aGlzLCBDQUxFTkRBUiksIEdldFNsb3Qob3RoZXIsIENBTEVOREFSKSk7XG4gICAgfVxuICAgIHRvU3RyaW5nKG9wdGlvbnNQYXJhbSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxEYXRlVGltZSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IEdldE9wdGlvbnNPYmplY3Qob3B0aW9uc1BhcmFtKTtcbiAgICAgICAgY29uc3QgeyBwcmVjaXNpb24sIHVuaXQsIGluY3JlbWVudCB9ID0gVG9TZWNvbmRzU3RyaW5nUHJlY2lzaW9uKG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBzaG93Q2FsZW5kYXIgPSBUb1Nob3dDYWxlbmRhck9wdGlvbihvcHRpb25zKTtcbiAgICAgICAgY29uc3Qgcm91bmRpbmdNb2RlID0gVG9UZW1wb3JhbFJvdW5kaW5nTW9kZShvcHRpb25zLCAndHJ1bmMnKTtcbiAgICAgICAgcmV0dXJuIFRlbXBvcmFsRGF0ZVRpbWVUb1N0cmluZyh0aGlzLCBwcmVjaXNpb24sIHNob3dDYWxlbmRhciwgeyB1bml0LCBpbmNyZW1lbnQsIHJvdW5kaW5nTW9kZSB9KTtcbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxEYXRlVGltZSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgcmV0dXJuIFRlbXBvcmFsRGF0ZVRpbWVUb1N0cmluZyh0aGlzLCAnYXV0bycpO1xuICAgIH1cbiAgICB0b0xvY2FsZVN0cmluZyhsb2NhbGVzID0gdW5kZWZpbmVkLCBvcHRpb25zID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbERhdGVUaW1lKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICByZXR1cm4gbmV3IERhdGVUaW1lRm9ybWF0KGxvY2FsZXMsIG9wdGlvbnMpLmZvcm1hdCh0aGlzKTtcbiAgICB9XG4gICAgdmFsdWVPZigpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigndXNlIGNvbXBhcmUoKSBvciBlcXVhbHMoKSB0byBjb21wYXJlIFRlbXBvcmFsLlBsYWluRGF0ZVRpbWUnKTtcbiAgICB9XG4gICAgdG9ab25lZERhdGVUaW1lKHRlbXBvcmFsVGltZVpvbmVMaWtlLCBvcHRpb25zUGFyYW0gPSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsRGF0ZVRpbWUodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIGNvbnN0IHRpbWVab25lID0gVG9UZW1wb3JhbFRpbWVab25lKHRlbXBvcmFsVGltZVpvbmVMaWtlKTtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IEdldE9wdGlvbnNPYmplY3Qob3B0aW9uc1BhcmFtKTtcbiAgICAgICAgY29uc3QgZGlzYW1iaWd1YXRpb24gPSBUb1RlbXBvcmFsRGlzYW1iaWd1YXRpb24ob3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IGluc3RhbnQgPSBCdWlsdGluVGltZVpvbmVHZXRJbnN0YW50Rm9yKHRpbWVab25lLCB0aGlzLCBkaXNhbWJpZ3VhdGlvbik7XG4gICAgICAgIHJldHVybiBDcmVhdGVUZW1wb3JhbFpvbmVkRGF0ZVRpbWUoR2V0U2xvdChpbnN0YW50LCBFUE9DSE5BTk9TRUNPTkRTKSwgdGltZVpvbmUsIEdldFNsb3QodGhpcywgQ0FMRU5EQVIpKTtcbiAgICB9XG4gICAgdG9QbGFpbkRhdGUoKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbERhdGVUaW1lKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICByZXR1cm4gVGVtcG9yYWxEYXRlVGltZVRvRGF0ZSh0aGlzKTtcbiAgICB9XG4gICAgdG9QbGFpblllYXJNb250aCgpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsRGF0ZVRpbWUodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIGNvbnN0IGNhbGVuZGFyID0gR2V0U2xvdCh0aGlzLCBDQUxFTkRBUik7XG4gICAgICAgIGNvbnN0IGZpZWxkTmFtZXMgPSBDYWxlbmRhckZpZWxkcyhjYWxlbmRhciwgWydtb250aENvZGUnLCAneWVhciddKTtcbiAgICAgICAgY29uc3QgZmllbGRzID0gVG9UZW1wb3JhbFllYXJNb250aEZpZWxkcyh0aGlzLCBmaWVsZE5hbWVzKTtcbiAgICAgICAgcmV0dXJuIFllYXJNb250aEZyb21GaWVsZHMoY2FsZW5kYXIsIGZpZWxkcyk7XG4gICAgfVxuICAgIHRvUGxhaW5Nb250aERheSgpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsRGF0ZVRpbWUodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIGNvbnN0IGNhbGVuZGFyID0gR2V0U2xvdCh0aGlzLCBDQUxFTkRBUik7XG4gICAgICAgIGNvbnN0IGZpZWxkTmFtZXMgPSBDYWxlbmRhckZpZWxkcyhjYWxlbmRhciwgWydkYXknLCAnbW9udGhDb2RlJ10pO1xuICAgICAgICBjb25zdCBmaWVsZHMgPSBUb1RlbXBvcmFsTW9udGhEYXlGaWVsZHModGhpcywgZmllbGROYW1lcyk7XG4gICAgICAgIHJldHVybiBNb250aERheUZyb21GaWVsZHMoY2FsZW5kYXIsIGZpZWxkcyk7XG4gICAgfVxuICAgIHRvUGxhaW5UaW1lKCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxEYXRlVGltZSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgcmV0dXJuIFRlbXBvcmFsRGF0ZVRpbWVUb1RpbWUodGhpcyk7XG4gICAgfVxuICAgIGdldElTT0ZpZWxkcygpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsRGF0ZVRpbWUodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjYWxlbmRhcjogR2V0U2xvdCh0aGlzLCBDQUxFTkRBUiksXG4gICAgICAgICAgICBpc29EYXk6IEdldFNsb3QodGhpcywgSVNPX0RBWSksXG4gICAgICAgICAgICBpc29Ib3VyOiBHZXRTbG90KHRoaXMsIElTT19IT1VSKSxcbiAgICAgICAgICAgIGlzb01pY3Jvc2Vjb25kOiBHZXRTbG90KHRoaXMsIElTT19NSUNST1NFQ09ORCksXG4gICAgICAgICAgICBpc29NaWxsaXNlY29uZDogR2V0U2xvdCh0aGlzLCBJU09fTUlMTElTRUNPTkQpLFxuICAgICAgICAgICAgaXNvTWludXRlOiBHZXRTbG90KHRoaXMsIElTT19NSU5VVEUpLFxuICAgICAgICAgICAgaXNvTW9udGg6IEdldFNsb3QodGhpcywgSVNPX01PTlRIKSxcbiAgICAgICAgICAgIGlzb05hbm9zZWNvbmQ6IEdldFNsb3QodGhpcywgSVNPX05BTk9TRUNPTkQpLFxuICAgICAgICAgICAgaXNvU2Vjb25kOiBHZXRTbG90KHRoaXMsIElTT19TRUNPTkQpLFxuICAgICAgICAgICAgaXNvWWVhcjogR2V0U2xvdCh0aGlzLCBJU09fWUVBUilcbiAgICAgICAgfTtcbiAgICB9XG4gICAgc3RhdGljIGZyb20oaXRlbSwgb3B0aW9uc1BhcmFtID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSBHZXRPcHRpb25zT2JqZWN0KG9wdGlvbnNQYXJhbSk7XG4gICAgICAgIGlmIChJc1RlbXBvcmFsRGF0ZVRpbWUoaXRlbSkpIHtcbiAgICAgICAgICAgIFRvVGVtcG9yYWxPdmVyZmxvdyhvcHRpb25zKTsgLy8gdmFsaWRhdGUgYW5kIGlnbm9yZVxuICAgICAgICAgICAgcmV0dXJuIENyZWF0ZVRlbXBvcmFsRGF0ZVRpbWUoR2V0U2xvdChpdGVtLCBJU09fWUVBUiksIEdldFNsb3QoaXRlbSwgSVNPX01PTlRIKSwgR2V0U2xvdChpdGVtLCBJU09fREFZKSwgR2V0U2xvdChpdGVtLCBJU09fSE9VUiksIEdldFNsb3QoaXRlbSwgSVNPX01JTlVURSksIEdldFNsb3QoaXRlbSwgSVNPX1NFQ09ORCksIEdldFNsb3QoaXRlbSwgSVNPX01JTExJU0VDT05EKSwgR2V0U2xvdChpdGVtLCBJU09fTUlDUk9TRUNPTkQpLCBHZXRTbG90KGl0ZW0sIElTT19OQU5PU0VDT05EKSwgR2V0U2xvdChpdGVtLCBDQUxFTkRBUikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBUb1RlbXBvcmFsRGF0ZVRpbWUoaXRlbSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIHN0YXRpYyBjb21wYXJlKG9uZVBhcmFtLCB0d29QYXJhbSkge1xuICAgICAgICBjb25zdCBvbmUgPSBUb1RlbXBvcmFsRGF0ZVRpbWUob25lUGFyYW0pO1xuICAgICAgICBjb25zdCB0d28gPSBUb1RlbXBvcmFsRGF0ZVRpbWUodHdvUGFyYW0pO1xuICAgICAgICBmb3IgKGNvbnN0IHNsb3Qgb2YgW1xuICAgICAgICAgICAgSVNPX1lFQVIsXG4gICAgICAgICAgICBJU09fTU9OVEgsXG4gICAgICAgICAgICBJU09fREFZLFxuICAgICAgICAgICAgSVNPX0hPVVIsXG4gICAgICAgICAgICBJU09fTUlOVVRFLFxuICAgICAgICAgICAgSVNPX1NFQ09ORCxcbiAgICAgICAgICAgIElTT19NSUxMSVNFQ09ORCxcbiAgICAgICAgICAgIElTT19NSUNST1NFQ09ORCxcbiAgICAgICAgICAgIElTT19OQU5PU0VDT05EXG4gICAgICAgIF0pIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbDEgPSBHZXRTbG90KG9uZSwgc2xvdCk7XG4gICAgICAgICAgICBjb25zdCB2YWwyID0gR2V0U2xvdCh0d28sIHNsb3QpO1xuICAgICAgICAgICAgaWYgKHZhbDEgIT09IHZhbDIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIENvbXBhcmlzb25SZXN1bHQodmFsMSAtIHZhbDIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbn1cbk1ha2VJbnRyaW5zaWNDbGFzcyhQbGFpbkRhdGVUaW1lLCAnVGVtcG9yYWwuUGxhaW5EYXRlVGltZScpO1xuXG5jbGFzcyBEdXJhdGlvbiB7XG4gICAgY29uc3RydWN0b3IoeWVhcnNQYXJhbSA9IDAsIG1vbnRoc1BhcmFtID0gMCwgd2Vla3NQYXJhbSA9IDAsIGRheXNQYXJhbSA9IDAsIGhvdXJzUGFyYW0gPSAwLCBtaW51dGVzUGFyYW0gPSAwLCBzZWNvbmRzUGFyYW0gPSAwLCBtaWxsaXNlY29uZHNQYXJhbSA9IDAsIG1pY3Jvc2Vjb25kc1BhcmFtID0gMCwgbmFub3NlY29uZHNQYXJhbSA9IDApIHtcbiAgICAgICAgY29uc3QgeWVhcnMgPSBUb0ludGVnZXJXaXRob3V0Um91bmRpbmcoeWVhcnNQYXJhbSk7XG4gICAgICAgIGNvbnN0IG1vbnRocyA9IFRvSW50ZWdlcldpdGhvdXRSb3VuZGluZyhtb250aHNQYXJhbSk7XG4gICAgICAgIGNvbnN0IHdlZWtzID0gVG9JbnRlZ2VyV2l0aG91dFJvdW5kaW5nKHdlZWtzUGFyYW0pO1xuICAgICAgICBjb25zdCBkYXlzID0gVG9JbnRlZ2VyV2l0aG91dFJvdW5kaW5nKGRheXNQYXJhbSk7XG4gICAgICAgIGNvbnN0IGhvdXJzID0gVG9JbnRlZ2VyV2l0aG91dFJvdW5kaW5nKGhvdXJzUGFyYW0pO1xuICAgICAgICBjb25zdCBtaW51dGVzID0gVG9JbnRlZ2VyV2l0aG91dFJvdW5kaW5nKG1pbnV0ZXNQYXJhbSk7XG4gICAgICAgIGNvbnN0IHNlY29uZHMgPSBUb0ludGVnZXJXaXRob3V0Um91bmRpbmcoc2Vjb25kc1BhcmFtKTtcbiAgICAgICAgY29uc3QgbWlsbGlzZWNvbmRzID0gVG9JbnRlZ2VyV2l0aG91dFJvdW5kaW5nKG1pbGxpc2Vjb25kc1BhcmFtKTtcbiAgICAgICAgY29uc3QgbWljcm9zZWNvbmRzID0gVG9JbnRlZ2VyV2l0aG91dFJvdW5kaW5nKG1pY3Jvc2Vjb25kc1BhcmFtKTtcbiAgICAgICAgY29uc3QgbmFub3NlY29uZHMgPSBUb0ludGVnZXJXaXRob3V0Um91bmRpbmcobmFub3NlY29uZHNQYXJhbSk7XG4gICAgICAgIGNvbnN0IHNpZ24gPSBEdXJhdGlvblNpZ24oeWVhcnMsIG1vbnRocywgd2Vla3MsIGRheXMsIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBtaWxsaXNlY29uZHMsIG1pY3Jvc2Vjb25kcywgbmFub3NlY29uZHMpO1xuICAgICAgICBmb3IgKGNvbnN0IHByb3Agb2YgW3llYXJzLCBtb250aHMsIHdlZWtzLCBkYXlzLCBob3VycywgbWludXRlcywgc2Vjb25kcywgbWlsbGlzZWNvbmRzLCBtaWNyb3NlY29uZHMsIG5hbm9zZWNvbmRzXSkge1xuICAgICAgICAgICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUocHJvcCkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2luZmluaXRlIHZhbHVlcyBub3QgYWxsb3dlZCBhcyBkdXJhdGlvbiBmaWVsZHMnKTtcbiAgICAgICAgICAgIGNvbnN0IHByb3BTaWduID0gTWF0aC5zaWduKHByb3ApO1xuICAgICAgICAgICAgaWYgKHByb3BTaWduICE9PSAwICYmIHByb3BTaWduICE9PSBzaWduKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdtaXhlZC1zaWduIHZhbHVlcyBub3QgYWxsb3dlZCBhcyBkdXJhdGlvbiBmaWVsZHMnKTtcbiAgICAgICAgfVxuICAgICAgICBDcmVhdGVTbG90cyh0aGlzKTtcbiAgICAgICAgU2V0U2xvdCh0aGlzLCBZRUFSUywgeWVhcnMpO1xuICAgICAgICBTZXRTbG90KHRoaXMsIE1PTlRIUywgbW9udGhzKTtcbiAgICAgICAgU2V0U2xvdCh0aGlzLCBXRUVLUywgd2Vla3MpO1xuICAgICAgICBTZXRTbG90KHRoaXMsIERBWVMsIGRheXMpO1xuICAgICAgICBTZXRTbG90KHRoaXMsIEhPVVJTLCBob3Vycyk7XG4gICAgICAgIFNldFNsb3QodGhpcywgTUlOVVRFUywgbWludXRlcyk7XG4gICAgICAgIFNldFNsb3QodGhpcywgU0VDT05EUywgc2Vjb25kcyk7XG4gICAgICAgIFNldFNsb3QodGhpcywgTUlMTElTRUNPTkRTLCBtaWxsaXNlY29uZHMpO1xuICAgICAgICBTZXRTbG90KHRoaXMsIE1JQ1JPU0VDT05EUywgbWljcm9zZWNvbmRzKTtcbiAgICAgICAgU2V0U2xvdCh0aGlzLCBOQU5PU0VDT05EUywgbmFub3NlY29uZHMpO1xuICAgICAgICB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ19yZXByXycsIHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogYCR7dGhpc1tTeW1ib2wudG9TdHJpbmdUYWddfSA8JHtUZW1wb3JhbER1cmF0aW9uVG9TdHJpbmcodGhpcyl9PmAsXG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCB5ZWFycygpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsRHVyYXRpb24odGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIHJldHVybiBHZXRTbG90KHRoaXMsIFlFQVJTKTtcbiAgICB9XG4gICAgZ2V0IG1vbnRocygpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsRHVyYXRpb24odGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIHJldHVybiBHZXRTbG90KHRoaXMsIE1PTlRIUyk7XG4gICAgfVxuICAgIGdldCB3ZWVrcygpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsRHVyYXRpb24odGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIHJldHVybiBHZXRTbG90KHRoaXMsIFdFRUtTKTtcbiAgICB9XG4gICAgZ2V0IGRheXMoKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbER1cmF0aW9uKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICByZXR1cm4gR2V0U2xvdCh0aGlzLCBEQVlTKTtcbiAgICB9XG4gICAgZ2V0IGhvdXJzKCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxEdXJhdGlvbih0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgcmV0dXJuIEdldFNsb3QodGhpcywgSE9VUlMpO1xuICAgIH1cbiAgICBnZXQgbWludXRlcygpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsRHVyYXRpb24odGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIHJldHVybiBHZXRTbG90KHRoaXMsIE1JTlVURVMpO1xuICAgIH1cbiAgICBnZXQgc2Vjb25kcygpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsRHVyYXRpb24odGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIHJldHVybiBHZXRTbG90KHRoaXMsIFNFQ09ORFMpO1xuICAgIH1cbiAgICBnZXQgbWlsbGlzZWNvbmRzKCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxEdXJhdGlvbih0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgcmV0dXJuIEdldFNsb3QodGhpcywgTUlMTElTRUNPTkRTKTtcbiAgICB9XG4gICAgZ2V0IG1pY3Jvc2Vjb25kcygpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsRHVyYXRpb24odGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIHJldHVybiBHZXRTbG90KHRoaXMsIE1JQ1JPU0VDT05EUyk7XG4gICAgfVxuICAgIGdldCBuYW5vc2Vjb25kcygpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsRHVyYXRpb24odGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIHJldHVybiBHZXRTbG90KHRoaXMsIE5BTk9TRUNPTkRTKTtcbiAgICB9XG4gICAgZ2V0IHNpZ24oKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbER1cmF0aW9uKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICByZXR1cm4gRHVyYXRpb25TaWduKEdldFNsb3QodGhpcywgWUVBUlMpLCBHZXRTbG90KHRoaXMsIE1PTlRIUyksIEdldFNsb3QodGhpcywgV0VFS1MpLCBHZXRTbG90KHRoaXMsIERBWVMpLCBHZXRTbG90KHRoaXMsIEhPVVJTKSwgR2V0U2xvdCh0aGlzLCBNSU5VVEVTKSwgR2V0U2xvdCh0aGlzLCBTRUNPTkRTKSwgR2V0U2xvdCh0aGlzLCBNSUxMSVNFQ09ORFMpLCBHZXRTbG90KHRoaXMsIE1JQ1JPU0VDT05EUyksIEdldFNsb3QodGhpcywgTkFOT1NFQ09ORFMpKTtcbiAgICB9XG4gICAgZ2V0IGJsYW5rKCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxEdXJhdGlvbih0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgcmV0dXJuIChEdXJhdGlvblNpZ24oR2V0U2xvdCh0aGlzLCBZRUFSUyksIEdldFNsb3QodGhpcywgTU9OVEhTKSwgR2V0U2xvdCh0aGlzLCBXRUVLUyksIEdldFNsb3QodGhpcywgREFZUyksIEdldFNsb3QodGhpcywgSE9VUlMpLCBHZXRTbG90KHRoaXMsIE1JTlVURVMpLCBHZXRTbG90KHRoaXMsIFNFQ09ORFMpLCBHZXRTbG90KHRoaXMsIE1JTExJU0VDT05EUyksIEdldFNsb3QodGhpcywgTUlDUk9TRUNPTkRTKSwgR2V0U2xvdCh0aGlzLCBOQU5PU0VDT05EUykpID09PSAwKTtcbiAgICB9XG4gICAgd2l0aChkdXJhdGlvbkxpa2UpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsRHVyYXRpb24odGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIGNvbnN0IHByb3BzID0gVG9QYXJ0aWFsUmVjb3JkKGR1cmF0aW9uTGlrZSwgW1xuICAgICAgICAgICAgJ2RheXMnLFxuICAgICAgICAgICAgJ2hvdXJzJyxcbiAgICAgICAgICAgICdtaWNyb3NlY29uZHMnLFxuICAgICAgICAgICAgJ21pbGxpc2Vjb25kcycsXG4gICAgICAgICAgICAnbWludXRlcycsXG4gICAgICAgICAgICAnbW9udGhzJyxcbiAgICAgICAgICAgICduYW5vc2Vjb25kcycsXG4gICAgICAgICAgICAnc2Vjb25kcycsXG4gICAgICAgICAgICAnd2Vla3MnLFxuICAgICAgICAgICAgJ3llYXJzJ1xuICAgICAgICBdKTtcbiAgICAgICAgaWYgKCFwcm9wcykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBkdXJhdGlvbi1saWtlJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyB5ZWFycyA9IEdldFNsb3QodGhpcywgWUVBUlMpLCBtb250aHMgPSBHZXRTbG90KHRoaXMsIE1PTlRIUyksIHdlZWtzID0gR2V0U2xvdCh0aGlzLCBXRUVLUyksIGRheXMgPSBHZXRTbG90KHRoaXMsIERBWVMpLCBob3VycyA9IEdldFNsb3QodGhpcywgSE9VUlMpLCBtaW51dGVzID0gR2V0U2xvdCh0aGlzLCBNSU5VVEVTKSwgc2Vjb25kcyA9IEdldFNsb3QodGhpcywgU0VDT05EUyksIG1pbGxpc2Vjb25kcyA9IEdldFNsb3QodGhpcywgTUlMTElTRUNPTkRTKSwgbWljcm9zZWNvbmRzID0gR2V0U2xvdCh0aGlzLCBNSUNST1NFQ09ORFMpLCBuYW5vc2Vjb25kcyA9IEdldFNsb3QodGhpcywgTkFOT1NFQ09ORFMpIH0gPSBwcm9wcztcbiAgICAgICAgcmV0dXJuIG5ldyBEdXJhdGlvbih5ZWFycywgbW9udGhzLCB3ZWVrcywgZGF5cywgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc2Vjb25kcywgbWljcm9zZWNvbmRzLCBuYW5vc2Vjb25kcyk7XG4gICAgfVxuICAgIG5lZ2F0ZWQoKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbER1cmF0aW9uKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICByZXR1cm4gQ3JlYXRlTmVnYXRlZFRlbXBvcmFsRHVyYXRpb24odGhpcyk7XG4gICAgfVxuICAgIGFicygpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsRHVyYXRpb24odGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIHJldHVybiBuZXcgRHVyYXRpb24oTWF0aC5hYnMoR2V0U2xvdCh0aGlzLCBZRUFSUykpLCBNYXRoLmFicyhHZXRTbG90KHRoaXMsIE1PTlRIUykpLCBNYXRoLmFicyhHZXRTbG90KHRoaXMsIFdFRUtTKSksIE1hdGguYWJzKEdldFNsb3QodGhpcywgREFZUykpLCBNYXRoLmFicyhHZXRTbG90KHRoaXMsIEhPVVJTKSksIE1hdGguYWJzKEdldFNsb3QodGhpcywgTUlOVVRFUykpLCBNYXRoLmFicyhHZXRTbG90KHRoaXMsIFNFQ09ORFMpKSwgTWF0aC5hYnMoR2V0U2xvdCh0aGlzLCBNSUxMSVNFQ09ORFMpKSwgTWF0aC5hYnMoR2V0U2xvdCh0aGlzLCBNSUNST1NFQ09ORFMpKSwgTWF0aC5hYnMoR2V0U2xvdCh0aGlzLCBOQU5PU0VDT05EUykpKTtcbiAgICB9XG4gICAgYWRkKG90aGVyLCBvcHRpb25zUGFyYW0gPSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsRHVyYXRpb24odGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIGxldCB7IHllYXJzLCBtb250aHMsIHdlZWtzLCBkYXlzLCBob3VycywgbWludXRlcywgc2Vjb25kcywgbWlsbGlzZWNvbmRzLCBtaWNyb3NlY29uZHMsIG5hbm9zZWNvbmRzIH0gPSBUb0xpbWl0ZWRUZW1wb3JhbER1cmF0aW9uKG90aGVyKTtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IEdldE9wdGlvbnNPYmplY3Qob3B0aW9uc1BhcmFtKTtcbiAgICAgICAgY29uc3QgcmVsYXRpdmVUbyA9IFRvUmVsYXRpdmVUZW1wb3JhbE9iamVjdChvcHRpb25zKTtcbiAgICAgICAgKHsgeWVhcnMsIG1vbnRocywgd2Vla3MsIGRheXMsIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBtaWxsaXNlY29uZHMsIG1pY3Jvc2Vjb25kcywgbmFub3NlY29uZHMgfSA9IEFkZER1cmF0aW9uKEdldFNsb3QodGhpcywgWUVBUlMpLCBHZXRTbG90KHRoaXMsIE1PTlRIUyksIEdldFNsb3QodGhpcywgV0VFS1MpLCBHZXRTbG90KHRoaXMsIERBWVMpLCBHZXRTbG90KHRoaXMsIEhPVVJTKSwgR2V0U2xvdCh0aGlzLCBNSU5VVEVTKSwgR2V0U2xvdCh0aGlzLCBTRUNPTkRTKSwgR2V0U2xvdCh0aGlzLCBNSUxMSVNFQ09ORFMpLCBHZXRTbG90KHRoaXMsIE1JQ1JPU0VDT05EUyksIEdldFNsb3QodGhpcywgTkFOT1NFQ09ORFMpLCB5ZWFycywgbW9udGhzLCB3ZWVrcywgZGF5cywgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc2Vjb25kcywgbWljcm9zZWNvbmRzLCBuYW5vc2Vjb25kcywgcmVsYXRpdmVUbykpO1xuICAgICAgICByZXR1cm4gbmV3IER1cmF0aW9uKHllYXJzLCBtb250aHMsIHdlZWtzLCBkYXlzLCBob3VycywgbWludXRlcywgc2Vjb25kcywgbWlsbGlzZWNvbmRzLCBtaWNyb3NlY29uZHMsIG5hbm9zZWNvbmRzKTtcbiAgICB9XG4gICAgc3VidHJhY3Qob3RoZXIsIG9wdGlvbnNQYXJhbSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxEdXJhdGlvbih0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgbGV0IHsgeWVhcnMsIG1vbnRocywgd2Vla3MsIGRheXMsIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBtaWxsaXNlY29uZHMsIG1pY3Jvc2Vjb25kcywgbmFub3NlY29uZHMgfSA9IFRvTGltaXRlZFRlbXBvcmFsRHVyYXRpb24ob3RoZXIpO1xuICAgICAgICBjb25zdCBvcHRpb25zID0gR2V0T3B0aW9uc09iamVjdChvcHRpb25zUGFyYW0pO1xuICAgICAgICBjb25zdCByZWxhdGl2ZVRvID0gVG9SZWxhdGl2ZVRlbXBvcmFsT2JqZWN0KG9wdGlvbnMpO1xuICAgICAgICAoeyB5ZWFycywgbW9udGhzLCB3ZWVrcywgZGF5cywgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc2Vjb25kcywgbWljcm9zZWNvbmRzLCBuYW5vc2Vjb25kcyB9ID0gQWRkRHVyYXRpb24oR2V0U2xvdCh0aGlzLCBZRUFSUyksIEdldFNsb3QodGhpcywgTU9OVEhTKSwgR2V0U2xvdCh0aGlzLCBXRUVLUyksIEdldFNsb3QodGhpcywgREFZUyksIEdldFNsb3QodGhpcywgSE9VUlMpLCBHZXRTbG90KHRoaXMsIE1JTlVURVMpLCBHZXRTbG90KHRoaXMsIFNFQ09ORFMpLCBHZXRTbG90KHRoaXMsIE1JTExJU0VDT05EUyksIEdldFNsb3QodGhpcywgTUlDUk9TRUNPTkRTKSwgR2V0U2xvdCh0aGlzLCBOQU5PU0VDT05EUyksIC15ZWFycywgLW1vbnRocywgLXdlZWtzLCAtZGF5cywgLWhvdXJzLCAtbWludXRlcywgLXNlY29uZHMsIC1taWxsaXNlY29uZHMsIC1taWNyb3NlY29uZHMsIC1uYW5vc2Vjb25kcywgcmVsYXRpdmVUbykpO1xuICAgICAgICByZXR1cm4gbmV3IER1cmF0aW9uKHllYXJzLCBtb250aHMsIHdlZWtzLCBkYXlzLCBob3VycywgbWludXRlcywgc2Vjb25kcywgbWlsbGlzZWNvbmRzLCBtaWNyb3NlY29uZHMsIG5hbm9zZWNvbmRzKTtcbiAgICB9XG4gICAgcm91bmQob3B0aW9uc1BhcmFtKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbER1cmF0aW9uKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICBpZiAob3B0aW9uc1BhcmFtID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdvcHRpb25zIHBhcmFtZXRlciBpcyByZXF1aXJlZCcpO1xuICAgICAgICBsZXQgeWVhcnMgPSBHZXRTbG90KHRoaXMsIFlFQVJTKTtcbiAgICAgICAgbGV0IG1vbnRocyA9IEdldFNsb3QodGhpcywgTU9OVEhTKTtcbiAgICAgICAgbGV0IHdlZWtzID0gR2V0U2xvdCh0aGlzLCBXRUVLUyk7XG4gICAgICAgIGxldCBkYXlzID0gR2V0U2xvdCh0aGlzLCBEQVlTKTtcbiAgICAgICAgbGV0IGhvdXJzID0gR2V0U2xvdCh0aGlzLCBIT1VSUyk7XG4gICAgICAgIGxldCBtaW51dGVzID0gR2V0U2xvdCh0aGlzLCBNSU5VVEVTKTtcbiAgICAgICAgbGV0IHNlY29uZHMgPSBHZXRTbG90KHRoaXMsIFNFQ09ORFMpO1xuICAgICAgICBsZXQgbWlsbGlzZWNvbmRzID0gR2V0U2xvdCh0aGlzLCBNSUxMSVNFQ09ORFMpO1xuICAgICAgICBsZXQgbWljcm9zZWNvbmRzID0gR2V0U2xvdCh0aGlzLCBNSUNST1NFQ09ORFMpO1xuICAgICAgICBsZXQgbmFub3NlY29uZHMgPSBHZXRTbG90KHRoaXMsIE5BTk9TRUNPTkRTKTtcbiAgICAgICAgbGV0IGRlZmF1bHRMYXJnZXN0VW5pdCA9IERlZmF1bHRUZW1wb3JhbExhcmdlc3RVbml0KHllYXJzLCBtb250aHMsIHdlZWtzLCBkYXlzLCBob3VycywgbWludXRlcywgc2Vjb25kcywgbWlsbGlzZWNvbmRzLCBtaWNyb3NlY29uZHMsIG5hbm9zZWNvbmRzKTtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHR5cGVvZiBvcHRpb25zUGFyYW0gPT09ICdzdHJpbmcnXG4gICAgICAgICAgICA/IENyZWF0ZU9uZVByb3BPYmplY3QoJ3NtYWxsZXN0VW5pdCcsIG9wdGlvbnNQYXJhbSlcbiAgICAgICAgICAgIDogR2V0T3B0aW9uc09iamVjdChvcHRpb25zUGFyYW0pO1xuICAgICAgICBsZXQgc21hbGxlc3RVbml0ID0gVG9TbWFsbGVzdFRlbXBvcmFsVW5pdChvcHRpb25zLCB1bmRlZmluZWQpO1xuICAgICAgICBsZXQgc21hbGxlc3RVbml0UHJlc2VudCA9IHRydWU7XG4gICAgICAgIGlmICghc21hbGxlc3RVbml0KSB7XG4gICAgICAgICAgICBzbWFsbGVzdFVuaXRQcmVzZW50ID0gZmFsc2U7XG4gICAgICAgICAgICBzbWFsbGVzdFVuaXQgPSAnbmFub3NlY29uZCc7XG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdExhcmdlc3RVbml0ID0gTGFyZ2VyT2ZUd29UZW1wb3JhbFVuaXRzKGRlZmF1bHRMYXJnZXN0VW5pdCwgc21hbGxlc3RVbml0KTtcbiAgICAgICAgbGV0IGxhcmdlc3RVbml0ID0gVG9MYXJnZXN0VGVtcG9yYWxVbml0KG9wdGlvbnMsIHVuZGVmaW5lZCk7XG4gICAgICAgIGxldCBsYXJnZXN0VW5pdFByZXNlbnQgPSB0cnVlO1xuICAgICAgICBpZiAoIWxhcmdlc3RVbml0KSB7XG4gICAgICAgICAgICBsYXJnZXN0VW5pdFByZXNlbnQgPSBmYWxzZTtcbiAgICAgICAgICAgIGxhcmdlc3RVbml0ID0gZGVmYXVsdExhcmdlc3RVbml0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChsYXJnZXN0VW5pdCA9PT0gJ2F1dG8nKVxuICAgICAgICAgICAgbGFyZ2VzdFVuaXQgPSBkZWZhdWx0TGFyZ2VzdFVuaXQ7XG4gICAgICAgIGlmICghc21hbGxlc3RVbml0UHJlc2VudCAmJiAhbGFyZ2VzdFVuaXRQcmVzZW50KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignYXQgbGVhc3Qgb25lIG9mIHNtYWxsZXN0VW5pdCBvciBsYXJnZXN0VW5pdCBpcyByZXF1aXJlZCcpO1xuICAgICAgICB9XG4gICAgICAgIFZhbGlkYXRlVGVtcG9yYWxVbml0UmFuZ2UobGFyZ2VzdFVuaXQsIHNtYWxsZXN0VW5pdCk7XG4gICAgICAgIGNvbnN0IHJvdW5kaW5nTW9kZSA9IFRvVGVtcG9yYWxSb3VuZGluZ01vZGUob3B0aW9ucywgJ2hhbGZFeHBhbmQnKTtcbiAgICAgICAgY29uc3Qgcm91bmRpbmdJbmNyZW1lbnQgPSBUb1RlbXBvcmFsRGF0ZVRpbWVSb3VuZGluZ0luY3JlbWVudChvcHRpb25zLCBzbWFsbGVzdFVuaXQpO1xuICAgICAgICBsZXQgcmVsYXRpdmVUbyA9IFRvUmVsYXRpdmVUZW1wb3JhbE9iamVjdChvcHRpb25zKTtcbiAgICAgICAgKHsgeWVhcnMsIG1vbnRocywgd2Vla3MsIGRheXMgfSA9IFVuYmFsYW5jZUR1cmF0aW9uUmVsYXRpdmUoeWVhcnMsIG1vbnRocywgd2Vla3MsIGRheXMsIGxhcmdlc3RVbml0LCByZWxhdGl2ZVRvKSk7XG4gICAgICAgICh7IHllYXJzLCBtb250aHMsIHdlZWtzLCBkYXlzLCBob3VycywgbWludXRlcywgc2Vjb25kcywgbWlsbGlzZWNvbmRzLCBtaWNyb3NlY29uZHMsIG5hbm9zZWNvbmRzIH0gPVxuICAgICAgICAgICAgUm91bmREdXJhdGlvbih5ZWFycywgbW9udGhzLCB3ZWVrcywgZGF5cywgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc2Vjb25kcywgbWljcm9zZWNvbmRzLCBuYW5vc2Vjb25kcywgcm91bmRpbmdJbmNyZW1lbnQsIHNtYWxsZXN0VW5pdCwgcm91bmRpbmdNb2RlLCByZWxhdGl2ZVRvKSk7XG4gICAgICAgICh7IHllYXJzLCBtb250aHMsIHdlZWtzLCBkYXlzLCBob3VycywgbWludXRlcywgc2Vjb25kcywgbWlsbGlzZWNvbmRzLCBtaWNyb3NlY29uZHMsIG5hbm9zZWNvbmRzIH0gPVxuICAgICAgICAgICAgQWRqdXN0Um91bmRlZER1cmF0aW9uRGF5cyh5ZWFycywgbW9udGhzLCB3ZWVrcywgZGF5cywgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc2Vjb25kcywgbWljcm9zZWNvbmRzLCBuYW5vc2Vjb25kcywgcm91bmRpbmdJbmNyZW1lbnQsIHNtYWxsZXN0VW5pdCwgcm91bmRpbmdNb2RlLCByZWxhdGl2ZVRvKSk7XG4gICAgICAgICh7IHllYXJzLCBtb250aHMsIHdlZWtzLCBkYXlzIH0gPSBCYWxhbmNlRHVyYXRpb25SZWxhdGl2ZSh5ZWFycywgbW9udGhzLCB3ZWVrcywgZGF5cywgbGFyZ2VzdFVuaXQsIHJlbGF0aXZlVG8pKTtcbiAgICAgICAgaWYgKElzVGVtcG9yYWxab25lZERhdGVUaW1lKHJlbGF0aXZlVG8pKSB7XG4gICAgICAgICAgICByZWxhdGl2ZVRvID0gTW92ZVJlbGF0aXZlWm9uZWREYXRlVGltZShyZWxhdGl2ZVRvLCB5ZWFycywgbW9udGhzLCB3ZWVrcywgMCk7XG4gICAgICAgIH1cbiAgICAgICAgKHsgZGF5cywgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc2Vjb25kcywgbWljcm9zZWNvbmRzLCBuYW5vc2Vjb25kcyB9ID0gQmFsYW5jZUR1cmF0aW9uKGRheXMsIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBtaWxsaXNlY29uZHMsIG1pY3Jvc2Vjb25kcywgbmFub3NlY29uZHMsIGxhcmdlc3RVbml0LCByZWxhdGl2ZVRvKSk7XG4gICAgICAgIHJldHVybiBuZXcgRHVyYXRpb24oeWVhcnMsIG1vbnRocywgd2Vla3MsIGRheXMsIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBtaWxsaXNlY29uZHMsIG1pY3Jvc2Vjb25kcywgbmFub3NlY29uZHMpO1xuICAgIH1cbiAgICB0b3RhbChvcHRpb25zUGFyYW0pIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsRHVyYXRpb24odGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIGxldCB5ZWFycyA9IEdldFNsb3QodGhpcywgWUVBUlMpO1xuICAgICAgICBsZXQgbW9udGhzID0gR2V0U2xvdCh0aGlzLCBNT05USFMpO1xuICAgICAgICBsZXQgd2Vla3MgPSBHZXRTbG90KHRoaXMsIFdFRUtTKTtcbiAgICAgICAgbGV0IGRheXMgPSBHZXRTbG90KHRoaXMsIERBWVMpO1xuICAgICAgICBsZXQgaG91cnMgPSBHZXRTbG90KHRoaXMsIEhPVVJTKTtcbiAgICAgICAgbGV0IG1pbnV0ZXMgPSBHZXRTbG90KHRoaXMsIE1JTlVURVMpO1xuICAgICAgICBsZXQgc2Vjb25kcyA9IEdldFNsb3QodGhpcywgU0VDT05EUyk7XG4gICAgICAgIGxldCBtaWxsaXNlY29uZHMgPSBHZXRTbG90KHRoaXMsIE1JTExJU0VDT05EUyk7XG4gICAgICAgIGxldCBtaWNyb3NlY29uZHMgPSBHZXRTbG90KHRoaXMsIE1JQ1JPU0VDT05EUyk7XG4gICAgICAgIGxldCBuYW5vc2Vjb25kcyA9IEdldFNsb3QodGhpcywgTkFOT1NFQ09ORFMpO1xuICAgICAgICBpZiAob3B0aW9uc1BhcmFtID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdvcHRpb25zIGFyZ3VtZW50IGlzIHJlcXVpcmVkJyk7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB0eXBlb2Ygb3B0aW9uc1BhcmFtID09PSAnc3RyaW5nJ1xuICAgICAgICAgICAgPyBDcmVhdGVPbmVQcm9wT2JqZWN0KCd1bml0Jywgb3B0aW9uc1BhcmFtKVxuICAgICAgICAgICAgOiBHZXRPcHRpb25zT2JqZWN0KG9wdGlvbnNQYXJhbSk7XG4gICAgICAgIGNvbnN0IHVuaXQgPSBUb1RlbXBvcmFsRHVyYXRpb25Ub3RhbFVuaXQob3B0aW9ucyk7XG4gICAgICAgIGlmICh1bml0ID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigndW5pdCBvcHRpb24gaXMgcmVxdWlyZWQnKTtcbiAgICAgICAgY29uc3QgcmVsYXRpdmVUbyA9IFRvUmVsYXRpdmVUZW1wb3JhbE9iamVjdChvcHRpb25zKTtcbiAgICAgICAgLy8gQ29udmVydCBsYXJnZXIgdW5pdHMgZG93biB0byBkYXlzXG4gICAgICAgICh7IHllYXJzLCBtb250aHMsIHdlZWtzLCBkYXlzIH0gPSBVbmJhbGFuY2VEdXJhdGlvblJlbGF0aXZlKHllYXJzLCBtb250aHMsIHdlZWtzLCBkYXlzLCB1bml0LCByZWxhdGl2ZVRvKSk7XG4gICAgICAgIC8vIElmIHRoZSB1bml0IHdlJ3JlIHRvdGFsbGluZyBpcyBzbWFsbGVyIHRoYW4gYGRheXNgLCBjb252ZXJ0IGRheXMgZG93biB0byB0aGF0IHVuaXQuXG4gICAgICAgIGxldCBpbnRlcm1lZGlhdGU7XG4gICAgICAgIGlmIChJc1RlbXBvcmFsWm9uZWREYXRlVGltZShyZWxhdGl2ZVRvKSkge1xuICAgICAgICAgICAgaW50ZXJtZWRpYXRlID0gTW92ZVJlbGF0aXZlWm9uZWREYXRlVGltZShyZWxhdGl2ZVRvLCB5ZWFycywgbW9udGhzLCB3ZWVrcywgMCk7XG4gICAgICAgIH1cbiAgICAgICAgKHsgZGF5cywgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc2Vjb25kcywgbWljcm9zZWNvbmRzLCBuYW5vc2Vjb25kcyB9ID0gQmFsYW5jZUR1cmF0aW9uKGRheXMsIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBtaWxsaXNlY29uZHMsIG1pY3Jvc2Vjb25kcywgbmFub3NlY29uZHMsIHVuaXQsIGludGVybWVkaWF0ZSkpO1xuICAgICAgICAvLyBGaW5hbGx5LCB0cnVuY2F0ZSB0byB0aGUgY29ycmVjdCB1bml0IGFuZCBjYWxjdWxhdGUgcmVtYWluZGVyXG4gICAgICAgIGNvbnN0IHsgdG90YWwgfSA9IFJvdW5kRHVyYXRpb24oeWVhcnMsIG1vbnRocywgd2Vla3MsIGRheXMsIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBtaWxsaXNlY29uZHMsIG1pY3Jvc2Vjb25kcywgbmFub3NlY29uZHMsIDEsIHVuaXQsICd0cnVuYycsIHJlbGF0aXZlVG8pO1xuICAgICAgICByZXR1cm4gdG90YWw7XG4gICAgfVxuICAgIHRvU3RyaW5nKG9wdGlvbnNQYXJhbSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxEdXJhdGlvbih0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IEdldE9wdGlvbnNPYmplY3Qob3B0aW9uc1BhcmFtKTtcbiAgICAgICAgY29uc3QgeyBwcmVjaXNpb24sIHVuaXQsIGluY3JlbWVudCB9ID0gVG9TZWNvbmRzU3RyaW5nUHJlY2lzaW9uKG9wdGlvbnMpO1xuICAgICAgICBpZiAocHJlY2lzaW9uID09PSAnbWludXRlJylcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdzbWFsbGVzdFVuaXQgbXVzdCBub3QgYmUgXCJtaW51dGVcIicpO1xuICAgICAgICBjb25zdCByb3VuZGluZ01vZGUgPSBUb1RlbXBvcmFsUm91bmRpbmdNb2RlKG9wdGlvbnMsICd0cnVuYycpO1xuICAgICAgICByZXR1cm4gVGVtcG9yYWxEdXJhdGlvblRvU3RyaW5nKHRoaXMsIHByZWNpc2lvbiwgeyB1bml0LCBpbmNyZW1lbnQsIHJvdW5kaW5nTW9kZSB9KTtcbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxEdXJhdGlvbih0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgcmV0dXJuIFRlbXBvcmFsRHVyYXRpb25Ub1N0cmluZyh0aGlzKTtcbiAgICB9XG4gICAgdG9Mb2NhbGVTdHJpbmcobG9jYWxlcyA9IHVuZGVmaW5lZCwgb3B0aW9ucyA9IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxEdXJhdGlvbih0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgaWYgKHR5cGVvZiBJbnRsICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgSW50bC5EdXJhdGlvbkZvcm1hdCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSW50bC5EdXJhdGlvbkZvcm1hdChsb2NhbGVzLCBvcHRpb25zKS5mb3JtYXQodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc29sZS53YXJuKCdUZW1wb3JhbC5EdXJhdGlvbi5wcm90b3R5cGUudG9Mb2NhbGVTdHJpbmcoKSByZXF1aXJlcyBJbnRsLkR1cmF0aW9uRm9ybWF0LicpO1xuICAgICAgICByZXR1cm4gVGVtcG9yYWxEdXJhdGlvblRvU3RyaW5nKHRoaXMpO1xuICAgIH1cbiAgICB2YWx1ZU9mKCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd1c2UgY29tcGFyZSgpIHRvIGNvbXBhcmUgVGVtcG9yYWwuRHVyYXRpb24nKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb20oaXRlbSkge1xuICAgICAgICBpZiAoSXNUZW1wb3JhbER1cmF0aW9uKGl0ZW0pKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IER1cmF0aW9uKEdldFNsb3QoaXRlbSwgWUVBUlMpLCBHZXRTbG90KGl0ZW0sIE1PTlRIUyksIEdldFNsb3QoaXRlbSwgV0VFS1MpLCBHZXRTbG90KGl0ZW0sIERBWVMpLCBHZXRTbG90KGl0ZW0sIEhPVVJTKSwgR2V0U2xvdChpdGVtLCBNSU5VVEVTKSwgR2V0U2xvdChpdGVtLCBTRUNPTkRTKSwgR2V0U2xvdChpdGVtLCBNSUxMSVNFQ09ORFMpLCBHZXRTbG90KGl0ZW0sIE1JQ1JPU0VDT05EUyksIEdldFNsb3QoaXRlbSwgTkFOT1NFQ09ORFMpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gVG9UZW1wb3JhbER1cmF0aW9uKGl0ZW0pO1xuICAgIH1cbiAgICBzdGF0aWMgY29tcGFyZShvbmVQYXJhbSwgdHdvUGFyYW0sIG9wdGlvbnNQYXJhbSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCBvbmUgPSBUb1RlbXBvcmFsRHVyYXRpb24ob25lUGFyYW0pO1xuICAgICAgICBjb25zdCB0d28gPSBUb1RlbXBvcmFsRHVyYXRpb24odHdvUGFyYW0pO1xuICAgICAgICBjb25zdCBvcHRpb25zID0gR2V0T3B0aW9uc09iamVjdChvcHRpb25zUGFyYW0pO1xuICAgICAgICBjb25zdCByZWxhdGl2ZVRvID0gVG9SZWxhdGl2ZVRlbXBvcmFsT2JqZWN0KG9wdGlvbnMpO1xuICAgICAgICBjb25zdCB5MSA9IEdldFNsb3Qob25lLCBZRUFSUyk7XG4gICAgICAgIGNvbnN0IG1vbjEgPSBHZXRTbG90KG9uZSwgTU9OVEhTKTtcbiAgICAgICAgY29uc3QgdzEgPSBHZXRTbG90KG9uZSwgV0VFS1MpO1xuICAgICAgICBsZXQgZDEgPSBHZXRTbG90KG9uZSwgREFZUyk7XG4gICAgICAgIGNvbnN0IGgxID0gR2V0U2xvdChvbmUsIEhPVVJTKTtcbiAgICAgICAgY29uc3QgbWluMSA9IEdldFNsb3Qob25lLCBNSU5VVEVTKTtcbiAgICAgICAgY29uc3QgczEgPSBHZXRTbG90KG9uZSwgU0VDT05EUyk7XG4gICAgICAgIGNvbnN0IG1zMSA9IEdldFNsb3Qob25lLCBNSUxMSVNFQ09ORFMpO1xuICAgICAgICBjb25zdCDCtXMxID0gR2V0U2xvdChvbmUsIE1JQ1JPU0VDT05EUyk7XG4gICAgICAgIGxldCBuczEgPSBHZXRTbG90KG9uZSwgTkFOT1NFQ09ORFMpO1xuICAgICAgICBjb25zdCB5MiA9IEdldFNsb3QodHdvLCBZRUFSUyk7XG4gICAgICAgIGNvbnN0IG1vbjIgPSBHZXRTbG90KHR3bywgTU9OVEhTKTtcbiAgICAgICAgY29uc3QgdzIgPSBHZXRTbG90KHR3bywgV0VFS1MpO1xuICAgICAgICBsZXQgZDIgPSBHZXRTbG90KHR3bywgREFZUyk7XG4gICAgICAgIGNvbnN0IGgyID0gR2V0U2xvdCh0d28sIEhPVVJTKTtcbiAgICAgICAgY29uc3QgbWluMiA9IEdldFNsb3QodHdvLCBNSU5VVEVTKTtcbiAgICAgICAgY29uc3QgczIgPSBHZXRTbG90KHR3bywgU0VDT05EUyk7XG4gICAgICAgIGNvbnN0IG1zMiA9IEdldFNsb3QodHdvLCBNSUxMSVNFQ09ORFMpO1xuICAgICAgICBjb25zdCDCtXMyID0gR2V0U2xvdCh0d28sIE1JQ1JPU0VDT05EUyk7XG4gICAgICAgIGxldCBuczIgPSBHZXRTbG90KHR3bywgTkFOT1NFQ09ORFMpO1xuICAgICAgICBjb25zdCBzaGlmdDEgPSBDYWxjdWxhdGVPZmZzZXRTaGlmdChyZWxhdGl2ZVRvLCB5MSwgbW9uMSwgdzEsIGQxLCBoMSwgbWluMSwgczEsIG1zMSwgwrVzMSwgbnMxKTtcbiAgICAgICAgY29uc3Qgc2hpZnQyID0gQ2FsY3VsYXRlT2Zmc2V0U2hpZnQocmVsYXRpdmVUbywgeTIsIG1vbjIsIHcyLCBkMiwgaDIsIG1pbjIsIHMyLCBtczIsIMK1czIsIG5zMik7XG4gICAgICAgIGlmICh5MSAhPT0gMCB8fCB5MiAhPT0gMCB8fCBtb24xICE9PSAwIHx8IG1vbjIgIT09IDAgfHwgdzEgIT09IDAgfHwgdzIgIT09IDApIHtcbiAgICAgICAgICAgICh7IGRheXM6IGQxIH0gPSBVbmJhbGFuY2VEdXJhdGlvblJlbGF0aXZlKHkxLCBtb24xLCB3MSwgZDEsICdkYXknLCByZWxhdGl2ZVRvKSk7XG4gICAgICAgICAgICAoeyBkYXlzOiBkMiB9ID0gVW5iYWxhbmNlRHVyYXRpb25SZWxhdGl2ZSh5MiwgbW9uMiwgdzIsIGQyLCAnZGF5JywgcmVsYXRpdmVUbykpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRvdGFsTnMxID0gVG90YWxEdXJhdGlvbk5hbm9zZWNvbmRzKGQxLCBoMSwgbWluMSwgczEsIG1zMSwgwrVzMSwgbnMxLCBzaGlmdDEpO1xuICAgICAgICBjb25zdCB0b3RhbE5zMiA9IFRvdGFsRHVyYXRpb25OYW5vc2Vjb25kcyhkMiwgaDIsIG1pbjIsIHMyLCBtczIsIMK1czIsIG5zMiwgc2hpZnQyKTtcbiAgICAgICAgcmV0dXJuIENvbXBhcmlzb25SZXN1bHQoSlNCSS50b051bWJlcihKU0JJLnN1YnRyYWN0KHRvdGFsTnMxLCB0b3RhbE5zMikpKTtcbiAgICB9XG59XG5NYWtlSW50cmluc2ljQ2xhc3MoRHVyYXRpb24sICdUZW1wb3JhbC5EdXJhdGlvbicpO1xuXG5jb25zdCBPYmplY3RDcmVhdGUkMSA9IE9iamVjdC5jcmVhdGU7XG5jbGFzcyBQbGFpbk1vbnRoRGF5IHtcbiAgICBjb25zdHJ1Y3Rvcihpc29Nb250aFBhcmFtLCBpc29EYXlQYXJhbSwgY2FsZW5kYXJQYXJhbSA9IEdldElTTzg2MDFDYWxlbmRhcigpLCByZWZlcmVuY2VJU09ZZWFyUGFyYW0gPSAxOTcyKSB7XG4gICAgICAgIGNvbnN0IGlzb01vbnRoID0gVG9JbnRlZ2VyVGhyb3dPbkluZmluaXR5KGlzb01vbnRoUGFyYW0pO1xuICAgICAgICBjb25zdCBpc29EYXkgPSBUb0ludGVnZXJUaHJvd09uSW5maW5pdHkoaXNvRGF5UGFyYW0pO1xuICAgICAgICBjb25zdCBjYWxlbmRhciA9IFRvVGVtcG9yYWxDYWxlbmRhcihjYWxlbmRhclBhcmFtKTtcbiAgICAgICAgY29uc3QgcmVmZXJlbmNlSVNPWWVhciA9IFRvSW50ZWdlclRocm93T25JbmZpbml0eShyZWZlcmVuY2VJU09ZZWFyUGFyYW0pO1xuICAgICAgICAvLyBOb3RlOiBpZiB0aGUgYXJndW1lbnRzIGFyZSBub3QgcGFzc2VkLFxuICAgICAgICAvLyAgICAgICBUb0ludGVnZXJUaHJvd09uSW5maW5pdHkodW5kZWZpbmVkKSB3aWxsIGhhdmUgcmV0dXJuZWQgMCwgd2hpY2ggd2lsbFxuICAgICAgICAvLyAgICAgICBiZSByZWplY3RlZCBieSBSZWplY3RJU09EYXRlIGluIENyZWF0ZVRlbXBvcmFsTW9udGhEYXlTbG90cy4gVGhpc1xuICAgICAgICAvLyAgICAgICBjaGVjayBleGlzdHMgb25seSB0byBpbXByb3ZlIHRoZSBlcnJvciBtZXNzYWdlLlxuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdtaXNzaW5nIGFyZ3VtZW50OiBpc29Nb250aCBhbmQgaXNvRGF5IGFyZSByZXF1aXJlZCcpO1xuICAgICAgICB9XG4gICAgICAgIENyZWF0ZVRlbXBvcmFsTW9udGhEYXlTbG90cyh0aGlzLCBpc29Nb250aCwgaXNvRGF5LCBjYWxlbmRhciwgcmVmZXJlbmNlSVNPWWVhcik7XG4gICAgfVxuICAgIGdldCBtb250aENvZGUoKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbE1vbnRoRGF5KHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICByZXR1cm4gQ2FsZW5kYXJNb250aENvZGUoR2V0U2xvdCh0aGlzLCBDQUxFTkRBUiksIHRoaXMpO1xuICAgIH1cbiAgICBnZXQgZGF5KCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxNb250aERheSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgcmV0dXJuIENhbGVuZGFyRGF5KEdldFNsb3QodGhpcywgQ0FMRU5EQVIpLCB0aGlzKTtcbiAgICB9XG4gICAgZ2V0IGNhbGVuZGFyKCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxNb250aERheSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgcmV0dXJuIEdldFNsb3QodGhpcywgQ0FMRU5EQVIpO1xuICAgIH1cbiAgICB3aXRoKHRlbXBvcmFsTW9udGhEYXlMaWtlLCBvcHRpb25zUGFyYW0gPSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsTW9udGhEYXkodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIGlmICghSXNPYmplY3QodGVtcG9yYWxNb250aERheUxpa2UpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIGFyZ3VtZW50Jyk7XG4gICAgICAgIH1cbiAgICAgICAgUmVqZWN0T2JqZWN0V2l0aENhbGVuZGFyT3JUaW1lWm9uZSh0ZW1wb3JhbE1vbnRoRGF5TGlrZSk7XG4gICAgICAgIGNvbnN0IGNhbGVuZGFyID0gR2V0U2xvdCh0aGlzLCBDQUxFTkRBUik7XG4gICAgICAgIGNvbnN0IGZpZWxkTmFtZXMgPSBDYWxlbmRhckZpZWxkcyhjYWxlbmRhciwgWydkYXknLCAnbW9udGgnLCAnbW9udGhDb2RlJywgJ3llYXInXSk7XG4gICAgICAgIGNvbnN0IHByb3BzID0gVG9QYXJ0aWFsUmVjb3JkKHRlbXBvcmFsTW9udGhEYXlMaWtlLCBmaWVsZE5hbWVzKTtcbiAgICAgICAgaWYgKCFwcm9wcykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBtb250aC1kYXktbGlrZScpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBmaWVsZHMgPSBUb1RlbXBvcmFsTW9udGhEYXlGaWVsZHModGhpcywgZmllbGROYW1lcyk7XG4gICAgICAgIGZpZWxkcyA9IENhbGVuZGFyTWVyZ2VGaWVsZHMoY2FsZW5kYXIsIGZpZWxkcywgcHJvcHMpO1xuICAgICAgICBmaWVsZHMgPSBUb1RlbXBvcmFsTW9udGhEYXlGaWVsZHMoZmllbGRzLCBmaWVsZE5hbWVzKTtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IEdldE9wdGlvbnNPYmplY3Qob3B0aW9uc1BhcmFtKTtcbiAgICAgICAgcmV0dXJuIE1vbnRoRGF5RnJvbUZpZWxkcyhjYWxlbmRhciwgZmllbGRzLCBvcHRpb25zKTtcbiAgICB9XG4gICAgZXF1YWxzKG90aGVyUGFyYW0pIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsTW9udGhEYXkodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIGNvbnN0IG90aGVyID0gVG9UZW1wb3JhbE1vbnRoRGF5KG90aGVyUGFyYW0pO1xuICAgICAgICBmb3IgKGNvbnN0IHNsb3Qgb2YgW0lTT19NT05USCwgSVNPX0RBWSwgSVNPX1lFQVJdKSB7XG4gICAgICAgICAgICBjb25zdCB2YWwxID0gR2V0U2xvdCh0aGlzLCBzbG90KTtcbiAgICAgICAgICAgIGNvbnN0IHZhbDIgPSBHZXRTbG90KG90aGVyLCBzbG90KTtcbiAgICAgICAgICAgIGlmICh2YWwxICE9PSB2YWwyKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQ2FsZW5kYXJFcXVhbHMoR2V0U2xvdCh0aGlzLCBDQUxFTkRBUiksIEdldFNsb3Qob3RoZXIsIENBTEVOREFSKSk7XG4gICAgfVxuICAgIHRvU3RyaW5nKG9wdGlvbnNQYXJhbSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxNb250aERheSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IEdldE9wdGlvbnNPYmplY3Qob3B0aW9uc1BhcmFtKTtcbiAgICAgICAgY29uc3Qgc2hvd0NhbGVuZGFyID0gVG9TaG93Q2FsZW5kYXJPcHRpb24ob3B0aW9ucyk7XG4gICAgICAgIHJldHVybiBUZW1wb3JhbE1vbnRoRGF5VG9TdHJpbmcodGhpcywgc2hvd0NhbGVuZGFyKTtcbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxNb250aERheSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgcmV0dXJuIFRlbXBvcmFsTW9udGhEYXlUb1N0cmluZyh0aGlzKTtcbiAgICB9XG4gICAgdG9Mb2NhbGVTdHJpbmcobG9jYWxlcyA9IHVuZGVmaW5lZCwgb3B0aW9ucyA9IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxNb250aERheSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlVGltZUZvcm1hdChsb2NhbGVzLCBvcHRpb25zKS5mb3JtYXQodGhpcyk7XG4gICAgfVxuICAgIHZhbHVlT2YoKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3VzZSBlcXVhbHMoKSB0byBjb21wYXJlIFRlbXBvcmFsLlBsYWluTW9udGhEYXknKTtcbiAgICB9XG4gICAgdG9QbGFpbkRhdGUoaXRlbSkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxNb250aERheSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgaWYgKCFJc09iamVjdChpdGVtKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2FyZ3VtZW50IHNob3VsZCBiZSBhbiBvYmplY3QnKTtcbiAgICAgICAgY29uc3QgY2FsZW5kYXIgPSBHZXRTbG90KHRoaXMsIENBTEVOREFSKTtcbiAgICAgICAgY29uc3QgcmVjZWl2ZXJGaWVsZE5hbWVzID0gQ2FsZW5kYXJGaWVsZHMoY2FsZW5kYXIsIFsnZGF5JywgJ21vbnRoQ29kZSddKTtcbiAgICAgICAgY29uc3QgZmllbGRzID0gVG9UZW1wb3JhbE1vbnRoRGF5RmllbGRzKHRoaXMsIHJlY2VpdmVyRmllbGROYW1lcyk7XG4gICAgICAgIGNvbnN0IGlucHV0RmllbGROYW1lcyA9IENhbGVuZGFyRmllbGRzKGNhbGVuZGFyLCBbJ3llYXInXSk7XG4gICAgICAgIGNvbnN0IGlucHV0RW50cmllcyA9IFtbJ3llYXInLCB1bmRlZmluZWRdXTtcbiAgICAgICAgLy8gQWRkIGV4dHJhIGZpZWxkcyBmcm9tIHRoZSBjYWxlbmRhciBhdCB0aGUgZW5kXG4gICAgICAgIGlucHV0RmllbGROYW1lcy5mb3JFYWNoKChmaWVsZE5hbWUpID0+IHtcbiAgICAgICAgICAgIGlmICghaW5wdXRFbnRyaWVzLnNvbWUoKFtuYW1lXSkgPT4gbmFtZSA9PT0gZmllbGROYW1lKSkge1xuICAgICAgICAgICAgICAgIGlucHV0RW50cmllcy5wdXNoKFtmaWVsZE5hbWUsIHVuZGVmaW5lZF0pOyAvLyBNYWtlIFRTIGlnbm9yZSBleHRyYSBmaWVsZHNcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGlucHV0RmllbGRzID0gUHJlcGFyZVRlbXBvcmFsRmllbGRzKGl0ZW0sIGlucHV0RW50cmllcyk7XG4gICAgICAgIGxldCBtZXJnZWRGaWVsZHMgPSBDYWxlbmRhck1lcmdlRmllbGRzKGNhbGVuZGFyLCBmaWVsZHMsIGlucHV0RmllbGRzKTtcbiAgICAgICAgY29uc3QgbWVyZ2VkRmllbGROYW1lcyA9IFsuLi5uZXcgU2V0KFsuLi5yZWNlaXZlckZpZWxkTmFtZXMsIC4uLmlucHV0RmllbGROYW1lc10pXTtcbiAgICAgICAgY29uc3QgbWVyZ2VkRW50cmllcyA9IFtdO1xuICAgICAgICBtZXJnZWRGaWVsZE5hbWVzLmZvckVhY2goKGZpZWxkTmFtZSkgPT4ge1xuICAgICAgICAgICAgaWYgKCFtZXJnZWRFbnRyaWVzLnNvbWUoKFtuYW1lXSkgPT4gbmFtZSA9PT0gZmllbGROYW1lKSkge1xuICAgICAgICAgICAgICAgIG1lcmdlZEVudHJpZXMucHVzaChbZmllbGROYW1lLCB1bmRlZmluZWRdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIG1lcmdlZEZpZWxkcyA9IFByZXBhcmVUZW1wb3JhbEZpZWxkcyhtZXJnZWRGaWVsZHMsIG1lcmdlZEVudHJpZXMpO1xuICAgICAgICBjb25zdCBvcHRpb25zID0gT2JqZWN0Q3JlYXRlJDEobnVsbCk7XG4gICAgICAgIG9wdGlvbnMub3ZlcmZsb3cgPSAncmVqZWN0JztcbiAgICAgICAgcmV0dXJuIERhdGVGcm9tRmllbGRzKGNhbGVuZGFyLCBtZXJnZWRGaWVsZHMsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBnZXRJU09GaWVsZHMoKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbE1vbnRoRGF5KHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY2FsZW5kYXI6IEdldFNsb3QodGhpcywgQ0FMRU5EQVIpLFxuICAgICAgICAgICAgaXNvRGF5OiBHZXRTbG90KHRoaXMsIElTT19EQVkpLFxuICAgICAgICAgICAgaXNvTW9udGg6IEdldFNsb3QodGhpcywgSVNPX01PTlRIKSxcbiAgICAgICAgICAgIGlzb1llYXI6IEdldFNsb3QodGhpcywgSVNPX1lFQVIpXG4gICAgICAgIH07XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tKGl0ZW0sIG9wdGlvbnNQYXJhbSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCBvcHRpb25zID0gR2V0T3B0aW9uc09iamVjdChvcHRpb25zUGFyYW0pO1xuICAgICAgICBpZiAoSXNUZW1wb3JhbE1vbnRoRGF5KGl0ZW0pKSB7XG4gICAgICAgICAgICBUb1RlbXBvcmFsT3ZlcmZsb3cob3B0aW9ucyk7IC8vIHZhbGlkYXRlIGFuZCBpZ25vcmVcbiAgICAgICAgICAgIHJldHVybiBDcmVhdGVUZW1wb3JhbE1vbnRoRGF5KEdldFNsb3QoaXRlbSwgSVNPX01PTlRIKSwgR2V0U2xvdChpdGVtLCBJU09fREFZKSwgR2V0U2xvdChpdGVtLCBDQUxFTkRBUiksIEdldFNsb3QoaXRlbSwgSVNPX1lFQVIpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gVG9UZW1wb3JhbE1vbnRoRGF5KGl0ZW0sIG9wdGlvbnMpO1xuICAgIH1cbn1cbk1ha2VJbnRyaW5zaWNDbGFzcyhQbGFpbk1vbnRoRGF5LCAnVGVtcG9yYWwuUGxhaW5Nb250aERheScpO1xuXG5jb25zdCBpbnN0YW50ID0gKCkgPT4ge1xuICAgIGNvbnN0IEluc3RhbnQgPSBHZXRJbnRyaW5zaWMoJyVUZW1wb3JhbC5JbnN0YW50JScpO1xuICAgIHJldHVybiBuZXcgSW5zdGFudChTeXN0ZW1VVENFcG9jaE5hbm9TZWNvbmRzKCkpO1xufTtcbmNvbnN0IHBsYWluRGF0ZVRpbWUgPSAoY2FsZW5kYXJMaWtlLCB0ZW1wb3JhbFRpbWVab25lTGlrZSA9IHRpbWVab25lKCkpID0+IHtcbiAgICBjb25zdCB0WiA9IFRvVGVtcG9yYWxUaW1lWm9uZSh0ZW1wb3JhbFRpbWVab25lTGlrZSk7XG4gICAgY29uc3QgY2FsZW5kYXIgPSBUb1RlbXBvcmFsQ2FsZW5kYXIoY2FsZW5kYXJMaWtlKTtcbiAgICBjb25zdCBpbnN0ID0gaW5zdGFudCgpO1xuICAgIHJldHVybiBCdWlsdGluVGltZVpvbmVHZXRQbGFpbkRhdGVUaW1lRm9yKHRaLCBpbnN0LCBjYWxlbmRhcik7XG59O1xuY29uc3QgcGxhaW5EYXRlVGltZUlTTyA9ICh0ZW1wb3JhbFRpbWVab25lTGlrZSA9IHRpbWVab25lKCkpID0+IHtcbiAgICBjb25zdCB0WiA9IFRvVGVtcG9yYWxUaW1lWm9uZSh0ZW1wb3JhbFRpbWVab25lTGlrZSk7XG4gICAgY29uc3QgY2FsZW5kYXIgPSBHZXRJU084NjAxQ2FsZW5kYXIoKTtcbiAgICBjb25zdCBpbnN0ID0gaW5zdGFudCgpO1xuICAgIHJldHVybiBCdWlsdGluVGltZVpvbmVHZXRQbGFpbkRhdGVUaW1lRm9yKHRaLCBpbnN0LCBjYWxlbmRhcik7XG59O1xuY29uc3Qgem9uZWREYXRlVGltZSA9IChjYWxlbmRhckxpa2UsIHRlbXBvcmFsVGltZVpvbmVMaWtlID0gdGltZVpvbmUoKSkgPT4ge1xuICAgIGNvbnN0IHRaID0gVG9UZW1wb3JhbFRpbWVab25lKHRlbXBvcmFsVGltZVpvbmVMaWtlKTtcbiAgICBjb25zdCBjYWxlbmRhciA9IFRvVGVtcG9yYWxDYWxlbmRhcihjYWxlbmRhckxpa2UpO1xuICAgIHJldHVybiBDcmVhdGVUZW1wb3JhbFpvbmVkRGF0ZVRpbWUoU3lzdGVtVVRDRXBvY2hOYW5vU2Vjb25kcygpLCB0WiwgY2FsZW5kYXIpO1xufTtcbmNvbnN0IHpvbmVkRGF0ZVRpbWVJU08gPSAodGVtcG9yYWxUaW1lWm9uZUxpa2UgPSB0aW1lWm9uZSgpKSA9PiB7XG4gICAgcmV0dXJuIHpvbmVkRGF0ZVRpbWUoR2V0SVNPODYwMUNhbGVuZGFyKCksIHRlbXBvcmFsVGltZVpvbmVMaWtlKTtcbn07XG5jb25zdCBwbGFpbkRhdGUgPSAoY2FsZW5kYXJMaWtlLCB0ZW1wb3JhbFRpbWVab25lTGlrZSA9IHRpbWVab25lKCkpID0+IHtcbiAgICByZXR1cm4gVGVtcG9yYWxEYXRlVGltZVRvRGF0ZShwbGFpbkRhdGVUaW1lKGNhbGVuZGFyTGlrZSwgdGVtcG9yYWxUaW1lWm9uZUxpa2UpKTtcbn07XG5jb25zdCBwbGFpbkRhdGVJU08gPSAodGVtcG9yYWxUaW1lWm9uZUxpa2UgPSB0aW1lWm9uZSgpKSA9PiB7XG4gICAgcmV0dXJuIFRlbXBvcmFsRGF0ZVRpbWVUb0RhdGUocGxhaW5EYXRlVGltZUlTTyh0ZW1wb3JhbFRpbWVab25lTGlrZSkpO1xufTtcbmNvbnN0IHBsYWluVGltZUlTTyA9ICh0ZW1wb3JhbFRpbWVab25lTGlrZSA9IHRpbWVab25lKCkpID0+IHtcbiAgICByZXR1cm4gVGVtcG9yYWxEYXRlVGltZVRvVGltZShwbGFpbkRhdGVUaW1lSVNPKHRlbXBvcmFsVGltZVpvbmVMaWtlKSk7XG59O1xuY29uc3QgdGltZVpvbmUgPSAoKSA9PiB7XG4gICAgcmV0dXJuIFN5c3RlbVRpbWVab25lKCk7XG59O1xuY29uc3QgTm93ID0ge1xuICAgIGluc3RhbnQsXG4gICAgcGxhaW5EYXRlVGltZSxcbiAgICBwbGFpbkRhdGVUaW1lSVNPLFxuICAgIHBsYWluRGF0ZSxcbiAgICBwbGFpbkRhdGVJU08sXG4gICAgcGxhaW5UaW1lSVNPLFxuICAgIHRpbWVab25lLFxuICAgIHpvbmVkRGF0ZVRpbWUsXG4gICAgem9uZWREYXRlVGltZUlTTyxcbiAgICBbU3ltYm9sLnRvU3RyaW5nVGFnXTogJ1RlbXBvcmFsLk5vdydcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoTm93LCBTeW1ib2wudG9TdHJpbmdUYWcsIHtcbiAgICB2YWx1ZTogJ1RlbXBvcmFsLk5vdycsXG4gICAgd3JpdGFibGU6IGZhbHNlLFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxufSk7XG5cbmNvbnN0IE9iamVjdEFzc2lnbiA9IE9iamVjdC5hc3NpZ247XG5jb25zdCBESVNBTExPV0VEX1VOSVRTJDEgPSBbJ3llYXInLCAnbW9udGgnLCAnd2VlaycsICdkYXknXTtcbmNvbnN0IE1BWF9JTkNSRU1FTlRTID0ge1xuICAgIGhvdXI6IDI0LFxuICAgIG1pbnV0ZTogNjAsXG4gICAgc2Vjb25kOiA2MCxcbiAgICBtaWxsaXNlY29uZDogMTAwMCxcbiAgICBtaWNyb3NlY29uZDogMTAwMCxcbiAgICBuYW5vc2Vjb25kOiAxMDAwXG59O1xuZnVuY3Rpb24gVGVtcG9yYWxUaW1lVG9TdHJpbmcodGltZSwgcHJlY2lzaW9uLCBvcHRpb25zID0gdW5kZWZpbmVkKSB7XG4gICAgbGV0IGhvdXIgPSBHZXRTbG90KHRpbWUsIElTT19IT1VSKTtcbiAgICBsZXQgbWludXRlID0gR2V0U2xvdCh0aW1lLCBJU09fTUlOVVRFKTtcbiAgICBsZXQgc2Vjb25kID0gR2V0U2xvdCh0aW1lLCBJU09fU0VDT05EKTtcbiAgICBsZXQgbWlsbGlzZWNvbmQgPSBHZXRTbG90KHRpbWUsIElTT19NSUxMSVNFQ09ORCk7XG4gICAgbGV0IG1pY3Jvc2Vjb25kID0gR2V0U2xvdCh0aW1lLCBJU09fTUlDUk9TRUNPTkQpO1xuICAgIGxldCBuYW5vc2Vjb25kID0gR2V0U2xvdCh0aW1lLCBJU09fTkFOT1NFQ09ORCk7XG4gICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgeyB1bml0LCBpbmNyZW1lbnQsIHJvdW5kaW5nTW9kZSB9ID0gb3B0aW9ucztcbiAgICAgICAgKHsgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kLCBtaWNyb3NlY29uZCwgbmFub3NlY29uZCB9ID0gUm91bmRUaW1lKGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZCwgbWljcm9zZWNvbmQsIG5hbm9zZWNvbmQsIGluY3JlbWVudCwgdW5pdCwgcm91bmRpbmdNb2RlKSk7XG4gICAgfVxuICAgIGNvbnN0IGhvdXJTdHJpbmcgPSBJU09EYXRlVGltZVBhcnRTdHJpbmcoaG91cik7XG4gICAgY29uc3QgbWludXRlU3RyaW5nID0gSVNPRGF0ZVRpbWVQYXJ0U3RyaW5nKG1pbnV0ZSk7XG4gICAgY29uc3Qgc2Vjb25kcyA9IEZvcm1hdFNlY29uZHNTdHJpbmdQYXJ0KHNlY29uZCwgbWlsbGlzZWNvbmQsIG1pY3Jvc2Vjb25kLCBuYW5vc2Vjb25kLCBwcmVjaXNpb24pO1xuICAgIHJldHVybiBgJHtob3VyU3RyaW5nfToke21pbnV0ZVN0cmluZ30ke3NlY29uZHN9YDtcbn1cbmNsYXNzIFBsYWluVGltZSB7XG4gICAgY29uc3RydWN0b3IoaXNvSG91clBhcmFtID0gMCwgaXNvTWludXRlUGFyYW0gPSAwLCBpc29TZWNvbmRQYXJhbSA9IDAsIGlzb01pbGxpc2Vjb25kUGFyYW0gPSAwLCBpc29NaWNyb3NlY29uZFBhcmFtID0gMCwgaXNvTmFub3NlY29uZFBhcmFtID0gMCkge1xuICAgICAgICBjb25zdCBpc29Ib3VyID0gVG9JbnRlZ2VyVGhyb3dPbkluZmluaXR5KGlzb0hvdXJQYXJhbSk7XG4gICAgICAgIGNvbnN0IGlzb01pbnV0ZSA9IFRvSW50ZWdlclRocm93T25JbmZpbml0eShpc29NaW51dGVQYXJhbSk7XG4gICAgICAgIGNvbnN0IGlzb1NlY29uZCA9IFRvSW50ZWdlclRocm93T25JbmZpbml0eShpc29TZWNvbmRQYXJhbSk7XG4gICAgICAgIGNvbnN0IGlzb01pbGxpc2Vjb25kID0gVG9JbnRlZ2VyVGhyb3dPbkluZmluaXR5KGlzb01pbGxpc2Vjb25kUGFyYW0pO1xuICAgICAgICBjb25zdCBpc29NaWNyb3NlY29uZCA9IFRvSW50ZWdlclRocm93T25JbmZpbml0eShpc29NaWNyb3NlY29uZFBhcmFtKTtcbiAgICAgICAgY29uc3QgaXNvTmFub3NlY29uZCA9IFRvSW50ZWdlclRocm93T25JbmZpbml0eShpc29OYW5vc2Vjb25kUGFyYW0pO1xuICAgICAgICBSZWplY3RUaW1lKGlzb0hvdXIsIGlzb01pbnV0ZSwgaXNvU2Vjb25kLCBpc29NaWxsaXNlY29uZCwgaXNvTWljcm9zZWNvbmQsIGlzb05hbm9zZWNvbmQpO1xuICAgICAgICBDcmVhdGVTbG90cyh0aGlzKTtcbiAgICAgICAgU2V0U2xvdCh0aGlzLCBJU09fSE9VUiwgaXNvSG91cik7XG4gICAgICAgIFNldFNsb3QodGhpcywgSVNPX01JTlVURSwgaXNvTWludXRlKTtcbiAgICAgICAgU2V0U2xvdCh0aGlzLCBJU09fU0VDT05ELCBpc29TZWNvbmQpO1xuICAgICAgICBTZXRTbG90KHRoaXMsIElTT19NSUxMSVNFQ09ORCwgaXNvTWlsbGlzZWNvbmQpO1xuICAgICAgICBTZXRTbG90KHRoaXMsIElTT19NSUNST1NFQ09ORCwgaXNvTWljcm9zZWNvbmQpO1xuICAgICAgICBTZXRTbG90KHRoaXMsIElTT19OQU5PU0VDT05ELCBpc29OYW5vc2Vjb25kKTtcbiAgICAgICAgU2V0U2xvdCh0aGlzLCBDQUxFTkRBUiwgR2V0SVNPODYwMUNhbGVuZGFyKCkpO1xuICAgICAgICB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ19yZXByXycsIHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogYCR7dGhpc1tTeW1ib2wudG9TdHJpbmdUYWddfSA8JHtUZW1wb3JhbFRpbWVUb1N0cmluZyh0aGlzLCAnYXV0bycpfT5gLFxuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgY2FsZW5kYXIoKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbFRpbWUodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIC8vIFBsYWluVGltZSdzIGNhbGVuZGFyIGlzbid0IHNldHRhYmxlLCBzbyBjYW4ndCBiZSBhIHVzZXJsYW5kIGNhbGVuZGFyXG4gICAgICAgIHJldHVybiBHZXRTbG90KHRoaXMsIENBTEVOREFSKTtcbiAgICB9XG4gICAgZ2V0IGhvdXIoKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbFRpbWUodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIHJldHVybiBHZXRTbG90KHRoaXMsIElTT19IT1VSKTtcbiAgICB9XG4gICAgZ2V0IG1pbnV0ZSgpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsVGltZSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgcmV0dXJuIEdldFNsb3QodGhpcywgSVNPX01JTlVURSk7XG4gICAgfVxuICAgIGdldCBzZWNvbmQoKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbFRpbWUodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIHJldHVybiBHZXRTbG90KHRoaXMsIElTT19TRUNPTkQpO1xuICAgIH1cbiAgICBnZXQgbWlsbGlzZWNvbmQoKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbFRpbWUodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIHJldHVybiBHZXRTbG90KHRoaXMsIElTT19NSUxMSVNFQ09ORCk7XG4gICAgfVxuICAgIGdldCBtaWNyb3NlY29uZCgpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsVGltZSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgcmV0dXJuIEdldFNsb3QodGhpcywgSVNPX01JQ1JPU0VDT05EKTtcbiAgICB9XG4gICAgZ2V0IG5hbm9zZWNvbmQoKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbFRpbWUodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIHJldHVybiBHZXRTbG90KHRoaXMsIElTT19OQU5PU0VDT05EKTtcbiAgICB9XG4gICAgd2l0aCh0ZW1wb3JhbFRpbWVMaWtlLCBvcHRpb25zUGFyYW0gPSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsVGltZSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgaWYgKCFJc09iamVjdCh0ZW1wb3JhbFRpbWVMaWtlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBhcmd1bWVudCcpO1xuICAgICAgICB9XG4gICAgICAgIFJlamVjdE9iamVjdFdpdGhDYWxlbmRhck9yVGltZVpvbmUodGVtcG9yYWxUaW1lTGlrZSk7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSBHZXRPcHRpb25zT2JqZWN0KG9wdGlvbnNQYXJhbSk7XG4gICAgICAgIGNvbnN0IG92ZXJmbG93ID0gVG9UZW1wb3JhbE92ZXJmbG93KG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBwcm9wcyA9IFRvUGFydGlhbFJlY29yZCh0ZW1wb3JhbFRpbWVMaWtlLCBbXG4gICAgICAgICAgICAnaG91cicsXG4gICAgICAgICAgICAnbWljcm9zZWNvbmQnLFxuICAgICAgICAgICAgJ21pbGxpc2Vjb25kJyxcbiAgICAgICAgICAgICdtaW51dGUnLFxuICAgICAgICAgICAgJ25hbm9zZWNvbmQnLFxuICAgICAgICAgICAgJ3NlY29uZCdcbiAgICAgICAgXSk7XG4gICAgICAgIGlmICghcHJvcHMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgdGltZS1saWtlJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZmllbGRzID0gVG9UZW1wb3JhbFRpbWVSZWNvcmQodGhpcyk7XG4gICAgICAgIGxldCB7IGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZCwgbWljcm9zZWNvbmQsIG5hbm9zZWNvbmQgfSA9IE9iamVjdEFzc2lnbihmaWVsZHMsIHByb3BzKTtcbiAgICAgICAgKHsgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kLCBtaWNyb3NlY29uZCwgbmFub3NlY29uZCB9ID0gUmVndWxhdGVUaW1lKGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZCwgbWljcm9zZWNvbmQsIG5hbm9zZWNvbmQsIG92ZXJmbG93KSk7XG4gICAgICAgIHJldHVybiBuZXcgUGxhaW5UaW1lKGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZCwgbWljcm9zZWNvbmQsIG5hbm9zZWNvbmQpO1xuICAgIH1cbiAgICBhZGQodGVtcG9yYWxEdXJhdGlvbkxpa2UpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsVGltZSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgY29uc3QgZHVyYXRpb24gPSBUb0xpbWl0ZWRUZW1wb3JhbER1cmF0aW9uKHRlbXBvcmFsRHVyYXRpb25MaWtlKTtcbiAgICAgICAgY29uc3QgeyBob3VycywgbWludXRlcywgc2Vjb25kcywgbWlsbGlzZWNvbmRzLCBtaWNyb3NlY29uZHMsIG5hbm9zZWNvbmRzIH0gPSBkdXJhdGlvbjtcbiAgICAgICAgbGV0IGhvdXIgPSBHZXRTbG90KHRoaXMsIElTT19IT1VSKTtcbiAgICAgICAgbGV0IG1pbnV0ZSA9IEdldFNsb3QodGhpcywgSVNPX01JTlVURSk7XG4gICAgICAgIGxldCBzZWNvbmQgPSBHZXRTbG90KHRoaXMsIElTT19TRUNPTkQpO1xuICAgICAgICBsZXQgbWlsbGlzZWNvbmQgPSBHZXRTbG90KHRoaXMsIElTT19NSUxMSVNFQ09ORCk7XG4gICAgICAgIGxldCBtaWNyb3NlY29uZCA9IEdldFNsb3QodGhpcywgSVNPX01JQ1JPU0VDT05EKTtcbiAgICAgICAgbGV0IG5hbm9zZWNvbmQgPSBHZXRTbG90KHRoaXMsIElTT19OQU5PU0VDT05EKTtcbiAgICAgICAgKHsgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kLCBtaWNyb3NlY29uZCwgbmFub3NlY29uZCB9ID0gQWRkVGltZShob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQsIG1pY3Jvc2Vjb25kLCBuYW5vc2Vjb25kLCBob3VycywgbWludXRlcywgc2Vjb25kcywgbWlsbGlzZWNvbmRzLCBtaWNyb3NlY29uZHMsIG5hbm9zZWNvbmRzKSk7XG4gICAgICAgICh7IGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZCwgbWljcm9zZWNvbmQsIG5hbm9zZWNvbmQgfSA9IFJlZ3VsYXRlVGltZShob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQsIG1pY3Jvc2Vjb25kLCBuYW5vc2Vjb25kLCAncmVqZWN0JykpO1xuICAgICAgICByZXR1cm4gbmV3IFBsYWluVGltZShob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQsIG1pY3Jvc2Vjb25kLCBuYW5vc2Vjb25kKTtcbiAgICB9XG4gICAgc3VidHJhY3QodGVtcG9yYWxEdXJhdGlvbkxpa2UpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsVGltZSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgY29uc3QgZHVyYXRpb24gPSBUb0xpbWl0ZWRUZW1wb3JhbER1cmF0aW9uKHRlbXBvcmFsRHVyYXRpb25MaWtlKTtcbiAgICAgICAgY29uc3QgeyBob3VycywgbWludXRlcywgc2Vjb25kcywgbWlsbGlzZWNvbmRzLCBtaWNyb3NlY29uZHMsIG5hbm9zZWNvbmRzIH0gPSBkdXJhdGlvbjtcbiAgICAgICAgbGV0IGhvdXIgPSBHZXRTbG90KHRoaXMsIElTT19IT1VSKTtcbiAgICAgICAgbGV0IG1pbnV0ZSA9IEdldFNsb3QodGhpcywgSVNPX01JTlVURSk7XG4gICAgICAgIGxldCBzZWNvbmQgPSBHZXRTbG90KHRoaXMsIElTT19TRUNPTkQpO1xuICAgICAgICBsZXQgbWlsbGlzZWNvbmQgPSBHZXRTbG90KHRoaXMsIElTT19NSUxMSVNFQ09ORCk7XG4gICAgICAgIGxldCBtaWNyb3NlY29uZCA9IEdldFNsb3QodGhpcywgSVNPX01JQ1JPU0VDT05EKTtcbiAgICAgICAgbGV0IG5hbm9zZWNvbmQgPSBHZXRTbG90KHRoaXMsIElTT19OQU5PU0VDT05EKTtcbiAgICAgICAgKHsgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kLCBtaWNyb3NlY29uZCwgbmFub3NlY29uZCB9ID0gQWRkVGltZShob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQsIG1pY3Jvc2Vjb25kLCBuYW5vc2Vjb25kLCAtaG91cnMsIC1taW51dGVzLCAtc2Vjb25kcywgLW1pbGxpc2Vjb25kcywgLW1pY3Jvc2Vjb25kcywgLW5hbm9zZWNvbmRzKSk7XG4gICAgICAgICh7IGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZCwgbWljcm9zZWNvbmQsIG5hbm9zZWNvbmQgfSA9IFJlZ3VsYXRlVGltZShob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQsIG1pY3Jvc2Vjb25kLCBuYW5vc2Vjb25kLCAncmVqZWN0JykpO1xuICAgICAgICByZXR1cm4gbmV3IFBsYWluVGltZShob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQsIG1pY3Jvc2Vjb25kLCBuYW5vc2Vjb25kKTtcbiAgICB9XG4gICAgdW50aWwob3RoZXJQYXJhbSwgb3B0aW9uc1BhcmFtID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbFRpbWUodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIGNvbnN0IG90aGVyID0gVG9UZW1wb3JhbFRpbWUob3RoZXJQYXJhbSk7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSBHZXRPcHRpb25zT2JqZWN0KG9wdGlvbnNQYXJhbSk7XG4gICAgICAgIGNvbnN0IGxhcmdlc3RVbml0ID0gVG9MYXJnZXN0VGVtcG9yYWxVbml0KG9wdGlvbnMsICdhdXRvJywgRElTQUxMT1dFRF9VTklUUyQxLCAnaG91cicpO1xuICAgICAgICBjb25zdCBzbWFsbGVzdFVuaXQgPSBUb1NtYWxsZXN0VGVtcG9yYWxVbml0KG9wdGlvbnMsICduYW5vc2Vjb25kJywgRElTQUxMT1dFRF9VTklUUyQxKTtcbiAgICAgICAgVmFsaWRhdGVUZW1wb3JhbFVuaXRSYW5nZShsYXJnZXN0VW5pdCwgc21hbGxlc3RVbml0KTtcbiAgICAgICAgY29uc3Qgcm91bmRpbmdNb2RlID0gVG9UZW1wb3JhbFJvdW5kaW5nTW9kZShvcHRpb25zLCAndHJ1bmMnKTtcbiAgICAgICAgY29uc3Qgcm91bmRpbmdJbmNyZW1lbnQgPSBUb1RlbXBvcmFsUm91bmRpbmdJbmNyZW1lbnQob3B0aW9ucywgTUFYX0lOQ1JFTUVOVFNbc21hbGxlc3RVbml0XSwgZmFsc2UpO1xuICAgICAgICBsZXQgeyBob3VycywgbWludXRlcywgc2Vjb25kcywgbWlsbGlzZWNvbmRzLCBtaWNyb3NlY29uZHMsIG5hbm9zZWNvbmRzIH0gPSBEaWZmZXJlbmNlVGltZShHZXRTbG90KHRoaXMsIElTT19IT1VSKSwgR2V0U2xvdCh0aGlzLCBJU09fTUlOVVRFKSwgR2V0U2xvdCh0aGlzLCBJU09fU0VDT05EKSwgR2V0U2xvdCh0aGlzLCBJU09fTUlMTElTRUNPTkQpLCBHZXRTbG90KHRoaXMsIElTT19NSUNST1NFQ09ORCksIEdldFNsb3QodGhpcywgSVNPX05BTk9TRUNPTkQpLCBHZXRTbG90KG90aGVyLCBJU09fSE9VUiksIEdldFNsb3Qob3RoZXIsIElTT19NSU5VVEUpLCBHZXRTbG90KG90aGVyLCBJU09fU0VDT05EKSwgR2V0U2xvdChvdGhlciwgSVNPX01JTExJU0VDT05EKSwgR2V0U2xvdChvdGhlciwgSVNPX01JQ1JPU0VDT05EKSwgR2V0U2xvdChvdGhlciwgSVNPX05BTk9TRUNPTkQpKTtcbiAgICAgICAgKHsgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc2Vjb25kcywgbWljcm9zZWNvbmRzLCBuYW5vc2Vjb25kcyB9ID0gUm91bmREdXJhdGlvbigwLCAwLCAwLCAwLCBob3VycywgbWludXRlcywgc2Vjb25kcywgbWlsbGlzZWNvbmRzLCBtaWNyb3NlY29uZHMsIG5hbm9zZWNvbmRzLCByb3VuZGluZ0luY3JlbWVudCwgc21hbGxlc3RVbml0LCByb3VuZGluZ01vZGUpKTtcbiAgICAgICAgKHsgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc2Vjb25kcywgbWljcm9zZWNvbmRzLCBuYW5vc2Vjb25kcyB9ID0gQmFsYW5jZUR1cmF0aW9uKDAsIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBtaWxsaXNlY29uZHMsIG1pY3Jvc2Vjb25kcywgbmFub3NlY29uZHMsIGxhcmdlc3RVbml0KSk7XG4gICAgICAgIGNvbnN0IER1cmF0aW9uID0gR2V0SW50cmluc2ljKCclVGVtcG9yYWwuRHVyYXRpb24lJyk7XG4gICAgICAgIHJldHVybiBuZXcgRHVyYXRpb24oMCwgMCwgMCwgMCwgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc2Vjb25kcywgbWljcm9zZWNvbmRzLCBuYW5vc2Vjb25kcyk7XG4gICAgfVxuICAgIHNpbmNlKG90aGVyUGFyYW0sIG9wdGlvbnNQYXJhbSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxUaW1lKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICBjb25zdCBvdGhlciA9IFRvVGVtcG9yYWxUaW1lKG90aGVyUGFyYW0pO1xuICAgICAgICBjb25zdCBvcHRpb25zID0gR2V0T3B0aW9uc09iamVjdChvcHRpb25zUGFyYW0pO1xuICAgICAgICBjb25zdCBsYXJnZXN0VW5pdCA9IFRvTGFyZ2VzdFRlbXBvcmFsVW5pdChvcHRpb25zLCAnYXV0bycsIERJU0FMTE9XRURfVU5JVFMkMSwgJ2hvdXInKTtcbiAgICAgICAgY29uc3Qgc21hbGxlc3RVbml0ID0gVG9TbWFsbGVzdFRlbXBvcmFsVW5pdChvcHRpb25zLCAnbmFub3NlY29uZCcsIERJU0FMTE9XRURfVU5JVFMkMSk7XG4gICAgICAgIFZhbGlkYXRlVGVtcG9yYWxVbml0UmFuZ2UobGFyZ2VzdFVuaXQsIHNtYWxsZXN0VW5pdCk7XG4gICAgICAgIGNvbnN0IHJvdW5kaW5nTW9kZSA9IFRvVGVtcG9yYWxSb3VuZGluZ01vZGUob3B0aW9ucywgJ3RydW5jJyk7XG4gICAgICAgIGNvbnN0IHJvdW5kaW5nSW5jcmVtZW50ID0gVG9UZW1wb3JhbFJvdW5kaW5nSW5jcmVtZW50KG9wdGlvbnMsIE1BWF9JTkNSRU1FTlRTW3NtYWxsZXN0VW5pdF0sIGZhbHNlKTtcbiAgICAgICAgbGV0IHsgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc2Vjb25kcywgbWljcm9zZWNvbmRzLCBuYW5vc2Vjb25kcyB9ID0gRGlmZmVyZW5jZVRpbWUoR2V0U2xvdChvdGhlciwgSVNPX0hPVVIpLCBHZXRTbG90KG90aGVyLCBJU09fTUlOVVRFKSwgR2V0U2xvdChvdGhlciwgSVNPX1NFQ09ORCksIEdldFNsb3Qob3RoZXIsIElTT19NSUxMSVNFQ09ORCksIEdldFNsb3Qob3RoZXIsIElTT19NSUNST1NFQ09ORCksIEdldFNsb3Qob3RoZXIsIElTT19OQU5PU0VDT05EKSwgR2V0U2xvdCh0aGlzLCBJU09fSE9VUiksIEdldFNsb3QodGhpcywgSVNPX01JTlVURSksIEdldFNsb3QodGhpcywgSVNPX1NFQ09ORCksIEdldFNsb3QodGhpcywgSVNPX01JTExJU0VDT05EKSwgR2V0U2xvdCh0aGlzLCBJU09fTUlDUk9TRUNPTkQpLCBHZXRTbG90KHRoaXMsIElTT19OQU5PU0VDT05EKSk7XG4gICAgICAgICh7IGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBtaWxsaXNlY29uZHMsIG1pY3Jvc2Vjb25kcywgbmFub3NlY29uZHMgfSA9IFJvdW5kRHVyYXRpb24oMCwgMCwgMCwgMCwgLWhvdXJzLCAtbWludXRlcywgLXNlY29uZHMsIC1taWxsaXNlY29uZHMsIC1taWNyb3NlY29uZHMsIC1uYW5vc2Vjb25kcywgcm91bmRpbmdJbmNyZW1lbnQsIHNtYWxsZXN0VW5pdCwgTmVnYXRlVGVtcG9yYWxSb3VuZGluZ01vZGUocm91bmRpbmdNb2RlKSkpO1xuICAgICAgICBob3VycyA9IC1ob3VycztcbiAgICAgICAgbWludXRlcyA9IC1taW51dGVzO1xuICAgICAgICBzZWNvbmRzID0gLXNlY29uZHM7XG4gICAgICAgIG1pbGxpc2Vjb25kcyA9IC1taWxsaXNlY29uZHM7XG4gICAgICAgIG1pY3Jvc2Vjb25kcyA9IC1taWNyb3NlY29uZHM7XG4gICAgICAgIG5hbm9zZWNvbmRzID0gLW5hbm9zZWNvbmRzO1xuICAgICAgICAoeyBob3VycywgbWludXRlcywgc2Vjb25kcywgbWlsbGlzZWNvbmRzLCBtaWNyb3NlY29uZHMsIG5hbm9zZWNvbmRzIH0gPSBCYWxhbmNlRHVyYXRpb24oMCwgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc2Vjb25kcywgbWljcm9zZWNvbmRzLCBuYW5vc2Vjb25kcywgbGFyZ2VzdFVuaXQpKTtcbiAgICAgICAgY29uc3QgRHVyYXRpb24gPSBHZXRJbnRyaW5zaWMoJyVUZW1wb3JhbC5EdXJhdGlvbiUnKTtcbiAgICAgICAgcmV0dXJuIG5ldyBEdXJhdGlvbigwLCAwLCAwLCAwLCBob3VycywgbWludXRlcywgc2Vjb25kcywgbWlsbGlzZWNvbmRzLCBtaWNyb3NlY29uZHMsIG5hbm9zZWNvbmRzKTtcbiAgICB9XG4gICAgcm91bmQob3B0aW9uc1BhcmFtKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbFRpbWUodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIGlmIChvcHRpb25zUGFyYW0gPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ29wdGlvbnMgcGFyYW1ldGVyIGlzIHJlcXVpcmVkJyk7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB0eXBlb2Ygb3B0aW9uc1BhcmFtID09PSAnc3RyaW5nJ1xuICAgICAgICAgICAgPyBDcmVhdGVPbmVQcm9wT2JqZWN0KCdzbWFsbGVzdFVuaXQnLCBvcHRpb25zUGFyYW0pXG4gICAgICAgICAgICA6IEdldE9wdGlvbnNPYmplY3Qob3B0aW9uc1BhcmFtKTtcbiAgICAgICAgY29uc3Qgc21hbGxlc3RVbml0ID0gVG9TbWFsbGVzdFRlbXBvcmFsVW5pdChvcHRpb25zLCB1bmRlZmluZWQsIERJU0FMTE9XRURfVU5JVFMkMSk7XG4gICAgICAgIGlmIChzbWFsbGVzdFVuaXQgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdzbWFsbGVzdFVuaXQgaXMgcmVxdWlyZWQnKTtcbiAgICAgICAgY29uc3Qgcm91bmRpbmdNb2RlID0gVG9UZW1wb3JhbFJvdW5kaW5nTW9kZShvcHRpb25zLCAnaGFsZkV4cGFuZCcpO1xuICAgICAgICBjb25zdCByb3VuZGluZ0luY3JlbWVudCA9IFRvVGVtcG9yYWxSb3VuZGluZ0luY3JlbWVudChvcHRpb25zLCBNQVhfSU5DUkVNRU5UU1tzbWFsbGVzdFVuaXRdLCBmYWxzZSk7XG4gICAgICAgIGxldCBob3VyID0gR2V0U2xvdCh0aGlzLCBJU09fSE9VUik7XG4gICAgICAgIGxldCBtaW51dGUgPSBHZXRTbG90KHRoaXMsIElTT19NSU5VVEUpO1xuICAgICAgICBsZXQgc2Vjb25kID0gR2V0U2xvdCh0aGlzLCBJU09fU0VDT05EKTtcbiAgICAgICAgbGV0IG1pbGxpc2Vjb25kID0gR2V0U2xvdCh0aGlzLCBJU09fTUlMTElTRUNPTkQpO1xuICAgICAgICBsZXQgbWljcm9zZWNvbmQgPSBHZXRTbG90KHRoaXMsIElTT19NSUNST1NFQ09ORCk7XG4gICAgICAgIGxldCBuYW5vc2Vjb25kID0gR2V0U2xvdCh0aGlzLCBJU09fTkFOT1NFQ09ORCk7XG4gICAgICAgICh7IGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZCwgbWljcm9zZWNvbmQsIG5hbm9zZWNvbmQgfSA9IFJvdW5kVGltZShob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQsIG1pY3Jvc2Vjb25kLCBuYW5vc2Vjb25kLCByb3VuZGluZ0luY3JlbWVudCwgc21hbGxlc3RVbml0LCByb3VuZGluZ01vZGUpKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQbGFpblRpbWUoaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kLCBtaWNyb3NlY29uZCwgbmFub3NlY29uZCk7XG4gICAgfVxuICAgIGVxdWFscyhvdGhlclBhcmFtKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbFRpbWUodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIGNvbnN0IG90aGVyID0gVG9UZW1wb3JhbFRpbWUob3RoZXJQYXJhbSk7XG4gICAgICAgIGZvciAoY29uc3Qgc2xvdCBvZiBbSVNPX0hPVVIsIElTT19NSU5VVEUsIElTT19TRUNPTkQsIElTT19NSUxMSVNFQ09ORCwgSVNPX01JQ1JPU0VDT05ELCBJU09fTkFOT1NFQ09ORF0pIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbDEgPSBHZXRTbG90KHRoaXMsIHNsb3QpO1xuICAgICAgICAgICAgY29uc3QgdmFsMiA9IEdldFNsb3Qob3RoZXIsIHNsb3QpO1xuICAgICAgICAgICAgaWYgKHZhbDEgIT09IHZhbDIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICB0b1N0cmluZyhvcHRpb25zUGFyYW0gPSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsVGltZSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IEdldE9wdGlvbnNPYmplY3Qob3B0aW9uc1BhcmFtKTtcbiAgICAgICAgY29uc3QgeyBwcmVjaXNpb24sIHVuaXQsIGluY3JlbWVudCB9ID0gVG9TZWNvbmRzU3RyaW5nUHJlY2lzaW9uKG9wdGlvbnMpO1xuICAgICAgICBjb25zdCByb3VuZGluZ01vZGUgPSBUb1RlbXBvcmFsUm91bmRpbmdNb2RlKG9wdGlvbnMsICd0cnVuYycpO1xuICAgICAgICByZXR1cm4gVGVtcG9yYWxUaW1lVG9TdHJpbmcodGhpcywgcHJlY2lzaW9uLCB7IHVuaXQsIGluY3JlbWVudCwgcm91bmRpbmdNb2RlIH0pO1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbFRpbWUodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIHJldHVybiBUZW1wb3JhbFRpbWVUb1N0cmluZyh0aGlzLCAnYXV0bycpO1xuICAgIH1cbiAgICB0b0xvY2FsZVN0cmluZyhsb2NhbGVzID0gdW5kZWZpbmVkLCBvcHRpb25zID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbFRpbWUodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZVRpbWVGb3JtYXQobG9jYWxlcywgb3B0aW9ucykuZm9ybWF0KHRoaXMpO1xuICAgIH1cbiAgICB2YWx1ZU9mKCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd1c2UgY29tcGFyZSgpIG9yIGVxdWFscygpIHRvIGNvbXBhcmUgVGVtcG9yYWwuUGxhaW5UaW1lJyk7XG4gICAgfVxuICAgIHRvUGxhaW5EYXRlVGltZSh0ZW1wb3JhbERhdGVQYXJhbSkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxUaW1lKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICBjb25zdCB0ZW1wb3JhbERhdGUgPSBUb1RlbXBvcmFsRGF0ZSh0ZW1wb3JhbERhdGVQYXJhbSk7XG4gICAgICAgIGNvbnN0IHllYXIgPSBHZXRTbG90KHRlbXBvcmFsRGF0ZSwgSVNPX1lFQVIpO1xuICAgICAgICBjb25zdCBtb250aCA9IEdldFNsb3QodGVtcG9yYWxEYXRlLCBJU09fTU9OVEgpO1xuICAgICAgICBjb25zdCBkYXkgPSBHZXRTbG90KHRlbXBvcmFsRGF0ZSwgSVNPX0RBWSk7XG4gICAgICAgIGNvbnN0IGNhbGVuZGFyID0gR2V0U2xvdCh0ZW1wb3JhbERhdGUsIENBTEVOREFSKTtcbiAgICAgICAgY29uc3QgaG91ciA9IEdldFNsb3QodGhpcywgSVNPX0hPVVIpO1xuICAgICAgICBjb25zdCBtaW51dGUgPSBHZXRTbG90KHRoaXMsIElTT19NSU5VVEUpO1xuICAgICAgICBjb25zdCBzZWNvbmQgPSBHZXRTbG90KHRoaXMsIElTT19TRUNPTkQpO1xuICAgICAgICBjb25zdCBtaWxsaXNlY29uZCA9IEdldFNsb3QodGhpcywgSVNPX01JTExJU0VDT05EKTtcbiAgICAgICAgY29uc3QgbWljcm9zZWNvbmQgPSBHZXRTbG90KHRoaXMsIElTT19NSUNST1NFQ09ORCk7XG4gICAgICAgIGNvbnN0IG5hbm9zZWNvbmQgPSBHZXRTbG90KHRoaXMsIElTT19OQU5PU0VDT05EKTtcbiAgICAgICAgcmV0dXJuIENyZWF0ZVRlbXBvcmFsRGF0ZVRpbWUoeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kLCBtaWNyb3NlY29uZCwgbmFub3NlY29uZCwgY2FsZW5kYXIpO1xuICAgIH1cbiAgICB0b1pvbmVkRGF0ZVRpbWUoaXRlbSkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxUaW1lKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICBpZiAoIUlzT2JqZWN0KGl0ZW0pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIGFyZ3VtZW50Jyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGF0ZUxpa2UgPSBpdGVtLnBsYWluRGF0ZTtcbiAgICAgICAgaWYgKGRhdGVMaWtlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ21pc3NpbmcgZGF0ZSBwcm9wZXJ0eScpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRlbXBvcmFsRGF0ZSA9IFRvVGVtcG9yYWxEYXRlKGRhdGVMaWtlKTtcbiAgICAgICAgY29uc3QgdGltZVpvbmVMaWtlID0gaXRlbS50aW1lWm9uZTtcbiAgICAgICAgaWYgKHRpbWVab25lTGlrZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdtaXNzaW5nIHRpbWVab25lIHByb3BlcnR5Jyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGltZVpvbmUgPSBUb1RlbXBvcmFsVGltZVpvbmUodGltZVpvbmVMaWtlKTtcbiAgICAgICAgY29uc3QgeWVhciA9IEdldFNsb3QodGVtcG9yYWxEYXRlLCBJU09fWUVBUik7XG4gICAgICAgIGNvbnN0IG1vbnRoID0gR2V0U2xvdCh0ZW1wb3JhbERhdGUsIElTT19NT05USCk7XG4gICAgICAgIGNvbnN0IGRheSA9IEdldFNsb3QodGVtcG9yYWxEYXRlLCBJU09fREFZKTtcbiAgICAgICAgY29uc3QgY2FsZW5kYXIgPSBHZXRTbG90KHRlbXBvcmFsRGF0ZSwgQ0FMRU5EQVIpO1xuICAgICAgICBjb25zdCBob3VyID0gR2V0U2xvdCh0aGlzLCBJU09fSE9VUik7XG4gICAgICAgIGNvbnN0IG1pbnV0ZSA9IEdldFNsb3QodGhpcywgSVNPX01JTlVURSk7XG4gICAgICAgIGNvbnN0IHNlY29uZCA9IEdldFNsb3QodGhpcywgSVNPX1NFQ09ORCk7XG4gICAgICAgIGNvbnN0IG1pbGxpc2Vjb25kID0gR2V0U2xvdCh0aGlzLCBJU09fTUlMTElTRUNPTkQpO1xuICAgICAgICBjb25zdCBtaWNyb3NlY29uZCA9IEdldFNsb3QodGhpcywgSVNPX01JQ1JPU0VDT05EKTtcbiAgICAgICAgY29uc3QgbmFub3NlY29uZCA9IEdldFNsb3QodGhpcywgSVNPX05BTk9TRUNPTkQpO1xuICAgICAgICBjb25zdCBQbGFpbkRhdGVUaW1lID0gR2V0SW50cmluc2ljKCclVGVtcG9yYWwuUGxhaW5EYXRlVGltZSUnKTtcbiAgICAgICAgY29uc3QgZHQgPSBuZXcgUGxhaW5EYXRlVGltZSh5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQsIG1pY3Jvc2Vjb25kLCBuYW5vc2Vjb25kLCBjYWxlbmRhcik7XG4gICAgICAgIGNvbnN0IGluc3RhbnQgPSBCdWlsdGluVGltZVpvbmVHZXRJbnN0YW50Rm9yKHRpbWVab25lLCBkdCwgJ2NvbXBhdGlibGUnKTtcbiAgICAgICAgcmV0dXJuIENyZWF0ZVRlbXBvcmFsWm9uZWREYXRlVGltZShHZXRTbG90KGluc3RhbnQsIEVQT0NITkFOT1NFQ09ORFMpLCB0aW1lWm9uZSwgY2FsZW5kYXIpO1xuICAgIH1cbiAgICBnZXRJU09GaWVsZHMoKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbFRpbWUodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjYWxlbmRhcjogR2V0U2xvdCh0aGlzLCBDQUxFTkRBUiksXG4gICAgICAgICAgICBpc29Ib3VyOiBHZXRTbG90KHRoaXMsIElTT19IT1VSKSxcbiAgICAgICAgICAgIGlzb01pY3Jvc2Vjb25kOiBHZXRTbG90KHRoaXMsIElTT19NSUNST1NFQ09ORCksXG4gICAgICAgICAgICBpc29NaWxsaXNlY29uZDogR2V0U2xvdCh0aGlzLCBJU09fTUlMTElTRUNPTkQpLFxuICAgICAgICAgICAgaXNvTWludXRlOiBHZXRTbG90KHRoaXMsIElTT19NSU5VVEUpLFxuICAgICAgICAgICAgaXNvTmFub3NlY29uZDogR2V0U2xvdCh0aGlzLCBJU09fTkFOT1NFQ09ORCksXG4gICAgICAgICAgICBpc29TZWNvbmQ6IEdldFNsb3QodGhpcywgSVNPX1NFQ09ORClcbiAgICAgICAgfTtcbiAgICB9XG4gICAgc3RhdGljIGZyb20oaXRlbSwgb3B0aW9uc1BhcmFtID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSBHZXRPcHRpb25zT2JqZWN0KG9wdGlvbnNQYXJhbSk7XG4gICAgICAgIGNvbnN0IG92ZXJmbG93ID0gVG9UZW1wb3JhbE92ZXJmbG93KG9wdGlvbnMpO1xuICAgICAgICBpZiAoSXNUZW1wb3JhbFRpbWUoaXRlbSkpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUGxhaW5UaW1lKEdldFNsb3QoaXRlbSwgSVNPX0hPVVIpLCBHZXRTbG90KGl0ZW0sIElTT19NSU5VVEUpLCBHZXRTbG90KGl0ZW0sIElTT19TRUNPTkQpLCBHZXRTbG90KGl0ZW0sIElTT19NSUxMSVNFQ09ORCksIEdldFNsb3QoaXRlbSwgSVNPX01JQ1JPU0VDT05EKSwgR2V0U2xvdChpdGVtLCBJU09fTkFOT1NFQ09ORCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBUb1RlbXBvcmFsVGltZShpdGVtLCBvdmVyZmxvdyk7XG4gICAgfVxuICAgIHN0YXRpYyBjb21wYXJlKG9uZVBhcmFtLCB0d29QYXJhbSkge1xuICAgICAgICBjb25zdCBvbmUgPSBUb1RlbXBvcmFsVGltZShvbmVQYXJhbSk7XG4gICAgICAgIGNvbnN0IHR3byA9IFRvVGVtcG9yYWxUaW1lKHR3b1BhcmFtKTtcbiAgICAgICAgZm9yIChjb25zdCBzbG90IG9mIFtJU09fSE9VUiwgSVNPX01JTlVURSwgSVNPX1NFQ09ORCwgSVNPX01JTExJU0VDT05ELCBJU09fTUlDUk9TRUNPTkQsIElTT19OQU5PU0VDT05EXSkge1xuICAgICAgICAgICAgY29uc3QgdmFsMSA9IEdldFNsb3Qob25lLCBzbG90KTtcbiAgICAgICAgICAgIGNvbnN0IHZhbDIgPSBHZXRTbG90KHR3bywgc2xvdCk7XG4gICAgICAgICAgICBpZiAodmFsMSAhPT0gdmFsMilcbiAgICAgICAgICAgICAgICByZXR1cm4gQ29tcGFyaXNvblJlc3VsdCh2YWwxIC0gdmFsMik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxufVxuTWFrZUludHJpbnNpY0NsYXNzKFBsYWluVGltZSwgJ1RlbXBvcmFsLlBsYWluVGltZScpO1xuXG5jbGFzcyBUaW1lWm9uZSB7XG4gICAgY29uc3RydWN0b3IodGltZVpvbmVJZGVudGlmaWVyUGFyYW0pIHtcbiAgICAgICAgLy8gTm90ZTogaWYgdGhlIGFyZ3VtZW50IGlzIG5vdCBwYXNzZWQsIEdldENhbm9uaWNhbFRpbWVab25lSWRlbnRpZmllcih1bmRlZmluZWQpIHdpbGwgdGhyb3cuXG4gICAgICAgIC8vICAgICAgIFRoaXMgY2hlY2sgZXhpc3RzIG9ubHkgdG8gaW1wcm92ZSB0aGUgZXJyb3IgbWVzc2FnZS5cbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAxKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignbWlzc2luZyBhcmd1bWVudDogaWRlbnRpZmllciBpcyByZXF1aXJlZCcpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRpbWVab25lSWRlbnRpZmllciA9IEdldENhbm9uaWNhbFRpbWVab25lSWRlbnRpZmllcih0aW1lWm9uZUlkZW50aWZpZXJQYXJhbSk7XG4gICAgICAgIENyZWF0ZVNsb3RzKHRoaXMpO1xuICAgICAgICBTZXRTbG90KHRoaXMsIFRJTUVaT05FX0lELCB0aW1lWm9uZUlkZW50aWZpZXIpO1xuICAgICAgICB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ19yZXByXycsIHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogYCR7dGhpc1tTeW1ib2wudG9TdHJpbmdUYWddfSA8JHt0aW1lWm9uZUlkZW50aWZpZXJ9PmAsXG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBpZCgpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsVGltZVpvbmUodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIHJldHVybiBUb1N0cmluZyh0aGlzKTtcbiAgICB9XG4gICAgZ2V0T2Zmc2V0TmFub3NlY29uZHNGb3IoaW5zdGFudFBhcmFtKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbFRpbWVab25lKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICBjb25zdCBpbnN0YW50ID0gVG9UZW1wb3JhbEluc3RhbnQoaW5zdGFudFBhcmFtKTtcbiAgICAgICAgY29uc3QgaWQgPSBHZXRTbG90KHRoaXMsIFRJTUVaT05FX0lEKTtcbiAgICAgICAgaWYgKFRlc3RUaW1lWm9uZU9mZnNldFN0cmluZyhpZCkpIHtcbiAgICAgICAgICAgIHJldHVybiBQYXJzZVRpbWVab25lT2Zmc2V0U3RyaW5nKGlkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gR2V0SUFOQVRpbWVab25lT2Zmc2V0TmFub3NlY29uZHMoR2V0U2xvdChpbnN0YW50LCBFUE9DSE5BTk9TRUNPTkRTKSwgaWQpO1xuICAgIH1cbiAgICBnZXRPZmZzZXRTdHJpbmdGb3IoaW5zdGFudFBhcmFtKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbFRpbWVab25lKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICBjb25zdCBpbnN0YW50ID0gVG9UZW1wb3JhbEluc3RhbnQoaW5zdGFudFBhcmFtKTtcbiAgICAgICAgcmV0dXJuIEJ1aWx0aW5UaW1lWm9uZUdldE9mZnNldFN0cmluZ0Zvcih0aGlzLCBpbnN0YW50KTtcbiAgICB9XG4gICAgZ2V0UGxhaW5EYXRlVGltZUZvcihpbnN0YW50UGFyYW0sIGNhbGVuZGFyUGFyYW0gPSBHZXRJU084NjAxQ2FsZW5kYXIoKSkge1xuICAgICAgICBjb25zdCBpbnN0YW50ID0gVG9UZW1wb3JhbEluc3RhbnQoaW5zdGFudFBhcmFtKTtcbiAgICAgICAgY29uc3QgY2FsZW5kYXIgPSBUb1RlbXBvcmFsQ2FsZW5kYXIoY2FsZW5kYXJQYXJhbSk7XG4gICAgICAgIHJldHVybiBCdWlsdGluVGltZVpvbmVHZXRQbGFpbkRhdGVUaW1lRm9yKHRoaXMsIGluc3RhbnQsIGNhbGVuZGFyKTtcbiAgICB9XG4gICAgZ2V0SW5zdGFudEZvcihkYXRlVGltZVBhcmFtLCBvcHRpb25zUGFyYW0gPSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsVGltZVpvbmUodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIGNvbnN0IGRhdGVUaW1lID0gVG9UZW1wb3JhbERhdGVUaW1lKGRhdGVUaW1lUGFyYW0pO1xuICAgICAgICBjb25zdCBvcHRpb25zID0gR2V0T3B0aW9uc09iamVjdChvcHRpb25zUGFyYW0pO1xuICAgICAgICBjb25zdCBkaXNhbWJpZ3VhdGlvbiA9IFRvVGVtcG9yYWxEaXNhbWJpZ3VhdGlvbihvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIEJ1aWx0aW5UaW1lWm9uZUdldEluc3RhbnRGb3IodGhpcywgZGF0ZVRpbWUsIGRpc2FtYmlndWF0aW9uKTtcbiAgICB9XG4gICAgZ2V0UG9zc2libGVJbnN0YW50c0ZvcihkYXRlVGltZVBhcmFtKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbFRpbWVab25lKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICBjb25zdCBkYXRlVGltZSA9IFRvVGVtcG9yYWxEYXRlVGltZShkYXRlVGltZVBhcmFtKTtcbiAgICAgICAgY29uc3QgSW5zdGFudCA9IEdldEludHJpbnNpYygnJVRlbXBvcmFsLkluc3RhbnQlJyk7XG4gICAgICAgIGNvbnN0IGlkID0gR2V0U2xvdCh0aGlzLCBUSU1FWk9ORV9JRCk7XG4gICAgICAgIGlmIChUZXN0VGltZVpvbmVPZmZzZXRTdHJpbmcoaWQpKSB7XG4gICAgICAgICAgICBjb25zdCBlcG9jaE5zID0gR2V0RXBvY2hGcm9tSVNPUGFydHMoR2V0U2xvdChkYXRlVGltZSwgSVNPX1lFQVIpLCBHZXRTbG90KGRhdGVUaW1lLCBJU09fTU9OVEgpLCBHZXRTbG90KGRhdGVUaW1lLCBJU09fREFZKSwgR2V0U2xvdChkYXRlVGltZSwgSVNPX0hPVVIpLCBHZXRTbG90KGRhdGVUaW1lLCBJU09fTUlOVVRFKSwgR2V0U2xvdChkYXRlVGltZSwgSVNPX1NFQ09ORCksIEdldFNsb3QoZGF0ZVRpbWUsIElTT19NSUxMSVNFQ09ORCksIEdldFNsb3QoZGF0ZVRpbWUsIElTT19NSUNST1NFQ09ORCksIEdldFNsb3QoZGF0ZVRpbWUsIElTT19OQU5PU0VDT05EKSk7XG4gICAgICAgICAgICBpZiAoZXBvY2hOcyA9PT0gbnVsbClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignRGF0ZVRpbWUgb3V0c2lkZSBvZiBzdXBwb3J0ZWQgcmFuZ2UnKTtcbiAgICAgICAgICAgIGNvbnN0IG9mZnNldE5zID0gUGFyc2VUaW1lWm9uZU9mZnNldFN0cmluZyhpZCk7XG4gICAgICAgICAgICByZXR1cm4gW25ldyBJbnN0YW50KEpTQkkuc3VidHJhY3QoZXBvY2hOcywgSlNCSS5CaWdJbnQob2Zmc2V0TnMpKSldO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBvc3NpYmxlRXBvY2hOcyA9IEdldElBTkFUaW1lWm9uZUVwb2NoVmFsdWUoaWQsIEdldFNsb3QoZGF0ZVRpbWUsIElTT19ZRUFSKSwgR2V0U2xvdChkYXRlVGltZSwgSVNPX01PTlRIKSwgR2V0U2xvdChkYXRlVGltZSwgSVNPX0RBWSksIEdldFNsb3QoZGF0ZVRpbWUsIElTT19IT1VSKSwgR2V0U2xvdChkYXRlVGltZSwgSVNPX01JTlVURSksIEdldFNsb3QoZGF0ZVRpbWUsIElTT19TRUNPTkQpLCBHZXRTbG90KGRhdGVUaW1lLCBJU09fTUlMTElTRUNPTkQpLCBHZXRTbG90KGRhdGVUaW1lLCBJU09fTUlDUk9TRUNPTkQpLCBHZXRTbG90KGRhdGVUaW1lLCBJU09fTkFOT1NFQ09ORCkpO1xuICAgICAgICByZXR1cm4gcG9zc2libGVFcG9jaE5zLm1hcCgobnMpID0+IG5ldyBJbnN0YW50KG5zKSk7XG4gICAgfVxuICAgIGdldE5leHRUcmFuc2l0aW9uKHN0YXJ0aW5nUG9pbnRQYXJhbSkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxUaW1lWm9uZSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgY29uc3Qgc3RhcnRpbmdQb2ludCA9IFRvVGVtcG9yYWxJbnN0YW50KHN0YXJ0aW5nUG9pbnRQYXJhbSk7XG4gICAgICAgIGNvbnN0IGlkID0gR2V0U2xvdCh0aGlzLCBUSU1FWk9ORV9JRCk7XG4gICAgICAgIC8vIE9mZnNldCB0aW1lIHpvbmVzIG9yIFVUQyBoYXZlIG5vIHRyYW5zaXRpb25zXG4gICAgICAgIGlmIChUZXN0VGltZVpvbmVPZmZzZXRTdHJpbmcoaWQpIHx8IGlkID09PSAnVVRDJykge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGVwb2NoTmFub3NlY29uZHMgPSBHZXRTbG90KHN0YXJ0aW5nUG9pbnQsIEVQT0NITkFOT1NFQ09ORFMpO1xuICAgICAgICBjb25zdCBJbnN0YW50ID0gR2V0SW50cmluc2ljKCclVGVtcG9yYWwuSW5zdGFudCUnKTtcbiAgICAgICAgZXBvY2hOYW5vc2Vjb25kcyA9IEdldElBTkFUaW1lWm9uZU5leHRUcmFuc2l0aW9uKGVwb2NoTmFub3NlY29uZHMsIGlkKTtcbiAgICAgICAgcmV0dXJuIGVwb2NoTmFub3NlY29uZHMgPT09IG51bGwgPyBudWxsIDogbmV3IEluc3RhbnQoZXBvY2hOYW5vc2Vjb25kcyk7XG4gICAgfVxuICAgIGdldFByZXZpb3VzVHJhbnNpdGlvbihzdGFydGluZ1BvaW50UGFyYW0pIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsVGltZVpvbmUodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIGNvbnN0IHN0YXJ0aW5nUG9pbnQgPSBUb1RlbXBvcmFsSW5zdGFudChzdGFydGluZ1BvaW50UGFyYW0pO1xuICAgICAgICBjb25zdCBpZCA9IEdldFNsb3QodGhpcywgVElNRVpPTkVfSUQpO1xuICAgICAgICAvLyBPZmZzZXQgdGltZSB6b25lcyBvciBVVEMgaGF2ZSBubyB0cmFuc2l0aW9uc1xuICAgICAgICBpZiAoVGVzdFRpbWVab25lT2Zmc2V0U3RyaW5nKGlkKSB8fCBpZCA9PT0gJ1VUQycpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGxldCBlcG9jaE5hbm9zZWNvbmRzID0gR2V0U2xvdChzdGFydGluZ1BvaW50LCBFUE9DSE5BTk9TRUNPTkRTKTtcbiAgICAgICAgY29uc3QgSW5zdGFudCA9IEdldEludHJpbnNpYygnJVRlbXBvcmFsLkluc3RhbnQlJyk7XG4gICAgICAgIGVwb2NoTmFub3NlY29uZHMgPSBHZXRJQU5BVGltZVpvbmVQcmV2aW91c1RyYW5zaXRpb24oZXBvY2hOYW5vc2Vjb25kcywgaWQpO1xuICAgICAgICByZXR1cm4gZXBvY2hOYW5vc2Vjb25kcyA9PT0gbnVsbCA/IG51bGwgOiBuZXcgSW5zdGFudChlcG9jaE5hbm9zZWNvbmRzKTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbFRpbWVab25lKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICByZXR1cm4gVG9TdHJpbmcoR2V0U2xvdCh0aGlzLCBUSU1FWk9ORV9JRCkpO1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbFRpbWVab25lKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICByZXR1cm4gVG9TdHJpbmcodGhpcyk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tKGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIFRvVGVtcG9yYWxUaW1lWm9uZShpdGVtKTtcbiAgICB9XG59XG5NYWtlSW50cmluc2ljQ2xhc3MoVGltZVpvbmUsICdUZW1wb3JhbC5UaW1lWm9uZScpO1xuXG5jb25zdCBPYmplY3RDcmVhdGUgPSBPYmplY3QuY3JlYXRlO1xuY29uc3QgRElTQUxMT1dFRF9VTklUUyA9IFtcbiAgICAnd2VlaycsXG4gICAgJ2RheScsXG4gICAgJ2hvdXInLFxuICAgICdtaW51dGUnLFxuICAgICdzZWNvbmQnLFxuICAgICdtaWxsaXNlY29uZCcsXG4gICAgJ21pY3Jvc2Vjb25kJyxcbiAgICAnbmFub3NlY29uZCdcbl07XG5jbGFzcyBQbGFpblllYXJNb250aCB7XG4gICAgY29uc3RydWN0b3IoaXNvWWVhclBhcmFtLCBpc29Nb250aFBhcmFtLCBjYWxlbmRhclBhcmFtID0gR2V0SVNPODYwMUNhbGVuZGFyKCksIHJlZmVyZW5jZUlTT0RheVBhcmFtID0gMSkge1xuICAgICAgICBjb25zdCBpc29ZZWFyID0gVG9JbnRlZ2VyVGhyb3dPbkluZmluaXR5KGlzb1llYXJQYXJhbSk7XG4gICAgICAgIGNvbnN0IGlzb01vbnRoID0gVG9JbnRlZ2VyVGhyb3dPbkluZmluaXR5KGlzb01vbnRoUGFyYW0pO1xuICAgICAgICBjb25zdCBjYWxlbmRhciA9IFRvVGVtcG9yYWxDYWxlbmRhcihjYWxlbmRhclBhcmFtKTtcbiAgICAgICAgY29uc3QgcmVmZXJlbmNlSVNPRGF5ID0gVG9JbnRlZ2VyVGhyb3dPbkluZmluaXR5KHJlZmVyZW5jZUlTT0RheVBhcmFtKTtcbiAgICAgICAgLy8gTm90ZTogaWYgdGhlIGFyZ3VtZW50cyBhcmUgbm90IHBhc3NlZCxcbiAgICAgICAgLy8gICAgICAgVG9JbnRlZ2VyVGhyb3dPbkluZmluaXR5KHVuZGVmaW5lZCkgd2lsbCBoYXZlIHJldHVybmVkIDAsIHdoaWNoIHdpbGxcbiAgICAgICAgLy8gICAgICAgYmUgcmVqZWN0ZWQgYnkgUmVqZWN0SVNPRGF0ZSBpbiBDcmVhdGVUZW1wb3JhbFllYXJNb250aFNsb3RzLiBUaGlzXG4gICAgICAgIC8vICAgICAgIGNoZWNrIGV4aXN0cyBvbmx5IHRvIGltcHJvdmUgdGhlIGVycm9yIG1lc3NhZ2UuXG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ21pc3NpbmcgYXJndW1lbnQ6IGlzb1llYXIgYW5kIGlzb01vbnRoIGFyZSByZXF1aXJlZCcpO1xuICAgICAgICB9XG4gICAgICAgIENyZWF0ZVRlbXBvcmFsWWVhck1vbnRoU2xvdHModGhpcywgaXNvWWVhciwgaXNvTW9udGgsIGNhbGVuZGFyLCByZWZlcmVuY2VJU09EYXkpO1xuICAgIH1cbiAgICBnZXQgeWVhcigpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsWWVhck1vbnRoKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICByZXR1cm4gQ2FsZW5kYXJZZWFyKEdldFNsb3QodGhpcywgQ0FMRU5EQVIpLCB0aGlzKTtcbiAgICB9XG4gICAgZ2V0IG1vbnRoKCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxZZWFyTW9udGgodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIHJldHVybiBDYWxlbmRhck1vbnRoKEdldFNsb3QodGhpcywgQ0FMRU5EQVIpLCB0aGlzKTtcbiAgICB9XG4gICAgZ2V0IG1vbnRoQ29kZSgpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsWWVhck1vbnRoKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICByZXR1cm4gQ2FsZW5kYXJNb250aENvZGUoR2V0U2xvdCh0aGlzLCBDQUxFTkRBUiksIHRoaXMpO1xuICAgIH1cbiAgICBnZXQgY2FsZW5kYXIoKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbFllYXJNb250aCh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgcmV0dXJuIEdldFNsb3QodGhpcywgQ0FMRU5EQVIpO1xuICAgIH1cbiAgICBnZXQgZXJhKCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxZZWFyTW9udGgodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIHJldHVybiBDYWxlbmRhckVyYShHZXRTbG90KHRoaXMsIENBTEVOREFSKSwgdGhpcyk7XG4gICAgfVxuICAgIGdldCBlcmFZZWFyKCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxZZWFyTW9udGgodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIHJldHVybiBDYWxlbmRhckVyYVllYXIoR2V0U2xvdCh0aGlzLCBDQUxFTkRBUiksIHRoaXMpO1xuICAgIH1cbiAgICBnZXQgZGF5c0luTW9udGgoKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbFllYXJNb250aCh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgcmV0dXJuIENhbGVuZGFyRGF5c0luTW9udGgoR2V0U2xvdCh0aGlzLCBDQUxFTkRBUiksIHRoaXMpO1xuICAgIH1cbiAgICBnZXQgZGF5c0luWWVhcigpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsWWVhck1vbnRoKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICByZXR1cm4gQ2FsZW5kYXJEYXlzSW5ZZWFyKEdldFNsb3QodGhpcywgQ0FMRU5EQVIpLCB0aGlzKTtcbiAgICB9XG4gICAgZ2V0IG1vbnRoc0luWWVhcigpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsWWVhck1vbnRoKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICByZXR1cm4gQ2FsZW5kYXJNb250aHNJblllYXIoR2V0U2xvdCh0aGlzLCBDQUxFTkRBUiksIHRoaXMpO1xuICAgIH1cbiAgICBnZXQgaW5MZWFwWWVhcigpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsWWVhck1vbnRoKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICByZXR1cm4gQ2FsZW5kYXJJbkxlYXBZZWFyKEdldFNsb3QodGhpcywgQ0FMRU5EQVIpLCB0aGlzKTtcbiAgICB9XG4gICAgd2l0aCh0ZW1wb3JhbFllYXJNb250aExpa2UsIG9wdGlvbnNQYXJhbSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxZZWFyTW9udGgodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIGlmICghSXNPYmplY3QodGVtcG9yYWxZZWFyTW9udGhMaWtlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBhcmd1bWVudCcpO1xuICAgICAgICB9XG4gICAgICAgIFJlamVjdE9iamVjdFdpdGhDYWxlbmRhck9yVGltZVpvbmUodGVtcG9yYWxZZWFyTW9udGhMaWtlKTtcbiAgICAgICAgY29uc3QgY2FsZW5kYXIgPSBHZXRTbG90KHRoaXMsIENBTEVOREFSKTtcbiAgICAgICAgY29uc3QgZmllbGROYW1lcyA9IENhbGVuZGFyRmllbGRzKGNhbGVuZGFyLCBbJ21vbnRoJywgJ21vbnRoQ29kZScsICd5ZWFyJ10pO1xuICAgICAgICBjb25zdCBwcm9wcyA9IFRvUGFydGlhbFJlY29yZCh0ZW1wb3JhbFllYXJNb250aExpa2UsIGZpZWxkTmFtZXMpO1xuICAgICAgICBpZiAoIXByb3BzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHllYXItbW9udGgtbGlrZScpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBmaWVsZHMgPSBUb1RlbXBvcmFsWWVhck1vbnRoRmllbGRzKHRoaXMsIGZpZWxkTmFtZXMpO1xuICAgICAgICBmaWVsZHMgPSBDYWxlbmRhck1lcmdlRmllbGRzKGNhbGVuZGFyLCBmaWVsZHMsIHByb3BzKTtcbiAgICAgICAgZmllbGRzID0gVG9UZW1wb3JhbFllYXJNb250aEZpZWxkcyhmaWVsZHMsIGZpZWxkTmFtZXMpO1xuICAgICAgICBjb25zdCBvcHRpb25zID0gR2V0T3B0aW9uc09iamVjdChvcHRpb25zUGFyYW0pO1xuICAgICAgICByZXR1cm4gWWVhck1vbnRoRnJvbUZpZWxkcyhjYWxlbmRhciwgZmllbGRzLCBvcHRpb25zKTtcbiAgICB9XG4gICAgYWRkKHRlbXBvcmFsRHVyYXRpb25MaWtlLCBvcHRpb25zUGFyYW0gPSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsWWVhck1vbnRoKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICBjb25zdCBkdXJhdGlvbiA9IFRvTGltaXRlZFRlbXBvcmFsRHVyYXRpb24odGVtcG9yYWxEdXJhdGlvbkxpa2UpO1xuICAgICAgICBsZXQgeyB5ZWFycywgbW9udGhzLCB3ZWVrcywgZGF5cywgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc2Vjb25kcywgbWljcm9zZWNvbmRzLCBuYW5vc2Vjb25kcyB9ID0gZHVyYXRpb247XG4gICAgICAgICh7IGRheXMgfSA9IEJhbGFuY2VEdXJhdGlvbihkYXlzLCBob3VycywgbWludXRlcywgc2Vjb25kcywgbWlsbGlzZWNvbmRzLCBtaWNyb3NlY29uZHMsIG5hbm9zZWNvbmRzLCAnZGF5JykpO1xuICAgICAgICBjb25zdCBvcHRpb25zID0gR2V0T3B0aW9uc09iamVjdChvcHRpb25zUGFyYW0pO1xuICAgICAgICBjb25zdCBjYWxlbmRhciA9IEdldFNsb3QodGhpcywgQ0FMRU5EQVIpO1xuICAgICAgICBjb25zdCBmaWVsZE5hbWVzID0gQ2FsZW5kYXJGaWVsZHMoY2FsZW5kYXIsIFsnbW9udGhDb2RlJywgJ3llYXInXSk7XG4gICAgICAgIGNvbnN0IGZpZWxkcyA9IFRvVGVtcG9yYWxZZWFyTW9udGhGaWVsZHModGhpcywgZmllbGROYW1lcyk7XG4gICAgICAgIGNvbnN0IHNpZ24gPSBEdXJhdGlvblNpZ24oeWVhcnMsIG1vbnRocywgd2Vla3MsIGRheXMsIDAsIDAsIDAsIDAsIDAsIDApO1xuICAgICAgICBjb25zdCBkYXkgPSBzaWduIDwgMCA/IFRvUG9zaXRpdmVJbnRlZ2VyKENhbGVuZGFyRGF5c0luTW9udGgoY2FsZW5kYXIsIHRoaXMpKSA6IDE7XG4gICAgICAgIGNvbnN0IHN0YXJ0RGF0ZSA9IERhdGVGcm9tRmllbGRzKGNhbGVuZGFyLCB7IC4uLmZpZWxkcywgZGF5IH0pO1xuICAgICAgICBjb25zdCBvcHRpb25zQ29weSA9IHsgLi4ub3B0aW9ucyB9O1xuICAgICAgICBjb25zdCBhZGRlZERhdGUgPSBDYWxlbmRhckRhdGVBZGQoY2FsZW5kYXIsIHN0YXJ0RGF0ZSwgeyAuLi5kdXJhdGlvbiwgZGF5cyB9LCBvcHRpb25zKTtcbiAgICAgICAgY29uc3QgYWRkZWREYXRlRmllbGRzID0gVG9UZW1wb3JhbFllYXJNb250aEZpZWxkcyhhZGRlZERhdGUsIGZpZWxkTmFtZXMpO1xuICAgICAgICByZXR1cm4gWWVhck1vbnRoRnJvbUZpZWxkcyhjYWxlbmRhciwgYWRkZWREYXRlRmllbGRzLCBvcHRpb25zQ29weSk7XG4gICAgfVxuICAgIHN1YnRyYWN0KHRlbXBvcmFsRHVyYXRpb25MaWtlLCBvcHRpb25zUGFyYW0gPSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsWWVhck1vbnRoKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICBsZXQgZHVyYXRpb24gPSBUb0xpbWl0ZWRUZW1wb3JhbER1cmF0aW9uKHRlbXBvcmFsRHVyYXRpb25MaWtlKTtcbiAgICAgICAgZHVyYXRpb24gPSB7XG4gICAgICAgICAgICB5ZWFyczogLWR1cmF0aW9uLnllYXJzLFxuICAgICAgICAgICAgbW9udGhzOiAtZHVyYXRpb24ubW9udGhzLFxuICAgICAgICAgICAgd2Vla3M6IC1kdXJhdGlvbi53ZWVrcyxcbiAgICAgICAgICAgIGRheXM6IC1kdXJhdGlvbi5kYXlzLFxuICAgICAgICAgICAgaG91cnM6IC1kdXJhdGlvbi5ob3VycyxcbiAgICAgICAgICAgIG1pbnV0ZXM6IC1kdXJhdGlvbi5taW51dGVzLFxuICAgICAgICAgICAgc2Vjb25kczogLWR1cmF0aW9uLnNlY29uZHMsXG4gICAgICAgICAgICBtaWxsaXNlY29uZHM6IC1kdXJhdGlvbi5taWxsaXNlY29uZHMsXG4gICAgICAgICAgICBtaWNyb3NlY29uZHM6IC1kdXJhdGlvbi5taWNyb3NlY29uZHMsXG4gICAgICAgICAgICBuYW5vc2Vjb25kczogLWR1cmF0aW9uLm5hbm9zZWNvbmRzXG4gICAgICAgIH07XG4gICAgICAgIGxldCB7IHllYXJzLCBtb250aHMsIHdlZWtzLCBkYXlzLCBob3VycywgbWludXRlcywgc2Vjb25kcywgbWlsbGlzZWNvbmRzLCBtaWNyb3NlY29uZHMsIG5hbm9zZWNvbmRzIH0gPSBkdXJhdGlvbjtcbiAgICAgICAgKHsgZGF5cyB9ID0gQmFsYW5jZUR1cmF0aW9uKGRheXMsIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBtaWxsaXNlY29uZHMsIG1pY3Jvc2Vjb25kcywgbmFub3NlY29uZHMsICdkYXknKSk7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSBHZXRPcHRpb25zT2JqZWN0KG9wdGlvbnNQYXJhbSk7XG4gICAgICAgIGNvbnN0IGNhbGVuZGFyID0gR2V0U2xvdCh0aGlzLCBDQUxFTkRBUik7XG4gICAgICAgIGNvbnN0IGZpZWxkTmFtZXMgPSBDYWxlbmRhckZpZWxkcyhjYWxlbmRhciwgWydtb250aENvZGUnLCAneWVhciddKTtcbiAgICAgICAgY29uc3QgZmllbGRzID0gVG9UZW1wb3JhbFllYXJNb250aEZpZWxkcyh0aGlzLCBmaWVsZE5hbWVzKTtcbiAgICAgICAgY29uc3Qgc2lnbiA9IER1cmF0aW9uU2lnbih5ZWFycywgbW9udGhzLCB3ZWVrcywgZGF5cywgMCwgMCwgMCwgMCwgMCwgMCk7XG4gICAgICAgIGNvbnN0IGRheSA9IHNpZ24gPCAwID8gVG9Qb3NpdGl2ZUludGVnZXIoQ2FsZW5kYXJEYXlzSW5Nb250aChjYWxlbmRhciwgdGhpcykpIDogMTtcbiAgICAgICAgY29uc3Qgc3RhcnREYXRlID0gRGF0ZUZyb21GaWVsZHMoY2FsZW5kYXIsIHsgLi4uZmllbGRzLCBkYXkgfSk7XG4gICAgICAgIGNvbnN0IG9wdGlvbnNDb3B5ID0geyAuLi5vcHRpb25zIH07XG4gICAgICAgIGNvbnN0IGFkZGVkRGF0ZSA9IENhbGVuZGFyRGF0ZUFkZChjYWxlbmRhciwgc3RhcnREYXRlLCB7IC4uLmR1cmF0aW9uLCBkYXlzIH0sIG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBhZGRlZERhdGVGaWVsZHMgPSBUb1RlbXBvcmFsWWVhck1vbnRoRmllbGRzKGFkZGVkRGF0ZSwgZmllbGROYW1lcyk7XG4gICAgICAgIHJldHVybiBZZWFyTW9udGhGcm9tRmllbGRzKGNhbGVuZGFyLCBhZGRlZERhdGVGaWVsZHMsIG9wdGlvbnNDb3B5KTtcbiAgICB9XG4gICAgdW50aWwob3RoZXJQYXJhbSwgb3B0aW9uc1BhcmFtID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbFllYXJNb250aCh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgY29uc3Qgb3RoZXIgPSBUb1RlbXBvcmFsWWVhck1vbnRoKG90aGVyUGFyYW0pO1xuICAgICAgICBjb25zdCBjYWxlbmRhciA9IEdldFNsb3QodGhpcywgQ0FMRU5EQVIpO1xuICAgICAgICBjb25zdCBvdGhlckNhbGVuZGFyID0gR2V0U2xvdChvdGhlciwgQ0FMRU5EQVIpO1xuICAgICAgICBjb25zdCBjYWxlbmRhcklEID0gVG9TdHJpbmcoY2FsZW5kYXIpO1xuICAgICAgICBjb25zdCBvdGhlckNhbGVuZGFySUQgPSBUb1N0cmluZyhvdGhlckNhbGVuZGFyKTtcbiAgICAgICAgaWYgKGNhbGVuZGFySUQgIT09IG90aGVyQ2FsZW5kYXJJRCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYGNhbm5vdCBjb21wdXRlIGRpZmZlcmVuY2UgYmV0d2VlbiBtb250aHMgb2YgJHtjYWxlbmRhcklEfSBhbmQgJHtvdGhlckNhbGVuZGFySUR9IGNhbGVuZGFyc2ApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSBHZXRPcHRpb25zT2JqZWN0KG9wdGlvbnNQYXJhbSk7XG4gICAgICAgIGNvbnN0IHNtYWxsZXN0VW5pdCA9IFRvU21hbGxlc3RUZW1wb3JhbFVuaXQob3B0aW9ucywgJ21vbnRoJywgRElTQUxMT1dFRF9VTklUUyk7XG4gICAgICAgIGNvbnN0IGxhcmdlc3RVbml0ID0gVG9MYXJnZXN0VGVtcG9yYWxVbml0KG9wdGlvbnMsICdhdXRvJywgRElTQUxMT1dFRF9VTklUUywgJ3llYXInKTtcbiAgICAgICAgVmFsaWRhdGVUZW1wb3JhbFVuaXRSYW5nZShsYXJnZXN0VW5pdCwgc21hbGxlc3RVbml0KTtcbiAgICAgICAgY29uc3Qgcm91bmRpbmdNb2RlID0gVG9UZW1wb3JhbFJvdW5kaW5nTW9kZShvcHRpb25zLCAndHJ1bmMnKTtcbiAgICAgICAgY29uc3Qgcm91bmRpbmdJbmNyZW1lbnQgPSBUb1RlbXBvcmFsUm91bmRpbmdJbmNyZW1lbnQob3B0aW9ucywgdW5kZWZpbmVkLCBmYWxzZSk7XG4gICAgICAgIGNvbnN0IGZpZWxkTmFtZXMgPSBDYWxlbmRhckZpZWxkcyhjYWxlbmRhciwgWydtb250aENvZGUnLCAneWVhciddKTtcbiAgICAgICAgY29uc3Qgb3RoZXJGaWVsZHMgPSBUb1RlbXBvcmFsWWVhck1vbnRoRmllbGRzKG90aGVyLCBmaWVsZE5hbWVzKTtcbiAgICAgICAgY29uc3QgdGhpc0ZpZWxkcyA9IFRvVGVtcG9yYWxZZWFyTW9udGhGaWVsZHModGhpcywgZmllbGROYW1lcyk7XG4gICAgICAgIGNvbnN0IG90aGVyRGF0ZSA9IERhdGVGcm9tRmllbGRzKGNhbGVuZGFyLCB7IC4uLm90aGVyRmllbGRzLCBkYXk6IDEgfSk7XG4gICAgICAgIGNvbnN0IHRoaXNEYXRlID0gRGF0ZUZyb21GaWVsZHMoY2FsZW5kYXIsIHsgLi4udGhpc0ZpZWxkcywgZGF5OiAxIH0pO1xuICAgICAgICBjb25zdCB1bnRpbE9wdGlvbnMgPSB7IC4uLm9wdGlvbnMsIGxhcmdlc3RVbml0IH07XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IENhbGVuZGFyRGF0ZVVudGlsKGNhbGVuZGFyLCB0aGlzRGF0ZSwgb3RoZXJEYXRlLCB1bnRpbE9wdGlvbnMpO1xuICAgICAgICBpZiAoc21hbGxlc3RVbml0ID09PSAnbW9udGgnICYmIHJvdW5kaW5nSW5jcmVtZW50ID09PSAxKVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgbGV0IHsgeWVhcnMsIG1vbnRocyB9ID0gcmVzdWx0O1xuICAgICAgICAoeyB5ZWFycywgbW9udGhzIH0gPSBSb3VuZER1cmF0aW9uKHllYXJzLCBtb250aHMsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIHJvdW5kaW5nSW5jcmVtZW50LCBzbWFsbGVzdFVuaXQsIHJvdW5kaW5nTW9kZSwgdGhpc0RhdGUpKTtcbiAgICAgICAgY29uc3QgRHVyYXRpb24gPSBHZXRJbnRyaW5zaWMoJyVUZW1wb3JhbC5EdXJhdGlvbiUnKTtcbiAgICAgICAgcmV0dXJuIG5ldyBEdXJhdGlvbih5ZWFycywgbW9udGhzLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwKTtcbiAgICB9XG4gICAgc2luY2Uob3RoZXJQYXJhbSwgb3B0aW9uc1BhcmFtID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbFllYXJNb250aCh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgY29uc3Qgb3RoZXIgPSBUb1RlbXBvcmFsWWVhck1vbnRoKG90aGVyUGFyYW0pO1xuICAgICAgICBjb25zdCBjYWxlbmRhciA9IEdldFNsb3QodGhpcywgQ0FMRU5EQVIpO1xuICAgICAgICBjb25zdCBvdGhlckNhbGVuZGFyID0gR2V0U2xvdChvdGhlciwgQ0FMRU5EQVIpO1xuICAgICAgICBjb25zdCBjYWxlbmRhcklEID0gVG9TdHJpbmcoY2FsZW5kYXIpO1xuICAgICAgICBjb25zdCBvdGhlckNhbGVuZGFySUQgPSBUb1N0cmluZyhvdGhlckNhbGVuZGFyKTtcbiAgICAgICAgaWYgKGNhbGVuZGFySUQgIT09IG90aGVyQ2FsZW5kYXJJRCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYGNhbm5vdCBjb21wdXRlIGRpZmZlcmVuY2UgYmV0d2VlbiBtb250aHMgb2YgJHtjYWxlbmRhcklEfSBhbmQgJHtvdGhlckNhbGVuZGFySUR9IGNhbGVuZGFyc2ApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSBHZXRPcHRpb25zT2JqZWN0KG9wdGlvbnNQYXJhbSk7XG4gICAgICAgIGNvbnN0IHNtYWxsZXN0VW5pdCA9IFRvU21hbGxlc3RUZW1wb3JhbFVuaXQob3B0aW9ucywgJ21vbnRoJywgRElTQUxMT1dFRF9VTklUUyk7XG4gICAgICAgIGNvbnN0IGxhcmdlc3RVbml0ID0gVG9MYXJnZXN0VGVtcG9yYWxVbml0KG9wdGlvbnMsICdhdXRvJywgRElTQUxMT1dFRF9VTklUUywgJ3llYXInKTtcbiAgICAgICAgVmFsaWRhdGVUZW1wb3JhbFVuaXRSYW5nZShsYXJnZXN0VW5pdCwgc21hbGxlc3RVbml0KTtcbiAgICAgICAgY29uc3Qgcm91bmRpbmdNb2RlID0gVG9UZW1wb3JhbFJvdW5kaW5nTW9kZShvcHRpb25zLCAndHJ1bmMnKTtcbiAgICAgICAgY29uc3Qgcm91bmRpbmdJbmNyZW1lbnQgPSBUb1RlbXBvcmFsUm91bmRpbmdJbmNyZW1lbnQob3B0aW9ucywgdW5kZWZpbmVkLCBmYWxzZSk7XG4gICAgICAgIGNvbnN0IGZpZWxkTmFtZXMgPSBDYWxlbmRhckZpZWxkcyhjYWxlbmRhciwgWydtb250aENvZGUnLCAneWVhciddKTtcbiAgICAgICAgY29uc3Qgb3RoZXJGaWVsZHMgPSBUb1RlbXBvcmFsWWVhck1vbnRoRmllbGRzKG90aGVyLCBmaWVsZE5hbWVzKTtcbiAgICAgICAgY29uc3QgdGhpc0ZpZWxkcyA9IFRvVGVtcG9yYWxZZWFyTW9udGhGaWVsZHModGhpcywgZmllbGROYW1lcyk7XG4gICAgICAgIGNvbnN0IG90aGVyRGF0ZSA9IERhdGVGcm9tRmllbGRzKGNhbGVuZGFyLCB7IC4uLm90aGVyRmllbGRzLCBkYXk6IDEgfSk7XG4gICAgICAgIGNvbnN0IHRoaXNEYXRlID0gRGF0ZUZyb21GaWVsZHMoY2FsZW5kYXIsIHsgLi4udGhpc0ZpZWxkcywgZGF5OiAxIH0pO1xuICAgICAgICBjb25zdCB1bnRpbE9wdGlvbnMgPSB7IC4uLm9wdGlvbnMsIGxhcmdlc3RVbml0IH07XG4gICAgICAgIGxldCB7IHllYXJzLCBtb250aHMgfSA9IENhbGVuZGFyRGF0ZVVudGlsKGNhbGVuZGFyLCB0aGlzRGF0ZSwgb3RoZXJEYXRlLCB1bnRpbE9wdGlvbnMpO1xuICAgICAgICBjb25zdCBEdXJhdGlvbiA9IEdldEludHJpbnNpYygnJVRlbXBvcmFsLkR1cmF0aW9uJScpO1xuICAgICAgICBpZiAoc21hbGxlc3RVbml0ID09PSAnbW9udGgnICYmIHJvdW5kaW5nSW5jcmVtZW50ID09PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IER1cmF0aW9uKC15ZWFycywgLW1vbnRocywgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgKHsgeWVhcnMsIG1vbnRocyB9ID0gUm91bmREdXJhdGlvbih5ZWFycywgbW9udGhzLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCByb3VuZGluZ0luY3JlbWVudCwgc21hbGxlc3RVbml0LCBOZWdhdGVUZW1wb3JhbFJvdW5kaW5nTW9kZShyb3VuZGluZ01vZGUpLCB0aGlzRGF0ZSkpO1xuICAgICAgICByZXR1cm4gbmV3IER1cmF0aW9uKC15ZWFycywgLW1vbnRocywgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCk7XG4gICAgfVxuICAgIGVxdWFscyhvdGhlclBhcmFtKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbFllYXJNb250aCh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgY29uc3Qgb3RoZXIgPSBUb1RlbXBvcmFsWWVhck1vbnRoKG90aGVyUGFyYW0pO1xuICAgICAgICBmb3IgKGNvbnN0IHNsb3Qgb2YgW0lTT19ZRUFSLCBJU09fTU9OVEgsIElTT19EQVldKSB7XG4gICAgICAgICAgICBjb25zdCB2YWwxID0gR2V0U2xvdCh0aGlzLCBzbG90KTtcbiAgICAgICAgICAgIGNvbnN0IHZhbDIgPSBHZXRTbG90KG90aGVyLCBzbG90KTtcbiAgICAgICAgICAgIGlmICh2YWwxICE9PSB2YWwyKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQ2FsZW5kYXJFcXVhbHMoR2V0U2xvdCh0aGlzLCBDQUxFTkRBUiksIEdldFNsb3Qob3RoZXIsIENBTEVOREFSKSk7XG4gICAgfVxuICAgIHRvU3RyaW5nKG9wdGlvbnNQYXJhbSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxZZWFyTW9udGgodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSBHZXRPcHRpb25zT2JqZWN0KG9wdGlvbnNQYXJhbSk7XG4gICAgICAgIGNvbnN0IHNob3dDYWxlbmRhciA9IFRvU2hvd0NhbGVuZGFyT3B0aW9uKG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gVGVtcG9yYWxZZWFyTW9udGhUb1N0cmluZyh0aGlzLCBzaG93Q2FsZW5kYXIpO1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbFllYXJNb250aCh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgcmV0dXJuIFRlbXBvcmFsWWVhck1vbnRoVG9TdHJpbmcodGhpcyk7XG4gICAgfVxuICAgIHRvTG9jYWxlU3RyaW5nKGxvY2FsZXMgPSB1bmRlZmluZWQsIG9wdGlvbnMgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsWWVhck1vbnRoKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICByZXR1cm4gbmV3IERhdGVUaW1lRm9ybWF0KGxvY2FsZXMsIG9wdGlvbnMpLmZvcm1hdCh0aGlzKTtcbiAgICB9XG4gICAgdmFsdWVPZigpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigndXNlIGNvbXBhcmUoKSBvciBlcXVhbHMoKSB0byBjb21wYXJlIFRlbXBvcmFsLlBsYWluWWVhck1vbnRoJyk7XG4gICAgfVxuICAgIHRvUGxhaW5EYXRlKGl0ZW0pIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsWWVhck1vbnRoKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICBpZiAoIUlzT2JqZWN0KGl0ZW0pKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYXJndW1lbnQgc2hvdWxkIGJlIGFuIG9iamVjdCcpO1xuICAgICAgICBjb25zdCBjYWxlbmRhciA9IEdldFNsb3QodGhpcywgQ0FMRU5EQVIpO1xuICAgICAgICBjb25zdCByZWNlaXZlckZpZWxkTmFtZXMgPSBDYWxlbmRhckZpZWxkcyhjYWxlbmRhciwgWydtb250aENvZGUnLCAneWVhciddKTtcbiAgICAgICAgY29uc3QgZmllbGRzID0gVG9UZW1wb3JhbFllYXJNb250aEZpZWxkcyh0aGlzLCByZWNlaXZlckZpZWxkTmFtZXMpO1xuICAgICAgICBjb25zdCBpbnB1dEZpZWxkTmFtZXMgPSBDYWxlbmRhckZpZWxkcyhjYWxlbmRhciwgWydkYXknXSk7XG4gICAgICAgIGNvbnN0IGlucHV0RW50cmllcyA9IFtbJ2RheSddXTtcbiAgICAgICAgLy8gQWRkIGV4dHJhIGZpZWxkcyBmcm9tIHRoZSBjYWxlbmRhciBhdCB0aGUgZW5kXG4gICAgICAgIGlucHV0RmllbGROYW1lcy5mb3JFYWNoKChmaWVsZE5hbWUpID0+IHtcbiAgICAgICAgICAgIGlmICghaW5wdXRFbnRyaWVzLnNvbWUoKFtuYW1lXSkgPT4gbmFtZSA9PT0gZmllbGROYW1lKSkge1xuICAgICAgICAgICAgICAgIGlucHV0RW50cmllcy5wdXNoKFtcbiAgICAgICAgICAgICAgICAgICAgZmllbGROYW1lLFxuICAgICAgICAgICAgICAgICAgICB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICBdKTsgLy8gTWFrZSBUUyBpZ25vcmUgZXh0cmEgZmllbGRzXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBpbnB1dEZpZWxkcyA9IFByZXBhcmVUZW1wb3JhbEZpZWxkcyhpdGVtLCBpbnB1dEVudHJpZXMpO1xuICAgICAgICBsZXQgbWVyZ2VkRmllbGRzID0gQ2FsZW5kYXJNZXJnZUZpZWxkcyhjYWxlbmRhciwgZmllbGRzLCBpbnB1dEZpZWxkcyk7XG4gICAgICAgIGNvbnN0IG1lcmdlZEZpZWxkTmFtZXMgPSBbLi4ubmV3IFNldChbLi4ucmVjZWl2ZXJGaWVsZE5hbWVzLCAuLi5pbnB1dEZpZWxkTmFtZXNdKV07XG4gICAgICAgIGNvbnN0IG1lcmdlZEVudHJpZXMgPSBbXTtcbiAgICAgICAgbWVyZ2VkRmllbGROYW1lcy5mb3JFYWNoKChmaWVsZE5hbWUpID0+IHtcbiAgICAgICAgICAgIGlmICghbWVyZ2VkRW50cmllcy5zb21lKChbbmFtZV0pID0+IG5hbWUgPT09IGZpZWxkTmFtZSkpIHtcbiAgICAgICAgICAgICAgICBtZXJnZWRFbnRyaWVzLnB1c2goW2ZpZWxkTmFtZSwgdW5kZWZpbmVkXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBtZXJnZWRGaWVsZHMgPSBQcmVwYXJlVGVtcG9yYWxGaWVsZHMobWVyZ2VkRmllbGRzLCBtZXJnZWRFbnRyaWVzKTtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IE9iamVjdENyZWF0ZShudWxsKTtcbiAgICAgICAgb3B0aW9ucy5vdmVyZmxvdyA9ICdyZWplY3QnO1xuICAgICAgICByZXR1cm4gRGF0ZUZyb21GaWVsZHMoY2FsZW5kYXIsIG1lcmdlZEZpZWxkcywgb3B0aW9ucyk7XG4gICAgfVxuICAgIGdldElTT0ZpZWxkcygpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsWWVhck1vbnRoKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY2FsZW5kYXI6IEdldFNsb3QodGhpcywgQ0FMRU5EQVIpLFxuICAgICAgICAgICAgaXNvRGF5OiBHZXRTbG90KHRoaXMsIElTT19EQVkpLFxuICAgICAgICAgICAgaXNvTW9udGg6IEdldFNsb3QodGhpcywgSVNPX01PTlRIKSxcbiAgICAgICAgICAgIGlzb1llYXI6IEdldFNsb3QodGhpcywgSVNPX1lFQVIpXG4gICAgICAgIH07XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tKGl0ZW0sIG9wdGlvbnNQYXJhbSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCBvcHRpb25zID0gR2V0T3B0aW9uc09iamVjdChvcHRpb25zUGFyYW0pO1xuICAgICAgICBpZiAoSXNUZW1wb3JhbFllYXJNb250aChpdGVtKSkge1xuICAgICAgICAgICAgVG9UZW1wb3JhbE92ZXJmbG93KG9wdGlvbnMpOyAvLyB2YWxpZGF0ZSBhbmQgaWdub3JlXG4gICAgICAgICAgICByZXR1cm4gQ3JlYXRlVGVtcG9yYWxZZWFyTW9udGgoR2V0U2xvdChpdGVtLCBJU09fWUVBUiksIEdldFNsb3QoaXRlbSwgSVNPX01PTlRIKSwgR2V0U2xvdChpdGVtLCBDQUxFTkRBUiksIEdldFNsb3QoaXRlbSwgSVNPX0RBWSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBUb1RlbXBvcmFsWWVhck1vbnRoKGl0ZW0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBzdGF0aWMgY29tcGFyZShvbmVQYXJhbSwgdHdvUGFyYW0pIHtcbiAgICAgICAgY29uc3Qgb25lID0gVG9UZW1wb3JhbFllYXJNb250aChvbmVQYXJhbSk7XG4gICAgICAgIGNvbnN0IHR3byA9IFRvVGVtcG9yYWxZZWFyTW9udGgodHdvUGFyYW0pO1xuICAgICAgICByZXR1cm4gQ29tcGFyZUlTT0RhdGUoR2V0U2xvdChvbmUsIElTT19ZRUFSKSwgR2V0U2xvdChvbmUsIElTT19NT05USCksIEdldFNsb3Qob25lLCBJU09fREFZKSwgR2V0U2xvdCh0d28sIElTT19ZRUFSKSwgR2V0U2xvdCh0d28sIElTT19NT05USCksIEdldFNsb3QodHdvLCBJU09fREFZKSk7XG4gICAgfVxufVxuTWFrZUludHJpbnNpY0NsYXNzKFBsYWluWWVhck1vbnRoLCAnVGVtcG9yYWwuUGxhaW5ZZWFyTW9udGgnKTtcblxuY29uc3QgQXJyYXlQcm90b3R5cGVQdXNoID0gQXJyYXkucHJvdG90eXBlLnB1c2g7XG5jbGFzcyBab25lZERhdGVUaW1lIHtcbiAgICBjb25zdHJ1Y3RvcihlcG9jaE5hbm9zZWNvbmRzUGFyYW0sIHRpbWVab25lUGFyYW0sIGNhbGVuZGFyUGFyYW0gPSBHZXRJU084NjAxQ2FsZW5kYXIoKSkge1xuICAgICAgICAvLyBOb3RlOiBpZiB0aGUgYXJndW1lbnQgaXMgbm90IHBhc3NlZCwgVG9CaWdJbnQodW5kZWZpbmVkKSB3aWxsIHRocm93LiBUaGlzIGNoZWNrIGV4aXN0cyBvbmx5XG4gICAgICAgIC8vICAgICAgIHRvIGltcHJvdmUgdGhlIGVycm9yIG1lc3NhZ2UuXG4gICAgICAgIC8vICAgICAgIFRvVGVtcG9yYWxUaW1lWm9uZSh1bmRlZmluZWQpIHdpbGwgZW5kIHVwIGNhbGxpbmcgVGltZVpvbmUuZnJvbShcInVuZGVmaW5lZFwiKSwgd2hpY2hcbiAgICAgICAgLy8gICAgICAgY291bGQgc3VjY2VlZC5cbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAxKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdtaXNzaW5nIGFyZ3VtZW50OiBlcG9jaE5hbm9zZWNvbmRzIGlzIHJlcXVpcmVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZXBvY2hOYW5vc2Vjb25kcyA9IFRvQmlnSW50KGVwb2NoTmFub3NlY29uZHNQYXJhbSk7XG4gICAgICAgIGNvbnN0IHRpbWVab25lID0gVG9UZW1wb3JhbFRpbWVab25lKHRpbWVab25lUGFyYW0pO1xuICAgICAgICBjb25zdCBjYWxlbmRhciA9IFRvVGVtcG9yYWxDYWxlbmRhcihjYWxlbmRhclBhcmFtKTtcbiAgICAgICAgQ3JlYXRlVGVtcG9yYWxab25lZERhdGVUaW1lU2xvdHModGhpcywgZXBvY2hOYW5vc2Vjb25kcywgdGltZVpvbmUsIGNhbGVuZGFyKTtcbiAgICB9XG4gICAgZ2V0IGNhbGVuZGFyKCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxab25lZERhdGVUaW1lKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICByZXR1cm4gR2V0U2xvdCh0aGlzLCBDQUxFTkRBUik7XG4gICAgfVxuICAgIGdldCB0aW1lWm9uZSgpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsWm9uZWREYXRlVGltZSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgcmV0dXJuIEdldFNsb3QodGhpcywgVElNRV9aT05FKTtcbiAgICB9XG4gICAgZ2V0IHllYXIoKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbFpvbmVkRGF0ZVRpbWUodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIHJldHVybiBDYWxlbmRhclllYXIoR2V0U2xvdCh0aGlzLCBDQUxFTkRBUiksIGRhdGVUaW1lKHRoaXMpKTtcbiAgICB9XG4gICAgZ2V0IG1vbnRoKCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxab25lZERhdGVUaW1lKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICByZXR1cm4gQ2FsZW5kYXJNb250aChHZXRTbG90KHRoaXMsIENBTEVOREFSKSwgZGF0ZVRpbWUodGhpcykpO1xuICAgIH1cbiAgICBnZXQgbW9udGhDb2RlKCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxab25lZERhdGVUaW1lKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICByZXR1cm4gQ2FsZW5kYXJNb250aENvZGUoR2V0U2xvdCh0aGlzLCBDQUxFTkRBUiksIGRhdGVUaW1lKHRoaXMpKTtcbiAgICB9XG4gICAgZ2V0IGRheSgpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsWm9uZWREYXRlVGltZSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgcmV0dXJuIENhbGVuZGFyRGF5KEdldFNsb3QodGhpcywgQ0FMRU5EQVIpLCBkYXRlVGltZSh0aGlzKSk7XG4gICAgfVxuICAgIGdldCBob3VyKCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxab25lZERhdGVUaW1lKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICByZXR1cm4gR2V0U2xvdChkYXRlVGltZSh0aGlzKSwgSVNPX0hPVVIpO1xuICAgIH1cbiAgICBnZXQgbWludXRlKCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxab25lZERhdGVUaW1lKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICByZXR1cm4gR2V0U2xvdChkYXRlVGltZSh0aGlzKSwgSVNPX01JTlVURSk7XG4gICAgfVxuICAgIGdldCBzZWNvbmQoKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbFpvbmVkRGF0ZVRpbWUodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIHJldHVybiBHZXRTbG90KGRhdGVUaW1lKHRoaXMpLCBJU09fU0VDT05EKTtcbiAgICB9XG4gICAgZ2V0IG1pbGxpc2Vjb25kKCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxab25lZERhdGVUaW1lKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICByZXR1cm4gR2V0U2xvdChkYXRlVGltZSh0aGlzKSwgSVNPX01JTExJU0VDT05EKTtcbiAgICB9XG4gICAgZ2V0IG1pY3Jvc2Vjb25kKCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxab25lZERhdGVUaW1lKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICByZXR1cm4gR2V0U2xvdChkYXRlVGltZSh0aGlzKSwgSVNPX01JQ1JPU0VDT05EKTtcbiAgICB9XG4gICAgZ2V0IG5hbm9zZWNvbmQoKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbFpvbmVkRGF0ZVRpbWUodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIHJldHVybiBHZXRTbG90KGRhdGVUaW1lKHRoaXMpLCBJU09fTkFOT1NFQ09ORCk7XG4gICAgfVxuICAgIGdldCBlcmEoKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbFpvbmVkRGF0ZVRpbWUodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIHJldHVybiBDYWxlbmRhckVyYShHZXRTbG90KHRoaXMsIENBTEVOREFSKSwgZGF0ZVRpbWUodGhpcykpO1xuICAgIH1cbiAgICBnZXQgZXJhWWVhcigpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsWm9uZWREYXRlVGltZSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgcmV0dXJuIENhbGVuZGFyRXJhWWVhcihHZXRTbG90KHRoaXMsIENBTEVOREFSKSwgZGF0ZVRpbWUodGhpcykpO1xuICAgIH1cbiAgICBnZXQgZXBvY2hTZWNvbmRzKCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxab25lZERhdGVUaW1lKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IEdldFNsb3QodGhpcywgRVBPQ0hOQU5PU0VDT05EUyk7XG4gICAgICAgIHJldHVybiBKU0JJLnRvTnVtYmVyKEpTQkkuZGl2aWRlKHZhbHVlLCBCSUxMSU9OKSk7XG4gICAgfVxuICAgIGdldCBlcG9jaE1pbGxpc2Vjb25kcygpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsWm9uZWREYXRlVGltZSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBHZXRTbG90KHRoaXMsIEVQT0NITkFOT1NFQ09ORFMpO1xuICAgICAgICByZXR1cm4gSlNCSS50b051bWJlcihKU0JJLmRpdmlkZSh2YWx1ZSwgTUlMTElPTikpO1xuICAgIH1cbiAgICBnZXQgZXBvY2hNaWNyb3NlY29uZHMoKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbFpvbmVkRGF0ZVRpbWUodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gR2V0U2xvdCh0aGlzLCBFUE9DSE5BTk9TRUNPTkRTKTtcbiAgICAgICAgcmV0dXJuIFRvQmlnSW50RXh0ZXJuYWwoSlNCSS5kaXZpZGUodmFsdWUsIFRIT1VTQU5EKSk7XG4gICAgfVxuICAgIGdldCBlcG9jaE5hbm9zZWNvbmRzKCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxab25lZERhdGVUaW1lKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICByZXR1cm4gVG9CaWdJbnRFeHRlcm5hbChHZXRTbG90KHRoaXMsIEVQT0NITkFOT1NFQ09ORFMpKTtcbiAgICB9XG4gICAgZ2V0IGRheU9mV2VlaygpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsWm9uZWREYXRlVGltZSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgcmV0dXJuIENhbGVuZGFyRGF5T2ZXZWVrKEdldFNsb3QodGhpcywgQ0FMRU5EQVIpLCBkYXRlVGltZSh0aGlzKSk7XG4gICAgfVxuICAgIGdldCBkYXlPZlllYXIoKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbFpvbmVkRGF0ZVRpbWUodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIHJldHVybiBDYWxlbmRhckRheU9mWWVhcihHZXRTbG90KHRoaXMsIENBTEVOREFSKSwgZGF0ZVRpbWUodGhpcykpO1xuICAgIH1cbiAgICBnZXQgd2Vla09mWWVhcigpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsWm9uZWREYXRlVGltZSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgcmV0dXJuIENhbGVuZGFyV2Vla09mWWVhcihHZXRTbG90KHRoaXMsIENBTEVOREFSKSwgZGF0ZVRpbWUodGhpcykpO1xuICAgIH1cbiAgICBnZXQgaG91cnNJbkRheSgpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsWm9uZWREYXRlVGltZSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgY29uc3QgZHQgPSBkYXRlVGltZSh0aGlzKTtcbiAgICAgICAgY29uc3QgRGF0ZVRpbWUgPSBHZXRJbnRyaW5zaWMoJyVUZW1wb3JhbC5QbGFpbkRhdGVUaW1lJScpO1xuICAgICAgICBjb25zdCB5ZWFyID0gR2V0U2xvdChkdCwgSVNPX1lFQVIpO1xuICAgICAgICBjb25zdCBtb250aCA9IEdldFNsb3QoZHQsIElTT19NT05USCk7XG4gICAgICAgIGNvbnN0IGRheSA9IEdldFNsb3QoZHQsIElTT19EQVkpO1xuICAgICAgICBjb25zdCB0b2RheSA9IG5ldyBEYXRlVGltZSh5ZWFyLCBtb250aCwgZGF5LCAwLCAwLCAwLCAwLCAwLCAwKTtcbiAgICAgICAgY29uc3QgdG9tb3Jyb3dGaWVsZHMgPSBBZGRJU09EYXRlKHllYXIsIG1vbnRoLCBkYXksIDAsIDAsIDAsIDEsICdyZWplY3QnKTtcbiAgICAgICAgY29uc3QgdG9tb3Jyb3cgPSBuZXcgRGF0ZVRpbWUodG9tb3Jyb3dGaWVsZHMueWVhciwgdG9tb3Jyb3dGaWVsZHMubW9udGgsIHRvbW9ycm93RmllbGRzLmRheSwgMCwgMCwgMCwgMCwgMCwgMCk7XG4gICAgICAgIGNvbnN0IHRpbWVab25lID0gR2V0U2xvdCh0aGlzLCBUSU1FX1pPTkUpO1xuICAgICAgICBjb25zdCB0b2RheU5zID0gR2V0U2xvdChCdWlsdGluVGltZVpvbmVHZXRJbnN0YW50Rm9yKHRpbWVab25lLCB0b2RheSwgJ2NvbXBhdGlibGUnKSwgRVBPQ0hOQU5PU0VDT05EUyk7XG4gICAgICAgIGNvbnN0IHRvbW9ycm93TnMgPSBHZXRTbG90KEJ1aWx0aW5UaW1lWm9uZUdldEluc3RhbnRGb3IodGltZVpvbmUsIHRvbW9ycm93LCAnY29tcGF0aWJsZScpLCBFUE9DSE5BTk9TRUNPTkRTKTtcbiAgICAgICAgcmV0dXJuIEpTQkkudG9OdW1iZXIoSlNCSS5zdWJ0cmFjdCh0b21vcnJvd05zLCB0b2RheU5zKSkgLyAzLjZlMTI7XG4gICAgfVxuICAgIGdldCBkYXlzSW5XZWVrKCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxab25lZERhdGVUaW1lKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICByZXR1cm4gQ2FsZW5kYXJEYXlzSW5XZWVrKEdldFNsb3QodGhpcywgQ0FMRU5EQVIpLCBkYXRlVGltZSh0aGlzKSk7XG4gICAgfVxuICAgIGdldCBkYXlzSW5Nb250aCgpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsWm9uZWREYXRlVGltZSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgcmV0dXJuIENhbGVuZGFyRGF5c0luTW9udGgoR2V0U2xvdCh0aGlzLCBDQUxFTkRBUiksIGRhdGVUaW1lKHRoaXMpKTtcbiAgICB9XG4gICAgZ2V0IGRheXNJblllYXIoKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbFpvbmVkRGF0ZVRpbWUodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIHJldHVybiBDYWxlbmRhckRheXNJblllYXIoR2V0U2xvdCh0aGlzLCBDQUxFTkRBUiksIGRhdGVUaW1lKHRoaXMpKTtcbiAgICB9XG4gICAgZ2V0IG1vbnRoc0luWWVhcigpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsWm9uZWREYXRlVGltZSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgcmV0dXJuIENhbGVuZGFyTW9udGhzSW5ZZWFyKEdldFNsb3QodGhpcywgQ0FMRU5EQVIpLCBkYXRlVGltZSh0aGlzKSk7XG4gICAgfVxuICAgIGdldCBpbkxlYXBZZWFyKCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxab25lZERhdGVUaW1lKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICByZXR1cm4gQ2FsZW5kYXJJbkxlYXBZZWFyKEdldFNsb3QodGhpcywgQ0FMRU5EQVIpLCBkYXRlVGltZSh0aGlzKSk7XG4gICAgfVxuICAgIGdldCBvZmZzZXQoKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbFpvbmVkRGF0ZVRpbWUodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIHJldHVybiBCdWlsdGluVGltZVpvbmVHZXRPZmZzZXRTdHJpbmdGb3IoR2V0U2xvdCh0aGlzLCBUSU1FX1pPTkUpLCBHZXRTbG90KHRoaXMsIElOU1RBTlQpKTtcbiAgICB9XG4gICAgZ2V0IG9mZnNldE5hbm9zZWNvbmRzKCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxab25lZERhdGVUaW1lKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICByZXR1cm4gR2V0T2Zmc2V0TmFub3NlY29uZHNGb3IoR2V0U2xvdCh0aGlzLCBUSU1FX1pPTkUpLCBHZXRTbG90KHRoaXMsIElOU1RBTlQpKTtcbiAgICB9XG4gICAgd2l0aCh0ZW1wb3JhbFpvbmVkRGF0ZVRpbWVMaWtlLCBvcHRpb25zUGFyYW0gPSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsWm9uZWREYXRlVGltZSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgaWYgKCFJc09iamVjdCh0ZW1wb3JhbFpvbmVkRGF0ZVRpbWVMaWtlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCB6b25lZC1kYXRlLXRpbWUtbGlrZScpO1xuICAgICAgICB9XG4gICAgICAgIFJlamVjdE9iamVjdFdpdGhDYWxlbmRhck9yVGltZVpvbmUodGVtcG9yYWxab25lZERhdGVUaW1lTGlrZSk7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSBHZXRPcHRpb25zT2JqZWN0KG9wdGlvbnNQYXJhbSk7XG4gICAgICAgIGNvbnN0IGRpc2FtYmlndWF0aW9uID0gVG9UZW1wb3JhbERpc2FtYmlndWF0aW9uKG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBvZmZzZXQgPSBUb1RlbXBvcmFsT2Zmc2V0KG9wdGlvbnMsICdwcmVmZXInKTtcbiAgICAgICAgY29uc3QgdGltZVpvbmUgPSBHZXRTbG90KHRoaXMsIFRJTUVfWk9ORSk7XG4gICAgICAgIGNvbnN0IGNhbGVuZGFyID0gR2V0U2xvdCh0aGlzLCBDQUxFTkRBUik7XG4gICAgICAgIGNvbnN0IGZpZWxkTmFtZXMgPSBDYWxlbmRhckZpZWxkcyhjYWxlbmRhciwgW1xuICAgICAgICAgICAgJ2RheScsXG4gICAgICAgICAgICAnaG91cicsXG4gICAgICAgICAgICAnbWljcm9zZWNvbmQnLFxuICAgICAgICAgICAgJ21pbGxpc2Vjb25kJyxcbiAgICAgICAgICAgICdtaW51dGUnLFxuICAgICAgICAgICAgJ21vbnRoJyxcbiAgICAgICAgICAgICdtb250aENvZGUnLFxuICAgICAgICAgICAgJ25hbm9zZWNvbmQnLFxuICAgICAgICAgICAgJ3NlY29uZCcsXG4gICAgICAgICAgICAneWVhcidcbiAgICAgICAgXSk7XG4gICAgICAgIEFycmF5UHJvdG90eXBlUHVzaC5jYWxsKGZpZWxkTmFtZXMsICdvZmZzZXQnKTtcbiAgICAgICAgY29uc3QgcHJvcHMgPSBUb1BhcnRpYWxSZWNvcmQodGVtcG9yYWxab25lZERhdGVUaW1lTGlrZSwgZmllbGROYW1lcyk7XG4gICAgICAgIGlmICghcHJvcHMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgem9uZWQtZGF0ZS10aW1lLWxpa2UnKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBVbmxpa2UgVG9UZW1wb3JhbFpvbmVkRGF0ZVRpbWVGaWVsZHMsIHRoZSBvZmZzZXQgcHJvcGVydHkgd2lsbCBiZSByZXF1aXJlZC5cbiAgICAgICAgY29uc3QgZW50cmllcyA9IFtcbiAgICAgICAgICAgIFsnZGF5JywgdW5kZWZpbmVkXSxcbiAgICAgICAgICAgIFsnaG91cicsIDBdLFxuICAgICAgICAgICAgWydtaWNyb3NlY29uZCcsIDBdLFxuICAgICAgICAgICAgWydtaWxsaXNlY29uZCcsIDBdLFxuICAgICAgICAgICAgWydtaW51dGUnLCAwXSxcbiAgICAgICAgICAgIFsnbW9udGgnLCB1bmRlZmluZWRdLFxuICAgICAgICAgICAgWydtb250aENvZGUnLCB1bmRlZmluZWRdLFxuICAgICAgICAgICAgWyduYW5vc2Vjb25kJywgMF0sXG4gICAgICAgICAgICBbJ3NlY29uZCcsIDBdLFxuICAgICAgICAgICAgWyd5ZWFyJywgdW5kZWZpbmVkXSxcbiAgICAgICAgICAgIFsnb2Zmc2V0J10sXG4gICAgICAgICAgICBbJ3RpbWVab25lJ11cbiAgICAgICAgXTtcbiAgICAgICAgLy8gQWRkIGV4dHJhIGZpZWxkcyBmcm9tIHRoZSBjYWxlbmRhciBhdCB0aGUgZW5kXG4gICAgICAgIGZpZWxkTmFtZXMuZm9yRWFjaCgoZmllbGROYW1lKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWVudHJpZXMuc29tZSgoW25hbWVdKSA9PiBuYW1lID09PSBmaWVsZE5hbWUpKSB7XG4gICAgICAgICAgICAgICAgZW50cmllcy5wdXNoKFtmaWVsZE5hbWUsIHVuZGVmaW5lZF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgbGV0IGZpZWxkcyA9IFByZXBhcmVUZW1wb3JhbEZpZWxkcyh0aGlzLCBlbnRyaWVzKTtcbiAgICAgICAgZmllbGRzID0gQ2FsZW5kYXJNZXJnZUZpZWxkcyhjYWxlbmRhciwgZmllbGRzLCBwcm9wcyk7XG4gICAgICAgIGZpZWxkcyA9IFByZXBhcmVUZW1wb3JhbEZpZWxkcyhmaWVsZHMsIGVudHJpZXMpO1xuICAgICAgICBjb25zdCB7IHllYXIsIG1vbnRoLCBkYXksIGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZCwgbWljcm9zZWNvbmQsIG5hbm9zZWNvbmQgfSA9IEludGVycHJldFRlbXBvcmFsRGF0ZVRpbWVGaWVsZHMoY2FsZW5kYXIsIGZpZWxkcywgb3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IG9mZnNldE5zID0gUGFyc2VUaW1lWm9uZU9mZnNldFN0cmluZyhmaWVsZHMub2Zmc2V0KTtcbiAgICAgICAgY29uc3QgZXBvY2hOYW5vc2Vjb25kcyA9IEludGVycHJldElTT0RhdGVUaW1lT2Zmc2V0KHllYXIsIG1vbnRoLCBkYXksIGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZCwgbWljcm9zZWNvbmQsIG5hbm9zZWNvbmQsICdvcHRpb24nLCBvZmZzZXROcywgdGltZVpvbmUsIGRpc2FtYmlndWF0aW9uLCBvZmZzZXQsIFxuICAgICAgICAvKiBtYXRjaE1pbnV0ZSA9ICovIGZhbHNlKTtcbiAgICAgICAgcmV0dXJuIENyZWF0ZVRlbXBvcmFsWm9uZWREYXRlVGltZShlcG9jaE5hbm9zZWNvbmRzLCBHZXRTbG90KHRoaXMsIFRJTUVfWk9ORSksIGNhbGVuZGFyKTtcbiAgICB9XG4gICAgd2l0aFBsYWluRGF0ZSh0ZW1wb3JhbERhdGVQYXJhbSkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxab25lZERhdGVUaW1lKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICBjb25zdCB0ZW1wb3JhbERhdGUgPSBUb1RlbXBvcmFsRGF0ZSh0ZW1wb3JhbERhdGVQYXJhbSk7XG4gICAgICAgIGNvbnN0IHllYXIgPSBHZXRTbG90KHRlbXBvcmFsRGF0ZSwgSVNPX1lFQVIpO1xuICAgICAgICBjb25zdCBtb250aCA9IEdldFNsb3QodGVtcG9yYWxEYXRlLCBJU09fTU9OVEgpO1xuICAgICAgICBjb25zdCBkYXkgPSBHZXRTbG90KHRlbXBvcmFsRGF0ZSwgSVNPX0RBWSk7XG4gICAgICAgIGxldCBjYWxlbmRhciA9IEdldFNsb3QodGVtcG9yYWxEYXRlLCBDQUxFTkRBUik7XG4gICAgICAgIGNvbnN0IHRoaXNEdCA9IGRhdGVUaW1lKHRoaXMpO1xuICAgICAgICBjb25zdCBob3VyID0gR2V0U2xvdCh0aGlzRHQsIElTT19IT1VSKTtcbiAgICAgICAgY29uc3QgbWludXRlID0gR2V0U2xvdCh0aGlzRHQsIElTT19NSU5VVEUpO1xuICAgICAgICBjb25zdCBzZWNvbmQgPSBHZXRTbG90KHRoaXNEdCwgSVNPX1NFQ09ORCk7XG4gICAgICAgIGNvbnN0IG1pbGxpc2Vjb25kID0gR2V0U2xvdCh0aGlzRHQsIElTT19NSUxMSVNFQ09ORCk7XG4gICAgICAgIGNvbnN0IG1pY3Jvc2Vjb25kID0gR2V0U2xvdCh0aGlzRHQsIElTT19NSUNST1NFQ09ORCk7XG4gICAgICAgIGNvbnN0IG5hbm9zZWNvbmQgPSBHZXRTbG90KHRoaXNEdCwgSVNPX05BTk9TRUNPTkQpO1xuICAgICAgICBjYWxlbmRhciA9IENvbnNvbGlkYXRlQ2FsZW5kYXJzKEdldFNsb3QodGhpcywgQ0FMRU5EQVIpLCBjYWxlbmRhcik7XG4gICAgICAgIGNvbnN0IHRpbWVab25lID0gR2V0U2xvdCh0aGlzLCBUSU1FX1pPTkUpO1xuICAgICAgICBjb25zdCBQbGFpbkRhdGVUaW1lID0gR2V0SW50cmluc2ljKCclVGVtcG9yYWwuUGxhaW5EYXRlVGltZSUnKTtcbiAgICAgICAgY29uc3QgZHQgPSBuZXcgUGxhaW5EYXRlVGltZSh5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQsIG1pY3Jvc2Vjb25kLCBuYW5vc2Vjb25kLCBjYWxlbmRhcik7XG4gICAgICAgIGNvbnN0IGluc3RhbnQgPSBCdWlsdGluVGltZVpvbmVHZXRJbnN0YW50Rm9yKHRpbWVab25lLCBkdCwgJ2NvbXBhdGlibGUnKTtcbiAgICAgICAgcmV0dXJuIENyZWF0ZVRlbXBvcmFsWm9uZWREYXRlVGltZShHZXRTbG90KGluc3RhbnQsIEVQT0NITkFOT1NFQ09ORFMpLCB0aW1lWm9uZSwgY2FsZW5kYXIpO1xuICAgIH1cbiAgICB3aXRoUGxhaW5UaW1lKHRlbXBvcmFsVGltZVBhcmFtID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbFpvbmVkRGF0ZVRpbWUodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIGNvbnN0IFBsYWluVGltZSA9IEdldEludHJpbnNpYygnJVRlbXBvcmFsLlBsYWluVGltZSUnKTtcbiAgICAgICAgY29uc3QgdGVtcG9yYWxUaW1lID0gdGVtcG9yYWxUaW1lUGFyYW0gPT0gdW5kZWZpbmVkID8gbmV3IFBsYWluVGltZSgpIDogVG9UZW1wb3JhbFRpbWUodGVtcG9yYWxUaW1lUGFyYW0pO1xuICAgICAgICBjb25zdCB0aGlzRHQgPSBkYXRlVGltZSh0aGlzKTtcbiAgICAgICAgY29uc3QgeWVhciA9IEdldFNsb3QodGhpc0R0LCBJU09fWUVBUik7XG4gICAgICAgIGNvbnN0IG1vbnRoID0gR2V0U2xvdCh0aGlzRHQsIElTT19NT05USCk7XG4gICAgICAgIGNvbnN0IGRheSA9IEdldFNsb3QodGhpc0R0LCBJU09fREFZKTtcbiAgICAgICAgY29uc3QgY2FsZW5kYXIgPSBHZXRTbG90KHRoaXMsIENBTEVOREFSKTtcbiAgICAgICAgY29uc3QgaG91ciA9IEdldFNsb3QodGVtcG9yYWxUaW1lLCBJU09fSE9VUik7XG4gICAgICAgIGNvbnN0IG1pbnV0ZSA9IEdldFNsb3QodGVtcG9yYWxUaW1lLCBJU09fTUlOVVRFKTtcbiAgICAgICAgY29uc3Qgc2Vjb25kID0gR2V0U2xvdCh0ZW1wb3JhbFRpbWUsIElTT19TRUNPTkQpO1xuICAgICAgICBjb25zdCBtaWxsaXNlY29uZCA9IEdldFNsb3QodGVtcG9yYWxUaW1lLCBJU09fTUlMTElTRUNPTkQpO1xuICAgICAgICBjb25zdCBtaWNyb3NlY29uZCA9IEdldFNsb3QodGVtcG9yYWxUaW1lLCBJU09fTUlDUk9TRUNPTkQpO1xuICAgICAgICBjb25zdCBuYW5vc2Vjb25kID0gR2V0U2xvdCh0ZW1wb3JhbFRpbWUsIElTT19OQU5PU0VDT05EKTtcbiAgICAgICAgY29uc3QgdGltZVpvbmUgPSBHZXRTbG90KHRoaXMsIFRJTUVfWk9ORSk7XG4gICAgICAgIGNvbnN0IFBsYWluRGF0ZVRpbWUgPSBHZXRJbnRyaW5zaWMoJyVUZW1wb3JhbC5QbGFpbkRhdGVUaW1lJScpO1xuICAgICAgICBjb25zdCBkdCA9IG5ldyBQbGFpbkRhdGVUaW1lKHllYXIsIG1vbnRoLCBkYXksIGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZCwgbWljcm9zZWNvbmQsIG5hbm9zZWNvbmQsIGNhbGVuZGFyKTtcbiAgICAgICAgY29uc3QgaW5zdGFudCA9IEJ1aWx0aW5UaW1lWm9uZUdldEluc3RhbnRGb3IodGltZVpvbmUsIGR0LCAnY29tcGF0aWJsZScpO1xuICAgICAgICByZXR1cm4gQ3JlYXRlVGVtcG9yYWxab25lZERhdGVUaW1lKEdldFNsb3QoaW5zdGFudCwgRVBPQ0hOQU5PU0VDT05EUyksIHRpbWVab25lLCBjYWxlbmRhcik7XG4gICAgfVxuICAgIHdpdGhUaW1lWm9uZSh0aW1lWm9uZVBhcmFtKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbFpvbmVkRGF0ZVRpbWUodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIGNvbnN0IHRpbWVab25lID0gVG9UZW1wb3JhbFRpbWVab25lKHRpbWVab25lUGFyYW0pO1xuICAgICAgICByZXR1cm4gQ3JlYXRlVGVtcG9yYWxab25lZERhdGVUaW1lKEdldFNsb3QodGhpcywgRVBPQ0hOQU5PU0VDT05EUyksIHRpbWVab25lLCBHZXRTbG90KHRoaXMsIENBTEVOREFSKSk7XG4gICAgfVxuICAgIHdpdGhDYWxlbmRhcihjYWxlbmRhclBhcmFtKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbFpvbmVkRGF0ZVRpbWUodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIGNvbnN0IGNhbGVuZGFyID0gVG9UZW1wb3JhbENhbGVuZGFyKGNhbGVuZGFyUGFyYW0pO1xuICAgICAgICByZXR1cm4gQ3JlYXRlVGVtcG9yYWxab25lZERhdGVUaW1lKEdldFNsb3QodGhpcywgRVBPQ0hOQU5PU0VDT05EUyksIEdldFNsb3QodGhpcywgVElNRV9aT05FKSwgY2FsZW5kYXIpO1xuICAgIH1cbiAgICBhZGQodGVtcG9yYWxEdXJhdGlvbkxpa2UsIG9wdGlvbnNQYXJhbSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxab25lZERhdGVUaW1lKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICBjb25zdCBkdXJhdGlvbiA9IFRvTGltaXRlZFRlbXBvcmFsRHVyYXRpb24odGVtcG9yYWxEdXJhdGlvbkxpa2UpO1xuICAgICAgICBjb25zdCB7IHllYXJzLCBtb250aHMsIHdlZWtzLCBkYXlzLCBob3VycywgbWludXRlcywgc2Vjb25kcywgbWlsbGlzZWNvbmRzLCBtaWNyb3NlY29uZHMsIG5hbm9zZWNvbmRzIH0gPSBkdXJhdGlvbjtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IEdldE9wdGlvbnNPYmplY3Qob3B0aW9uc1BhcmFtKTtcbiAgICAgICAgY29uc3QgdGltZVpvbmUgPSBHZXRTbG90KHRoaXMsIFRJTUVfWk9ORSk7XG4gICAgICAgIGNvbnN0IGNhbGVuZGFyID0gR2V0U2xvdCh0aGlzLCBDQUxFTkRBUik7XG4gICAgICAgIGNvbnN0IGVwb2NoTmFub3NlY29uZHMgPSBBZGRab25lZERhdGVUaW1lKEdldFNsb3QodGhpcywgSU5TVEFOVCksIHRpbWVab25lLCBjYWxlbmRhciwgeWVhcnMsIG1vbnRocywgd2Vla3MsIGRheXMsIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBtaWxsaXNlY29uZHMsIG1pY3Jvc2Vjb25kcywgbmFub3NlY29uZHMsIG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gQ3JlYXRlVGVtcG9yYWxab25lZERhdGVUaW1lKGVwb2NoTmFub3NlY29uZHMsIHRpbWVab25lLCBjYWxlbmRhcik7XG4gICAgfVxuICAgIHN1YnRyYWN0KHRlbXBvcmFsRHVyYXRpb25MaWtlLCBvcHRpb25zUGFyYW0gPSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsWm9uZWREYXRlVGltZSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgY29uc3QgZHVyYXRpb24gPSBUb0xpbWl0ZWRUZW1wb3JhbER1cmF0aW9uKHRlbXBvcmFsRHVyYXRpb25MaWtlKTtcbiAgICAgICAgY29uc3QgeyB5ZWFycywgbW9udGhzLCB3ZWVrcywgZGF5cywgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc2Vjb25kcywgbWljcm9zZWNvbmRzLCBuYW5vc2Vjb25kcyB9ID0gZHVyYXRpb247XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSBHZXRPcHRpb25zT2JqZWN0KG9wdGlvbnNQYXJhbSk7XG4gICAgICAgIGNvbnN0IHRpbWVab25lID0gR2V0U2xvdCh0aGlzLCBUSU1FX1pPTkUpO1xuICAgICAgICBjb25zdCBjYWxlbmRhciA9IEdldFNsb3QodGhpcywgQ0FMRU5EQVIpO1xuICAgICAgICBjb25zdCBlcG9jaE5hbm9zZWNvbmRzID0gQWRkWm9uZWREYXRlVGltZShHZXRTbG90KHRoaXMsIElOU1RBTlQpLCB0aW1lWm9uZSwgY2FsZW5kYXIsIC15ZWFycywgLW1vbnRocywgLXdlZWtzLCAtZGF5cywgLWhvdXJzLCAtbWludXRlcywgLXNlY29uZHMsIC1taWxsaXNlY29uZHMsIC1taWNyb3NlY29uZHMsIC1uYW5vc2Vjb25kcywgb3B0aW9ucyk7XG4gICAgICAgIHJldHVybiBDcmVhdGVUZW1wb3JhbFpvbmVkRGF0ZVRpbWUoZXBvY2hOYW5vc2Vjb25kcywgdGltZVpvbmUsIGNhbGVuZGFyKTtcbiAgICB9XG4gICAgdW50aWwob3RoZXJQYXJhbSwgb3B0aW9uc1BhcmFtID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbFpvbmVkRGF0ZVRpbWUodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIGNvbnN0IG90aGVyID0gVG9UZW1wb3JhbFpvbmVkRGF0ZVRpbWUob3RoZXJQYXJhbSk7XG4gICAgICAgIGNvbnN0IGNhbGVuZGFyID0gR2V0U2xvdCh0aGlzLCBDQUxFTkRBUik7XG4gICAgICAgIGNvbnN0IG90aGVyQ2FsZW5kYXIgPSBHZXRTbG90KG90aGVyLCBDQUxFTkRBUik7XG4gICAgICAgIGNvbnN0IGNhbGVuZGFySWQgPSBUb1N0cmluZyhjYWxlbmRhcik7XG4gICAgICAgIGNvbnN0IG90aGVyQ2FsZW5kYXJJZCA9IFRvU3RyaW5nKG90aGVyQ2FsZW5kYXIpO1xuICAgICAgICBpZiAoY2FsZW5kYXJJZCAhPT0gb3RoZXJDYWxlbmRhcklkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgY2Fubm90IGNvbXB1dGUgZGlmZmVyZW5jZSBiZXR3ZWVuIGRhdGVzIG9mICR7Y2FsZW5kYXJJZH0gYW5kICR7b3RoZXJDYWxlbmRhcklkfSBjYWxlbmRhcnNgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvcHRpb25zID0gR2V0T3B0aW9uc09iamVjdChvcHRpb25zUGFyYW0pO1xuICAgICAgICBjb25zdCBzbWFsbGVzdFVuaXQgPSBUb1NtYWxsZXN0VGVtcG9yYWxVbml0KG9wdGlvbnMsICduYW5vc2Vjb25kJyk7XG4gICAgICAgIGNvbnN0IGRlZmF1bHRMYXJnZXN0VW5pdCA9IExhcmdlck9mVHdvVGVtcG9yYWxVbml0cygnaG91cicsIHNtYWxsZXN0VW5pdCk7XG4gICAgICAgIGNvbnN0IGxhcmdlc3RVbml0ID0gVG9MYXJnZXN0VGVtcG9yYWxVbml0KG9wdGlvbnMsICdhdXRvJywgW10sIGRlZmF1bHRMYXJnZXN0VW5pdCk7XG4gICAgICAgIFZhbGlkYXRlVGVtcG9yYWxVbml0UmFuZ2UobGFyZ2VzdFVuaXQsIHNtYWxsZXN0VW5pdCk7XG4gICAgICAgIGNvbnN0IHJvdW5kaW5nTW9kZSA9IFRvVGVtcG9yYWxSb3VuZGluZ01vZGUob3B0aW9ucywgJ3RydW5jJyk7XG4gICAgICAgIGNvbnN0IHJvdW5kaW5nSW5jcmVtZW50ID0gVG9UZW1wb3JhbERhdGVUaW1lUm91bmRpbmdJbmNyZW1lbnQob3B0aW9ucywgc21hbGxlc3RVbml0KTtcbiAgICAgICAgY29uc3QgbnMxID0gR2V0U2xvdCh0aGlzLCBFUE9DSE5BTk9TRUNPTkRTKTtcbiAgICAgICAgY29uc3QgbnMyID0gR2V0U2xvdChvdGhlciwgRVBPQ0hOQU5PU0VDT05EUyk7XG4gICAgICAgIGxldCB5ZWFycywgbW9udGhzLCB3ZWVrcywgZGF5cywgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc2Vjb25kcywgbWljcm9zZWNvbmRzLCBuYW5vc2Vjb25kcztcbiAgICAgICAgaWYgKGxhcmdlc3RVbml0ICE9PSAneWVhcicgJiYgbGFyZ2VzdFVuaXQgIT09ICdtb250aCcgJiYgbGFyZ2VzdFVuaXQgIT09ICd3ZWVrJyAmJiBsYXJnZXN0VW5pdCAhPT0gJ2RheScpIHtcbiAgICAgICAgICAgIC8vIFRoZSB1c2VyIGlzIG9ubHkgYXNraW5nIGZvciBhIHRpbWUgZGlmZmVyZW5jZSwgc28gcmV0dXJuIGRpZmZlcmVuY2Ugb2YgaW5zdGFudHMuXG4gICAgICAgICAgICB5ZWFycyA9IDA7XG4gICAgICAgICAgICBtb250aHMgPSAwO1xuICAgICAgICAgICAgd2Vla3MgPSAwO1xuICAgICAgICAgICAgZGF5cyA9IDA7XG4gICAgICAgICAgICAoeyBzZWNvbmRzLCBtaWxsaXNlY29uZHMsIG1pY3Jvc2Vjb25kcywgbmFub3NlY29uZHMgfSA9IERpZmZlcmVuY2VJbnN0YW50KG5zMSwgbnMyLCByb3VuZGluZ0luY3JlbWVudCwgc21hbGxlc3RVbml0LCByb3VuZGluZ01vZGUpKTtcbiAgICAgICAgICAgICh7IGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBtaWxsaXNlY29uZHMsIG1pY3Jvc2Vjb25kcywgbmFub3NlY29uZHMgfSA9IEJhbGFuY2VEdXJhdGlvbigwLCAwLCAwLCBzZWNvbmRzLCBtaWxsaXNlY29uZHMsIG1pY3Jvc2Vjb25kcywgbmFub3NlY29uZHMsIGxhcmdlc3RVbml0KSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCB0aW1lWm9uZSA9IEdldFNsb3QodGhpcywgVElNRV9aT05FKTtcbiAgICAgICAgICAgIGlmICghVGltZVpvbmVFcXVhbHModGltZVpvbmUsIEdldFNsb3Qob3RoZXIsIFRJTUVfWk9ORSkpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJXaGVuIGNhbGN1bGF0aW5nIGRpZmZlcmVuY2UgYmV0d2VlbiB0aW1lIHpvbmVzLCBsYXJnZXN0VW5pdCBtdXN0IGJlICdob3VycycgXCIgK1xuICAgICAgICAgICAgICAgICAgICAnb3Igc21hbGxlciBiZWNhdXNlIGRheSBsZW5ndGhzIGNhbiB2YXJ5IGJldHdlZW4gdGltZSB6b25lcyBkdWUgdG8gRFNUIG9yIHRpbWUgem9uZSBvZmZzZXQgY2hhbmdlcy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHVudGlsT3B0aW9ucyA9IHsgLi4ub3B0aW9ucywgbGFyZ2VzdFVuaXQgfTtcbiAgICAgICAgICAgICh7IHllYXJzLCBtb250aHMsIHdlZWtzLCBkYXlzLCBob3VycywgbWludXRlcywgc2Vjb25kcywgbWlsbGlzZWNvbmRzLCBtaWNyb3NlY29uZHMsIG5hbm9zZWNvbmRzIH0gPVxuICAgICAgICAgICAgICAgIERpZmZlcmVuY2Vab25lZERhdGVUaW1lKG5zMSwgbnMyLCB0aW1lWm9uZSwgY2FsZW5kYXIsIGxhcmdlc3RVbml0LCB1bnRpbE9wdGlvbnMpKTtcbiAgICAgICAgICAgICh7IHllYXJzLCBtb250aHMsIHdlZWtzLCBkYXlzLCBob3VycywgbWludXRlcywgc2Vjb25kcywgbWlsbGlzZWNvbmRzLCBtaWNyb3NlY29uZHMsIG5hbm9zZWNvbmRzIH0gPVxuICAgICAgICAgICAgICAgIFJvdW5kRHVyYXRpb24oeWVhcnMsIG1vbnRocywgd2Vla3MsIGRheXMsIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBtaWxsaXNlY29uZHMsIG1pY3Jvc2Vjb25kcywgbmFub3NlY29uZHMsIHJvdW5kaW5nSW5jcmVtZW50LCBzbWFsbGVzdFVuaXQsIHJvdW5kaW5nTW9kZSwgdGhpcykpO1xuICAgICAgICAgICAgKHsgeWVhcnMsIG1vbnRocywgd2Vla3MsIGRheXMsIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBtaWxsaXNlY29uZHMsIG1pY3Jvc2Vjb25kcywgbmFub3NlY29uZHMgfSA9XG4gICAgICAgICAgICAgICAgQWRqdXN0Um91bmRlZER1cmF0aW9uRGF5cyh5ZWFycywgbW9udGhzLCB3ZWVrcywgZGF5cywgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc2Vjb25kcywgbWljcm9zZWNvbmRzLCBuYW5vc2Vjb25kcywgcm91bmRpbmdJbmNyZW1lbnQsIHNtYWxsZXN0VW5pdCwgcm91bmRpbmdNb2RlLCB0aGlzKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgRHVyYXRpb24gPSBHZXRJbnRyaW5zaWMoJyVUZW1wb3JhbC5EdXJhdGlvbiUnKTtcbiAgICAgICAgcmV0dXJuIG5ldyBEdXJhdGlvbih5ZWFycywgbW9udGhzLCB3ZWVrcywgZGF5cywgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc2Vjb25kcywgbWljcm9zZWNvbmRzLCBuYW5vc2Vjb25kcyk7XG4gICAgfVxuICAgIHNpbmNlKG90aGVyUGFyYW0sIG9wdGlvbnNQYXJhbSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxab25lZERhdGVUaW1lKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICBjb25zdCBvdGhlciA9IFRvVGVtcG9yYWxab25lZERhdGVUaW1lKG90aGVyUGFyYW0pO1xuICAgICAgICBjb25zdCBjYWxlbmRhciA9IEdldFNsb3QodGhpcywgQ0FMRU5EQVIpO1xuICAgICAgICBjb25zdCBvdGhlckNhbGVuZGFyID0gR2V0U2xvdChvdGhlciwgQ0FMRU5EQVIpO1xuICAgICAgICBjb25zdCBjYWxlbmRhcklkID0gVG9TdHJpbmcoY2FsZW5kYXIpO1xuICAgICAgICBjb25zdCBvdGhlckNhbGVuZGFySWQgPSBUb1N0cmluZyhvdGhlckNhbGVuZGFyKTtcbiAgICAgICAgaWYgKGNhbGVuZGFySWQgIT09IG90aGVyQ2FsZW5kYXJJZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYGNhbm5vdCBjb21wdXRlIGRpZmZlcmVuY2UgYmV0d2VlbiBkYXRlcyBvZiAke2NhbGVuZGFySWR9IGFuZCAke290aGVyQ2FsZW5kYXJJZH0gY2FsZW5kYXJzYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IEdldE9wdGlvbnNPYmplY3Qob3B0aW9uc1BhcmFtKTtcbiAgICAgICAgY29uc3Qgc21hbGxlc3RVbml0ID0gVG9TbWFsbGVzdFRlbXBvcmFsVW5pdChvcHRpb25zLCAnbmFub3NlY29uZCcpO1xuICAgICAgICBjb25zdCBkZWZhdWx0TGFyZ2VzdFVuaXQgPSBMYXJnZXJPZlR3b1RlbXBvcmFsVW5pdHMoJ2hvdXInLCBzbWFsbGVzdFVuaXQpO1xuICAgICAgICBjb25zdCBsYXJnZXN0VW5pdCA9IFRvTGFyZ2VzdFRlbXBvcmFsVW5pdChvcHRpb25zLCAnYXV0bycsIFtdLCBkZWZhdWx0TGFyZ2VzdFVuaXQpO1xuICAgICAgICBWYWxpZGF0ZVRlbXBvcmFsVW5pdFJhbmdlKGxhcmdlc3RVbml0LCBzbWFsbGVzdFVuaXQpO1xuICAgICAgICBsZXQgcm91bmRpbmdNb2RlID0gVG9UZW1wb3JhbFJvdW5kaW5nTW9kZShvcHRpb25zLCAndHJ1bmMnKTtcbiAgICAgICAgcm91bmRpbmdNb2RlID0gTmVnYXRlVGVtcG9yYWxSb3VuZGluZ01vZGUocm91bmRpbmdNb2RlKTtcbiAgICAgICAgY29uc3Qgcm91bmRpbmdJbmNyZW1lbnQgPSBUb1RlbXBvcmFsRGF0ZVRpbWVSb3VuZGluZ0luY3JlbWVudChvcHRpb25zLCBzbWFsbGVzdFVuaXQpO1xuICAgICAgICBjb25zdCBuczEgPSBHZXRTbG90KHRoaXMsIEVQT0NITkFOT1NFQ09ORFMpO1xuICAgICAgICBjb25zdCBuczIgPSBHZXRTbG90KG90aGVyLCBFUE9DSE5BTk9TRUNPTkRTKTtcbiAgICAgICAgbGV0IHllYXJzLCBtb250aHMsIHdlZWtzLCBkYXlzLCBob3VycywgbWludXRlcywgc2Vjb25kcywgbWlsbGlzZWNvbmRzLCBtaWNyb3NlY29uZHMsIG5hbm9zZWNvbmRzO1xuICAgICAgICBpZiAobGFyZ2VzdFVuaXQgIT09ICd5ZWFyJyAmJiBsYXJnZXN0VW5pdCAhPT0gJ21vbnRoJyAmJiBsYXJnZXN0VW5pdCAhPT0gJ3dlZWsnICYmIGxhcmdlc3RVbml0ICE9PSAnZGF5Jykge1xuICAgICAgICAgICAgLy8gVGhlIHVzZXIgaXMgb25seSBhc2tpbmcgZm9yIGEgdGltZSBkaWZmZXJlbmNlLCBzbyByZXR1cm4gZGlmZmVyZW5jZSBvZiBpbnN0YW50cy5cbiAgICAgICAgICAgIHllYXJzID0gMDtcbiAgICAgICAgICAgIG1vbnRocyA9IDA7XG4gICAgICAgICAgICB3ZWVrcyA9IDA7XG4gICAgICAgICAgICBkYXlzID0gMDtcbiAgICAgICAgICAgICh7IHNlY29uZHMsIG1pbGxpc2Vjb25kcywgbWljcm9zZWNvbmRzLCBuYW5vc2Vjb25kcyB9ID0gRGlmZmVyZW5jZUluc3RhbnQobnMxLCBuczIsIHJvdW5kaW5nSW5jcmVtZW50LCBzbWFsbGVzdFVuaXQsIHJvdW5kaW5nTW9kZSkpO1xuICAgICAgICAgICAgKHsgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc2Vjb25kcywgbWljcm9zZWNvbmRzLCBuYW5vc2Vjb25kcyB9ID0gQmFsYW5jZUR1cmF0aW9uKDAsIDAsIDAsIHNlY29uZHMsIG1pbGxpc2Vjb25kcywgbWljcm9zZWNvbmRzLCBuYW5vc2Vjb25kcywgbGFyZ2VzdFVuaXQpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHRpbWVab25lID0gR2V0U2xvdCh0aGlzLCBUSU1FX1pPTkUpO1xuICAgICAgICAgICAgaWYgKCFUaW1lWm9uZUVxdWFscyh0aW1lWm9uZSwgR2V0U2xvdChvdGhlciwgVElNRV9aT05FKSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIldoZW4gY2FsY3VsYXRpbmcgZGlmZmVyZW5jZSBiZXR3ZWVuIHRpbWUgem9uZXMsIGxhcmdlc3RVbml0IG11c3QgYmUgJ2hvdXJzJyBcIiArXG4gICAgICAgICAgICAgICAgICAgICdvciBzbWFsbGVyIGJlY2F1c2UgZGF5IGxlbmd0aHMgY2FuIHZhcnkgYmV0d2VlbiB0aW1lIHpvbmVzIGR1ZSB0byBEU1Qgb3IgdGltZSB6b25lIG9mZnNldCBjaGFuZ2VzLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdW50aWxPcHRpb25zID0geyAuLi5vcHRpb25zLCBsYXJnZXN0VW5pdCB9O1xuICAgICAgICAgICAgKHsgeWVhcnMsIG1vbnRocywgd2Vla3MsIGRheXMsIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBtaWxsaXNlY29uZHMsIG1pY3Jvc2Vjb25kcywgbmFub3NlY29uZHMgfSA9XG4gICAgICAgICAgICAgICAgRGlmZmVyZW5jZVpvbmVkRGF0ZVRpbWUobnMxLCBuczIsIHRpbWVab25lLCBjYWxlbmRhciwgbGFyZ2VzdFVuaXQsIHVudGlsT3B0aW9ucykpO1xuICAgICAgICAgICAgKHsgeWVhcnMsIG1vbnRocywgd2Vla3MsIGRheXMsIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBtaWxsaXNlY29uZHMsIG1pY3Jvc2Vjb25kcywgbmFub3NlY29uZHMgfSA9XG4gICAgICAgICAgICAgICAgUm91bmREdXJhdGlvbih5ZWFycywgbW9udGhzLCB3ZWVrcywgZGF5cywgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc2Vjb25kcywgbWljcm9zZWNvbmRzLCBuYW5vc2Vjb25kcywgcm91bmRpbmdJbmNyZW1lbnQsIHNtYWxsZXN0VW5pdCwgcm91bmRpbmdNb2RlLCB0aGlzKSk7XG4gICAgICAgICAgICAoeyB5ZWFycywgbW9udGhzLCB3ZWVrcywgZGF5cywgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc2Vjb25kcywgbWljcm9zZWNvbmRzLCBuYW5vc2Vjb25kcyB9ID1cbiAgICAgICAgICAgICAgICBBZGp1c3RSb3VuZGVkRHVyYXRpb25EYXlzKHllYXJzLCBtb250aHMsIHdlZWtzLCBkYXlzLCBob3VycywgbWludXRlcywgc2Vjb25kcywgbWlsbGlzZWNvbmRzLCBtaWNyb3NlY29uZHMsIG5hbm9zZWNvbmRzLCByb3VuZGluZ0luY3JlbWVudCwgc21hbGxlc3RVbml0LCByb3VuZGluZ01vZGUsIHRoaXMpKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBEdXJhdGlvbiA9IEdldEludHJpbnNpYygnJVRlbXBvcmFsLkR1cmF0aW9uJScpO1xuICAgICAgICByZXR1cm4gbmV3IER1cmF0aW9uKC15ZWFycywgLW1vbnRocywgLXdlZWtzLCAtZGF5cywgLWhvdXJzLCAtbWludXRlcywgLXNlY29uZHMsIC1taWxsaXNlY29uZHMsIC1taWNyb3NlY29uZHMsIC1uYW5vc2Vjb25kcyk7XG4gICAgfVxuICAgIHJvdW5kKG9wdGlvbnNQYXJhbSkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxab25lZERhdGVUaW1lKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICBpZiAob3B0aW9uc1BhcmFtID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdvcHRpb25zIHBhcmFtZXRlciBpcyByZXF1aXJlZCcpO1xuICAgICAgICBjb25zdCBvcHRpb25zID0gdHlwZW9mIG9wdGlvbnNQYXJhbSA9PT0gJ3N0cmluZydcbiAgICAgICAgICAgID8gQ3JlYXRlT25lUHJvcE9iamVjdCgnc21hbGxlc3RVbml0Jywgb3B0aW9uc1BhcmFtKVxuICAgICAgICAgICAgOiBHZXRPcHRpb25zT2JqZWN0KG9wdGlvbnNQYXJhbSk7XG4gICAgICAgIGNvbnN0IHNtYWxsZXN0VW5pdCA9IFRvU21hbGxlc3RUZW1wb3JhbFVuaXQob3B0aW9ucywgdW5kZWZpbmVkLCBbJ3llYXInLCAnbW9udGgnLCAnd2VlayddKTtcbiAgICAgICAgaWYgKHNtYWxsZXN0VW5pdCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NtYWxsZXN0VW5pdCBpcyByZXF1aXJlZCcpO1xuICAgICAgICBjb25zdCByb3VuZGluZ01vZGUgPSBUb1RlbXBvcmFsUm91bmRpbmdNb2RlKG9wdGlvbnMsICdoYWxmRXhwYW5kJyk7XG4gICAgICAgIGNvbnN0IG1heGltdW1JbmNyZW1lbnRzID0ge1xuICAgICAgICAgICAgZGF5OiAxLFxuICAgICAgICAgICAgaG91cjogMjQsXG4gICAgICAgICAgICBtaW51dGU6IDYwLFxuICAgICAgICAgICAgc2Vjb25kOiA2MCxcbiAgICAgICAgICAgIG1pbGxpc2Vjb25kOiAxMDAwLFxuICAgICAgICAgICAgbWljcm9zZWNvbmQ6IDEwMDAsXG4gICAgICAgICAgICBuYW5vc2Vjb25kOiAxMDAwXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJvdW5kaW5nSW5jcmVtZW50ID0gVG9UZW1wb3JhbFJvdW5kaW5nSW5jcmVtZW50KG9wdGlvbnMsIG1heGltdW1JbmNyZW1lbnRzW3NtYWxsZXN0VW5pdF0sIGZhbHNlKTtcbiAgICAgICAgLy8gZmlyc3QsIHJvdW5kIHRoZSB1bmRlcmx5aW5nIERhdGVUaW1lIGZpZWxkc1xuICAgICAgICBjb25zdCBkdCA9IGRhdGVUaW1lKHRoaXMpO1xuICAgICAgICBsZXQgeWVhciA9IEdldFNsb3QoZHQsIElTT19ZRUFSKTtcbiAgICAgICAgbGV0IG1vbnRoID0gR2V0U2xvdChkdCwgSVNPX01PTlRIKTtcbiAgICAgICAgbGV0IGRheSA9IEdldFNsb3QoZHQsIElTT19EQVkpO1xuICAgICAgICBsZXQgaG91ciA9IEdldFNsb3QoZHQsIElTT19IT1VSKTtcbiAgICAgICAgbGV0IG1pbnV0ZSA9IEdldFNsb3QoZHQsIElTT19NSU5VVEUpO1xuICAgICAgICBsZXQgc2Vjb25kID0gR2V0U2xvdChkdCwgSVNPX1NFQ09ORCk7XG4gICAgICAgIGxldCBtaWxsaXNlY29uZCA9IEdldFNsb3QoZHQsIElTT19NSUxMSVNFQ09ORCk7XG4gICAgICAgIGxldCBtaWNyb3NlY29uZCA9IEdldFNsb3QoZHQsIElTT19NSUNST1NFQ09ORCk7XG4gICAgICAgIGxldCBuYW5vc2Vjb25kID0gR2V0U2xvdChkdCwgSVNPX05BTk9TRUNPTkQpO1xuICAgICAgICBjb25zdCBEYXRlVGltZSA9IEdldEludHJpbnNpYygnJVRlbXBvcmFsLlBsYWluRGF0ZVRpbWUlJyk7XG4gICAgICAgIGNvbnN0IHRpbWVab25lID0gR2V0U2xvdCh0aGlzLCBUSU1FX1pPTkUpO1xuICAgICAgICBjb25zdCBjYWxlbmRhciA9IEdldFNsb3QodGhpcywgQ0FMRU5EQVIpO1xuICAgICAgICBjb25zdCBkdFN0YXJ0ID0gbmV3IERhdGVUaW1lKEdldFNsb3QoZHQsIElTT19ZRUFSKSwgR2V0U2xvdChkdCwgSVNPX01PTlRIKSwgR2V0U2xvdChkdCwgSVNPX0RBWSksIDAsIDAsIDAsIDAsIDAsIDApO1xuICAgICAgICBjb25zdCBpbnN0YW50U3RhcnQgPSBCdWlsdGluVGltZVpvbmVHZXRJbnN0YW50Rm9yKHRpbWVab25lLCBkdFN0YXJ0LCAnY29tcGF0aWJsZScpO1xuICAgICAgICBjb25zdCBlbmROcyA9IEFkZFpvbmVkRGF0ZVRpbWUoaW5zdGFudFN0YXJ0LCB0aW1lWm9uZSwgY2FsZW5kYXIsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDAsIDAsIDApO1xuICAgICAgICBjb25zdCBkYXlMZW5ndGhOcyA9IEpTQkkuc3VidHJhY3QoZW5kTnMsIEpTQkkuQmlnSW50KEdldFNsb3QoaW5zdGFudFN0YXJ0LCBFUE9DSE5BTk9TRUNPTkRTKSkpO1xuICAgICAgICBpZiAoSlNCSS5lcXVhbChkYXlMZW5ndGhOcywgWkVSTykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdjYW5ub3Qgcm91bmQgYSBab25lZERhdGVUaW1lIGluIGEgY2FsZW5kYXIgd2l0aCB6ZXJvLWxlbmd0aCBkYXlzJyk7XG4gICAgICAgIH1cbiAgICAgICAgKHsgeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kLCBtaWNyb3NlY29uZCwgbmFub3NlY29uZCB9ID0gUm91bmRJU09EYXRlVGltZSh5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQsIG1pY3Jvc2Vjb25kLCBuYW5vc2Vjb25kLCByb3VuZGluZ0luY3JlbWVudCwgc21hbGxlc3RVbml0LCByb3VuZGluZ01vZGUsIFxuICAgICAgICAvLyBEYXlzIGFyZSBndWFyYW50ZWVkIHRvIGJlIHNob3J0ZXIgdGhhbiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUlxuICAgICAgICAvLyAod2hpY2ggY2FuIGhvbGQgdXAgdG8gMTA0IGRheXMgaW4gbmFub3NlY29uZHMpXG4gICAgICAgIEpTQkkudG9OdW1iZXIoZGF5TGVuZ3RoTnMpKSk7XG4gICAgICAgIC8vIE5vdyByZXNldCBhbGwgRGF0ZVRpbWUgZmllbGRzIGJ1dCBsZWF2ZSB0aGUgVGltZVpvbmUuIFRoZSBvZmZzZXQgd2lsbFxuICAgICAgICAvLyBhbHNvIGJlIHJldGFpbmVkIGlmIHRoZSBuZXcgZGF0ZS90aW1lIHZhbHVlcyBhcmUgc3RpbGwgT0sgd2l0aCB0aGUgb2xkXG4gICAgICAgIC8vIG9mZnNldC4gT3RoZXJ3aXNlIHRoZSBvZmZzZXQgd2lsbCBiZSBjaGFuZ2VkIHRvIGJlIGNvbXBhdGlibGUgd2l0aCB0aGVcbiAgICAgICAgLy8gbmV3IGRhdGUvdGltZSB2YWx1ZXMuIElmIERTVCBkaXNhbWJpZ3VhdGlvbiBpcyByZXF1aXJlZCwgdGhlIGBjb21wYXRpYmxlYFxuICAgICAgICAvLyBkaXNhbWJpZ3VhdGlvbiBhbGdvcml0aG0gd2lsbCBiZSB1c2VkLlxuICAgICAgICBjb25zdCBvZmZzZXROcyA9IEdldE9mZnNldE5hbm9zZWNvbmRzRm9yKHRpbWVab25lLCBHZXRTbG90KHRoaXMsIElOU1RBTlQpKTtcbiAgICAgICAgY29uc3QgZXBvY2hOYW5vc2Vjb25kcyA9IEludGVycHJldElTT0RhdGVUaW1lT2Zmc2V0KHllYXIsIG1vbnRoLCBkYXksIGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZCwgbWljcm9zZWNvbmQsIG5hbm9zZWNvbmQsICdvcHRpb24nLCBvZmZzZXROcywgdGltZVpvbmUsICdjb21wYXRpYmxlJywgJ3ByZWZlcicsIFxuICAgICAgICAvKiBtYXRjaE1pbnV0ZSA9ICovIGZhbHNlKTtcbiAgICAgICAgcmV0dXJuIENyZWF0ZVRlbXBvcmFsWm9uZWREYXRlVGltZShlcG9jaE5hbm9zZWNvbmRzLCB0aW1lWm9uZSwgR2V0U2xvdCh0aGlzLCBDQUxFTkRBUikpO1xuICAgIH1cbiAgICBlcXVhbHMob3RoZXJQYXJhbSkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxab25lZERhdGVUaW1lKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICBjb25zdCBvdGhlciA9IFRvVGVtcG9yYWxab25lZERhdGVUaW1lKG90aGVyUGFyYW0pO1xuICAgICAgICBjb25zdCBvbmUgPSBHZXRTbG90KHRoaXMsIEVQT0NITkFOT1NFQ09ORFMpO1xuICAgICAgICBjb25zdCB0d28gPSBHZXRTbG90KG90aGVyLCBFUE9DSE5BTk9TRUNPTkRTKTtcbiAgICAgICAgaWYgKCFKU0JJLmVxdWFsKEpTQkkuQmlnSW50KG9uZSksIEpTQkkuQmlnSW50KHR3bykpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoIVRpbWVab25lRXF1YWxzKEdldFNsb3QodGhpcywgVElNRV9aT05FKSwgR2V0U2xvdChvdGhlciwgVElNRV9aT05FKSkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiBDYWxlbmRhckVxdWFscyhHZXRTbG90KHRoaXMsIENBTEVOREFSKSwgR2V0U2xvdChvdGhlciwgQ0FMRU5EQVIpKTtcbiAgICB9XG4gICAgdG9TdHJpbmcob3B0aW9uc1BhcmFtID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbFpvbmVkRGF0ZVRpbWUodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSBHZXRPcHRpb25zT2JqZWN0KG9wdGlvbnNQYXJhbSk7XG4gICAgICAgIGNvbnN0IHsgcHJlY2lzaW9uLCB1bml0LCBpbmNyZW1lbnQgfSA9IFRvU2Vjb25kc1N0cmluZ1ByZWNpc2lvbihvcHRpb25zKTtcbiAgICAgICAgY29uc3Qgcm91bmRpbmdNb2RlID0gVG9UZW1wb3JhbFJvdW5kaW5nTW9kZShvcHRpb25zLCAndHJ1bmMnKTtcbiAgICAgICAgY29uc3Qgc2hvd0NhbGVuZGFyID0gVG9TaG93Q2FsZW5kYXJPcHRpb24ob3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IHNob3dUaW1lWm9uZSA9IFRvU2hvd1RpbWVab25lTmFtZU9wdGlvbihvcHRpb25zKTtcbiAgICAgICAgY29uc3Qgc2hvd09mZnNldCA9IFRvU2hvd09mZnNldE9wdGlvbihvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIFRlbXBvcmFsWm9uZWREYXRlVGltZVRvU3RyaW5nKHRoaXMsIHByZWNpc2lvbiwgc2hvd0NhbGVuZGFyLCBzaG93VGltZVpvbmUsIHNob3dPZmZzZXQsIHtcbiAgICAgICAgICAgIHVuaXQsXG4gICAgICAgICAgICBpbmNyZW1lbnQsXG4gICAgICAgICAgICByb3VuZGluZ01vZGVcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHRvTG9jYWxlU3RyaW5nKGxvY2FsZXMgPSB1bmRlZmluZWQsIG9wdGlvbnMgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsWm9uZWREYXRlVGltZSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlVGltZUZvcm1hdChsb2NhbGVzLCBvcHRpb25zKS5mb3JtYXQodGhpcyk7XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsWm9uZWREYXRlVGltZSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgcmV0dXJuIFRlbXBvcmFsWm9uZWREYXRlVGltZVRvU3RyaW5nKHRoaXMsICdhdXRvJyk7XG4gICAgfVxuICAgIHZhbHVlT2YoKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3VzZSBjb21wYXJlKCkgb3IgZXF1YWxzKCkgdG8gY29tcGFyZSBUZW1wb3JhbC5ab25lZERhdGVUaW1lJyk7XG4gICAgfVxuICAgIHN0YXJ0T2ZEYXkoKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbFpvbmVkRGF0ZVRpbWUodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIGNvbnN0IGR0ID0gZGF0ZVRpbWUodGhpcyk7XG4gICAgICAgIGNvbnN0IERhdGVUaW1lID0gR2V0SW50cmluc2ljKCclVGVtcG9yYWwuUGxhaW5EYXRlVGltZSUnKTtcbiAgICAgICAgY29uc3QgY2FsZW5kYXIgPSBHZXRTbG90KHRoaXMsIENBTEVOREFSKTtcbiAgICAgICAgY29uc3QgZHRTdGFydCA9IG5ldyBEYXRlVGltZShHZXRTbG90KGR0LCBJU09fWUVBUiksIEdldFNsb3QoZHQsIElTT19NT05USCksIEdldFNsb3QoZHQsIElTT19EQVkpLCAwLCAwLCAwLCAwLCAwLCAwLCBjYWxlbmRhcik7XG4gICAgICAgIGNvbnN0IHRpbWVab25lID0gR2V0U2xvdCh0aGlzLCBUSU1FX1pPTkUpO1xuICAgICAgICBjb25zdCBpbnN0YW50ID0gQnVpbHRpblRpbWVab25lR2V0SW5zdGFudEZvcih0aW1lWm9uZSwgZHRTdGFydCwgJ2NvbXBhdGlibGUnKTtcbiAgICAgICAgcmV0dXJuIENyZWF0ZVRlbXBvcmFsWm9uZWREYXRlVGltZShHZXRTbG90KGluc3RhbnQsIEVQT0NITkFOT1NFQ09ORFMpLCB0aW1lWm9uZSwgY2FsZW5kYXIpO1xuICAgIH1cbiAgICB0b0luc3RhbnQoKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbFpvbmVkRGF0ZVRpbWUodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIGNvbnN0IFRlbXBvcmFsSW5zdGFudCA9IEdldEludHJpbnNpYygnJVRlbXBvcmFsLkluc3RhbnQlJyk7XG4gICAgICAgIHJldHVybiBuZXcgVGVtcG9yYWxJbnN0YW50KEdldFNsb3QodGhpcywgRVBPQ0hOQU5PU0VDT05EUykpO1xuICAgIH1cbiAgICB0b1BsYWluRGF0ZSgpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsWm9uZWREYXRlVGltZSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgcmV0dXJuIFRlbXBvcmFsRGF0ZVRpbWVUb0RhdGUoZGF0ZVRpbWUodGhpcykpO1xuICAgIH1cbiAgICB0b1BsYWluVGltZSgpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsWm9uZWREYXRlVGltZSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgcmV0dXJuIFRlbXBvcmFsRGF0ZVRpbWVUb1RpbWUoZGF0ZVRpbWUodGhpcykpO1xuICAgIH1cbiAgICB0b1BsYWluRGF0ZVRpbWUoKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbFpvbmVkRGF0ZVRpbWUodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIHJldHVybiBkYXRlVGltZSh0aGlzKTtcbiAgICB9XG4gICAgdG9QbGFpblllYXJNb250aCgpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsWm9uZWREYXRlVGltZSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgY29uc3QgY2FsZW5kYXIgPSBHZXRTbG90KHRoaXMsIENBTEVOREFSKTtcbiAgICAgICAgY29uc3QgZmllbGROYW1lcyA9IENhbGVuZGFyRmllbGRzKGNhbGVuZGFyLCBbJ21vbnRoQ29kZScsICd5ZWFyJ10pO1xuICAgICAgICBjb25zdCBmaWVsZHMgPSBUb1RlbXBvcmFsWWVhck1vbnRoRmllbGRzKHRoaXMsIGZpZWxkTmFtZXMpO1xuICAgICAgICByZXR1cm4gWWVhck1vbnRoRnJvbUZpZWxkcyhjYWxlbmRhciwgZmllbGRzKTtcbiAgICB9XG4gICAgdG9QbGFpbk1vbnRoRGF5KCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxab25lZERhdGVUaW1lKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICBjb25zdCBjYWxlbmRhciA9IEdldFNsb3QodGhpcywgQ0FMRU5EQVIpO1xuICAgICAgICBjb25zdCBmaWVsZE5hbWVzID0gQ2FsZW5kYXJGaWVsZHMoY2FsZW5kYXIsIFsnZGF5JywgJ21vbnRoQ29kZSddKTtcbiAgICAgICAgY29uc3QgZmllbGRzID0gVG9UZW1wb3JhbE1vbnRoRGF5RmllbGRzKHRoaXMsIGZpZWxkTmFtZXMpO1xuICAgICAgICByZXR1cm4gTW9udGhEYXlGcm9tRmllbGRzKGNhbGVuZGFyLCBmaWVsZHMpO1xuICAgIH1cbiAgICBnZXRJU09GaWVsZHMoKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbFpvbmVkRGF0ZVRpbWUodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIGNvbnN0IGR0ID0gZGF0ZVRpbWUodGhpcyk7XG4gICAgICAgIGNvbnN0IHR6ID0gR2V0U2xvdCh0aGlzLCBUSU1FX1pPTkUpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY2FsZW5kYXI6IEdldFNsb3QodGhpcywgQ0FMRU5EQVIpLFxuICAgICAgICAgICAgaXNvRGF5OiBHZXRTbG90KGR0LCBJU09fREFZKSxcbiAgICAgICAgICAgIGlzb0hvdXI6IEdldFNsb3QoZHQsIElTT19IT1VSKSxcbiAgICAgICAgICAgIGlzb01pY3Jvc2Vjb25kOiBHZXRTbG90KGR0LCBJU09fTUlDUk9TRUNPTkQpLFxuICAgICAgICAgICAgaXNvTWlsbGlzZWNvbmQ6IEdldFNsb3QoZHQsIElTT19NSUxMSVNFQ09ORCksXG4gICAgICAgICAgICBpc29NaW51dGU6IEdldFNsb3QoZHQsIElTT19NSU5VVEUpLFxuICAgICAgICAgICAgaXNvTW9udGg6IEdldFNsb3QoZHQsIElTT19NT05USCksXG4gICAgICAgICAgICBpc29OYW5vc2Vjb25kOiBHZXRTbG90KGR0LCBJU09fTkFOT1NFQ09ORCksXG4gICAgICAgICAgICBpc29TZWNvbmQ6IEdldFNsb3QoZHQsIElTT19TRUNPTkQpLFxuICAgICAgICAgICAgaXNvWWVhcjogR2V0U2xvdChkdCwgSVNPX1lFQVIpLFxuICAgICAgICAgICAgb2Zmc2V0OiBCdWlsdGluVGltZVpvbmVHZXRPZmZzZXRTdHJpbmdGb3IodHosIEdldFNsb3QodGhpcywgSU5TVEFOVCkpLFxuICAgICAgICAgICAgdGltZVpvbmU6IHR6XG4gICAgICAgIH07XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tKGl0ZW0sIG9wdGlvbnNQYXJhbSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCBvcHRpb25zID0gR2V0T3B0aW9uc09iamVjdChvcHRpb25zUGFyYW0pO1xuICAgICAgICBpZiAoSXNUZW1wb3JhbFpvbmVkRGF0ZVRpbWUoaXRlbSkpIHtcbiAgICAgICAgICAgIFRvVGVtcG9yYWxPdmVyZmxvdyhvcHRpb25zKTsgLy8gdmFsaWRhdGUgYW5kIGlnbm9yZVxuICAgICAgICAgICAgVG9UZW1wb3JhbERpc2FtYmlndWF0aW9uKG9wdGlvbnMpO1xuICAgICAgICAgICAgVG9UZW1wb3JhbE9mZnNldChvcHRpb25zLCAncmVqZWN0Jyk7XG4gICAgICAgICAgICByZXR1cm4gQ3JlYXRlVGVtcG9yYWxab25lZERhdGVUaW1lKEdldFNsb3QoaXRlbSwgRVBPQ0hOQU5PU0VDT05EUyksIEdldFNsb3QoaXRlbSwgVElNRV9aT05FKSwgR2V0U2xvdChpdGVtLCBDQUxFTkRBUikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBUb1RlbXBvcmFsWm9uZWREYXRlVGltZShpdGVtLCBvcHRpb25zKTtcbiAgICB9XG4gICAgc3RhdGljIGNvbXBhcmUob25lUGFyYW0sIHR3b1BhcmFtKSB7XG4gICAgICAgIGNvbnN0IG9uZSA9IFRvVGVtcG9yYWxab25lZERhdGVUaW1lKG9uZVBhcmFtKTtcbiAgICAgICAgY29uc3QgdHdvID0gVG9UZW1wb3JhbFpvbmVkRGF0ZVRpbWUodHdvUGFyYW0pO1xuICAgICAgICBjb25zdCBuczEgPSBHZXRTbG90KG9uZSwgRVBPQ0hOQU5PU0VDT05EUyk7XG4gICAgICAgIGNvbnN0IG5zMiA9IEdldFNsb3QodHdvLCBFUE9DSE5BTk9TRUNPTkRTKTtcbiAgICAgICAgaWYgKEpTQkkubGVzc1RoYW4oSlNCSS5CaWdJbnQobnMxKSwgSlNCSS5CaWdJbnQobnMyKSkpXG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIGlmIChKU0JJLmdyZWF0ZXJUaGFuKEpTQkkuQmlnSW50KG5zMSksIEpTQkkuQmlnSW50KG5zMikpKVxuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbn1cbk1ha2VJbnRyaW5zaWNDbGFzcyhab25lZERhdGVUaW1lLCAnVGVtcG9yYWwuWm9uZWREYXRlVGltZScpO1xuZnVuY3Rpb24gZGF0ZVRpbWUoemR0KSB7XG4gICAgcmV0dXJuIEJ1aWx0aW5UaW1lWm9uZUdldFBsYWluRGF0ZVRpbWVGb3IoR2V0U2xvdCh6ZHQsIFRJTUVfWk9ORSksIEdldFNsb3QoemR0LCBJTlNUQU5UKSwgR2V0U2xvdCh6ZHQsIENBTEVOREFSKSk7XG59XG5cbnZhciB0ZW1wb3JhbCA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgSW5zdGFudDogSW5zdGFudCxcbiAgICBDYWxlbmRhcjogQ2FsZW5kYXIsXG4gICAgUGxhaW5EYXRlOiBQbGFpbkRhdGUsXG4gICAgUGxhaW5EYXRlVGltZTogUGxhaW5EYXRlVGltZSxcbiAgICBEdXJhdGlvbjogRHVyYXRpb24sXG4gICAgUGxhaW5Nb250aERheTogUGxhaW5Nb250aERheSxcbiAgICBOb3c6IE5vdyxcbiAgICBQbGFpblRpbWU6IFBsYWluVGltZSxcbiAgICBUaW1lWm9uZTogVGltZVpvbmUsXG4gICAgUGxhaW5ZZWFyTW9udGg6IFBsYWluWWVhck1vbnRoLFxuICAgIFpvbmVkRGF0ZVRpbWU6IFpvbmVkRGF0ZVRpbWVcbn0pO1xuXG5mdW5jdGlvbiB0b1RlbXBvcmFsSW5zdGFudCgpIHtcbiAgICAvLyBPYnNlcnZhYmxlIGFjY2VzcyB0byB2YWx1ZU9mIGlzIG5vdCBjb3JyZWN0IGhlcmUsIGJ1dCB1bmF2b2lkYWJsZVxuICAgIGNvbnN0IGVwb2NoTmFub3NlY29uZHMgPSBKU0JJLm11bHRpcGx5KEpTQkkuQmlnSW50KCt0aGlzKSwgTUlMTElPTik7XG4gICAgcmV0dXJuIG5ldyBJbnN0YW50KFRvQmlnSW50KGVwb2NoTmFub3NlY29uZHMpKTtcbn1cblxuLy8gVGhpcyBlbnRyeSBwb2ludCB0cmVhdHMgVGVtcG9yYWwgYXMgYSBsaWJyYXJ5LCBhbmQgZG9lcyBub3QgcG9seWZpbGwgaXQgb250b1xuLy8gV29yayBhcm91bmQgaHR0cHM6Ly9naXRodWIuY29tL2JhYmVsL2JhYmVsL2lzc3Vlcy8yMDI1LlxuY29uc3QgdHlwZXMgPSBbXG4gICAgSW5zdGFudCxcbiAgICBDYWxlbmRhcixcbiAgICBQbGFpbkRhdGUsXG4gICAgUGxhaW5EYXRlVGltZSxcbiAgICBEdXJhdGlvbixcbiAgICBQbGFpbk1vbnRoRGF5LFxuICAgIC8vIFRlbXBvcmFsLk5vdywgLy8gcGxhaW4gb2JqZWN0IChub3QgYSBjb25zdHJ1Y3RvciksIHNvIG5vIGBwcm90b3R5cGVgXG4gICAgUGxhaW5UaW1lLFxuICAgIFRpbWVab25lLFxuICAgIFBsYWluWWVhck1vbnRoLFxuICAgIFpvbmVkRGF0ZVRpbWVcbl07XG5mb3IgKGNvbnN0IHR5cGUgb2YgdHlwZXMpIHtcbiAgICBjb25zdCBkZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0eXBlLCAncHJvdG90eXBlJyk7XG4gICAgaWYgKGRlc2NyaXB0b3IuY29uZmlndXJhYmxlIHx8IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBkZXNjcmlwdG9yLndyaXRhYmxlKSB7XG4gICAgICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gZmFsc2U7XG4gICAgICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGZhbHNlO1xuICAgICAgICBkZXNjcmlwdG9yLndyaXRhYmxlID0gZmFsc2U7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0eXBlLCAncHJvdG90eXBlJywgZGVzY3JpcHRvcik7XG4gICAgfVxufVxuXG5leHBvcnQgeyBpbnRsIGFzIEludGwsIHRlbXBvcmFsIGFzIFRlbXBvcmFsLCB0b1RlbXBvcmFsSW5zdGFudCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguZXNtLmpzLm1hcFxuIiwiaW1wb3J0IHsgVGVtcG9yYWwgfSBmcm9tIFwiQGpzLXRlbXBvcmFsL3BvbHlmaWxsXCI7XG5cbi8vIDIwMjItMDMtMTZUMDM6NTIgPT4gMDMvMTYvMjAyMiBAIDAzOjUyIEFNXG5leHBvcnQgY29uc3QgZGF0ZUZpbHRlciA9IChkYXRlKSA9PiB7XG4gICAgbGV0IHNwbGl0VGltZUFuZERhdGUgPSBkYXRlLnNwbGl0KCdUJyk7XG4gICAgbGV0IHNwbGl0RGF0ZSA9IHNwbGl0VGltZUFuZERhdGVbMF0uc3BsaXQoJy0nKTtcbiAgICBsZXQgc3BsaXRUaW1lID0gc3BsaXRUaW1lQW5kRGF0ZVsxXS5zcGxpdCgnOicpO1xuICAgIGxldCBmaXhlZEhvdXIgPSAwO1xuICAgIGlmKHNwbGl0VGltZVswXSA+PSAwICYmIHNwbGl0VGltZVswXSA8IDEyKXtcbiAgICAgICAgZml4ZWRIb3VyID0gc3BsaXRUaW1lWzBdKyAnOicgKyBzcGxpdFRpbWVbMV0rJ0FNJztcbiAgICB9XG4gICAgZWxzZXtcbiAgICAgICAgZml4ZWRIb3VyID0gc3BsaXRUaW1lWzBdKyAnOicgKyBzcGxpdFRpbWVbMV0rJ1BNJzsgIFxuICAgIH1cbiAgICBsZXQgZml4ZWREYXRlID0gc3BsaXREYXRlWzFdICsgJy8nICsgc3BsaXREYXRlWzJdICsgJy8nICsgc3BsaXREYXRlWzBdO1xuICAgIGxldCBmaXhlZFRpbWVBbmREYXRlID0gIGZpeGVkRGF0ZSArICcgQCAnICsgZml4ZWRIb3VyO1xuICAgIHJldHVybiBmaXhlZFRpbWVBbmREYXRlO1xufVxuZXhwb3J0IGNvbnN0IGNvbnZlcnREYXRlID0gKGRhdGUpID0+IHtcbiAgICBsZXQgZGRfZGF0ZSA9IGRhdGUudmFsdWUuc3Vic3RyaW5nKDAsIDEwKTtcblxuICAgIGxldCBkZF95ZWFyID0gZGRfZGF0ZS5zdWJzdHJpbmcoMCwgNCk7XG4gICAgbGV0IGRkX21vbnRoID0gZGRfZGF0ZS5zdWJzdHJpbmcoNSwgNyk7XG4gICAgbGV0IGRkX2RheSA9IGRkX2RhdGUuc3Vic3RyaW5nKDgsIDEwKTtcbiAgICBcbiAgICByZXR1cm4geyBkZF9kYXRlLCBkZF95ZWFyLCBkZF9tb250aCwgZGRfZGF5IH07XG59O1xuXG4vLyBUZW1wb3JhbFxuXG5leHBvcnQgY29uc3Qgbm93ID0gKCkgPT4ge1xuICAgIHJldHVybiBUZW1wb3JhbC5Ob3cuem9uZWREYXRlVGltZUlTTygpLnRvUGxhaW5EYXRlVGltZSgpLnJvdW5kKHtzbWFsbGVzdFVuaXQ6IFwibWludXRlXCIsIHJvdW5kaW5nTW9kZTogXCJmbG9vclwifSkudG9TdHJpbmcoKTtcbn07XG5cbmV4cG9ydCBjb25zdCB0b2RheSA9ICgpID0+IHtcbiAgICByZXR1cm4gVGVtcG9yYWwuTm93LnpvbmVkRGF0ZVRpbWVJU08oKS50b1BsYWluRGF0ZSgpLnRvU3RyaW5nKCk7XG59O1xuXG5leHBvcnQgY29uc3QgdGhpc1dlZWsgPSAoKSA9PiB7XG4gICAgbGV0IHRvZGF5ID0gVGVtcG9yYWwuTm93LnpvbmVkRGF0ZVRpbWVJU08oKVxuICAgIGxldCBvbmVXZWVrRnJvbVRvZGF5ID0gdG9kYXkuYWRkKHsgZGF5czogN30pO1xuICAgIHJldHVybiBvbmVXZWVrRnJvbVRvZGF5LnRvUGxhaW5EYXRlKCk7XG59O1xuXG5leHBvcnQgY29uc3QgdG9kYXlDaGVjayA9ICh5ZWFyQ2hlY2ssIG1vbnRoQ2hlY2ssIGRheUNoZWNrKSA9PiB7XG4gICAgcmV0dXJuIFRlbXBvcmFsLlBsYWluRGF0ZS5mcm9tKHt5ZWFyOiB5ZWFyQ2hlY2ssIG1vbnRoOiBtb250aENoZWNrLCBkYXk6IGRheUNoZWNrfSkuZXF1YWxzKHRvZGF5KCkpO1xufTtcblxuZXhwb3J0IGNvbnN0IHRoaXNXZWVrQ2hlY2sgPSAoeWVhckNoZWNrLCBtb250aENoZWNrLCBkYXlDaGVjaykgPT4ge1xuXG4gICAgbGV0IGNvbnZlcnRlZERhdGUgPSBUZW1wb3JhbC5QbGFpbkRhdGUuZnJvbSh7eWVhcjogeWVhckNoZWNrLCBtb250aDogbW9udGhDaGVjaywgZGF5OiBkYXlDaGVja30pO1xuICAgIGxldCBkaWZmZXJlbmNlID0gY29udmVydGVkRGF0ZS51bnRpbCh0aGlzV2VlaygpKS5kYXlzO1xuXG4gICAgaWYgKCtkaWZmZXJlbmNlIDw9IDcgJiYgK2RpZmZlcmVuY2UgPj0gMCl7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBlbHNle1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufTsiLCJpbXBvcnQgeyBUZW1wb3JhbCB9IGZyb20gXCJAanMtdGVtcG9yYWwvcG9seWZpbGxcIjtcbmltcG9ydCB7IHRvZGF5LCB0aGlzV2VlayB9IGZyb20gXCIuL3RpbWVcIjtcblxuZXhwb3J0IGNvbnN0IFRvZG8gPSAodGl0bGUsIGRlc2NyaXB0aW9uLCBkdWVEYXRlLCBwcmlvcml0eSwgaWQpID0+IHtcblxuICAgIGNvbnN0IGdldFRpdGxlID0gKCkgPT4gdGl0bGU7XG4gICAgY29uc3QgZ2V0RGVzY3JpcHRpb24gPSAoKSA9PiBkZXNjcmlwdGlvbjtcbiAgICBjb25zdCBnZXREdWVEYXRlID0gKCkgPT4gZHVlRGF0ZTtcbiAgICBjb25zdCBnZXRQcmlvcml0eSA9ICgpID0+IHByaW9yaXR5O1xuICAgIGNvbnN0IGdldElEID0gKCkgPT4gaWQ7XG5cbiAgICBjb25zdCBzZXRUaXRsZSA9IChuZXdUaXRsZSkgPT4gdGl0bGUgPSBuZXdUaXRsZTsgXG4gICAgY29uc3Qgc2V0RGVzY3JpcHRpb24gPSAobmV3RGVzY3JpcHRpb24pID0+IGRlc2NyaXB0aW9uID0gbmV3RGVzY3JpcHRpb247XG4gICAgY29uc3Qgc2V0RHVlRGF0ZSA9IChuZXdEdWVEYXRlKSA9PiBkdWVEYXRlID0gbmV3RHVlRGF0ZTtcbiAgICBjb25zdCBzZXRQcmlvcml0eSA9IChuZXdQcmlvcml0eSkgPT4gcHJpb3JpdHkgPSBuZXdQcmlvcml0eTtcbiAgICBjb25zdCBzZXRJRCA9IChuZXdJRCkgPT4gaWQgPSBuZXdJRDtcblxuICAgIC8vIHBhc3MgaW4gdmFsdWUgZnJvbSBnZXREdWVEYXRlKCkgdG8gZ2V0IFRlbXBvcmFsLWZyaWVuZGx5IGRhdGUgZm9ybWF0XG4gICAgY29uc3QgY29udmVydGVkRGF0ZSA9IChjYWxlbmRhckRhdGUpID0+IHtcbiAgICAgICAgbGV0IGRkX2RhdGUgPSBjYWxlbmRhckRhdGUuc3Vic3RyaW5nKDAsIDEwKTtcbiAgICAgICAgcmV0dXJuIHsgZGRfZGF0ZSB9O1xuICAgIH07XG5cbiAgICBjb25zdCBpc1RvZGF5Q2hlY2sgPSAoY29udmVydGVkRGF0ZSkgPT4ge1xuICAgICAgICBsZXQgZGF0ZUhvbGRlciA9IGNvbnZlcnRlZERhdGUuZGRfZGF0ZTtcbiAgICAgICAgbGV0IGRhdGUgPSBkYXRlSG9sZGVyLnN1YnN0cmluZygwLCAxMCk7XG4gICAgICAgIGxldCB5ciA9IGRhdGUuc3Vic3RyaW5nKDAsIDQpO1xuICAgICAgICBsZXQgbW9udGggPSBkYXRlLnN1YnN0cmluZyg1LCA3KTtcbiAgICAgICAgbGV0IGRheSA9IGRhdGUuc3Vic3RyaW5nKDgsIDEwKTtcbiAgICAgICAgcmV0dXJuIFRlbXBvcmFsLlBsYWluRGF0ZS5mcm9tKHt5ZWFyOiB5ciwgbW9udGg6IG1vbnRoLCBkYXk6IGRheX0pLmVxdWFscyh0b2RheSgpKTtcbiAgICB9O1xuXG4gICAgY29uc3QgaXNUaGlzV2Vla0NoZWNrID0gKGNvbnZlcnRlZERhdGUpID0+IHtcbiAgICAgICAgbGV0IGRhdGVIb2xkZXIgPSBjb252ZXJ0ZWREYXRlLmRkX2RhdGU7XG4gICAgICAgIGxldCBkYXRlID0gZGF0ZUhvbGRlci5zdWJzdHJpbmcoMCwgMTApO1xuICAgICAgICBsZXQgeXIgPSBkYXRlLnN1YnN0cmluZygwLCA0KTtcbiAgICAgICAgbGV0IG1vbnRoID0gZGF0ZS5zdWJzdHJpbmcoNSwgNyk7XG4gICAgICAgIGxldCBkYXkgPSBkYXRlLnN1YnN0cmluZyg4LCAxMCk7XG5cbiAgICAgICAgbGV0IHRlbXBvcmFsRGF0ZUZvcm1hdCA9IFRlbXBvcmFsLlBsYWluRGF0ZS5mcm9tKHt5ZWFyOiB5ciwgbW9udGg6IG1vbnRoLCBkYXk6IGRheX0pO1xuICAgICAgICBsZXQgZGlmZmVyZW5jZSA9IHRlbXBvcmFsRGF0ZUZvcm1hdC51bnRpbCh0aGlzV2VlaygpKS5kYXlzO1xuXG4gICAgICAgIGlmICgrZGlmZmVyZW5jZSA8PSA3ICYmICtkaWZmZXJlbmNlID49IDApe1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZXtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4geyBnZXRUaXRsZSwgZ2V0RGVzY3JpcHRpb24sIGdldER1ZURhdGUsIGdldFByaW9yaXR5LCBnZXRJRCwgc2V0VGl0bGUsIHNldERlc2NyaXB0aW9uLCBcbiAgICAgICAgc2V0RHVlRGF0ZSwgc2V0UHJpb3JpdHksIHNldElELCBjb252ZXJ0ZWREYXRlLCBpc1RvZGF5Q2hlY2ssIGlzVGhpc1dlZWtDaGVjaywgXG4gICAgfTtcbn07IiwiZXhwb3J0IGNvbnN0IFByb2plY3QgPSAodGl0bGUsIGluZGV4KSA9PiB7XG5cbiAgICBsZXQgYXJyID0gW107XG5cbiAgICBjb25zdCBnZXRUaXRsZSA9ICgpID0+IHRpdGxlO1xuICAgIGNvbnN0IGdldEluZGV4ID0gKCkgPT4gaW5kZXg7XG4gICAgXG4gICAgY29uc3Qgc2V0VGl0bGUgPSAobmV3VGl0bGUpID0+IHRpdGxlID0gbmV3VGl0bGU7IFxuICAgIGNvbnN0IHNldEluZGV4ID0gKG5ld0luZGV4KSA9PiBpbmRleCA9IG5ld0luZGV4O1xuXG4gICAgY29uc3QgYWRkVG9MaXN0ID0gKG9iaikgPT4gYXJyLnB1c2gob2JqKTtcbiAgICBjb25zdCByZW1vdmVGcm9tTGlzdCA9ICh0YXJnZXRJRCkgPT4ge1xuICAgICAgICBsZXQgaW5kZXg7XG4gICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgaWYgKGFycltpXS5nZXRJRCgpID09IHRhcmdldElEKXtcbiAgICAgICAgICAgICAgICBpbmRleCA9IGk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZihpbmRleCA+IC0xKXtcbiAgICAgICAgICAgICAgICBhcnIuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBjb25zdCBmaWx0ZXJUb2RheXNUb0RvcyA9ICgpID0+IHtcbiAgICAgICAgY29uc3QgdG9kYXlzVG9Eb3MgPSBhcnIuZmlsdGVyKHRvRG8gPT4gdG9Eby5pc1RvZGF5Q2hlY2sodG9Eby5jb252ZXJ0ZWREYXRlKHRvRG8uZ2V0RHVlRGF0ZSgpKSkpO1xuICAgICAgICByZXR1cm4gdG9kYXlzVG9Eb3M7XG4gICAgfTtcbiAgICBjb25zdCBmaWx0ZXJUaGlzV2Vla3NUb0RvcyA9ICgpID0+IHtcbiAgICAgICAgY29uc3QgdGhpc1dlZWtzVG9Eb3MgPSBhcnIuZmlsdGVyKHRvRG8gPT4gdG9Eby5pc1RoaXNXZWVrQ2hlY2sodG9Eby5jb252ZXJ0ZWREYXRlKHRvRG8uZ2V0RHVlRGF0ZSgpKSkpO1xuICAgICAgICByZXR1cm4gdGhpc1dlZWtzVG9Eb3M7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtnZXRUaXRsZSwgZ2V0SW5kZXgsIHNldFRpdGxlLCBcbiAgICAgICAgc2V0SW5kZXgsIGFyciwgYWRkVG9MaXN0LCByZW1vdmVGcm9tTGlzdCxcbiAgICAgICAgZmlsdGVyVG9kYXlzVG9Eb3MsIGZpbHRlclRoaXNXZWVrc1RvRG9zLFxuICAgIH07XG59OyIsImltcG9ydCB7IFByb2plY3QgfSBmcm9tICcuL3Byb2plY3QnO1xuaW1wb3J0IHsgVG9kbyB9IGZyb20gJy4vdG9kbyc7XG5cblxuLy8gbG9jYWxTdG9yYWdlLmNsZWFyKCk7XG5cbmNvbnN0IGxpc3RPZlByb2plY3RzID0gSlNPTi5wYXJzZShsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnbGlzdHMnKSkgfHwgW107XG5sZXQgY3VycmVudFByb2plY3RJbmRleCA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdsaXN0SUQnKSB8fCAwO1xuXG5sZXQgYSA9IFRvZG8oJ2hpJywgJ2hpJywgJzIwMjItMDMtMjJUMDM6NDUnLCAnSGlnaCcsIDEwKTtcblxubGV0IHByb2plY3RDb3VudCA9IDA7XG5cbmNvbnN0IGRlZmF1bHRQcm9qID0gUHJvamVjdChcIkdlbmVyYWxcIiwgcHJvamVjdENvdW50KTtcbnByb2plY3RDb3VudCsrO1xubGlzdE9mUHJvamVjdHMucHVzaChkZWZhdWx0UHJvaik7XG5cbmNvbnN0IGV2ZXJ5dGhpbmdQcm9qID0gUHJvamVjdChcIkV2ZXJ5dGhpbmdcIiwgcHJvamVjdENvdW50KTtcbnByb2plY3RDb3VudCsrO1xuZXZlcnl0aGluZ1Byb2ouYWRkVG9MaXN0KGEpO1xubGlzdE9mUHJvamVjdHMucHVzaChldmVyeXRoaW5nUHJvaik7XG5cbmNvbnN0IHRvZGF5c1RvRG9zID0gUHJvamVjdChcIlRvZGF5J3MgMkRvc1wiLCBwcm9qZWN0Q291bnQpO1xucHJvamVjdENvdW50Kys7XG5saXN0T2ZQcm9qZWN0cy5wdXNoKHRvZGF5c1RvRG9zKTtcblxuY29uc3QgdGhpc1dlZWtzVG9Eb3MgPSBQcm9qZWN0KFwiV2VlaydzIDJEb3NcIiwgcHJvamVjdENvdW50KTtcbnByb2plY3RDb3VudCsrO1xubGlzdE9mUHJvamVjdHMucHVzaCh0aGlzV2Vla3NUb0Rvcyk7XG5cblxuZXhwb3J0IGRlZmF1bHQge1xuICAgIGxpc3RPZlByb2plY3RzLCBjdXJyZW50UHJvamVjdEluZGV4LCBwcm9qZWN0Q291bnQsXG4gICAgZGVmYXVsdFByb2osIHRvZGF5c1RvRG9zLCB0aGlzV2Vla3NUb0Rvc1xufTsiLCJleHBvcnQgY29uc3QgY3JlYXRlUHJvamVjdE1vZGFsID0gKCkgPT4ge1xuICAgIFxuICAgIGNvbnN0IG5ld01vZGFsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGlhbG9nJyk7XG4gICAgbmV3TW9kYWwuY2xhc3NMaXN0LmFkZCgncHJvamVjdE1vZGFsJyk7XG4gICAgbmV3TW9kYWwuc2V0QXR0cmlidXRlKCdpZCcsICdwcm9qZWN0TW9kYWwnKTtcblxuICAgIGNvbnN0IHByb2plY3RNb2RhbEhlYWRlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2gyJyk7XG4gICAgcHJvamVjdE1vZGFsSGVhZGVyLnRleHRDb250ZW50ID0gJ05ldyBQcm9qZWN0JztcblxuICAgIGNvbnN0IHByb2plY3RNb2RhbEZvcm0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdmb3JtJyk7XG4gICAgcHJvamVjdE1vZGFsRm9ybS5jbGFzc0xpc3QuYWRkKCdwcm9qZWN0Rm9ybScpO1xuICAgIHByb2plY3RNb2RhbEZvcm0uc2V0QXR0cmlidXRlKCdtZXRob2QnLCAnZGlhbG9nJyk7XG5cbiAgICBjb25zdCBwcm9qZWN0TmFtZURpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGNvbnN0IHByb2plY3ROYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcbiAgICBjb25zdCBwcm9qZWN0TmFtZUxhYmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGFiZWwnKTtcbiAgICBwcm9qZWN0TmFtZS5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCAndGV4dCcpO1xuICAgIHByb2plY3ROYW1lLnNldEF0dHJpYnV0ZSgnbmFtZScsICdwcm9qZWN0TmFtZScpO1xuICAgIHByb2plY3ROYW1lLnNldEF0dHJpYnV0ZSgnaWQnLCAncHJvamVjdE5hbWUnKTtcbiAgICBwcm9qZWN0TmFtZS5zZXRBdHRyaWJ1dGUoJ3BsYWNlaG9sZGVyJywgJ0ZpdG5lc3MnKTtcbiAgICBwcm9qZWN0TmFtZUxhYmVsLnNldEF0dHJpYnV0ZSgnZm9yJywgJ3Byb2plY3ROYW1lJyk7XG4gICAgcHJvamVjdE5hbWVMYWJlbC50ZXh0Q29udGVudCA9ICdUaXRsZSc7XG4gICAgcHJvamVjdE5hbWVEaXYuYXBwZW5kQ2hpbGQocHJvamVjdE5hbWVMYWJlbCk7XG4gICAgcHJvamVjdE5hbWVEaXYuYXBwZW5kQ2hpbGQocHJvamVjdE5hbWUpO1xuXG4gICAgY29uc3QgYnRucyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGJ0bnMuY2xhc3NMaXN0LmFkZCgnYnRucycpO1xuICAgIGNvbnN0IHN1Ym1pdEJ0biA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2J1dHRvbicpO1xuICAgIHN1Ym1pdEJ0bi5pbm5lckhUTUwgPSBgPGkgY2xhc3M9XCJmYS1zb2xpZCBmYS1jaGVja1wiPjwvaT5gO1xuICAgIHN1Ym1pdEJ0bi5jbGFzc0xpc3QuYWRkKCdzdWJtaXRQcm9qZWN0QnRuJyk7XG4gICAgc3VibWl0QnRuLnNldEF0dHJpYnV0ZSgndHlwZScsICdidXR0b24nKTtcbiAgICBjb25zdCBjYW5jZWxCdG4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdidXR0b24nKTtcbiAgICBjYW5jZWxCdG4uaW5uZXJIVE1MID0gYDxpIGNsYXNzPVwiZmEtc29saWQgZmEtYmFuXCI+PC9pPmA7XG4gICAgY2FuY2VsQnRuLmNsYXNzTGlzdC5hZGQoJ2NhbmNlbFByb2plY3RCdG4nKTtcbiAgICBzdWJtaXRCdG4uc2V0QXR0cmlidXRlKCd0eXBlJywgJ2J1dHRvbicpO1xuICAgIGJ0bnMuYXBwZW5kQ2hpbGQoc3VibWl0QnRuKTtcbiAgICBidG5zLmFwcGVuZENoaWxkKGNhbmNlbEJ0bik7XG5cbiAgICBuZXdNb2RhbC5hcHBlbmRDaGlsZChwcm9qZWN0TW9kYWxIZWFkZXIpO1xuICAgIHByb2plY3RNb2RhbEZvcm0uYXBwZW5kQ2hpbGQocHJvamVjdE5hbWVEaXYpO1xuICAgIHByb2plY3RNb2RhbEZvcm0uYXBwZW5kQ2hpbGQoYnRucyk7XG4gICAgbmV3TW9kYWwuYXBwZW5kQ2hpbGQocHJvamVjdE1vZGFsRm9ybSk7XG5cbiAgICByZXR1cm4ge25ld01vZGFsLCBwcm9qZWN0TW9kYWxGb3JtLCBwcm9qZWN0TmFtZSwgc3VibWl0QnRuLCBjYW5jZWxCdG59O1xufTtcblxuXG5leHBvcnQgY29uc3QgY3JlYXRlRWRpdE1vZGFsID0gKG5hbWUsIGRlc2NyaXB0aW9uLCBkdWVEYXRlLCBwcmlvcml0eSkgPT4ge1xuICAgIFxuICAgIGNvbnN0IG5ld01vZGFsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGlhbG9nJyk7XG4gICAgbmV3TW9kYWwuY2xhc3NMaXN0LmFkZCgnZWRpdE1vZGFsJyk7XG4gICAgbmV3TW9kYWwuc2V0QXR0cmlidXRlKCdpZCcsICdlZGl0TW9kYWwnKTtcblxuICAgIGNvbnN0IGVkaXRNb2RhbEhlYWRlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2gyJyk7XG4gICAgZWRpdE1vZGFsSGVhZGVyLnRleHRDb250ZW50ID0gJ0VkaXQgVGFzayc7XG5cbiAgICBjb25zdCBlZGl0TW9kYWxGb3JtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZm9ybScpO1xuICAgIGVkaXRNb2RhbEZvcm0uY2xhc3NMaXN0LmFkZCgnZWRpdEZvcm0nKTtcbiAgICBlZGl0TW9kYWxGb3JtLnNldEF0dHJpYnV0ZSgnbWV0aG9kJywgJ2RpYWxvZycpO1xuXG4gICAgY29uc3QgdGFza05hbWVEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBjb25zdCB0YXNrTmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XG4gICAgY29uc3QgdGFza05hbWVMYWJlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xhYmVsJyk7XG4gICAgdGFza05hbWUuc2V0QXR0cmlidXRlKCd0eXBlJywgJ3RleHQnKTtcbiAgICB0YXNrTmFtZS5zZXRBdHRyaWJ1dGUoJ25hbWUnLCAndGFza05hbWUnKTtcbiAgICB0YXNrTmFtZS5zZXRBdHRyaWJ1dGUoJ2lkJywgJ3Rhc2tOYW1lJyk7XG4gICAgdGFza05hbWUuc2V0QXR0cmlidXRlKCdwbGFjZWhvbGRlcicsICdUYWtlIG91dCB0aGUgdHJhc2gnKTtcbiAgICB0YXNrTmFtZS5zZXRBdHRyaWJ1dGUoJ3ZhbHVlJywgbmFtZSk7XG4gICAgdGFza05hbWVMYWJlbC5zZXRBdHRyaWJ1dGUoJ2ZvcicsICd0YXNrTmFtZScpO1xuICAgIHRhc2tOYW1lTGFiZWwudGV4dENvbnRlbnQgPSAnVGl0bGUnO1xuICAgIHRhc2tOYW1lRGl2LmFwcGVuZENoaWxkKHRhc2tOYW1lTGFiZWwpO1xuICAgIHRhc2tOYW1lRGl2LmFwcGVuZENoaWxkKHRhc2tOYW1lKTtcblxuICAgIGNvbnN0IHRhc2tEZXNjcmlwdGlvbkRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGNvbnN0IHRhc2tEZXNjcmlwdGlvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RleHRhcmVhJyk7XG4gICAgY29uc3QgdGFza0Rlc2NyaXB0aW9uTGFiZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsYWJlbCcpO1xuICAgIHRhc2tEZXNjcmlwdGlvbi5zZXRBdHRyaWJ1dGUoJ25hbWUnLCAndGFza0Rlc2NyaXB0aW9uJyk7XG4gICAgdGFza0Rlc2NyaXB0aW9uLnNldEF0dHJpYnV0ZSgnaWQnLCAndGFza0Rlc2NyaXB0aW9uJyk7XG4gICAgdGFza0Rlc2NyaXB0aW9uLnNldEF0dHJpYnV0ZSgncGxhY2Vob2xkZXInLCAnSSBhdm9pZCB0aGUgYWN1bXVsYXRpb24gb2YgdHJhc2ggYnkgcGVyZm9ybWluZyB0aGUgc2FjcmVkIGFydCBvZiByZW1vdmluZyBzYWlkIHRyYXNoLi4uJyk7XG4gICAgdGFza0Rlc2NyaXB0aW9uLnZhbHVlID0gZGVzY3JpcHRpb247XG4gICAgdGFza0Rlc2NyaXB0aW9uTGFiZWwuc2V0QXR0cmlidXRlKCdmb3InLCAndGFza0Rlc2NyaXB0aW9uJyk7XG4gICAgdGFza0Rlc2NyaXB0aW9uTGFiZWwudGV4dENvbnRlbnQgPSAnRGVzY3JpcHRpb24nO1xuICAgIHRhc2tEZXNjcmlwdGlvbkRpdi5hcHBlbmRDaGlsZCh0YXNrRGVzY3JpcHRpb25MYWJlbCk7XG4gICAgdGFza0Rlc2NyaXB0aW9uRGl2LmFwcGVuZENoaWxkKHRhc2tEZXNjcmlwdGlvbik7XG5cbiAgICBjb25zdCB0YXNrRHVlRGF0ZURpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGNvbnN0IHRhc2tEdWVEYXRlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcbiAgICBjb25zdCB0YXNrRHVlRGF0ZUxhYmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGFiZWwnKTtcbiAgICB0YXNrRHVlRGF0ZS5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCAnZGF0ZXRpbWUtbG9jYWwnKTtcbiAgICB0YXNrRHVlRGF0ZS5zZXRBdHRyaWJ1dGUoJ25hbWUnLCAndGFza0R1ZURhdGUnKTtcbiAgICB0YXNrRHVlRGF0ZS5zZXRBdHRyaWJ1dGUoJ2lkJywgJ3Rhc2tEdWVEYXRlJyk7XG4gICAgdGFza0R1ZURhdGUuc2V0QXR0cmlidXRlKCd2YWx1ZScsIGR1ZURhdGUpO1xuICAgIHRhc2tEdWVEYXRlTGFiZWwuc2V0QXR0cmlidXRlKCdmb3InLCAndGFza0R1ZURhdGUnKTtcbiAgICB0YXNrRHVlRGF0ZUxhYmVsLnRleHRDb250ZW50ID0gJ0R1ZSBEYXRlJztcbiAgICB0YXNrRHVlRGF0ZURpdi5hcHBlbmRDaGlsZCh0YXNrRHVlRGF0ZUxhYmVsKTtcbiAgICB0YXNrRHVlRGF0ZURpdi5hcHBlbmRDaGlsZCh0YXNrRHVlRGF0ZSk7XG5cbiAgICBjb25zdCB0YXNrUHJpb3JpdHlEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBjb25zdCB0YXNrUHJpb3JpdHkgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzZWxlY3QnKTtcbiAgICBjb25zdCB0YXNrUHJpb3JpdHlMYWJlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xhYmVsJyk7XG4gICAgdGFza1ByaW9yaXR5LnNldEF0dHJpYnV0ZSgnbmFtZScsICd0YXNrUHJpb3JpdHknKTtcbiAgICB0YXNrUHJpb3JpdHkuc2V0QXR0cmlidXRlKCdpZCcsICd0YXNrUHJpb3JpdHlFZGl0Jyk7XG4gICAgdGFza1ByaW9yaXR5TGFiZWwuc2V0QXR0cmlidXRlKCdmb3InLCAndGFza1ByaW9yaXR5Jyk7XG4gICAgdGFza1ByaW9yaXR5TGFiZWwudGV4dENvbnRlbnQgPSAnUHJpb3JpdHknO1xuICAgIGNvbnN0IGhpZ2hQcmlvcml0eSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ29wdGlvbicpO1xuICAgIGhpZ2hQcmlvcml0eS50ZXh0Q29udGVudCA9ICdIaWdoJztcbiAgICBjb25zdCBub3JtYWxQcmlvcml0eSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ29wdGlvbicpO1xuICAgIG5vcm1hbFByaW9yaXR5LnRleHRDb250ZW50ID0gJ05vcm1hbCc7XG4gICAgY29uc3QgbG93UHJpb3JpdHkgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdvcHRpb24nKTtcbiAgICBsb3dQcmlvcml0eS50ZXh0Q29udGVudCA9ICdMb3cnO1xuXG4gICAgdGFza1ByaW9yaXR5LmFwcGVuZENoaWxkKGhpZ2hQcmlvcml0eSk7XG4gICAgdGFza1ByaW9yaXR5LmFwcGVuZENoaWxkKG5vcm1hbFByaW9yaXR5KTtcbiAgICB0YXNrUHJpb3JpdHkuYXBwZW5kQ2hpbGQobG93UHJpb3JpdHkpO1xuXG4gICAgdGFza1ByaW9yaXR5LnZhbHVlID0gcHJpb3JpdHk7XG4gICAgXG4gICAgdGFza1ByaW9yaXR5RGl2LmFwcGVuZENoaWxkKHRhc2tQcmlvcml0eUxhYmVsKTtcbiAgICB0YXNrUHJpb3JpdHlEaXYuYXBwZW5kQ2hpbGQodGFza1ByaW9yaXR5KTtcblxuICAgIGNvbnN0IGJ0bnMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBidG5zLmNsYXNzTGlzdC5hZGQoJ2J0bnMnKTtcbiAgICBjb25zdCBzdWJtaXRCdG4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdidXR0b24nKTtcbiAgICBzdWJtaXRCdG4uaW5uZXJIVE1MID0gYDxpIGNsYXNzPVwiZmEtc29saWQgZmEtY2hlY2tcIj48L2k+YDtcbiAgICBzdWJtaXRCdG4uY2xhc3NMaXN0LmFkZCgnc3VibWl0RWRpdEJ0bicpO1xuICAgIHN1Ym1pdEJ0bi5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCAnYnV0dG9uJyk7XG4gICAgY29uc3QgY2FuY2VsQnRuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYnV0dG9uJyk7XG4gICAgY2FuY2VsQnRuLmlubmVySFRNTCA9IGA8aSBjbGFzcz1cImZhLXNvbGlkIGZhLWJhblwiPjwvaT5gO1xuICAgIGNhbmNlbEJ0bi5jbGFzc0xpc3QuYWRkKCdjYW5jZWxFZGl0QnRuJyk7XG4gICAgc3VibWl0QnRuLnNldEF0dHJpYnV0ZSgndHlwZScsICdidXR0b24nKTtcbiAgICBidG5zLmFwcGVuZENoaWxkKHN1Ym1pdEJ0bik7XG4gICAgYnRucy5hcHBlbmRDaGlsZChjYW5jZWxCdG4pO1xuXG4gICAgbmV3TW9kYWwuYXBwZW5kQ2hpbGQoZWRpdE1vZGFsSGVhZGVyKTtcbiAgICBlZGl0TW9kYWxGb3JtLmFwcGVuZENoaWxkKHRhc2tOYW1lRGl2KTtcbiAgICBlZGl0TW9kYWxGb3JtLmFwcGVuZENoaWxkKHRhc2tEZXNjcmlwdGlvbkRpdik7XG4gICAgZWRpdE1vZGFsRm9ybS5hcHBlbmRDaGlsZCh0YXNrRHVlRGF0ZURpdik7XG4gICAgZWRpdE1vZGFsRm9ybS5hcHBlbmRDaGlsZCh0YXNrUHJpb3JpdHlEaXYpO1xuICAgIGVkaXRNb2RhbEZvcm0uYXBwZW5kQ2hpbGQoYnRucyk7XG4gICAgbmV3TW9kYWwuYXBwZW5kQ2hpbGQoZWRpdE1vZGFsRm9ybSk7XG5cbiAgICByZXR1cm4ge25ld01vZGFsLCBlZGl0TW9kYWxGb3JtLCB0YXNrTmFtZSwgdGFza0R1ZURhdGUsIHRhc2tQcmlvcml0eSwgXG4gICAgICAgIHRhc2tEZXNjcmlwdGlvbiwgc3VibWl0QnRuLCBjYW5jZWxCdG59O1xufTsiLCJpbXBvcnQgXyBmcm9tICcuL2RvY3VtZW50UGFydHMnO1xuaW1wb3J0IGRlZmF1bHRzIGZyb20gJy4vZGVmYXVsdFByb2plY3RzJztcbmltcG9ydCB7IGFkZFRvRG9Ub1RhYmxlIH0gZnJvbSAnLi9hZGRUb0RvJztcbmltcG9ydCB7IGNyZWF0ZUVkaXRNb2RhbCwgY3JlYXRlUHJvamVjdE1vZGFsIH0gZnJvbSAnLi9jcmVhdGVNb2RhbHMnO1xuaW1wb3J0IHsgZGF0ZUZpbHRlciwgbm93IH0gZnJvbSAnLi90aW1lJztcbmltcG9ydCB7IFByb2plY3QgfSBmcm9tICcuL3Byb2plY3QnO1xuXG5leHBvcnQgY29uc3QgYWRkRXZlbnRMaXN0ZW5lcnMgPSAoKSA9PiB7XG4gICAgLy8gcmVtb3ZlIHRvRG9cbiAgICBjb25zdCB0cmFzaEJ0bnMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcuZmEtdHJhc2gtY2FuJyk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0cmFzaEJ0bnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdHJhc2hCdG5zW2ldLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZGVsZXRlVG9Ebyk7XG4gICAgfVxuICAgIC8vIG1hcmsgY29tcGxldGVcbiAgICBjb25zdCB1bmNoZWNrZWRCb3hlcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5mYS1zcXVhcmUnKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHVuY2hlY2tlZEJveGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHVuY2hlY2tlZEJveGVzW2ldLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgY29tcGxldGVUb0RvKTtcbiAgICB9XG4gICAgLy8gbWFyayBpbmNvbXBsZXRlXG4gICAgY29uc3QgY2hlY2tlZEJveGVzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLmZhLXNxdWFyZS1jaGVjaycpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hlY2tlZEJveGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNoZWNrZWRCb3hlc1tpXS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHVuZG9Ub0RvQ29tcGxldGlvbik7XG4gICAgfVxuICAgIC8vIGVkaXQgdG9EbyBtb2RhbFxuICAgIGNvbnN0IGVkaXRNb2RhbEJ0bnMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcuZmEtcGVuLXRvLXNxdWFyZScpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZWRpdE1vZGFsQnRucy5sZW5ndGg7IGkrKykge1xuICAgICAgICBlZGl0TW9kYWxCdG5zW2ldLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgaW5zdGFudGlhdGVFZGl0TW9kYWwpO1xuICAgIH1cbiAgICAvLyBjcmVhdGUgdG9EbyBtb2RhbFxuICAgIF8uYWRkVG9Eb0J0bi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGluc3RhbnRpYXRlQ3JlYXRpb25Nb2RhbCk7XG4gICAgLy8gY3JlYXRlIHByb2plY3QgbW9kYWxcbiAgICBfLmFkZFByb2plY3RCdG4uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBpbnN0YW50aWF0ZVByb2plY3RNb2RhbCk7XG4gICAgLy8gcmVtb3ZlIHByb2plY3QgbW9kYWxcbiAgICBjb25zdCByZW1vdmVQcm9qZWN0QnRucyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5mYS1jaXJjbGUtbWludXMnKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlbW92ZVByb2plY3RCdG5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJlbW92ZVByb2plY3RCdG5zW2ldLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgcmVtb3ZlUHJvamVjdCk7XG4gICAgfVxuICAgIFxufTtcblxuXG4vLyBzZWxlY3RlZFByb2plY3QgZXguIGRlZmF1bHRzLmxpc3RPZlByb2plY3RzW2RlZmF1bHRzLmN1cnJlbnRQcm9qZWN0SW5kZXhdXG5fLnNpZGViYXIuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBsb2FkUHJvamVjdCk7XG5cbmV4cG9ydCBmdW5jdGlvbiBsb2FkUHJvamVjdCAoZSkge1xuICAgIGlmKGUudGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucygnb3RoZXJQcm9qZWN0cycpKXtcbiAgICAgICAgLy8gc2V0dXBcbiAgICAgICAgY29uc3QgcHJvakluZGV4ID0gZS50YXJnZXQuZ2V0QXR0cmlidXRlKCdkYXRhLWluZGV4Jyk7XG4gICAgICAgIGRlZmF1bHRzLmN1cnJlbnRQcm9qZWN0SW5kZXggPSBwcm9qSW5kZXg7XG4gICAgICAgIF8udGFibGUudGV4dENvbnRlbnQgPSAnJztcbiAgICAgICAgLy8gZ2VuZXJhdGVUYWJsZUhlYWRlciBcbiAgICAgICAgbGV0IHRyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndHInKTtcbiAgICAgICAgdHIuY2xhc3NMaXN0LmFkZCgndGl0bGVzJyk7XG4gICAgICAgIGxldCB0aFByb2pOYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGgnKTtcbiAgICAgICAgdGhQcm9qTmFtZS5jbGFzc0xpc3QuYWRkKCdwcm9qTmFtZScpO1xuXG4gICAgICAgIGlmIChkZWZhdWx0cy5saXN0T2ZQcm9qZWN0c1tkZWZhdWx0cy5jdXJyZW50UHJvamVjdEluZGV4XS5nZXRUaXRsZSgpLmxlbmd0aCA+IDApe1xuICAgICAgICAgICAgdGhQcm9qTmFtZS50ZXh0Q29udGVudCA9IGRlZmF1bHRzLmxpc3RPZlByb2plY3RzW2RlZmF1bHRzLmN1cnJlbnRQcm9qZWN0SW5kZXhdLmdldFRpdGxlKCkuc3Vic3RyaW5nKDAsMzApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2V7XG4gICAgICAgICAgICB0aFByb2pOYW1lLnRleHRDb250ZW50ID0gJ1VubmFtZWQnO1xuICAgICAgICB9XG4gICAgICAgIGxldCB0aER1ZURhdGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0aCcpO1xuICAgICAgICB0aER1ZURhdGUuY2xhc3NMaXN0LmFkZCgnZHVlRGF0ZScpO1xuICAgICAgICB0aER1ZURhdGUuaW5uZXJIVE1MID0gYER1ZSBEYXRlIDxpIGNsYXNzPVwiZmEtc29saWQgZmEtY2FsZW5kYXItZGF5XCI+PC9pPmA7XG4gICAgICAgIHRyLmFwcGVuZENoaWxkKHRoUHJvak5hbWUpO1xuICAgICAgICB0ci5hcHBlbmRDaGlsZCh0aER1ZURhdGUpO1xuICAgICAgICBfLnRhYmxlLmFwcGVuZENoaWxkKHRyKTtcbiAgICAgICAgLy8gZ2VuZXJhdGUgcm93c1xuICAgICAgICBjb25zdCBtYWtlUm93ID0gKHJvdykgPT4ge1xuICAgICAgICAgICAgY29uc3QgdHIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0cicpO1xuICAgICAgICAgICAgdHIuY2xhc3NMaXN0LmFkZCgnY3JlYXRlZFJvdycpO1xuICAgICAgICAgICAgdHIuc2V0QXR0cmlidXRlKCdkYXRhLWluZGV4JywgYCR7cm93LmdldElEKCl9YCk7XG4gICAgICAgICAgICBjb25zdCB0ZDEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZCcpO1xuICAgICAgICAgICAgY29uc3QgdGQyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGQnKTtcbiAgICAgICAgICAgIHRkMS5jbGFzc0xpc3QuYWRkKCdjb2x1bW4xJyk7XG4gICAgICAgICAgICB0ZDIuY2xhc3NMaXN0LmFkZCgnY29sdW1uMicpO1xuXG4gICAgICAgICAgICBfLnNldFByaW9yaXR5Q29sb3JzKHJvdy5nZXRQcmlvcml0eSgpLCB0ZDEpO1xuICAgIFxuICAgICAgICAgICAgdGQxLmlubmVySFRNTCA9IGA8aSBjbGFzcz1cImZhLXJlZ3VsYXIgZmEtc3F1YXJlXCI+PC9pPiAke3Jvdy5nZXRUaXRsZSgpfWA7XG4gICAgICAgICAgICB0ZDIuaW5uZXJIVE1MID0gYCR7ZGF0ZUZpbHRlcihyb3cuZ2V0RHVlRGF0ZSgpKX0gPGkgY2xhc3M9XCJmYS1yZWd1bGFyIGZhLXBlbi10by1zcXVhcmVcIj48L2k+PGkgY2xhc3M9XCJmYS1yZWd1bGFyIGZhLXRyYXNoLWNhblwiPjwvaT5gO1xuICAgIFxuICAgICAgICAgICAgdHIuYXBwZW5kQ2hpbGQodGQxKTtcbiAgICAgICAgICAgIHRyLmFwcGVuZENoaWxkKHRkMik7XG4gICAgXG4gICAgICAgICAgICByZXR1cm4gdHI7XG4gICAgICAgIH07XG4gICAgXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGVmYXVsdHMubGlzdE9mUHJvamVjdHNbZGVmYXVsdHMuY3VycmVudFByb2plY3RJbmRleF0uYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBfLnRhYmxlLmFwcGVuZENoaWxkKG1ha2VSb3coZGVmYXVsdHMubGlzdE9mUHJvamVjdHNbZGVmYXVsdHMuY3VycmVudFByb2plY3RJbmRleF0uYXJyW2ldKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZighXy50b0RvTGlzdC5jb250YWlucyhfLmFkZFRvRG9CdG4pKXtcbiAgICAgICAgICAgIF8udG9Eb0xpc3QuYXBwZW5kQ2hpbGQoXy5hZGRUb0RvQnRuKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFkZEV2ZW50TGlzdGVuZXJzKClcbiAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICB9XG59O1xuXG5jb25zdCBkZWxldGVUb0RvID0gKGUpID0+IHtcbiAgICBjb25zdCBpdGVtID0gZS50YXJnZXQ7XG4gICAgY29uc3QgdG9kbyA9IGl0ZW0ucGFyZW50RWxlbWVudC5wYXJlbnRFbGVtZW50O1xuICAgIHRvZG8ucmVtb3ZlKCk7XG5cbiAgICBjb25zdCByZW1vdmVGcm9tQXJyYXkgPSAoKSA9PiB7XG4gICAgICAgIGxldCB0YXJnZXRJbmRleCA9IHRvZG8uZ2V0QXR0cmlidXRlKCdkYXRhLWluZGV4Jyk7XG4gICAgICAgIGxldCBsaXN0ID0gZGVmYXVsdHMubGlzdE9mUHJvamVjdHM7XG4gICAgICAgIGxldCBpbmRleCA9IGRlZmF1bHRzLmN1cnJlbnRQcm9qZWN0SW5kZXg7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0W2luZGV4XS5hcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBpZCA9IGxpc3RbaW5kZXhdLmFycltpXS5nZXRJRCgpO1xuICAgICAgICAgICAgaWYgKGlkID09IHRhcmdldEluZGV4KSB7XG4gICAgICAgICAgICAgICAgbGlzdFtpbmRleF0ucmVtb3ZlRnJvbUxpc3QoaWQpO1xuICAgICAgICAgICAgICAgIGxpc3RbMV0ucmVtb3ZlRnJvbUxpc3QoaWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgIH07XG4gICAgcmVtb3ZlRnJvbUFycmF5KCk7XG59O1xuXG5jb25zdCBjb21wbGV0ZVRvRG8gPSAoZSkgPT4ge1xuICAgIGNvbnN0IGl0ZW0gPSBlLnRhcmdldDtcbiAgICBjb25zdCB0b2RvID0gaXRlbS5wYXJlbnRFbGVtZW50LnBhcmVudEVsZW1lbnQ7XG4gICAgdG9kby5jbGFzc0xpc3QuYWRkKCdjb21wbGV0ZWQnKTtcbiAgICB0b2RvLmlubmVySFRNTCA9IHRvZG8uaW5uZXJIVE1MLnJlcGxhY2UoJzxpIGNsYXNzPVwiZmEtcmVndWxhciBmYS1zcXVhcmVcIj48L2k+JywgJzxpIGNsYXNzPVwiZmEtcmVndWxhciBmYS1zcXVhcmUtY2hlY2tcIj48L2k+Jyk7XG4gICAgYWRkRXZlbnRMaXN0ZW5lcnMoKTtcbn07XG5cbmNvbnN0IHVuZG9Ub0RvQ29tcGxldGlvbiA9IChlKSA9PiB7XG4gICAgY29uc3QgaXRlbSA9IGUudGFyZ2V0O1xuICAgIGNvbnN0IHRvZG8gPSBpdGVtLnBhcmVudEVsZW1lbnQucGFyZW50RWxlbWVudDtcbiAgICB0b2RvLmNsYXNzTGlzdC5yZW1vdmUoJ2NvbXBsZXRlZCcpO1xuICAgIHRvZG8uaW5uZXJIVE1MID0gdG9kby5pbm5lckhUTUwucmVwbGFjZSgnPGkgY2xhc3M9XCJmYS1yZWd1bGFyIGZhLXNxdWFyZS1jaGVja1wiPjwvaT4nLCAnPGkgY2xhc3M9XCJmYS1yZWd1bGFyIGZhLXNxdWFyZVwiPjwvaT4nKTtcbiAgICBhZGRFdmVudExpc3RlbmVycygpO1xufTtcblxuY29uc3QgaW5zdGFudGlhdGVFZGl0TW9kYWwgPSAoZSkgPT4ge1xuXG4gICAgY29uc3QgaXRlbSA9IGUudGFyZ2V0O1xuICAgIGNvbnN0IHRvZG8gPSBpdGVtLnBhcmVudEVsZW1lbnQucGFyZW50RWxlbWVudDtcbiAgICBjb25zdCB0YXJnZXRJbmRleCA9IHRvZG8uZ2V0QXR0cmlidXRlKCdkYXRhLWluZGV4Jyk7XG4gICAgY29uc3Qgc2hvcnRIYW5kID0gZGVmYXVsdHMubGlzdE9mUHJvamVjdHNbZGVmYXVsdHMuY3VycmVudFByb2plY3RJbmRleF07XG5cbiAgICBjb25zdCBnZXRUb0RvSW5mbyA9ICgpID0+IHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaG9ydEhhbmQuYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoc2hvcnRIYW5kLmFycltpXS5nZXRJRCgpID09IHRhcmdldEluZGV4KSB7XG4gICAgICAgICAgICAgICAgbGV0IG5hbWUgPSBzaG9ydEhhbmQuYXJyW2ldLmdldFRpdGxlKCk7XG4gICAgICAgICAgICAgICAgbGV0IGRlc2NyaXB0aW9uID0gc2hvcnRIYW5kLmFycltpXS5nZXREZXNjcmlwdGlvbigpO1xuICAgICAgICAgICAgICAgIGxldCBkdWVEYXRlID0gc2hvcnRIYW5kLmFycltpXS5nZXREdWVEYXRlKCk7XG4gICAgICAgICAgICAgICAgbGV0IHByaW9yaXR5ID0gc2hvcnRIYW5kLmFycltpXS5nZXRQcmlvcml0eSgpO1xuICAgICAgICAgICAgICAgIGxldCBpZCA9IGk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgbmFtZSwgZGVzY3JpcHRpb24sIGR1ZURhdGUsIHByaW9yaXR5LCBpZCB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIGNvbnN0IHRvRG9JbmZvID0gZ2V0VG9Eb0luZm8oKTtcbiAgICBjb25zdCBmb3JtID0gY3JlYXRlRWRpdE1vZGFsKHRvRG9JbmZvLm5hbWUsIHRvRG9JbmZvLmRlc2NyaXB0aW9uLFxuICAgICAgICB0b0RvSW5mby5kdWVEYXRlLCB0b0RvSW5mby5wcmlvcml0eSk7XG5cbiAgICBfLmJvZHkuYXBwZW5kQ2hpbGQoZm9ybS5uZXdNb2RhbCk7XG4gICAgZm9ybS5uZXdNb2RhbC5zaG93TW9kYWwoKTtcblxuICAgIGNvbnN0IHN1Ym1pdEVkaXRCdG4gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuc3VibWl0RWRpdEJ0bicpO1xuICAgIGNvbnN0IGNhbmNlbEVkaXRCdG4gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuY2FuY2VsRWRpdEJ0bicpO1xuXG4gICAgY2FuY2VsRWRpdEJ0bi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uIGNhbmNlbEVkaXRNb2RhbChlKSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZm9ybS5uZXdNb2RhbC5jbG9zZSgpO1xuICAgICAgICBfLmJvZHkucmVtb3ZlQ2hpbGQoZm9ybS5uZXdNb2RhbCk7XG4gICAgICAgIGFkZEV2ZW50TGlzdGVuZXJzKCk7XG4gICAgfSk7XG5cbiAgICBzdWJtaXRFZGl0QnRuLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24gc3VibWl0RWRpdE1vZGFsKGUpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgIC8vIHVwZGF0ZSBBcnIgdmFsdWVzXG5cbiAgICAgICAgc2hvcnRIYW5kLmFyclt0b0RvSW5mby5pZF0uc2V0VGl0bGUoZm9ybS50YXNrTmFtZS52YWx1ZSk7XG4gICAgICAgIHNob3J0SGFuZC5hcnJbdG9Eb0luZm8uaWRdLnNldERlc2NyaXB0aW9uKGZvcm0udGFza0Rlc2NyaXB0aW9uLnZhbHVlKTtcbiAgICAgICAgc2hvcnRIYW5kLmFyclt0b0RvSW5mby5pZF0uc2V0RHVlRGF0ZShmb3JtLnRhc2tEdWVEYXRlLnZhbHVlKTtcbiAgICAgICAgc2hvcnRIYW5kLmFyclt0b0RvSW5mby5pZF0uc2V0UHJpb3JpdHkoZm9ybS50YXNrUHJpb3JpdHkudmFsdWUpO1xuXG4gICAgICAgIC8vIHVwZGF0ZSB0YWJsZSB2YWx1ZXNcbiAgICAgICAgdG9kby5jaGlsZHJlblswXS5pbm5lckhUTUwgPSBgPGkgY2xhc3M9XCJmYS1yZWd1bGFyIGZhLXNxdWFyZVwiPjwvaT4gJHtmb3JtLnRhc2tOYW1lLnZhbHVlfWA7XG4gICAgICAgIFxuICAgICAgICBfLnNldFByaW9yaXR5Q29sb3JzKGZvcm0udGFza1ByaW9yaXR5LnZhbHVlLCB0b2RvLmNoaWxkcmVuWzBdKTtcblxuICAgICAgICBpZiAoZm9ybS50YXNrRHVlRGF0ZS52YWx1ZSAhPT0gJycpIHtcbiAgICAgICAgICAgIGxldCBmaWx0ZXJlZER1ZURhdGUgPSBkYXRlRmlsdGVyKGZvcm0udGFza0R1ZURhdGUudmFsdWUpO1xuICAgICAgICAgICAgdG9kby5jaGlsZHJlblsxXS5pbm5lckhUTUwgPSBgJHtmaWx0ZXJlZER1ZURhdGV9IDxpIGNsYXNzPVwiZmEtcmVndWxhciBmYS1wZW4tdG8tc3F1YXJlXCI+PC9pPjxpIGNsYXNzPVwiZmEtcmVndWxhciBmYS10cmFzaC1jYW5cIj48L2k+YDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRvZG8uY2hpbGRyZW5bMV0uaW5uZXJIVE1MID0gYDxpIGNsYXNzPVwiZmEtcmVndWxhciBmYS1wZW4tdG8tc3F1YXJlXCI+PC9pPjxpIGNsYXNzPVwiZmEtcmVndWxhciBmYS10cmFzaC1jYW5cIj48L2k+YDtcbiAgICAgICAgfVxuXG4gICAgICAgIF8uYm9keS5yZW1vdmVDaGlsZChmb3JtLm5ld01vZGFsKTtcbiAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICB9KTtcbn07XG5cbmNvbnN0IGluc3RhbnRpYXRlQ3JlYXRpb25Nb2RhbCA9IChlKSA9PiB7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgXy5tb2RhbC5zaG93TW9kYWwoKTtcblxuICAgIC8vIHNldCBkZWZhdWx0IGRhdGUgdmFsdWUgdG8gbm93XG4gICAgbGV0IGR1ZURhdGUgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjY3JlYXRlVGFza0R1ZURhdGUnKTtcbiAgICBkdWVEYXRlLnNldEF0dHJpYnV0ZShcInZhbHVlXCIsIGAke25vdygpfWApO1xuXG4gICAgXy5tb2RhbENhbmNlbEJ0bi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uIGNhbmNlbENyZWF0aW9uTW9kYWwoKSB7XG4gICAgICAgIF8ubW9kYWwuY2xvc2UoKTtcbiAgICB9KTtcblxuICAgIF8ubW9kYWxTdWJtaXRCdG4uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBhZGRUb0RvVG9UYWJsZSk7XG4gICAgYWRkRXZlbnRMaXN0ZW5lcnMoKTtcbn07XG5cbmNvbnN0IGluc3RhbnRpYXRlUHJvamVjdE1vZGFsID0gKGUpID0+IHtcblxuICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgIGNvbnN0IHByb2ogPSBjcmVhdGVQcm9qZWN0TW9kYWwoKTtcbiAgICBfLmJvZHkuYXBwZW5kQ2hpbGQocHJvai5uZXdNb2RhbCk7XG5cbiAgICBwcm9qLm5ld01vZGFsLnNob3dNb2RhbCgpO1xuXG4gICAgY29uc3Qgc3VibWl0UHJvamVjdEJ0biA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5zdWJtaXRQcm9qZWN0QnRuJyk7XG4gICAgY29uc3QgY2FuY2VsUHJvamVjdEJ0biA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5jYW5jZWxQcm9qZWN0QnRuJyk7XG5cbiAgICBjYW5jZWxQcm9qZWN0QnRuLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24gY2FuY2VsUHJvamVjdE1vZGFsKGUpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBwcm9qLm5ld01vZGFsLmNsb3NlKCk7XG4gICAgICAgIF8uYm9keS5yZW1vdmVDaGlsZChwcm9qLm5ld01vZGFsKTtcbiAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICB9KTtcblxuICAgIHN1Ym1pdFByb2plY3RCdG4uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbiBzdWJtaXRQcm9qZWN0TW9kYWwoZSkge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgLy8gY3JlYXRlIG5ldyBwcm9qZWN0XG4gICAgICAgIGNvbnN0IG5ld1Byb2ogPSBQcm9qZWN0KHByb2oucHJvamVjdE5hbWUudmFsdWUsIGRlZmF1bHRzLnByb2plY3RDb3VudCk7XG4gICAgICAgIGRlZmF1bHRzLnByb2plY3RDb3VudCsrO1xuXG4gICAgICAgIHByb2oubmV3TW9kYWwuY2xvc2UoKTtcbiAgICAgICAgXy5ib2R5LnJlbW92ZUNoaWxkKHByb2oubmV3TW9kYWwpO1xuXG4gICAgICAgIC8vIGFkZCBuZXcgcHJvamVjdCB0byBwcm9qZWN0c1xuXG4gICAgICAgIGRlZmF1bHRzLmxpc3RPZlByb2plY3RzLnB1c2gobmV3UHJvaik7XG5cbiAgICAgICAgLy8gdXBkYXRlIGh0bWwgdG8gc2hvdyBwcm9qZWN0XG5cbiAgICAgICAgY29uc3QgbGkgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsaScpO1xuICAgICAgICBsaS5jbGFzc0xpc3QuYWRkKCdwcm9qZWN0Jyk7XG4gICAgICAgIGxpLmNsYXNzTGlzdC5hZGQoJ290aGVyUHJvamVjdHMnKTtcbiAgICAgICAgbGkuc2V0QXR0cmlidXRlKCdkYXRhLWluZGV4JywgZGVmYXVsdHMucHJvamVjdENvdW50IC0gMSk7XG5cbiAgICAgICAgbGV0IG5hbWUgPSBwcm9qLnByb2plY3ROYW1lLnZhbHVlLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIG5hbWUgPSBuYW1lLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgbmFtZS5zbGljZSgxKTtcbiAgICAgICAgaWYgKG5hbWUubGVuZ3RoID4gMTIpIHtcbiAgICAgICAgICAgIG5hbWUgPSBuYW1lLnN1YnN0cmluZygwLCAxMCkgKyAnLi4uJztcbiAgICAgICAgfVxuICAgICAgICBsaS5pbm5lckhUTUwgPSBgPGkgY2xhc3M9XCJmYS1zb2xpZCBmYS1tYXNrcy10aGVhdGVyXCI+PC9pPiR7bmFtZX0gPGkgY2xhc3M9XCJmYS1zb2xpZCBmYS1jaXJjbGUtbWludXNcIj48L2k+YDtcbiAgICAgICAgXy5wcm9qZWN0cy5hcHBlbmRDaGlsZChsaSk7XG5cbiAgICAgICAgLy8gdXBkYXRlIG1pc2NcbiAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICB9KTtcbn07XG5cblxuY29uc3QgcmVtb3ZlUHJvamVjdCA9IChlKSA9PiB7XG4gICAgbGV0IHByb2plY3RzID0gZS50YXJnZXQucGFyZW50RWxlbWVudC5wYXJlbnRFbGVtZW50O1xuICAgIGxldCBwcm9qZWN0ID0gZS50YXJnZXQucGFyZW50RWxlbWVudDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRlZmF1bHRzLmxpc3RPZlByb2plY3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChkZWZhdWx0cy5saXN0T2ZQcm9qZWN0c1tpXS5nZXRJbmRleCgpID09IHByb2plY3QuZ2V0QXR0cmlidXRlKCdkYXRhLWluZGV4JykpIHtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gc3BsaWNlIG91dCBwcm9qZWN0XG4gICAgICAgICAgICBsZXQgcmVtb3ZlZExpc3QgPSBkZWZhdWx0cy5saXN0T2ZQcm9qZWN0c1tpXS5hcnI7XG4gICAgICAgICAgICBsZXQgcmVtb3ZlZExpc3RJbmRleGVzID0gW107XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIHVwZGF0ZSBldmVyeXRoaW5nUHJvaiB0byByZW1vdmUgdGhlc2UgdG9Eb3NcbiAgICAgICAgICAgIGZvcihsZXQgaiA9IDA7IGogPCByZW1vdmVkTGlzdC5sZW5ndGg7IGorKyl7XG4gICAgICAgICAgICAgICAgcmVtb3ZlZExpc3RJbmRleGVzLnB1c2gocmVtb3ZlZExpc3Rbal0uZ2V0SUQoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGNvbnN0IHJlbW92ZUZyb21BcnJheSA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgbGlzdCA9IGRlZmF1bHRzLmxpc3RPZlByb2plY3RzO1xuICAgICAgICAgICAgICAgIGxldCBsZW5ndGggPSByZW1vdmVkTGlzdEluZGV4ZXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGZvcihsZXQgayA9IDA7IGsgPCBsZW5ndGg7IGsrKyl7XG4gICAgICAgICAgICAgICAgICAgIGxpc3RbaV0ucmVtb3ZlRnJvbUxpc3QocmVtb3ZlZExpc3RJbmRleGVzW2tdKTtcbiAgICAgICAgICAgICAgICAgICAgbGlzdFsxXS5yZW1vdmVGcm9tTGlzdChyZW1vdmVkTGlzdEluZGV4ZXNba10pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZW1vdmVGcm9tQXJyYXkoKTtcblxuICAgICAgICB9XG4gICAgfVxuICAgIHByb2plY3RzLnJlbW92ZUNoaWxkKHByb2plY3QpO1xuICAgIF8udGFibGUudGV4dENvbnRlbnQgPSAnUGxlYXNlIHNlbGVjdCBhIHByb2plY3QnO1xuICAgIGlmKF8udG9Eb0xpc3QuY29udGFpbnMoXy5hZGRUb0RvQnRuKSl7XG4gICAgICAgIF8udG9Eb0xpc3QucmVtb3ZlQ2hpbGQoXy5hZGRUb0RvQnRuKTtcbiAgICB9XG59OyIsImltcG9ydCBfIGZyb20gJy4vZG9jdW1lbnRQYXJ0cyc7XG5pbXBvcnQgeyBUb2RvIH0gZnJvbSAnLi90b2RvJztcbmltcG9ydCBkZWZhdWx0cyBmcm9tICcuL2RlZmF1bHRQcm9qZWN0cyc7XG5pbXBvcnQgeyBkYXRlRmlsdGVyLCBub3cgfSBmcm9tICcuL3RpbWUnO1xuaW1wb3J0IHsgYWRkRXZlbnRMaXN0ZW5lcnMgfSBmcm9tICcuL2FkZExpc3RlbmVycyc7XG5cbmV4cG9ydCBjb25zdCBhZGRUb0RvVG9UYWJsZSA9ICgpID0+IHtcblxuICAgIGNvbnN0IG1ha2VSb3cgPSAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHRyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndHInKTtcbiAgICAgICAgdHIuY2xhc3NMaXN0LmFkZCgnY3JlYXRlZFJvdycpO1xuICAgICAgICB0ci5zZXRBdHRyaWJ1dGUoJ2RhdGEtaW5kZXgnLCBgJHtfLnRvRG9Db3VudGVyfWApO1xuICAgICAgICBjb25zdCB0ZDEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZCcpO1xuICAgICAgICBjb25zdCB0ZDIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZCcpO1xuICAgICAgICB0ZDEuY2xhc3NMaXN0LmFkZCgnY29sdW1uMScpO1xuICAgICAgICB0ZDIuY2xhc3NMaXN0LmFkZCgnY29sdW1uMicpO1xuXG4gICAgICAgIF8uc2V0UHJpb3JpdHlDb2xvcnMoY3JlYXRlVGFza1ByaW9yaXR5LnZhbHVlLCB0ZDEpO1xuXG4gICAgICAgIHRkMS5pbm5lckhUTUwgPSBgPGkgY2xhc3M9XCJmYS1yZWd1bGFyIGZhLXNxdWFyZVwiPjwvaT4gJHtjcmVhdGVUYXNrTmFtZS52YWx1ZX1gO1xuICAgICAgICBpZiAoY3JlYXRlVGFza0R1ZURhdGUudmFsdWUgIT09ICcnKSB7XG4gICAgICAgICAgICBsZXQgZmlsdGVyZWREdWVEYXRlID0gZGF0ZUZpbHRlcihjcmVhdGVUYXNrRHVlRGF0ZS52YWx1ZSk7XG4gICAgICAgICAgICB0ZDIuaW5uZXJIVE1MID0gYCR7ZmlsdGVyZWREdWVEYXRlfSA8aSBjbGFzcz1cImZhLXJlZ3VsYXIgZmEtcGVuLXRvLXNxdWFyZVwiPjwvaT48aSBjbGFzcz1cImZhLXJlZ3VsYXIgZmEtdHJhc2gtY2FuXCI+PC9pPmA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0ZDIuaW5uZXJIVE1MID0gYDxpIGNsYXNzPVwiZmEtcmVndWxhciBmYS1wZW4tdG8tc3F1YXJlXCI+PC9pPjxpIGNsYXNzPVwiZmEtcmVndWxhciBmYS10cmFzaC1jYW5cIj48L2k+YDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRyLmFwcGVuZENoaWxkKHRkMSk7XG4gICAgICAgIHRyLmFwcGVuZENoaWxkKHRkMik7XG5cbiAgICAgICAgcmV0dXJuIHRyO1xuICAgIH07XG5cbiAgICBjb25zdCByb3cgPSBtYWtlUm93KCk7XG5cbiAgICAvLyBjcmVhdGUgYW4gb2JqZWN0IHRvIHN0b3JlIHRoZSB2YWx1ZXMgYW5kIHB1c2ggaW50byBkZWZhdWx0UHJvaiBsYXRlclxuICAgIGxldCB0b0RvT2JqID0gVG9kbyhjcmVhdGVUYXNrTmFtZS52YWx1ZSwgY3JlYXRlVGFza0Rlc2NyaXB0aW9uLnZhbHVlLCBjcmVhdGVUYXNrRHVlRGF0ZS52YWx1ZSxcbiAgICAgICAgY3JlYXRlVGFza1ByaW9yaXR5LnZhbHVlLCBfLnRvRG9Db3VudGVyKTtcbiAgICBcbiAgICBfLnRvRG9Db3VudGVyKys7XG5cbiAgICBkZWZhdWx0cy5saXN0T2ZQcm9qZWN0c1tkZWZhdWx0cy5jdXJyZW50UHJvamVjdEluZGV4XS5hZGRUb0xpc3QodG9Eb09iaik7XG4gICAgZGVmYXVsdHMubGlzdE9mUHJvamVjdHNbMV0uYWRkVG9MaXN0KHRvRG9PYmopO1xuXG4gICAgXy50YWJsZS5hcHBlbmRDaGlsZChyb3cpO1xuICAgIC8vIHNldCBkZWZhdWx0IHZhbHVlc1xuICAgIGNyZWF0ZVRhc2tOYW1lLnZhbHVlID0gJyc7XG4gICAgY3JlYXRlVGFza0Rlc2NyaXB0aW9uLnZhbHVlID0gJyc7XG4gICAgY3JlYXRlVGFza0R1ZURhdGUudmFsdWUgPSBub3coKTtcbiAgICBjcmVhdGVUYXNrUHJpb3JpdHkudmFsdWUgPSAnTm9ybWFsJztcbiAgICBhZGRFdmVudExpc3RlbmVycygpO1xufTtcbiIsImltcG9ydCBfIGZyb20gJy4vZG9jdW1lbnRQYXJ0cyc7XG5pbXBvcnQgZGVmYXVsdHMgZnJvbSAnLi9kZWZhdWx0UHJvamVjdHMnO1xuaW1wb3J0IHsgYWRkRXZlbnRMaXN0ZW5lcnMgfSBmcm9tICcuL2FkZExpc3RlbmVycyc7XG5pbXBvcnQgeyBkYXRlRmlsdGVyIH0gZnJvbSAnLi90aW1lJztcblxuZXhwb3J0IGNvbnN0IGdlbmVyYXRlUHJvamVjdCA9IChzZWxlY3RlZFByb2plY3QpID0+IHtcbiAgICBkZWZhdWx0cy5jdXJyZW50UHJvamVjdEluZGV4ID0gc2VsZWN0ZWRQcm9qZWN0LmdldEluZGV4KCk7XG4gICAgY2xlYXJPbGRQcm9qZWN0KCk7XG4gICAgZ2VuZXJhdGVUYWJsZUhlYWRlcihzZWxlY3RlZFByb2plY3QpO1xuICAgIGdlbmVyYXRlUm93cyhzZWxlY3RlZFByb2plY3QpO1xuICAgIGFkZEV2ZW50TGlzdGVuZXJzKCk7XG59O1xuXG5jb25zdCBjbGVhck9sZFByb2plY3QgPSAoKSA9PiB7XG4gICAgXy50YWJsZS50ZXh0Q29udGVudCA9ICcnO1xufTtcblxuY29uc3QgZ2VuZXJhdGVUYWJsZUhlYWRlciA9IChzZWxlY3RlZFByb2plY3QpID0+IHtcbiAgICBsZXQgdHIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0cicpO1xuICAgIHRyLmNsYXNzTGlzdC5hZGQoJ3RpdGxlcycpO1xuICAgIGxldCB0aFByb2pOYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGgnKTtcbiAgICB0aFByb2pOYW1lLmNsYXNzTGlzdC5hZGQoJ3Byb2pOYW1lJyk7XG4gICAgdGhQcm9qTmFtZS50ZXh0Q29udGVudCA9IHNlbGVjdGVkUHJvamVjdC5nZXRUaXRsZSgpLnN1YnN0cmluZygwLDMwKTtcbiAgICBsZXQgdGhEdWVEYXRlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGgnKTtcbiAgICB0aER1ZURhdGUuY2xhc3NMaXN0LmFkZCgnZHVlRGF0ZScpO1xuICAgIHRoRHVlRGF0ZS5pbm5lckhUTUwgPSBgRHVlIERhdGUgPGkgY2xhc3M9XCJmYS1zb2xpZCBmYS1jYWxlbmRhci1kYXlcIj48L2k+YDtcbiAgICB0ci5hcHBlbmRDaGlsZCh0aFByb2pOYW1lKTtcbiAgICB0ci5hcHBlbmRDaGlsZCh0aER1ZURhdGUpO1xuICAgIF8udGFibGUuYXBwZW5kQ2hpbGQodHIpO1xufTtcblxuY29uc3QgZ2VuZXJhdGVSb3dzID0gKHNlbGVjdGVkUHJvamVjdCkgPT4ge1xuXG4gICAgaWYoc2VsZWN0ZWRQcm9qZWN0LmdldEluZGV4KCkgPT0gMiB8fCBzZWxlY3RlZFByb2plY3QuZ2V0SW5kZXgoKSA9PSAzKXtcbiAgICAgICAgY29uc3QgbWFrZVJvdyA9IChyb3cpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHRyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndHInKTtcbiAgICAgICAgICAgIHRyLmNsYXNzTGlzdC5hZGQoJ3ZpZXdPbmx5Jyk7XG4gICAgICAgICAgICB0ci5zZXRBdHRyaWJ1dGUoJ2RhdGEtaW5kZXgnLCBgJHtyb3cuZ2V0SUQoKX1gKTtcbiAgICAgICAgICAgIGNvbnN0IHRkMSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RkJyk7XG4gICAgICAgICAgICBjb25zdCB0ZDIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZCcpO1xuICAgICAgICAgICAgdGQxLmNsYXNzTGlzdC5hZGQoJ2NvbHVtbjEnKTtcbiAgICAgICAgICAgIHRkMi5jbGFzc0xpc3QuYWRkKCdjb2x1bW4yJyk7XG5cbiAgICAgICAgICAgIF8uc2V0UHJpb3JpdHlDb2xvcnMocm93LmdldFByaW9yaXR5KCksIHRkMSk7XG4gICAgXG4gICAgICAgICAgICB0ZDEuaW5uZXJIVE1MID0gYCR7cm93LmdldFRpdGxlKCl9YDtcbiAgICAgICAgICAgIHRkMi5pbm5lckhUTUwgPSBgJHtkYXRlRmlsdGVyKHJvdy5nZXREdWVEYXRlKCkpfWA7XG4gICAgXG4gICAgICAgICAgICB0ci5hcHBlbmRDaGlsZCh0ZDEpO1xuICAgICAgICAgICAgdHIuYXBwZW5kQ2hpbGQodGQyKTtcbiAgICBcbiAgICAgICAgICAgIHJldHVybiB0cjtcbiAgICAgICAgfTtcbiAgICBcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWxlY3RlZFByb2plY3QuYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBfLnRhYmxlLmFwcGVuZENoaWxkKG1ha2VSb3coc2VsZWN0ZWRQcm9qZWN0LmFycltpXSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmKF8udG9Eb0xpc3QuY29udGFpbnMoXy5hZGRUb0RvQnRuKSl7XG4gICAgICAgICAgICBfLnRvRG9MaXN0LnJlbW92ZUNoaWxkKF8uYWRkVG9Eb0J0bik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZXtcbiAgICAgICAgY29uc3QgbWFrZVJvdyA9IChyb3cpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHRyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndHInKTtcbiAgICAgICAgICAgIHRyLmNsYXNzTGlzdC5hZGQoJ2NyZWF0ZWRSb3cnKTtcbiAgICAgICAgICAgIHRyLnNldEF0dHJpYnV0ZSgnZGF0YS1pbmRleCcsIGAke3Jvdy5nZXRJRCgpfWApO1xuICAgICAgICAgICAgY29uc3QgdGQxID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGQnKTtcbiAgICAgICAgICAgIGNvbnN0IHRkMiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RkJyk7XG4gICAgICAgICAgICB0ZDEuY2xhc3NMaXN0LmFkZCgnY29sdW1uMScpO1xuICAgICAgICAgICAgdGQyLmNsYXNzTGlzdC5hZGQoJ2NvbHVtbjInKTtcblxuICAgICAgICAgICAgXy5zZXRQcmlvcml0eUNvbG9ycyhyb3cuZ2V0UHJpb3JpdHkoKSwgdGQxKTtcbiAgICBcbiAgICAgICAgICAgIHRkMS5pbm5lckhUTUwgPSBgPGkgY2xhc3M9XCJmYS1yZWd1bGFyIGZhLXNxdWFyZVwiPjwvaT4gJHtyb3cuZ2V0VGl0bGUoKX1gO1xuICAgICAgICAgICAgdGQyLmlubmVySFRNTCA9IGAke2RhdGVGaWx0ZXIocm93LmdldER1ZURhdGUoKSl9IDxpIGNsYXNzPVwiZmEtcmVndWxhciBmYS1wZW4tdG8tc3F1YXJlXCI+PC9pPjxpIGNsYXNzPVwiZmEtcmVndWxhciBmYS10cmFzaC1jYW5cIj48L2k+YDtcbiAgICBcbiAgICAgICAgICAgIHRyLmFwcGVuZENoaWxkKHRkMSk7XG4gICAgICAgICAgICB0ci5hcHBlbmRDaGlsZCh0ZDIpO1xuICAgIFxuICAgICAgICAgICAgcmV0dXJuIHRyO1xuICAgICAgICB9O1xuICAgIFxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNlbGVjdGVkUHJvamVjdC5hcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIF8udGFibGUuYXBwZW5kQ2hpbGQobWFrZVJvdyhzZWxlY3RlZFByb2plY3QuYXJyW2ldKSk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmKCFfLnRvRG9MaXN0LmNvbnRhaW5zKF8uYWRkVG9Eb0J0bikpe1xuICAgICAgICAgICAgXy50b0RvTGlzdC5hcHBlbmRDaGlsZChfLmFkZFRvRG9CdG4pO1xuICAgICAgICB9XG4gICAgfSAgICAgICAgICAgIFxuXG59O1xuXG5leHBvcnQgY29uc3QgZ2VuZXJhdGVUb2RheXNUb0RvcyA9ICgpID0+IHtcbiAgICBkZWZhdWx0cy5saXN0T2ZQcm9qZWN0c1syXS5hcnIuc3BsaWNlKDAsIGRlZmF1bHRzLmxpc3RPZlByb2plY3RzWzJdLmFyci5sZW5ndGgsIC4uLmRlZmF1bHRzLmxpc3RPZlByb2plY3RzWzFdLmZpbHRlclRvZGF5c1RvRG9zKCkpO1xuICAgIGdlbmVyYXRlUHJvamVjdChkZWZhdWx0cy50b2RheXNUb0Rvcyk7XG59O1xuXG5leHBvcnQgY29uc3QgZ2VuZXJhdGVUaGlzV2Vla3NUb0RvcyA9ICgpID0+IHtcbiAgICBkZWZhdWx0cy5saXN0T2ZQcm9qZWN0c1szXS5hcnIuc3BsaWNlKDAsIGRlZmF1bHRzLmxpc3RPZlByb2plY3RzWzNdLmFyci5sZW5ndGgsIC4uLmRlZmF1bHRzLmxpc3RPZlByb2plY3RzWzFdLmZpbHRlclRoaXNXZWVrc1RvRG9zKCkpO1xuICAgIGdlbmVyYXRlUHJvamVjdChkZWZhdWx0cy50aGlzV2Vla3NUb0Rvcyk7XG59O1xuXG5leHBvcnQgY29uc3QgZ2VuZXJhdGVEZWZhdWx0VG9Eb3MgPSAoKSA9PiB7XG4gICAgZ2VuZXJhdGVQcm9qZWN0KGRlZmF1bHRzLmRlZmF1bHRQcm9qKTtcbn07XG5cbmNvbnN0IHNldHVwRGVmYXVsdFByb2plY3RzID0gKCkgPT4ge1xuICAgIF8udG9kYXlzVG9Eb3MuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBnZW5lcmF0ZVRvZGF5c1RvRG9zKTtcbiAgICBfLnRoaXNXZWVrc1RvRG9zLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZ2VuZXJhdGVUaGlzV2Vla3NUb0Rvcyk7XG4gICAgXy5kZWZhdWx0UHJvamVjdC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGdlbmVyYXRlRGVmYXVsdFRvRG9zKTtcbiAgICBnZW5lcmF0ZVByb2plY3QoZGVmYXVsdHMubGlzdE9mUHJvamVjdHNbZGVmYXVsdHMuY3VycmVudFByb2plY3RJbmRleF0pO1xufTtcblxuc2V0dXBEZWZhdWx0UHJvamVjdHMoKTsiLCJpbXBvcnQgJy4vc3R5bGUuc2Nzcyc7XG5pbXBvcnQgJy4vanMvYWRkVG9Ebyc7XG5pbXBvcnQgXyBmcm9tICcuL2pzL2RvY3VtZW50UGFydHMnO1xuaW1wb3J0ICcuL2pzL3Byb2plY3RQYWdlR2VuZXJhdGlvbic7XG5pbXBvcnQgeyBhZGRFdmVudExpc3RlbmVycyB9IGZyb20gJy4vanMvYWRkTGlzdGVuZXJzJztcbmltcG9ydCAnLi9pbWcvcGx1cy1jaXJjbGUucG5nJztcbmltcG9ydCB0b2RvTGlzdEltZyBmcm9tICcuL2ltZy90b2RvTGlzdC5wbmcnO1xuXG5fLnBsdXNDaXJjbGVEaXYuc3R5bGUuYmFja2dyb3VuZEltYWdlID0gYHVybCgke3RvZG9MaXN0SW1nfSlgO1xuXG5cbmFkZEV2ZW50TGlzdGVuZXJzKCk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///586\n")},680:(n,I,g)=>{"use strict";n.exports=g.p+"plus-circle.png"},661:(n,I,g)=>{"use strict";n.exports=g.p+"todoList.png"}},__webpack_module_cache__={};function __webpack_require__(n){var I=__webpack_module_cache__[n];if(void 0!==I)return I.exports;var g=__webpack_module_cache__[n]={id:n,exports:{}};return __webpack_modules__[n].call(g.exports,g,g.exports,__webpack_require__),g.exports}__webpack_require__.n=n=>{var I=n&&n.__esModule?()=>n.default:()=>n;return __webpack_require__.d(I,{a:I}),I},__webpack_require__.d=(n,I)=>{for(var g in I)__webpack_require__.o(I,g)&&!__webpack_require__.o(n,g)&&Object.defineProperty(n,g,{enumerable:!0,get:I[g]})},__webpack_require__.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(n){if("object"==typeof window)return window}}(),__webpack_require__.o=(n,I)=>Object.prototype.hasOwnProperty.call(n,I),(()=>{var n;__webpack_require__.g.importScripts&&(n=__webpack_require__.g.location+"");var I=__webpack_require__.g.document;if(!n&&I&&(I.currentScript&&(n=I.currentScript.src),!n)){var g=I.getElementsByTagName("script");g.length&&(n=g[g.length-1].src)}if(!n)throw new Error("Automatic publicPath is not supported in this browser");n=n.replace(/#.*$/,"").replace(/\?.*$/,"").replace(/\/[^\/]+$/,"/"),__webpack_require__.p=n})();var __webpack_exports__=__webpack_require__(586)})();