/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/css-loader/dist/cjs.js!./node_modules/sass-loader/dist/cjs.js!./src/style.scss":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./node_modules/sass-loader/dist/cjs.js!./src/style.scss ***!
  \*****************************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../node_modules/css-loader/dist/runtime/sourceMaps.js */ \"./node_modules/css-loader/dist/runtime/sourceMaps.js\");\n/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../node_modules/css-loader/dist/runtime/api.js */ \"./node_modules/css-loader/dist/runtime/api.js\");\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);\n// Imports\n\n\nvar ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \".container {\\n  position: absolute;\\n  display: grid;\\n  grid-template-columns: 1fr 1fr;\\n  min-width: 25rem;\\n  background-color: white;\\n  border: 1px solid black;\\n  padding: 10px;\\n}\\n.container label,\\n.container textarea {\\n  font-size: 0.8rem;\\n  letter-spacing: 1px;\\n}\\n.container textarea {\\n  padding: 10px;\\n  max-width: 100%;\\n  line-height: 1.5;\\n  border-radius: 5px;\\n  border: 1px solid #ccc;\\n  box-shadow: 1px 1px 1px #999;\\n}\\n.container label {\\n  display: block;\\n  margin-bottom: 10px;\\n}\\n.container input[type=text] {\\n  padding: 2px;\\n}\\n.container .btns {\\n  display: flex;\\n  gap: 5px;\\n}\\n.container .btns .submitBtn, .container .btns .cancelBtn {\\n  background-color: #a3c9bc;\\n  max-width: 50px;\\n  padding: 10px;\\n}\\n.container .btns .submitBtn:hover, .container .btns .cancelBtn:hover {\\n  cursor: pointer;\\n  background-color: white;\\n}\\n.container .btns .cancelBtn {\\n  background-color: red;\\n}\\n\\n* {\\n  padding: 0;\\n  margin: 0;\\n  box-sizing: border-box;\\n}\\n\\nbody {\\n  font-family: \\\"Coming Soon\\\", cursive;\\n  height: 100vh;\\n  width: 100vw;\\n  display: flex;\\n  flex-direction: column;\\n}\\n\\n#header {\\n  display: flex;\\n  justify-content: center;\\n  align-items: center;\\n  justify-content: flex-start;\\n  background-color: rgba(255, 72, 0, 0.8);\\n  color: white;\\n  font-size: 2.5rem;\\n  font-weight: 900;\\n  gap: 1rem;\\n  width: 100%;\\n}\\n#header .logo {\\n  max-height: 5rem;\\n  padding: 5px;\\n}\\n\\n#content {\\n  display: grid;\\n  grid-template-columns: 1fr 6fr;\\n  height: 100vh;\\n}\\n#content .sidebar {\\n  font-size: 1.5rem;\\n  padding: 10px;\\n  background-color: rgba(255, 72, 0, 0.5);\\n}\\n#content .sidebar li.projects {\\n  background-color: white;\\n}\\n#content .sidebar ul {\\n  text-align: center;\\n  list-style-type: none;\\n}\\n#content .sidebar ul .link {\\n  padding: 10px;\\n}\\n#content .sidebar ul .link a {\\n  text-decoration: none;\\n  color: black;\\n  text-shadow: 1px 1px white;\\n}\\n#content .sidebar li.projects ul {\\n  padding: 10px;\\n  display: flex;\\n  flex-direction: column;\\n  gap: 10px;\\n  justify-content: center;\\n  align-items: center;\\n  margin: 0 auto;\\n}\\n#content .sidebar li.projects ul li.project {\\n  font-size: 1.3rem;\\n  padding: 5px;\\n  width: 200px;\\n}\\n#content .sidebar li.projects ul li.project:hover {\\n  cursor: pointer;\\n}\\n#content .sidebar li.projects ul li.project a {\\n  display: flex;\\n  gap: 10px;\\n  justify-content: center;\\n  align-items: center;\\n  padding: 5px;\\n  border: 1px solid;\\n  font-family: \\\"rock salt\\\", cursive;\\n}\\n#content .todoList {\\n  display: flex;\\n  flex-direction: column;\\n  justify-content: flex-start;\\n  align-items: center;\\n  gap: 10px;\\n  background-color: rgba(255, 72, 0, 0.1);\\n}\\n#content .todoList table {\\n  min-width: 800px;\\n  max-width: 1200px;\\n}\\n#content .todoList table .titles {\\n  font-size: 1.5rem;\\n  font-family: \\\"Times New Roman\\\", Times, serif;\\n}\\n#content .todoList table .titles:hover {\\n  box-shadow: none;\\n}\\n#content .todoList table .titles .dueDate {\\n  text-align: right;\\n}\\n#content .todoList table .titles .projName {\\n  text-align: left;\\n}\\n#content .todoList table .titles th {\\n  padding: 10px 0;\\n}\\n#content .todoList table tr:hover, #content .todoList table tr.createdRow:hover {\\n  box-shadow: 0 0 5px 5px;\\n}\\n#content .todoList table tr td, #content .todoList table tr.createdRow td {\\n  vertical-align: middle;\\n  max-width: 600px;\\n  padding: 10px;\\n}\\n#content .todoList table tr .column1, #content .todoList table tr.createdRow .column1 {\\n  font-size: 1.5rem;\\n}\\n#content .todoList table tr .column2, #content .todoList table tr.createdRow .column2 {\\n  display: flex;\\n  justify-content: flex-end;\\n  align-items: center;\\n  gap: 10px;\\n  font-size: 1.3rem;\\n}\\n\\ni, .addToDoBtn, .addProjectBtn {\\n  cursor: pointer;\\n}\\n\\n.fa-arrow-down, .fa-calendar, .fa-exclamation {\\n  margin-left: 10px;\\n}\\n\\n.completed {\\n  opacity: 0.5;\\n  text-decoration: line-through;\\n}\\n\\n.completed .column2 {\\n  text-decoration: none;\\n}\\n\\n#modal, #editModal {\\n  top: 35%;\\n  left: 40%;\\n  max-width: 50ch;\\n  padding: 10px;\\n}\\n#modal > *, #editModal > * {\\n  margin: 0 0 0.5rem 0;\\n}\\n#modal::backdrop, #editModal::backdrop {\\n  background: rgba(0, 0, 0, 0.4);\\n}\", \"\",{\"version\":3,\"sources\":[\"webpack://./src/scss/_container.scss\",\"webpack://./src/style.scss\",\"webpack://./src/scss/_globals.scss\"],\"names\":[],\"mappings\":\"AAAA;EAEI,kBAAA;EACA,aAAA;EACA,8BAAA;EACA,gBAAA;EACA,uBAAA;EACA,uBAAA;EACA,aAAA;ACAJ;ADEI;;EAEI,iBAAA;EACA,mBAAA;ACAR;ADGI;EACI,aAAA;EACA,eAAA;EACA,gBAAA;EACA,kBAAA;EACA,sBAAA;EACA,4BAAA;ACDR;ADII;EACI,cAAA;EACA,mBAAA;ACFR;ADKI;EACI,YAAA;ACHR;ADMI;EACI,aAAA;EACA,QAAA;ACJR;ADKQ;EACI,yBAAA;EACA,eAAA;EACA,aAAA;ACHZ;ADIY;EACI,eAAA;EACA,uBAAA;ACFhB;ADKQ;EACI,qBAAA;ACHZ;;AAnCA;EACI,UAAA;EACA,SAAA;EACA,sBAAA;AAsCJ;;AAnCA;EACI,mCAAA;EACA,aAAA;EACA,YAAA;EACA,aAAA;EACA,sBAAA;AAsCJ;;AAnCA;EAnBI,aAAA;EACA,uBAAA;EACA,mBAAA;EAmBA,2BAAA;EACA,uCCxBK;EDyBL,YC1BG;ED2BH,iBAAA;EACA,gBAAA;EACA,SAAA;EACA,WAAA;AAwCJ;AAvCI;EACI,gBAAA;EACA,YAAA;AAyCR;;AArCA;EACI,aAAA;EACA,8BAAA;EACA,aAAA;AAwCJ;AAvCI;EACI,iBAAA;EACA,aAAA;EACA,uCC1CE;ADmFV;AAxCQ;EACI,uBAAA;AA0CZ;AAxCQ;EACI,kBAAA;EACA,qBAAA;AA0CZ;AAzCY;EACI,aAAA;AA2ChB;AA1CgB;EACI,qBAAA;EACA,YCpDL;EDqDK,0BAAA;AA4CpB;AAxCQ;EACI,aAAA;EACA,aAAA;EACA,sBAAA;EACA,SAAA;EACA,uBAAA;EACA,mBAAA;EACA,cAAA;AA0CZ;AAzCY;EACI,iBAAA;EACA,YAAA;EACA,YAAA;AA2ChB;AA1CgB;EACI,eAAA;AA4CpB;AA1CgB;EACI,aAAA;EACA,SAAA;EACA,uBAAA;EACA,mBAAA;EACA,YAAA;EACA,iBAAA;EACA,iCAAA;AA4CpB;AAvCI;EACI,aAAA;EACA,sBAAA;EACA,2BAAA;EACA,mBAAA;EACA,SAAA;EACA,uCCzFG;ADkIX;AAxCQ;EAEI,gBAAA;EACA,iBAAA;AAyCZ;AAxCY;EAII,iBAAA;EACA,4CAAA;AAuChB;AA3CgB;EACI,gBAAA;AA6CpB;AAzCgB;EACI,iBAAA;AA2CpB;AAzCgB;EACI,gBAAA;AA2CpB;AAzCgB;EACI,eAAA;AA2CpB;AAtCgB;EACI,uBAAA;AAwCpB;AAtCgB;EACI,sBAAA;EACA,gBAAA;EACA,aAAA;AAwCpB;AAtCgB;EACI,iBAAA;AAwCpB;AAtCgB;EACI,aAAA;EACA,yBAAA;EACA,mBAAA;EACA,SAAA;EACA,iBAAA;AAwCpB;;AAjCA;EACI,eAAA;AAoCJ;;AAlCA;EACI,iBAAA;AAqCJ;;AAlCA;EACI,YAAA;EACA,6BAAA;AAqCJ;;AAnCA;EACI,qBAAA;AAsCJ;;AAlCA;EAEI,QAAA;EACA,SAAA;EACA,eAAA;EACA,aAAA;AAoCJ;AAhCI;EACA,oBAAA;AAkCJ;AAhCI;EACA,8BAAA;AAkCJ\",\"sourcesContent\":[\".container{\\n\\n    position: absolute;\\n    display: grid;\\n    grid-template-columns: 1fr 1fr;\\n    min-width: 25rem;\\n    background-color: $TODO_INFO_FORM;\\n    border: 1px solid black;\\n    padding: 10px;\\n    \\n    label,\\n    textarea {\\n        font-size: .8rem;\\n        letter-spacing: 1px;\\n    }\\n\\n    textarea {\\n        padding: 10px;\\n        max-width: 100%;\\n        line-height: 1.5;\\n        border-radius: 5px;\\n        border: 1px solid #ccc;\\n        box-shadow: 1px 1px 1px #999;\\n    }\\n\\n    label {\\n        display: block;\\n        margin-bottom: 10px;\\n    }\\n\\n    input[type=\\\"text\\\"]{\\n        padding: 2px;\\n    }\\n\\n    .btns{\\n        display: flex;\\n        gap: 5px;\\n        .submitBtn, .cancelBtn{\\n            background-color: rgb(163, 201, 188);\\n            max-width: 50px;\\n            padding: 10px;\\n            &:hover{\\n                cursor: pointer;\\n                background-color: white;\\n            }\\n        }\\n        .cancelBtn{\\n            background-color: red;\\n        }\\n    }\\n}\",\"@import './scss/globals';\\n@import './scss/container';\\n\\n@mixin center {\\n    display: flex;\\n    justify-content: center;\\n    align-items: center;\\n}\\n\\n*{\\n    padding: 0;\\n    margin: 0;\\n    box-sizing: border-box;\\n}\\n\\nbody{\\n    font-family: 'Coming Soon', cursive;\\n    height: 100vh;\\n    width: 100vw;\\n    display: flex;\\n    flex-direction: column;\\n}\\n\\n#header{\\n    @include center;\\n    justify-content: flex-start;\\n    background-color: $HEADER;\\n    color: $FONT;\\n    font-size: 2.5rem;\\n    font-weight: 900;\\n    gap: 1rem;\\n    width: 100%;\\n    .logo{\\n        max-height: 5rem;\\n        padding: 5px;\\n    }\\n}\\n\\n#content{\\n    display: grid;\\n    grid-template-columns: 1fr 6fr;\\n    height: 100vh;\\n    .sidebar{\\n        font-size: 1.5rem;\\n        padding: 10px;\\n        background-color: $SIDEBAR;\\n        li.projects{\\n            background-color: white;\\n        }\\n        ul{\\n            text-align: center;\\n            list-style-type: none;\\n            .link{\\n                padding: 10px;\\n                a{\\n                    text-decoration: none;\\n                    color: $SIDEBAR_TEXT;\\n                    text-shadow: 1px 1px white;\\n                }\\n            }\\n        }\\n        li.projects ul{\\n            padding: 10px;\\n            display: flex;\\n            flex-direction: column;\\n            gap: 10px;\\n            justify-content: center;\\n            align-items: center;\\n            margin: 0 auto;\\n            li.project{\\n                font-size: 1.3rem;\\n                padding: 5px;\\n                width: 200px;\\n                &:hover{\\n                    cursor: pointer;\\n                }\\n                a{\\n                    display: flex;\\n                    gap: 10px;\\n                    justify-content: center;\\n                    align-items: center;\\n                    padding: 5px;\\n                    border: 1px solid;\\n                    font-family: 'rock salt', cursive;\\n                }\\n            }\\n        }\\n    }\\n    .todoList{\\n        display: flex;\\n        flex-direction: column;\\n        justify-content: flex-start;\\n        align-items: center;\\n        gap: 10px;\\n        background-color: $TODOLIST;\\n        table{\\n            // margin-top: 10px;\\n            min-width: clamp(320px, 800px, 1000px);\\n            max-width: clamp(400px, 1200px, 1600px);\\n            .titles{\\n                &:hover{\\n                    box-shadow: none;\\n                }\\n                font-size: 1.5rem;\\n                font-family: 'Times New Roman', Times, serif;\\n                .dueDate{\\n                    text-align: right;\\n                }\\n                .projName{\\n                    text-align: left;\\n                }\\n                th{\\n                    padding: 10px 0;\\n                }\\n            }\\n\\n            tr, tr.createdRow{\\n                &:hover{\\n                    box-shadow: 0 0 5px 5px;\\n                }\\n                td{\\n                    vertical-align: middle;\\n                    max-width: 600px;\\n                    padding: 10px;\\n                }\\n                .column1{\\n                    font-size: 1.5rem;\\n                }\\n                .column2{\\n                    display: flex;\\n                    justify-content: flex-end;\\n                    align-items: center;\\n                    gap: 10px;\\n                    font-size: 1.3rem;\\n                }\\n            }\\n        }\\n    }\\n}\\n\\ni, .addToDoBtn, .addProjectBtn{\\n    cursor: pointer;\\n}\\n.fa-arrow-down, .fa-calendar, .fa-exclamation{\\n    margin-left: 10px;\\n}\\n\\n.completed{\\n    opacity: 0.5;\\n    text-decoration: line-through;\\n}\\n.completed .column2{\\n    text-decoration: none;\\n}\\n\\n\\n#modal, #editModal{\\n    // padding: 1em;\\n    top: 35%;\\n    left: 40%;\\n    max-width: 50ch;\\n    padding: 10px;\\n    // border: 0;\\n    // box-shadow: 0 0 1em rgb(0 0 0 / .3);\\n\\n    & > * {\\n    margin: 0 0 0.5rem 0;\\n    }\\n    &::backdrop{\\n    background: rgb(0 0 0 / 0.4);\\n    }\\n}\",\"$BODY: #3f3f3f;\\n$FONT: white;\\n$HEADER: rgba(255, 72, 0, .8);\\n$SIDEBAR: rgba(255, 72, 0, .5);\\n$SIDEBAR_TEXT: black;\\n$TODOLIST: rgba(255, 72, 0, .1);\\n$TODO_INFO_FORM: white;\"],\"sourceRoot\":\"\"}]);\n// Exports\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL3NyYy9zdHlsZS5zY3NzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7QUFDMEc7QUFDakI7QUFDekYsOEJBQThCLG1GQUEyQixDQUFDLDRGQUFxQztBQUMvRjtBQUNBLHNEQUFzRCx1QkFBdUIsa0JBQWtCLG1DQUFtQyxxQkFBcUIsNEJBQTRCLDRCQUE0QixrQkFBa0IsR0FBRywwQ0FBMEMsc0JBQXNCLHdCQUF3QixHQUFHLHVCQUF1QixrQkFBa0Isb0JBQW9CLHFCQUFxQix1QkFBdUIsMkJBQTJCLGlDQUFpQyxHQUFHLG9CQUFvQixtQkFBbUIsd0JBQXdCLEdBQUcsK0JBQStCLGlCQUFpQixHQUFHLG9CQUFvQixrQkFBa0IsYUFBYSxHQUFHLDREQUE0RCw4QkFBOEIsb0JBQW9CLGtCQUFrQixHQUFHLHdFQUF3RSxvQkFBb0IsNEJBQTRCLEdBQUcsK0JBQStCLDBCQUEwQixHQUFHLE9BQU8sZUFBZSxjQUFjLDJCQUEyQixHQUFHLFVBQVUsMENBQTBDLGtCQUFrQixpQkFBaUIsa0JBQWtCLDJCQUEyQixHQUFHLGFBQWEsa0JBQWtCLDRCQUE0Qix3QkFBd0IsZ0NBQWdDLDRDQUE0QyxpQkFBaUIsc0JBQXNCLHFCQUFxQixjQUFjLGdCQUFnQixHQUFHLGlCQUFpQixxQkFBcUIsaUJBQWlCLEdBQUcsY0FBYyxrQkFBa0IsbUNBQW1DLGtCQUFrQixHQUFHLHFCQUFxQixzQkFBc0Isa0JBQWtCLDRDQUE0QyxHQUFHLGlDQUFpQyw0QkFBNEIsR0FBRyx3QkFBd0IsdUJBQXVCLDBCQUEwQixHQUFHLDhCQUE4QixrQkFBa0IsR0FBRyxnQ0FBZ0MsMEJBQTBCLGlCQUFpQiwrQkFBK0IsR0FBRyxvQ0FBb0Msa0JBQWtCLGtCQUFrQiwyQkFBMkIsY0FBYyw0QkFBNEIsd0JBQXdCLG1CQUFtQixHQUFHLCtDQUErQyxzQkFBc0IsaUJB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QXNCLEdBQUcsZ0RBQWdELHdCQUF3QixHQUFHLGVBQWUsbUJBQW1CLG9DQUFvQyxHQUFHLHNCQUFzQiw0QkFBNEIsR0FBRyx5QkFBeUIsc0JBQXNCLGVBQWUsZ0JBQWdCLHNCQUFzQixvQkFBb0IsbUJBQW1CLDZDQUE2QyxlQUFlLDJCQUEyQixPQUFPLGtCQUFrQixtQ0FBbUMsT0FBTyxHQUFHLGtCQUFrQixlQUFlLGdDQUFnQyxpQ0FBaUMsdUJBQXVCLGtDQUFrQyx5QkFBeUIsbUJBQW1CO0FBQ2x0VztBQUNBLGlFQUFlLHVCQUF1QixFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdG9kby1saXN0Ly4vc3JjL3N0eWxlLnNjc3M/ODc2YyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBJbXBvcnRzXG5pbXBvcnQgX19fQ1NTX0xPQURFUl9BUElfU09VUkNFTUFQX0lNUE9SVF9fXyBmcm9tIFwiLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL3NvdXJjZU1hcHMuanNcIjtcbmltcG9ydCBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18gZnJvbSBcIi4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9hcGkuanNcIjtcbnZhciBfX19DU1NfTE9BREVSX0VYUE9SVF9fXyA9IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyhfX19DU1NfTE9BREVSX0FQSV9TT1VSQ0VNQVBfSU1QT1JUX19fKTtcbi8vIE1vZHVsZVxuX19fQ1NTX0xPQURFUl9FWFBPUlRfX18ucHVzaChbbW9kdWxlLmlkLCBcIi5jb250YWluZXIge1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgZGlzcGxheTogZ3JpZDtcXG4gIGdyaWQtdGVtcGxhdGUtY29sdW1uczogMWZyIDFmcjtcXG4gIG1pbi13aWR0aDogMjVyZW07XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiB3aGl0ZTtcXG4gIGJvcmRlcjogMXB4IHNvbGlkIGJsYWNrO1xcbiAgcGFkZGluZzogMTBweDtcXG59XFxuLmNvbnRhaW5lciBsYWJlbCxcXG4uY29udGFpbmVyIHRleHRhcmVhIHtcXG4gIGZvbnQtc2l6ZTogMC44cmVtO1xcbiAgbGV0dGVyLXNwYWNpbmc6IDFweDtcXG59XFxuLmNvbnRhaW5lciB0ZXh0YXJlYSB7XFxuICBwYWRkaW5nOiAxMHB4O1xcbiAgbWF4LXdpZHRoOiAxMDAlO1xcbiAgbGluZS1oZWlnaHQ6IDEuNTtcXG4gIGJvcmRlci1yYWRpdXM6IDVweDtcXG4gIGJvcmRlcjogMXB4IHNvbGlkICNjY2M7XFxuICBib3gtc2hhZG93OiAxcHggMXB4IDFweCAjOTk5O1xcbn1cXG4uY29udGFpbmVyIGxhYmVsIHtcXG4gIGRpc3BsYXk6IGJsb2NrO1xcbiAgbWFyZ2luLWJvdHRvbTogMTBweDtcXG59XFxuLmNvbnRhaW5lciBpbnB1dFt0eXBlPXRleHRdIHtcXG4gIHBhZGRpbmc6IDJweDtcXG59XFxuLmNvbnRhaW5lciAuYnRucyB7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAgZ2FwOiA1cHg7XFxufVxcbi5jb250YWluZXIgLmJ0bnMgLnN1Ym1pdEJ0biwgLmNvbnRhaW5lciAuYnRucyAuY2FuY2VsQnRuIHtcXG4gIGJhY2tncm91bmQtY29sb3I6ICNhM2M5YmM7XFxuICBtYXgtd2lkdGg6IDUwcHg7XFxuICBwYWRkaW5nOiAxMHB4O1xcbn1cXG4uY29udGFpbmVyIC5idG5zIC5zdWJtaXRCdG46aG92ZXIsIC5jb250YWluZXIgLmJ0bnMgLmNhbmNlbEJ0bjpob3ZlciB7XFxuICBjdXJzb3I6IHBvaW50ZXI7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiB3aGl0ZTtcXG59XFxuLmNvbnRhaW5lciAuYnRucyAuY2FuY2VsQnRuIHtcXG4gIGJhY2tncm91bmQtY29sb3I6IHJlZDtcXG59XFxuXFxuKiB7XFxuICBwYWRkaW5nOiAwO1xcbiAgbWFyZ2luOiAwO1xcbiAgYm94LXNpemluZzogYm9yZGVyLWJveDtcXG59XFxuXFxuYm9keSB7XFxuICBmb250LWZhbWlseTogXFxcIkNvbWluZyBTb29uXFxcIiwgY3Vyc2l2ZTtcXG4gIGhlaWdodDogMTAwdmg7XFxuICB3aWR0aDogMTAwdnc7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXG59XFxuXFxuI2hlYWRlciB7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxuICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAganVzdGlmeS1jb250ZW50OiBmbGV4LXN0YXJ0O1xcbiAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgyNTUsIDcyLCAwLCAwLjgpO1xcbiAgY29sb3I6IHdoaXRlO1xcbiAgZm9udC1zaXplOiAyLjVyZW07XFxuICBmb250LXdlaWdodDogOTAwO1xcbiAgZ2FwOiAxcmVtO1xcbiAgd2lkdGg6IDEwMCU7XFxufVxcbiNoZWFkZXIgLmxvZ28ge1xcbiAgbWF4LWhlaWdodDogNXJlbTtcXG4gIHBhZGRpbmc6IDVweDtcXG59XFxuXFxuI2NvbnRlbnQge1xcbiAgZGlzcGxheTogZ3JpZDtcXG4gIGdyaWQtdGVtcGxhdGUtY29sdW1uczogMWZyIDZmcjtcXG4gIGhlaWdodDogMTAwdmg7XFxufVxcbiNjb250ZW50IC5zaWRlYmFyIHtcXG4gIGZvbnQtc2l6ZTogMS41cmVtO1xcbiAgcGFkZGluZzogMTBweDtcXG4gIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMjU1LCA3MiwgMCwgMC41KTtcXG59XFxuI2NvbnRlbnQgLnNpZGViYXIgbGkucHJvamVjdHMge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogd2hpdGU7XFxufVxcbiNjb250ZW50IC5zaWRlYmFyIHVsIHtcXG4gIHRleHQtYWxpZ246IGNlbnRlcjtcXG4gIGxpc3Qtc3R5bGUtdHlwZTogbm9uZTtcXG59XFxuI2NvbnRlbnQgLnNpZGViYXIgdWwgLmxpbmsge1xcbiAgcGFkZGluZzogMTBweDtcXG59XFxuI2NvbnRlbnQgLnNpZGViYXIgdWwgLmxpbmsgYSB7XFxuICB0ZXh0LWRlY29yYXRpb246IG5vbmU7XFxuICBjb2xvcjogYmxhY2s7XFxuICB0ZXh0LXNoYWRvdzogMXB4IDFweCB3aGl0ZTtcXG59XFxuI2NvbnRlbnQgLnNpZGViYXIgbGkucHJvamVjdHMgdWwge1xcbiAgcGFkZGluZzogMTBweDtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xcbiAgZ2FwOiAxMHB4O1xcbiAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxuICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgbWFyZ2luOiAwIGF1dG87XFxufVxcbiNjb250ZW50IC5zaWRlYmFyIGxpLnByb2plY3RzIHVsIGxpLnByb2plY3Qge1xcbiAgZm9udC1zaXplOiAxLjNyZW07XFxuICBwYWRkaW5nOiA1cHg7XFxuICB3aWR0aDogMjAwcHg7XFxufVxcbiNjb250ZW50IC5zaWRlYmFyIGxpLnByb2plY3RzIHVsIGxpLnByb2plY3Q6aG92ZXIge1xcbiAgY3Vyc29yOiBwb2ludGVyO1xcbn1cXG4jY29udGVudCAuc2lkZWJhciBsaS5wcm9qZWN0cyB1bCBsaS5wcm9qZWN0IGEge1xcbiAgZGlzcGxheTogZmxleDtcXG4gIGdhcDogMTBweDtcXG4gIGp1c3RpZnktY29udGVudDogY2VudGVyO1xcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gIHBhZGRpbmc6IDVweDtcXG4gIGJvcmRlcjogMXB4IHNvbGlkO1xcbiAgZm9udC1mYW1pbHk6IFxcXCJyb2NrIHNhbHRcXFwiLCBjdXJzaXZlO1xcbn1cXG4jY29udGVudCAudG9kb0xpc3Qge1xcbiAgZGlzcGxheTogZmxleDtcXG4gIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XFxuICBqdXN0aWZ5LWNvbnRlbnQ6IGZsZXgtc3RhcnQ7XFxuICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgZ2FwOiAxMHB4O1xcbiAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgyNTUsIDcyLCAwLCAwLjEpO1xcbn1cXG4jY29udGVudCAudG9kb0xpc3QgdGFibGUge1xcbiAgbWluLXdpZHRoOiA4MDBweDtcXG4gIG1heC13aWR0aDogMTIwMHB4O1xcbn1cXG4jY29udGVudCAudG9kb0xpc3QgdGFibGUgLnRpdGxlcyB7XFxuICBmb250LXNpemU6IDEuNXJlbTtcXG4gIGZvbnQtZmFtaWx5OiBcXFwiVGltZXMgTmV3IFJvbWFuXFxcIiwgVGltZXMsIHNlcmlmO1xcbn1cXG4jY29udGVudCAudG9kb0xpc3QgdGFibGUgLnRpdGxlczpob3ZlciB7XFxuICBib3gtc2hhZG93OiBub25lO1xcbn1cXG4jY29udGVudCAudG9kb0xpc3QgdGFibGUgLnRpdGxlcyAuZHVlRGF0ZSB7XFxuICB0ZXh0LWFsaWduOiByaWdodDtcXG59XFxuI2NvbnRlbnQgLnRvZG9MaXN0IHRhYmxlIC50aXRsZXMgLnByb2pOYW1lIHtcXG4gIHRleHQtYWxpZ246IGxlZnQ7XFxufVxcbiNjb250ZW50IC50b2RvTGlzdCB0YWJsZSAudGl0bGVzIHRoIHtcXG4gIHBhZGRpbmc6IDEwcHggMDtcXG59XFxuI2NvbnRlbnQgLnRvZG9MaXN0IHRhYmxlIHRyOmhvdmVyLCAjY29udGVudCAudG9kb0xpc3QgdGFibGUgdHIuY3JlYXRlZFJvdzpob3ZlciB7XFxuICBib3gtc2hhZG93OiAwIDAgNXB4IDVweDtcXG59XFxuI2NvbnRlbnQgLnRvZG9MaXN0IHRhYmxlIHRyIHRkLCAjY29udGVudCAudG9kb0xpc3QgdGFibGUgdHIuY3JlYXRlZFJvdyB0ZCB7XFxuICB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlO1xcbiAgbWF4LXdpZHRoOiA2MDBweDtcXG4gIHBhZGRpbmc6IDEwcHg7XFxufVxcbiNjb250ZW50IC50b2RvTGlzdCB0YWJsZSB0ciAuY29sdW1uMSwgI2NvbnRlbnQgLnRvZG9MaXN0IHRhYmxlIHRyLmNyZWF0ZWRSb3cgLmNvbHVtbjEge1xcbiAgZm9udC1zaXplOiAxLjVyZW07XFxufVxcbiNjb250ZW50IC50b2RvTGlzdCB0YWJsZSB0ciAuY29sdW1uMiwgI2NvbnRlbnQgLnRvZG9MaXN0IHRhYmxlIHRyLmNyZWF0ZWRSb3cgLmNvbHVtbjIge1xcbiAgZGlzcGxheTogZmxleDtcXG4gIGp1c3RpZnktY29udGVudDogZmxleC1lbmQ7XFxuICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgZ2FwOiAxMHB4O1xcbiAgZm9udC1zaXplOiAxLjNyZW07XFxufVxcblxcbmksIC5hZGRUb0RvQnRuLCAuYWRkUHJvamVjdEJ0biB7XFxuICBjdXJzb3I6IHBvaW50ZXI7XFxufVxcblxcbi5mYS1hcnJvdy1kb3duLCAuZmEtY2FsZW5kYXIsIC5mYS1leGNsYW1hdGlvbiB7XFxuICBtYXJnaW4tbGVmdDogMTBweDtcXG59XFxuXFxuLmNvbXBsZXRlZCB7XFxuICBvcGFjaXR5OiAwLjU7XFxuICB0ZXh0LWRlY29yYXRpb246IGxpbmUtdGhyb3VnaDtcXG59XFxuXFxuLmNvbXBsZXRlZCAuY29sdW1uMiB7XFxuICB0ZXh0LWRlY29yYXRpb246IG5vbmU7XFxufVxcblxcbiNtb2RhbCwgI2VkaXRNb2RhbCB7XFxuICB0b3A6IDM1JTtcXG4gIGxlZnQ6IDQwJTtcXG4gIG1heC13aWR0aDogNTBjaDtcXG4gIHBhZGRpbmc6IDEwcHg7XFxufVxcbiNtb2RhbCA+ICosICNlZGl0TW9kYWwgPiAqIHtcXG4gIG1hcmdpbjogMCAwIDAuNXJlbSAwO1xcbn1cXG4jbW9kYWw6OmJhY2tkcm9wLCAjZWRpdE1vZGFsOjpiYWNrZHJvcCB7XFxuICBiYWNrZ3JvdW5kOiByZ2JhKDAsIDAsIDAsIDAuNCk7XFxufVwiLCBcIlwiLHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIndlYnBhY2s6Ly8uL3NyYy9zY3NzL19jb250YWluZXIuc2Nzc1wiLFwid2VicGFjazovLy4vc3JjL3N0eWxlLnNjc3NcIixcIndlYnBhY2s6Ly8uL3NyYy9zY3NzL19nbG9iYWxzLnNjc3NcIl0sXCJuYW1lc1wiOltdLFwibWFwcGluZ3NcIjpcIkFBQUE7RUFFSSxrQkFBQTtFQUNBLGFBQUE7RUFDQSw4QkFBQTtFQUNBLGdCQUFBO0VBQ0EsdUJBQUE7RUFDQSx1QkFBQTtFQUNBLGFBQUE7QUNBSjtBREVJOztFQUVJLGlCQUFBO0VBQ0EsbUJBQUE7QUNBUjtBREdJO0VBQ0ksYUFBQTtFQUNBLGVBQUE7RUFDQSxnQkFBQTtFQUNBLGtCQUFBO0VBQ0Esc0JBQUE7RUFDQSw0QkFBQTtBQ0RSO0FESUk7RUFDSSxjQUFBO0VBQ0EsbUJBQUE7QUNGUjtBREtJO0VBQ0ksWUFBQTtBQ0hSO0FETUk7RUFDSSxhQUFBO0VBQ0EsUUFBQTtBQ0pSO0FES1E7RUFDSSx5QkFBQTtFQUNBLGVBQUE7RUFDQSxhQUFBO0FDSFo7QURJWTtFQUNJLGVBQUE7RUFDQSx1QkFBQTtBQ0ZoQjtBREtRO0VBQ0kscUJBQUE7QUNIWjs7QUFuQ0E7RUFDSSxVQUFBO0VBQ0EsU0FBQTtFQUNBLHNCQUFBO0FBc0NKOztBQW5DQTtFQUNJLG1DQUFBO0VBQ0EsYUFBQTtFQUNBLFlBQUE7RUFDQSxhQUFBO0VBQ0Esc0JBQUE7QUFzQ0o7O0FBbkNBO0VBbkJJLGFBQUE7RUFDQSx1QkFBQTtFQUNBLG1CQUFBO0VBbUJBLDJCQUFBO0VBQ0EsdUNDeEJLO0VEeUJMLFlDMUJHO0VEMkJILGlCQUFBO0VBQ0EsZ0JBQUE7RUFDQSxTQUFBO0VBQ0EsV0FBQTtBQXdDSjtBQXZDSTtFQUNJLGdCQUFBO0VBQ0EsWUFBQTtBQXlDUjs7QUFyQ0E7RUFDSSxhQUFBO0VBQ0EsOEJBQUE7RUFDQSxhQUFBO0FBd0NKO0FBdkNJO0VBQ0ksaUJBQUE7RUFDQSxhQUFBO0VBQ0EsdUNDMUNFO0FEbUZWO0FBeENRO0VBQ0ksdUJBQUE7QUEwQ1o7QUF4Q1E7RUFDSSxrQkFBQTtFQUNBLHFCQUFBO0FBMENaO0FBekNZO0VBQ0ksYUFBQTtBQTJDaEI7QUExQ2dCO0VBQ0kscUJBQUE7RUFDQSxZQ3BETDtFRHFESywwQkFBQTtBQTRDcEI7QUF4Q1E7RUFDSSxhQUFBO0VBQ0EsYUFBQTtFQUNBLHNCQUFBO0VBQ0EsU0FBQTtFQUNBLHVCQUFBO0VBQ0EsbUJBQUE7RUFDQSxjQUFBO0FBMENaO0FBekNZO0VBQ0ksaUJBQUE7RUFDQSxZQUFBO0VBQ0EsWUFBQTtBQTJDaEI7QUExQ2dCO0VBQ0ksZUFBQTtBQTRDcEI7QUExQ2dCO0VBQ0ksYUFBQTtFQUNBLFNBQUE7RUFDQSx1QkFBQTtFQUNBLG1CQUFBO0VBQ0EsWUFBQTtFQUNBLGlCQUFBO0VBQ0EsaUNBQUE7QUE0Q3BCO0FBdkNJO0VBQ0ksYUFBQTtFQUNBLHNCQUFBO0VBQ0EsMkJBQUE7RUFDQSxtQkFBQTtFQUNBLFNBQUE7RUFDQSx1Q0N6Rkc7QURrSVg7QUF4Q1E7RUFFSSxnQkFBQTtFQUNBLGlCQUFBO0FBeUNaO0FBeENZO0VBSUksaUJBQUE7RUFDQSw0Q0FBQTtBQXVDaEI7QUEzQ2dCO0VBQ0ksZ0JBQUE7QUE2Q3BCO0FBekNnQjtFQUNJLGlCQUFBO0FBMkNwQjtBQXpDZ0I7RUFDSSxnQkFBQTtBQTJDcEI7QUF6Q2dCO0VBQ0ksZUFBQTtBQTJDcEI7QUF0Q2dCO0VBQ0ksdUJBQUE7QUF3Q3BCO0FBdENnQjtFQUNJLHNCQUFBO0VBQ0EsZ0JBQUE7RUFDQSxhQUFBO0FBd0NwQjtBQXRDZ0I7RUFDSSxpQkFBQTtBQXdDcEI7QUF0Q2dCO0VBQ0ksYUFBQTtFQUNBLHlCQUFBO0VBQ0EsbUJBQUE7RUFDQSxTQUFBO0VBQ0EsaUJBQUE7QUF3Q3BCOztBQWpDQTtFQUNJLGVBQUE7QUFvQ0o7O0FBbENBO0VBQ0ksaUJBQUE7QUFxQ0o7O0FBbENBO0VBQ0ksWUFBQTtFQUNBLDZCQUFBO0FBcUNKOztBQW5DQTtFQUNJLHFCQUFBO0FBc0NKOztBQWxDQTtFQUVJLFFBQUE7RUFDQSxTQUFBO0VBQ0EsZUFBQTtFQUNBLGFBQUE7QUFvQ0o7QUFoQ0k7RUFDQSxvQkFBQTtBQWtDSjtBQWhDSTtFQUNBLDhCQUFBO0FBa0NKXCIsXCJzb3VyY2VzQ29udGVudFwiOltcIi5jb250YWluZXJ7XFxuXFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgZGlzcGxheTogZ3JpZDtcXG4gICAgZ3JpZC10ZW1wbGF0ZS1jb2x1bW5zOiAxZnIgMWZyO1xcbiAgICBtaW4td2lkdGg6IDI1cmVtO1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAkVE9ET19JTkZPX0ZPUk07XFxuICAgIGJvcmRlcjogMXB4IHNvbGlkIGJsYWNrO1xcbiAgICBwYWRkaW5nOiAxMHB4O1xcbiAgICBcXG4gICAgbGFiZWwsXFxuICAgIHRleHRhcmVhIHtcXG4gICAgICAgIGZvbnQtc2l6ZTogLjhyZW07XFxuICAgICAgICBsZXR0ZXItc3BhY2luZzogMXB4O1xcbiAgICB9XFxuXFxuICAgIHRleHRhcmVhIHtcXG4gICAgICAgIHBhZGRpbmc6IDEwcHg7XFxuICAgICAgICBtYXgtd2lkdGg6IDEwMCU7XFxuICAgICAgICBsaW5lLWhlaWdodDogMS41O1xcbiAgICAgICAgYm9yZGVyLXJhZGl1czogNXB4O1xcbiAgICAgICAgYm9yZGVyOiAxcHggc29saWQgI2NjYztcXG4gICAgICAgIGJveC1zaGFkb3c6IDFweCAxcHggMXB4ICM5OTk7XFxuICAgIH1cXG5cXG4gICAgbGFiZWwge1xcbiAgICAgICAgZGlzcGxheTogYmxvY2s7XFxuICAgICAgICBtYXJnaW4tYm90dG9tOiAxMHB4O1xcbiAgICB9XFxuXFxuICAgIGlucHV0W3R5cGU9XFxcInRleHRcXFwiXXtcXG4gICAgICAgIHBhZGRpbmc6IDJweDtcXG4gICAgfVxcblxcbiAgICAuYnRuc3tcXG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgICAgICBnYXA6IDVweDtcXG4gICAgICAgIC5zdWJtaXRCdG4sIC5jYW5jZWxCdG57XFxuICAgICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogcmdiKDE2MywgMjAxLCAxODgpO1xcbiAgICAgICAgICAgIG1heC13aWR0aDogNTBweDtcXG4gICAgICAgICAgICBwYWRkaW5nOiAxMHB4O1xcbiAgICAgICAgICAgICY6aG92ZXJ7XFxuICAgICAgICAgICAgICAgIGN1cnNvcjogcG9pbnRlcjtcXG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogd2hpdGU7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgLmNhbmNlbEJ0bntcXG4gICAgICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZWQ7XFxuICAgICAgICB9XFxuICAgIH1cXG59XCIsXCJAaW1wb3J0ICcuL3Njc3MvZ2xvYmFscyc7XFxuQGltcG9ydCAnLi9zY3NzL2NvbnRhaW5lcic7XFxuXFxuQG1peGluIGNlbnRlciB7XFxuICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xcbn1cXG5cXG4qe1xcbiAgICBwYWRkaW5nOiAwO1xcbiAgICBtYXJnaW46IDA7XFxuICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxufVxcblxcbmJvZHl7XFxuICAgIGZvbnQtZmFtaWx5OiAnQ29taW5nIFNvb24nLCBjdXJzaXZlO1xcbiAgICBoZWlnaHQ6IDEwMHZoO1xcbiAgICB3aWR0aDogMTAwdnc7XFxuICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XFxufVxcblxcbiNoZWFkZXJ7XFxuICAgIEBpbmNsdWRlIGNlbnRlcjtcXG4gICAganVzdGlmeS1jb250ZW50OiBmbGV4LXN0YXJ0O1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAkSEVBREVSO1xcbiAgICBjb2xvcjogJEZPTlQ7XFxuICAgIGZvbnQtc2l6ZTogMi41cmVtO1xcbiAgICBmb250LXdlaWdodDogOTAwO1xcbiAgICBnYXA6IDFyZW07XFxuICAgIHdpZHRoOiAxMDAlO1xcbiAgICAubG9nb3tcXG4gICAgICAgIG1heC1oZWlnaHQ6IDVyZW07XFxuICAgICAgICBwYWRkaW5nOiA1cHg7XFxuICAgIH1cXG59XFxuXFxuI2NvbnRlbnR7XFxuICAgIGRpc3BsYXk6IGdyaWQ7XFxuICAgIGdyaWQtdGVtcGxhdGUtY29sdW1uczogMWZyIDZmcjtcXG4gICAgaGVpZ2h0OiAxMDB2aDtcXG4gICAgLnNpZGViYXJ7XFxuICAgICAgICBmb250LXNpemU6IDEuNXJlbTtcXG4gICAgICAgIHBhZGRpbmc6IDEwcHg7XFxuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAkU0lERUJBUjtcXG4gICAgICAgIGxpLnByb2plY3Rze1xcbiAgICAgICAgICAgIGJhY2tncm91bmQtY29sb3I6IHdoaXRlO1xcbiAgICAgICAgfVxcbiAgICAgICAgdWx7XFxuICAgICAgICAgICAgdGV4dC1hbGlnbjogY2VudGVyO1xcbiAgICAgICAgICAgIGxpc3Qtc3R5bGUtdHlwZTogbm9uZTtcXG4gICAgICAgICAgICAubGlua3tcXG4gICAgICAgICAgICAgICAgcGFkZGluZzogMTBweDtcXG4gICAgICAgICAgICAgICAgYXtcXG4gICAgICAgICAgICAgICAgICAgIHRleHQtZGVjb3JhdGlvbjogbm9uZTtcXG4gICAgICAgICAgICAgICAgICAgIGNvbG9yOiAkU0lERUJBUl9URVhUO1xcbiAgICAgICAgICAgICAgICAgICAgdGV4dC1zaGFkb3c6IDFweCAxcHggd2hpdGU7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICBsaS5wcm9qZWN0cyB1bHtcXG4gICAgICAgICAgICBwYWRkaW5nOiAxMHB4O1xcbiAgICAgICAgICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgICAgICAgICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXG4gICAgICAgICAgICBnYXA6IDEwcHg7XFxuICAgICAgICAgICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxuICAgICAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gICAgICAgICAgICBtYXJnaW46IDAgYXV0bztcXG4gICAgICAgICAgICBsaS5wcm9qZWN0e1xcbiAgICAgICAgICAgICAgICBmb250LXNpemU6IDEuM3JlbTtcXG4gICAgICAgICAgICAgICAgcGFkZGluZzogNXB4O1xcbiAgICAgICAgICAgICAgICB3aWR0aDogMjAwcHg7XFxuICAgICAgICAgICAgICAgICY6aG92ZXJ7XFxuICAgICAgICAgICAgICAgICAgICBjdXJzb3I6IHBvaW50ZXI7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgYXtcXG4gICAgICAgICAgICAgICAgICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgICAgICAgICAgICAgICAgICBnYXA6IDEwcHg7XFxuICAgICAgICAgICAgICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXG4gICAgICAgICAgICAgICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICAgICAgICAgICAgICAgICAgICBwYWRkaW5nOiA1cHg7XFxuICAgICAgICAgICAgICAgICAgICBib3JkZXI6IDFweCBzb2xpZDtcXG4gICAgICAgICAgICAgICAgICAgIGZvbnQtZmFtaWx5OiAncm9jayBzYWx0JywgY3Vyc2l2ZTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgfVxcbiAgICAudG9kb0xpc3R7XFxuICAgICAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICAgICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXG4gICAgICAgIGp1c3RpZnktY29udGVudDogZmxleC1zdGFydDtcXG4gICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICAgICAgICBnYXA6IDEwcHg7XFxuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAkVE9ET0xJU1Q7XFxuICAgICAgICB0YWJsZXtcXG4gICAgICAgICAgICAvLyBtYXJnaW4tdG9wOiAxMHB4O1xcbiAgICAgICAgICAgIG1pbi13aWR0aDogY2xhbXAoMzIwcHgsIDgwMHB4LCAxMDAwcHgpO1xcbiAgICAgICAgICAgIG1heC13aWR0aDogY2xhbXAoNDAwcHgsIDEyMDBweCwgMTYwMHB4KTtcXG4gICAgICAgICAgICAudGl0bGVze1xcbiAgICAgICAgICAgICAgICAmOmhvdmVye1xcbiAgICAgICAgICAgICAgICAgICAgYm94LXNoYWRvdzogbm9uZTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICBmb250LXNpemU6IDEuNXJlbTtcXG4gICAgICAgICAgICAgICAgZm9udC1mYW1pbHk6ICdUaW1lcyBOZXcgUm9tYW4nLCBUaW1lcywgc2VyaWY7XFxuICAgICAgICAgICAgICAgIC5kdWVEYXRle1xcbiAgICAgICAgICAgICAgICAgICAgdGV4dC1hbGlnbjogcmlnaHQ7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgLnByb2pOYW1le1xcbiAgICAgICAgICAgICAgICAgICAgdGV4dC1hbGlnbjogbGVmdDtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICB0aHtcXG4gICAgICAgICAgICAgICAgICAgIHBhZGRpbmc6IDEwcHggMDtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICB0ciwgdHIuY3JlYXRlZFJvd3tcXG4gICAgICAgICAgICAgICAgJjpob3ZlcntcXG4gICAgICAgICAgICAgICAgICAgIGJveC1zaGFkb3c6IDAgMCA1cHggNXB4O1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIHRke1xcbiAgICAgICAgICAgICAgICAgICAgdmVydGljYWwtYWxpZ246IG1pZGRsZTtcXG4gICAgICAgICAgICAgICAgICAgIG1heC13aWR0aDogNjAwcHg7XFxuICAgICAgICAgICAgICAgICAgICBwYWRkaW5nOiAxMHB4O1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIC5jb2x1bW4xe1xcbiAgICAgICAgICAgICAgICAgICAgZm9udC1zaXplOiAxLjVyZW07XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgLmNvbHVtbjJ7XFxuICAgICAgICAgICAgICAgICAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICAgICAgICAgICAgICAgICAganVzdGlmeS1jb250ZW50OiBmbGV4LWVuZDtcXG4gICAgICAgICAgICAgICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICAgICAgICAgICAgICAgICAgICBnYXA6IDEwcHg7XFxuICAgICAgICAgICAgICAgICAgICBmb250LXNpemU6IDEuM3JlbTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgfVxcbn1cXG5cXG5pLCAuYWRkVG9Eb0J0biwgLmFkZFByb2plY3RCdG57XFxuICAgIGN1cnNvcjogcG9pbnRlcjtcXG59XFxuLmZhLWFycm93LWRvd24sIC5mYS1jYWxlbmRhciwgLmZhLWV4Y2xhbWF0aW9ue1xcbiAgICBtYXJnaW4tbGVmdDogMTBweDtcXG59XFxuXFxuLmNvbXBsZXRlZHtcXG4gICAgb3BhY2l0eTogMC41O1xcbiAgICB0ZXh0LWRlY29yYXRpb246IGxpbmUtdGhyb3VnaDtcXG59XFxuLmNvbXBsZXRlZCAuY29sdW1uMntcXG4gICAgdGV4dC1kZWNvcmF0aW9uOiBub25lO1xcbn1cXG5cXG5cXG4jbW9kYWwsICNlZGl0TW9kYWx7XFxuICAgIC8vIHBhZGRpbmc6IDFlbTtcXG4gICAgdG9wOiAzNSU7XFxuICAgIGxlZnQ6IDQwJTtcXG4gICAgbWF4LXdpZHRoOiA1MGNoO1xcbiAgICBwYWRkaW5nOiAxMHB4O1xcbiAgICAvLyBib3JkZXI6IDA7XFxuICAgIC8vIGJveC1zaGFkb3c6IDAgMCAxZW0gcmdiKDAgMCAwIC8gLjMpO1xcblxcbiAgICAmID4gKiB7XFxuICAgIG1hcmdpbjogMCAwIDAuNXJlbSAwO1xcbiAgICB9XFxuICAgICY6OmJhY2tkcm9we1xcbiAgICBiYWNrZ3JvdW5kOiByZ2IoMCAwIDAgLyAwLjQpO1xcbiAgICB9XFxufVwiLFwiJEJPRFk6ICMzZjNmM2Y7XFxuJEZPTlQ6IHdoaXRlO1xcbiRIRUFERVI6IHJnYmEoMjU1LCA3MiwgMCwgLjgpO1xcbiRTSURFQkFSOiByZ2JhKDI1NSwgNzIsIDAsIC41KTtcXG4kU0lERUJBUl9URVhUOiBibGFjaztcXG4kVE9ET0xJU1Q6IHJnYmEoMjU1LCA3MiwgMCwgLjEpO1xcbiRUT0RPX0lORk9fRk9STTogd2hpdGU7XCJdLFwic291cmNlUm9vdFwiOlwiXCJ9XSk7XG4vLyBFeHBvcnRzXG5leHBvcnQgZGVmYXVsdCBfX19DU1NfTE9BREVSX0VYUE9SVF9fXztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/css-loader/dist/cjs.js!./node_modules/sass-loader/dist/cjs.js!./src/style.scss\n");

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/api.js":
/*!*****************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/api.js ***!
  \*****************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n*/\nmodule.exports = function (cssWithMappingToString) {\n  var list = []; // return the list of modules as css string\n\n  list.toString = function toString() {\n    return this.map(function (item) {\n      var content = \"\";\n      var needLayer = typeof item[5] !== \"undefined\";\n\n      if (item[4]) {\n        content += \"@supports (\".concat(item[4], \") {\");\n      }\n\n      if (item[2]) {\n        content += \"@media \".concat(item[2], \" {\");\n      }\n\n      if (needLayer) {\n        content += \"@layer\".concat(item[5].length > 0 ? \" \".concat(item[5]) : \"\", \" {\");\n      }\n\n      content += cssWithMappingToString(item);\n\n      if (needLayer) {\n        content += \"}\";\n      }\n\n      if (item[2]) {\n        content += \"}\";\n      }\n\n      if (item[4]) {\n        content += \"}\";\n      }\n\n      return content;\n    }).join(\"\");\n  }; // import a list of modules into the list\n\n\n  list.i = function i(modules, media, dedupe, supports, layer) {\n    if (typeof modules === \"string\") {\n      modules = [[null, modules, undefined]];\n    }\n\n    var alreadyImportedModules = {};\n\n    if (dedupe) {\n      for (var k = 0; k < this.length; k++) {\n        var id = this[k][0];\n\n        if (id != null) {\n          alreadyImportedModules[id] = true;\n        }\n      }\n    }\n\n    for (var _k = 0; _k < modules.length; _k++) {\n      var item = [].concat(modules[_k]);\n\n      if (dedupe && alreadyImportedModules[item[0]]) {\n        continue;\n      }\n\n      if (typeof layer !== \"undefined\") {\n        if (typeof item[5] === \"undefined\") {\n          item[5] = layer;\n        } else {\n          item[1] = \"@layer\".concat(item[5].length > 0 ? \" \".concat(item[5]) : \"\", \" {\").concat(item[1], \"}\");\n          item[5] = layer;\n        }\n      }\n\n      if (media) {\n        if (!item[2]) {\n          item[2] = media;\n        } else {\n          item[1] = \"@media \".concat(item[2], \" {\").concat(item[1], \"}\");\n          item[2] = media;\n        }\n      }\n\n      if (supports) {\n        if (!item[4]) {\n          item[4] = \"\".concat(supports);\n        } else {\n          item[1] = \"@supports (\".concat(item[4], \") {\").concat(item[1], \"}\");\n          item[4] = supports;\n        }\n      }\n\n      list.push(item);\n    }\n  };\n\n  return list;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscURBQXFEO0FBQ3JEOztBQUVBO0FBQ0EsZ0RBQWdEO0FBQ2hEOztBQUVBO0FBQ0EscUZBQXFGO0FBQ3JGOztBQUVBOztBQUVBO0FBQ0EscUJBQXFCO0FBQ3JCOztBQUVBO0FBQ0EscUJBQXFCO0FBQ3JCOztBQUVBO0FBQ0EscUJBQXFCO0FBQ3JCOztBQUVBO0FBQ0EsS0FBSztBQUNMLEtBQUs7OztBQUdMO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0Esc0JBQXNCLGlCQUFpQjtBQUN2Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFCQUFxQixxQkFBcUI7QUFDMUM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixzRkFBc0YscUJBQXFCO0FBQzNHO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsaURBQWlELHFCQUFxQjtBQUN0RTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLHNEQUFzRCxxQkFBcUI7QUFDM0U7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdG9kby1saXN0Ly4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2FwaS5qcz8yNGZiIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG4vKlxuICBNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuICBBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4qL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoY3NzV2l0aE1hcHBpbmdUb1N0cmluZykge1xuICB2YXIgbGlzdCA9IFtdOyAvLyByZXR1cm4gdGhlIGxpc3Qgb2YgbW9kdWxlcyBhcyBjc3Mgc3RyaW5nXG5cbiAgbGlzdC50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgdmFyIGNvbnRlbnQgPSBcIlwiO1xuICAgICAgdmFyIG5lZWRMYXllciA9IHR5cGVvZiBpdGVtWzVdICE9PSBcInVuZGVmaW5lZFwiO1xuXG4gICAgICBpZiAoaXRlbVs0XSkge1xuICAgICAgICBjb250ZW50ICs9IFwiQHN1cHBvcnRzIChcIi5jb25jYXQoaXRlbVs0XSwgXCIpIHtcIik7XG4gICAgICB9XG5cbiAgICAgIGlmIChpdGVtWzJdKSB7XG4gICAgICAgIGNvbnRlbnQgKz0gXCJAbWVkaWEgXCIuY29uY2F0KGl0ZW1bMl0sIFwiIHtcIik7XG4gICAgICB9XG5cbiAgICAgIGlmIChuZWVkTGF5ZXIpIHtcbiAgICAgICAgY29udGVudCArPSBcIkBsYXllclwiLmNvbmNhdChpdGVtWzVdLmxlbmd0aCA+IDAgPyBcIiBcIi5jb25jYXQoaXRlbVs1XSkgOiBcIlwiLCBcIiB7XCIpO1xuICAgICAgfVxuXG4gICAgICBjb250ZW50ICs9IGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSk7XG5cbiAgICAgIGlmIChuZWVkTGF5ZXIpIHtcbiAgICAgICAgY29udGVudCArPSBcIn1cIjtcbiAgICAgIH1cblxuICAgICAgaWYgKGl0ZW1bMl0pIHtcbiAgICAgICAgY29udGVudCArPSBcIn1cIjtcbiAgICAgIH1cblxuICAgICAgaWYgKGl0ZW1bNF0pIHtcbiAgICAgICAgY29udGVudCArPSBcIn1cIjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgfSkuam9pbihcIlwiKTtcbiAgfTsgLy8gaW1wb3J0IGEgbGlzdCBvZiBtb2R1bGVzIGludG8gdGhlIGxpc3RcblxuXG4gIGxpc3QuaSA9IGZ1bmN0aW9uIGkobW9kdWxlcywgbWVkaWEsIGRlZHVwZSwgc3VwcG9ydHMsIGxheWVyKSB7XG4gICAgaWYgKHR5cGVvZiBtb2R1bGVzID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBtb2R1bGVzID0gW1tudWxsLCBtb2R1bGVzLCB1bmRlZmluZWRdXTtcbiAgICB9XG5cbiAgICB2YXIgYWxyZWFkeUltcG9ydGVkTW9kdWxlcyA9IHt9O1xuXG4gICAgaWYgKGRlZHVwZSkge1xuICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCB0aGlzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgIHZhciBpZCA9IHRoaXNba11bMF07XG5cbiAgICAgICAgaWYgKGlkICE9IG51bGwpIHtcbiAgICAgICAgICBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2lkXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKHZhciBfayA9IDA7IF9rIDwgbW9kdWxlcy5sZW5ndGg7IF9rKyspIHtcbiAgICAgIHZhciBpdGVtID0gW10uY29uY2F0KG1vZHVsZXNbX2tdKTtcblxuICAgICAgaWYgKGRlZHVwZSAmJiBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2l0ZW1bMF1dKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGxheWVyICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaXRlbVs1XSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgIGl0ZW1bNV0gPSBsYXllcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpdGVtWzFdID0gXCJAbGF5ZXJcIi5jb25jYXQoaXRlbVs1XS5sZW5ndGggPiAwID8gXCIgXCIuY29uY2F0KGl0ZW1bNV0pIDogXCJcIiwgXCIge1wiKS5jb25jYXQoaXRlbVsxXSwgXCJ9XCIpO1xuICAgICAgICAgIGl0ZW1bNV0gPSBsYXllcjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAobWVkaWEpIHtcbiAgICAgICAgaWYgKCFpdGVtWzJdKSB7XG4gICAgICAgICAgaXRlbVsyXSA9IG1lZGlhO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGl0ZW1bMV0gPSBcIkBtZWRpYSBcIi5jb25jYXQoaXRlbVsyXSwgXCIge1wiKS5jb25jYXQoaXRlbVsxXSwgXCJ9XCIpO1xuICAgICAgICAgIGl0ZW1bMl0gPSBtZWRpYTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoc3VwcG9ydHMpIHtcbiAgICAgICAgaWYgKCFpdGVtWzRdKSB7XG4gICAgICAgICAgaXRlbVs0XSA9IFwiXCIuY29uY2F0KHN1cHBvcnRzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpdGVtWzFdID0gXCJAc3VwcG9ydHMgKFwiLmNvbmNhdChpdGVtWzRdLCBcIikge1wiKS5jb25jYXQoaXRlbVsxXSwgXCJ9XCIpO1xuICAgICAgICAgIGl0ZW1bNF0gPSBzdXBwb3J0cztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBsaXN0LnB1c2goaXRlbSk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBsaXN0O1xufTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/css-loader/dist/runtime/api.js\n");

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/sourceMaps.js":
/*!************************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/sourceMaps.js ***!
  \************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = function (item) {\n  var content = item[1];\n  var cssMapping = item[3];\n\n  if (!cssMapping) {\n    return content;\n  }\n\n  if (typeof btoa === \"function\") {\n    var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(cssMapping))));\n    var data = \"sourceMappingURL=data:application/json;charset=utf-8;base64,\".concat(base64);\n    var sourceMapping = \"/*# \".concat(data, \" */\");\n    var sourceURLs = cssMapping.sources.map(function (source) {\n      return \"/*# sourceURL=\".concat(cssMapping.sourceRoot || \"\").concat(source, \" */\");\n    });\n    return [content].concat(sourceURLs).concat([sourceMapping]).join(\"\\n\");\n  }\n\n  return [content].join(\"\\n\");\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvc291cmNlTWFwcy5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1REFBdUQsY0FBYztBQUNyRTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdG9kby1saXN0Ly4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL3NvdXJjZU1hcHMuanM/YWYxMiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXRlbSkge1xuICB2YXIgY29udGVudCA9IGl0ZW1bMV07XG4gIHZhciBjc3NNYXBwaW5nID0gaXRlbVszXTtcblxuICBpZiAoIWNzc01hcHBpbmcpIHtcbiAgICByZXR1cm4gY29udGVudDtcbiAgfVxuXG4gIGlmICh0eXBlb2YgYnRvYSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgdmFyIGJhc2U2NCA9IGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KGNzc01hcHBpbmcpKSkpO1xuICAgIHZhciBkYXRhID0gXCJzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxcIi5jb25jYXQoYmFzZTY0KTtcbiAgICB2YXIgc291cmNlTWFwcGluZyA9IFwiLyojIFwiLmNvbmNhdChkYXRhLCBcIiAqL1wiKTtcbiAgICB2YXIgc291cmNlVVJMcyA9IGNzc01hcHBpbmcuc291cmNlcy5tYXAoZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgICAgcmV0dXJuIFwiLyojIHNvdXJjZVVSTD1cIi5jb25jYXQoY3NzTWFwcGluZy5zb3VyY2VSb290IHx8IFwiXCIpLmNvbmNhdChzb3VyY2UsIFwiICovXCIpO1xuICAgIH0pO1xuICAgIHJldHVybiBbY29udGVudF0uY29uY2F0KHNvdXJjZVVSTHMpLmNvbmNhdChbc291cmNlTWFwcGluZ10pLmpvaW4oXCJcXG5cIik7XG4gIH1cblxuICByZXR1cm4gW2NvbnRlbnRdLmpvaW4oXCJcXG5cIik7XG59OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/css-loader/dist/runtime/sourceMaps.js\n");

/***/ }),

/***/ "./node_modules/jsbi/dist/jsbi-umd.js":
/*!********************************************!*\
  !*** ./node_modules/jsbi/dist/jsbi-umd.js ***!
  \********************************************/
/***/ (function(module) {

eval("(function(e,t){ true?module.exports=t():0})(this,function(){\"use strict\";var e=Math.imul,t=Math.clz32;function i(e){\"@babel/helpers - typeof\";return i=\"function\"==typeof Symbol&&\"symbol\"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&\"function\"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?\"symbol\":typeof e},i(e)}function _(e,t){if(!(e instanceof t))throw new TypeError(\"Cannot call a class as a function\")}function n(e,t){for(var _,n=0;n<t.length;n++)_=t[n],_.enumerable=_.enumerable||!1,_.configurable=!0,\"value\"in _&&(_.writable=!0),Object.defineProperty(e,_.key,_)}function l(e,t,i){return t&&n(e.prototype,t),i&&n(e,i),Object.defineProperty(e,\"prototype\",{writable:!1}),e}function g(e,t){if(\"function\"!=typeof t&&null!==t)throw new TypeError(\"Super expression must either be null or a function\");e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),Object.defineProperty(e,\"prototype\",{writable:!1}),t&&u(e,t)}function a(e){return a=Object.setPrototypeOf?Object.getPrototypeOf:function(e){return e.__proto__||Object.getPrototypeOf(e)},a(e)}function u(e,t){return u=Object.setPrototypeOf||function(e,t){return e.__proto__=t,e},u(e,t)}function s(){if(\"undefined\"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if(\"function\"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],function(){})),!0}catch(t){return!1}}function r(){return r=s()?Reflect.construct:function(e,t,i){var _=[null];_.push.apply(_,t);var n=Function.bind.apply(e,_),l=new n;return i&&u(l,i.prototype),l},r.apply(null,arguments)}function d(e){return-1!==Function.toString.call(e).indexOf(\"[native code]\")}function h(e){var t=\"function\"==typeof Map?new Map:void 0;return h=function(e){function i(){return r(e,arguments,a(this).constructor)}if(null===e||!d(e))return e;if(\"function\"!=typeof e)throw new TypeError(\"Super expression must either be null or a function\");if(\"undefined\"!=typeof t){if(t.has(e))return t.get(e);t.set(e,i)}return i.prototype=Object.create(e.prototype,{constructor:{value:i,enumerable:!1,writable:!0,configurable:!0}}),u(i,e)},h(e)}function b(e){if(void 0===e)throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");return e}function m(e,t){if(t&&(\"object\"==typeof t||\"function\"==typeof t))return t;if(void 0!==t)throw new TypeError(\"Derived constructors may only return object or undefined\");return b(e)}function c(e){var t=s();return function(){var i,_=a(e);if(t){var n=a(this).constructor;i=Reflect.construct(_,arguments,n)}else i=_.apply(this,arguments);return m(this,i)}}function v(e,t){return y(e)||f(e,t)||D(e,t)||k()}function y(e){if(Array.isArray(e))return e}function f(e,t){var i=null==e?null:\"undefined\"!=typeof Symbol&&e[Symbol.iterator]||e[\"@@iterator\"];if(null!=i){var _,n,l=[],g=!0,o=!1;try{for(i=i.call(e);!(g=(_=i.next()).done)&&(l.push(_.value),!(t&&l.length===t));g=!0);}catch(e){o=!0,n=e}finally{try{g||null==i[\"return\"]||i[\"return\"]()}finally{if(o)throw n}}return l}}function D(e,t){if(e){if(\"string\"==typeof e)return p(e,t);var i=Object.prototype.toString.call(e).slice(8,-1);return\"Object\"===i&&e.constructor&&(i=e.constructor.name),\"Map\"===i||\"Set\"===i?Array.from(e):\"Arguments\"===i||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i)?p(e,t):void 0}}function p(e,t){(null==t||t>e.length)&&(t=e.length);for(var _=0,n=Array(t);_<t;_++)n[_]=e[_];return n}function k(){throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\")}function B(e,t){var _=\"undefined\"!=typeof Symbol&&e[Symbol.iterator]||e[\"@@iterator\"];if(!_){if(Array.isArray(e)||(_=D(e))||t&&e&&\"number\"==typeof e.length){_&&(e=_);var n=0,l=function(){};return{s:l,n:function(){return n>=e.length?{done:!0}:{done:!1,value:e[n++]}},e:function(t){throw t},f:l}}throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\")}var g,a=!0,u=!1;return{s:function(){_=_.call(e)},n:function(){var e=_.next();return a=e.done,e},e:function(t){u=!0,g=t},f:function(){try{a||null==_.return||_.return()}finally{if(u)throw g}}}}var S=function(e){var t=Math.abs,n=Math.max,o=Math.floor;function a(e,t){var i;if(_(this,a),i=u.call(this,e),i.sign=t,Object.setPrototypeOf(b(i),a.prototype),e>a.__kMaxLength)throw new RangeError(\"Maximum BigInt size exceeded\");return i}g(a,e);var u=c(a);return l(a,[{key:\"toDebugString\",value:function(){var e,t=[\"BigInt[\"],i=B(this);try{for(i.s();!(e=i.n()).done;){var _=e.value;t.push((_?(_>>>0).toString(16):_)+\", \")}}catch(e){i.e(e)}finally{i.f()}return t.push(\"]\"),t.join(\"\")}},{key:\"toString\",value:function(){var e=0<arguments.length&&void 0!==arguments[0]?arguments[0]:10;if(2>e||36<e)throw new RangeError(\"toString() radix argument must be between 2 and 36\");return 0===this.length?\"0\":0==(e&e-1)?a.__toStringBasePowerOfTwo(this,e):a.__toStringGeneric(this,e,!1)}},{key:\"valueOf\",value:function(){throw new Error(\"Convert JSBI instances to native numbers using `toNumber`.\")}},{key:\"__copy\",value:function(){for(var e=new a(this.length,this.sign),t=0;t<this.length;t++)e[t]=this[t];return e}},{key:\"__trim\",value:function(){for(var e=this.length,t=this[e-1];0===t;)e--,t=this[e-1],this.pop();return 0===e&&(this.sign=!1),this}},{key:\"__initializeDigits\",value:function(){for(var e=0;e<this.length;e++)this[e]=0}},{key:\"__clzmsd\",value:function(){return a.__clz30(this.__digit(this.length-1))}},{key:\"__inplaceMultiplyAdd\",value:function(e,t,_){_>this.length&&(_=this.length);for(var n=32767&e,l=e>>>15,g=0,o=t,u=0;u<_;u++){var s=this.__digit(u),r=32767&s,d=s>>>15,h=a.__imul(r,n),b=a.__imul(r,l),m=a.__imul(d,n),c=a.__imul(d,l),v=o+h+g;g=v>>>30,v&=1073741823,v+=((32767&b)<<15)+((32767&m)<<15),g+=v>>>30,o=c+(b>>>15)+(m>>>15),this.__setDigit(u,1073741823&v)}if(0!==g||0!==o)throw new Error(\"implementation bug\")}},{key:\"__inplaceAdd\",value:function(e,t,_){for(var n,l=0,g=0;g<_;g++)n=this.__halfDigit(t+g)+e.__halfDigit(g)+l,l=n>>>15,this.__setHalfDigit(t+g,32767&n);return l}},{key:\"__inplaceSub\",value:function(e,t,_){var n=0;if(1&t){t>>=1;for(var l=this.__digit(t),g=32767&l,o=0;o<_-1>>>1;o++){var a=e.__digit(o),u=(l>>>15)-(32767&a)-n;n=1&u>>>15,this.__setDigit(t+o,(32767&u)<<15|32767&g),l=this.__digit(t+o+1),g=(32767&l)-(a>>>15)-n,n=1&g>>>15}var s=e.__digit(o),r=(l>>>15)-(32767&s)-n;n=1&r>>>15,this.__setDigit(t+o,(32767&r)<<15|32767&g);if(t+o+1>=this.length)throw new RangeError(\"out of bounds\");0==(1&_)&&(l=this.__digit(t+o+1),g=(32767&l)-(s>>>15)-n,n=1&g>>>15,this.__setDigit(t+e.length,1073709056&l|32767&g))}else{t>>=1;for(var d=0;d<e.length-1;d++){var h=this.__digit(t+d),b=e.__digit(d),m=(32767&h)-(32767&b)-n;n=1&m>>>15;var c=(h>>>15)-(b>>>15)-n;n=1&c>>>15,this.__setDigit(t+d,(32767&c)<<15|32767&m)}var v=this.__digit(t+d),y=e.__digit(d),f=(32767&v)-(32767&y)-n;n=1&f>>>15;var D=0;0==(1&_)&&(D=(v>>>15)-(y>>>15)-n,n=1&D>>>15),this.__setDigit(t+d,(32767&D)<<15|32767&f)}return n}},{key:\"__inplaceRightShift\",value:function(e){if(0!==e){for(var t,_=this.__digit(0)>>>e,n=this.length-1,l=0;l<n;l++)t=this.__digit(l+1),this.__setDigit(l,1073741823&t<<30-e|_),_=t>>>e;this.__setDigit(n,_)}}},{key:\"__digit\",value:function(e){return this[e]}},{key:\"__unsignedDigit\",value:function(e){return this[e]>>>0}},{key:\"__setDigit\",value:function(e,t){this[e]=0|t}},{key:\"__setDigitGrow\",value:function(e,t){this[e]=0|t}},{key:\"__halfDigitLength\",value:function(){var e=this.length;return 32767>=this.__unsignedDigit(e-1)?2*e-1:2*e}},{key:\"__halfDigit\",value:function(e){return 32767&this[e>>>1]>>>15*(1&e)}},{key:\"__setHalfDigit\",value:function(e,t){var i=e>>>1,_=this.__digit(i),n=1&e?32767&_|t<<15:1073709056&_|32767&t;this.__setDigit(i,n)}}],[{key:\"BigInt\",value:function(e){var t=Number.isFinite;if(\"number\"==typeof e){if(0===e)return a.__zero();if(a.__isOneDigitInt(e))return 0>e?a.__oneDigit(-e,!0):a.__oneDigit(e,!1);if(!t(e)||o(e)!==e)throw new RangeError(\"The number \"+e+\" cannot be converted to BigInt because it is not an integer\");return a.__fromDouble(e)}if(\"string\"==typeof e){var _=a.__fromString(e);if(null===_)throw new SyntaxError(\"Cannot convert \"+e+\" to a BigInt\");return _}if(\"boolean\"==typeof e)return!0===e?a.__oneDigit(1,!1):a.__zero();if(\"object\"===i(e)){if(e.constructor===a)return e;var n=a.__toPrimitive(e);return a.BigInt(n)}throw new TypeError(\"Cannot convert \"+e+\" to a BigInt\")}},{key:\"toNumber\",value:function(e){var t=e.length;if(0===t)return 0;if(1===t){var i=e.__unsignedDigit(0);return e.sign?-i:i}var _=e.__digit(t-1),n=a.__clz30(_),l=30*t-n;if(1024<l)return e.sign?-Infinity:1/0;var g=l-1,o=_,u=t-1,s=n+3,r=32===s?0:o<<s;r>>>=12;var d=s-12,h=12<=s?0:o<<20+s,b=20+s;for(0<d&&0<u&&(u--,o=e.__digit(u),r|=o>>>30-d,h=o<<d+2,b=d+2);0<b&&0<u;)u--,o=e.__digit(u),h|=30<=b?o<<b-30:o>>>30-b,b-=30;var m=a.__decideRounding(e,b,u,o);if((1===m||0===m&&1==(1&h))&&(h=h+1>>>0,0===h&&(r++,0!=r>>>20&&(r=0,g++,1023<g))))return e.sign?-Infinity:1/0;var c=e.sign?-2147483648:0;return g=g+1023<<20,a.__kBitConversionInts[1]=c|g|r,a.__kBitConversionInts[0]=h,a.__kBitConversionDouble[0]}},{key:\"unaryMinus\",value:function(e){if(0===e.length)return e;var t=e.__copy();return t.sign=!e.sign,t}},{key:\"bitwiseNot\",value:function(e){return e.sign?a.__absoluteSubOne(e).__trim():a.__absoluteAddOne(e,!0)}},{key:\"exponentiate\",value:function(e,t){if(t.sign)throw new RangeError(\"Exponent must be positive\");if(0===t.length)return a.__oneDigit(1,!1);if(0===e.length)return e;if(1===e.length&&1===e.__digit(0))return e.sign&&0==(1&t.__digit(0))?a.unaryMinus(e):e;if(1<t.length)throw new RangeError(\"BigInt too big\");var i=t.__unsignedDigit(0);if(1===i)return e;if(i>=a.__kMaxLengthBits)throw new RangeError(\"BigInt too big\");if(1===e.length&&2===e.__digit(0)){var _=1+(0|i/30),n=e.sign&&0!=(1&i),l=new a(_,n);l.__initializeDigits();var g=1<<i%30;return l.__setDigit(_-1,g),l}var o=null,u=e;for(0!=(1&i)&&(o=e),i>>=1;0!==i;i>>=1)u=a.multiply(u,u),0!=(1&i)&&(null===o?o=u:o=a.multiply(o,u));return o}},{key:\"multiply\",value:function(e,t){if(0===e.length)return e;if(0===t.length)return t;var _=e.length+t.length;30<=e.__clzmsd()+t.__clzmsd()&&_--;var n=new a(_,e.sign!==t.sign);n.__initializeDigits();for(var l=0;l<e.length;l++)a.__multiplyAccumulate(t,e.__digit(l),n,l);return n.__trim()}},{key:\"divide\",value:function(e,t){if(0===t.length)throw new RangeError(\"Division by zero\");if(0>a.__absoluteCompare(e,t))return a.__zero();var i,_=e.sign!==t.sign,n=t.__unsignedDigit(0);if(1===t.length&&32767>=n){if(1===n)return _===e.sign?e:a.unaryMinus(e);i=a.__absoluteDivSmall(e,n,null)}else i=a.__absoluteDivLarge(e,t,!0,!1);return i.sign=_,i.__trim()}},{key:\"remainder\",value:function i(e,t){if(0===t.length)throw new RangeError(\"Division by zero\");if(0>a.__absoluteCompare(e,t))return e;var _=t.__unsignedDigit(0);if(1===t.length&&32767>=_){if(1===_)return a.__zero();var n=a.__absoluteModSmall(e,_);return 0===n?a.__zero():a.__oneDigit(n,e.sign)}var i=a.__absoluteDivLarge(e,t,!1,!0);return i.sign=e.sign,i.__trim()}},{key:\"add\",value:function(e,t){var i=e.sign;return i===t.sign?a.__absoluteAdd(e,t,i):0<=a.__absoluteCompare(e,t)?a.__absoluteSub(e,t,i):a.__absoluteSub(t,e,!i)}},{key:\"subtract\",value:function(e,t){var i=e.sign;return i===t.sign?0<=a.__absoluteCompare(e,t)?a.__absoluteSub(e,t,i):a.__absoluteSub(t,e,!i):a.__absoluteAdd(e,t,i)}},{key:\"leftShift\",value:function(e,t){return 0===t.length||0===e.length?e:t.sign?a.__rightShiftByAbsolute(e,t):a.__leftShiftByAbsolute(e,t)}},{key:\"signedRightShift\",value:function(e,t){return 0===t.length||0===e.length?e:t.sign?a.__leftShiftByAbsolute(e,t):a.__rightShiftByAbsolute(e,t)}},{key:\"unsignedRightShift\",value:function(){throw new TypeError(\"BigInts have no unsigned right shift; use >> instead\")}},{key:\"lessThan\",value:function(e,t){return 0>a.__compareToBigInt(e,t)}},{key:\"lessThanOrEqual\",value:function(e,t){return 0>=a.__compareToBigInt(e,t)}},{key:\"greaterThan\",value:function(e,t){return 0<a.__compareToBigInt(e,t)}},{key:\"greaterThanOrEqual\",value:function(e,t){return 0<=a.__compareToBigInt(e,t)}},{key:\"equal\",value:function(e,t){if(e.sign!==t.sign)return!1;if(e.length!==t.length)return!1;for(var _=0;_<e.length;_++)if(e.__digit(_)!==t.__digit(_))return!1;return!0}},{key:\"notEqual\",value:function(e,t){return!a.equal(e,t)}},{key:\"bitwiseAnd\",value:function(e,t){if(!e.sign&&!t.sign)return a.__absoluteAnd(e,t).__trim();if(e.sign&&t.sign){var i=n(e.length,t.length)+1,_=a.__absoluteSubOne(e,i),l=a.__absoluteSubOne(t);return _=a.__absoluteOr(_,l,_),a.__absoluteAddOne(_,!0,_).__trim()}if(e.sign){var g=[t,e];e=g[0],t=g[1]}return a.__absoluteAndNot(e,a.__absoluteSubOne(t)).__trim()}},{key:\"bitwiseXor\",value:function(e,t){if(!e.sign&&!t.sign)return a.__absoluteXor(e,t).__trim();if(e.sign&&t.sign){var i=n(e.length,t.length),_=a.__absoluteSubOne(e,i),l=a.__absoluteSubOne(t);return a.__absoluteXor(_,l,_).__trim()}var g=n(e.length,t.length)+1;if(e.sign){var o=[t,e];e=o[0],t=o[1]}var u=a.__absoluteSubOne(t,g);return u=a.__absoluteXor(u,e,u),a.__absoluteAddOne(u,!0,u).__trim()}},{key:\"bitwiseOr\",value:function(e,t){var i=n(e.length,t.length);if(!e.sign&&!t.sign)return a.__absoluteOr(e,t).__trim();if(e.sign&&t.sign){var _=a.__absoluteSubOne(e,i),l=a.__absoluteSubOne(t);return _=a.__absoluteAnd(_,l,_),a.__absoluteAddOne(_,!0,_).__trim()}if(e.sign){var g=[t,e];e=g[0],t=g[1]}var o=a.__absoluteSubOne(t,i);return o=a.__absoluteAndNot(o,e,o),a.__absoluteAddOne(o,!0,o).__trim()}},{key:\"asIntN\",value:function(e,t){if(0===t.length)return t;if(e=o(e),0>e)throw new RangeError(\"Invalid value: not (convertible to) a safe integer\");if(0===e)return a.__zero();if(e>=a.__kMaxLengthBits)return t;var _=0|(e+29)/30;if(t.length<_)return t;var l=t.__unsignedDigit(_-1),g=1<<(e-1)%30;if(t.length===_&&l<g)return t;if(!((l&g)===g))return a.__truncateToNBits(e,t);if(!t.sign)return a.__truncateAndSubFromPowerOfTwo(e,t,!0);if(0==(l&g-1)){for(var u=_-2;0<=u;u--)if(0!==t.__digit(u))return a.__truncateAndSubFromPowerOfTwo(e,t,!1);return t.length===_&&l===g?t:a.__truncateToNBits(e,t)}return a.__truncateAndSubFromPowerOfTwo(e,t,!1)}},{key:\"asUintN\",value:function(e,t){if(0===t.length)return t;if(e=o(e),0>e)throw new RangeError(\"Invalid value: not (convertible to) a safe integer\");if(0===e)return a.__zero();if(t.sign){if(e>a.__kMaxLengthBits)throw new RangeError(\"BigInt too big\");return a.__truncateAndSubFromPowerOfTwo(e,t,!1)}if(e>=a.__kMaxLengthBits)return t;var i=0|(e+29)/30;if(t.length<i)return t;var _=e%30;if(t.length==i){if(0===_)return t;var l=t.__digit(i-1);if(0==l>>>_)return t}return a.__truncateToNBits(e,t)}},{key:\"ADD\",value:function(e,t){if(e=a.__toPrimitive(e),t=a.__toPrimitive(t),\"string\"==typeof e)return\"string\"!=typeof t&&(t=t.toString()),e+t;if(\"string\"==typeof t)return e.toString()+t;if(e=a.__toNumeric(e),t=a.__toNumeric(t),a.__isBigInt(e)&&a.__isBigInt(t))return a.add(e,t);if(\"number\"==typeof e&&\"number\"==typeof t)return e+t;throw new TypeError(\"Cannot mix BigInt and other types, use explicit conversions\")}},{key:\"LT\",value:function(e,t){return a.__compare(e,t,0)}},{key:\"LE\",value:function(e,t){return a.__compare(e,t,1)}},{key:\"GT\",value:function(e,t){return a.__compare(e,t,2)}},{key:\"GE\",value:function(e,t){return a.__compare(e,t,3)}},{key:\"EQ\",value:function(e,t){for(;;){if(a.__isBigInt(e))return a.__isBigInt(t)?a.equal(e,t):a.EQ(t,e);if(\"number\"==typeof e){if(a.__isBigInt(t))return a.__equalToNumber(t,e);if(\"object\"!==i(t))return e==t;t=a.__toPrimitive(t)}else if(\"string\"==typeof e){if(a.__isBigInt(t))return e=a.__fromString(e),null!==e&&a.equal(e,t);if(\"object\"!==i(t))return e==t;t=a.__toPrimitive(t)}else if(\"boolean\"==typeof e){if(a.__isBigInt(t))return a.__equalToNumber(t,+e);if(\"object\"!==i(t))return e==t;t=a.__toPrimitive(t)}else if(\"symbol\"===i(e)){if(a.__isBigInt(t))return!1;if(\"object\"!==i(t))return e==t;t=a.__toPrimitive(t)}else if(\"object\"===i(e)){if(\"object\"===i(t)&&t.constructor!==a)return e==t;e=a.__toPrimitive(e)}else return e==t}}},{key:\"NE\",value:function(e,t){return!a.EQ(e,t)}},{key:\"DataViewGetBigInt64\",value:function(e,t){var i=!!(2<arguments.length&&void 0!==arguments[2])&&arguments[2];return a.asIntN(64,a.DataViewGetBigUint64(e,t,i))}},{key:\"DataViewGetBigUint64\",value:function(e,t){var i=!!(2<arguments.length&&void 0!==arguments[2])&&arguments[2],_=i?[4,0]:[0,4],n=v(_,2),g=n[0],o=n[1],l=e.getUint32(t+g,i),u=e.getUint32(t+o,i),s=new a(3,!1);return s.__setDigit(0,1073741823&u),s.__setDigit(1,(268435455&l)<<2|u>>>30),s.__setDigit(2,l>>>28),s.__trim()}},{key:\"DataViewSetBigInt64\",value:function(e,t,i){var _=!!(3<arguments.length&&void 0!==arguments[3])&&arguments[3];a.DataViewSetBigUint64(e,t,i,_)}},{key:\"DataViewSetBigUint64\",value:function(e,t,i){var _=!!(3<arguments.length&&void 0!==arguments[3])&&arguments[3];i=a.asUintN(64,i);var n=0,g=0;if(0<i.length&&(g=i.__digit(0),1<i.length)){var o=i.__digit(1);g|=o<<30,n=o>>>2,2<i.length&&(n|=i.__digit(2)<<28)}var u=_?[4,0]:[0,4],s=v(u,2),r=s[0],d=s[1];e.setUint32(t+r,n,_),e.setUint32(t+d,g,_)}},{key:\"__zero\",value:function(){return new a(0,!1)}},{key:\"__oneDigit\",value:function(e,t){var i=new a(1,t);return i.__setDigit(0,e),i}},{key:\"__decideRounding\",value:function(e,t,i,_){if(0<t)return-1;var n;if(0>t)n=-t-1;else{if(0===i)return-1;i--,_=e.__digit(i),n=29}var l=1<<n;if(0==(_&l))return-1;if(l-=1,0!=(_&l))return 1;for(;0<i;)if(i--,0!==e.__digit(i))return 1;return 0}},{key:\"__fromDouble\",value:function(e){a.__kBitConversionDouble[0]=e;var t,i=2047&a.__kBitConversionInts[1]>>>20,_=i-1023,n=(0|_/30)+1,l=new a(n,0>e),g=1048575&a.__kBitConversionInts[1]|1048576,o=a.__kBitConversionInts[0],u=20,s=_%30,r=0;if(s<u){var d=u-s;r=d+32,t=g>>>d,g=g<<32-d|o>>>d,o<<=32-d}else if(s===u)r=32,t=g,g=o,o=0;else{var h=s-u;r=32-h,t=g<<h|o>>>32-h,g=o<<h,o=0}l.__setDigit(n-1,t);for(var b=n-2;0<=b;b--)0<r?(r-=30,t=g>>>2,g=g<<30|o>>>2,o<<=30):t=0,l.__setDigit(b,t);return l.__trim()}},{key:\"__isWhitespace\",value:function(e){return!!(13>=e&&9<=e)||(159>=e?32==e:131071>=e?160==e||5760==e:196607>=e?(e&=131071,10>=e||40==e||41==e||47==e||95==e||4096==e):65279==e)}},{key:\"__fromString\",value:function(e){var t=1<arguments.length&&void 0!==arguments[1]?arguments[1]:0,i=0,_=e.length,n=0;if(n===_)return a.__zero();for(var l=e.charCodeAt(n);a.__isWhitespace(l);){if(++n===_)return a.__zero();l=e.charCodeAt(n)}if(43===l){if(++n===_)return null;l=e.charCodeAt(n),i=1}else if(45===l){if(++n===_)return null;l=e.charCodeAt(n),i=-1}if(0===t){if(t=10,48===l){if(++n===_)return a.__zero();if(l=e.charCodeAt(n),88===l||120===l){if(t=16,++n===_)return null;l=e.charCodeAt(n)}else if(79===l||111===l){if(t=8,++n===_)return null;l=e.charCodeAt(n)}else if(66===l||98===l){if(t=2,++n===_)return null;l=e.charCodeAt(n)}}}else if(16===t&&48===l){if(++n===_)return a.__zero();if(l=e.charCodeAt(n),88===l||120===l){if(++n===_)return null;l=e.charCodeAt(n)}}if(0!==i&&10!==t)return null;for(;48===l;){if(++n===_)return a.__zero();l=e.charCodeAt(n)}var g=_-n,o=a.__kMaxBitsPerChar[t],u=a.__kBitsPerCharTableMultiplier-1;if(g>1073741824/o)return null;var s=o*g+u>>>a.__kBitsPerCharTableShift,r=new a(0|(s+29)/30,!1),h=10>t?t:10,b=10<t?t-10:0;if(0==(t&t-1)){o>>=a.__kBitsPerCharTableShift;var c=[],v=[],y=!1;do{for(var f,D=0,p=0;;){if(f=void 0,l-48>>>0<h)f=l-48;else if((32|l)-97>>>0<b)f=(32|l)-87;else{y=!0;break}if(p+=o,D=D<<o|f,++n===_){y=!0;break}if(l=e.charCodeAt(n),30<p+o)break}c.push(D),v.push(p)}while(!y);a.__fillFromParts(r,c,v)}else{r.__initializeDigits();var k=!1,B=0;do{for(var S,C=0,I=1;;){if(S=void 0,l-48>>>0<h)S=l-48;else if((32|l)-97>>>0<b)S=(32|l)-87;else{k=!0;break}var A=I*t;if(1073741823<A)break;if(I=A,C=C*t+S,B++,++n===_){k=!0;break}l=e.charCodeAt(n)}u=30*a.__kBitsPerCharTableMultiplier-1;var m=0|(o*B+u>>>a.__kBitsPerCharTableShift)/30;r.__inplaceMultiplyAdd(I,C,m)}while(!k)}if(n!==_){if(!a.__isWhitespace(l))return null;for(n++;n<_;n++)if(l=e.charCodeAt(n),!a.__isWhitespace(l))return null}return r.sign=-1===i,r.__trim()}},{key:\"__fillFromParts\",value:function(e,t,_){for(var n=0,l=0,g=0,o=t.length-1;0<=o;o--){var a=t[o],u=_[o];l|=a<<g,g+=u,30===g?(e.__setDigit(n++,l),g=0,l=0):30<g&&(e.__setDigit(n++,1073741823&l),g-=30,l=a>>>u-g)}if(0!==l){if(n>=e.length)throw new Error(\"implementation bug\");e.__setDigit(n++,l)}for(;n<e.length;n++)e.__setDigit(n,0)}},{key:\"__toStringBasePowerOfTwo\",value:function(e,t){var _=e.length,n=t-1;n=(85&n>>>1)+(85&n),n=(51&n>>>2)+(51&n),n=(15&n>>>4)+(15&n);var l=n,g=t-1,o=e.__digit(_-1),u=a.__clz30(o),s=0|(30*_-u+l-1)/l;if(e.sign&&s++,268435456<s)throw new Error(\"string too long\");for(var r=Array(s),d=s-1,h=0,b=0,m=0;m<_-1;m++){var c=e.__digit(m),v=(h|c<<b)&g;r[d--]=a.__kConversionChars[v];var y=l-b;for(h=c>>>y,b=30-y;b>=l;)r[d--]=a.__kConversionChars[h&g],h>>>=l,b-=l}var f=(h|o<<b)&g;for(r[d--]=a.__kConversionChars[f],h=o>>>l-b;0!==h;)r[d--]=a.__kConversionChars[h&g],h>>>=l;if(e.sign&&(r[d--]=\"-\"),-1!==d)throw new Error(\"implementation bug\");return r.join(\"\")}},{key:\"__toStringGeneric\",value:function(e,t,_){var n=e.length;if(0===n)return\"\";if(1===n){var l=e.__unsignedDigit(0).toString(t);return!1===_&&e.sign&&(l=\"-\"+l),l}var g=30*n-a.__clz30(e.__digit(n-1)),o=a.__kMaxBitsPerChar[t],u=o-1,s=g*a.__kBitsPerCharTableMultiplier;s+=u-1,s=0|s/u;var r,d,h=s+1>>1,b=a.exponentiate(a.__oneDigit(t,!1),a.__oneDigit(h,!1)),m=b.__unsignedDigit(0);if(1===b.length&&32767>=m){r=new a(e.length,!1),r.__initializeDigits();for(var c,v=0,y=2*e.length-1;0<=y;y--)c=v<<15|e.__halfDigit(y),r.__setHalfDigit(y,0|c/m),v=0|c%m;d=v.toString(t)}else{var f=a.__absoluteDivLarge(e,b,!0,!0);r=f.quotient;var D=f.remainder.__trim();d=a.__toStringGeneric(D,t,!0)}r.__trim();for(var p=a.__toStringGeneric(r,t,!0);d.length<h;)d=\"0\"+d;return!1===_&&e.sign&&(p=\"-\"+p),p+d}},{key:\"__unequalSign\",value:function(e){return e?-1:1}},{key:\"__absoluteGreater\",value:function(e){return e?-1:1}},{key:\"__absoluteLess\",value:function(e){return e?1:-1}},{key:\"__compareToBigInt\",value:function(e,t){var i=e.sign;if(i!==t.sign)return a.__unequalSign(i);var _=a.__absoluteCompare(e,t);return 0<_?a.__absoluteGreater(i):0>_?a.__absoluteLess(i):0}},{key:\"__compareToNumber\",value:function(e,i){if(a.__isOneDigitInt(i)){var _=e.sign,n=0>i;if(_!==n)return a.__unequalSign(_);if(0===e.length){if(n)throw new Error(\"implementation bug\");return 0===i?0:-1}if(1<e.length)return a.__absoluteGreater(_);var l=t(i),g=e.__unsignedDigit(0);return g>l?a.__absoluteGreater(_):g<l?a.__absoluteLess(_):0}return a.__compareToDouble(e,i)}},{key:\"__compareToDouble\",value:function(e,t){if(t!==t)return t;if(t===1/0)return-1;if(t===-Infinity)return 1;var i=e.sign;if(i!==0>t)return a.__unequalSign(i);if(0===t)throw new Error(\"implementation bug: should be handled elsewhere\");if(0===e.length)return-1;a.__kBitConversionDouble[0]=t;var _=2047&a.__kBitConversionInts[1]>>>20;if(2047==_)throw new Error(\"implementation bug: handled elsewhere\");var n=_-1023;if(0>n)return a.__absoluteGreater(i);var l=e.length,g=e.__digit(l-1),o=a.__clz30(g),u=30*l-o,s=n+1;if(u<s)return a.__absoluteLess(i);if(u>s)return a.__absoluteGreater(i);var r=1048576|1048575&a.__kBitConversionInts[1],d=a.__kBitConversionInts[0],h=20,b=29-o;if(b!==(0|(u-1)%30))throw new Error(\"implementation bug\");var m,c=0;if(b<h){var v=h-b;c=v+32,m=r>>>v,r=r<<32-v|d>>>v,d<<=32-v}else if(b===h)c=32,m=r,r=d,d=0;else{var y=b-h;c=32-y,m=r<<y|d>>>32-y,r=d<<y,d=0}if(g>>>=0,m>>>=0,g>m)return a.__absoluteGreater(i);if(g<m)return a.__absoluteLess(i);for(var f=l-2;0<=f;f--){0<c?(c-=30,m=r>>>2,r=r<<30|d>>>2,d<<=30):m=0;var D=e.__unsignedDigit(f);if(D>m)return a.__absoluteGreater(i);if(D<m)return a.__absoluteLess(i)}if(0!==r||0!==d){if(0===c)throw new Error(\"implementation bug\");return a.__absoluteLess(i)}return 0}},{key:\"__equalToNumber\",value:function(e,i){return a.__isOneDigitInt(i)?0===i?0===e.length:1===e.length&&e.sign===0>i&&e.__unsignedDigit(0)===t(i):0===a.__compareToDouble(e,i)}},{key:\"__comparisonResultToBool\",value:function(e,t){return 0===t?0>e:1===t?0>=e:2===t?0<e:3===t?0<=e:void 0}},{key:\"__compare\",value:function(e,t,i){if(e=a.__toPrimitive(e),t=a.__toPrimitive(t),\"string\"==typeof e&&\"string\"==typeof t)switch(i){case 0:return e<t;case 1:return e<=t;case 2:return e>t;case 3:return e>=t;}if(a.__isBigInt(e)&&\"string\"==typeof t)return t=a.__fromString(t),null!==t&&a.__comparisonResultToBool(a.__compareToBigInt(e,t),i);if(\"string\"==typeof e&&a.__isBigInt(t))return e=a.__fromString(e),null!==e&&a.__comparisonResultToBool(a.__compareToBigInt(e,t),i);if(e=a.__toNumeric(e),t=a.__toNumeric(t),a.__isBigInt(e)){if(a.__isBigInt(t))return a.__comparisonResultToBool(a.__compareToBigInt(e,t),i);if(\"number\"!=typeof t)throw new Error(\"implementation bug\");return a.__comparisonResultToBool(a.__compareToNumber(e,t),i)}if(\"number\"!=typeof e)throw new Error(\"implementation bug\");if(a.__isBigInt(t))return a.__comparisonResultToBool(a.__compareToNumber(t,e),2^i);if(\"number\"!=typeof t)throw new Error(\"implementation bug\");return 0===i?e<t:1===i?e<=t:2===i?e>t:3===i?e>=t:void 0}},{key:\"__absoluteAdd\",value:function(e,t,_){if(e.length<t.length)return a.__absoluteAdd(t,e,_);if(0===e.length)return e;if(0===t.length)return e.sign===_?e:a.unaryMinus(e);var n=e.length;(0===e.__clzmsd()||t.length===e.length&&0===t.__clzmsd())&&n++;for(var l,g=new a(n,_),o=0,u=0;u<t.length;u++)l=e.__digit(u)+t.__digit(u)+o,o=l>>>30,g.__setDigit(u,1073741823&l);for(;u<e.length;u++){var s=e.__digit(u)+o;o=s>>>30,g.__setDigit(u,1073741823&s)}return u<g.length&&g.__setDigit(u,o),g.__trim()}},{key:\"__absoluteSub\",value:function(e,t,_){if(0===e.length)return e;if(0===t.length)return e.sign===_?e:a.unaryMinus(e);for(var n,l=new a(e.length,_),g=0,o=0;o<t.length;o++)n=e.__digit(o)-t.__digit(o)-g,g=1&n>>>30,l.__setDigit(o,1073741823&n);for(;o<e.length;o++){var u=e.__digit(o)-g;g=1&u>>>30,l.__setDigit(o,1073741823&u)}return l.__trim()}},{key:\"__absoluteAddOne\",value:function(e,t){var _=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null,n=e.length;null===_?_=new a(n,t):_.sign=t;for(var l,g=1,o=0;o<n;o++)l=e.__digit(o)+g,g=l>>>30,_.__setDigit(o,1073741823&l);return 0!==g&&_.__setDigitGrow(n,1),_}},{key:\"__absoluteSubOne\",value:function(e,t){var _=e.length;t=t||_;for(var n,l=new a(t,!1),g=1,o=0;o<_;o++)n=e.__digit(o)-g,g=1&n>>>30,l.__setDigit(o,1073741823&n);if(0!==g)throw new Error(\"implementation bug\");for(var u=_;u<t;u++)l.__setDigit(u,0);return l}},{key:\"__absoluteAnd\",value:function(e,t){var _=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null,n=e.length,l=t.length,g=l;if(n<l){g=n;var o=e,u=n;e=t,n=l,t=o,l=u}var s=g;null===_?_=new a(s,!1):s=_.length;for(var r=0;r<g;r++)_.__setDigit(r,e.__digit(r)&t.__digit(r));for(;r<s;r++)_.__setDigit(r,0);return _}},{key:\"__absoluteAndNot\",value:function(e,t){var _=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null,n=e.length,l=t.length,g=l;n<l&&(g=n);var o=n;null===_?_=new a(o,!1):o=_.length;for(var u=0;u<g;u++)_.__setDigit(u,e.__digit(u)&~t.__digit(u));for(;u<n;u++)_.__setDigit(u,e.__digit(u));for(;u<o;u++)_.__setDigit(u,0);return _}},{key:\"__absoluteOr\",value:function(e,t){var _=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null,n=e.length,l=t.length,g=l;if(n<l){g=n;var o=e,u=n;e=t,n=l,t=o,l=u}var s=n;null===_?_=new a(s,!1):s=_.length;for(var r=0;r<g;r++)_.__setDigit(r,e.__digit(r)|t.__digit(r));for(;r<n;r++)_.__setDigit(r,e.__digit(r));for(;r<s;r++)_.__setDigit(r,0);return _}},{key:\"__absoluteXor\",value:function(e,t){var _=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null,n=e.length,l=t.length,g=l;if(n<l){g=n;var o=e,u=n;e=t,n=l,t=o,l=u}var s=n;null===_?_=new a(s,!1):s=_.length;for(var r=0;r<g;r++)_.__setDigit(r,e.__digit(r)^t.__digit(r));for(;r<n;r++)_.__setDigit(r,e.__digit(r));for(;r<s;r++)_.__setDigit(r,0);return _}},{key:\"__absoluteCompare\",value:function(e,t){var _=e.length-t.length;if(0!=_)return _;for(var n=e.length-1;0<=n&&e.__digit(n)===t.__digit(n);)n--;return 0>n?0:e.__unsignedDigit(n)>t.__unsignedDigit(n)?1:-1}},{key:\"__multiplyAccumulate\",value:function(e,t,_,n){if(0!==t){for(var l=32767&t,g=t>>>15,o=0,u=0,s=0;s<e.length;s++,n++){var r=_.__digit(n),d=e.__digit(s),h=32767&d,b=d>>>15,m=a.__imul(h,l),c=a.__imul(h,g),v=a.__imul(b,l),y=a.__imul(b,g);r+=u+m+o,o=r>>>30,r&=1073741823,r+=((32767&c)<<15)+((32767&v)<<15),o+=r>>>30,u=y+(c>>>15)+(v>>>15),_.__setDigit(n,1073741823&r)}for(;0!==o||0!==u;n++){var f=_.__digit(n);f+=o+u,u=0,o=f>>>30,_.__setDigit(n,1073741823&f)}}}},{key:\"__internalMultiplyAdd\",value:function(e,t,_,l,g){for(var o=_,u=0,s=0;s<l;s++){var d=e.__digit(s),h=a.__imul(32767&d,t),b=a.__imul(d>>>15,t),m=h+((32767&b)<<15)+u+o;o=m>>>30,u=b>>>15,g.__setDigit(s,1073741823&m)}if(g.length>l)for(g.__setDigit(l++,o+u);l<g.length;)g.__setDigit(l++,0);else if(0!==o+u)throw new Error(\"implementation bug\")}},{key:\"__absoluteDivSmall\",value:function(e,t){var _=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;null===_&&(_=new a(e.length,!1));for(var n=0,l=2*e.length-1;0<=l;l-=2){var g=(n<<15|e.__halfDigit(l))>>>0,o=0|g/t;n=0|g%t,g=(n<<15|e.__halfDigit(l-1))>>>0;var u=0|g/t;n=0|g%t,_.__setDigit(l>>>1,o<<15|u)}return _}},{key:\"__absoluteModSmall\",value:function(e,t){for(var _,n=0,l=2*e.length-1;0<=l;l--)_=(n<<15|e.__halfDigit(l))>>>0,n=0|_%t;return n}},{key:\"__absoluteDivLarge\",value:function(e,t,i,_){var l=t.__halfDigitLength(),n=t.length,g=e.__halfDigitLength()-l,o=null;i&&(o=new a(g+2>>>1,!1),o.__initializeDigits());var s=new a(l+2>>>1,!1);s.__initializeDigits();var r=a.__clz15(t.__halfDigit(l-1));0<r&&(t=a.__specialLeftShift(t,r,0));for(var d=a.__specialLeftShift(e,r,1),u=t.__halfDigit(l-1),h=0,b=g;0<=b;b--){var m=32767,v=d.__halfDigit(b+l);if(v!==u){var y=(v<<15|d.__halfDigit(b+l-1))>>>0;m=0|y/u;for(var f=0|y%u,D=t.__halfDigit(l-2),p=d.__halfDigit(b+l-2);a.__imul(m,D)>>>0>(f<<16|p)>>>0&&(m--,f+=u,!(32767<f)););}a.__internalMultiplyAdd(t,m,0,n,s);var k=d.__inplaceSub(s,b,l+1);0!==k&&(k=d.__inplaceAdd(t,b,l),d.__setHalfDigit(b+l,32767&d.__halfDigit(b+l)+k),m--),i&&(1&b?h=m<<15:o.__setDigit(b>>>1,h|m))}if(_)return d.__inplaceRightShift(r),i?{quotient:o,remainder:d}:d;if(i)return o;throw new Error(\"unreachable\")}},{key:\"__clz15\",value:function(e){return a.__clz30(e)-15}},{key:\"__specialLeftShift\",value:function(e,t,_){var l=e.length,n=new a(l+_,!1);if(0===t){for(var g=0;g<l;g++)n.__setDigit(g,e.__digit(g));return 0<_&&n.__setDigit(l,0),n}for(var o,u=0,s=0;s<l;s++)o=e.__digit(s),n.__setDigit(s,1073741823&o<<t|u),u=o>>>30-t;return 0<_&&n.__setDigit(l,u),n}},{key:\"__leftShiftByAbsolute\",value:function(e,t){var _=a.__toShiftAmount(t);if(0>_)throw new RangeError(\"BigInt too big\");var n=0|_/30,l=_%30,g=e.length,o=0!==l&&0!=e.__digit(g-1)>>>30-l,u=g+n+(o?1:0),s=new a(u,e.sign);if(0===l){for(var r=0;r<n;r++)s.__setDigit(r,0);for(;r<u;r++)s.__setDigit(r,e.__digit(r-n))}else{for(var h=0,b=0;b<n;b++)s.__setDigit(b,0);for(var m,c=0;c<g;c++)m=e.__digit(c),s.__setDigit(c+n,1073741823&m<<l|h),h=m>>>30-l;if(o)s.__setDigit(g+n,h);else if(0!==h)throw new Error(\"implementation bug\")}return s.__trim()}},{key:\"__rightShiftByAbsolute\",value:function(e,t){var _=e.length,n=e.sign,l=a.__toShiftAmount(t);if(0>l)return a.__rightShiftByMaximum(n);var g=0|l/30,o=l%30,u=_-g;if(0>=u)return a.__rightShiftByMaximum(n);var s=!1;if(n){if(0!=(e.__digit(g)&(1<<o)-1))s=!0;else for(var r=0;r<g;r++)if(0!==e.__digit(r)){s=!0;break}}if(s&&0===o){var h=e.__digit(_-1);0==~h&&u++}var b=new a(u,n);if(0===o){b.__setDigit(u-1,0);for(var m=g;m<_;m++)b.__setDigit(m-g,e.__digit(m))}else{for(var c,v=e.__digit(g)>>>o,y=_-g-1,f=0;f<y;f++)c=e.__digit(f+g+1),b.__setDigit(f,1073741823&c<<30-o|v),v=c>>>o;b.__setDigit(y,v)}return s&&(b=a.__absoluteAddOne(b,!0,b)),b.__trim()}},{key:\"__rightShiftByMaximum\",value:function(e){return e?a.__oneDigit(1,!0):a.__zero()}},{key:\"__toShiftAmount\",value:function(e){if(1<e.length)return-1;var t=e.__unsignedDigit(0);return t>a.__kMaxLengthBits?-1:t}},{key:\"__toPrimitive\",value:function(e){var t=1<arguments.length&&void 0!==arguments[1]?arguments[1]:\"default\";if(\"object\"!==i(e))return e;if(e.constructor===a)return e;if(\"undefined\"!=typeof Symbol&&\"symbol\"===i(Symbol.toPrimitive)){var _=e[Symbol.toPrimitive];if(_){var n=_(t);if(\"object\"!==i(n))return n;throw new TypeError(\"Cannot convert object to primitive value\")}}var l=e.valueOf;if(l){var g=l.call(e);if(\"object\"!==i(g))return g}var o=e.toString;if(o){var u=o.call(e);if(\"object\"!==i(u))return u}throw new TypeError(\"Cannot convert object to primitive value\")}},{key:\"__toNumeric\",value:function(e){return a.__isBigInt(e)?e:+e}},{key:\"__isBigInt\",value:function(e){return\"object\"===i(e)&&null!==e&&e.constructor===a}},{key:\"__truncateToNBits\",value:function(e,t){for(var _=0|(e+29)/30,n=new a(_,t.sign),l=_-1,g=0;g<l;g++)n.__setDigit(g,t.__digit(g));var o=t.__digit(l);if(0!=e%30){var u=32-e%30;o=o<<u>>>u}return n.__setDigit(l,o),n.__trim()}},{key:\"__truncateAndSubFromPowerOfTwo\",value:function(e,t,_){for(var n=Math.min,l,g=0|(e+29)/30,o=new a(g,_),u=0,s=g-1,d=0,h=n(s,t.length);u<h;u++)l=0-t.__digit(u)-d,d=1&l>>>30,o.__setDigit(u,1073741823&l);for(;u<s;u++)o.__setDigit(u,0|1073741823&-d);var b,m=s<t.length?t.__digit(s):0,c=e%30;if(0===c)b=0-m-d,b&=1073741823;else{var v=32-c;m=m<<v>>>v;var y=1<<32-v;b=y-m-d,b&=y-1}return o.__setDigit(s,b),o.__trim()}},{key:\"__digitPow\",value:function(e,t){for(var i=1;0<t;)1&t&&(i*=e),t>>>=1,e*=e;return i}},{key:\"__isOneDigitInt\",value:function(e){return(1073741823&e)===e}}]),a}(h(Array));return S.__kMaxLength=33554432,S.__kMaxLengthBits=S.__kMaxLength<<5,S.__kMaxBitsPerChar=[0,0,32,51,64,75,83,90,96,102,107,111,115,119,122,126,128,131,134,136,139,141,143,145,147,149,151,153,154,156,158,159,160,162,163,165,166],S.__kBitsPerCharTableShift=5,S.__kBitsPerCharTableMultiplier=1<<S.__kBitsPerCharTableShift,S.__kConversionChars=[\"0\",\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\",\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"m\",\"n\",\"o\",\"p\",\"q\",\"r\",\"s\",\"t\",\"u\",\"v\",\"w\",\"x\",\"y\",\"z\"],S.__kBitConversionBuffer=new ArrayBuffer(8),S.__kBitConversionDouble=new Float64Array(S.__kBitConversionBuffer),S.__kBitConversionInts=new Int32Array(S.__kBitConversionBuffer),S.__clz30=t?function(e){return t(e)-2}:function(e){var t=Math.LN2,i=Math.log;return 0===e?30:0|29-(0|i(e>>>0)/t)},S.__imul=e||function(e,t){return 0|e*t},S});\n//# sourceMappingURL=jsbi-umd.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvanNiaS9kaXN0L2pzYmktdW1kLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBLGVBQWUsS0FBb0Qsb0JBQW9CLENBQXNFLENBQUMsa0JBQWtCLGFBQWEsNkJBQTZCLGNBQWMsMEJBQTBCLGlGQUFpRixnQkFBZ0IsYUFBYSxvR0FBb0csTUFBTSxnQkFBZ0IsOEVBQThFLGdCQUFnQixjQUFjLFdBQVcseUhBQXlILGtCQUFrQiwwRUFBMEUsWUFBWSxJQUFJLGdCQUFnQiw0R0FBNEcsMENBQTBDLGFBQWEscUNBQXFDLHVDQUF1QyxZQUFZLFlBQVksY0FBYyxpRUFBaUUsNkNBQTZDLE1BQU0sZ0JBQWdCLDhDQUE4Qyx1QkFBdUIsUUFBUSxhQUFhLDREQUE0RCxtQ0FBbUMscUNBQXFDLElBQUksK0VBQStFLE1BQU0sU0FBUyxVQUFVLGFBQWEsK0NBQStDLGFBQWEsa0JBQWtCLHVDQUF1Qyw2QkFBNkIseUJBQXlCLGNBQWMsOERBQThELGNBQWMsNENBQTRDLHFCQUFxQixhQUFhLDBDQUEwQyw0QkFBNEIsa0dBQWtHLDBCQUEwQiw0QkFBNEIsV0FBVyw4Q0FBOEMsYUFBYSxtREFBbUQsU0FBUyxNQUFNLGNBQWMsb0dBQW9HLFNBQVMsZ0JBQWdCLDBEQUEwRCw4RkFBOEYsWUFBWSxjQUFjLFVBQVUsa0JBQWtCLGFBQWEsTUFBTSwwQkFBMEIsbUNBQW1DLCtCQUErQixrQkFBa0IsZ0JBQWdCLGlDQUFpQyxjQUFjLDZCQUE2QixnQkFBZ0IsbUZBQW1GLFlBQVksdUJBQXVCLElBQUksZ0JBQWdCLDZEQUE2RCxPQUFPLFNBQVMsU0FBUyxRQUFRLElBQUksb0NBQW9DLFFBQVEsY0FBYyxVQUFVLGdCQUFnQixNQUFNLG9DQUFvQyxvREFBb0QsZ0xBQWdMLGdCQUFnQixvQ0FBb0MsdUJBQXVCLElBQUksY0FBYyxTQUFTLGFBQWEsaUtBQWlLLGdCQUFnQixzRUFBc0UsT0FBTyxnRUFBZ0UsU0FBUyx1QkFBdUIsT0FBTyxpQkFBaUIsb0JBQW9CLFFBQVEsRUFBRSxz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QUFLLElBQUksb0NBQW9DLHlDQUF5QywrQkFBK0IsS0FBSyxXQUFXLFdBQVcsY0FBYyxlQUFlLHFDQUFxQyxFQUFFLHFDQUFxQyxZQUFZLElBQUkseUJBQXlCLFVBQVUsRUFBRSx3Q0FBd0MsMEJBQTBCLEtBQUssV0FBVyw2cUJBQTZxQixjQUFjLGFBQWEsMEJBQTBCLG9DQUFvQywyQkFBMkIsYUFBYSxHQUFHO0FBQzdpakMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90b2RvLWxpc3QvLi9ub2RlX21vZHVsZXMvanNiaS9kaXN0L2pzYmktdW1kLmpzP2Y1NTciXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKGUsdCl7XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHMmJlwidW5kZWZpbmVkXCIhPXR5cGVvZiBtb2R1bGU/bW9kdWxlLmV4cG9ydHM9dCgpOlwiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUodCk6KGU9ZXx8c2VsZixlLkpTQkk9dCgpKX0pKHRoaXMsZnVuY3Rpb24oKXtcInVzZSBzdHJpY3RcIjt2YXIgZT1NYXRoLmltdWwsdD1NYXRoLmNsejMyO2Z1bmN0aW9uIGkoZSl7XCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiO3JldHVybiBpPVwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmXCJzeW1ib2xcIj09dHlwZW9mIFN5bWJvbC5pdGVyYXRvcj9mdW5jdGlvbihlKXtyZXR1cm4gdHlwZW9mIGV9OmZ1bmN0aW9uKGUpe3JldHVybiBlJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJmUuY29uc3RydWN0b3I9PT1TeW1ib2wmJmUhPT1TeW1ib2wucHJvdG90eXBlP1wic3ltYm9sXCI6dHlwZW9mIGV9LGkoZSl9ZnVuY3Rpb24gXyhlLHQpe2lmKCEoZSBpbnN0YW5jZW9mIHQpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIil9ZnVuY3Rpb24gbihlLHQpe2Zvcih2YXIgXyxuPTA7bjx0Lmxlbmd0aDtuKyspXz10W25dLF8uZW51bWVyYWJsZT1fLmVudW1lcmFibGV8fCExLF8uY29uZmlndXJhYmxlPSEwLFwidmFsdWVcImluIF8mJihfLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxfLmtleSxfKX1mdW5jdGlvbiBsKGUsdCxpKXtyZXR1cm4gdCYmbihlLnByb3RvdHlwZSx0KSxpJiZuKGUsaSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJwcm90b3R5cGVcIix7d3JpdGFibGU6ITF9KSxlfWZ1bmN0aW9uIGcoZSx0KXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiB0JiZudWxsIT09dCl0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7ZS5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZSh0JiZ0LnByb3RvdHlwZSx7Y29uc3RydWN0b3I6e3ZhbHVlOmUsd3JpdGFibGU6ITAsY29uZmlndXJhYmxlOiEwfX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwicHJvdG90eXBlXCIse3dyaXRhYmxlOiExfSksdCYmdShlLHQpfWZ1bmN0aW9uIGEoZSl7cmV0dXJuIGE9T2JqZWN0LnNldFByb3RvdHlwZU9mP09iamVjdC5nZXRQcm90b3R5cGVPZjpmdW5jdGlvbihlKXtyZXR1cm4gZS5fX3Byb3RvX198fE9iamVjdC5nZXRQcm90b3R5cGVPZihlKX0sYShlKX1mdW5jdGlvbiB1KGUsdCl7cmV0dXJuIHU9T2JqZWN0LnNldFByb3RvdHlwZU9mfHxmdW5jdGlvbihlLHQpe3JldHVybiBlLl9fcHJvdG9fXz10LGV9LHUoZSx0KX1mdW5jdGlvbiBzKCl7aWYoXCJ1bmRlZmluZWRcIj09dHlwZW9mIFJlZmxlY3R8fCFSZWZsZWN0LmNvbnN0cnVjdClyZXR1cm4hMTtpZihSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKXJldHVybiExO2lmKFwiZnVuY3Rpb25cIj09dHlwZW9mIFByb3h5KXJldHVybiEwO3RyeXtyZXR1cm4gQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sW10sZnVuY3Rpb24oKXt9KSksITB9Y2F0Y2godCl7cmV0dXJuITF9fWZ1bmN0aW9uIHIoKXtyZXR1cm4gcj1zKCk/UmVmbGVjdC5jb25zdHJ1Y3Q6ZnVuY3Rpb24oZSx0LGkpe3ZhciBfPVtudWxsXTtfLnB1c2guYXBwbHkoXyx0KTt2YXIgbj1GdW5jdGlvbi5iaW5kLmFwcGx5KGUsXyksbD1uZXcgbjtyZXR1cm4gaSYmdShsLGkucHJvdG90eXBlKSxsfSxyLmFwcGx5KG51bGwsYXJndW1lbnRzKX1mdW5jdGlvbiBkKGUpe3JldHVybi0xIT09RnVuY3Rpb24udG9TdHJpbmcuY2FsbChlKS5pbmRleE9mKFwiW25hdGl2ZSBjb2RlXVwiKX1mdW5jdGlvbiBoKGUpe3ZhciB0PVwiZnVuY3Rpb25cIj09dHlwZW9mIE1hcD9uZXcgTWFwOnZvaWQgMDtyZXR1cm4gaD1mdW5jdGlvbihlKXtmdW5jdGlvbiBpKCl7cmV0dXJuIHIoZSxhcmd1bWVudHMsYSh0aGlzKS5jb25zdHJ1Y3Rvcil9aWYobnVsbD09PWV8fCFkKGUpKXJldHVybiBlO2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIGUpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO2lmKFwidW5kZWZpbmVkXCIhPXR5cGVvZiB0KXtpZih0LmhhcyhlKSlyZXR1cm4gdC5nZXQoZSk7dC5zZXQoZSxpKX1yZXR1cm4gaS5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShlLnByb3RvdHlwZSx7Y29uc3RydWN0b3I6e3ZhbHVlOmksZW51bWVyYWJsZTohMSx3cml0YWJsZTohMCxjb25maWd1cmFibGU6ITB9fSksdShpLGUpfSxoKGUpfWZ1bmN0aW9uIGIoZSl7aWYodm9pZCAwPT09ZSl0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7cmV0dXJuIGV9ZnVuY3Rpb24gbShlLHQpe2lmKHQmJihcIm9iamVjdFwiPT10eXBlb2YgdHx8XCJmdW5jdGlvblwiPT10eXBlb2YgdCkpcmV0dXJuIHQ7aWYodm9pZCAwIT09dCl0aHJvdyBuZXcgVHlwZUVycm9yKFwiRGVyaXZlZCBjb25zdHJ1Y3RvcnMgbWF5IG9ubHkgcmV0dXJuIG9iamVjdCBvciB1bmRlZmluZWRcIik7cmV0dXJuIGIoZSl9ZnVuY3Rpb24gYyhlKXt2YXIgdD1zKCk7cmV0dXJuIGZ1bmN0aW9uKCl7dmFyIGksXz1hKGUpO2lmKHQpe3ZhciBuPWEodGhpcykuY29uc3RydWN0b3I7aT1SZWZsZWN0LmNvbnN0cnVjdChfLGFyZ3VtZW50cyxuKX1lbHNlIGk9Xy5hcHBseSh0aGlzLGFyZ3VtZW50cyk7cmV0dXJuIG0odGhpcyxpKX19ZnVuY3Rpb24gdihlLHQpe3JldHVybiB5KGUpfHxmKGUsdCl8fEQoZSx0KXx8aygpfWZ1bmN0aW9uIHkoZSl7aWYoQXJyYXkuaXNBcnJheShlKSlyZXR1cm4gZX1mdW5jdGlvbiBmKGUsdCl7dmFyIGk9bnVsbD09ZT9udWxsOlwidW5kZWZpbmVkXCIhPXR5cGVvZiBTeW1ib2wmJmVbU3ltYm9sLml0ZXJhdG9yXXx8ZVtcIkBAaXRlcmF0b3JcIl07aWYobnVsbCE9aSl7dmFyIF8sbixsPVtdLGc9ITAsbz0hMTt0cnl7Zm9yKGk9aS5jYWxsKGUpOyEoZz0oXz1pLm5leHQoKSkuZG9uZSkmJihsLnB1c2goXy52YWx1ZSksISh0JiZsLmxlbmd0aD09PXQpKTtnPSEwKTt9Y2F0Y2goZSl7bz0hMCxuPWV9ZmluYWxseXt0cnl7Z3x8bnVsbD09aVtcInJldHVyblwiXXx8aVtcInJldHVyblwiXSgpfWZpbmFsbHl7aWYobyl0aHJvdyBufX1yZXR1cm4gbH19ZnVuY3Rpb24gRChlLHQpe2lmKGUpe2lmKFwic3RyaW5nXCI9PXR5cGVvZiBlKXJldHVybiBwKGUsdCk7dmFyIGk9T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGUpLnNsaWNlKDgsLTEpO3JldHVyblwiT2JqZWN0XCI9PT1pJiZlLmNvbnN0cnVjdG9yJiYoaT1lLmNvbnN0cnVjdG9yLm5hbWUpLFwiTWFwXCI9PT1pfHxcIlNldFwiPT09aT9BcnJheS5mcm9tKGUpOlwiQXJndW1lbnRzXCI9PT1pfHwvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChpKT9wKGUsdCk6dm9pZCAwfX1mdW5jdGlvbiBwKGUsdCl7KG51bGw9PXR8fHQ+ZS5sZW5ndGgpJiYodD1lLmxlbmd0aCk7Zm9yKHZhciBfPTAsbj1BcnJheSh0KTtfPHQ7XysrKW5bX109ZVtfXTtyZXR1cm4gbn1mdW5jdGlvbiBrKCl7dGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKX1mdW5jdGlvbiBCKGUsdCl7dmFyIF89XCJ1bmRlZmluZWRcIiE9dHlwZW9mIFN5bWJvbCYmZVtTeW1ib2wuaXRlcmF0b3JdfHxlW1wiQEBpdGVyYXRvclwiXTtpZighXyl7aWYoQXJyYXkuaXNBcnJheShlKXx8KF89RChlKSl8fHQmJmUmJlwibnVtYmVyXCI9PXR5cGVvZiBlLmxlbmd0aCl7XyYmKGU9Xyk7dmFyIG49MCxsPWZ1bmN0aW9uKCl7fTtyZXR1cm57czpsLG46ZnVuY3Rpb24oKXtyZXR1cm4gbj49ZS5sZW5ndGg/e2RvbmU6ITB9Ontkb25lOiExLHZhbHVlOmVbbisrXX19LGU6ZnVuY3Rpb24odCl7dGhyb3cgdH0sZjpsfX10aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIil9dmFyIGcsYT0hMCx1PSExO3JldHVybntzOmZ1bmN0aW9uKCl7Xz1fLmNhbGwoZSl9LG46ZnVuY3Rpb24oKXt2YXIgZT1fLm5leHQoKTtyZXR1cm4gYT1lLmRvbmUsZX0sZTpmdW5jdGlvbih0KXt1PSEwLGc9dH0sZjpmdW5jdGlvbigpe3RyeXthfHxudWxsPT1fLnJldHVybnx8Xy5yZXR1cm4oKX1maW5hbGx5e2lmKHUpdGhyb3cgZ319fX12YXIgUz1mdW5jdGlvbihlKXt2YXIgdD1NYXRoLmFicyxuPU1hdGgubWF4LG89TWF0aC5mbG9vcjtmdW5jdGlvbiBhKGUsdCl7dmFyIGk7aWYoXyh0aGlzLGEpLGk9dS5jYWxsKHRoaXMsZSksaS5zaWduPXQsT2JqZWN0LnNldFByb3RvdHlwZU9mKGIoaSksYS5wcm90b3R5cGUpLGU+YS5fX2tNYXhMZW5ndGgpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJNYXhpbXVtIEJpZ0ludCBzaXplIGV4Y2VlZGVkXCIpO3JldHVybiBpfWcoYSxlKTt2YXIgdT1jKGEpO3JldHVybiBsKGEsW3trZXk6XCJ0b0RlYnVnU3RyaW5nXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZSx0PVtcIkJpZ0ludFtcIl0saT1CKHRoaXMpO3RyeXtmb3IoaS5zKCk7IShlPWkubigpKS5kb25lOyl7dmFyIF89ZS52YWx1ZTt0LnB1c2goKF8/KF8+Pj4wKS50b1N0cmluZygxNik6XykrXCIsIFwiKX19Y2F0Y2goZSl7aS5lKGUpfWZpbmFsbHl7aS5mKCl9cmV0dXJuIHQucHVzaChcIl1cIiksdC5qb2luKFwiXCIpfX0se2tleTpcInRvU3RyaW5nXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT0wPGFyZ3VtZW50cy5sZW5ndGgmJnZvaWQgMCE9PWFyZ3VtZW50c1swXT9hcmd1bWVudHNbMF06MTA7aWYoMj5lfHwzNjxlKXRocm93IG5ldyBSYW5nZUVycm9yKFwidG9TdHJpbmcoKSByYWRpeCBhcmd1bWVudCBtdXN0IGJlIGJldHdlZW4gMiBhbmQgMzZcIik7cmV0dXJuIDA9PT10aGlzLmxlbmd0aD9cIjBcIjowPT0oZSZlLTEpP2EuX190b1N0cmluZ0Jhc2VQb3dlck9mVHdvKHRoaXMsZSk6YS5fX3RvU3RyaW5nR2VuZXJpYyh0aGlzLGUsITEpfX0se2tleTpcInZhbHVlT2ZcIix2YWx1ZTpmdW5jdGlvbigpe3Rocm93IG5ldyBFcnJvcihcIkNvbnZlcnQgSlNCSSBpbnN0YW5jZXMgdG8gbmF0aXZlIG51bWJlcnMgdXNpbmcgYHRvTnVtYmVyYC5cIil9fSx7a2V5OlwiX19jb3B5XCIsdmFsdWU6ZnVuY3Rpb24oKXtmb3IodmFyIGU9bmV3IGEodGhpcy5sZW5ndGgsdGhpcy5zaWduKSx0PTA7dDx0aGlzLmxlbmd0aDt0KyspZVt0XT10aGlzW3RdO3JldHVybiBlfX0se2tleTpcIl9fdHJpbVwiLHZhbHVlOmZ1bmN0aW9uKCl7Zm9yKHZhciBlPXRoaXMubGVuZ3RoLHQ9dGhpc1tlLTFdOzA9PT10OyllLS0sdD10aGlzW2UtMV0sdGhpcy5wb3AoKTtyZXR1cm4gMD09PWUmJih0aGlzLnNpZ249ITEpLHRoaXN9fSx7a2V5OlwiX19pbml0aWFsaXplRGlnaXRzXCIsdmFsdWU6ZnVuY3Rpb24oKXtmb3IodmFyIGU9MDtlPHRoaXMubGVuZ3RoO2UrKyl0aGlzW2VdPTB9fSx7a2V5OlwiX19jbHptc2RcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiBhLl9fY2x6MzAodGhpcy5fX2RpZ2l0KHRoaXMubGVuZ3RoLTEpKX19LHtrZXk6XCJfX2lucGxhY2VNdWx0aXBseUFkZFwiLHZhbHVlOmZ1bmN0aW9uKGUsdCxfKXtfPnRoaXMubGVuZ3RoJiYoXz10aGlzLmxlbmd0aCk7Zm9yKHZhciBuPTMyNzY3JmUsbD1lPj4+MTUsZz0wLG89dCx1PTA7dTxfO3UrKyl7dmFyIHM9dGhpcy5fX2RpZ2l0KHUpLHI9MzI3NjcmcyxkPXM+Pj4xNSxoPWEuX19pbXVsKHIsbiksYj1hLl9faW11bChyLGwpLG09YS5fX2ltdWwoZCxuKSxjPWEuX19pbXVsKGQsbCksdj1vK2grZztnPXY+Pj4zMCx2Jj0xMDczNzQxODIzLHYrPSgoMzI3NjcmYik8PDE1KSsoKDMyNzY3Jm0pPDwxNSksZys9dj4+PjMwLG89YysoYj4+PjE1KSsobT4+PjE1KSx0aGlzLl9fc2V0RGlnaXQodSwxMDczNzQxODIzJnYpfWlmKDAhPT1nfHwwIT09byl0aHJvdyBuZXcgRXJyb3IoXCJpbXBsZW1lbnRhdGlvbiBidWdcIil9fSx7a2V5OlwiX19pbnBsYWNlQWRkXCIsdmFsdWU6ZnVuY3Rpb24oZSx0LF8pe2Zvcih2YXIgbixsPTAsZz0wO2c8XztnKyspbj10aGlzLl9faGFsZkRpZ2l0KHQrZykrZS5fX2hhbGZEaWdpdChnKStsLGw9bj4+PjE1LHRoaXMuX19zZXRIYWxmRGlnaXQodCtnLDMyNzY3Jm4pO3JldHVybiBsfX0se2tleTpcIl9faW5wbGFjZVN1YlwiLHZhbHVlOmZ1bmN0aW9uKGUsdCxfKXt2YXIgbj0wO2lmKDEmdCl7dD4+PTE7Zm9yKHZhciBsPXRoaXMuX19kaWdpdCh0KSxnPTMyNzY3Jmwsbz0wO288Xy0xPj4+MTtvKyspe3ZhciBhPWUuX19kaWdpdChvKSx1PShsPj4+MTUpLSgzMjc2NyZhKS1uO249MSZ1Pj4+MTUsdGhpcy5fX3NldERpZ2l0KHQrbywoMzI3NjcmdSk8PDE1fDMyNzY3JmcpLGw9dGhpcy5fX2RpZ2l0KHQrbysxKSxnPSgzMjc2NyZsKS0oYT4+PjE1KS1uLG49MSZnPj4+MTV9dmFyIHM9ZS5fX2RpZ2l0KG8pLHI9KGw+Pj4xNSktKDMyNzY3JnMpLW47bj0xJnI+Pj4xNSx0aGlzLl9fc2V0RGlnaXQodCtvLCgzMjc2NyZyKTw8MTV8MzI3NjcmZyk7aWYodCtvKzE+PXRoaXMubGVuZ3RoKXRocm93IG5ldyBSYW5nZUVycm9yKFwib3V0IG9mIGJvdW5kc1wiKTswPT0oMSZfKSYmKGw9dGhpcy5fX2RpZ2l0KHQrbysxKSxnPSgzMjc2NyZsKS0ocz4+PjE1KS1uLG49MSZnPj4+MTUsdGhpcy5fX3NldERpZ2l0KHQrZS5sZW5ndGgsMTA3MzcwOTA1NiZsfDMyNzY3JmcpKX1lbHNle3Q+Pj0xO2Zvcih2YXIgZD0wO2Q8ZS5sZW5ndGgtMTtkKyspe3ZhciBoPXRoaXMuX19kaWdpdCh0K2QpLGI9ZS5fX2RpZ2l0KGQpLG09KDMyNzY3JmgpLSgzMjc2NyZiKS1uO249MSZtPj4+MTU7dmFyIGM9KGg+Pj4xNSktKGI+Pj4xNSktbjtuPTEmYz4+PjE1LHRoaXMuX19zZXREaWdpdCh0K2QsKDMyNzY3JmMpPDwxNXwzMjc2NyZtKX12YXIgdj10aGlzLl9fZGlnaXQodCtkKSx5PWUuX19kaWdpdChkKSxmPSgzMjc2NyZ2KS0oMzI3NjcmeSktbjtuPTEmZj4+PjE1O3ZhciBEPTA7MD09KDEmXykmJihEPSh2Pj4+MTUpLSh5Pj4+MTUpLW4sbj0xJkQ+Pj4xNSksdGhpcy5fX3NldERpZ2l0KHQrZCwoMzI3NjcmRCk8PDE1fDMyNzY3JmYpfXJldHVybiBufX0se2tleTpcIl9faW5wbGFjZVJpZ2h0U2hpZnRcIix2YWx1ZTpmdW5jdGlvbihlKXtpZigwIT09ZSl7Zm9yKHZhciB0LF89dGhpcy5fX2RpZ2l0KDApPj4+ZSxuPXRoaXMubGVuZ3RoLTEsbD0wO2w8bjtsKyspdD10aGlzLl9fZGlnaXQobCsxKSx0aGlzLl9fc2V0RGlnaXQobCwxMDczNzQxODIzJnQ8PDMwLWV8XyksXz10Pj4+ZTt0aGlzLl9fc2V0RGlnaXQobixfKX19fSx7a2V5OlwiX19kaWdpdFwiLHZhbHVlOmZ1bmN0aW9uKGUpe3JldHVybiB0aGlzW2VdfX0se2tleTpcIl9fdW5zaWduZWREaWdpdFwiLHZhbHVlOmZ1bmN0aW9uKGUpe3JldHVybiB0aGlzW2VdPj4+MH19LHtrZXk6XCJfX3NldERpZ2l0XCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXt0aGlzW2VdPTB8dH19LHtrZXk6XCJfX3NldERpZ2l0R3Jvd1wiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7dGhpc1tlXT0wfHR9fSx7a2V5OlwiX19oYWxmRGlnaXRMZW5ndGhcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPXRoaXMubGVuZ3RoO3JldHVybiAzMjc2Nz49dGhpcy5fX3Vuc2lnbmVkRGlnaXQoZS0xKT8yKmUtMToyKmV9fSx7a2V5OlwiX19oYWxmRGlnaXRcIix2YWx1ZTpmdW5jdGlvbihlKXtyZXR1cm4gMzI3NjcmdGhpc1tlPj4+MV0+Pj4xNSooMSZlKX19LHtrZXk6XCJfX3NldEhhbGZEaWdpdFwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7dmFyIGk9ZT4+PjEsXz10aGlzLl9fZGlnaXQoaSksbj0xJmU/MzI3NjcmX3x0PDwxNToxMDczNzA5MDU2Jl98MzI3NjcmdDt0aGlzLl9fc2V0RGlnaXQoaSxuKX19XSxbe2tleTpcIkJpZ0ludFwiLHZhbHVlOmZ1bmN0aW9uKGUpe3ZhciB0PU51bWJlci5pc0Zpbml0ZTtpZihcIm51bWJlclwiPT10eXBlb2YgZSl7aWYoMD09PWUpcmV0dXJuIGEuX196ZXJvKCk7aWYoYS5fX2lzT25lRGlnaXRJbnQoZSkpcmV0dXJuIDA+ZT9hLl9fb25lRGlnaXQoLWUsITApOmEuX19vbmVEaWdpdChlLCExKTtpZighdChlKXx8byhlKSE9PWUpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJUaGUgbnVtYmVyIFwiK2UrXCIgY2Fubm90IGJlIGNvbnZlcnRlZCB0byBCaWdJbnQgYmVjYXVzZSBpdCBpcyBub3QgYW4gaW50ZWdlclwiKTtyZXR1cm4gYS5fX2Zyb21Eb3VibGUoZSl9aWYoXCJzdHJpbmdcIj09dHlwZW9mIGUpe3ZhciBfPWEuX19mcm9tU3RyaW5nKGUpO2lmKG51bGw9PT1fKXRocm93IG5ldyBTeW50YXhFcnJvcihcIkNhbm5vdCBjb252ZXJ0IFwiK2UrXCIgdG8gYSBCaWdJbnRcIik7cmV0dXJuIF99aWYoXCJib29sZWFuXCI9PXR5cGVvZiBlKXJldHVybiEwPT09ZT9hLl9fb25lRGlnaXQoMSwhMSk6YS5fX3plcm8oKTtpZihcIm9iamVjdFwiPT09aShlKSl7aWYoZS5jb25zdHJ1Y3Rvcj09PWEpcmV0dXJuIGU7dmFyIG49YS5fX3RvUHJpbWl0aXZlKGUpO3JldHVybiBhLkJpZ0ludChuKX10aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNvbnZlcnQgXCIrZStcIiB0byBhIEJpZ0ludFwiKX19LHtrZXk6XCJ0b051bWJlclwiLHZhbHVlOmZ1bmN0aW9uKGUpe3ZhciB0PWUubGVuZ3RoO2lmKDA9PT10KXJldHVybiAwO2lmKDE9PT10KXt2YXIgaT1lLl9fdW5zaWduZWREaWdpdCgwKTtyZXR1cm4gZS5zaWduPy1pOml9dmFyIF89ZS5fX2RpZ2l0KHQtMSksbj1hLl9fY2x6MzAoXyksbD0zMCp0LW47aWYoMTAyNDxsKXJldHVybiBlLnNpZ24/LUluZmluaXR5OjEvMDt2YXIgZz1sLTEsbz1fLHU9dC0xLHM9biszLHI9MzI9PT1zPzA6bzw8cztyPj4+PTEyO3ZhciBkPXMtMTIsaD0xMjw9cz8wOm88PDIwK3MsYj0yMCtzO2ZvcigwPGQmJjA8dSYmKHUtLSxvPWUuX19kaWdpdCh1KSxyfD1vPj4+MzAtZCxoPW88PGQrMixiPWQrMik7MDxiJiYwPHU7KXUtLSxvPWUuX19kaWdpdCh1KSxofD0zMDw9Yj9vPDxiLTMwOm8+Pj4zMC1iLGItPTMwO3ZhciBtPWEuX19kZWNpZGVSb3VuZGluZyhlLGIsdSxvKTtpZigoMT09PW18fDA9PT1tJiYxPT0oMSZoKSkmJihoPWgrMT4+PjAsMD09PWgmJihyKyssMCE9cj4+PjIwJiYocj0wLGcrKywxMDIzPGcpKSkpcmV0dXJuIGUuc2lnbj8tSW5maW5pdHk6MS8wO3ZhciBjPWUuc2lnbj8tMjE0NzQ4MzY0ODowO3JldHVybiBnPWcrMTAyMzw8MjAsYS5fX2tCaXRDb252ZXJzaW9uSW50c1sxXT1jfGd8cixhLl9fa0JpdENvbnZlcnNpb25JbnRzWzBdPWgsYS5fX2tCaXRDb252ZXJzaW9uRG91YmxlWzBdfX0se2tleTpcInVuYXJ5TWludXNcIix2YWx1ZTpmdW5jdGlvbihlKXtpZigwPT09ZS5sZW5ndGgpcmV0dXJuIGU7dmFyIHQ9ZS5fX2NvcHkoKTtyZXR1cm4gdC5zaWduPSFlLnNpZ24sdH19LHtrZXk6XCJiaXR3aXNlTm90XCIsdmFsdWU6ZnVuY3Rpb24oZSl7cmV0dXJuIGUuc2lnbj9hLl9fYWJzb2x1dGVTdWJPbmUoZSkuX190cmltKCk6YS5fX2Fic29sdXRlQWRkT25lKGUsITApfX0se2tleTpcImV4cG9uZW50aWF0ZVwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7aWYodC5zaWduKXRocm93IG5ldyBSYW5nZUVycm9yKFwiRXhwb25lbnQgbXVzdCBiZSBwb3NpdGl2ZVwiKTtpZigwPT09dC5sZW5ndGgpcmV0dXJuIGEuX19vbmVEaWdpdCgxLCExKTtpZigwPT09ZS5sZW5ndGgpcmV0dXJuIGU7aWYoMT09PWUubGVuZ3RoJiYxPT09ZS5fX2RpZ2l0KDApKXJldHVybiBlLnNpZ24mJjA9PSgxJnQuX19kaWdpdCgwKSk/YS51bmFyeU1pbnVzKGUpOmU7aWYoMTx0Lmxlbmd0aCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkJpZ0ludCB0b28gYmlnXCIpO3ZhciBpPXQuX191bnNpZ25lZERpZ2l0KDApO2lmKDE9PT1pKXJldHVybiBlO2lmKGk+PWEuX19rTWF4TGVuZ3RoQml0cyl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkJpZ0ludCB0b28gYmlnXCIpO2lmKDE9PT1lLmxlbmd0aCYmMj09PWUuX19kaWdpdCgwKSl7dmFyIF89MSsoMHxpLzMwKSxuPWUuc2lnbiYmMCE9KDEmaSksbD1uZXcgYShfLG4pO2wuX19pbml0aWFsaXplRGlnaXRzKCk7dmFyIGc9MTw8aSUzMDtyZXR1cm4gbC5fX3NldERpZ2l0KF8tMSxnKSxsfXZhciBvPW51bGwsdT1lO2ZvcigwIT0oMSZpKSYmKG89ZSksaT4+PTE7MCE9PWk7aT4+PTEpdT1hLm11bHRpcGx5KHUsdSksMCE9KDEmaSkmJihudWxsPT09bz9vPXU6bz1hLm11bHRpcGx5KG8sdSkpO3JldHVybiBvfX0se2tleTpcIm11bHRpcGx5XCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXtpZigwPT09ZS5sZW5ndGgpcmV0dXJuIGU7aWYoMD09PXQubGVuZ3RoKXJldHVybiB0O3ZhciBfPWUubGVuZ3RoK3QubGVuZ3RoOzMwPD1lLl9fY2x6bXNkKCkrdC5fX2Nsem1zZCgpJiZfLS07dmFyIG49bmV3IGEoXyxlLnNpZ24hPT10LnNpZ24pO24uX19pbml0aWFsaXplRGlnaXRzKCk7Zm9yKHZhciBsPTA7bDxlLmxlbmd0aDtsKyspYS5fX211bHRpcGx5QWNjdW11bGF0ZSh0LGUuX19kaWdpdChsKSxuLGwpO3JldHVybiBuLl9fdHJpbSgpfX0se2tleTpcImRpdmlkZVwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7aWYoMD09PXQubGVuZ3RoKXRocm93IG5ldyBSYW5nZUVycm9yKFwiRGl2aXNpb24gYnkgemVyb1wiKTtpZigwPmEuX19hYnNvbHV0ZUNvbXBhcmUoZSx0KSlyZXR1cm4gYS5fX3plcm8oKTt2YXIgaSxfPWUuc2lnbiE9PXQuc2lnbixuPXQuX191bnNpZ25lZERpZ2l0KDApO2lmKDE9PT10Lmxlbmd0aCYmMzI3Njc+PW4pe2lmKDE9PT1uKXJldHVybiBfPT09ZS5zaWduP2U6YS51bmFyeU1pbnVzKGUpO2k9YS5fX2Fic29sdXRlRGl2U21hbGwoZSxuLG51bGwpfWVsc2UgaT1hLl9fYWJzb2x1dGVEaXZMYXJnZShlLHQsITAsITEpO3JldHVybiBpLnNpZ249XyxpLl9fdHJpbSgpfX0se2tleTpcInJlbWFpbmRlclwiLHZhbHVlOmZ1bmN0aW9uIGkoZSx0KXtpZigwPT09dC5sZW5ndGgpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJEaXZpc2lvbiBieSB6ZXJvXCIpO2lmKDA+YS5fX2Fic29sdXRlQ29tcGFyZShlLHQpKXJldHVybiBlO3ZhciBfPXQuX191bnNpZ25lZERpZ2l0KDApO2lmKDE9PT10Lmxlbmd0aCYmMzI3Njc+PV8pe2lmKDE9PT1fKXJldHVybiBhLl9femVybygpO3ZhciBuPWEuX19hYnNvbHV0ZU1vZFNtYWxsKGUsXyk7cmV0dXJuIDA9PT1uP2EuX196ZXJvKCk6YS5fX29uZURpZ2l0KG4sZS5zaWduKX12YXIgaT1hLl9fYWJzb2x1dGVEaXZMYXJnZShlLHQsITEsITApO3JldHVybiBpLnNpZ249ZS5zaWduLGkuX190cmltKCl9fSx7a2V5OlwiYWRkXCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXt2YXIgaT1lLnNpZ247cmV0dXJuIGk9PT10LnNpZ24/YS5fX2Fic29sdXRlQWRkKGUsdCxpKTowPD1hLl9fYWJzb2x1dGVDb21wYXJlKGUsdCk/YS5fX2Fic29sdXRlU3ViKGUsdCxpKTphLl9fYWJzb2x1dGVTdWIodCxlLCFpKX19LHtrZXk6XCJzdWJ0cmFjdFwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7dmFyIGk9ZS5zaWduO3JldHVybiBpPT09dC5zaWduPzA8PWEuX19hYnNvbHV0ZUNvbXBhcmUoZSx0KT9hLl9fYWJzb2x1dGVTdWIoZSx0LGkpOmEuX19hYnNvbHV0ZVN1Yih0LGUsIWkpOmEuX19hYnNvbHV0ZUFkZChlLHQsaSl9fSx7a2V5OlwibGVmdFNoaWZ0XCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gMD09PXQubGVuZ3RofHwwPT09ZS5sZW5ndGg/ZTp0LnNpZ24/YS5fX3JpZ2h0U2hpZnRCeUFic29sdXRlKGUsdCk6YS5fX2xlZnRTaGlmdEJ5QWJzb2x1dGUoZSx0KX19LHtrZXk6XCJzaWduZWRSaWdodFNoaWZ0XCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gMD09PXQubGVuZ3RofHwwPT09ZS5sZW5ndGg/ZTp0LnNpZ24/YS5fX2xlZnRTaGlmdEJ5QWJzb2x1dGUoZSx0KTphLl9fcmlnaHRTaGlmdEJ5QWJzb2x1dGUoZSx0KX19LHtrZXk6XCJ1bnNpZ25lZFJpZ2h0U2hpZnRcIix2YWx1ZTpmdW5jdGlvbigpe3Rocm93IG5ldyBUeXBlRXJyb3IoXCJCaWdJbnRzIGhhdmUgbm8gdW5zaWduZWQgcmlnaHQgc2hpZnQ7IHVzZSA+PiBpbnN0ZWFkXCIpfX0se2tleTpcImxlc3NUaGFuXCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gMD5hLl9fY29tcGFyZVRvQmlnSW50KGUsdCl9fSx7a2V5OlwibGVzc1RoYW5PckVxdWFsXCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gMD49YS5fX2NvbXBhcmVUb0JpZ0ludChlLHQpfX0se2tleTpcImdyZWF0ZXJUaGFuXCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gMDxhLl9fY29tcGFyZVRvQmlnSW50KGUsdCl9fSx7a2V5OlwiZ3JlYXRlclRoYW5PckVxdWFsXCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gMDw9YS5fX2NvbXBhcmVUb0JpZ0ludChlLHQpfX0se2tleTpcImVxdWFsXCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXtpZihlLnNpZ24hPT10LnNpZ24pcmV0dXJuITE7aWYoZS5sZW5ndGghPT10Lmxlbmd0aClyZXR1cm4hMTtmb3IodmFyIF89MDtfPGUubGVuZ3RoO18rKylpZihlLl9fZGlnaXQoXykhPT10Ll9fZGlnaXQoXykpcmV0dXJuITE7cmV0dXJuITB9fSx7a2V5Olwibm90RXF1YWxcIix2YWx1ZTpmdW5jdGlvbihlLHQpe3JldHVybiFhLmVxdWFsKGUsdCl9fSx7a2V5OlwiYml0d2lzZUFuZFwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7aWYoIWUuc2lnbiYmIXQuc2lnbilyZXR1cm4gYS5fX2Fic29sdXRlQW5kKGUsdCkuX190cmltKCk7aWYoZS5zaWduJiZ0LnNpZ24pe3ZhciBpPW4oZS5sZW5ndGgsdC5sZW5ndGgpKzEsXz1hLl9fYWJzb2x1dGVTdWJPbmUoZSxpKSxsPWEuX19hYnNvbHV0ZVN1Yk9uZSh0KTtyZXR1cm4gXz1hLl9fYWJzb2x1dGVPcihfLGwsXyksYS5fX2Fic29sdXRlQWRkT25lKF8sITAsXykuX190cmltKCl9aWYoZS5zaWduKXt2YXIgZz1bdCxlXTtlPWdbMF0sdD1nWzFdfXJldHVybiBhLl9fYWJzb2x1dGVBbmROb3QoZSxhLl9fYWJzb2x1dGVTdWJPbmUodCkpLl9fdHJpbSgpfX0se2tleTpcImJpdHdpc2VYb3JcIix2YWx1ZTpmdW5jdGlvbihlLHQpe2lmKCFlLnNpZ24mJiF0LnNpZ24pcmV0dXJuIGEuX19hYnNvbHV0ZVhvcihlLHQpLl9fdHJpbSgpO2lmKGUuc2lnbiYmdC5zaWduKXt2YXIgaT1uKGUubGVuZ3RoLHQubGVuZ3RoKSxfPWEuX19hYnNvbHV0ZVN1Yk9uZShlLGkpLGw9YS5fX2Fic29sdXRlU3ViT25lKHQpO3JldHVybiBhLl9fYWJzb2x1dGVYb3IoXyxsLF8pLl9fdHJpbSgpfXZhciBnPW4oZS5sZW5ndGgsdC5sZW5ndGgpKzE7aWYoZS5zaWduKXt2YXIgbz1bdCxlXTtlPW9bMF0sdD1vWzFdfXZhciB1PWEuX19hYnNvbHV0ZVN1Yk9uZSh0LGcpO3JldHVybiB1PWEuX19hYnNvbHV0ZVhvcih1LGUsdSksYS5fX2Fic29sdXRlQWRkT25lKHUsITAsdSkuX190cmltKCl9fSx7a2V5OlwiYml0d2lzZU9yXCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXt2YXIgaT1uKGUubGVuZ3RoLHQubGVuZ3RoKTtpZighZS5zaWduJiYhdC5zaWduKXJldHVybiBhLl9fYWJzb2x1dGVPcihlLHQpLl9fdHJpbSgpO2lmKGUuc2lnbiYmdC5zaWduKXt2YXIgXz1hLl9fYWJzb2x1dGVTdWJPbmUoZSxpKSxsPWEuX19hYnNvbHV0ZVN1Yk9uZSh0KTtyZXR1cm4gXz1hLl9fYWJzb2x1dGVBbmQoXyxsLF8pLGEuX19hYnNvbHV0ZUFkZE9uZShfLCEwLF8pLl9fdHJpbSgpfWlmKGUuc2lnbil7dmFyIGc9W3QsZV07ZT1nWzBdLHQ9Z1sxXX12YXIgbz1hLl9fYWJzb2x1dGVTdWJPbmUodCxpKTtyZXR1cm4gbz1hLl9fYWJzb2x1dGVBbmROb3QobyxlLG8pLGEuX19hYnNvbHV0ZUFkZE9uZShvLCEwLG8pLl9fdHJpbSgpfX0se2tleTpcImFzSW50TlwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7aWYoMD09PXQubGVuZ3RoKXJldHVybiB0O2lmKGU9byhlKSwwPmUpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIHZhbHVlOiBub3QgKGNvbnZlcnRpYmxlIHRvKSBhIHNhZmUgaW50ZWdlclwiKTtpZigwPT09ZSlyZXR1cm4gYS5fX3plcm8oKTtpZihlPj1hLl9fa01heExlbmd0aEJpdHMpcmV0dXJuIHQ7dmFyIF89MHwoZSsyOSkvMzA7aWYodC5sZW5ndGg8XylyZXR1cm4gdDt2YXIgbD10Ll9fdW5zaWduZWREaWdpdChfLTEpLGc9MTw8KGUtMSklMzA7aWYodC5sZW5ndGg9PT1fJiZsPGcpcmV0dXJuIHQ7aWYoISgobCZnKT09PWcpKXJldHVybiBhLl9fdHJ1bmNhdGVUb05CaXRzKGUsdCk7aWYoIXQuc2lnbilyZXR1cm4gYS5fX3RydW5jYXRlQW5kU3ViRnJvbVBvd2VyT2ZUd28oZSx0LCEwKTtpZigwPT0obCZnLTEpKXtmb3IodmFyIHU9Xy0yOzA8PXU7dS0tKWlmKDAhPT10Ll9fZGlnaXQodSkpcmV0dXJuIGEuX190cnVuY2F0ZUFuZFN1YkZyb21Qb3dlck9mVHdvKGUsdCwhMSk7cmV0dXJuIHQubGVuZ3RoPT09XyYmbD09PWc/dDphLl9fdHJ1bmNhdGVUb05CaXRzKGUsdCl9cmV0dXJuIGEuX190cnVuY2F0ZUFuZFN1YkZyb21Qb3dlck9mVHdvKGUsdCwhMSl9fSx7a2V5OlwiYXNVaW50TlwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7aWYoMD09PXQubGVuZ3RoKXJldHVybiB0O2lmKGU9byhlKSwwPmUpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIHZhbHVlOiBub3QgKGNvbnZlcnRpYmxlIHRvKSBhIHNhZmUgaW50ZWdlclwiKTtpZigwPT09ZSlyZXR1cm4gYS5fX3plcm8oKTtpZih0LnNpZ24pe2lmKGU+YS5fX2tNYXhMZW5ndGhCaXRzKXRocm93IG5ldyBSYW5nZUVycm9yKFwiQmlnSW50IHRvbyBiaWdcIik7cmV0dXJuIGEuX190cnVuY2F0ZUFuZFN1YkZyb21Qb3dlck9mVHdvKGUsdCwhMSl9aWYoZT49YS5fX2tNYXhMZW5ndGhCaXRzKXJldHVybiB0O3ZhciBpPTB8KGUrMjkpLzMwO2lmKHQubGVuZ3RoPGkpcmV0dXJuIHQ7dmFyIF89ZSUzMDtpZih0Lmxlbmd0aD09aSl7aWYoMD09PV8pcmV0dXJuIHQ7dmFyIGw9dC5fX2RpZ2l0KGktMSk7aWYoMD09bD4+Pl8pcmV0dXJuIHR9cmV0dXJuIGEuX190cnVuY2F0ZVRvTkJpdHMoZSx0KX19LHtrZXk6XCJBRERcIix2YWx1ZTpmdW5jdGlvbihlLHQpe2lmKGU9YS5fX3RvUHJpbWl0aXZlKGUpLHQ9YS5fX3RvUHJpbWl0aXZlKHQpLFwic3RyaW5nXCI9PXR5cGVvZiBlKXJldHVyblwic3RyaW5nXCIhPXR5cGVvZiB0JiYodD10LnRvU3RyaW5nKCkpLGUrdDtpZihcInN0cmluZ1wiPT10eXBlb2YgdClyZXR1cm4gZS50b1N0cmluZygpK3Q7aWYoZT1hLl9fdG9OdW1lcmljKGUpLHQ9YS5fX3RvTnVtZXJpYyh0KSxhLl9faXNCaWdJbnQoZSkmJmEuX19pc0JpZ0ludCh0KSlyZXR1cm4gYS5hZGQoZSx0KTtpZihcIm51bWJlclwiPT10eXBlb2YgZSYmXCJudW1iZXJcIj09dHlwZW9mIHQpcmV0dXJuIGUrdDt0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IG1peCBCaWdJbnQgYW5kIG90aGVyIHR5cGVzLCB1c2UgZXhwbGljaXQgY29udmVyc2lvbnNcIil9fSx7a2V5OlwiTFRcIix2YWx1ZTpmdW5jdGlvbihlLHQpe3JldHVybiBhLl9fY29tcGFyZShlLHQsMCl9fSx7a2V5OlwiTEVcIix2YWx1ZTpmdW5jdGlvbihlLHQpe3JldHVybiBhLl9fY29tcGFyZShlLHQsMSl9fSx7a2V5OlwiR1RcIix2YWx1ZTpmdW5jdGlvbihlLHQpe3JldHVybiBhLl9fY29tcGFyZShlLHQsMil9fSx7a2V5OlwiR0VcIix2YWx1ZTpmdW5jdGlvbihlLHQpe3JldHVybiBhLl9fY29tcGFyZShlLHQsMyl9fSx7a2V5OlwiRVFcIix2YWx1ZTpmdW5jdGlvbihlLHQpe2Zvcig7Oyl7aWYoYS5fX2lzQmlnSW50KGUpKXJldHVybiBhLl9faXNCaWdJbnQodCk/YS5lcXVhbChlLHQpOmEuRVEodCxlKTtpZihcIm51bWJlclwiPT10eXBlb2YgZSl7aWYoYS5fX2lzQmlnSW50KHQpKXJldHVybiBhLl9fZXF1YWxUb051bWJlcih0LGUpO2lmKFwib2JqZWN0XCIhPT1pKHQpKXJldHVybiBlPT10O3Q9YS5fX3RvUHJpbWl0aXZlKHQpfWVsc2UgaWYoXCJzdHJpbmdcIj09dHlwZW9mIGUpe2lmKGEuX19pc0JpZ0ludCh0KSlyZXR1cm4gZT1hLl9fZnJvbVN0cmluZyhlKSxudWxsIT09ZSYmYS5lcXVhbChlLHQpO2lmKFwib2JqZWN0XCIhPT1pKHQpKXJldHVybiBlPT10O3Q9YS5fX3RvUHJpbWl0aXZlKHQpfWVsc2UgaWYoXCJib29sZWFuXCI9PXR5cGVvZiBlKXtpZihhLl9faXNCaWdJbnQodCkpcmV0dXJuIGEuX19lcXVhbFRvTnVtYmVyKHQsK2UpO2lmKFwib2JqZWN0XCIhPT1pKHQpKXJldHVybiBlPT10O3Q9YS5fX3RvUHJpbWl0aXZlKHQpfWVsc2UgaWYoXCJzeW1ib2xcIj09PWkoZSkpe2lmKGEuX19pc0JpZ0ludCh0KSlyZXR1cm4hMTtpZihcIm9iamVjdFwiIT09aSh0KSlyZXR1cm4gZT09dDt0PWEuX190b1ByaW1pdGl2ZSh0KX1lbHNlIGlmKFwib2JqZWN0XCI9PT1pKGUpKXtpZihcIm9iamVjdFwiPT09aSh0KSYmdC5jb25zdHJ1Y3RvciE9PWEpcmV0dXJuIGU9PXQ7ZT1hLl9fdG9QcmltaXRpdmUoZSl9ZWxzZSByZXR1cm4gZT09dH19fSx7a2V5OlwiTkVcIix2YWx1ZTpmdW5jdGlvbihlLHQpe3JldHVybiFhLkVRKGUsdCl9fSx7a2V5OlwiRGF0YVZpZXdHZXRCaWdJbnQ2NFwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7dmFyIGk9ISEoMjxhcmd1bWVudHMubGVuZ3RoJiZ2b2lkIDAhPT1hcmd1bWVudHNbMl0pJiZhcmd1bWVudHNbMl07cmV0dXJuIGEuYXNJbnROKDY0LGEuRGF0YVZpZXdHZXRCaWdVaW50NjQoZSx0LGkpKX19LHtrZXk6XCJEYXRhVmlld0dldEJpZ1VpbnQ2NFwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7dmFyIGk9ISEoMjxhcmd1bWVudHMubGVuZ3RoJiZ2b2lkIDAhPT1hcmd1bWVudHNbMl0pJiZhcmd1bWVudHNbMl0sXz1pP1s0LDBdOlswLDRdLG49dihfLDIpLGc9blswXSxvPW5bMV0sbD1lLmdldFVpbnQzMih0K2csaSksdT1lLmdldFVpbnQzMih0K28saSkscz1uZXcgYSgzLCExKTtyZXR1cm4gcy5fX3NldERpZ2l0KDAsMTA3Mzc0MTgyMyZ1KSxzLl9fc2V0RGlnaXQoMSwoMjY4NDM1NDU1JmwpPDwyfHU+Pj4zMCkscy5fX3NldERpZ2l0KDIsbD4+PjI4KSxzLl9fdHJpbSgpfX0se2tleTpcIkRhdGFWaWV3U2V0QmlnSW50NjRcIix2YWx1ZTpmdW5jdGlvbihlLHQsaSl7dmFyIF89ISEoMzxhcmd1bWVudHMubGVuZ3RoJiZ2b2lkIDAhPT1hcmd1bWVudHNbM10pJiZhcmd1bWVudHNbM107YS5EYXRhVmlld1NldEJpZ1VpbnQ2NChlLHQsaSxfKX19LHtrZXk6XCJEYXRhVmlld1NldEJpZ1VpbnQ2NFwiLHZhbHVlOmZ1bmN0aW9uKGUsdCxpKXt2YXIgXz0hISgzPGFyZ3VtZW50cy5sZW5ndGgmJnZvaWQgMCE9PWFyZ3VtZW50c1szXSkmJmFyZ3VtZW50c1szXTtpPWEuYXNVaW50Tig2NCxpKTt2YXIgbj0wLGc9MDtpZigwPGkubGVuZ3RoJiYoZz1pLl9fZGlnaXQoMCksMTxpLmxlbmd0aCkpe3ZhciBvPWkuX19kaWdpdCgxKTtnfD1vPDwzMCxuPW8+Pj4yLDI8aS5sZW5ndGgmJihufD1pLl9fZGlnaXQoMik8PDI4KX12YXIgdT1fP1s0LDBdOlswLDRdLHM9dih1LDIpLHI9c1swXSxkPXNbMV07ZS5zZXRVaW50MzIodCtyLG4sXyksZS5zZXRVaW50MzIodCtkLGcsXyl9fSx7a2V5OlwiX196ZXJvXCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IGEoMCwhMSl9fSx7a2V5OlwiX19vbmVEaWdpdFwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7dmFyIGk9bmV3IGEoMSx0KTtyZXR1cm4gaS5fX3NldERpZ2l0KDAsZSksaX19LHtrZXk6XCJfX2RlY2lkZVJvdW5kaW5nXCIsdmFsdWU6ZnVuY3Rpb24oZSx0LGksXyl7aWYoMDx0KXJldHVybi0xO3ZhciBuO2lmKDA+dCluPS10LTE7ZWxzZXtpZigwPT09aSlyZXR1cm4tMTtpLS0sXz1lLl9fZGlnaXQoaSksbj0yOX12YXIgbD0xPDxuO2lmKDA9PShfJmwpKXJldHVybi0xO2lmKGwtPTEsMCE9KF8mbCkpcmV0dXJuIDE7Zm9yKDswPGk7KWlmKGktLSwwIT09ZS5fX2RpZ2l0KGkpKXJldHVybiAxO3JldHVybiAwfX0se2tleTpcIl9fZnJvbURvdWJsZVwiLHZhbHVlOmZ1bmN0aW9uKGUpe2EuX19rQml0Q29udmVyc2lvbkRvdWJsZVswXT1lO3ZhciB0LGk9MjA0NyZhLl9fa0JpdENvbnZlcnNpb25JbnRzWzFdPj4+MjAsXz1pLTEwMjMsbj0oMHxfLzMwKSsxLGw9bmV3IGEobiwwPmUpLGc9MTA0ODU3NSZhLl9fa0JpdENvbnZlcnNpb25JbnRzWzFdfDEwNDg1NzYsbz1hLl9fa0JpdENvbnZlcnNpb25JbnRzWzBdLHU9MjAscz1fJTMwLHI9MDtpZihzPHUpe3ZhciBkPXUtcztyPWQrMzIsdD1nPj4+ZCxnPWc8PDMyLWR8bz4+PmQsbzw8PTMyLWR9ZWxzZSBpZihzPT09dSlyPTMyLHQ9ZyxnPW8sbz0wO2Vsc2V7dmFyIGg9cy11O3I9MzItaCx0PWc8PGh8bz4+PjMyLWgsZz1vPDxoLG89MH1sLl9fc2V0RGlnaXQobi0xLHQpO2Zvcih2YXIgYj1uLTI7MDw9YjtiLS0pMDxyPyhyLT0zMCx0PWc+Pj4yLGc9Zzw8MzB8bz4+PjIsbzw8PTMwKTp0PTAsbC5fX3NldERpZ2l0KGIsdCk7cmV0dXJuIGwuX190cmltKCl9fSx7a2V5OlwiX19pc1doaXRlc3BhY2VcIix2YWx1ZTpmdW5jdGlvbihlKXtyZXR1cm4hISgxMz49ZSYmOTw9ZSl8fCgxNTk+PWU/MzI9PWU6MTMxMDcxPj1lPzE2MD09ZXx8NTc2MD09ZToxOTY2MDc+PWU/KGUmPTEzMTA3MSwxMD49ZXx8NDA9PWV8fDQxPT1lfHw0Nz09ZXx8OTU9PWV8fDQwOTY9PWUpOjY1Mjc5PT1lKX19LHtrZXk6XCJfX2Zyb21TdHJpbmdcIix2YWx1ZTpmdW5jdGlvbihlKXt2YXIgdD0xPGFyZ3VtZW50cy5sZW5ndGgmJnZvaWQgMCE9PWFyZ3VtZW50c1sxXT9hcmd1bWVudHNbMV06MCxpPTAsXz1lLmxlbmd0aCxuPTA7aWYobj09PV8pcmV0dXJuIGEuX196ZXJvKCk7Zm9yKHZhciBsPWUuY2hhckNvZGVBdChuKTthLl9faXNXaGl0ZXNwYWNlKGwpOyl7aWYoKytuPT09XylyZXR1cm4gYS5fX3plcm8oKTtsPWUuY2hhckNvZGVBdChuKX1pZig0Mz09PWwpe2lmKCsrbj09PV8pcmV0dXJuIG51bGw7bD1lLmNoYXJDb2RlQXQobiksaT0xfWVsc2UgaWYoNDU9PT1sKXtpZigrK249PT1fKXJldHVybiBudWxsO2w9ZS5jaGFyQ29kZUF0KG4pLGk9LTF9aWYoMD09PXQpe2lmKHQ9MTAsNDg9PT1sKXtpZigrK249PT1fKXJldHVybiBhLl9femVybygpO2lmKGw9ZS5jaGFyQ29kZUF0KG4pLDg4PT09bHx8MTIwPT09bCl7aWYodD0xNiwrK249PT1fKXJldHVybiBudWxsO2w9ZS5jaGFyQ29kZUF0KG4pfWVsc2UgaWYoNzk9PT1sfHwxMTE9PT1sKXtpZih0PTgsKytuPT09XylyZXR1cm4gbnVsbDtsPWUuY2hhckNvZGVBdChuKX1lbHNlIGlmKDY2PT09bHx8OTg9PT1sKXtpZih0PTIsKytuPT09XylyZXR1cm4gbnVsbDtsPWUuY2hhckNvZGVBdChuKX19fWVsc2UgaWYoMTY9PT10JiY0OD09PWwpe2lmKCsrbj09PV8pcmV0dXJuIGEuX196ZXJvKCk7aWYobD1lLmNoYXJDb2RlQXQobiksODg9PT1sfHwxMjA9PT1sKXtpZigrK249PT1fKXJldHVybiBudWxsO2w9ZS5jaGFyQ29kZUF0KG4pfX1pZigwIT09aSYmMTAhPT10KXJldHVybiBudWxsO2Zvcig7NDg9PT1sOyl7aWYoKytuPT09XylyZXR1cm4gYS5fX3plcm8oKTtsPWUuY2hhckNvZGVBdChuKX12YXIgZz1fLW4sbz1hLl9fa01heEJpdHNQZXJDaGFyW3RdLHU9YS5fX2tCaXRzUGVyQ2hhclRhYmxlTXVsdGlwbGllci0xO2lmKGc+MTA3Mzc0MTgyNC9vKXJldHVybiBudWxsO3ZhciBzPW8qZyt1Pj4+YS5fX2tCaXRzUGVyQ2hhclRhYmxlU2hpZnQscj1uZXcgYSgwfChzKzI5KS8zMCwhMSksaD0xMD50P3Q6MTAsYj0xMDx0P3QtMTA6MDtpZigwPT0odCZ0LTEpKXtvPj49YS5fX2tCaXRzUGVyQ2hhclRhYmxlU2hpZnQ7dmFyIGM9W10sdj1bXSx5PSExO2Rve2Zvcih2YXIgZixEPTAscD0wOzspe2lmKGY9dm9pZCAwLGwtNDg+Pj4wPGgpZj1sLTQ4O2Vsc2UgaWYoKDMyfGwpLTk3Pj4+MDxiKWY9KDMyfGwpLTg3O2Vsc2V7eT0hMDticmVha31pZihwKz1vLEQ9RDw8b3xmLCsrbj09PV8pe3k9ITA7YnJlYWt9aWYobD1lLmNoYXJDb2RlQXQobiksMzA8cCtvKWJyZWFrfWMucHVzaChEKSx2LnB1c2gocCl9d2hpbGUoIXkpO2EuX19maWxsRnJvbVBhcnRzKHIsYyx2KX1lbHNle3IuX19pbml0aWFsaXplRGlnaXRzKCk7dmFyIGs9ITEsQj0wO2Rve2Zvcih2YXIgUyxDPTAsST0xOzspe2lmKFM9dm9pZCAwLGwtNDg+Pj4wPGgpUz1sLTQ4O2Vsc2UgaWYoKDMyfGwpLTk3Pj4+MDxiKVM9KDMyfGwpLTg3O2Vsc2V7az0hMDticmVha312YXIgQT1JKnQ7aWYoMTA3Mzc0MTgyMzxBKWJyZWFrO2lmKEk9QSxDPUMqdCtTLEIrKywrK249PT1fKXtrPSEwO2JyZWFrfWw9ZS5jaGFyQ29kZUF0KG4pfXU9MzAqYS5fX2tCaXRzUGVyQ2hhclRhYmxlTXVsdGlwbGllci0xO3ZhciBtPTB8KG8qQit1Pj4+YS5fX2tCaXRzUGVyQ2hhclRhYmxlU2hpZnQpLzMwO3IuX19pbnBsYWNlTXVsdGlwbHlBZGQoSSxDLG0pfXdoaWxlKCFrKX1pZihuIT09Xyl7aWYoIWEuX19pc1doaXRlc3BhY2UobCkpcmV0dXJuIG51bGw7Zm9yKG4rKztuPF87bisrKWlmKGw9ZS5jaGFyQ29kZUF0KG4pLCFhLl9faXNXaGl0ZXNwYWNlKGwpKXJldHVybiBudWxsfXJldHVybiByLnNpZ249LTE9PT1pLHIuX190cmltKCl9fSx7a2V5OlwiX19maWxsRnJvbVBhcnRzXCIsdmFsdWU6ZnVuY3Rpb24oZSx0LF8pe2Zvcih2YXIgbj0wLGw9MCxnPTAsbz10Lmxlbmd0aC0xOzA8PW87by0tKXt2YXIgYT10W29dLHU9X1tvXTtsfD1hPDxnLGcrPXUsMzA9PT1nPyhlLl9fc2V0RGlnaXQobisrLGwpLGc9MCxsPTApOjMwPGcmJihlLl9fc2V0RGlnaXQobisrLDEwNzM3NDE4MjMmbCksZy09MzAsbD1hPj4+dS1nKX1pZigwIT09bCl7aWYobj49ZS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiaW1wbGVtZW50YXRpb24gYnVnXCIpO2UuX19zZXREaWdpdChuKyssbCl9Zm9yKDtuPGUubGVuZ3RoO24rKyllLl9fc2V0RGlnaXQobiwwKX19LHtrZXk6XCJfX3RvU3RyaW5nQmFzZVBvd2VyT2ZUd29cIix2YWx1ZTpmdW5jdGlvbihlLHQpe3ZhciBfPWUubGVuZ3RoLG49dC0xO249KDg1Jm4+Pj4xKSsoODUmbiksbj0oNTEmbj4+PjIpKyg1MSZuKSxuPSgxNSZuPj4+NCkrKDE1Jm4pO3ZhciBsPW4sZz10LTEsbz1lLl9fZGlnaXQoXy0xKSx1PWEuX19jbHozMChvKSxzPTB8KDMwKl8tdStsLTEpL2w7aWYoZS5zaWduJiZzKyssMjY4NDM1NDU2PHMpdGhyb3cgbmV3IEVycm9yKFwic3RyaW5nIHRvbyBsb25nXCIpO2Zvcih2YXIgcj1BcnJheShzKSxkPXMtMSxoPTAsYj0wLG09MDttPF8tMTttKyspe3ZhciBjPWUuX19kaWdpdChtKSx2PShofGM8PGIpJmc7cltkLS1dPWEuX19rQ29udmVyc2lvbkNoYXJzW3ZdO3ZhciB5PWwtYjtmb3IoaD1jPj4+eSxiPTMwLXk7Yj49bDspcltkLS1dPWEuX19rQ29udmVyc2lvbkNoYXJzW2gmZ10saD4+Pj1sLGItPWx9dmFyIGY9KGh8bzw8YikmZztmb3IocltkLS1dPWEuX19rQ29udmVyc2lvbkNoYXJzW2ZdLGg9bz4+PmwtYjswIT09aDspcltkLS1dPWEuX19rQ29udmVyc2lvbkNoYXJzW2gmZ10saD4+Pj1sO2lmKGUuc2lnbiYmKHJbZC0tXT1cIi1cIiksLTEhPT1kKXRocm93IG5ldyBFcnJvcihcImltcGxlbWVudGF0aW9uIGJ1Z1wiKTtyZXR1cm4gci5qb2luKFwiXCIpfX0se2tleTpcIl9fdG9TdHJpbmdHZW5lcmljXCIsdmFsdWU6ZnVuY3Rpb24oZSx0LF8pe3ZhciBuPWUubGVuZ3RoO2lmKDA9PT1uKXJldHVyblwiXCI7aWYoMT09PW4pe3ZhciBsPWUuX191bnNpZ25lZERpZ2l0KDApLnRvU3RyaW5nKHQpO3JldHVybiExPT09XyYmZS5zaWduJiYobD1cIi1cIitsKSxsfXZhciBnPTMwKm4tYS5fX2NsejMwKGUuX19kaWdpdChuLTEpKSxvPWEuX19rTWF4Qml0c1BlckNoYXJbdF0sdT1vLTEscz1nKmEuX19rQml0c1BlckNoYXJUYWJsZU11bHRpcGxpZXI7cys9dS0xLHM9MHxzL3U7dmFyIHIsZCxoPXMrMT4+MSxiPWEuZXhwb25lbnRpYXRlKGEuX19vbmVEaWdpdCh0LCExKSxhLl9fb25lRGlnaXQoaCwhMSkpLG09Yi5fX3Vuc2lnbmVkRGlnaXQoMCk7aWYoMT09PWIubGVuZ3RoJiYzMjc2Nz49bSl7cj1uZXcgYShlLmxlbmd0aCwhMSksci5fX2luaXRpYWxpemVEaWdpdHMoKTtmb3IodmFyIGMsdj0wLHk9MiplLmxlbmd0aC0xOzA8PXk7eS0tKWM9djw8MTV8ZS5fX2hhbGZEaWdpdCh5KSxyLl9fc2V0SGFsZkRpZ2l0KHksMHxjL20pLHY9MHxjJW07ZD12LnRvU3RyaW5nKHQpfWVsc2V7dmFyIGY9YS5fX2Fic29sdXRlRGl2TGFyZ2UoZSxiLCEwLCEwKTtyPWYucXVvdGllbnQ7dmFyIEQ9Zi5yZW1haW5kZXIuX190cmltKCk7ZD1hLl9fdG9TdHJpbmdHZW5lcmljKEQsdCwhMCl9ci5fX3RyaW0oKTtmb3IodmFyIHA9YS5fX3RvU3RyaW5nR2VuZXJpYyhyLHQsITApO2QubGVuZ3RoPGg7KWQ9XCIwXCIrZDtyZXR1cm4hMT09PV8mJmUuc2lnbiYmKHA9XCItXCIrcCkscCtkfX0se2tleTpcIl9fdW5lcXVhbFNpZ25cIix2YWx1ZTpmdW5jdGlvbihlKXtyZXR1cm4gZT8tMToxfX0se2tleTpcIl9fYWJzb2x1dGVHcmVhdGVyXCIsdmFsdWU6ZnVuY3Rpb24oZSl7cmV0dXJuIGU/LTE6MX19LHtrZXk6XCJfX2Fic29sdXRlTGVzc1wiLHZhbHVlOmZ1bmN0aW9uKGUpe3JldHVybiBlPzE6LTF9fSx7a2V5OlwiX19jb21wYXJlVG9CaWdJbnRcIix2YWx1ZTpmdW5jdGlvbihlLHQpe3ZhciBpPWUuc2lnbjtpZihpIT09dC5zaWduKXJldHVybiBhLl9fdW5lcXVhbFNpZ24oaSk7dmFyIF89YS5fX2Fic29sdXRlQ29tcGFyZShlLHQpO3JldHVybiAwPF8/YS5fX2Fic29sdXRlR3JlYXRlcihpKTowPl8/YS5fX2Fic29sdXRlTGVzcyhpKTowfX0se2tleTpcIl9fY29tcGFyZVRvTnVtYmVyXCIsdmFsdWU6ZnVuY3Rpb24oZSxpKXtpZihhLl9faXNPbmVEaWdpdEludChpKSl7dmFyIF89ZS5zaWduLG49MD5pO2lmKF8hPT1uKXJldHVybiBhLl9fdW5lcXVhbFNpZ24oXyk7aWYoMD09PWUubGVuZ3RoKXtpZihuKXRocm93IG5ldyBFcnJvcihcImltcGxlbWVudGF0aW9uIGJ1Z1wiKTtyZXR1cm4gMD09PWk/MDotMX1pZigxPGUubGVuZ3RoKXJldHVybiBhLl9fYWJzb2x1dGVHcmVhdGVyKF8pO3ZhciBsPXQoaSksZz1lLl9fdW5zaWduZWREaWdpdCgwKTtyZXR1cm4gZz5sP2EuX19hYnNvbHV0ZUdyZWF0ZXIoXyk6ZzxsP2EuX19hYnNvbHV0ZUxlc3MoXyk6MH1yZXR1cm4gYS5fX2NvbXBhcmVUb0RvdWJsZShlLGkpfX0se2tleTpcIl9fY29tcGFyZVRvRG91YmxlXCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXtpZih0IT09dClyZXR1cm4gdDtpZih0PT09MS8wKXJldHVybi0xO2lmKHQ9PT0tSW5maW5pdHkpcmV0dXJuIDE7dmFyIGk9ZS5zaWduO2lmKGkhPT0wPnQpcmV0dXJuIGEuX191bmVxdWFsU2lnbihpKTtpZigwPT09dCl0aHJvdyBuZXcgRXJyb3IoXCJpbXBsZW1lbnRhdGlvbiBidWc6IHNob3VsZCBiZSBoYW5kbGVkIGVsc2V3aGVyZVwiKTtpZigwPT09ZS5sZW5ndGgpcmV0dXJuLTE7YS5fX2tCaXRDb252ZXJzaW9uRG91YmxlWzBdPXQ7dmFyIF89MjA0NyZhLl9fa0JpdENvbnZlcnNpb25JbnRzWzFdPj4+MjA7aWYoMjA0Nz09Xyl0aHJvdyBuZXcgRXJyb3IoXCJpbXBsZW1lbnRhdGlvbiBidWc6IGhhbmRsZWQgZWxzZXdoZXJlXCIpO3ZhciBuPV8tMTAyMztpZigwPm4pcmV0dXJuIGEuX19hYnNvbHV0ZUdyZWF0ZXIoaSk7dmFyIGw9ZS5sZW5ndGgsZz1lLl9fZGlnaXQobC0xKSxvPWEuX19jbHozMChnKSx1PTMwKmwtbyxzPW4rMTtpZih1PHMpcmV0dXJuIGEuX19hYnNvbHV0ZUxlc3MoaSk7aWYodT5zKXJldHVybiBhLl9fYWJzb2x1dGVHcmVhdGVyKGkpO3ZhciByPTEwNDg1NzZ8MTA0ODU3NSZhLl9fa0JpdENvbnZlcnNpb25JbnRzWzFdLGQ9YS5fX2tCaXRDb252ZXJzaW9uSW50c1swXSxoPTIwLGI9MjktbztpZihiIT09KDB8KHUtMSklMzApKXRocm93IG5ldyBFcnJvcihcImltcGxlbWVudGF0aW9uIGJ1Z1wiKTt2YXIgbSxjPTA7aWYoYjxoKXt2YXIgdj1oLWI7Yz12KzMyLG09cj4+PnYscj1yPDwzMi12fGQ+Pj52LGQ8PD0zMi12fWVsc2UgaWYoYj09PWgpYz0zMixtPXIscj1kLGQ9MDtlbHNle3ZhciB5PWItaDtjPTMyLXksbT1yPDx5fGQ+Pj4zMi15LHI9ZDw8eSxkPTB9aWYoZz4+Pj0wLG0+Pj49MCxnPm0pcmV0dXJuIGEuX19hYnNvbHV0ZUdyZWF0ZXIoaSk7aWYoZzxtKXJldHVybiBhLl9fYWJzb2x1dGVMZXNzKGkpO2Zvcih2YXIgZj1sLTI7MDw9ZjtmLS0pezA8Yz8oYy09MzAsbT1yPj4+MixyPXI8PDMwfGQ+Pj4yLGQ8PD0zMCk6bT0wO3ZhciBEPWUuX191bnNpZ25lZERpZ2l0KGYpO2lmKEQ+bSlyZXR1cm4gYS5fX2Fic29sdXRlR3JlYXRlcihpKTtpZihEPG0pcmV0dXJuIGEuX19hYnNvbHV0ZUxlc3MoaSl9aWYoMCE9PXJ8fDAhPT1kKXtpZigwPT09Yyl0aHJvdyBuZXcgRXJyb3IoXCJpbXBsZW1lbnRhdGlvbiBidWdcIik7cmV0dXJuIGEuX19hYnNvbHV0ZUxlc3MoaSl9cmV0dXJuIDB9fSx7a2V5OlwiX19lcXVhbFRvTnVtYmVyXCIsdmFsdWU6ZnVuY3Rpb24oZSxpKXtyZXR1cm4gYS5fX2lzT25lRGlnaXRJbnQoaSk/MD09PWk/MD09PWUubGVuZ3RoOjE9PT1lLmxlbmd0aCYmZS5zaWduPT09MD5pJiZlLl9fdW5zaWduZWREaWdpdCgwKT09PXQoaSk6MD09PWEuX19jb21wYXJlVG9Eb3VibGUoZSxpKX19LHtrZXk6XCJfX2NvbXBhcmlzb25SZXN1bHRUb0Jvb2xcIix2YWx1ZTpmdW5jdGlvbihlLHQpe3JldHVybiAwPT09dD8wPmU6MT09PXQ/MD49ZToyPT09dD8wPGU6Mz09PXQ/MDw9ZTp2b2lkIDB9fSx7a2V5OlwiX19jb21wYXJlXCIsdmFsdWU6ZnVuY3Rpb24oZSx0LGkpe2lmKGU9YS5fX3RvUHJpbWl0aXZlKGUpLHQ9YS5fX3RvUHJpbWl0aXZlKHQpLFwic3RyaW5nXCI9PXR5cGVvZiBlJiZcInN0cmluZ1wiPT10eXBlb2YgdClzd2l0Y2goaSl7Y2FzZSAwOnJldHVybiBlPHQ7Y2FzZSAxOnJldHVybiBlPD10O2Nhc2UgMjpyZXR1cm4gZT50O2Nhc2UgMzpyZXR1cm4gZT49dDt9aWYoYS5fX2lzQmlnSW50KGUpJiZcInN0cmluZ1wiPT10eXBlb2YgdClyZXR1cm4gdD1hLl9fZnJvbVN0cmluZyh0KSxudWxsIT09dCYmYS5fX2NvbXBhcmlzb25SZXN1bHRUb0Jvb2woYS5fX2NvbXBhcmVUb0JpZ0ludChlLHQpLGkpO2lmKFwic3RyaW5nXCI9PXR5cGVvZiBlJiZhLl9faXNCaWdJbnQodCkpcmV0dXJuIGU9YS5fX2Zyb21TdHJpbmcoZSksbnVsbCE9PWUmJmEuX19jb21wYXJpc29uUmVzdWx0VG9Cb29sKGEuX19jb21wYXJlVG9CaWdJbnQoZSx0KSxpKTtpZihlPWEuX190b051bWVyaWMoZSksdD1hLl9fdG9OdW1lcmljKHQpLGEuX19pc0JpZ0ludChlKSl7aWYoYS5fX2lzQmlnSW50KHQpKXJldHVybiBhLl9fY29tcGFyaXNvblJlc3VsdFRvQm9vbChhLl9fY29tcGFyZVRvQmlnSW50KGUsdCksaSk7aWYoXCJudW1iZXJcIiE9dHlwZW9mIHQpdGhyb3cgbmV3IEVycm9yKFwiaW1wbGVtZW50YXRpb24gYnVnXCIpO3JldHVybiBhLl9fY29tcGFyaXNvblJlc3VsdFRvQm9vbChhLl9fY29tcGFyZVRvTnVtYmVyKGUsdCksaSl9aWYoXCJudW1iZXJcIiE9dHlwZW9mIGUpdGhyb3cgbmV3IEVycm9yKFwiaW1wbGVtZW50YXRpb24gYnVnXCIpO2lmKGEuX19pc0JpZ0ludCh0KSlyZXR1cm4gYS5fX2NvbXBhcmlzb25SZXN1bHRUb0Jvb2woYS5fX2NvbXBhcmVUb051bWJlcih0LGUpLDJeaSk7aWYoXCJudW1iZXJcIiE9dHlwZW9mIHQpdGhyb3cgbmV3IEVycm9yKFwiaW1wbGVtZW50YXRpb24gYnVnXCIpO3JldHVybiAwPT09aT9lPHQ6MT09PWk/ZTw9dDoyPT09aT9lPnQ6Mz09PWk/ZT49dDp2b2lkIDB9fSx7a2V5OlwiX19hYnNvbHV0ZUFkZFwiLHZhbHVlOmZ1bmN0aW9uKGUsdCxfKXtpZihlLmxlbmd0aDx0Lmxlbmd0aClyZXR1cm4gYS5fX2Fic29sdXRlQWRkKHQsZSxfKTtpZigwPT09ZS5sZW5ndGgpcmV0dXJuIGU7aWYoMD09PXQubGVuZ3RoKXJldHVybiBlLnNpZ249PT1fP2U6YS51bmFyeU1pbnVzKGUpO3ZhciBuPWUubGVuZ3RoOygwPT09ZS5fX2Nsem1zZCgpfHx0Lmxlbmd0aD09PWUubGVuZ3RoJiYwPT09dC5fX2Nsem1zZCgpKSYmbisrO2Zvcih2YXIgbCxnPW5ldyBhKG4sXyksbz0wLHU9MDt1PHQubGVuZ3RoO3UrKylsPWUuX19kaWdpdCh1KSt0Ll9fZGlnaXQodSkrbyxvPWw+Pj4zMCxnLl9fc2V0RGlnaXQodSwxMDczNzQxODIzJmwpO2Zvcig7dTxlLmxlbmd0aDt1Kyspe3ZhciBzPWUuX19kaWdpdCh1KStvO289cz4+PjMwLGcuX19zZXREaWdpdCh1LDEwNzM3NDE4MjMmcyl9cmV0dXJuIHU8Zy5sZW5ndGgmJmcuX19zZXREaWdpdCh1LG8pLGcuX190cmltKCl9fSx7a2V5OlwiX19hYnNvbHV0ZVN1YlwiLHZhbHVlOmZ1bmN0aW9uKGUsdCxfKXtpZigwPT09ZS5sZW5ndGgpcmV0dXJuIGU7aWYoMD09PXQubGVuZ3RoKXJldHVybiBlLnNpZ249PT1fP2U6YS51bmFyeU1pbnVzKGUpO2Zvcih2YXIgbixsPW5ldyBhKGUubGVuZ3RoLF8pLGc9MCxvPTA7bzx0Lmxlbmd0aDtvKyspbj1lLl9fZGlnaXQobyktdC5fX2RpZ2l0KG8pLWcsZz0xJm4+Pj4zMCxsLl9fc2V0RGlnaXQobywxMDczNzQxODIzJm4pO2Zvcig7bzxlLmxlbmd0aDtvKyspe3ZhciB1PWUuX19kaWdpdChvKS1nO2c9MSZ1Pj4+MzAsbC5fX3NldERpZ2l0KG8sMTA3Mzc0MTgyMyZ1KX1yZXR1cm4gbC5fX3RyaW0oKX19LHtrZXk6XCJfX2Fic29sdXRlQWRkT25lXCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXt2YXIgXz0yPGFyZ3VtZW50cy5sZW5ndGgmJnZvaWQgMCE9PWFyZ3VtZW50c1syXT9hcmd1bWVudHNbMl06bnVsbCxuPWUubGVuZ3RoO251bGw9PT1fP189bmV3IGEobix0KTpfLnNpZ249dDtmb3IodmFyIGwsZz0xLG89MDtvPG47bysrKWw9ZS5fX2RpZ2l0KG8pK2csZz1sPj4+MzAsXy5fX3NldERpZ2l0KG8sMTA3Mzc0MTgyMyZsKTtyZXR1cm4gMCE9PWcmJl8uX19zZXREaWdpdEdyb3cobiwxKSxffX0se2tleTpcIl9fYWJzb2x1dGVTdWJPbmVcIix2YWx1ZTpmdW5jdGlvbihlLHQpe3ZhciBfPWUubGVuZ3RoO3Q9dHx8Xztmb3IodmFyIG4sbD1uZXcgYSh0LCExKSxnPTEsbz0wO288XztvKyspbj1lLl9fZGlnaXQobyktZyxnPTEmbj4+PjMwLGwuX19zZXREaWdpdChvLDEwNzM3NDE4MjMmbik7aWYoMCE9PWcpdGhyb3cgbmV3IEVycm9yKFwiaW1wbGVtZW50YXRpb24gYnVnXCIpO2Zvcih2YXIgdT1fO3U8dDt1KyspbC5fX3NldERpZ2l0KHUsMCk7cmV0dXJuIGx9fSx7a2V5OlwiX19hYnNvbHV0ZUFuZFwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7dmFyIF89Mjxhcmd1bWVudHMubGVuZ3RoJiZ2b2lkIDAhPT1hcmd1bWVudHNbMl0/YXJndW1lbnRzWzJdOm51bGwsbj1lLmxlbmd0aCxsPXQubGVuZ3RoLGc9bDtpZihuPGwpe2c9bjt2YXIgbz1lLHU9bjtlPXQsbj1sLHQ9byxsPXV9dmFyIHM9ZztudWxsPT09Xz9fPW5ldyBhKHMsITEpOnM9Xy5sZW5ndGg7Zm9yKHZhciByPTA7cjxnO3IrKylfLl9fc2V0RGlnaXQocixlLl9fZGlnaXQocikmdC5fX2RpZ2l0KHIpKTtmb3IoO3I8cztyKyspXy5fX3NldERpZ2l0KHIsMCk7cmV0dXJuIF99fSx7a2V5OlwiX19hYnNvbHV0ZUFuZE5vdFwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7dmFyIF89Mjxhcmd1bWVudHMubGVuZ3RoJiZ2b2lkIDAhPT1hcmd1bWVudHNbMl0/YXJndW1lbnRzWzJdOm51bGwsbj1lLmxlbmd0aCxsPXQubGVuZ3RoLGc9bDtuPGwmJihnPW4pO3ZhciBvPW47bnVsbD09PV8/Xz1uZXcgYShvLCExKTpvPV8ubGVuZ3RoO2Zvcih2YXIgdT0wO3U8Zzt1KyspXy5fX3NldERpZ2l0KHUsZS5fX2RpZ2l0KHUpJn50Ll9fZGlnaXQodSkpO2Zvcig7dTxuO3UrKylfLl9fc2V0RGlnaXQodSxlLl9fZGlnaXQodSkpO2Zvcig7dTxvO3UrKylfLl9fc2V0RGlnaXQodSwwKTtyZXR1cm4gX319LHtrZXk6XCJfX2Fic29sdXRlT3JcIix2YWx1ZTpmdW5jdGlvbihlLHQpe3ZhciBfPTI8YXJndW1lbnRzLmxlbmd0aCYmdm9pZCAwIT09YXJndW1lbnRzWzJdP2FyZ3VtZW50c1syXTpudWxsLG49ZS5sZW5ndGgsbD10Lmxlbmd0aCxnPWw7aWYobjxsKXtnPW47dmFyIG89ZSx1PW47ZT10LG49bCx0PW8sbD11fXZhciBzPW47bnVsbD09PV8/Xz1uZXcgYShzLCExKTpzPV8ubGVuZ3RoO2Zvcih2YXIgcj0wO3I8ZztyKyspXy5fX3NldERpZ2l0KHIsZS5fX2RpZ2l0KHIpfHQuX19kaWdpdChyKSk7Zm9yKDtyPG47cisrKV8uX19zZXREaWdpdChyLGUuX19kaWdpdChyKSk7Zm9yKDtyPHM7cisrKV8uX19zZXREaWdpdChyLDApO3JldHVybiBffX0se2tleTpcIl9fYWJzb2x1dGVYb3JcIix2YWx1ZTpmdW5jdGlvbihlLHQpe3ZhciBfPTI8YXJndW1lbnRzLmxlbmd0aCYmdm9pZCAwIT09YXJndW1lbnRzWzJdP2FyZ3VtZW50c1syXTpudWxsLG49ZS5sZW5ndGgsbD10Lmxlbmd0aCxnPWw7aWYobjxsKXtnPW47dmFyIG89ZSx1PW47ZT10LG49bCx0PW8sbD11fXZhciBzPW47bnVsbD09PV8/Xz1uZXcgYShzLCExKTpzPV8ubGVuZ3RoO2Zvcih2YXIgcj0wO3I8ZztyKyspXy5fX3NldERpZ2l0KHIsZS5fX2RpZ2l0KHIpXnQuX19kaWdpdChyKSk7Zm9yKDtyPG47cisrKV8uX19zZXREaWdpdChyLGUuX19kaWdpdChyKSk7Zm9yKDtyPHM7cisrKV8uX19zZXREaWdpdChyLDApO3JldHVybiBffX0se2tleTpcIl9fYWJzb2x1dGVDb21wYXJlXCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXt2YXIgXz1lLmxlbmd0aC10Lmxlbmd0aDtpZigwIT1fKXJldHVybiBfO2Zvcih2YXIgbj1lLmxlbmd0aC0xOzA8PW4mJmUuX19kaWdpdChuKT09PXQuX19kaWdpdChuKTspbi0tO3JldHVybiAwPm4/MDplLl9fdW5zaWduZWREaWdpdChuKT50Ll9fdW5zaWduZWREaWdpdChuKT8xOi0xfX0se2tleTpcIl9fbXVsdGlwbHlBY2N1bXVsYXRlXCIsdmFsdWU6ZnVuY3Rpb24oZSx0LF8sbil7aWYoMCE9PXQpe2Zvcih2YXIgbD0zMjc2NyZ0LGc9dD4+PjE1LG89MCx1PTAscz0wO3M8ZS5sZW5ndGg7cysrLG4rKyl7dmFyIHI9Xy5fX2RpZ2l0KG4pLGQ9ZS5fX2RpZ2l0KHMpLGg9MzI3NjcmZCxiPWQ+Pj4xNSxtPWEuX19pbXVsKGgsbCksYz1hLl9faW11bChoLGcpLHY9YS5fX2ltdWwoYixsKSx5PWEuX19pbXVsKGIsZyk7cis9dSttK28sbz1yPj4+MzAsciY9MTA3Mzc0MTgyMyxyKz0oKDMyNzY3JmMpPDwxNSkrKCgzMjc2NyZ2KTw8MTUpLG8rPXI+Pj4zMCx1PXkrKGM+Pj4xNSkrKHY+Pj4xNSksXy5fX3NldERpZ2l0KG4sMTA3Mzc0MTgyMyZyKX1mb3IoOzAhPT1vfHwwIT09dTtuKyspe3ZhciBmPV8uX19kaWdpdChuKTtmKz1vK3UsdT0wLG89Zj4+PjMwLF8uX19zZXREaWdpdChuLDEwNzM3NDE4MjMmZil9fX19LHtrZXk6XCJfX2ludGVybmFsTXVsdGlwbHlBZGRcIix2YWx1ZTpmdW5jdGlvbihlLHQsXyxsLGcpe2Zvcih2YXIgbz1fLHU9MCxzPTA7czxsO3MrKyl7dmFyIGQ9ZS5fX2RpZ2l0KHMpLGg9YS5fX2ltdWwoMzI3NjcmZCx0KSxiPWEuX19pbXVsKGQ+Pj4xNSx0KSxtPWgrKCgzMjc2NyZiKTw8MTUpK3UrbztvPW0+Pj4zMCx1PWI+Pj4xNSxnLl9fc2V0RGlnaXQocywxMDczNzQxODIzJm0pfWlmKGcubGVuZ3RoPmwpZm9yKGcuX19zZXREaWdpdChsKyssbyt1KTtsPGcubGVuZ3RoOylnLl9fc2V0RGlnaXQobCsrLDApO2Vsc2UgaWYoMCE9PW8rdSl0aHJvdyBuZXcgRXJyb3IoXCJpbXBsZW1lbnRhdGlvbiBidWdcIil9fSx7a2V5OlwiX19hYnNvbHV0ZURpdlNtYWxsXCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXt2YXIgXz0yPGFyZ3VtZW50cy5sZW5ndGgmJnZvaWQgMCE9PWFyZ3VtZW50c1syXT9hcmd1bWVudHNbMl06bnVsbDtudWxsPT09XyYmKF89bmV3IGEoZS5sZW5ndGgsITEpKTtmb3IodmFyIG49MCxsPTIqZS5sZW5ndGgtMTswPD1sO2wtPTIpe3ZhciBnPShuPDwxNXxlLl9faGFsZkRpZ2l0KGwpKT4+PjAsbz0wfGcvdDtuPTB8ZyV0LGc9KG48PDE1fGUuX19oYWxmRGlnaXQobC0xKSk+Pj4wO3ZhciB1PTB8Zy90O249MHxnJXQsXy5fX3NldERpZ2l0KGw+Pj4xLG88PDE1fHUpfXJldHVybiBffX0se2tleTpcIl9fYWJzb2x1dGVNb2RTbWFsbFwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7Zm9yKHZhciBfLG49MCxsPTIqZS5sZW5ndGgtMTswPD1sO2wtLSlfPShuPDwxNXxlLl9faGFsZkRpZ2l0KGwpKT4+PjAsbj0wfF8ldDtyZXR1cm4gbn19LHtrZXk6XCJfX2Fic29sdXRlRGl2TGFyZ2VcIix2YWx1ZTpmdW5jdGlvbihlLHQsaSxfKXt2YXIgbD10Ll9faGFsZkRpZ2l0TGVuZ3RoKCksbj10Lmxlbmd0aCxnPWUuX19oYWxmRGlnaXRMZW5ndGgoKS1sLG89bnVsbDtpJiYobz1uZXcgYShnKzI+Pj4xLCExKSxvLl9faW5pdGlhbGl6ZURpZ2l0cygpKTt2YXIgcz1uZXcgYShsKzI+Pj4xLCExKTtzLl9faW5pdGlhbGl6ZURpZ2l0cygpO3ZhciByPWEuX19jbHoxNSh0Ll9faGFsZkRpZ2l0KGwtMSkpOzA8ciYmKHQ9YS5fX3NwZWNpYWxMZWZ0U2hpZnQodCxyLDApKTtmb3IodmFyIGQ9YS5fX3NwZWNpYWxMZWZ0U2hpZnQoZSxyLDEpLHU9dC5fX2hhbGZEaWdpdChsLTEpLGg9MCxiPWc7MDw9YjtiLS0pe3ZhciBtPTMyNzY3LHY9ZC5fX2hhbGZEaWdpdChiK2wpO2lmKHYhPT11KXt2YXIgeT0odjw8MTV8ZC5fX2hhbGZEaWdpdChiK2wtMSkpPj4+MDttPTB8eS91O2Zvcih2YXIgZj0wfHkldSxEPXQuX19oYWxmRGlnaXQobC0yKSxwPWQuX19oYWxmRGlnaXQoYitsLTIpO2EuX19pbXVsKG0sRCk+Pj4wPihmPDwxNnxwKT4+PjAmJihtLS0sZis9dSwhKDMyNzY3PGYpKTspO31hLl9faW50ZXJuYWxNdWx0aXBseUFkZCh0LG0sMCxuLHMpO3ZhciBrPWQuX19pbnBsYWNlU3ViKHMsYixsKzEpOzAhPT1rJiYoaz1kLl9faW5wbGFjZUFkZCh0LGIsbCksZC5fX3NldEhhbGZEaWdpdChiK2wsMzI3NjcmZC5fX2hhbGZEaWdpdChiK2wpK2spLG0tLSksaSYmKDEmYj9oPW08PDE1Om8uX19zZXREaWdpdChiPj4+MSxofG0pKX1pZihfKXJldHVybiBkLl9faW5wbGFjZVJpZ2h0U2hpZnQociksaT97cXVvdGllbnQ6byxyZW1haW5kZXI6ZH06ZDtpZihpKXJldHVybiBvO3Rocm93IG5ldyBFcnJvcihcInVucmVhY2hhYmxlXCIpfX0se2tleTpcIl9fY2x6MTVcIix2YWx1ZTpmdW5jdGlvbihlKXtyZXR1cm4gYS5fX2NsejMwKGUpLTE1fX0se2tleTpcIl9fc3BlY2lhbExlZnRTaGlmdFwiLHZhbHVlOmZ1bmN0aW9uKGUsdCxfKXt2YXIgbD1lLmxlbmd0aCxuPW5ldyBhKGwrXywhMSk7aWYoMD09PXQpe2Zvcih2YXIgZz0wO2c8bDtnKyspbi5fX3NldERpZ2l0KGcsZS5fX2RpZ2l0KGcpKTtyZXR1cm4gMDxfJiZuLl9fc2V0RGlnaXQobCwwKSxufWZvcih2YXIgbyx1PTAscz0wO3M8bDtzKyspbz1lLl9fZGlnaXQocyksbi5fX3NldERpZ2l0KHMsMTA3Mzc0MTgyMyZvPDx0fHUpLHU9bz4+PjMwLXQ7cmV0dXJuIDA8XyYmbi5fX3NldERpZ2l0KGwsdSksbn19LHtrZXk6XCJfX2xlZnRTaGlmdEJ5QWJzb2x1dGVcIix2YWx1ZTpmdW5jdGlvbihlLHQpe3ZhciBfPWEuX190b1NoaWZ0QW1vdW50KHQpO2lmKDA+Xyl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkJpZ0ludCB0b28gYmlnXCIpO3ZhciBuPTB8Xy8zMCxsPV8lMzAsZz1lLmxlbmd0aCxvPTAhPT1sJiYwIT1lLl9fZGlnaXQoZy0xKT4+PjMwLWwsdT1nK24rKG8/MTowKSxzPW5ldyBhKHUsZS5zaWduKTtpZigwPT09bCl7Zm9yKHZhciByPTA7cjxuO3IrKylzLl9fc2V0RGlnaXQociwwKTtmb3IoO3I8dTtyKyspcy5fX3NldERpZ2l0KHIsZS5fX2RpZ2l0KHItbikpfWVsc2V7Zm9yKHZhciBoPTAsYj0wO2I8bjtiKyspcy5fX3NldERpZ2l0KGIsMCk7Zm9yKHZhciBtLGM9MDtjPGc7YysrKW09ZS5fX2RpZ2l0KGMpLHMuX19zZXREaWdpdChjK24sMTA3Mzc0MTgyMyZtPDxsfGgpLGg9bT4+PjMwLWw7aWYobylzLl9fc2V0RGlnaXQoZytuLGgpO2Vsc2UgaWYoMCE9PWgpdGhyb3cgbmV3IEVycm9yKFwiaW1wbGVtZW50YXRpb24gYnVnXCIpfXJldHVybiBzLl9fdHJpbSgpfX0se2tleTpcIl9fcmlnaHRTaGlmdEJ5QWJzb2x1dGVcIix2YWx1ZTpmdW5jdGlvbihlLHQpe3ZhciBfPWUubGVuZ3RoLG49ZS5zaWduLGw9YS5fX3RvU2hpZnRBbW91bnQodCk7aWYoMD5sKXJldHVybiBhLl9fcmlnaHRTaGlmdEJ5TWF4aW11bShuKTt2YXIgZz0wfGwvMzAsbz1sJTMwLHU9Xy1nO2lmKDA+PXUpcmV0dXJuIGEuX19yaWdodFNoaWZ0QnlNYXhpbXVtKG4pO3ZhciBzPSExO2lmKG4pe2lmKDAhPShlLl9fZGlnaXQoZykmKDE8PG8pLTEpKXM9ITA7ZWxzZSBmb3IodmFyIHI9MDtyPGc7cisrKWlmKDAhPT1lLl9fZGlnaXQocikpe3M9ITA7YnJlYWt9fWlmKHMmJjA9PT1vKXt2YXIgaD1lLl9fZGlnaXQoXy0xKTswPT1+aCYmdSsrfXZhciBiPW5ldyBhKHUsbik7aWYoMD09PW8pe2IuX19zZXREaWdpdCh1LTEsMCk7Zm9yKHZhciBtPWc7bTxfO20rKyliLl9fc2V0RGlnaXQobS1nLGUuX19kaWdpdChtKSl9ZWxzZXtmb3IodmFyIGMsdj1lLl9fZGlnaXQoZyk+Pj5vLHk9Xy1nLTEsZj0wO2Y8eTtmKyspYz1lLl9fZGlnaXQoZitnKzEpLGIuX19zZXREaWdpdChmLDEwNzM3NDE4MjMmYzw8MzAtb3x2KSx2PWM+Pj5vO2IuX19zZXREaWdpdCh5LHYpfXJldHVybiBzJiYoYj1hLl9fYWJzb2x1dGVBZGRPbmUoYiwhMCxiKSksYi5fX3RyaW0oKX19LHtrZXk6XCJfX3JpZ2h0U2hpZnRCeU1heGltdW1cIix2YWx1ZTpmdW5jdGlvbihlKXtyZXR1cm4gZT9hLl9fb25lRGlnaXQoMSwhMCk6YS5fX3plcm8oKX19LHtrZXk6XCJfX3RvU2hpZnRBbW91bnRcIix2YWx1ZTpmdW5jdGlvbihlKXtpZigxPGUubGVuZ3RoKXJldHVybi0xO3ZhciB0PWUuX191bnNpZ25lZERpZ2l0KDApO3JldHVybiB0PmEuX19rTWF4TGVuZ3RoQml0cz8tMTp0fX0se2tleTpcIl9fdG9QcmltaXRpdmVcIix2YWx1ZTpmdW5jdGlvbihlKXt2YXIgdD0xPGFyZ3VtZW50cy5sZW5ndGgmJnZvaWQgMCE9PWFyZ3VtZW50c1sxXT9hcmd1bWVudHNbMV06XCJkZWZhdWx0XCI7aWYoXCJvYmplY3RcIiE9PWkoZSkpcmV0dXJuIGU7aWYoZS5jb25zdHJ1Y3Rvcj09PWEpcmV0dXJuIGU7aWYoXCJ1bmRlZmluZWRcIiE9dHlwZW9mIFN5bWJvbCYmXCJzeW1ib2xcIj09PWkoU3ltYm9sLnRvUHJpbWl0aXZlKSl7dmFyIF89ZVtTeW1ib2wudG9QcmltaXRpdmVdO2lmKF8pe3ZhciBuPV8odCk7aWYoXCJvYmplY3RcIiE9PWkobikpcmV0dXJuIG47dGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjb252ZXJ0IG9iamVjdCB0byBwcmltaXRpdmUgdmFsdWVcIil9fXZhciBsPWUudmFsdWVPZjtpZihsKXt2YXIgZz1sLmNhbGwoZSk7aWYoXCJvYmplY3RcIiE9PWkoZykpcmV0dXJuIGd9dmFyIG89ZS50b1N0cmluZztpZihvKXt2YXIgdT1vLmNhbGwoZSk7aWYoXCJvYmplY3RcIiE9PWkodSkpcmV0dXJuIHV9dGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjb252ZXJ0IG9iamVjdCB0byBwcmltaXRpdmUgdmFsdWVcIil9fSx7a2V5OlwiX190b051bWVyaWNcIix2YWx1ZTpmdW5jdGlvbihlKXtyZXR1cm4gYS5fX2lzQmlnSW50KGUpP2U6K2V9fSx7a2V5OlwiX19pc0JpZ0ludFwiLHZhbHVlOmZ1bmN0aW9uKGUpe3JldHVyblwib2JqZWN0XCI9PT1pKGUpJiZudWxsIT09ZSYmZS5jb25zdHJ1Y3Rvcj09PWF9fSx7a2V5OlwiX190cnVuY2F0ZVRvTkJpdHNcIix2YWx1ZTpmdW5jdGlvbihlLHQpe2Zvcih2YXIgXz0wfChlKzI5KS8zMCxuPW5ldyBhKF8sdC5zaWduKSxsPV8tMSxnPTA7ZzxsO2crKyluLl9fc2V0RGlnaXQoZyx0Ll9fZGlnaXQoZykpO3ZhciBvPXQuX19kaWdpdChsKTtpZigwIT1lJTMwKXt2YXIgdT0zMi1lJTMwO289bzw8dT4+PnV9cmV0dXJuIG4uX19zZXREaWdpdChsLG8pLG4uX190cmltKCl9fSx7a2V5OlwiX190cnVuY2F0ZUFuZFN1YkZyb21Qb3dlck9mVHdvXCIsdmFsdWU6ZnVuY3Rpb24oZSx0LF8pe2Zvcih2YXIgbj1NYXRoLm1pbixsLGc9MHwoZSsyOSkvMzAsbz1uZXcgYShnLF8pLHU9MCxzPWctMSxkPTAsaD1uKHMsdC5sZW5ndGgpO3U8aDt1KyspbD0wLXQuX19kaWdpdCh1KS1kLGQ9MSZsPj4+MzAsby5fX3NldERpZ2l0KHUsMTA3Mzc0MTgyMyZsKTtmb3IoO3U8czt1Kyspby5fX3NldERpZ2l0KHUsMHwxMDczNzQxODIzJi1kKTt2YXIgYixtPXM8dC5sZW5ndGg/dC5fX2RpZ2l0KHMpOjAsYz1lJTMwO2lmKDA9PT1jKWI9MC1tLWQsYiY9MTA3Mzc0MTgyMztlbHNle3ZhciB2PTMyLWM7bT1tPDx2Pj4+djt2YXIgeT0xPDwzMi12O2I9eS1tLWQsYiY9eS0xfXJldHVybiBvLl9fc2V0RGlnaXQocyxiKSxvLl9fdHJpbSgpfX0se2tleTpcIl9fZGlnaXRQb3dcIix2YWx1ZTpmdW5jdGlvbihlLHQpe2Zvcih2YXIgaT0xOzA8dDspMSZ0JiYoaSo9ZSksdD4+Pj0xLGUqPWU7cmV0dXJuIGl9fSx7a2V5OlwiX19pc09uZURpZ2l0SW50XCIsdmFsdWU6ZnVuY3Rpb24oZSl7cmV0dXJuKDEwNzM3NDE4MjMmZSk9PT1lfX1dKSxhfShoKEFycmF5KSk7cmV0dXJuIFMuX19rTWF4TGVuZ3RoPTMzNTU0NDMyLFMuX19rTWF4TGVuZ3RoQml0cz1TLl9fa01heExlbmd0aDw8NSxTLl9fa01heEJpdHNQZXJDaGFyPVswLDAsMzIsNTEsNjQsNzUsODMsOTAsOTYsMTAyLDEwNywxMTEsMTE1LDExOSwxMjIsMTI2LDEyOCwxMzEsMTM0LDEzNiwxMzksMTQxLDE0MywxNDUsMTQ3LDE0OSwxNTEsMTUzLDE1NCwxNTYsMTU4LDE1OSwxNjAsMTYyLDE2MywxNjUsMTY2XSxTLl9fa0JpdHNQZXJDaGFyVGFibGVTaGlmdD01LFMuX19rQml0c1BlckNoYXJUYWJsZU11bHRpcGxpZXI9MTw8Uy5fX2tCaXRzUGVyQ2hhclRhYmxlU2hpZnQsUy5fX2tDb252ZXJzaW9uQ2hhcnM9W1wiMFwiLFwiMVwiLFwiMlwiLFwiM1wiLFwiNFwiLFwiNVwiLFwiNlwiLFwiN1wiLFwiOFwiLFwiOVwiLFwiYVwiLFwiYlwiLFwiY1wiLFwiZFwiLFwiZVwiLFwiZlwiLFwiZ1wiLFwiaFwiLFwiaVwiLFwialwiLFwia1wiLFwibFwiLFwibVwiLFwiblwiLFwib1wiLFwicFwiLFwicVwiLFwiclwiLFwic1wiLFwidFwiLFwidVwiLFwidlwiLFwid1wiLFwieFwiLFwieVwiLFwielwiXSxTLl9fa0JpdENvbnZlcnNpb25CdWZmZXI9bmV3IEFycmF5QnVmZmVyKDgpLFMuX19rQml0Q29udmVyc2lvbkRvdWJsZT1uZXcgRmxvYXQ2NEFycmF5KFMuX19rQml0Q29udmVyc2lvbkJ1ZmZlciksUy5fX2tCaXRDb252ZXJzaW9uSW50cz1uZXcgSW50MzJBcnJheShTLl9fa0JpdENvbnZlcnNpb25CdWZmZXIpLFMuX19jbHozMD10P2Z1bmN0aW9uKGUpe3JldHVybiB0KGUpLTJ9OmZ1bmN0aW9uKGUpe3ZhciB0PU1hdGguTE4yLGk9TWF0aC5sb2c7cmV0dXJuIDA9PT1lPzMwOjB8MjktKDB8aShlPj4+MCkvdCl9LFMuX19pbXVsPWV8fGZ1bmN0aW9uKGUsdCl7cmV0dXJuIDB8ZSp0fSxTfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1qc2JpLXVtZC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/jsbi/dist/jsbi-umd.js\n");

/***/ }),

/***/ "./src/style.scss":
/*!************************!*\
  !*** ./src/style.scss ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/styleDomAPI.js */ \"./node_modules/style-loader/dist/runtime/styleDomAPI.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/insertBySelector.js */ \"./node_modules/style-loader/dist/runtime/insertBySelector.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js */ \"./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/insertStyleElement.js */ \"./node_modules/style-loader/dist/runtime/insertStyleElement.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/styleTagTransform.js */ \"./node_modules/style-loader/dist/runtime/styleTagTransform.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var _node_modules_css_loader_dist_cjs_js_node_modules_sass_loader_dist_cjs_js_style_scss__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../node_modules/css-loader/dist/cjs.js!../node_modules/sass-loader/dist/cjs.js!./style.scss */ \"./node_modules/css-loader/dist/cjs.js!./node_modules/sass-loader/dist/cjs.js!./src/style.scss\");\n\n      \n      \n      \n      \n      \n      \n      \n      \n      \n\nvar options = {};\n\noptions.styleTagTransform = (_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());\noptions.setAttributes = (_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());\n\n      options.insert = _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, \"head\");\n    \noptions.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());\noptions.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());\n\nvar update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_node_modules_sass_loader_dist_cjs_js_style_scss__WEBPACK_IMPORTED_MODULE_6__[\"default\"], options);\n\n\n\n\n       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_node_modules_sass_loader_dist_cjs_js_style_scss__WEBPACK_IMPORTED_MODULE_6__[\"default\"] && _node_modules_css_loader_dist_cjs_js_node_modules_sass_loader_dist_cjs_js_style_scss__WEBPACK_IMPORTED_MODULE_6__[\"default\"].locals ? _node_modules_css_loader_dist_cjs_js_node_modules_sass_loader_dist_cjs_js_style_scss__WEBPACK_IMPORTED_MODULE_6__[\"default\"].locals : undefined);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvc3R5bGUuc2Nzcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFDQSxNQUErRjtBQUMvRixNQUFxRjtBQUNyRixNQUE0RjtBQUM1RixNQUErRztBQUMvRyxNQUF3RztBQUN4RyxNQUF3RztBQUN4RyxNQUE0STtBQUM1STtBQUNBOztBQUVBOztBQUVBLDRCQUE0QixxR0FBbUI7QUFDL0Msd0JBQXdCLGtIQUFhOztBQUVyQyx1QkFBdUIsdUdBQWE7QUFDcEM7QUFDQSxpQkFBaUIsK0ZBQU07QUFDdkIsNkJBQTZCLHNHQUFrQjs7QUFFL0MsYUFBYSwwR0FBRyxDQUFDLDRIQUFPOzs7O0FBSXNGO0FBQzlHLE9BQU8saUVBQWUsNEhBQU8sSUFBSSxtSUFBYyxHQUFHLG1JQUFjLFlBQVksRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3RvZG8tbGlzdC8uL3NyYy9zdHlsZS5zY3NzPzc1YmEiXSwic291cmNlc0NvbnRlbnQiOlsiXG4gICAgICBpbXBvcnQgQVBJIGZyb20gXCIhLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5qZWN0U3R5bGVzSW50b1N0eWxlVGFnLmpzXCI7XG4gICAgICBpbXBvcnQgZG9tQVBJIGZyb20gXCIhLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvc3R5bGVEb21BUEkuanNcIjtcbiAgICAgIGltcG9ydCBpbnNlcnRGbiBmcm9tIFwiIS4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luc2VydEJ5U2VsZWN0b3IuanNcIjtcbiAgICAgIGltcG9ydCBzZXRBdHRyaWJ1dGVzIGZyb20gXCIhLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvc2V0QXR0cmlidXRlc1dpdGhvdXRBdHRyaWJ1dGVzLmpzXCI7XG4gICAgICBpbXBvcnQgaW5zZXJ0U3R5bGVFbGVtZW50IGZyb20gXCIhLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5zZXJ0U3R5bGVFbGVtZW50LmpzXCI7XG4gICAgICBpbXBvcnQgc3R5bGVUYWdUcmFuc2Zvcm1GbiBmcm9tIFwiIS4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL3N0eWxlVGFnVHJhbnNmb3JtLmpzXCI7XG4gICAgICBpbXBvcnQgY29udGVudCwgKiBhcyBuYW1lZEV4cG9ydCBmcm9tIFwiISEuLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcyEuLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvZGlzdC9janMuanMhLi9zdHlsZS5zY3NzXCI7XG4gICAgICBcbiAgICAgIFxuXG52YXIgb3B0aW9ucyA9IHt9O1xuXG5vcHRpb25zLnN0eWxlVGFnVHJhbnNmb3JtID0gc3R5bGVUYWdUcmFuc2Zvcm1Gbjtcbm9wdGlvbnMuc2V0QXR0cmlidXRlcyA9IHNldEF0dHJpYnV0ZXM7XG5cbiAgICAgIG9wdGlvbnMuaW5zZXJ0ID0gaW5zZXJ0Rm4uYmluZChudWxsLCBcImhlYWRcIik7XG4gICAgXG5vcHRpb25zLmRvbUFQSSA9IGRvbUFQSTtcbm9wdGlvbnMuaW5zZXJ0U3R5bGVFbGVtZW50ID0gaW5zZXJ0U3R5bGVFbGVtZW50O1xuXG52YXIgdXBkYXRlID0gQVBJKGNvbnRlbnQsIG9wdGlvbnMpO1xuXG5cblxuZXhwb3J0ICogZnJvbSBcIiEhLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanMhLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vc3R5bGUuc2Nzc1wiO1xuICAgICAgIGV4cG9ydCBkZWZhdWx0IGNvbnRlbnQgJiYgY29udGVudC5sb2NhbHMgPyBjb250ZW50LmxvY2FscyA6IHVuZGVmaW5lZDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/style.scss\n");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js":
/*!****************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js ***!
  \****************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nvar stylesInDOM = [];\n\nfunction getIndexByIdentifier(identifier) {\n  var result = -1;\n\n  for (var i = 0; i < stylesInDOM.length; i++) {\n    if (stylesInDOM[i].identifier === identifier) {\n      result = i;\n      break;\n    }\n  }\n\n  return result;\n}\n\nfunction modulesToDom(list, options) {\n  var idCountMap = {};\n  var identifiers = [];\n\n  for (var i = 0; i < list.length; i++) {\n    var item = list[i];\n    var id = options.base ? item[0] + options.base : item[0];\n    var count = idCountMap[id] || 0;\n    var identifier = \"\".concat(id, \" \").concat(count);\n    idCountMap[id] = count + 1;\n    var indexByIdentifier = getIndexByIdentifier(identifier);\n    var obj = {\n      css: item[1],\n      media: item[2],\n      sourceMap: item[3],\n      supports: item[4],\n      layer: item[5]\n    };\n\n    if (indexByIdentifier !== -1) {\n      stylesInDOM[indexByIdentifier].references++;\n      stylesInDOM[indexByIdentifier].updater(obj);\n    } else {\n      var updater = addElementStyle(obj, options);\n      options.byIndex = i;\n      stylesInDOM.splice(i, 0, {\n        identifier: identifier,\n        updater: updater,\n        references: 1\n      });\n    }\n\n    identifiers.push(identifier);\n  }\n\n  return identifiers;\n}\n\nfunction addElementStyle(obj, options) {\n  var api = options.domAPI(options);\n  api.update(obj);\n\n  var updater = function updater(newObj) {\n    if (newObj) {\n      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap && newObj.supports === obj.supports && newObj.layer === obj.layer) {\n        return;\n      }\n\n      api.update(obj = newObj);\n    } else {\n      api.remove();\n    }\n  };\n\n  return updater;\n}\n\nmodule.exports = function (list, options) {\n  options = options || {};\n  list = list || [];\n  var lastIdentifiers = modulesToDom(list, options);\n  return function update(newList) {\n    newList = newList || [];\n\n    for (var i = 0; i < lastIdentifiers.length; i++) {\n      var identifier = lastIdentifiers[i];\n      var index = getIndexByIdentifier(identifier);\n      stylesInDOM[index].references--;\n    }\n\n    var newLastIdentifiers = modulesToDom(newList, options);\n\n    for (var _i = 0; _i < lastIdentifiers.length; _i++) {\n      var _identifier = lastIdentifiers[_i];\n\n      var _index = getIndexByIdentifier(_identifier);\n\n      if (stylesInDOM[_index].references === 0) {\n        stylesInDOM[_index].updater();\n\n        stylesInDOM.splice(_index, 1);\n      }\n    }\n\n    lastIdentifiers = newLastIdentifiers;\n  };\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbmplY3RTdHlsZXNJbnRvU3R5bGVUYWcuanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7O0FBRUE7QUFDQTs7QUFFQSxrQkFBa0Isd0JBQXdCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLGlCQUFpQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLDRCQUE0QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxxQkFBcUIsNkJBQTZCO0FBQ2xEOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3RvZG8tbGlzdC8uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qcz8yZGJhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG52YXIgc3R5bGVzSW5ET00gPSBbXTtcblxuZnVuY3Rpb24gZ2V0SW5kZXhCeUlkZW50aWZpZXIoaWRlbnRpZmllcikge1xuICB2YXIgcmVzdWx0ID0gLTE7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHlsZXNJbkRPTS5sZW5ndGg7IGkrKykge1xuICAgIGlmIChzdHlsZXNJbkRPTVtpXS5pZGVudGlmaWVyID09PSBpZGVudGlmaWVyKSB7XG4gICAgICByZXN1bHQgPSBpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gbW9kdWxlc1RvRG9tKGxpc3QsIG9wdGlvbnMpIHtcbiAgdmFyIGlkQ291bnRNYXAgPSB7fTtcbiAgdmFyIGlkZW50aWZpZXJzID0gW107XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGl0ZW0gPSBsaXN0W2ldO1xuICAgIHZhciBpZCA9IG9wdGlvbnMuYmFzZSA/IGl0ZW1bMF0gKyBvcHRpb25zLmJhc2UgOiBpdGVtWzBdO1xuICAgIHZhciBjb3VudCA9IGlkQ291bnRNYXBbaWRdIHx8IDA7XG4gICAgdmFyIGlkZW50aWZpZXIgPSBcIlwiLmNvbmNhdChpZCwgXCIgXCIpLmNvbmNhdChjb3VudCk7XG4gICAgaWRDb3VudE1hcFtpZF0gPSBjb3VudCArIDE7XG4gICAgdmFyIGluZGV4QnlJZGVudGlmaWVyID0gZ2V0SW5kZXhCeUlkZW50aWZpZXIoaWRlbnRpZmllcik7XG4gICAgdmFyIG9iaiA9IHtcbiAgICAgIGNzczogaXRlbVsxXSxcbiAgICAgIG1lZGlhOiBpdGVtWzJdLFxuICAgICAgc291cmNlTWFwOiBpdGVtWzNdLFxuICAgICAgc3VwcG9ydHM6IGl0ZW1bNF0sXG4gICAgICBsYXllcjogaXRlbVs1XVxuICAgIH07XG5cbiAgICBpZiAoaW5kZXhCeUlkZW50aWZpZXIgIT09IC0xKSB7XG4gICAgICBzdHlsZXNJbkRPTVtpbmRleEJ5SWRlbnRpZmllcl0ucmVmZXJlbmNlcysrO1xuICAgICAgc3R5bGVzSW5ET01baW5kZXhCeUlkZW50aWZpZXJdLnVwZGF0ZXIob2JqKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHVwZGF0ZXIgPSBhZGRFbGVtZW50U3R5bGUob2JqLCBvcHRpb25zKTtcbiAgICAgIG9wdGlvbnMuYnlJbmRleCA9IGk7XG4gICAgICBzdHlsZXNJbkRPTS5zcGxpY2UoaSwgMCwge1xuICAgICAgICBpZGVudGlmaWVyOiBpZGVudGlmaWVyLFxuICAgICAgICB1cGRhdGVyOiB1cGRhdGVyLFxuICAgICAgICByZWZlcmVuY2VzOiAxXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZGVudGlmaWVycy5wdXNoKGlkZW50aWZpZXIpO1xuICB9XG5cbiAgcmV0dXJuIGlkZW50aWZpZXJzO1xufVxuXG5mdW5jdGlvbiBhZGRFbGVtZW50U3R5bGUob2JqLCBvcHRpb25zKSB7XG4gIHZhciBhcGkgPSBvcHRpb25zLmRvbUFQSShvcHRpb25zKTtcbiAgYXBpLnVwZGF0ZShvYmopO1xuXG4gIHZhciB1cGRhdGVyID0gZnVuY3Rpb24gdXBkYXRlcihuZXdPYmopIHtcbiAgICBpZiAobmV3T2JqKSB7XG4gICAgICBpZiAobmV3T2JqLmNzcyA9PT0gb2JqLmNzcyAmJiBuZXdPYmoubWVkaWEgPT09IG9iai5tZWRpYSAmJiBuZXdPYmouc291cmNlTWFwID09PSBvYmouc291cmNlTWFwICYmIG5ld09iai5zdXBwb3J0cyA9PT0gb2JqLnN1cHBvcnRzICYmIG5ld09iai5sYXllciA9PT0gb2JqLmxheWVyKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgYXBpLnVwZGF0ZShvYmogPSBuZXdPYmopO1xuICAgIH0gZWxzZSB7XG4gICAgICBhcGkucmVtb3ZlKCk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiB1cGRhdGVyO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChsaXN0LCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBsaXN0ID0gbGlzdCB8fCBbXTtcbiAgdmFyIGxhc3RJZGVudGlmaWVycyA9IG1vZHVsZXNUb0RvbShsaXN0LCBvcHRpb25zKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZShuZXdMaXN0KSB7XG4gICAgbmV3TGlzdCA9IG5ld0xpc3QgfHwgW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxhc3RJZGVudGlmaWVycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGlkZW50aWZpZXIgPSBsYXN0SWRlbnRpZmllcnNbaV07XG4gICAgICB2YXIgaW5kZXggPSBnZXRJbmRleEJ5SWRlbnRpZmllcihpZGVudGlmaWVyKTtcbiAgICAgIHN0eWxlc0luRE9NW2luZGV4XS5yZWZlcmVuY2VzLS07XG4gICAgfVxuXG4gICAgdmFyIG5ld0xhc3RJZGVudGlmaWVycyA9IG1vZHVsZXNUb0RvbShuZXdMaXN0LCBvcHRpb25zKTtcblxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBsYXN0SWRlbnRpZmllcnMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICB2YXIgX2lkZW50aWZpZXIgPSBsYXN0SWRlbnRpZmllcnNbX2ldO1xuXG4gICAgICB2YXIgX2luZGV4ID0gZ2V0SW5kZXhCeUlkZW50aWZpZXIoX2lkZW50aWZpZXIpO1xuXG4gICAgICBpZiAoc3R5bGVzSW5ET01bX2luZGV4XS5yZWZlcmVuY2VzID09PSAwKSB7XG4gICAgICAgIHN0eWxlc0luRE9NW19pbmRleF0udXBkYXRlcigpO1xuXG4gICAgICAgIHN0eWxlc0luRE9NLnNwbGljZShfaW5kZXgsIDEpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGxhc3RJZGVudGlmaWVycyA9IG5ld0xhc3RJZGVudGlmaWVycztcbiAgfTtcbn07Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\n");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertBySelector.js":
/*!********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertBySelector.js ***!
  \********************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nvar memo = {};\n/* istanbul ignore next  */\n\nfunction getTarget(target) {\n  if (typeof memo[target] === \"undefined\") {\n    var styleTarget = document.querySelector(target); // Special case to return head of iframe instead of iframe itself\n\n    if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n      try {\n        // This will throw an exception if access to iframe is blocked\n        // due to cross-origin restrictions\n        styleTarget = styleTarget.contentDocument.head;\n      } catch (e) {\n        // istanbul ignore next\n        styleTarget = null;\n      }\n    }\n\n    memo[target] = styleTarget;\n  }\n\n  return memo[target];\n}\n/* istanbul ignore next  */\n\n\nfunction insertBySelector(insert, style) {\n  var target = getTarget(insert);\n\n  if (!target) {\n    throw new Error(\"Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.\");\n  }\n\n  target.appendChild(style);\n}\n\nmodule.exports = insertBySelector;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbnNlcnRCeVNlbGVjdG9yLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNEQUFzRDs7QUFFdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3RvZG8tbGlzdC8uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luc2VydEJ5U2VsZWN0b3IuanM/YjIxNCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxudmFyIG1lbW8gPSB7fTtcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICAqL1xuXG5mdW5jdGlvbiBnZXRUYXJnZXQodGFyZ2V0KSB7XG4gIGlmICh0eXBlb2YgbWVtb1t0YXJnZXRdID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgdmFyIHN0eWxlVGFyZ2V0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0YXJnZXQpOyAvLyBTcGVjaWFsIGNhc2UgdG8gcmV0dXJuIGhlYWQgb2YgaWZyYW1lIGluc3RlYWQgb2YgaWZyYW1lIGl0c2VsZlxuXG4gICAgaWYgKHdpbmRvdy5IVE1MSUZyYW1lRWxlbWVudCAmJiBzdHlsZVRhcmdldCBpbnN0YW5jZW9mIHdpbmRvdy5IVE1MSUZyYW1lRWxlbWVudCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gVGhpcyB3aWxsIHRocm93IGFuIGV4Y2VwdGlvbiBpZiBhY2Nlc3MgdG8gaWZyYW1lIGlzIGJsb2NrZWRcbiAgICAgICAgLy8gZHVlIHRvIGNyb3NzLW9yaWdpbiByZXN0cmljdGlvbnNcbiAgICAgICAgc3R5bGVUYXJnZXQgPSBzdHlsZVRhcmdldC5jb250ZW50RG9jdW1lbnQuaGVhZDtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gaXN0YW5idWwgaWdub3JlIG5leHRcbiAgICAgICAgc3R5bGVUYXJnZXQgPSBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIG1lbW9bdGFyZ2V0XSA9IHN0eWxlVGFyZ2V0O1xuICB9XG5cbiAgcmV0dXJuIG1lbW9bdGFyZ2V0XTtcbn1cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICAqL1xuXG5cbmZ1bmN0aW9uIGluc2VydEJ5U2VsZWN0b3IoaW5zZXJ0LCBzdHlsZSkge1xuICB2YXIgdGFyZ2V0ID0gZ2V0VGFyZ2V0KGluc2VydCk7XG5cbiAgaWYgKCF0YXJnZXQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZG4ndCBmaW5kIGEgc3R5bGUgdGFyZ2V0LiBUaGlzIHByb2JhYmx5IG1lYW5zIHRoYXQgdGhlIHZhbHVlIGZvciB0aGUgJ2luc2VydCcgcGFyYW1ldGVyIGlzIGludmFsaWQuXCIpO1xuICB9XG5cbiAgdGFyZ2V0LmFwcGVuZENoaWxkKHN0eWxlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpbnNlcnRCeVNlbGVjdG9yOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/style-loader/dist/runtime/insertBySelector.js\n");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertStyleElement.js":
/*!**********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertStyleElement.js ***!
  \**********************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/* istanbul ignore next  */\nfunction insertStyleElement(options) {\n  var element = document.createElement(\"style\");\n  options.setAttributes(element, options.attributes);\n  options.insert(element, options.options);\n  return element;\n}\n\nmodule.exports = insertStyleElement;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbnNlcnRTdHlsZUVsZW1lbnQuanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90b2RvLWxpc3QvLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbnNlcnRTdHlsZUVsZW1lbnQuanM/ZGU2YyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgICovXG5mdW5jdGlvbiBpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucykge1xuICB2YXIgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtcbiAgb3B0aW9ucy5zZXRBdHRyaWJ1dGVzKGVsZW1lbnQsIG9wdGlvbnMuYXR0cmlidXRlcyk7XG4gIG9wdGlvbnMuaW5zZXJ0KGVsZW1lbnQsIG9wdGlvbnMub3B0aW9ucyk7XG4gIHJldHVybiBlbGVtZW50O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGluc2VydFN0eWxlRWxlbWVudDsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/style-loader/dist/runtime/insertStyleElement.js\n");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n/* istanbul ignore next  */\nfunction setAttributesWithoutAttributes(styleElement) {\n  var nonce =  true ? __webpack_require__.nc : 0;\n\n  if (nonce) {\n    styleElement.setAttribute(\"nonce\", nonce);\n  }\n}\n\nmodule.exports = setAttributesWithoutAttributes;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9zZXRBdHRyaWJ1dGVzV2l0aG91dEF0dHJpYnV0ZXMuanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBLGNBQWMsS0FBd0MsR0FBRyxzQkFBaUIsR0FBRyxDQUFJOztBQUVqRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3RvZG8tbGlzdC8uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL3NldEF0dHJpYnV0ZXNXaXRob3V0QXR0cmlidXRlcy5qcz9kZGNlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAgKi9cbmZ1bmN0aW9uIHNldEF0dHJpYnV0ZXNXaXRob3V0QXR0cmlidXRlcyhzdHlsZUVsZW1lbnQpIHtcbiAgdmFyIG5vbmNlID0gdHlwZW9mIF9fd2VicGFja19ub25jZV9fICE9PSBcInVuZGVmaW5lZFwiID8gX193ZWJwYWNrX25vbmNlX18gOiBudWxsO1xuXG4gIGlmIChub25jZSkge1xuICAgIHN0eWxlRWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJub25jZVwiLCBub25jZSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzZXRBdHRyaWJ1dGVzV2l0aG91dEF0dHJpYnV0ZXM7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js\n");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleDomAPI.js":
/*!***************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleDomAPI.js ***!
  \***************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/* istanbul ignore next  */\nfunction apply(styleElement, options, obj) {\n  var css = \"\";\n\n  if (obj.supports) {\n    css += \"@supports (\".concat(obj.supports, \") {\");\n  }\n\n  if (obj.media) {\n    css += \"@media \".concat(obj.media, \" {\");\n  }\n\n  var needLayer = typeof obj.layer !== \"undefined\";\n\n  if (needLayer) {\n    css += \"@layer\".concat(obj.layer.length > 0 ? \" \".concat(obj.layer) : \"\", \" {\");\n  }\n\n  css += obj.css;\n\n  if (needLayer) {\n    css += \"}\";\n  }\n\n  if (obj.media) {\n    css += \"}\";\n  }\n\n  if (obj.supports) {\n    css += \"}\";\n  }\n\n  var sourceMap = obj.sourceMap;\n\n  if (sourceMap && typeof btoa !== \"undefined\") {\n    css += \"\\n/*# sourceMappingURL=data:application/json;base64,\".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), \" */\");\n  } // For old IE\n\n  /* istanbul ignore if  */\n\n\n  options.styleTagTransform(css, styleElement, options.options);\n}\n\nfunction removeStyleElement(styleElement) {\n  // istanbul ignore if\n  if (styleElement.parentNode === null) {\n    return false;\n  }\n\n  styleElement.parentNode.removeChild(styleElement);\n}\n/* istanbul ignore next  */\n\n\nfunction domAPI(options) {\n  var styleElement = options.insertStyleElement(options);\n  return {\n    update: function update(obj) {\n      apply(styleElement, options, obj);\n    },\n    remove: function remove() {\n      removeStyleElement(styleElement);\n    }\n  };\n}\n\nmodule.exports = domAPI;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9zdHlsZURvbUFQSS5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrREFBa0Q7QUFDbEQ7O0FBRUE7QUFDQSwwQ0FBMEM7QUFDMUM7O0FBRUE7O0FBRUE7QUFDQSxpRkFBaUY7QUFDakY7O0FBRUE7O0FBRUE7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7O0FBRUE7QUFDQSx5REFBeUQ7QUFDekQsSUFBSTs7QUFFSjs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdG9kby1saXN0Ly4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvc3R5bGVEb21BUEkuanM/ZTQ3OSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgICovXG5mdW5jdGlvbiBhcHBseShzdHlsZUVsZW1lbnQsIG9wdGlvbnMsIG9iaikge1xuICB2YXIgY3NzID0gXCJcIjtcblxuICBpZiAob2JqLnN1cHBvcnRzKSB7XG4gICAgY3NzICs9IFwiQHN1cHBvcnRzIChcIi5jb25jYXQob2JqLnN1cHBvcnRzLCBcIikge1wiKTtcbiAgfVxuXG4gIGlmIChvYmoubWVkaWEpIHtcbiAgICBjc3MgKz0gXCJAbWVkaWEgXCIuY29uY2F0KG9iai5tZWRpYSwgXCIge1wiKTtcbiAgfVxuXG4gIHZhciBuZWVkTGF5ZXIgPSB0eXBlb2Ygb2JqLmxheWVyICE9PSBcInVuZGVmaW5lZFwiO1xuXG4gIGlmIChuZWVkTGF5ZXIpIHtcbiAgICBjc3MgKz0gXCJAbGF5ZXJcIi5jb25jYXQob2JqLmxheWVyLmxlbmd0aCA+IDAgPyBcIiBcIi5jb25jYXQob2JqLmxheWVyKSA6IFwiXCIsIFwiIHtcIik7XG4gIH1cblxuICBjc3MgKz0gb2JqLmNzcztcblxuICBpZiAobmVlZExheWVyKSB7XG4gICAgY3NzICs9IFwifVwiO1xuICB9XG5cbiAgaWYgKG9iai5tZWRpYSkge1xuICAgIGNzcyArPSBcIn1cIjtcbiAgfVxuXG4gIGlmIChvYmouc3VwcG9ydHMpIHtcbiAgICBjc3MgKz0gXCJ9XCI7XG4gIH1cblxuICB2YXIgc291cmNlTWFwID0gb2JqLnNvdXJjZU1hcDtcblxuICBpZiAoc291cmNlTWFwICYmIHR5cGVvZiBidG9hICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgY3NzICs9IFwiXFxuLyojIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxcIi5jb25jYXQoYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkpKSwgXCIgKi9cIik7XG4gIH0gLy8gRm9yIG9sZCBJRVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAgKi9cblxuXG4gIG9wdGlvbnMuc3R5bGVUYWdUcmFuc2Zvcm0oY3NzLCBzdHlsZUVsZW1lbnQsIG9wdGlvbnMub3B0aW9ucyk7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZUVsZW1lbnQpIHtcbiAgLy8gaXN0YW5idWwgaWdub3JlIGlmXG4gIGlmIChzdHlsZUVsZW1lbnQucGFyZW50Tm9kZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHN0eWxlRWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHN0eWxlRWxlbWVudCk7XG59XG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAgKi9cblxuXG5mdW5jdGlvbiBkb21BUEkob3B0aW9ucykge1xuICB2YXIgc3R5bGVFbGVtZW50ID0gb3B0aW9ucy5pbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucyk7XG4gIHJldHVybiB7XG4gICAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUob2JqKSB7XG4gICAgICBhcHBseShzdHlsZUVsZW1lbnQsIG9wdGlvbnMsIG9iaik7XG4gICAgfSxcbiAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZSgpIHtcbiAgICAgIHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZUVsZW1lbnQpO1xuICAgIH1cbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBkb21BUEk7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/style-loader/dist/runtime/styleDomAPI.js\n");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleTagTransform.js":
/*!*********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleTagTransform.js ***!
  \*********************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/* istanbul ignore next  */\nfunction styleTagTransform(css, styleElement) {\n  if (styleElement.styleSheet) {\n    styleElement.styleSheet.cssText = css;\n  } else {\n    while (styleElement.firstChild) {\n      styleElement.removeChild(styleElement.firstChild);\n    }\n\n    styleElement.appendChild(document.createTextNode(css));\n  }\n}\n\nmodule.exports = styleTagTransform;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9zdHlsZVRhZ1RyYW5zZm9ybS5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdG9kby1saXN0Ly4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvc3R5bGVUYWdUcmFuc2Zvcm0uanM/MWRkZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgICovXG5mdW5jdGlvbiBzdHlsZVRhZ1RyYW5zZm9ybShjc3MsIHN0eWxlRWxlbWVudCkge1xuICBpZiAoc3R5bGVFbGVtZW50LnN0eWxlU2hlZXQpIHtcbiAgICBzdHlsZUVsZW1lbnQuc3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzO1xuICB9IGVsc2Uge1xuICAgIHdoaWxlIChzdHlsZUVsZW1lbnQuZmlyc3RDaGlsZCkge1xuICAgICAgc3R5bGVFbGVtZW50LnJlbW92ZUNoaWxkKHN0eWxlRWxlbWVudC5maXJzdENoaWxkKTtcbiAgICB9XG5cbiAgICBzdHlsZUVsZW1lbnQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdHlsZVRhZ1RyYW5zZm9ybTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/style-loader/dist/runtime/styleTagTransform.js\n");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _style_scss__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./style.scss */ \"./src/style.scss\");\n/* harmony import */ var _js_addToDo__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./js/addToDo */ \"./src/js/addToDo.js\");\n/* harmony import */ var _js_documentParts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./js/documentParts */ \"./src/js/documentParts.js\");\n/* harmony import */ var _js_projectPageGeneration__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./js/projectPageGeneration */ \"./src/js/projectPageGeneration.js\");\n/* harmony import */ var _js_addListeners__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./js/addListeners */ \"./src/js/addListeners.js\");\n\n\n\n\n\n\n(0,_js_addListeners__WEBPACK_IMPORTED_MODULE_4__[\"default\"])();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvaW5kZXguanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQXNCO0FBQ0E7QUFDYTtBQUNDO0FBQ2M7O0FBRWxELDREQUFpQiIsInNvdXJjZXMiOlsid2VicGFjazovL3RvZG8tbGlzdC8uL3NyYy9pbmRleC5qcz9iNjM1Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAnLi9zdHlsZS5zY3NzJztcbmltcG9ydCAnLi9qcy9hZGRUb0RvJztcbmltcG9ydCBfIGZyb20gJy4vanMvZG9jdW1lbnRQYXJ0cyc7XG5pbXBvcnQgJy4vanMvcHJvamVjdFBhZ2VHZW5lcmF0aW9uJztcbmltcG9ydCBhZGRFdmVudExpc3RlbmVycyBmcm9tICcuL2pzL2FkZExpc3RlbmVycyc7XG5cbmFkZEV2ZW50TGlzdGVuZXJzKCk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/index.js\n");

/***/ }),

/***/ "./src/js/addListeners.js":
/*!********************************!*\
  !*** ./src/js/addListeners.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _documentParts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./documentParts */ \"./src/js/documentParts.js\");\n/* harmony import */ var _defaultProjects__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./defaultProjects */ \"./src/js/defaultProjects.js\");\n/* harmony import */ var _addToDo__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./addToDo */ \"./src/js/addToDo.js\");\n/* harmony import */ var _createEditModal__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./createEditModal */ \"./src/js/createEditModal.js\");\n/* harmony import */ var _dateFilter__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./dateFilter */ \"./src/js/dateFilter.js\");\n/* harmony import */ var _currentDate__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./currentDate */ \"./src/js/currentDate.js\");\n\n\n\n\n\n\n// import pageGeneration from './projectPageGeneration';\n\n// function viewContents () {\n//     let list = defaults.listOfProjects;\n\n//     for (let i = 0; i < list.length; i++){\n//         console.log(list[i].getTitle());\n//         for(let j = 0; j < list[i].arr.length; j++){\n//             console.log(list[i].arr[j].getID());\n//         }\n//     }\n//     console.log('stop');\n// }\n\nconst addEventListeners = () => {\n    // viewContents();\n    // remove toDo\n    const trashBtns = document.querySelectorAll('.fa-trash-can');\n    for (let i = 0; i < trashBtns.length; i++) {\n        trashBtns[i].addEventListener('click', deleteToDo);\n    }\n    // mark complete\n    const uncheckedBoxes = document.querySelectorAll('.fa-square');\n    for (let i = 0; i < uncheckedBoxes.length; i++) {\n        uncheckedBoxes[i].addEventListener('click', completeToDo);\n    }\n    // mark incomplete\n    const checkedBoxes = document.querySelectorAll('.fa-square-check');\n    for (let i = 0; i < checkedBoxes.length; i++) {\n        checkedBoxes[i].addEventListener('click', undoToDoCompletion);\n    }\n    // edit toDo modal\n    const editModalBtns = document.querySelectorAll('.fa-pen-to-square');\n    for (let i = 0; i < editModalBtns.length; i++) {\n        editModalBtns[i].addEventListener('click', instantiateEditModal);\n    }\n    // create toDo modal\n    _documentParts__WEBPACK_IMPORTED_MODULE_0__[\"default\"].addToDoBtn.addEventListener('click', instantiateCreationModal);\n    // create project modal\n    _documentParts__WEBPACK_IMPORTED_MODULE_0__[\"default\"].addProjectBtn.addEventListener('click', instantiateProjectModal);\n}\n\nconst deleteToDo = (e) => {\n    const item = e.target;\n    const todo = item.parentElement.parentElement;\n    todo.remove();\n\n    const removeFromArray = () => {\n        let targetIndex = todo.getAttribute('data-index');\n        for (let i = 0; i < _defaultProjects__WEBPACK_IMPORTED_MODULE_1__[\"default\"].listOfProjects[_defaultProjects__WEBPACK_IMPORTED_MODULE_1__[\"default\"].currentProjectIndex].arr.length; i++) {\n            if (_defaultProjects__WEBPACK_IMPORTED_MODULE_1__[\"default\"].listOfProjects[_defaultProjects__WEBPACK_IMPORTED_MODULE_1__[\"default\"].currentProjectIndex].arr[i].getID() == targetIndex) {\n                _defaultProjects__WEBPACK_IMPORTED_MODULE_1__[\"default\"].listOfProjects[_defaultProjects__WEBPACK_IMPORTED_MODULE_1__[\"default\"].currentProjectIndex].removeFromList(i);\n            }\n        }\n    };\n\n    removeFromArray();\n}\n\nconst completeToDo = (e) => {\n    const item = e.target;\n    const todo = item.parentElement.parentElement;\n    todo.classList.add('completed');\n    todo.innerHTML = todo.innerHTML.replace('<i class=\"fa-regular fa-square\"></i>', '<i class=\"fa-regular fa-square-check\"></i>');\n    addEventListeners();\n};\n\nconst undoToDoCompletion = (e) => {\n    const item = e.target;\n    const todo = item.parentElement.parentElement;\n    todo.classList.remove('completed');\n    todo.innerHTML = todo.innerHTML.replace('<i class=\"fa-regular fa-square-check\"></i>', '<i class=\"fa-regular fa-square\"></i>');\n    addEventListeners();\n}\n\nconst instantiateEditModal = (e) => {\n\n    const item = e.target;\n    const todo = item.parentElement.parentElement;\n    const targetIndex = todo.getAttribute('data-index');\n    const shortHand = _defaultProjects__WEBPACK_IMPORTED_MODULE_1__[\"default\"].listOfProjects[_defaultProjects__WEBPACK_IMPORTED_MODULE_1__[\"default\"].currentProjectIndex];\n\n    const getToDoInfo = () => {\n        for (let i = 0; i < shortHand.arr.length; i++) {\n            if (shortHand.arr[i].getID() == targetIndex) {\n                let name = shortHand.arr[i].getTitle();  \n                let description = shortHand.arr[i].getDescription();\n                let dueDate = shortHand.arr[i].getDueDate();\n                let priority = shortHand.arr[i].getPriority();\n                return {name, description, dueDate, priority};\n            }\n        }\n    };\n\n    const toDoInfo = getToDoInfo();\n    const form = (0,_createEditModal__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(toDoInfo.name, toDoInfo.description,\n        toDoInfo.dueDate, toDoInfo.priority);\n\n    _documentParts__WEBPACK_IMPORTED_MODULE_0__[\"default\"].body.appendChild(form.newModal);\n    form.newModal.showModal();\n\n    const submitEditBtn = document.querySelector('.submitEditBtn');\n    const cancelEditBtn = document.querySelector('.cancelEditBtn');\n\n    cancelEditBtn.addEventListener('click', function cancelEditModal(e) {\n        e.preventDefault();\n        form.newModal.close();\n        _documentParts__WEBPACK_IMPORTED_MODULE_0__[\"default\"].body.removeChild(form.newModal);\n        addEventListeners(); \n    });\n\n    submitEditBtn.addEventListener('click', function submitEditModal(e){\n        e.preventDefault();\n        for (let i = 0; i < shortHand.arr.length; i++) {\n            if (shortHand.arr[i].getID() == targetIndex) {\n\n                // update arr\n                shortHand.arr[i].setTitle(form.taskName.value);\n                shortHand.arr[i].setDescription(form.taskDescription.value);\n                shortHand.arr[i].setDueDate(form.taskDueDate.value);\n                shortHand.arr[i].setPriority(form.taskPriority.value);\n                // update table\n\n                todo.children[0].innerHTML = `<i class=\"fa-regular fa-square\"></i> ${form.taskName.value}`;\n                if (form.taskDueDate.value !== '') {\n                    let filteredDueDate = (0,_dateFilter__WEBPACK_IMPORTED_MODULE_4__.dateFilter)(form.taskDueDate.value);\n                    todo.children[1].innerHTML = `${filteredDueDate} <i class=\"fa-regular fa-pen-to-square\"></i><i class=\"fa-regular fa-trash-can\"></i>`;\n                }\n                else {\n                    todo.children[1].innerHTML = `<i class=\"fa-regular fa-pen-to-square\"></i><i class=\"fa-regular fa-trash-can\"></i>`;\n                }\n            }\n        }\n        _documentParts__WEBPACK_IMPORTED_MODULE_0__[\"default\"].body.removeChild(form.newModal);\n        addEventListeners();   \n    });\n};\n\nconst instantiateCreationModal = (e) => {\n    e.preventDefault();\n\n    _documentParts__WEBPACK_IMPORTED_MODULE_0__[\"default\"].modal.showModal();\n\n    // set default date value to now\n    let dueDate = document.querySelector('#createTaskDueDate'); \n    dueDate.setAttribute(\"value\", `${(0,_currentDate__WEBPACK_IMPORTED_MODULE_5__.now)()}`);\n\n    _documentParts__WEBPACK_IMPORTED_MODULE_0__[\"default\"].modalCancelBtn.addEventListener('click', function cancelCreationModal () {\n        _documentParts__WEBPACK_IMPORTED_MODULE_0__[\"default\"].modal.close();\n    });\n\n    _documentParts__WEBPACK_IMPORTED_MODULE_0__[\"default\"].modalSubmitBtn.addEventListener('click', _addToDo__WEBPACK_IMPORTED_MODULE_2__[\"default\"]);\n    addEventListeners();\n};\n\nconst instantiateProjectModal = (e) => {\n    e.preventDefault();\n    \n};\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (addEventListeners);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvanMvYWRkTGlzdGVuZXJzLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBZ0M7QUFDUztBQUNGO0FBQ1M7QUFDTjtBQUNOO0FBQ3BDOztBQUVBO0FBQ0E7O0FBRUEsdUJBQXVCLGlCQUFpQjtBQUN4QztBQUNBLDBCQUEwQix3QkFBd0I7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMkJBQTJCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHlCQUF5QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwwQkFBMEI7QUFDOUM7QUFDQTtBQUNBO0FBQ0EsSUFBSSxrRkFBNkI7QUFDakM7QUFDQSxJQUFJLHFGQUFnQztBQUNwQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0JBQXdCLElBQUksdUVBQXVCLENBQUMsNEVBQTRCLGNBQWM7QUFDOUYsZ0JBQWdCLHVFQUF1QixDQUFDLDRFQUE0QjtBQUNwRSxnQkFBZ0IsdUVBQXVCLENBQUMsNEVBQTRCO0FBQ3BFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQix1RUFBdUIsQ0FBQyw0RUFBNEI7O0FBRTFFO0FBQ0Esd0JBQXdCLDBCQUEwQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQiw0REFBZTtBQUNoQzs7QUFFQSxJQUFJLHVFQUFrQjtBQUN0Qjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsdUVBQWtCO0FBQzFCO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0Esd0JBQXdCLDBCQUEwQjtBQUNsRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUZBQXFGLG9CQUFvQjtBQUN6RztBQUNBLDBDQUEwQyx1REFBVTtBQUNwRCxvREFBb0QsaUJBQWlCO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsdUVBQWtCO0FBQzFCO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUEsSUFBSSxzRUFBaUI7O0FBRXJCO0FBQ0E7QUFDQSxxQ0FBcUMsaURBQUcsR0FBRzs7QUFFM0MsSUFBSSxzRkFBaUM7QUFDckMsUUFBUSxrRUFBYTtBQUNyQixLQUFLOztBQUVMLElBQUksc0ZBQWlDLFVBQVUsZ0RBQWM7QUFDN0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpRUFBZSxpQkFBaUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90b2RvLWxpc3QvLi9zcmMvanMvYWRkTGlzdGVuZXJzLmpzPzQ2NGEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IF8gZnJvbSAnLi9kb2N1bWVudFBhcnRzJztcbmltcG9ydCBkZWZhdWx0cyBmcm9tICcuL2RlZmF1bHRQcm9qZWN0cyc7XG5pbXBvcnQgYWRkVG9Eb1RvVGFibGUgZnJvbSAnLi9hZGRUb0RvJztcbmltcG9ydCBjcmVhdGVFZGl0TW9kYWwgZnJvbSAnLi9jcmVhdGVFZGl0TW9kYWwnO1xuaW1wb3J0IHsgZGF0ZUZpbHRlciB9IGZyb20gJy4vZGF0ZUZpbHRlcic7XG5pbXBvcnQgeyBub3cgfSBmcm9tICcuL2N1cnJlbnREYXRlJztcbi8vIGltcG9ydCBwYWdlR2VuZXJhdGlvbiBmcm9tICcuL3Byb2plY3RQYWdlR2VuZXJhdGlvbic7XG5cbi8vIGZ1bmN0aW9uIHZpZXdDb250ZW50cyAoKSB7XG4vLyAgICAgbGV0IGxpc3QgPSBkZWZhdWx0cy5saXN0T2ZQcm9qZWN0cztcblxuLy8gICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKyl7XG4vLyAgICAgICAgIGNvbnNvbGUubG9nKGxpc3RbaV0uZ2V0VGl0bGUoKSk7XG4vLyAgICAgICAgIGZvcihsZXQgaiA9IDA7IGogPCBsaXN0W2ldLmFyci5sZW5ndGg7IGorKyl7XG4vLyAgICAgICAgICAgICBjb25zb2xlLmxvZyhsaXN0W2ldLmFycltqXS5nZXRJRCgpKTtcbi8vICAgICAgICAgfVxuLy8gICAgIH1cbi8vICAgICBjb25zb2xlLmxvZygnc3RvcCcpO1xuLy8gfVxuXG5jb25zdCBhZGRFdmVudExpc3RlbmVycyA9ICgpID0+IHtcbiAgICAvLyB2aWV3Q29udGVudHMoKTtcbiAgICAvLyByZW1vdmUgdG9Eb1xuICAgIGNvbnN0IHRyYXNoQnRucyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5mYS10cmFzaC1jYW4nKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRyYXNoQnRucy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0cmFzaEJ0bnNbaV0uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBkZWxldGVUb0RvKTtcbiAgICB9XG4gICAgLy8gbWFyayBjb21wbGV0ZVxuICAgIGNvbnN0IHVuY2hlY2tlZEJveGVzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLmZhLXNxdWFyZScpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdW5jaGVja2VkQm94ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdW5jaGVja2VkQm94ZXNbaV0uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBjb21wbGV0ZVRvRG8pO1xuICAgIH1cbiAgICAvLyBtYXJrIGluY29tcGxldGVcbiAgICBjb25zdCBjaGVja2VkQm94ZXMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcuZmEtc3F1YXJlLWNoZWNrJyk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGVja2VkQm94ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY2hlY2tlZEJveGVzW2ldLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdW5kb1RvRG9Db21wbGV0aW9uKTtcbiAgICB9XG4gICAgLy8gZWRpdCB0b0RvIG1vZGFsXG4gICAgY29uc3QgZWRpdE1vZGFsQnRucyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5mYS1wZW4tdG8tc3F1YXJlJyk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlZGl0TW9kYWxCdG5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGVkaXRNb2RhbEJ0bnNbaV0uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBpbnN0YW50aWF0ZUVkaXRNb2RhbCk7XG4gICAgfVxuICAgIC8vIGNyZWF0ZSB0b0RvIG1vZGFsXG4gICAgXy5hZGRUb0RvQnRuLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgaW5zdGFudGlhdGVDcmVhdGlvbk1vZGFsKTtcbiAgICAvLyBjcmVhdGUgcHJvamVjdCBtb2RhbFxuICAgIF8uYWRkUHJvamVjdEJ0bi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGluc3RhbnRpYXRlUHJvamVjdE1vZGFsKTtcbn1cblxuY29uc3QgZGVsZXRlVG9EbyA9IChlKSA9PiB7XG4gICAgY29uc3QgaXRlbSA9IGUudGFyZ2V0O1xuICAgIGNvbnN0IHRvZG8gPSBpdGVtLnBhcmVudEVsZW1lbnQucGFyZW50RWxlbWVudDtcbiAgICB0b2RvLnJlbW92ZSgpO1xuXG4gICAgY29uc3QgcmVtb3ZlRnJvbUFycmF5ID0gKCkgPT4ge1xuICAgICAgICBsZXQgdGFyZ2V0SW5kZXggPSB0b2RvLmdldEF0dHJpYnV0ZSgnZGF0YS1pbmRleCcpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRlZmF1bHRzLmxpc3RPZlByb2plY3RzW2RlZmF1bHRzLmN1cnJlbnRQcm9qZWN0SW5kZXhdLmFyci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGRlZmF1bHRzLmxpc3RPZlByb2plY3RzW2RlZmF1bHRzLmN1cnJlbnRQcm9qZWN0SW5kZXhdLmFycltpXS5nZXRJRCgpID09IHRhcmdldEluZGV4KSB7XG4gICAgICAgICAgICAgICAgZGVmYXVsdHMubGlzdE9mUHJvamVjdHNbZGVmYXVsdHMuY3VycmVudFByb2plY3RJbmRleF0ucmVtb3ZlRnJvbUxpc3QoaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgcmVtb3ZlRnJvbUFycmF5KCk7XG59XG5cbmNvbnN0IGNvbXBsZXRlVG9EbyA9IChlKSA9PiB7XG4gICAgY29uc3QgaXRlbSA9IGUudGFyZ2V0O1xuICAgIGNvbnN0IHRvZG8gPSBpdGVtLnBhcmVudEVsZW1lbnQucGFyZW50RWxlbWVudDtcbiAgICB0b2RvLmNsYXNzTGlzdC5hZGQoJ2NvbXBsZXRlZCcpO1xuICAgIHRvZG8uaW5uZXJIVE1MID0gdG9kby5pbm5lckhUTUwucmVwbGFjZSgnPGkgY2xhc3M9XCJmYS1yZWd1bGFyIGZhLXNxdWFyZVwiPjwvaT4nLCAnPGkgY2xhc3M9XCJmYS1yZWd1bGFyIGZhLXNxdWFyZS1jaGVja1wiPjwvaT4nKTtcbiAgICBhZGRFdmVudExpc3RlbmVycygpO1xufTtcblxuY29uc3QgdW5kb1RvRG9Db21wbGV0aW9uID0gKGUpID0+IHtcbiAgICBjb25zdCBpdGVtID0gZS50YXJnZXQ7XG4gICAgY29uc3QgdG9kbyA9IGl0ZW0ucGFyZW50RWxlbWVudC5wYXJlbnRFbGVtZW50O1xuICAgIHRvZG8uY2xhc3NMaXN0LnJlbW92ZSgnY29tcGxldGVkJyk7XG4gICAgdG9kby5pbm5lckhUTUwgPSB0b2RvLmlubmVySFRNTC5yZXBsYWNlKCc8aSBjbGFzcz1cImZhLXJlZ3VsYXIgZmEtc3F1YXJlLWNoZWNrXCI+PC9pPicsICc8aSBjbGFzcz1cImZhLXJlZ3VsYXIgZmEtc3F1YXJlXCI+PC9pPicpO1xuICAgIGFkZEV2ZW50TGlzdGVuZXJzKCk7XG59XG5cbmNvbnN0IGluc3RhbnRpYXRlRWRpdE1vZGFsID0gKGUpID0+IHtcblxuICAgIGNvbnN0IGl0ZW0gPSBlLnRhcmdldDtcbiAgICBjb25zdCB0b2RvID0gaXRlbS5wYXJlbnRFbGVtZW50LnBhcmVudEVsZW1lbnQ7XG4gICAgY29uc3QgdGFyZ2V0SW5kZXggPSB0b2RvLmdldEF0dHJpYnV0ZSgnZGF0YS1pbmRleCcpO1xuICAgIGNvbnN0IHNob3J0SGFuZCA9IGRlZmF1bHRzLmxpc3RPZlByb2plY3RzW2RlZmF1bHRzLmN1cnJlbnRQcm9qZWN0SW5kZXhdO1xuXG4gICAgY29uc3QgZ2V0VG9Eb0luZm8gPSAoKSA9PiB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2hvcnRIYW5kLmFyci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHNob3J0SGFuZC5hcnJbaV0uZ2V0SUQoKSA9PSB0YXJnZXRJbmRleCkge1xuICAgICAgICAgICAgICAgIGxldCBuYW1lID0gc2hvcnRIYW5kLmFycltpXS5nZXRUaXRsZSgpOyAgXG4gICAgICAgICAgICAgICAgbGV0IGRlc2NyaXB0aW9uID0gc2hvcnRIYW5kLmFycltpXS5nZXREZXNjcmlwdGlvbigpO1xuICAgICAgICAgICAgICAgIGxldCBkdWVEYXRlID0gc2hvcnRIYW5kLmFycltpXS5nZXREdWVEYXRlKCk7XG4gICAgICAgICAgICAgICAgbGV0IHByaW9yaXR5ID0gc2hvcnRIYW5kLmFycltpXS5nZXRQcmlvcml0eSgpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7bmFtZSwgZGVzY3JpcHRpb24sIGR1ZURhdGUsIHByaW9yaXR5fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBjb25zdCB0b0RvSW5mbyA9IGdldFRvRG9JbmZvKCk7XG4gICAgY29uc3QgZm9ybSA9IGNyZWF0ZUVkaXRNb2RhbCh0b0RvSW5mby5uYW1lLCB0b0RvSW5mby5kZXNjcmlwdGlvbixcbiAgICAgICAgdG9Eb0luZm8uZHVlRGF0ZSwgdG9Eb0luZm8ucHJpb3JpdHkpO1xuXG4gICAgXy5ib2R5LmFwcGVuZENoaWxkKGZvcm0ubmV3TW9kYWwpO1xuICAgIGZvcm0ubmV3TW9kYWwuc2hvd01vZGFsKCk7XG5cbiAgICBjb25zdCBzdWJtaXRFZGl0QnRuID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLnN1Ym1pdEVkaXRCdG4nKTtcbiAgICBjb25zdCBjYW5jZWxFZGl0QnRuID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmNhbmNlbEVkaXRCdG4nKTtcblxuICAgIGNhbmNlbEVkaXRCdG4uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbiBjYW5jZWxFZGl0TW9kYWwoZSkge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGZvcm0ubmV3TW9kYWwuY2xvc2UoKTtcbiAgICAgICAgXy5ib2R5LnJlbW92ZUNoaWxkKGZvcm0ubmV3TW9kYWwpO1xuICAgICAgICBhZGRFdmVudExpc3RlbmVycygpOyBcbiAgICB9KTtcblxuICAgIHN1Ym1pdEVkaXRCdG4uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbiBzdWJtaXRFZGl0TW9kYWwoZSl7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaG9ydEhhbmQuYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoc2hvcnRIYW5kLmFycltpXS5nZXRJRCgpID09IHRhcmdldEluZGV4KSB7XG5cbiAgICAgICAgICAgICAgICAvLyB1cGRhdGUgYXJyXG4gICAgICAgICAgICAgICAgc2hvcnRIYW5kLmFycltpXS5zZXRUaXRsZShmb3JtLnRhc2tOYW1lLnZhbHVlKTtcbiAgICAgICAgICAgICAgICBzaG9ydEhhbmQuYXJyW2ldLnNldERlc2NyaXB0aW9uKGZvcm0udGFza0Rlc2NyaXB0aW9uLnZhbHVlKTtcbiAgICAgICAgICAgICAgICBzaG9ydEhhbmQuYXJyW2ldLnNldER1ZURhdGUoZm9ybS50YXNrRHVlRGF0ZS52YWx1ZSk7XG4gICAgICAgICAgICAgICAgc2hvcnRIYW5kLmFycltpXS5zZXRQcmlvcml0eShmb3JtLnRhc2tQcmlvcml0eS52YWx1ZSk7XG4gICAgICAgICAgICAgICAgLy8gdXBkYXRlIHRhYmxlXG5cbiAgICAgICAgICAgICAgICB0b2RvLmNoaWxkcmVuWzBdLmlubmVySFRNTCA9IGA8aSBjbGFzcz1cImZhLXJlZ3VsYXIgZmEtc3F1YXJlXCI+PC9pPiAke2Zvcm0udGFza05hbWUudmFsdWV9YDtcbiAgICAgICAgICAgICAgICBpZiAoZm9ybS50YXNrRHVlRGF0ZS52YWx1ZSAhPT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGZpbHRlcmVkRHVlRGF0ZSA9IGRhdGVGaWx0ZXIoZm9ybS50YXNrRHVlRGF0ZS52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHRvZG8uY2hpbGRyZW5bMV0uaW5uZXJIVE1MID0gYCR7ZmlsdGVyZWREdWVEYXRlfSA8aSBjbGFzcz1cImZhLXJlZ3VsYXIgZmEtcGVuLXRvLXNxdWFyZVwiPjwvaT48aSBjbGFzcz1cImZhLXJlZ3VsYXIgZmEtdHJhc2gtY2FuXCI+PC9pPmA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0b2RvLmNoaWxkcmVuWzFdLmlubmVySFRNTCA9IGA8aSBjbGFzcz1cImZhLXJlZ3VsYXIgZmEtcGVuLXRvLXNxdWFyZVwiPjwvaT48aSBjbGFzcz1cImZhLXJlZ3VsYXIgZmEtdHJhc2gtY2FuXCI+PC9pPmA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIF8uYm9keS5yZW1vdmVDaGlsZChmb3JtLm5ld01vZGFsKTtcbiAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcnMoKTsgICBcbiAgICB9KTtcbn07XG5cbmNvbnN0IGluc3RhbnRpYXRlQ3JlYXRpb25Nb2RhbCA9IChlKSA9PiB7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgXy5tb2RhbC5zaG93TW9kYWwoKTtcblxuICAgIC8vIHNldCBkZWZhdWx0IGRhdGUgdmFsdWUgdG8gbm93XG4gICAgbGV0IGR1ZURhdGUgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjY3JlYXRlVGFza0R1ZURhdGUnKTsgXG4gICAgZHVlRGF0ZS5zZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiLCBgJHtub3coKX1gKTtcblxuICAgIF8ubW9kYWxDYW5jZWxCdG4uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbiBjYW5jZWxDcmVhdGlvbk1vZGFsICgpIHtcbiAgICAgICAgXy5tb2RhbC5jbG9zZSgpO1xuICAgIH0pO1xuXG4gICAgXy5tb2RhbFN1Ym1pdEJ0bi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGFkZFRvRG9Ub1RhYmxlKTtcbiAgICBhZGRFdmVudExpc3RlbmVycygpO1xufTtcblxuY29uc3QgaW5zdGFudGlhdGVQcm9qZWN0TW9kYWwgPSAoZSkgPT4ge1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICBcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGFkZEV2ZW50TGlzdGVuZXJzOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/js/addListeners.js\n");

/***/ }),

/***/ "./src/js/addToDo.js":
/*!***************************!*\
  !*** ./src/js/addToDo.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _documentParts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./documentParts */ \"./src/js/documentParts.js\");\n/* harmony import */ var _todo__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./todo */ \"./src/js/todo.js\");\n/* harmony import */ var _defaultProjects__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./defaultProjects */ \"./src/js/defaultProjects.js\");\n/* harmony import */ var _dateFilter__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./dateFilter */ \"./src/js/dateFilter.js\");\n/* harmony import */ var _addListeners__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./addListeners */ \"./src/js/addListeners.js\");\n/* harmony import */ var _currentDate__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./currentDate */ \"./src/js/currentDate.js\");\n\n\n\n\n\n\n\nconst addToDoToTable = () => {\n\n    const makeRow = () => {\n        const tr = document.createElement('tr');\n        tr.classList.add('createdRow');\n        tr.setAttribute('data-index', `${_documentParts__WEBPACK_IMPORTED_MODULE_0__[\"default\"].toDoCounter}`);\n        const td1 = document.createElement('td');\n        const td2 = document.createElement('td');\n        td1.classList.add('column1');\n        td2.classList.add('column2');\n\n        td1.innerHTML = `<i class=\"fa-regular fa-square\"></i> ${createTaskName.value}`;\n        if (createTaskDueDate.value !== '') {\n            let filteredDueDate = (0,_dateFilter__WEBPACK_IMPORTED_MODULE_3__.dateFilter)(createTaskDueDate.value);\n            td2.innerHTML = `${filteredDueDate} <i class=\"fa-regular fa-pen-to-square\"></i><i class=\"fa-regular fa-trash-can\"></i>`;\n        }\n        else {\n            td2.innerHTML = `<i class=\"fa-regular fa-pen-to-square\"></i><i class=\"fa-regular fa-trash-can\"></i>`;\n        }\n\n        tr.appendChild(td1);\n        tr.appendChild(td2);\n\n        return tr;\n    };\n\n    const row = makeRow();\n\n    // create an object to store the values and push into defaultProj later\n    let toDoObj = (0,_todo__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(createTaskName.value, createTaskDescription.value, createTaskDueDate.value,\n        createTaskPriority.value, _documentParts__WEBPACK_IMPORTED_MODULE_0__[\"default\"].toDoCounter);\n    \n    _documentParts__WEBPACK_IMPORTED_MODULE_0__[\"default\"].toDoCounter++;\n\n    let convertedDate = (0,_dateFilter__WEBPACK_IMPORTED_MODULE_3__.convertDate)(createTaskDueDate);\n\n    if ((0,_currentDate__WEBPACK_IMPORTED_MODULE_5__.todayCheck)(convertedDate.dd_year, convertedDate.dd_month, convertedDate.dd_day)) {\n        console.log('day');\n    }\n    if ((0,_currentDate__WEBPACK_IMPORTED_MODULE_5__.thisWeekCheck)(convertedDate.dd_year, convertedDate.dd_month, convertedDate.dd_day)){\n        console.log('week');\n    }\n\n    _defaultProjects__WEBPACK_IMPORTED_MODULE_2__[\"default\"].listOfProjects[_defaultProjects__WEBPACK_IMPORTED_MODULE_2__[\"default\"].currentProjectIndex].addToList(toDoObj);\n    _defaultProjects__WEBPACK_IMPORTED_MODULE_2__[\"default\"].listOfProjects[1].addToList(toDoObj);\n\n    _documentParts__WEBPACK_IMPORTED_MODULE_0__[\"default\"].table.appendChild(row);\n    createTaskName.value = '';\n    createTaskDescription.value = '';\n    createTaskDueDate.value = (0,_currentDate__WEBPACK_IMPORTED_MODULE_5__.now)();\n    createTaskPriority.value = 'Normal';\n    (0,_addListeners__WEBPACK_IMPORTED_MODULE_4__[\"default\"])();\n};\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (addToDoToTable);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvanMvYWRkVG9Eby5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQWdDO0FBQ047QUFDZTtBQUNjO0FBQ1I7QUFDZ0I7O0FBRS9EOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxrRUFBYSxDQUFDO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdFQUFnRSxxQkFBcUI7QUFDckY7QUFDQSxrQ0FBa0MsdURBQVU7QUFDNUMsK0JBQStCLGlCQUFpQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxrQkFBa0IsaURBQUk7QUFDdEIsa0NBQWtDLGtFQUFhO0FBQy9DO0FBQ0EsSUFBSSxrRUFBYTs7QUFFakIsd0JBQXdCLHdEQUFXOztBQUVuQyxRQUFRLHdEQUFVO0FBQ2xCO0FBQ0E7QUFDQSxRQUFRLDJEQUFhO0FBQ3JCO0FBQ0E7O0FBRUEsSUFBSSx1RUFBdUIsQ0FBQyw0RUFBNEI7QUFDeEQsSUFBSSxvRkFBb0M7O0FBRXhDLElBQUksd0VBQW1CO0FBQ3ZCO0FBQ0E7QUFDQSw4QkFBOEIsaURBQUc7QUFDakM7QUFDQSxJQUFJLHlEQUFpQjtBQUNyQjs7QUFFQSxpRUFBZSxjQUFjLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90b2RvLWxpc3QvLi9zcmMvanMvYWRkVG9Eby5qcz8xOGY0Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBfIGZyb20gJy4vZG9jdW1lbnRQYXJ0cyc7XG5pbXBvcnQgVG9kbyBmcm9tICcuL3RvZG8nO1xuaW1wb3J0IGRlZmF1bHRzIGZyb20gJy4vZGVmYXVsdFByb2plY3RzJztcbmltcG9ydCB7IGRhdGVGaWx0ZXIsIGNvbnZlcnREYXRlIH0gZnJvbSAnLi9kYXRlRmlsdGVyJztcbmltcG9ydCBhZGRFdmVudExpc3RlbmVycyBmcm9tICcuL2FkZExpc3RlbmVycyc7XG5pbXBvcnQgeyBub3csIHRoaXNXZWVrQ2hlY2ssIHRvZGF5Q2hlY2sgfSBmcm9tICcuL2N1cnJlbnREYXRlJztcblxuY29uc3QgYWRkVG9Eb1RvVGFibGUgPSAoKSA9PiB7XG5cbiAgICBjb25zdCBtYWtlUm93ID0gKCkgPT4ge1xuICAgICAgICBjb25zdCB0ciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RyJyk7XG4gICAgICAgIHRyLmNsYXNzTGlzdC5hZGQoJ2NyZWF0ZWRSb3cnKTtcbiAgICAgICAgdHIuc2V0QXR0cmlidXRlKCdkYXRhLWluZGV4JywgYCR7Xy50b0RvQ291bnRlcn1gKTtcbiAgICAgICAgY29uc3QgdGQxID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGQnKTtcbiAgICAgICAgY29uc3QgdGQyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGQnKTtcbiAgICAgICAgdGQxLmNsYXNzTGlzdC5hZGQoJ2NvbHVtbjEnKTtcbiAgICAgICAgdGQyLmNsYXNzTGlzdC5hZGQoJ2NvbHVtbjInKTtcblxuICAgICAgICB0ZDEuaW5uZXJIVE1MID0gYDxpIGNsYXNzPVwiZmEtcmVndWxhciBmYS1zcXVhcmVcIj48L2k+ICR7Y3JlYXRlVGFza05hbWUudmFsdWV9YDtcbiAgICAgICAgaWYgKGNyZWF0ZVRhc2tEdWVEYXRlLnZhbHVlICE9PSAnJykge1xuICAgICAgICAgICAgbGV0IGZpbHRlcmVkRHVlRGF0ZSA9IGRhdGVGaWx0ZXIoY3JlYXRlVGFza0R1ZURhdGUudmFsdWUpO1xuICAgICAgICAgICAgdGQyLmlubmVySFRNTCA9IGAke2ZpbHRlcmVkRHVlRGF0ZX0gPGkgY2xhc3M9XCJmYS1yZWd1bGFyIGZhLXBlbi10by1zcXVhcmVcIj48L2k+PGkgY2xhc3M9XCJmYS1yZWd1bGFyIGZhLXRyYXNoLWNhblwiPjwvaT5gO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGQyLmlubmVySFRNTCA9IGA8aSBjbGFzcz1cImZhLXJlZ3VsYXIgZmEtcGVuLXRvLXNxdWFyZVwiPjwvaT48aSBjbGFzcz1cImZhLXJlZ3VsYXIgZmEtdHJhc2gtY2FuXCI+PC9pPmA7XG4gICAgICAgIH1cblxuICAgICAgICB0ci5hcHBlbmRDaGlsZCh0ZDEpO1xuICAgICAgICB0ci5hcHBlbmRDaGlsZCh0ZDIpO1xuXG4gICAgICAgIHJldHVybiB0cjtcbiAgICB9O1xuXG4gICAgY29uc3Qgcm93ID0gbWFrZVJvdygpO1xuXG4gICAgLy8gY3JlYXRlIGFuIG9iamVjdCB0byBzdG9yZSB0aGUgdmFsdWVzIGFuZCBwdXNoIGludG8gZGVmYXVsdFByb2ogbGF0ZXJcbiAgICBsZXQgdG9Eb09iaiA9IFRvZG8oY3JlYXRlVGFza05hbWUudmFsdWUsIGNyZWF0ZVRhc2tEZXNjcmlwdGlvbi52YWx1ZSwgY3JlYXRlVGFza0R1ZURhdGUudmFsdWUsXG4gICAgICAgIGNyZWF0ZVRhc2tQcmlvcml0eS52YWx1ZSwgXy50b0RvQ291bnRlcik7XG4gICAgXG4gICAgXy50b0RvQ291bnRlcisrO1xuXG4gICAgbGV0IGNvbnZlcnRlZERhdGUgPSBjb252ZXJ0RGF0ZShjcmVhdGVUYXNrRHVlRGF0ZSk7XG5cbiAgICBpZiAodG9kYXlDaGVjayhjb252ZXJ0ZWREYXRlLmRkX3llYXIsIGNvbnZlcnRlZERhdGUuZGRfbW9udGgsIGNvbnZlcnRlZERhdGUuZGRfZGF5KSkge1xuICAgICAgICBjb25zb2xlLmxvZygnZGF5Jyk7XG4gICAgfVxuICAgIGlmICh0aGlzV2Vla0NoZWNrKGNvbnZlcnRlZERhdGUuZGRfeWVhciwgY29udmVydGVkRGF0ZS5kZF9tb250aCwgY29udmVydGVkRGF0ZS5kZF9kYXkpKXtcbiAgICAgICAgY29uc29sZS5sb2coJ3dlZWsnKTtcbiAgICB9XG5cbiAgICBkZWZhdWx0cy5saXN0T2ZQcm9qZWN0c1tkZWZhdWx0cy5jdXJyZW50UHJvamVjdEluZGV4XS5hZGRUb0xpc3QodG9Eb09iaik7XG4gICAgZGVmYXVsdHMubGlzdE9mUHJvamVjdHNbMV0uYWRkVG9MaXN0KHRvRG9PYmopO1xuXG4gICAgXy50YWJsZS5hcHBlbmRDaGlsZChyb3cpO1xuICAgIGNyZWF0ZVRhc2tOYW1lLnZhbHVlID0gJyc7XG4gICAgY3JlYXRlVGFza0Rlc2NyaXB0aW9uLnZhbHVlID0gJyc7XG4gICAgY3JlYXRlVGFza0R1ZURhdGUudmFsdWUgPSBub3coKTtcbiAgICBjcmVhdGVUYXNrUHJpb3JpdHkudmFsdWUgPSAnTm9ybWFsJztcbiAgICBhZGRFdmVudExpc3RlbmVycygpO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgYWRkVG9Eb1RvVGFibGU7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/js/addToDo.js\n");

/***/ }),

/***/ "./src/js/createEditModal.js":
/*!***********************************!*\
  !*** ./src/js/createEditModal.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nconst createEditModal = (name, description, dueDate, priority) => {\n    \n    const newModal = document.createElement('dialog');\n    newModal.classList.add('editModal');\n    newModal.setAttribute('id', 'editModal');\n\n    const editModalHeader = document.createElement('h2');\n    editModalHeader.textContent = 'Edit Task';\n\n    const editModalForm = document.createElement('form');\n    editModalForm.classList.add('editForm');\n    editModalForm.setAttribute('method', 'dialog');\n\n    const taskNameDiv = document.createElement('div');\n    const taskName = document.createElement('input');\n    const taskNameLabel = document.createElement('label');\n    taskName.setAttribute('type', 'text');\n    taskName.setAttribute('name', 'taskName');\n    taskName.setAttribute('id', 'taskName');\n    taskName.setAttribute('placeholder', 'Take out the trash');\n    taskName.setAttribute('value', name);\n    taskNameLabel.setAttribute('for', 'taskName');\n    taskNameLabel.textContent = 'Title';\n    taskNameDiv.appendChild(taskNameLabel);\n    taskNameDiv.appendChild(taskName);\n\n    const taskDescriptionDiv = document.createElement('div');\n    const taskDescription = document.createElement('textarea');\n    const taskDescriptionLabel = document.createElement('label');\n    taskDescription.setAttribute('name', 'taskDescription');\n    taskDescription.setAttribute('id', 'taskDescription');\n    taskDescription.setAttribute('placeholder', 'I avoid the acumulation of trash by performing the sacred art of removing said trash...');\n    taskDescription.setAttribute('value', description);\n    taskDescriptionLabel.setAttribute('for', 'taskDescription');\n    taskDescriptionLabel.textContent = 'Description';\n    taskDescriptionDiv.appendChild(taskDescriptionLabel);\n    taskDescriptionDiv.appendChild(taskDescription);\n\n    const taskDueDateDiv = document.createElement('div');\n    const taskDueDate = document.createElement('input');\n    const taskDueDateLabel = document.createElement('label');\n    taskDueDate.setAttribute('type', 'datetime-local');\n    taskDueDate.setAttribute('name', 'taskDueDate');\n    taskDueDate.setAttribute('id', 'taskDueDate');\n    taskDueDate.setAttribute('value', dueDate);\n    taskDueDateLabel.setAttribute('for', 'taskDueDate');\n    taskDueDateLabel.textContent = 'Due Date';\n    taskDueDateDiv.appendChild(taskDueDateLabel);\n    taskDueDateDiv.appendChild(taskDueDate);\n\n    const taskPriorityDiv = document.createElement('div');\n    const taskPriority = document.createElement('select');\n    const taskPriorityLabel = document.createElement('label');\n    taskPriority.setAttribute('name', 'taskPriority');\n    taskPriority.setAttribute('id', 'taskPriority');\n    taskPriorityLabel.setAttribute('for', 'taskPriority');\n    taskPriorityLabel.textContent = 'Priority';\n    const highPriority = document.createElement('option');\n    highPriority.textContent = 'High';\n    const normalPriority = document.createElement('option');\n    normalPriority.textContent = 'Normal';\n    const lowPriority = document.createElement('option');\n    lowPriority.textContent = 'Low';\n    taskPriority.setAttribute('value', priority);\n    taskPriority.appendChild(highPriority);\n    taskPriority.appendChild(normalPriority);\n    taskPriority.appendChild(lowPriority);\n    taskPriorityDiv.appendChild(taskPriorityLabel);\n    taskPriorityDiv.appendChild(taskPriority);\n\n    const btns = document.createElement('div');\n    btns.classList.add('btns');\n    const submitBtn = document.createElement('button');\n    submitBtn.innerHTML = `<i class=\"fa-solid fa-check\"></i>`;\n    submitBtn.classList.add('submitEditBtn');\n    const cancelBtn = document.createElement('button');\n    cancelBtn.innerHTML = `<i class=\"fa-solid fa-ban\"></i>`;\n    cancelBtn.classList.add('cancelEditBtn');\n    btns.appendChild(submitBtn);\n    btns.appendChild(cancelBtn);\n\n    newModal.appendChild(editModalHeader);\n    editModalForm.appendChild(taskNameDiv);\n    editModalForm.appendChild(taskDescriptionDiv);\n    editModalForm.appendChild(taskDueDateDiv);\n    editModalForm.appendChild(taskPriorityDiv);\n    editModalForm.appendChild(btns);\n    newModal.appendChild(editModalForm);\n\n    return {newModal, editModalForm, taskName, taskDueDate, taskPriority, \n        taskDescription, submitBtn, cancelBtn};\n};\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (createEditModal);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvanMvY3JlYXRlRWRpdE1vZGFsLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsWUFBWTtBQUNaO0FBQ0E7O0FBRUEsaUVBQWUsZUFBZSIsInNvdXJjZXMiOlsid2VicGFjazovL3RvZG8tbGlzdC8uL3NyYy9qcy9jcmVhdGVFZGl0TW9kYWwuanM/NjgwMCJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBjcmVhdGVFZGl0TW9kYWwgPSAobmFtZSwgZGVzY3JpcHRpb24sIGR1ZURhdGUsIHByaW9yaXR5KSA9PiB7XG4gICAgXG4gICAgY29uc3QgbmV3TW9kYWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaWFsb2cnKTtcbiAgICBuZXdNb2RhbC5jbGFzc0xpc3QuYWRkKCdlZGl0TW9kYWwnKTtcbiAgICBuZXdNb2RhbC5zZXRBdHRyaWJ1dGUoJ2lkJywgJ2VkaXRNb2RhbCcpO1xuXG4gICAgY29uc3QgZWRpdE1vZGFsSGVhZGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaDInKTtcbiAgICBlZGl0TW9kYWxIZWFkZXIudGV4dENvbnRlbnQgPSAnRWRpdCBUYXNrJztcblxuICAgIGNvbnN0IGVkaXRNb2RhbEZvcm0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdmb3JtJyk7XG4gICAgZWRpdE1vZGFsRm9ybS5jbGFzc0xpc3QuYWRkKCdlZGl0Rm9ybScpO1xuICAgIGVkaXRNb2RhbEZvcm0uc2V0QXR0cmlidXRlKCdtZXRob2QnLCAnZGlhbG9nJyk7XG5cbiAgICBjb25zdCB0YXNrTmFtZURpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGNvbnN0IHRhc2tOYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcbiAgICBjb25zdCB0YXNrTmFtZUxhYmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGFiZWwnKTtcbiAgICB0YXNrTmFtZS5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCAndGV4dCcpO1xuICAgIHRhc2tOYW1lLnNldEF0dHJpYnV0ZSgnbmFtZScsICd0YXNrTmFtZScpO1xuICAgIHRhc2tOYW1lLnNldEF0dHJpYnV0ZSgnaWQnLCAndGFza05hbWUnKTtcbiAgICB0YXNrTmFtZS5zZXRBdHRyaWJ1dGUoJ3BsYWNlaG9sZGVyJywgJ1Rha2Ugb3V0IHRoZSB0cmFzaCcpO1xuICAgIHRhc2tOYW1lLnNldEF0dHJpYnV0ZSgndmFsdWUnLCBuYW1lKTtcbiAgICB0YXNrTmFtZUxhYmVsLnNldEF0dHJpYnV0ZSgnZm9yJywgJ3Rhc2tOYW1lJyk7XG4gICAgdGFza05hbWVMYWJlbC50ZXh0Q29udGVudCA9ICdUaXRsZSc7XG4gICAgdGFza05hbWVEaXYuYXBwZW5kQ2hpbGQodGFza05hbWVMYWJlbCk7XG4gICAgdGFza05hbWVEaXYuYXBwZW5kQ2hpbGQodGFza05hbWUpO1xuXG4gICAgY29uc3QgdGFza0Rlc2NyaXB0aW9uRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgY29uc3QgdGFza0Rlc2NyaXB0aW9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGV4dGFyZWEnKTtcbiAgICBjb25zdCB0YXNrRGVzY3JpcHRpb25MYWJlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xhYmVsJyk7XG4gICAgdGFza0Rlc2NyaXB0aW9uLnNldEF0dHJpYnV0ZSgnbmFtZScsICd0YXNrRGVzY3JpcHRpb24nKTtcbiAgICB0YXNrRGVzY3JpcHRpb24uc2V0QXR0cmlidXRlKCdpZCcsICd0YXNrRGVzY3JpcHRpb24nKTtcbiAgICB0YXNrRGVzY3JpcHRpb24uc2V0QXR0cmlidXRlKCdwbGFjZWhvbGRlcicsICdJIGF2b2lkIHRoZSBhY3VtdWxhdGlvbiBvZiB0cmFzaCBieSBwZXJmb3JtaW5nIHRoZSBzYWNyZWQgYXJ0IG9mIHJlbW92aW5nIHNhaWQgdHJhc2guLi4nKTtcbiAgICB0YXNrRGVzY3JpcHRpb24uc2V0QXR0cmlidXRlKCd2YWx1ZScsIGRlc2NyaXB0aW9uKTtcbiAgICB0YXNrRGVzY3JpcHRpb25MYWJlbC5zZXRBdHRyaWJ1dGUoJ2ZvcicsICd0YXNrRGVzY3JpcHRpb24nKTtcbiAgICB0YXNrRGVzY3JpcHRpb25MYWJlbC50ZXh0Q29udGVudCA9ICdEZXNjcmlwdGlvbic7XG4gICAgdGFza0Rlc2NyaXB0aW9uRGl2LmFwcGVuZENoaWxkKHRhc2tEZXNjcmlwdGlvbkxhYmVsKTtcbiAgICB0YXNrRGVzY3JpcHRpb25EaXYuYXBwZW5kQ2hpbGQodGFza0Rlc2NyaXB0aW9uKTtcblxuICAgIGNvbnN0IHRhc2tEdWVEYXRlRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgY29uc3QgdGFza0R1ZURhdGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpO1xuICAgIGNvbnN0IHRhc2tEdWVEYXRlTGFiZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsYWJlbCcpO1xuICAgIHRhc2tEdWVEYXRlLnNldEF0dHJpYnV0ZSgndHlwZScsICdkYXRldGltZS1sb2NhbCcpO1xuICAgIHRhc2tEdWVEYXRlLnNldEF0dHJpYnV0ZSgnbmFtZScsICd0YXNrRHVlRGF0ZScpO1xuICAgIHRhc2tEdWVEYXRlLnNldEF0dHJpYnV0ZSgnaWQnLCAndGFza0R1ZURhdGUnKTtcbiAgICB0YXNrRHVlRGF0ZS5zZXRBdHRyaWJ1dGUoJ3ZhbHVlJywgZHVlRGF0ZSk7XG4gICAgdGFza0R1ZURhdGVMYWJlbC5zZXRBdHRyaWJ1dGUoJ2ZvcicsICd0YXNrRHVlRGF0ZScpO1xuICAgIHRhc2tEdWVEYXRlTGFiZWwudGV4dENvbnRlbnQgPSAnRHVlIERhdGUnO1xuICAgIHRhc2tEdWVEYXRlRGl2LmFwcGVuZENoaWxkKHRhc2tEdWVEYXRlTGFiZWwpO1xuICAgIHRhc2tEdWVEYXRlRGl2LmFwcGVuZENoaWxkKHRhc2tEdWVEYXRlKTtcblxuICAgIGNvbnN0IHRhc2tQcmlvcml0eURpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGNvbnN0IHRhc2tQcmlvcml0eSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NlbGVjdCcpO1xuICAgIGNvbnN0IHRhc2tQcmlvcml0eUxhYmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGFiZWwnKTtcbiAgICB0YXNrUHJpb3JpdHkuc2V0QXR0cmlidXRlKCduYW1lJywgJ3Rhc2tQcmlvcml0eScpO1xuICAgIHRhc2tQcmlvcml0eS5zZXRBdHRyaWJ1dGUoJ2lkJywgJ3Rhc2tQcmlvcml0eScpO1xuICAgIHRhc2tQcmlvcml0eUxhYmVsLnNldEF0dHJpYnV0ZSgnZm9yJywgJ3Rhc2tQcmlvcml0eScpO1xuICAgIHRhc2tQcmlvcml0eUxhYmVsLnRleHRDb250ZW50ID0gJ1ByaW9yaXR5JztcbiAgICBjb25zdCBoaWdoUHJpb3JpdHkgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdvcHRpb24nKTtcbiAgICBoaWdoUHJpb3JpdHkudGV4dENvbnRlbnQgPSAnSGlnaCc7XG4gICAgY29uc3Qgbm9ybWFsUHJpb3JpdHkgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdvcHRpb24nKTtcbiAgICBub3JtYWxQcmlvcml0eS50ZXh0Q29udGVudCA9ICdOb3JtYWwnO1xuICAgIGNvbnN0IGxvd1ByaW9yaXR5ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnb3B0aW9uJyk7XG4gICAgbG93UHJpb3JpdHkudGV4dENvbnRlbnQgPSAnTG93JztcbiAgICB0YXNrUHJpb3JpdHkuc2V0QXR0cmlidXRlKCd2YWx1ZScsIHByaW9yaXR5KTtcbiAgICB0YXNrUHJpb3JpdHkuYXBwZW5kQ2hpbGQoaGlnaFByaW9yaXR5KTtcbiAgICB0YXNrUHJpb3JpdHkuYXBwZW5kQ2hpbGQobm9ybWFsUHJpb3JpdHkpO1xuICAgIHRhc2tQcmlvcml0eS5hcHBlbmRDaGlsZChsb3dQcmlvcml0eSk7XG4gICAgdGFza1ByaW9yaXR5RGl2LmFwcGVuZENoaWxkKHRhc2tQcmlvcml0eUxhYmVsKTtcbiAgICB0YXNrUHJpb3JpdHlEaXYuYXBwZW5kQ2hpbGQodGFza1ByaW9yaXR5KTtcblxuICAgIGNvbnN0IGJ0bnMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBidG5zLmNsYXNzTGlzdC5hZGQoJ2J0bnMnKTtcbiAgICBjb25zdCBzdWJtaXRCdG4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdidXR0b24nKTtcbiAgICBzdWJtaXRCdG4uaW5uZXJIVE1MID0gYDxpIGNsYXNzPVwiZmEtc29saWQgZmEtY2hlY2tcIj48L2k+YDtcbiAgICBzdWJtaXRCdG4uY2xhc3NMaXN0LmFkZCgnc3VibWl0RWRpdEJ0bicpO1xuICAgIGNvbnN0IGNhbmNlbEJ0biA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2J1dHRvbicpO1xuICAgIGNhbmNlbEJ0bi5pbm5lckhUTUwgPSBgPGkgY2xhc3M9XCJmYS1zb2xpZCBmYS1iYW5cIj48L2k+YDtcbiAgICBjYW5jZWxCdG4uY2xhc3NMaXN0LmFkZCgnY2FuY2VsRWRpdEJ0bicpO1xuICAgIGJ0bnMuYXBwZW5kQ2hpbGQoc3VibWl0QnRuKTtcbiAgICBidG5zLmFwcGVuZENoaWxkKGNhbmNlbEJ0bik7XG5cbiAgICBuZXdNb2RhbC5hcHBlbmRDaGlsZChlZGl0TW9kYWxIZWFkZXIpO1xuICAgIGVkaXRNb2RhbEZvcm0uYXBwZW5kQ2hpbGQodGFza05hbWVEaXYpO1xuICAgIGVkaXRNb2RhbEZvcm0uYXBwZW5kQ2hpbGQodGFza0Rlc2NyaXB0aW9uRGl2KTtcbiAgICBlZGl0TW9kYWxGb3JtLmFwcGVuZENoaWxkKHRhc2tEdWVEYXRlRGl2KTtcbiAgICBlZGl0TW9kYWxGb3JtLmFwcGVuZENoaWxkKHRhc2tQcmlvcml0eURpdik7XG4gICAgZWRpdE1vZGFsRm9ybS5hcHBlbmRDaGlsZChidG5zKTtcbiAgICBuZXdNb2RhbC5hcHBlbmRDaGlsZChlZGl0TW9kYWxGb3JtKTtcblxuICAgIHJldHVybiB7bmV3TW9kYWwsIGVkaXRNb2RhbEZvcm0sIHRhc2tOYW1lLCB0YXNrRHVlRGF0ZSwgdGFza1ByaW9yaXR5LCBcbiAgICAgICAgdGFza0Rlc2NyaXB0aW9uLCBzdWJtaXRCdG4sIGNhbmNlbEJ0bn07XG59O1xuXG5leHBvcnQgZGVmYXVsdCBjcmVhdGVFZGl0TW9kYWw7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/js/createEditModal.js\n");

/***/ }),

/***/ "./src/js/currentDate.js":
/*!*******************************!*\
  !*** ./src/js/currentDate.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"now\": () => (/* binding */ now),\n/* harmony export */   \"thisWeekCheck\": () => (/* binding */ thisWeekCheck),\n/* harmony export */   \"today\": () => (/* binding */ today),\n/* harmony export */   \"todayCheck\": () => (/* binding */ todayCheck)\n/* harmony export */ });\n/* harmony import */ var _js_temporal_polyfill__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @js-temporal/polyfill */ \"./node_modules/@js-temporal/polyfill/dist/index.esm.js\");\n\n\nconst now = () => {\n    return _js_temporal_polyfill__WEBPACK_IMPORTED_MODULE_0__.Temporal.Now.zonedDateTimeISO().toPlainDateTime().round({smallestUnit: \"minute\", roundingMode: \"floor\"}).toString();\n};\n\nconst today = () => {\n    return _js_temporal_polyfill__WEBPACK_IMPORTED_MODULE_0__.Temporal.Now.zonedDateTimeISO().toPlainDate().toString();\n};\n\nconst thisWeek = () => {\n    let today = _js_temporal_polyfill__WEBPACK_IMPORTED_MODULE_0__.Temporal.Now.zonedDateTimeISO()\n    let oneWeekFromToday = today.add({ days: 7});\n    return oneWeekFromToday.toPlainDate();\n};\n\nconst todayCheck = (yearCheck, monthCheck, dayCheck) => {\n    return _js_temporal_polyfill__WEBPACK_IMPORTED_MODULE_0__.Temporal.PlainDate.from({year: yearCheck, month: monthCheck, day: dayCheck}).equals(today());\n};\n\nconst thisWeekCheck = (yearCheck, monthCheck, dayCheck) => {\n\n    let convertedDate = _js_temporal_polyfill__WEBPACK_IMPORTED_MODULE_0__.Temporal.PlainDate.from({year: yearCheck, month: monthCheck, day: dayCheck});\n    let difference = convertedDate.until(thisWeek()).days;\n\n    if (+difference <= 7 && +difference >= 0){\n        return true;\n    }\n    else{\n        return false;\n    }\n};\n\n// export default { now, today, thisWeek };//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvanMvY3VycmVudERhdGUuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBaUQ7O0FBRTFDO0FBQ1AsV0FBVyxnRkFBNkIsNEJBQTRCLDhDQUE4QztBQUNsSDs7QUFFTztBQUNQLFdBQVcsZ0ZBQTZCO0FBQ3hDOztBQUVBO0FBQ0EsZ0JBQWdCLGdGQUE2QjtBQUM3Qyx1Q0FBdUMsUUFBUTtBQUMvQztBQUNBOztBQUVPO0FBQ1AsV0FBVywwRUFBdUIsRUFBRSxrREFBa0Q7QUFDdEY7O0FBRU87O0FBRVAsd0JBQXdCLDBFQUF1QixFQUFFLGtEQUFrRDtBQUNuRzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90b2RvLWxpc3QvLi9zcmMvanMvY3VycmVudERhdGUuanM/ZTU5MyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBUZW1wb3JhbCB9IGZyb20gXCJAanMtdGVtcG9yYWwvcG9seWZpbGxcIjtcblxuZXhwb3J0IGNvbnN0IG5vdyA9ICgpID0+IHtcbiAgICByZXR1cm4gVGVtcG9yYWwuTm93LnpvbmVkRGF0ZVRpbWVJU08oKS50b1BsYWluRGF0ZVRpbWUoKS5yb3VuZCh7c21hbGxlc3RVbml0OiBcIm1pbnV0ZVwiLCByb3VuZGluZ01vZGU6IFwiZmxvb3JcIn0pLnRvU3RyaW5nKCk7XG59O1xuXG5leHBvcnQgY29uc3QgdG9kYXkgPSAoKSA9PiB7XG4gICAgcmV0dXJuIFRlbXBvcmFsLk5vdy56b25lZERhdGVUaW1lSVNPKCkudG9QbGFpbkRhdGUoKS50b1N0cmluZygpO1xufTtcblxuY29uc3QgdGhpc1dlZWsgPSAoKSA9PiB7XG4gICAgbGV0IHRvZGF5ID0gVGVtcG9yYWwuTm93LnpvbmVkRGF0ZVRpbWVJU08oKVxuICAgIGxldCBvbmVXZWVrRnJvbVRvZGF5ID0gdG9kYXkuYWRkKHsgZGF5czogN30pO1xuICAgIHJldHVybiBvbmVXZWVrRnJvbVRvZGF5LnRvUGxhaW5EYXRlKCk7XG59O1xuXG5leHBvcnQgY29uc3QgdG9kYXlDaGVjayA9ICh5ZWFyQ2hlY2ssIG1vbnRoQ2hlY2ssIGRheUNoZWNrKSA9PiB7XG4gICAgcmV0dXJuIFRlbXBvcmFsLlBsYWluRGF0ZS5mcm9tKHt5ZWFyOiB5ZWFyQ2hlY2ssIG1vbnRoOiBtb250aENoZWNrLCBkYXk6IGRheUNoZWNrfSkuZXF1YWxzKHRvZGF5KCkpO1xufTtcblxuZXhwb3J0IGNvbnN0IHRoaXNXZWVrQ2hlY2sgPSAoeWVhckNoZWNrLCBtb250aENoZWNrLCBkYXlDaGVjaykgPT4ge1xuXG4gICAgbGV0IGNvbnZlcnRlZERhdGUgPSBUZW1wb3JhbC5QbGFpbkRhdGUuZnJvbSh7eWVhcjogeWVhckNoZWNrLCBtb250aDogbW9udGhDaGVjaywgZGF5OiBkYXlDaGVja30pO1xuICAgIGxldCBkaWZmZXJlbmNlID0gY29udmVydGVkRGF0ZS51bnRpbCh0aGlzV2VlaygpKS5kYXlzO1xuXG4gICAgaWYgKCtkaWZmZXJlbmNlIDw9IDcgJiYgK2RpZmZlcmVuY2UgPj0gMCl7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBlbHNle1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufTtcblxuLy8gZXhwb3J0IGRlZmF1bHQgeyBub3csIHRvZGF5LCB0aGlzV2VlayB9OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/js/currentDate.js\n");

/***/ }),

/***/ "./src/js/dateFilter.js":
/*!******************************!*\
  !*** ./src/js/dateFilter.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"convertDate\": () => (/* binding */ convertDate),\n/* harmony export */   \"dateFilter\": () => (/* binding */ dateFilter)\n/* harmony export */ });\n// 2022-03-16T03:52 => 03/16/2022 @ 03:52 AM\nconst dateFilter = (date) => {\n    let splitTimeAndDate = date.split('T');\n    let splitDate = splitTimeAndDate[0].split('-');\n    let splitTime = splitTimeAndDate[1].split(':');\n    let fixedHour = 0;\n    if(splitTime[0] >= 0 && splitTime[0] < 12){\n        fixedHour = splitTime[0]+ ':' + splitTime[1]+'AM';\n    }\n    else{\n        fixedHour = splitTime[0]+ ':' + splitTime[1]+'PM';  \n    }\n    let fixedDate = splitDate[1] + '/' + splitDate[2] + '/' + splitDate[0];\n    let fixedTimeAndDate =  fixedDate + ' @ ' + fixedHour;\n    return fixedTimeAndDate;\n}\nconst convertDate = (date) => {\n    let dd_date = date.value.substring(0, 10);\n\n    let dd_year = dd_date.substring(0, 4);\n    let dd_month = dd_date.substring(5, 7);\n    let dd_day = dd_date.substring(8, 10);\n    \n    return { dd_date, dd_year, dd_month, dd_day };\n};\n\n// 03/16/2022 @ 03:52 AM => 2022-03-26T11:46\n// export const undoDateFilter = (date) => {\n//     let splitDateAndTime = date.split(' @ ');\n//     let splitDate = splitDateAndTime[0].split('/');\n//     let splitTimeAndPeriod = splitDateAndTime[1].split(' ');\n//     let splitTime = splitTimeAndPeriod[0].split(':');\n//     let period = splitTimeAndPeriod[1];\n//     let fixedTime;\n//     if (period === 'PM'){\n//         fixedTime = ((+splitTime[0] + 12)+':'+splitTime[1]).toString();\n//     }\n//     else{\n//         fixedTime = splitTime[0]+':'+splitTime[1];\n//     }\n//     let fixedDateAndTime = splitDate[2] + '-' + splitDate[0] + '-' + splitDate[1] + 'T' + fixedTime;\n//     return fixedDateAndTime;\n// }//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvanMvZGF0ZUZpbHRlci5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdG9kby1saXN0Ly4vc3JjL2pzL2RhdGVGaWx0ZXIuanM/Mzc2NSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyAyMDIyLTAzLTE2VDAzOjUyID0+IDAzLzE2LzIwMjIgQCAwMzo1MiBBTVxuZXhwb3J0IGNvbnN0IGRhdGVGaWx0ZXIgPSAoZGF0ZSkgPT4ge1xuICAgIGxldCBzcGxpdFRpbWVBbmREYXRlID0gZGF0ZS5zcGxpdCgnVCcpO1xuICAgIGxldCBzcGxpdERhdGUgPSBzcGxpdFRpbWVBbmREYXRlWzBdLnNwbGl0KCctJyk7XG4gICAgbGV0IHNwbGl0VGltZSA9IHNwbGl0VGltZUFuZERhdGVbMV0uc3BsaXQoJzonKTtcbiAgICBsZXQgZml4ZWRIb3VyID0gMDtcbiAgICBpZihzcGxpdFRpbWVbMF0gPj0gMCAmJiBzcGxpdFRpbWVbMF0gPCAxMil7XG4gICAgICAgIGZpeGVkSG91ciA9IHNwbGl0VGltZVswXSsgJzonICsgc3BsaXRUaW1lWzFdKydBTSc7XG4gICAgfVxuICAgIGVsc2V7XG4gICAgICAgIGZpeGVkSG91ciA9IHNwbGl0VGltZVswXSsgJzonICsgc3BsaXRUaW1lWzFdKydQTSc7ICBcbiAgICB9XG4gICAgbGV0IGZpeGVkRGF0ZSA9IHNwbGl0RGF0ZVsxXSArICcvJyArIHNwbGl0RGF0ZVsyXSArICcvJyArIHNwbGl0RGF0ZVswXTtcbiAgICBsZXQgZml4ZWRUaW1lQW5kRGF0ZSA9ICBmaXhlZERhdGUgKyAnIEAgJyArIGZpeGVkSG91cjtcbiAgICByZXR1cm4gZml4ZWRUaW1lQW5kRGF0ZTtcbn1cbmV4cG9ydCBjb25zdCBjb252ZXJ0RGF0ZSA9IChkYXRlKSA9PiB7XG4gICAgbGV0IGRkX2RhdGUgPSBkYXRlLnZhbHVlLnN1YnN0cmluZygwLCAxMCk7XG5cbiAgICBsZXQgZGRfeWVhciA9IGRkX2RhdGUuc3Vic3RyaW5nKDAsIDQpO1xuICAgIGxldCBkZF9tb250aCA9IGRkX2RhdGUuc3Vic3RyaW5nKDUsIDcpO1xuICAgIGxldCBkZF9kYXkgPSBkZF9kYXRlLnN1YnN0cmluZyg4LCAxMCk7XG4gICAgXG4gICAgcmV0dXJuIHsgZGRfZGF0ZSwgZGRfeWVhciwgZGRfbW9udGgsIGRkX2RheSB9O1xufTtcblxuLy8gMDMvMTYvMjAyMiBAIDAzOjUyIEFNID0+IDIwMjItMDMtMjZUMTE6NDZcbi8vIGV4cG9ydCBjb25zdCB1bmRvRGF0ZUZpbHRlciA9IChkYXRlKSA9PiB7XG4vLyAgICAgbGV0IHNwbGl0RGF0ZUFuZFRpbWUgPSBkYXRlLnNwbGl0KCcgQCAnKTtcbi8vICAgICBsZXQgc3BsaXREYXRlID0gc3BsaXREYXRlQW5kVGltZVswXS5zcGxpdCgnLycpO1xuLy8gICAgIGxldCBzcGxpdFRpbWVBbmRQZXJpb2QgPSBzcGxpdERhdGVBbmRUaW1lWzFdLnNwbGl0KCcgJyk7XG4vLyAgICAgbGV0IHNwbGl0VGltZSA9IHNwbGl0VGltZUFuZFBlcmlvZFswXS5zcGxpdCgnOicpO1xuLy8gICAgIGxldCBwZXJpb2QgPSBzcGxpdFRpbWVBbmRQZXJpb2RbMV07XG4vLyAgICAgbGV0IGZpeGVkVGltZTtcbi8vICAgICBpZiAocGVyaW9kID09PSAnUE0nKXtcbi8vICAgICAgICAgZml4ZWRUaW1lID0gKCgrc3BsaXRUaW1lWzBdICsgMTIpKyc6JytzcGxpdFRpbWVbMV0pLnRvU3RyaW5nKCk7XG4vLyAgICAgfVxuLy8gICAgIGVsc2V7XG4vLyAgICAgICAgIGZpeGVkVGltZSA9IHNwbGl0VGltZVswXSsnOicrc3BsaXRUaW1lWzFdO1xuLy8gICAgIH1cbi8vICAgICBsZXQgZml4ZWREYXRlQW5kVGltZSA9IHNwbGl0RGF0ZVsyXSArICctJyArIHNwbGl0RGF0ZVswXSArICctJyArIHNwbGl0RGF0ZVsxXSArICdUJyArIGZpeGVkVGltZTtcbi8vICAgICByZXR1cm4gZml4ZWREYXRlQW5kVGltZTtcbi8vIH0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/js/dateFilter.js\n");

/***/ }),

/***/ "./src/js/defaultProjects.js":
/*!***********************************!*\
  !*** ./src/js/defaultProjects.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _project__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./project */ \"./src/js/project.js\");\n/* harmony import */ var _todo__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./todo */ \"./src/js/todo.js\");\n\n\n\nconst listOfProjects = [];\nlet currentProjectIndex = 0;\nlet projectCount = 0;\n\nconst defaultProj = (0,_project__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"Default\", \"The default grouping for toDos\", projectCount);\nlistOfProjects.push(defaultProj);\nprojectCount++;\nlet sampleObj = (0,_todo__WEBPACK_IMPORTED_MODULE_1__[\"default\"])('Default Task', 'Default Description', \"2022-03-16T03:52\", \"High\", 20);\ndefaultProj.addToList(sampleObj);\n\nconst everythingProj = (0,_project__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"Everything\", \"Every toDo\", projectCount);\nprojectCount++;\nlistOfProjects.push(everythingProj);\n\nconst todaysToDos = (0,_project__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"Today\", \"Today's Tasks\", projectCount);\nprojectCount++;\nlistOfProjects.push(todaysToDos);\nlet sampleObj2 = (0,_todo__WEBPACK_IMPORTED_MODULE_1__[\"default\"])('Today Task', 'Default Description', \"2022-03-16T03:52\", \"High\", 30);\ntodaysToDos.addToList(sampleObj2);\n\nconst thisWeeksToDos = (0,_project__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"This Week\", \"This week's projects\", projectCount);\nprojectCount++;\nlistOfProjects.push(thisWeeksToDos);\nlet sampleObj3 = (0,_todo__WEBPACK_IMPORTED_MODULE_1__[\"default\"])('Week Task', 'Default Description', \"2022-03-16T03:52\", \"High\", 40);\nthisWeeksToDos.addToList(sampleObj3);\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({ listOfProjects, currentProjectIndex, defaultProj, todaysToDos, thisWeeksToDos });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvanMvZGVmYXVsdFByb2plY3RzLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFnQztBQUNOOztBQUUxQjtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLG9EQUFPO0FBQzNCO0FBQ0E7QUFDQSxnQkFBZ0IsaURBQUk7QUFDcEI7O0FBRUEsdUJBQXVCLG9EQUFPO0FBQzlCO0FBQ0E7O0FBRUEsb0JBQW9CLG9EQUFPO0FBQzNCO0FBQ0E7QUFDQSxpQkFBaUIsaURBQUk7QUFDckI7O0FBRUEsdUJBQXVCLG9EQUFPO0FBQzlCO0FBQ0E7QUFDQSxpQkFBaUIsaURBQUk7QUFDckI7O0FBRUEsaUVBQWUsRUFBRSwrRUFBK0UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90b2RvLWxpc3QvLi9zcmMvanMvZGVmYXVsdFByb2plY3RzLmpzPzY3YTUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFByb2plY3QgZnJvbSAnLi9wcm9qZWN0JztcbmltcG9ydCBUb2RvIGZyb20gJy4vdG9kbyc7XG5cbmNvbnN0IGxpc3RPZlByb2plY3RzID0gW107XG5sZXQgY3VycmVudFByb2plY3RJbmRleCA9IDA7XG5sZXQgcHJvamVjdENvdW50ID0gMDtcblxuY29uc3QgZGVmYXVsdFByb2ogPSBQcm9qZWN0KFwiRGVmYXVsdFwiLCBcIlRoZSBkZWZhdWx0IGdyb3VwaW5nIGZvciB0b0Rvc1wiLCBwcm9qZWN0Q291bnQpO1xubGlzdE9mUHJvamVjdHMucHVzaChkZWZhdWx0UHJvaik7XG5wcm9qZWN0Q291bnQrKztcbmxldCBzYW1wbGVPYmogPSBUb2RvKCdEZWZhdWx0IFRhc2snLCAnRGVmYXVsdCBEZXNjcmlwdGlvbicsIFwiMjAyMi0wMy0xNlQwMzo1MlwiLCBcIkhpZ2hcIiwgMjApO1xuZGVmYXVsdFByb2ouYWRkVG9MaXN0KHNhbXBsZU9iaik7XG5cbmNvbnN0IGV2ZXJ5dGhpbmdQcm9qID0gUHJvamVjdChcIkV2ZXJ5dGhpbmdcIiwgXCJFdmVyeSB0b0RvXCIsIHByb2plY3RDb3VudCk7XG5wcm9qZWN0Q291bnQrKztcbmxpc3RPZlByb2plY3RzLnB1c2goZXZlcnl0aGluZ1Byb2opO1xuXG5jb25zdCB0b2RheXNUb0RvcyA9IFByb2plY3QoXCJUb2RheVwiLCBcIlRvZGF5J3MgVGFza3NcIiwgcHJvamVjdENvdW50KTtcbnByb2plY3RDb3VudCsrO1xubGlzdE9mUHJvamVjdHMucHVzaCh0b2RheXNUb0Rvcyk7XG5sZXQgc2FtcGxlT2JqMiA9IFRvZG8oJ1RvZGF5IFRhc2snLCAnRGVmYXVsdCBEZXNjcmlwdGlvbicsIFwiMjAyMi0wMy0xNlQwMzo1MlwiLCBcIkhpZ2hcIiwgMzApO1xudG9kYXlzVG9Eb3MuYWRkVG9MaXN0KHNhbXBsZU9iajIpO1xuXG5jb25zdCB0aGlzV2Vla3NUb0RvcyA9IFByb2plY3QoXCJUaGlzIFdlZWtcIiwgXCJUaGlzIHdlZWsncyBwcm9qZWN0c1wiLCBwcm9qZWN0Q291bnQpO1xucHJvamVjdENvdW50Kys7XG5saXN0T2ZQcm9qZWN0cy5wdXNoKHRoaXNXZWVrc1RvRG9zKTtcbmxldCBzYW1wbGVPYmozID0gVG9kbygnV2VlayBUYXNrJywgJ0RlZmF1bHQgRGVzY3JpcHRpb24nLCBcIjIwMjItMDMtMTZUMDM6NTJcIiwgXCJIaWdoXCIsIDQwKTtcbnRoaXNXZWVrc1RvRG9zLmFkZFRvTGlzdChzYW1wbGVPYmozKTtcblxuZXhwb3J0IGRlZmF1bHQgeyBsaXN0T2ZQcm9qZWN0cywgY3VycmVudFByb2plY3RJbmRleCwgZGVmYXVsdFByb2osIHRvZGF5c1RvRG9zLCB0aGlzV2Vla3NUb0RvcyB9OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/js/defaultProjects.js\n");

/***/ }),

/***/ "./src/js/documentParts.js":
/*!*********************************!*\
  !*** ./src/js/documentParts.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nconst body = document.querySelector('body');\nconst todaysToDos = document.querySelector('.today');\nconst thisWeeksToDos = document.querySelector('.week');\nconst categories = document.querySelector('.categories');\nconst defaultProject = document.querySelector('.defaultProject');\nconst addProjectBtn = document.querySelector('.addProjectBtn');\nconst toDoList = document.querySelector('.todoList');\nconst table = document.querySelector('table');\nconst tableTitle = document.querySelector('.titles.projName');\nconst tableDueDate = document.querySelector('.titles.dueDate');\nconst addToDoBtn = document.querySelector('.addToDoBtn');\nconst modal = document.querySelector('#modal');\nconst editModal = document.querySelector('#editModal');\nconst creationModalTaskName = document.querySelector('.createTaskName');\nconst creationModalTaskDescription = document.querySelector('.createTaskDescription');\nconst creationModalTaskDueDate = document.querySelector('.createTaskDueDate');\nconst creationModalTaskPriority = document.querySelector('.createTaskPriority');\nconst modalCancelBtn = document.querySelector('.createModalCancelBtn');\nconst modalSubmitBtn = document.querySelector('.createModalSubmitBtn');\nconst toDoCounter = 0;\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({ \n    \nbody, todaysToDos, thisWeeksToDos, categories, defaultProject,\ntoDoList, table, tableTitle, tableDueDate, addToDoBtn, toDoCounter, modal, \ncreationModalTaskName, creationModalTaskDescription, creationModalTaskDueDate,\ncreationModalTaskPriority, editModal, modalCancelBtn, modalSubmitBtn, addProjectBtn \n\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvanMvZG9jdW1lbnRQYXJ0cy5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpRUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3RvZG8tbGlzdC8uL3NyYy9qcy9kb2N1bWVudFBhcnRzLmpzPzY5ZWQiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgYm9keSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2JvZHknKTtcbmNvbnN0IHRvZGF5c1RvRG9zID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLnRvZGF5Jyk7XG5jb25zdCB0aGlzV2Vla3NUb0RvcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy53ZWVrJyk7XG5jb25zdCBjYXRlZ29yaWVzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmNhdGVnb3JpZXMnKTtcbmNvbnN0IGRlZmF1bHRQcm9qZWN0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmRlZmF1bHRQcm9qZWN0Jyk7XG5jb25zdCBhZGRQcm9qZWN0QnRuID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmFkZFByb2plY3RCdG4nKTtcbmNvbnN0IHRvRG9MaXN0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLnRvZG9MaXN0Jyk7XG5jb25zdCB0YWJsZSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ3RhYmxlJyk7XG5jb25zdCB0YWJsZVRpdGxlID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLnRpdGxlcy5wcm9qTmFtZScpO1xuY29uc3QgdGFibGVEdWVEYXRlID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLnRpdGxlcy5kdWVEYXRlJyk7XG5jb25zdCBhZGRUb0RvQnRuID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmFkZFRvRG9CdG4nKTtcbmNvbnN0IG1vZGFsID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI21vZGFsJyk7XG5jb25zdCBlZGl0TW9kYWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjZWRpdE1vZGFsJyk7XG5jb25zdCBjcmVhdGlvbk1vZGFsVGFza05hbWUgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuY3JlYXRlVGFza05hbWUnKTtcbmNvbnN0IGNyZWF0aW9uTW9kYWxUYXNrRGVzY3JpcHRpb24gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuY3JlYXRlVGFza0Rlc2NyaXB0aW9uJyk7XG5jb25zdCBjcmVhdGlvbk1vZGFsVGFza0R1ZURhdGUgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuY3JlYXRlVGFza0R1ZURhdGUnKTtcbmNvbnN0IGNyZWF0aW9uTW9kYWxUYXNrUHJpb3JpdHkgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuY3JlYXRlVGFza1ByaW9yaXR5Jyk7XG5jb25zdCBtb2RhbENhbmNlbEJ0biA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5jcmVhdGVNb2RhbENhbmNlbEJ0bicpO1xuY29uc3QgbW9kYWxTdWJtaXRCdG4gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuY3JlYXRlTW9kYWxTdWJtaXRCdG4nKTtcbmNvbnN0IHRvRG9Db3VudGVyID0gMDtcblxuZXhwb3J0IGRlZmF1bHQgeyBcbiAgICBcbmJvZHksIHRvZGF5c1RvRG9zLCB0aGlzV2Vla3NUb0RvcywgY2F0ZWdvcmllcywgZGVmYXVsdFByb2plY3QsXG50b0RvTGlzdCwgdGFibGUsIHRhYmxlVGl0bGUsIHRhYmxlRHVlRGF0ZSwgYWRkVG9Eb0J0biwgdG9Eb0NvdW50ZXIsIG1vZGFsLCBcbmNyZWF0aW9uTW9kYWxUYXNrTmFtZSwgY3JlYXRpb25Nb2RhbFRhc2tEZXNjcmlwdGlvbiwgY3JlYXRpb25Nb2RhbFRhc2tEdWVEYXRlLFxuY3JlYXRpb25Nb2RhbFRhc2tQcmlvcml0eSwgZWRpdE1vZGFsLCBtb2RhbENhbmNlbEJ0biwgbW9kYWxTdWJtaXRCdG4sIGFkZFByb2plY3RCdG4gXG5cbn07Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/js/documentParts.js\n");

/***/ }),

/***/ "./src/js/project.js":
/*!***************************!*\
  !*** ./src/js/project.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nconst Project = (title, description, index) => {\n\n    let arr = [];\n\n    const getTitle = () => title;\n    const getDescription = () => description;\n    const getIndex = () => index;\n    \n    const setTitle = (newTitle) => title = newTitle; \n    const setDescription = (newDescription) => description = newDescription;\n    const setIndex = (newIndex) => index = newIndex;\n\n    const addToList = (obj) => arr.push(obj);\n    const removeFromList = (index) => {\n        if(index > -1){\n            arr.splice(index, 1);\n        }\n    }\n\n    return {getTitle, getDescription, getIndex, setTitle, \n        setDescription, setIndex, arr, addToList, removeFromList};\n};\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Project);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvanMvcHJvamVjdC5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFlBQVk7QUFDWjtBQUNBOztBQUVBLGlFQUFlLE9BQU8iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90b2RvLWxpc3QvLi9zcmMvanMvcHJvamVjdC5qcz9lZjU4Il0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IFByb2plY3QgPSAodGl0bGUsIGRlc2NyaXB0aW9uLCBpbmRleCkgPT4ge1xuXG4gICAgbGV0IGFyciA9IFtdO1xuXG4gICAgY29uc3QgZ2V0VGl0bGUgPSAoKSA9PiB0aXRsZTtcbiAgICBjb25zdCBnZXREZXNjcmlwdGlvbiA9ICgpID0+IGRlc2NyaXB0aW9uO1xuICAgIGNvbnN0IGdldEluZGV4ID0gKCkgPT4gaW5kZXg7XG4gICAgXG4gICAgY29uc3Qgc2V0VGl0bGUgPSAobmV3VGl0bGUpID0+IHRpdGxlID0gbmV3VGl0bGU7IFxuICAgIGNvbnN0IHNldERlc2NyaXB0aW9uID0gKG5ld0Rlc2NyaXB0aW9uKSA9PiBkZXNjcmlwdGlvbiA9IG5ld0Rlc2NyaXB0aW9uO1xuICAgIGNvbnN0IHNldEluZGV4ID0gKG5ld0luZGV4KSA9PiBpbmRleCA9IG5ld0luZGV4O1xuXG4gICAgY29uc3QgYWRkVG9MaXN0ID0gKG9iaikgPT4gYXJyLnB1c2gob2JqKTtcbiAgICBjb25zdCByZW1vdmVGcm9tTGlzdCA9IChpbmRleCkgPT4ge1xuICAgICAgICBpZihpbmRleCA+IC0xKXtcbiAgICAgICAgICAgIGFyci5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtnZXRUaXRsZSwgZ2V0RGVzY3JpcHRpb24sIGdldEluZGV4LCBzZXRUaXRsZSwgXG4gICAgICAgIHNldERlc2NyaXB0aW9uLCBzZXRJbmRleCwgYXJyLCBhZGRUb0xpc3QsIHJlbW92ZUZyb21MaXN0fTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IFByb2plY3Q7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/js/project.js\n");

/***/ }),

/***/ "./src/js/projectPageGeneration.js":
/*!*****************************************!*\
  !*** ./src/js/projectPageGeneration.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _documentParts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./documentParts */ \"./src/js/documentParts.js\");\n/* harmony import */ var _defaultProjects__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./defaultProjects */ \"./src/js/defaultProjects.js\");\n/* harmony import */ var _addListeners__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./addListeners */ \"./src/js/addListeners.js\");\n/* harmony import */ var _dateFilter__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./dateFilter */ \"./src/js/dateFilter.js\");\n\n\n\n\n\nconst clearOldProject = () => {\n    _documentParts__WEBPACK_IMPORTED_MODULE_0__[\"default\"].table.textContent = '';\n};\n\nconst generateProject = (selectedProject, projectIndex) => {\n    _defaultProjects__WEBPACK_IMPORTED_MODULE_1__[\"default\"].currentProjectIndex = projectIndex;\n    clearOldProject();\n    generateTableHeader();\n    generateRows(selectedProject);\n    (0,_addListeners__WEBPACK_IMPORTED_MODULE_2__[\"default\"])();\n};\n\nconst generateTableHeader = () => {\n    let tr = document.createElement('tr');\n    tr.classList.add('titles');\n    let thProjName = document.createElement('th');\n    thProjName.classList.add('projName');\n    thProjName.textContent = 'DEFAULT';\n    let thDueDate = document.createElement('th');\n    thDueDate.classList.add('dueDate');\n    thDueDate.innerHTML = `DUE DATE <i class=\"fa-solid fa-arrow-down\"></i>`;\n    tr.appendChild(thProjName);\n    tr.appendChild(thDueDate);\n    _documentParts__WEBPACK_IMPORTED_MODULE_0__[\"default\"].table.appendChild(tr);\n};\n\nconst generateRows = (selectedProject) => {\n\n    const makeRow = (row) => {\n        const tr = document.createElement('tr');\n        tr.classList.add('createdRow');\n        tr.setAttribute('data-index', `${row.getID()}`);\n        const td1 = document.createElement('td');\n        const td2 = document.createElement('td');\n        td1.classList.add('column1');\n        td2.classList.add('column2');\n\n        td1.innerHTML = `<i class=\"fa-regular fa-square\"></i> ${row.getTitle()}`;\n        td2.innerHTML = `${(0,_dateFilter__WEBPACK_IMPORTED_MODULE_3__.dateFilter)(row.getDueDate())} <i class=\"fa-regular fa-pen-to-square\"></i><i class=\"fa-regular fa-trash-can\"></i>`;\n\n        tr.appendChild(td1);\n        tr.appendChild(td2);\n\n        return tr;\n    };\n    \n    for(let i = 0; i < selectedProject.arr.length; i++){\n        _documentParts__WEBPACK_IMPORTED_MODULE_0__[\"default\"].table.appendChild(makeRow(selectedProject.arr[i]));\n    }\n\n};\n\nconst generateTodaysToDos = () => {\n    generateProject(_defaultProjects__WEBPACK_IMPORTED_MODULE_1__[\"default\"].todaysToDos, 2);\n}\n\nconst generateThisWeeksToDos = () => {\n    generateProject(_defaultProjects__WEBPACK_IMPORTED_MODULE_1__[\"default\"].thisWeeksToDos, 3);\n}\n\nconst generateDefaultToDos = () => {\n    generateProject(_defaultProjects__WEBPACK_IMPORTED_MODULE_1__[\"default\"].defaultProj, 0);\n}\n\nconst setupDefaultProjects = () => {\n    _documentParts__WEBPACK_IMPORTED_MODULE_0__[\"default\"].todaysToDos.addEventListener('click', generateTodaysToDos);\n    _documentParts__WEBPACK_IMPORTED_MODULE_0__[\"default\"].thisWeeksToDos.addEventListener('click', generateThisWeeksToDos);\n    _documentParts__WEBPACK_IMPORTED_MODULE_0__[\"default\"].defaultProject.addEventListener('click', generateDefaultToDos);\n}\n\nsetupDefaultProjects();\n\ngenerateProject(_defaultProjects__WEBPACK_IMPORTED_MODULE_1__[\"default\"].listOfProjects[_defaultProjects__WEBPACK_IMPORTED_MODULE_1__[\"default\"].currentProjectIndex], _defaultProjects__WEBPACK_IMPORTED_MODULE_1__[\"default\"].currentProjectIndex);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvanMvcHJvamVjdFBhZ2VHZW5lcmF0aW9uLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQWdDO0FBQ1M7QUFDTTtBQUNMOztBQUUxQztBQUNBLElBQUksd0VBQW1CO0FBQ3ZCOztBQUVBO0FBQ0EsSUFBSSw0RUFBNEI7QUFDaEM7QUFDQTtBQUNBO0FBQ0EsSUFBSSx5REFBaUI7QUFDckI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksd0VBQW1CO0FBQ3ZCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxZQUFZO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdFQUFnRSxlQUFlO0FBQy9FLDJCQUEyQix1REFBVSxvQkFBb0I7O0FBRXpEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGdDQUFnQztBQUNuRCxRQUFRLHdFQUFtQjtBQUMzQjs7QUFFQTs7QUFFQTtBQUNBLG9CQUFvQixvRUFBb0I7QUFDeEM7O0FBRUE7QUFDQSxvQkFBb0IsdUVBQXVCO0FBQzNDOztBQUVBO0FBQ0Esb0JBQW9CLG9FQUFvQjtBQUN4Qzs7QUFFQTtBQUNBLElBQUksbUZBQThCO0FBQ2xDLElBQUksc0ZBQWlDO0FBQ3JDLElBQUksc0ZBQWlDO0FBQ3JDOztBQUVBOztBQUVBLGdCQUFnQix1RUFBdUIsQ0FBQyw0RUFBNEIsR0FBRyw0RUFBNEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90b2RvLWxpc3QvLi9zcmMvanMvcHJvamVjdFBhZ2VHZW5lcmF0aW9uLmpzPzY3MjMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IF8gZnJvbSAnLi9kb2N1bWVudFBhcnRzJztcbmltcG9ydCBkZWZhdWx0cyBmcm9tICcuL2RlZmF1bHRQcm9qZWN0cyc7XG5pbXBvcnQgYWRkRXZlbnRMaXN0ZW5lcnMgZnJvbSAnLi9hZGRMaXN0ZW5lcnMnO1xuaW1wb3J0IHsgZGF0ZUZpbHRlciB9IGZyb20gJy4vZGF0ZUZpbHRlcic7XG5cbmNvbnN0IGNsZWFyT2xkUHJvamVjdCA9ICgpID0+IHtcbiAgICBfLnRhYmxlLnRleHRDb250ZW50ID0gJyc7XG59O1xuXG5jb25zdCBnZW5lcmF0ZVByb2plY3QgPSAoc2VsZWN0ZWRQcm9qZWN0LCBwcm9qZWN0SW5kZXgpID0+IHtcbiAgICBkZWZhdWx0cy5jdXJyZW50UHJvamVjdEluZGV4ID0gcHJvamVjdEluZGV4O1xuICAgIGNsZWFyT2xkUHJvamVjdCgpO1xuICAgIGdlbmVyYXRlVGFibGVIZWFkZXIoKTtcbiAgICBnZW5lcmF0ZVJvd3Moc2VsZWN0ZWRQcm9qZWN0KTtcbiAgICBhZGRFdmVudExpc3RlbmVycygpO1xufTtcblxuY29uc3QgZ2VuZXJhdGVUYWJsZUhlYWRlciA9ICgpID0+IHtcbiAgICBsZXQgdHIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0cicpO1xuICAgIHRyLmNsYXNzTGlzdC5hZGQoJ3RpdGxlcycpO1xuICAgIGxldCB0aFByb2pOYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGgnKTtcbiAgICB0aFByb2pOYW1lLmNsYXNzTGlzdC5hZGQoJ3Byb2pOYW1lJyk7XG4gICAgdGhQcm9qTmFtZS50ZXh0Q29udGVudCA9ICdERUZBVUxUJztcbiAgICBsZXQgdGhEdWVEYXRlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGgnKTtcbiAgICB0aER1ZURhdGUuY2xhc3NMaXN0LmFkZCgnZHVlRGF0ZScpO1xuICAgIHRoRHVlRGF0ZS5pbm5lckhUTUwgPSBgRFVFIERBVEUgPGkgY2xhc3M9XCJmYS1zb2xpZCBmYS1hcnJvdy1kb3duXCI+PC9pPmA7XG4gICAgdHIuYXBwZW5kQ2hpbGQodGhQcm9qTmFtZSk7XG4gICAgdHIuYXBwZW5kQ2hpbGQodGhEdWVEYXRlKTtcbiAgICBfLnRhYmxlLmFwcGVuZENoaWxkKHRyKTtcbn07XG5cbmNvbnN0IGdlbmVyYXRlUm93cyA9IChzZWxlY3RlZFByb2plY3QpID0+IHtcblxuICAgIGNvbnN0IG1ha2VSb3cgPSAocm93KSA9PiB7XG4gICAgICAgIGNvbnN0IHRyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndHInKTtcbiAgICAgICAgdHIuY2xhc3NMaXN0LmFkZCgnY3JlYXRlZFJvdycpO1xuICAgICAgICB0ci5zZXRBdHRyaWJ1dGUoJ2RhdGEtaW5kZXgnLCBgJHtyb3cuZ2V0SUQoKX1gKTtcbiAgICAgICAgY29uc3QgdGQxID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGQnKTtcbiAgICAgICAgY29uc3QgdGQyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGQnKTtcbiAgICAgICAgdGQxLmNsYXNzTGlzdC5hZGQoJ2NvbHVtbjEnKTtcbiAgICAgICAgdGQyLmNsYXNzTGlzdC5hZGQoJ2NvbHVtbjInKTtcblxuICAgICAgICB0ZDEuaW5uZXJIVE1MID0gYDxpIGNsYXNzPVwiZmEtcmVndWxhciBmYS1zcXVhcmVcIj48L2k+ICR7cm93LmdldFRpdGxlKCl9YDtcbiAgICAgICAgdGQyLmlubmVySFRNTCA9IGAke2RhdGVGaWx0ZXIocm93LmdldER1ZURhdGUoKSl9IDxpIGNsYXNzPVwiZmEtcmVndWxhciBmYS1wZW4tdG8tc3F1YXJlXCI+PC9pPjxpIGNsYXNzPVwiZmEtcmVndWxhciBmYS10cmFzaC1jYW5cIj48L2k+YDtcblxuICAgICAgICB0ci5hcHBlbmRDaGlsZCh0ZDEpO1xuICAgICAgICB0ci5hcHBlbmRDaGlsZCh0ZDIpO1xuXG4gICAgICAgIHJldHVybiB0cjtcbiAgICB9O1xuICAgIFxuICAgIGZvcihsZXQgaSA9IDA7IGkgPCBzZWxlY3RlZFByb2plY3QuYXJyLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgXy50YWJsZS5hcHBlbmRDaGlsZChtYWtlUm93KHNlbGVjdGVkUHJvamVjdC5hcnJbaV0pKTtcbiAgICB9XG5cbn07XG5cbmNvbnN0IGdlbmVyYXRlVG9kYXlzVG9Eb3MgPSAoKSA9PiB7XG4gICAgZ2VuZXJhdGVQcm9qZWN0KGRlZmF1bHRzLnRvZGF5c1RvRG9zLCAyKTtcbn1cblxuY29uc3QgZ2VuZXJhdGVUaGlzV2Vla3NUb0RvcyA9ICgpID0+IHtcbiAgICBnZW5lcmF0ZVByb2plY3QoZGVmYXVsdHMudGhpc1dlZWtzVG9Eb3MsIDMpO1xufVxuXG5jb25zdCBnZW5lcmF0ZURlZmF1bHRUb0RvcyA9ICgpID0+IHtcbiAgICBnZW5lcmF0ZVByb2plY3QoZGVmYXVsdHMuZGVmYXVsdFByb2osIDApO1xufVxuXG5jb25zdCBzZXR1cERlZmF1bHRQcm9qZWN0cyA9ICgpID0+IHtcbiAgICBfLnRvZGF5c1RvRG9zLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZ2VuZXJhdGVUb2RheXNUb0Rvcyk7XG4gICAgXy50aGlzV2Vla3NUb0Rvcy5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGdlbmVyYXRlVGhpc1dlZWtzVG9Eb3MpO1xuICAgIF8uZGVmYXVsdFByb2plY3QuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBnZW5lcmF0ZURlZmF1bHRUb0Rvcyk7XG59XG5cbnNldHVwRGVmYXVsdFByb2plY3RzKCk7XG5cbmdlbmVyYXRlUHJvamVjdChkZWZhdWx0cy5saXN0T2ZQcm9qZWN0c1tkZWZhdWx0cy5jdXJyZW50UHJvamVjdEluZGV4XSwgZGVmYXVsdHMuY3VycmVudFByb2plY3RJbmRleCk7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/js/projectPageGeneration.js\n");

/***/ }),

/***/ "./src/js/todo.js":
/*!************************!*\
  !*** ./src/js/todo.js ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nconst Todo = (title, description, dueDate, priority, id) => {\n    \n    const getTitle = () => title;\n    const getDescription = () => description;\n    const getDueDate = () => dueDate;\n    const getPriority = () => priority;\n    const getID = () => id;\n\n    const setTitle = (newTitle) => title = newTitle; \n    const setDescription = (newDescription) => description = newDescription;\n    const setDueDate = (newDueDate) => dueDate = newDueDate;\n    const setPriority = (newPriority) => priority = newPriority;\n    const setID = (newID) => id = newID;\n\n    return {getTitle, getDescription, getDueDate, getPriority, getID, setTitle, setDescription, setDueDate, setPriority, setID};\n};\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Todo);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvanMvdG9kby5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxZQUFZO0FBQ1o7O0FBRUEsaUVBQWUsSUFBSSIsInNvdXJjZXMiOlsid2VicGFjazovL3RvZG8tbGlzdC8uL3NyYy9qcy90b2RvLmpzP2VhM2QiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgVG9kbyA9ICh0aXRsZSwgZGVzY3JpcHRpb24sIGR1ZURhdGUsIHByaW9yaXR5LCBpZCkgPT4ge1xuICAgIFxuICAgIGNvbnN0IGdldFRpdGxlID0gKCkgPT4gdGl0bGU7XG4gICAgY29uc3QgZ2V0RGVzY3JpcHRpb24gPSAoKSA9PiBkZXNjcmlwdGlvbjtcbiAgICBjb25zdCBnZXREdWVEYXRlID0gKCkgPT4gZHVlRGF0ZTtcbiAgICBjb25zdCBnZXRQcmlvcml0eSA9ICgpID0+IHByaW9yaXR5O1xuICAgIGNvbnN0IGdldElEID0gKCkgPT4gaWQ7XG5cbiAgICBjb25zdCBzZXRUaXRsZSA9IChuZXdUaXRsZSkgPT4gdGl0bGUgPSBuZXdUaXRsZTsgXG4gICAgY29uc3Qgc2V0RGVzY3JpcHRpb24gPSAobmV3RGVzY3JpcHRpb24pID0+IGRlc2NyaXB0aW9uID0gbmV3RGVzY3JpcHRpb247XG4gICAgY29uc3Qgc2V0RHVlRGF0ZSA9IChuZXdEdWVEYXRlKSA9PiBkdWVEYXRlID0gbmV3RHVlRGF0ZTtcbiAgICBjb25zdCBzZXRQcmlvcml0eSA9IChuZXdQcmlvcml0eSkgPT4gcHJpb3JpdHkgPSBuZXdQcmlvcml0eTtcbiAgICBjb25zdCBzZXRJRCA9IChuZXdJRCkgPT4gaWQgPSBuZXdJRDtcblxuICAgIHJldHVybiB7Z2V0VGl0bGUsIGdldERlc2NyaXB0aW9uLCBnZXREdWVEYXRlLCBnZXRQcmlvcml0eSwgZ2V0SUQsIHNldFRpdGxlLCBzZXREZXNjcmlwdGlvbiwgc2V0RHVlRGF0ZSwgc2V0UHJpb3JpdHksIHNldElEfTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IFRvZG87Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/js/todo.js\n");

/***/ }),

/***/ "./node_modules/@js-temporal/polyfill/dist/index.esm.js":
/*!**************************************************************!*\
  !*** ./node_modules/@js-temporal/polyfill/dist/index.esm.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Intl\": () => (/* binding */ intl),\n/* harmony export */   \"Temporal\": () => (/* binding */ temporal),\n/* harmony export */   \"toTemporalInstant\": () => (/* binding */ toTemporalInstant)\n/* harmony export */ });\n/* harmony import */ var jsbi__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jsbi */ \"./node_modules/jsbi/dist/jsbi-umd.js\");\n\n\nconst INTRINSICS = {};\nconst customUtilInspectFormatters = {\n    ['Temporal.Duration'](depth, options) {\n        const descr = options.stylize(`${this[Symbol.toStringTag]} <${this}>`, 'special');\n        if (depth < 1)\n            return descr;\n        const entries = [];\n        for (const prop of [\n            'years',\n            'months',\n            'weeks',\n            'days',\n            'hours',\n            'minutes',\n            'seconds',\n            'milliseconds',\n            'microseconds',\n            'nanoseconds'\n        ]) {\n            if (this[prop] !== 0)\n                entries.push(`  ${prop}: ${options.stylize(this[prop], 'number')}`);\n        }\n        return descr + ' {\\n' + entries.join(',\\n') + '\\n}';\n    }\n};\nfunction defaultUtilInspectFormatter(depth, options) {\n    return options.stylize(`${this[Symbol.toStringTag]} <${this}>`, 'special');\n}\nfunction MakeIntrinsicClass(Class, name) {\n    Object.defineProperty(Class.prototype, Symbol.toStringTag, {\n        value: name,\n        writable: false,\n        enumerable: false,\n        configurable: true\n    });\n    {\n        Object.defineProperty(Class.prototype, Symbol.for('nodejs.util.inspect.custom'), {\n            value: customUtilInspectFormatters[name] || defaultUtilInspectFormatter,\n            writable: false,\n            enumerable: false,\n            configurable: true\n        });\n    }\n    for (const prop of Object.getOwnPropertyNames(Class)) {\n        // we know that `prop` is present, so the descriptor is never undefined\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        const desc = Object.getOwnPropertyDescriptor(Class, prop);\n        if (!desc.configurable || !desc.enumerable)\n            continue;\n        desc.enumerable = false;\n        Object.defineProperty(Class, prop, desc);\n    }\n    for (const prop of Object.getOwnPropertyNames(Class.prototype)) {\n        // we know that `prop` is present, so the descriptor is never undefined\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        const desc = Object.getOwnPropertyDescriptor(Class.prototype, prop);\n        if (!desc.configurable || !desc.enumerable)\n            continue;\n        desc.enumerable = false;\n        Object.defineProperty(Class.prototype, prop, desc);\n    }\n    DefineIntrinsic(name, Class);\n    DefineIntrinsic(`${name}.prototype`, Class.prototype);\n}\nfunction DefineIntrinsic(name, value) {\n    const key = `%${name}%`;\n    if (INTRINSICS[key] !== undefined)\n        throw new Error(`intrinsic ${name} already exists`);\n    INTRINSICS[key] = value;\n}\nfunction GetIntrinsic(intrinsic) {\n    return INTRINSICS[intrinsic];\n}\n\n// Instant\nconst EPOCHNANOSECONDS = 'slot-epochNanoSeconds';\n// TimeZone\nconst TIMEZONE_ID = 'slot-timezone-identifier';\n// DateTime, Date, Time, YearMonth, MonthDay\nconst ISO_YEAR = 'slot-year';\nconst ISO_MONTH = 'slot-month';\nconst ISO_DAY = 'slot-day';\nconst ISO_HOUR = 'slot-hour';\nconst ISO_MINUTE = 'slot-minute';\nconst ISO_SECOND = 'slot-second';\nconst ISO_MILLISECOND = 'slot-millisecond';\nconst ISO_MICROSECOND = 'slot-microsecond';\nconst ISO_NANOSECOND = 'slot-nanosecond';\nconst CALENDAR = 'slot-calendar';\n// Date, YearMonth, and MonthDay all have the same slots, disambiguation needed:\nconst DATE_BRAND = 'slot-date-brand';\nconst YEAR_MONTH_BRAND = 'slot-year-month-brand';\nconst MONTH_DAY_BRAND = 'slot-month-day-brand';\n// ZonedDateTime\nconst INSTANT = 'slot-cached-instant';\nconst TIME_ZONE = 'slot-time-zone';\n// Duration\nconst YEARS = 'slot-years';\nconst MONTHS = 'slot-months';\nconst WEEKS = 'slot-weeks';\nconst DAYS = 'slot-days';\nconst HOURS = 'slot-hours';\nconst MINUTES = 'slot-minutes';\nconst SECONDS = 'slot-seconds';\nconst MILLISECONDS = 'slot-milliseconds';\nconst MICROSECONDS = 'slot-microseconds';\nconst NANOSECONDS = 'slot-nanoseconds';\n// Calendar\nconst CALENDAR_ID = 'slot-calendar-identifier';\nconst slots = new WeakMap();\nfunction CreateSlots(container) {\n    slots.set(container, Object.create(null));\n}\nfunction GetSlots(container) {\n    return slots.get(container);\n}\nfunction HasSlot(container, ...ids) {\n    if (!container || 'object' !== typeof container)\n        return false;\n    const myslots = GetSlots(container);\n    return !!myslots && ids.reduce((all, id) => all && id in myslots, true);\n}\nfunction GetSlot(container, id) {\n    const value = GetSlots(container)[id];\n    if (value === undefined)\n        throw new TypeError(`Missing internal slot ${id}`);\n    return value;\n}\nfunction SetSlot(container, id, value) {\n    GetSlots(container)[id] = value;\n}\n\nconst ArrayIncludes = Array.prototype.includes;\nconst ArrayPrototypePush$2 = Array.prototype.push;\nconst IntlDateTimeFormat$2 = globalThis.Intl.DateTimeFormat;\nconst ArraySort = Array.prototype.sort;\nconst MathAbs$1 = Math.abs;\nconst MathFloor$1 = Math.floor;\nconst ObjectEntries = Object.entries;\nconst ObjectKeys = Object.keys;\n/**\n * Implementations for each calendar. Non-ISO calendars have an extra `helper`\n * property that provides additional per-calendar logic.\n */\nconst impl = {};\n/**\n * Thin wrapper around the implementation of each built-in calendar. This\n * class's methods follow a similar pattern:\n * 1. Validate parameters\n * 2. Fill in default options (for methods where options are present)\n * 3. Simplify and/or normalize parameters. For example, some methods accept\n *    PlainDate, PlainDateTime, ZonedDateTime, etc. and these are normalized to\n *    PlainDate.\n * 4. Look up the ID of the built-in calendar\n * 5. Fetch the implementation object for that ID.\n * 6. Call the corresponding method in the implementation object.\n */\nclass Calendar {\n    constructor(idParam) {\n        // Note: if the argument is not passed, IsBuiltinCalendar(\"undefined\") will fail. This check\n        //       exists only to improve the error message.\n        if (arguments.length < 1) {\n            throw new RangeError('missing argument: id is required');\n        }\n        const id = ToString(idParam);\n        if (!IsBuiltinCalendar(id))\n            throw new RangeError(`invalid calendar identifier ${id}`);\n        CreateSlots(this);\n        SetSlot(this, CALENDAR_ID, id);\n        {\n            Object.defineProperty(this, '_repr_', {\n                value: `${this[Symbol.toStringTag]} <${id}>`,\n                writable: false,\n                enumerable: false,\n                configurable: false\n            });\n        }\n    }\n    get id() {\n        if (!IsTemporalCalendar(this))\n            throw new TypeError('invalid receiver');\n        return ToString(this);\n    }\n    dateFromFields(fields, optionsParam = undefined) {\n        if (!IsTemporalCalendar(this))\n            throw new TypeError('invalid receiver');\n        if (!IsObject(fields))\n            throw new TypeError('invalid fields');\n        const options = GetOptionsObject(optionsParam);\n        return impl[GetSlot(this, CALENDAR_ID)].dateFromFields(fields, options, this);\n    }\n    yearMonthFromFields(fields, optionsParam = undefined) {\n        if (!IsTemporalCalendar(this))\n            throw new TypeError('invalid receiver');\n        if (!IsObject(fields))\n            throw new TypeError('invalid fields');\n        const options = GetOptionsObject(optionsParam);\n        return impl[GetSlot(this, CALENDAR_ID)].yearMonthFromFields(fields, options, this);\n    }\n    monthDayFromFields(fields, optionsParam = undefined) {\n        if (!IsTemporalCalendar(this))\n            throw new TypeError('invalid receiver');\n        if (!IsObject(fields))\n            throw new TypeError('invalid fields');\n        const options = GetOptionsObject(optionsParam);\n        return impl[GetSlot(this, CALENDAR_ID)].monthDayFromFields(fields, options, this);\n    }\n    fields(fields) {\n        if (!IsTemporalCalendar(this))\n            throw new TypeError('invalid receiver');\n        const fieldsArray = [];\n        const allowed = new Set([\n            'year',\n            'month',\n            'monthCode',\n            'day',\n            'hour',\n            'minute',\n            'second',\n            'millisecond',\n            'microsecond',\n            'nanosecond'\n        ]);\n        for (const name of fields) {\n            if (typeof name !== 'string')\n                throw new TypeError('invalid fields');\n            if (!allowed.has(name))\n                throw new RangeError(`invalid field name ${name}`);\n            allowed.delete(name);\n            ArrayPrototypePush$2.call(fieldsArray, name);\n        }\n        return impl[GetSlot(this, CALENDAR_ID)].fields(fieldsArray);\n    }\n    mergeFields(fields, additionalFields) {\n        if (!IsTemporalCalendar(this))\n            throw new TypeError('invalid receiver');\n        return impl[GetSlot(this, CALENDAR_ID)].mergeFields(fields, additionalFields);\n    }\n    dateAdd(dateParam, durationParam, optionsParam = undefined) {\n        if (!IsTemporalCalendar(this))\n            throw new TypeError('invalid receiver');\n        const date = ToTemporalDate(dateParam);\n        const duration = ToTemporalDuration(durationParam);\n        const options = GetOptionsObject(optionsParam);\n        const overflow = ToTemporalOverflow(options);\n        const { days } = BalanceDuration(GetSlot(duration, DAYS), GetSlot(duration, HOURS), GetSlot(duration, MINUTES), GetSlot(duration, SECONDS), GetSlot(duration, MILLISECONDS), GetSlot(duration, MICROSECONDS), GetSlot(duration, NANOSECONDS), 'day');\n        return impl[GetSlot(this, CALENDAR_ID)].dateAdd(date, GetSlot(duration, YEARS), GetSlot(duration, MONTHS), GetSlot(duration, WEEKS), days, overflow, this);\n    }\n    dateUntil(oneParam, twoParam, optionsParam = undefined) {\n        if (!IsTemporalCalendar(this))\n            throw new TypeError('invalid receiver');\n        const one = ToTemporalDate(oneParam);\n        const two = ToTemporalDate(twoParam);\n        const options = GetOptionsObject(optionsParam);\n        const largestUnit = ToLargestTemporalUnit(options, 'auto', ['hour', 'minute', 'second', 'millisecond', 'microsecond', 'nanosecond'], 'day');\n        const { years, months, weeks, days } = impl[GetSlot(this, CALENDAR_ID)].dateUntil(one, two, largestUnit);\n        const Duration = GetIntrinsic('%Temporal.Duration%');\n        return new Duration(years, months, weeks, days, 0, 0, 0, 0, 0, 0);\n    }\n    year(dateParam) {\n        let date = dateParam;\n        if (!IsTemporalCalendar(this))\n            throw new TypeError('invalid receiver');\n        if (!IsTemporalYearMonth(date))\n            date = ToTemporalDate(date);\n        return impl[GetSlot(this, CALENDAR_ID)].year(date);\n    }\n    month(dateParam) {\n        let date = dateParam;\n        if (!IsTemporalCalendar(this))\n            throw new TypeError('invalid receiver');\n        if (IsTemporalMonthDay(date))\n            throw new TypeError('use monthCode on PlainMonthDay instead');\n        if (!IsTemporalYearMonth(date))\n            date = ToTemporalDate(date);\n        return impl[GetSlot(this, CALENDAR_ID)].month(date);\n    }\n    monthCode(dateParam) {\n        let date = dateParam;\n        if (!IsTemporalCalendar(this))\n            throw new TypeError('invalid receiver');\n        if (!IsTemporalYearMonth(date) && !IsTemporalMonthDay(date))\n            date = ToTemporalDate(date);\n        return impl[GetSlot(this, CALENDAR_ID)].monthCode(date);\n    }\n    day(dateParam) {\n        let date = dateParam;\n        if (!IsTemporalCalendar(this))\n            throw new TypeError('invalid receiver');\n        if (!IsTemporalMonthDay(date))\n            date = ToTemporalDate(date);\n        return impl[GetSlot(this, CALENDAR_ID)].day(date);\n    }\n    era(dateParam) {\n        let date = dateParam;\n        if (!IsTemporalCalendar(this))\n            throw new TypeError('invalid receiver');\n        if (!IsTemporalYearMonth(date))\n            date = ToTemporalDate(date);\n        return impl[GetSlot(this, CALENDAR_ID)].era(date);\n    }\n    eraYear(dateParam) {\n        let date = dateParam;\n        if (!IsTemporalCalendar(this))\n            throw new TypeError('invalid receiver');\n        if (!IsTemporalYearMonth(date))\n            date = ToTemporalDate(date);\n        return impl[GetSlot(this, CALENDAR_ID)].eraYear(date);\n    }\n    dayOfWeek(dateParam) {\n        if (!IsTemporalCalendar(this))\n            throw new TypeError('invalid receiver');\n        const date = ToTemporalDate(dateParam);\n        return impl[GetSlot(this, CALENDAR_ID)].dayOfWeek(date);\n    }\n    dayOfYear(dateParam) {\n        if (!IsTemporalCalendar(this))\n            throw new TypeError('invalid receiver');\n        const date = ToTemporalDate(dateParam);\n        return impl[GetSlot(this, CALENDAR_ID)].dayOfYear(date);\n    }\n    weekOfYear(dateParam) {\n        if (!IsTemporalCalendar(this))\n            throw new TypeError('invalid receiver');\n        const date = ToTemporalDate(dateParam);\n        return impl[GetSlot(this, CALENDAR_ID)].weekOfYear(date);\n    }\n    daysInWeek(dateParam) {\n        if (!IsTemporalCalendar(this))\n            throw new TypeError('invalid receiver');\n        const date = ToTemporalDate(dateParam);\n        return impl[GetSlot(this, CALENDAR_ID)].daysInWeek(date);\n    }\n    daysInMonth(dateParam) {\n        let date = dateParam;\n        if (!IsTemporalCalendar(this))\n            throw new TypeError('invalid receiver');\n        if (!IsTemporalYearMonth(date))\n            date = ToTemporalDate(date);\n        return impl[GetSlot(this, CALENDAR_ID)].daysInMonth(date);\n    }\n    daysInYear(dateParam) {\n        let date = dateParam;\n        if (!IsTemporalCalendar(this))\n            throw new TypeError('invalid receiver');\n        if (!IsTemporalYearMonth(date))\n            date = ToTemporalDate(date);\n        return impl[GetSlot(this, CALENDAR_ID)].daysInYear(date);\n    }\n    monthsInYear(dateParam) {\n        let date = dateParam;\n        if (!IsTemporalCalendar(this))\n            throw new TypeError('invalid receiver');\n        if (!IsTemporalYearMonth(date))\n            date = ToTemporalDate(date);\n        return impl[GetSlot(this, CALENDAR_ID)].monthsInYear(date);\n    }\n    inLeapYear(dateParam) {\n        let date = dateParam;\n        if (!IsTemporalCalendar(this))\n            throw new TypeError('invalid receiver');\n        if (!IsTemporalYearMonth(date))\n            date = ToTemporalDate(date);\n        return impl[GetSlot(this, CALENDAR_ID)].inLeapYear(date);\n    }\n    toString() {\n        if (!IsTemporalCalendar(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, CALENDAR_ID);\n    }\n    toJSON() {\n        if (!IsTemporalCalendar(this))\n            throw new TypeError('invalid receiver');\n        return ToString(this);\n    }\n    static from(item) {\n        return ToTemporalCalendar(item);\n    }\n}\nMakeIntrinsicClass(Calendar, 'Temporal.Calendar');\nDefineIntrinsic('Temporal.Calendar.from', Calendar.from);\n/**\n * Implementation for the ISO 8601 calendar. This is the only calendar that's\n * guaranteed to be supported by all ECMAScript implementations, including those\n * without Intl (ECMA-402) support.\n */\nimpl['iso8601'] = {\n    dateFromFields(fieldsParam, options, calendar) {\n        const overflow = ToTemporalOverflow(options);\n        let fields = PrepareTemporalFields(fieldsParam, [\n            ['day'],\n            ['month', undefined],\n            ['monthCode', undefined],\n            ['year']\n        ]);\n        fields = resolveNonLunisolarMonth(fields);\n        let { year, month, day } = fields;\n        ({ year, month, day } = RegulateISODate(year, month, day, overflow));\n        return CreateTemporalDate(year, month, day, calendar);\n    },\n    yearMonthFromFields(fieldsParam, options, calendar) {\n        const overflow = ToTemporalOverflow(options);\n        let fields = PrepareTemporalFields(fieldsParam, [\n            ['month', undefined],\n            ['monthCode', undefined],\n            ['year']\n        ]);\n        fields = resolveNonLunisolarMonth(fields);\n        let { year, month } = fields;\n        ({ year, month } = RegulateISOYearMonth(year, month, overflow));\n        return CreateTemporalYearMonth(year, month, calendar, /* referenceISODay = */ 1);\n    },\n    monthDayFromFields(fieldsParam, options, calendar) {\n        const overflow = ToTemporalOverflow(options);\n        let fields = PrepareTemporalFields(fieldsParam, [\n            ['day'],\n            ['month', undefined],\n            ['monthCode', undefined],\n            ['year', undefined]\n        ]);\n        if (fields.month !== undefined && fields.year === undefined && fields.monthCode === undefined) {\n            throw new TypeError('either year or monthCode required with month');\n        }\n        const useYear = fields.monthCode === undefined;\n        const referenceISOYear = 1972;\n        fields = resolveNonLunisolarMonth(fields);\n        let { month, day, year } = fields;\n        ({ month, day } = RegulateISODate(useYear ? year : referenceISOYear, month, day, overflow));\n        return CreateTemporalMonthDay(month, day, calendar, referenceISOYear);\n    },\n    fields(fields) {\n        return fields;\n    },\n    mergeFields(fields, additionalFields) {\n        const merged = {};\n        for (const nextKey of ObjectKeys(fields)) {\n            if (nextKey === 'month' || nextKey === 'monthCode')\n                continue;\n            merged[nextKey] = fields[nextKey];\n        }\n        const newKeys = ObjectKeys(additionalFields);\n        for (const nextKey of newKeys) {\n            merged[nextKey] = additionalFields[nextKey];\n        }\n        if (!ArrayIncludes.call(newKeys, 'month') && !ArrayIncludes.call(newKeys, 'monthCode')) {\n            const { month, monthCode } = fields;\n            if (month !== undefined)\n                merged.month = month;\n            if (monthCode !== undefined)\n                merged.monthCode = monthCode;\n        }\n        return merged;\n    },\n    dateAdd(date, years, months, weeks, days, overflow, calendar) {\n        let year = GetSlot(date, ISO_YEAR);\n        let month = GetSlot(date, ISO_MONTH);\n        let day = GetSlot(date, ISO_DAY);\n        ({ year, month, day } = AddISODate(year, month, day, years, months, weeks, days, overflow));\n        return CreateTemporalDate(year, month, day, calendar);\n    },\n    dateUntil(one, two, largestUnit) {\n        return DifferenceISODate(GetSlot(one, ISO_YEAR), GetSlot(one, ISO_MONTH), GetSlot(one, ISO_DAY), GetSlot(two, ISO_YEAR), GetSlot(two, ISO_MONTH), GetSlot(two, ISO_DAY), largestUnit);\n    },\n    year(date) {\n        return GetSlot(date, ISO_YEAR);\n    },\n    era() {\n        return undefined;\n    },\n    eraYear() {\n        return undefined;\n    },\n    month(date) {\n        return GetSlot(date, ISO_MONTH);\n    },\n    monthCode(date) {\n        return buildMonthCode(GetSlot(date, ISO_MONTH));\n    },\n    day(date) {\n        return GetSlot(date, ISO_DAY);\n    },\n    dayOfWeek(date) {\n        return DayOfWeek(GetSlot(date, ISO_YEAR), GetSlot(date, ISO_MONTH), GetSlot(date, ISO_DAY));\n    },\n    dayOfYear(date) {\n        return DayOfYear(GetSlot(date, ISO_YEAR), GetSlot(date, ISO_MONTH), GetSlot(date, ISO_DAY));\n    },\n    weekOfYear(date) {\n        return WeekOfYear(GetSlot(date, ISO_YEAR), GetSlot(date, ISO_MONTH), GetSlot(date, ISO_DAY));\n    },\n    daysInWeek() {\n        return 7;\n    },\n    daysInMonth(date) {\n        return ISODaysInMonth(GetSlot(date, ISO_YEAR), GetSlot(date, ISO_MONTH));\n    },\n    daysInYear(dateParam) {\n        let date = dateParam;\n        if (!HasSlot(date, ISO_YEAR))\n            date = ToTemporalDate(date);\n        return LeapYear(GetSlot(date, ISO_YEAR)) ? 366 : 365;\n    },\n    monthsInYear() {\n        return 12;\n    },\n    inLeapYear(dateParam) {\n        let date = dateParam;\n        if (!HasSlot(date, ISO_YEAR))\n            date = ToTemporalDate(date);\n        return LeapYear(GetSlot(date, ISO_YEAR));\n    }\n};\nfunction monthCodeNumberPart(monthCode) {\n    if (!monthCode.startsWith('M')) {\n        throw new RangeError(`Invalid month code: ${monthCode}.  Month codes must start with M.`);\n    }\n    const month = +monthCode.slice(1);\n    if (isNaN(month))\n        throw new RangeError(`Invalid month code: ${monthCode}`);\n    return month;\n}\nfunction buildMonthCode(month, leap = false) {\n    return `M${month.toString().padStart(2, '0')}${leap ? 'L' : ''}`;\n}\n/**\n * Safely merge a month, monthCode pair into an integer month.\n * If both are present, make sure they match.\n * This logic doesn't work for lunisolar calendars!\n * */\nfunction resolveNonLunisolarMonth(calendarDate, overflow = undefined, monthsPerYear = 12) {\n    let { month, monthCode } = calendarDate;\n    if (monthCode === undefined) {\n        if (month === undefined)\n            throw new TypeError('Either month or monthCode are required');\n        // The ISO calendar uses the default (undefined) value because it does\n        // constrain/reject after this method returns. Non-ISO calendars, however,\n        // rely on this function to constrain/reject out-of-range `month` values.\n        if (overflow === 'reject')\n            RejectToRange(month, 1, monthsPerYear);\n        if (overflow === 'constrain')\n            month = ConstrainToRange(month, 1, monthsPerYear);\n        monthCode = buildMonthCode(month);\n    }\n    else {\n        const numberPart = monthCodeNumberPart(monthCode);\n        if (month !== undefined && month !== numberPart) {\n            throw new RangeError(`monthCode ${monthCode} and month ${month} must match if both are present`);\n        }\n        if (monthCode !== buildMonthCode(numberPart)) {\n            throw new RangeError(`Invalid month code: ${monthCode}`);\n        }\n        month = numberPart;\n        if (month < 1 || month > monthsPerYear)\n            throw new RangeError(`Invalid monthCode: ${monthCode}`);\n    }\n    return { ...calendarDate, month, monthCode };\n}\n/**\n * This prototype implementation of non-ISO calendars makes many repeated calls\n * to Intl APIs which may be slow (e.g. >0.2ms). This trivial cache will speed\n * up these repeat accesses. Each cache instance is associated (via a WeakMap)\n * to a specific Temporal object, which speeds up multiple calendar calls on the\n * same Temporal object instance.  No invalidation or pruning is necessary\n * because each object's cache is thrown away when the object is GC-ed.\n */\nclass OneObjectCache {\n    constructor(cacheToClone) {\n        this.map = new Map();\n        this.calls = 0;\n        this.hits = 0;\n        this.misses = 0;\n        this.now = globalThis.performance ? globalThis.performance.now() : Date.now();\n        if (cacheToClone !== undefined) {\n            let i = 0;\n            for (const entry of cacheToClone.map.entries()) {\n                if (++i > OneObjectCache.MAX_CACHE_ENTRIES)\n                    break;\n                this.map.set(...entry);\n            }\n        }\n    }\n    get(key) {\n        const result = this.map.get(key);\n        if (result) {\n            this.hits++;\n            this.report();\n        }\n        this.calls++;\n        return result;\n    }\n    set(key, value) {\n        this.map.set(key, value);\n        this.misses++;\n        this.report();\n    }\n    report() {\n        /*\n        if (this.calls === 0) return;\n        const ms = (globalThis.performance ? globalThis.performance.now() : Date.now()) - this.now;\n        const hitRate = ((100 * this.hits) / this.calls).toFixed(0);\n        console.log(`${this.calls} calls in ${ms.toFixed(2)}ms. Hits: ${this.hits} (${hitRate}%). Misses: ${this.misses}.`);\n        */\n    }\n    setObject(obj) {\n        if (OneObjectCache.objectMap.get(obj))\n            throw new RangeError('object already cached');\n        OneObjectCache.objectMap.set(obj, this);\n        this.report();\n    }\n    /**\n     * Returns a WeakMap-backed cache that's used to store expensive results\n     * that are associated with a particular Temporal object instance.\n     *\n     * @param obj - object to associate with the cache\n     */\n    static getCacheForObject(obj) {\n        let cache = OneObjectCache.objectMap.get(obj);\n        if (!cache) {\n            cache = new OneObjectCache();\n            OneObjectCache.objectMap.set(obj, cache);\n        }\n        return cache;\n    }\n}\nOneObjectCache.objectMap = new WeakMap();\nOneObjectCache.MAX_CACHE_ENTRIES = 1000;\nfunction toUtcIsoDateString({ isoYear, isoMonth, isoDay }) {\n    const yearString = ISOYearString(isoYear);\n    const monthString = ISODateTimePartString(isoMonth);\n    const dayString = ISODateTimePartString(isoDay);\n    return `${yearString}-${monthString}-${dayString}T00:00Z`;\n}\nfunction simpleDateDiff(one, two) {\n    return {\n        years: one.year - two.year,\n        months: one.month - two.month,\n        days: one.day - two.day\n    };\n}\n/**\n * Implementation helper that's common to all non-ISO calendars\n */\nclass HelperBase {\n    constructor() {\n        // The short era format works for all calendars except Japanese, which will\n        // override.\n        this.eraLength = 'short';\n        // All built-in calendars except Chinese/Dangi and Hebrew use an era\n        this.hasEra = true;\n    }\n    getFormatter() {\n        // `new Intl.DateTimeFormat()` is amazingly slow and chews up RAM. Per\n        // https://bugs.chromium.org/p/v8/issues/detail?id=6528#c4, we cache one\n        // DateTimeFormat instance per calendar. Caching is lazy so we only pay for\n        // calendars that are used. Note that the nonIsoHelperBase object is spread\n        // into each each calendar's implementation before any cache is created, so\n        // each calendar gets its own separate cached formatter.\n        if (typeof this.formatter === 'undefined') {\n            this.formatter = new IntlDateTimeFormat$2(`en-US-u-ca-${this.id}`, {\n                day: 'numeric',\n                month: 'numeric',\n                year: 'numeric',\n                era: this.eraLength,\n                timeZone: 'UTC'\n            });\n        }\n        return this.formatter;\n    }\n    isoToCalendarDate(isoDate, cache) {\n        const { year: isoYear, month: isoMonth, day: isoDay } = isoDate;\n        const key = JSON.stringify({ func: 'isoToCalendarDate', isoYear, isoMonth, isoDay, id: this.id });\n        const cached = cache.get(key);\n        if (cached)\n            return cached;\n        const dateTimeFormat = this.getFormatter();\n        let parts, isoString;\n        try {\n            isoString = toUtcIsoDateString({ isoYear, isoMonth, isoDay });\n            parts = dateTimeFormat.formatToParts(new Date(isoString));\n        }\n        catch (e) {\n            throw new RangeError(`Invalid ISO date: ${JSON.stringify({ isoYear, isoMonth, isoDay })}`);\n        }\n        const result = {};\n        for (let { type, value } of parts) {\n            if (type === 'year')\n                result.eraYear = +value;\n            // TODO: remove this type annotation when `relatedYear` gets into TS lib types\n            if (type === 'relatedYear')\n                result.eraYear = +value;\n            if (type === 'month') {\n                const matches = /^([0-9]*)(.*?)$/.exec(value);\n                if (!matches || matches.length != 3 || (!matches[1] && !matches[2])) {\n                    throw new RangeError(`Unexpected month: ${value}`);\n                }\n                // If the month has no numeric part (should only see this for the Hebrew\n                // calendar with newer FF / Chromium versions; see\n                // https://bugzilla.mozilla.org/show_bug.cgi?id=1751833) then set a\n                // placeholder month index of `1` and rely on the derived class to\n                // calculate the correct month index from the month name stored in\n                // `monthExtra`.\n                result.month = matches[1] ? +matches[1] : 1;\n                if (result.month < 1) {\n                    throw new RangeError(`Invalid month ${value} from ${isoString}[u-ca-${this.id}]` +\n                        ' (probably due to https://bugs.chromium.org/p/v8/issues/detail?id=10527)');\n                }\n                if (result.month > 13) {\n                    throw new RangeError(`Invalid month ${value} from ${isoString}[u-ca-${this.id}]` +\n                        ' (probably due to https://bugs.chromium.org/p/v8/issues/detail?id=10529)');\n                }\n                // The ICU formats for the Hebrew calendar no longer support a numeric\n                // month format. So we'll rely on the derived class to interpret it.\n                // `monthExtra` is also used on the Chinese calendar to handle a suffix\n                // \"bis\" indicating a leap month.\n                if (matches[2])\n                    result.monthExtra = matches[2];\n            }\n            if (type === 'day')\n                result.day = +value;\n            if (this.hasEra && type === 'era' && value != null && value !== '') {\n                // The convention for Temporal era values is lowercase, so following\n                // that convention in this prototype. Punctuation is removed, accented\n                // letters are normalized, and spaces are replaced with dashes.\n                // E.g.: \"ERA0\" => \"era0\", \"Before R.O.C.\" => \"before-roc\", \"En\" => \"eno\"\n                // The call to normalize() and the replacement regex deals with era\n                // names that contain non-ASCII characters like Japanese eras. Also\n                // ignore extra content in parentheses like JPN era date ranges.\n                value = value.split(' (')[0];\n                result.era = value\n                    .normalize('NFD')\n                    .replace(/[^-0-9 \\p{L}]/gu, '')\n                    .replace(' ', '-')\n                    .toLowerCase();\n            }\n        }\n        if (result.eraYear === undefined) {\n            // Node 12 has outdated ICU data that lacks the `relatedYear` field in the\n            // output of Intl.DateTimeFormat.formatToParts.\n            throw new RangeError(`Intl.DateTimeFormat.formatToParts lacks relatedYear in ${this.id} calendar. Try Node 14+ or modern browsers.`);\n        }\n        // Translate eras that may be handled differently by Temporal vs. by Intl\n        // (e.g. Japanese pre-Meiji eras). See https://github.com/tc39/proposal-temporal/issues/526.\n        if (this.reviseIntlEra) {\n            const { era, eraYear } = this.reviseIntlEra(result, isoDate);\n            result.era = era;\n            result.eraYear = eraYear;\n        }\n        if (this.checkIcuBugs)\n            this.checkIcuBugs(isoDate);\n        const calendarDate = this.adjustCalendarDate(result, cache, 'constrain', true);\n        if (calendarDate.year === undefined)\n            throw new RangeError(`Missing year converting ${JSON.stringify(isoDate)}`);\n        if (calendarDate.month === undefined)\n            throw new RangeError(`Missing month converting ${JSON.stringify(isoDate)}`);\n        if (calendarDate.day === undefined)\n            throw new RangeError(`Missing day converting ${JSON.stringify(isoDate)}`);\n        cache.set(key, calendarDate);\n        // Also cache the reverse mapping\n        ['constrain', 'reject'].forEach((overflow) => {\n            const keyReverse = JSON.stringify({\n                func: 'calendarToIsoDate',\n                year: calendarDate.year,\n                month: calendarDate.month,\n                day: calendarDate.day,\n                overflow,\n                id: this.id\n            });\n            cache.set(keyReverse, isoDate);\n        });\n        return calendarDate;\n    }\n    validateCalendarDate(calendarDate) {\n        const { era, month, year, day, eraYear, monthCode, monthExtra } = calendarDate;\n        // When there's a suffix (e.g. \"5bis\" for a leap month in Chinese calendar)\n        // the derived class must deal with it.\n        if (monthExtra !== undefined)\n            throw new RangeError('Unexpected `monthExtra` value');\n        if (year === undefined && eraYear === undefined)\n            throw new TypeError('year or eraYear is required');\n        if (month === undefined && monthCode === undefined)\n            throw new TypeError('month or monthCode is required');\n        if (day === undefined)\n            throw new RangeError('Missing day');\n        if (monthCode !== undefined) {\n            if (typeof monthCode !== 'string') {\n                throw new RangeError(`monthCode must be a string, not ${typeof monthCode}`);\n            }\n            if (!/^M([01]?\\d)(L?)$/.test(monthCode))\n                throw new RangeError(`Invalid monthCode: ${monthCode}`);\n        }\n        if (this.constantEra) {\n            if (era !== undefined && era !== this.constantEra) {\n                throw new RangeError(`era must be ${this.constantEra}, not ${era}`);\n            }\n            if (eraYear !== undefined && year !== undefined && eraYear !== year) {\n                throw new RangeError(`eraYear ${eraYear} does not match year ${year}`);\n            }\n        }\n    }\n    /**\n     * Allows derived calendars to add additional fields and/or to make\n     * adjustments e.g. to set the era based on the date or to revise the month\n     * number in lunisolar calendars per\n     * https://github.com/tc39/proposal-temporal/issues/1203.\n     *\n     * The base implementation fills in missing values by assuming the simplest\n     * possible calendar:\n     * - no eras or a constant era defined in `.constantEra`\n     * - non-lunisolar calendar (no leap months)\n     * */\n    adjustCalendarDate(calendarDateParam, cache = undefined, overflow = 'constrain', \n    // This param is only used by derived classes\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    fromLegacyDate = false) {\n        if (this.calendarType === 'lunisolar')\n            throw new RangeError('Override required for lunisolar calendars');\n        let calendarDate = calendarDateParam;\n        this.validateCalendarDate(calendarDate);\n        // For calendars that always use the same era, set it here so that derived\n        // calendars won't need to implement this method simply to set the era.\n        if (this.constantEra) {\n            // year and eraYear always match when there's only one possible era\n            const { year, eraYear } = calendarDate;\n            calendarDate = {\n                ...calendarDate,\n                era: this.constantEra,\n                year: year !== undefined ? year : eraYear,\n                eraYear: eraYear !== undefined ? eraYear : year\n            };\n        }\n        const largestMonth = this.monthsInYear(calendarDate, cache);\n        let { month, monthCode } = calendarDate;\n        ({ month, monthCode } = resolveNonLunisolarMonth(calendarDate, overflow, largestMonth));\n        return { ...calendarDate, month, monthCode };\n    }\n    regulateMonthDayNaive(calendarDate, overflow, cache) {\n        const largestMonth = this.monthsInYear(calendarDate, cache);\n        let { month, day } = calendarDate;\n        if (overflow === 'reject') {\n            RejectToRange(month, 1, largestMonth);\n            RejectToRange(day, 1, this.maximumMonthLength(calendarDate));\n        }\n        else {\n            month = ConstrainToRange(month, 1, largestMonth);\n            day = ConstrainToRange(day, 1, this.maximumMonthLength({ ...calendarDate, month }));\n        }\n        return { ...calendarDate, month, day };\n    }\n    calendarToIsoDate(dateParam, overflow = 'constrain', cache) {\n        const originalDate = dateParam;\n        // First, normalize the calendar date to ensure that (year, month, day)\n        // are all present, converting monthCode and eraYear if needed.\n        let date = this.adjustCalendarDate(dateParam, cache, overflow, false);\n        // Fix obviously out-of-bounds values. Values that are valid generally, but\n        // not in this particular year, may not be caught here for some calendars.\n        // If so, these will be handled lower below.\n        date = this.regulateMonthDayNaive(date, overflow, cache);\n        const { year, month, day } = date;\n        const key = JSON.stringify({ func: 'calendarToIsoDate', year, month, day, overflow, id: this.id });\n        let cached = cache.get(key);\n        if (cached)\n            return cached;\n        // If YMD are present in the input but the input has been constrained\n        // already, then cache both the original value and the constrained value.\n        let keyOriginal;\n        if (originalDate.year !== undefined &&\n            originalDate.month !== undefined &&\n            originalDate.day !== undefined &&\n            (originalDate.year !== date.year || originalDate.month !== date.month || originalDate.day !== date.day)) {\n            keyOriginal = JSON.stringify({\n                func: 'calendarToIsoDate',\n                year: originalDate.year,\n                month: originalDate.month,\n                day: originalDate.day,\n                overflow,\n                id: this.id\n            });\n            cached = cache.get(keyOriginal);\n            if (cached)\n                return cached;\n        }\n        // First, try to roughly guess the result\n        let isoEstimate = this.estimateIsoDate({ year, month, day });\n        const calculateSameMonthResult = (diffDays) => {\n            // If the estimate is in the same year & month as the target, then we can\n            // calculate the result exactly and short-circuit any additional logic.\n            // This optimization assumes that months are continuous. It would break if\n            // a calendar skipped days, like the Julian->Gregorian switchover. But the\n            // only ICU calendars that currently skip days (japanese/roc/buddhist) is\n            // a bug (https://bugs.chromium.org/p/chromium/issues/detail?id=1173158)\n            // that's currently detected by `checkIcuBugs()` which will throw. So\n            // this optimization should be safe for all ICU calendars.\n            let testIsoEstimate = this.addDaysIso(isoEstimate, diffDays);\n            if (date.day > this.minimumMonthLength(date)) {\n                // There's a chance that the calendar date is out of range. Throw or\n                // constrain if so.\n                let testCalendarDate = this.isoToCalendarDate(testIsoEstimate, cache);\n                while (testCalendarDate.month !== month || testCalendarDate.year !== year) {\n                    if (overflow === 'reject') {\n                        throw new RangeError(`day ${day} does not exist in month ${month} of year ${year}`);\n                    }\n                    // Back up a day at a time until we're not hanging over the month end\n                    testIsoEstimate = this.addDaysIso(testIsoEstimate, -1);\n                    testCalendarDate = this.isoToCalendarDate(testIsoEstimate, cache);\n                }\n            }\n            return testIsoEstimate;\n        };\n        let sign = 0;\n        let roundtripEstimate = this.isoToCalendarDate(isoEstimate, cache);\n        let diff = simpleDateDiff(date, roundtripEstimate);\n        if (diff.years !== 0 || diff.months !== 0 || diff.days !== 0) {\n            const diffTotalDaysEstimate = diff.years * 365 + diff.months * 30 + diff.days;\n            isoEstimate = this.addDaysIso(isoEstimate, diffTotalDaysEstimate);\n            roundtripEstimate = this.isoToCalendarDate(isoEstimate, cache);\n            diff = simpleDateDiff(date, roundtripEstimate);\n            if (diff.years === 0 && diff.months === 0) {\n                isoEstimate = calculateSameMonthResult(diff.days);\n            }\n            else {\n                sign = this.compareCalendarDates(date, roundtripEstimate);\n            }\n        }\n        // If the initial guess is not in the same month, then then bisect the\n        // distance to the target, starting with 8 days per step.\n        let increment = 8;\n        let maybeConstrained = false;\n        while (sign) {\n            isoEstimate = this.addDaysIso(isoEstimate, sign * increment);\n            const oldRoundtripEstimate = roundtripEstimate;\n            roundtripEstimate = this.isoToCalendarDate(isoEstimate, cache);\n            const oldSign = sign;\n            sign = this.compareCalendarDates(date, roundtripEstimate);\n            if (sign) {\n                diff = simpleDateDiff(date, roundtripEstimate);\n                if (diff.years === 0 && diff.months === 0) {\n                    isoEstimate = calculateSameMonthResult(diff.days);\n                    // Signal the loop condition that there's a match.\n                    sign = 0;\n                    // If the calendar day is larger than the minimal length for this\n                    // month, then it might be larger than the actual length of the month.\n                    // So we won't cache it as the correct calendar date for this ISO\n                    // date.\n                    maybeConstrained = date.day > this.minimumMonthLength(date);\n                }\n                else if (oldSign && sign !== oldSign) {\n                    if (increment > 1) {\n                        // If the estimate overshot the target, try again with a smaller increment\n                        // in the reverse direction.\n                        increment /= 2;\n                    }\n                    else {\n                        // Increment is 1, and neither the previous estimate nor the new\n                        // estimate is correct. The only way that can happen is if the\n                        // original date was an invalid value that will be constrained or\n                        // rejected here.\n                        if (overflow === 'reject') {\n                            throw new RangeError(`Can't find ISO date from calendar date: ${JSON.stringify({ ...originalDate })}`);\n                        }\n                        else {\n                            // To constrain, pick the earliest value\n                            const order = this.compareCalendarDates(roundtripEstimate, oldRoundtripEstimate);\n                            // If current value is larger, then back up to the previous value.\n                            if (order > 0)\n                                isoEstimate = this.addDaysIso(isoEstimate, -1);\n                            maybeConstrained = true;\n                            sign = 0;\n                        }\n                    }\n                }\n            }\n        }\n        cache.set(key, isoEstimate);\n        if (keyOriginal)\n            cache.set(keyOriginal, isoEstimate);\n        if (date.year === undefined ||\n            date.month === undefined ||\n            date.day === undefined ||\n            date.monthCode === undefined ||\n            (this.hasEra && (date.era === undefined || date.eraYear === undefined))) {\n            throw new RangeError('Unexpected missing property');\n        }\n        if (!maybeConstrained) {\n            // Also cache the reverse mapping\n            const keyReverse = JSON.stringify({\n                func: 'isoToCalendarDate',\n                isoYear: isoEstimate.year,\n                isoMonth: isoEstimate.month,\n                isoDay: isoEstimate.day,\n                id: this.id\n            });\n            cache.set(keyReverse, date);\n        }\n        return isoEstimate;\n    }\n    temporalToCalendarDate(date, cache) {\n        const isoDate = { year: GetSlot(date, ISO_YEAR), month: GetSlot(date, ISO_MONTH), day: GetSlot(date, ISO_DAY) };\n        const result = this.isoToCalendarDate(isoDate, cache);\n        return result;\n    }\n    compareCalendarDates(date1Param, date2Param) {\n        // `date1` and `date2` are already records. The calls below simply validate\n        // that all three required fields are present.\n        const date1 = PrepareTemporalFields(date1Param, [['day'], ['month'], ['year']]);\n        const date2 = PrepareTemporalFields(date2Param, [['day'], ['month'], ['year']]);\n        if (date1.year !== date2.year)\n            return ComparisonResult(date1.year - date2.year);\n        if (date1.month !== date2.month)\n            return ComparisonResult(date1.month - date2.month);\n        if (date1.day !== date2.day)\n            return ComparisonResult(date1.day - date2.day);\n        return 0;\n    }\n    /** Ensure that a calendar date actually exists. If not, return the closest earlier date. */\n    regulateDate(calendarDate, overflow = 'constrain', cache) {\n        const isoDate = this.calendarToIsoDate(calendarDate, overflow, cache);\n        return this.isoToCalendarDate(isoDate, cache);\n    }\n    addDaysIso(isoDate, days) {\n        const added = AddISODate(isoDate.year, isoDate.month, isoDate.day, 0, 0, 0, days, 'constrain');\n        return added;\n    }\n    addDaysCalendar(calendarDate, days, cache) {\n        const isoDate = this.calendarToIsoDate(calendarDate, 'constrain', cache);\n        const addedIso = this.addDaysIso(isoDate, days);\n        const addedCalendar = this.isoToCalendarDate(addedIso, cache);\n        return addedCalendar;\n    }\n    addMonthsCalendar(calendarDateParam, months, overflow, cache) {\n        let calendarDate = calendarDateParam;\n        const { day } = calendarDate;\n        for (let i = 0, absMonths = MathAbs$1(months); i < absMonths; i++) {\n            const { month } = calendarDate;\n            const oldCalendarDate = calendarDate;\n            const days = months < 0\n                ? -Math.max(day, this.daysInPreviousMonth(calendarDate, cache))\n                : this.daysInMonth(calendarDate, cache);\n            const isoDate = this.calendarToIsoDate(calendarDate, 'constrain', cache);\n            let addedIso = this.addDaysIso(isoDate, days);\n            calendarDate = this.isoToCalendarDate(addedIso, cache);\n            // Normally, we can advance one month by adding the number of days in the\n            // current month. However, if we're at the end of the current month and\n            // the next month has fewer days, then we rolled over to the after-next\n            // month. Below we detect this condition and back up until we're back in\n            // the desired month.\n            if (months > 0) {\n                const monthsInOldYear = this.monthsInYear(oldCalendarDate, cache);\n                while (calendarDate.month - 1 !== month % monthsInOldYear) {\n                    addedIso = this.addDaysIso(addedIso, -1);\n                    calendarDate = this.isoToCalendarDate(addedIso, cache);\n                }\n            }\n            if (calendarDate.day !== day) {\n                // try to retain the original day-of-month, if possible\n                calendarDate = this.regulateDate({ ...calendarDate, day }, 'constrain', cache);\n            }\n        }\n        if (overflow === 'reject' && calendarDate.day !== day) {\n            throw new RangeError(`Day ${day} does not exist in resulting calendar month`);\n        }\n        return calendarDate;\n    }\n    addCalendar(calendarDate, { years = 0, months = 0, weeks = 0, days = 0 }, overflow, cache) {\n        const { year, month, day } = calendarDate;\n        const addedMonths = this.addMonthsCalendar({ year: year + years, month, day }, months, overflow, cache);\n        const initialDays = days + weeks * 7;\n        const addedDays = this.addDaysCalendar(addedMonths, initialDays, cache);\n        return addedDays;\n    }\n    untilCalendar(calendarOne, calendarTwo, largestUnit, cache) {\n        let days = 0;\n        let weeks = 0;\n        let months = 0;\n        let years = 0;\n        switch (largestUnit) {\n            case 'day':\n                days = this.calendarDaysUntil(calendarOne, calendarTwo, cache);\n                break;\n            case 'week': {\n                const totalDays = this.calendarDaysUntil(calendarOne, calendarTwo, cache);\n                days = totalDays % 7;\n                weeks = (totalDays - days) / 7;\n                break;\n            }\n            case 'month':\n            case 'year': {\n                const diffYears = calendarTwo.year - calendarOne.year;\n                const diffMonths = calendarTwo.month - calendarOne.month;\n                const diffDays = calendarTwo.day - calendarOne.day;\n                const sign = this.compareCalendarDates(calendarTwo, calendarOne);\n                if (largestUnit === 'year' && diffYears) {\n                    const isOneFurtherInYear = diffMonths * sign < 0 || (diffMonths === 0 && diffDays * sign < 0);\n                    years = isOneFurtherInYear ? diffYears - sign : diffYears;\n                }\n                const yearsAdded = years ? this.addCalendar(calendarOne, { years }, 'constrain', cache) : calendarOne;\n                // Now we have less than one year remaining. Add one month at a time\n                // until we go over the target, then back up one month and calculate\n                // remaining days and weeks.\n                let current;\n                let next = yearsAdded;\n                do {\n                    months += sign;\n                    current = next;\n                    next = this.addMonthsCalendar(current, sign, 'constrain', cache);\n                    if (next.day !== calendarOne.day) {\n                        // In case the day was constrained down, try to un-constrain it\n                        next = this.regulateDate({ ...next, day: calendarOne.day }, 'constrain', cache);\n                    }\n                } while (this.compareCalendarDates(calendarTwo, next) * sign >= 0);\n                months -= sign; // correct for loop above which overshoots by 1\n                const remainingDays = this.calendarDaysUntil(current, calendarTwo, cache);\n                days = remainingDays;\n                break;\n            }\n        }\n        return { years, months, weeks, days };\n    }\n    daysInMonth(calendarDate, cache) {\n        // Add enough days to roll over to the next month. One we're in the next\n        // month, we can calculate the length of the current month. NOTE: This\n        // algorithm assumes that months are continuous. It would break if a\n        // calendar skipped days, like the Julian->Gregorian switchover. But the\n        // only ICU calendars that currently skip days (japanese/roc/buddhist) is a\n        // bug (https://bugs.chromium.org/p/chromium/issues/detail?id=1173158)\n        // that's currently detected by `checkIcuBugs()` which will throw. So this\n        // code should be safe for all ICU calendars.\n        const { day } = calendarDate;\n        const max = this.maximumMonthLength(calendarDate);\n        const min = this.minimumMonthLength(calendarDate);\n        // easiest case: we already know the month length if min and max are the same.\n        if (min === max)\n            return min;\n        // Add enough days to get into the next month, without skipping it\n        const increment = day <= max - min ? max : min;\n        const isoDate = this.calendarToIsoDate(calendarDate, 'constrain', cache);\n        const addedIsoDate = this.addDaysIso(isoDate, increment);\n        const addedCalendarDate = this.isoToCalendarDate(addedIsoDate, cache);\n        // Now back up to the last day of the original month\n        const endOfMonthIso = this.addDaysIso(addedIsoDate, -addedCalendarDate.day);\n        const endOfMonthCalendar = this.isoToCalendarDate(endOfMonthIso, cache);\n        return endOfMonthCalendar.day;\n    }\n    daysInPreviousMonth(calendarDate, cache) {\n        const { day, month, year } = calendarDate;\n        // Check to see if we already know the month length, and return it if so\n        const previousMonthYear = month > 1 ? year : year - 1;\n        let previousMonthDate = { year: previousMonthYear, month, day: 1 };\n        const previousMonth = month > 1 ? month - 1 : this.monthsInYear(previousMonthDate, cache);\n        previousMonthDate = { ...previousMonthDate, month: previousMonth };\n        const min = this.minimumMonthLength(previousMonthDate);\n        const max = this.maximumMonthLength(previousMonthDate);\n        if (min === max)\n            return max;\n        const isoDate = this.calendarToIsoDate(calendarDate, 'constrain', cache);\n        const lastDayOfPreviousMonthIso = this.addDaysIso(isoDate, -day);\n        const lastDayOfPreviousMonthCalendar = this.isoToCalendarDate(lastDayOfPreviousMonthIso, cache);\n        return lastDayOfPreviousMonthCalendar.day;\n    }\n    startOfCalendarYear(calendarDate) {\n        return { year: calendarDate.year, month: 1, day: 1 };\n    }\n    startOfCalendarMonth(calendarDate) {\n        return { year: calendarDate.year, month: calendarDate.month, day: 1 };\n    }\n    calendarDaysUntil(calendarOne, calendarTwo, cache) {\n        const oneIso = this.calendarToIsoDate(calendarOne, 'constrain', cache);\n        const twoIso = this.calendarToIsoDate(calendarTwo, 'constrain', cache);\n        return this.isoDaysUntil(oneIso, twoIso);\n    }\n    isoDaysUntil(oneIso, twoIso) {\n        const duration = DifferenceISODate(oneIso.year, oneIso.month, oneIso.day, twoIso.year, twoIso.month, twoIso.day, 'day');\n        return duration.days;\n    }\n    monthDayFromFields(fields, overflow, cache) {\n        let { year, month, monthCode, day, era, eraYear } = fields;\n        if (monthCode === undefined) {\n            if (year === undefined && (era === undefined || eraYear === undefined)) {\n                throw new TypeError('`monthCode`, `year`, or `era` and `eraYear` is required');\n            }\n            ({ monthCode, year } = this.adjustCalendarDate({ year, month, monthCode, day, era, eraYear }, cache, overflow));\n        }\n        let isoYear, isoMonth, isoDay;\n        let closestCalendar, closestIso;\n        // Look backwards starting from the calendar year of 1972-01-01 up to 100\n        // calendar years to find a year that has this month and day. Normal months\n        // and days will match immediately, but for leap days and leap months we may\n        // have to look for a while.\n        const startDateIso = { year: 1972, month: 1, day: 1 };\n        const { year: calendarYear } = this.isoToCalendarDate(startDateIso, cache);\n        for (let i = 0; i < 100; i++) {\n            const testCalendarDate = this.adjustCalendarDate({ day, monthCode, year: calendarYear - i }, cache);\n            const isoDate = this.calendarToIsoDate(testCalendarDate, 'constrain', cache);\n            const roundTripCalendarDate = this.isoToCalendarDate(isoDate, cache);\n            ({ year: isoYear, month: isoMonth, day: isoDay } = isoDate);\n            if (roundTripCalendarDate.monthCode === monthCode && roundTripCalendarDate.day === day) {\n                return { month: isoMonth, day: isoDay, year: isoYear };\n            }\n            else if (overflow === 'constrain') {\n                // non-ISO constrain algorithm tries to find the closest date in a matching month\n                if (closestCalendar === undefined ||\n                    (roundTripCalendarDate.monthCode === closestCalendar.monthCode &&\n                        roundTripCalendarDate.day > closestCalendar.day)) {\n                    closestCalendar = roundTripCalendarDate;\n                    closestIso = isoDate;\n                }\n            }\n        }\n        if (overflow === 'constrain' && closestIso !== undefined)\n            return closestIso;\n        throw new RangeError(`No recent ${this.id} year with monthCode ${monthCode} and day ${day}`);\n    }\n}\nclass HebrewHelper extends HelperBase {\n    constructor() {\n        super(...arguments);\n        this.id = 'hebrew';\n        this.calendarType = 'lunisolar';\n        this.months = {\n            Tishri: { leap: 1, regular: 1, monthCode: 'M01', days: 30 },\n            Heshvan: { leap: 2, regular: 2, monthCode: 'M02', days: { min: 29, max: 30 } },\n            Kislev: { leap: 3, regular: 3, monthCode: 'M03', days: { min: 29, max: 30 } },\n            Tevet: { leap: 4, regular: 4, monthCode: 'M04', days: 29 },\n            Shevat: { leap: 5, regular: 5, monthCode: 'M05', days: 30 },\n            Adar: { leap: undefined, regular: 6, monthCode: 'M06', days: 29 },\n            'Adar I': { leap: 6, regular: undefined, monthCode: 'M05L', days: 30 },\n            'Adar II': { leap: 7, regular: undefined, monthCode: 'M06', days: 29 },\n            Nisan: { leap: 8, regular: 7, monthCode: 'M07', days: 30 },\n            Iyar: { leap: 9, regular: 8, monthCode: 'M08', days: 29 },\n            Sivan: { leap: 10, regular: 9, monthCode: 'M09', days: 30 },\n            Tamuz: { leap: 11, regular: 10, monthCode: 'M10', days: 29 },\n            Av: { leap: 12, regular: 11, monthCode: 'M11', days: 30 },\n            Elul: { leap: 13, regular: 12, monthCode: 'M12', days: 29 }\n        };\n        // All built-in calendars except Chinese/Dangi and Hebrew use an era\n        this.hasEra = false;\n    }\n    inLeapYear(calendarDate) {\n        const { year } = calendarDate;\n        // FYI: In addition to adding a month in leap years, the Hebrew calendar\n        // also has per-year changes to the number of days of Heshvan and Kislev.\n        // Given that these can be calculated by counting the number of days in\n        // those months, I assume that these DO NOT need to be exposed as\n        // Hebrew-only prototype fields or methods.\n        return (7 * year + 1) % 19 < 7;\n    }\n    monthsInYear(calendarDate) {\n        return this.inLeapYear(calendarDate) ? 13 : 12;\n    }\n    minimumMonthLength(calendarDate) {\n        return this.minMaxMonthLength(calendarDate, 'min');\n    }\n    maximumMonthLength(calendarDate) {\n        return this.minMaxMonthLength(calendarDate, 'max');\n    }\n    minMaxMonthLength(calendarDate, minOrMax) {\n        const { month, year } = calendarDate;\n        const monthCode = this.getMonthCode(year, month);\n        const monthInfo = ObjectEntries(this.months).find((m) => m[1].monthCode === monthCode);\n        if (monthInfo === undefined)\n            throw new RangeError(`unmatched Hebrew month: ${month}`);\n        const daysInMonth = monthInfo[1].days;\n        return typeof daysInMonth === 'number' ? daysInMonth : daysInMonth[minOrMax];\n    }\n    /** Take a guess at what ISO date a particular calendar date corresponds to */\n    estimateIsoDate(calendarDate) {\n        const { year } = calendarDate;\n        return { year: year - 3760, month: 1, day: 1 };\n    }\n    getMonthCode(year, month) {\n        if (this.inLeapYear({ year })) {\n            return month === 6 ? buildMonthCode(5, true) : buildMonthCode(month < 6 ? month : month - 1);\n        }\n        else {\n            return buildMonthCode(month);\n        }\n    }\n    adjustCalendarDate(calendarDate, cache, overflow = 'constrain', fromLegacyDate = false) {\n        // The incoming type is actually CalendarDate (same as args to\n        // Calendar.dateFromParams) but TS isn't smart enough to follow all the\n        // reassignments below, so as an alternative to 10+ type casts, we'll lie\n        // here and claim that the type has `day` and `year` filled in already.\n        let { year, eraYear, month, monthCode, day, monthExtra } = calendarDate;\n        if (year === undefined && eraYear !== undefined)\n            year = eraYear;\n        if (eraYear === undefined && year !== undefined)\n            eraYear = year;\n        if (fromLegacyDate) {\n            // In Pre Node-14 V8, DateTimeFormat.formatToParts `month: 'numeric'`\n            // output returns the numeric equivalent of `month` as a string, meaning\n            // that `'6'` in a leap year is Adar I, while `'6'` in a non-leap year\n            // means Adar. In this case, `month` will already be correct and no action\n            // is needed. However, in Node 14 and later formatToParts returns the name\n            // of the Hebrew month (e.g. \"Tevet\"), so we'll need to look up the\n            // correct `month` using the string name as a key.\n            if (monthExtra) {\n                const monthInfo = this.months[monthExtra];\n                if (!monthInfo)\n                    throw new RangeError(`Unrecognized month from formatToParts: ${monthExtra}`);\n                month = this.inLeapYear({ year }) ? monthInfo.leap : monthInfo.regular;\n            }\n            // Because we're getting data from legacy Date, then `month` will always be present\n            monthCode = this.getMonthCode(year, month);\n            const result = { year, month: month, day, era: undefined, eraYear, monthCode };\n            return result;\n        }\n        else {\n            // When called without input coming from legacy Date output, simply ensure\n            // that all fields are present.\n            this.validateCalendarDate(calendarDate);\n            if (month === undefined) {\n                if (monthCode.endsWith('L')) {\n                    if (monthCode !== 'M05L') {\n                        throw new RangeError(`Hebrew leap month must have monthCode M05L, not ${monthCode}`);\n                    }\n                    month = 6;\n                    if (!this.inLeapYear({ year })) {\n                        if (overflow === 'reject') {\n                            throw new RangeError(`Hebrew monthCode M05L is invalid in year ${year} which is not a leap year`);\n                        }\n                        else {\n                            // constrain to last day of previous month (Av)\n                            month = 5;\n                            day = 30;\n                            monthCode = 'M05';\n                        }\n                    }\n                }\n                else {\n                    month = monthCodeNumberPart(monthCode);\n                    // if leap month is before this one, the month index is one more than the month code\n                    if (this.inLeapYear({ year }) && month > 6)\n                        month++;\n                    const largestMonth = this.monthsInYear({ year });\n                    if (month < 1 || month > largestMonth)\n                        throw new RangeError(`Invalid monthCode: ${monthCode}`);\n                }\n            }\n            else {\n                if (overflow === 'reject') {\n                    RejectToRange(month, 1, this.monthsInYear({ year }));\n                    RejectToRange(day, 1, this.maximumMonthLength({ year, month }));\n                }\n                else {\n                    month = ConstrainToRange(month, 1, this.monthsInYear({ year }));\n                    day = ConstrainToRange(day, 1, this.maximumMonthLength({ year, month }));\n                }\n                if (monthCode === undefined) {\n                    monthCode = this.getMonthCode(year, month);\n                }\n                else {\n                    const calculatedMonthCode = this.getMonthCode(year, month);\n                    if (calculatedMonthCode !== monthCode) {\n                        throw new RangeError(`monthCode ${monthCode} doesn't correspond to month ${month} in Hebrew year ${year}`);\n                    }\n                }\n            }\n            return { ...calendarDate, day, month, monthCode: monthCode, year, eraYear };\n        }\n    }\n}\n/**\n * For Temporal purposes, the Islamic calendar is simple because it's always the\n * same 12 months in the same order.\n */\nclass IslamicBaseHelper extends HelperBase {\n    constructor() {\n        super(...arguments);\n        this.calendarType = 'lunar';\n        this.DAYS_PER_ISLAMIC_YEAR = 354 + 11 / 30;\n        this.DAYS_PER_ISO_YEAR = 365.2425;\n        this.constantEra = 'ah';\n    }\n    inLeapYear(calendarDate, cache) {\n        // In leap years, the 12th month has 30 days. In non-leap years: 29.\n        const days = this.daysInMonth({ year: calendarDate.year, month: 12, day: 1 }, cache);\n        return days === 30;\n    }\n    monthsInYear( /* calendarYear, cache */) {\n        return 12;\n    }\n    minimumMonthLength( /* calendarDate */) {\n        return 29;\n    }\n    maximumMonthLength( /* calendarDate */) {\n        return 30;\n    }\n    estimateIsoDate(calendarDate) {\n        const { year } = this.adjustCalendarDate(calendarDate);\n        return { year: MathFloor$1((year * this.DAYS_PER_ISLAMIC_YEAR) / this.DAYS_PER_ISO_YEAR) + 622, month: 1, day: 1 };\n    }\n}\n// There are 6 Islamic calendars with the same implementation in this polyfill.\n// They vary only in their ID. They do emit different output from the underlying\n// Intl implementation, but our code for each of them is identical.\nclass IslamicHelper extends IslamicBaseHelper {\n    constructor() {\n        super(...arguments);\n        this.id = 'islamic';\n    }\n}\nclass IslamicUmalquraHelper extends IslamicBaseHelper {\n    constructor() {\n        super(...arguments);\n        this.id = 'islamic-umalqura';\n    }\n}\nclass IslamicTblaHelper extends IslamicBaseHelper {\n    constructor() {\n        super(...arguments);\n        this.id = 'islamic-tbla';\n    }\n}\nclass IslamicCivilHelper extends IslamicBaseHelper {\n    constructor() {\n        super(...arguments);\n        this.id = 'islamic-civil';\n    }\n}\nclass IslamicRgsaHelper extends IslamicBaseHelper {\n    constructor() {\n        super(...arguments);\n        this.id = 'islamic-rgsa';\n    }\n}\nclass IslamicCcHelper extends IslamicBaseHelper {\n    constructor() {\n        super(...arguments);\n        this.id = 'islamicc';\n    }\n}\nclass PersianHelper extends HelperBase {\n    constructor() {\n        super(...arguments);\n        this.id = 'persian';\n        this.calendarType = 'solar';\n        this.constantEra = 'ap';\n    }\n    inLeapYear(calendarDate, cache) {\n        // Same logic (count days in the last month) for Persian as for Islamic,\n        // even though Persian is solar and Islamic is lunar.\n        return IslamicHelper.prototype.inLeapYear.call(this, calendarDate, cache);\n    }\n    monthsInYear( /* calendarYear, cache */) {\n        return 12;\n    }\n    minimumMonthLength(calendarDate) {\n        const { month } = calendarDate;\n        if (month === 12)\n            return 29;\n        return month <= 6 ? 31 : 30;\n    }\n    maximumMonthLength(calendarDate) {\n        const { month } = calendarDate;\n        if (month === 12)\n            return 30;\n        return month <= 6 ? 31 : 30;\n    }\n    estimateIsoDate(calendarDate) {\n        const { year } = this.adjustCalendarDate(calendarDate);\n        return { year: year + 621, month: 1, day: 1 };\n    }\n}\nclass IndianHelper extends HelperBase {\n    constructor() {\n        super(...arguments);\n        this.id = 'indian';\n        this.calendarType = 'solar';\n        this.constantEra = 'saka';\n        // Indian months always start at the same well-known Gregorian month and\n        // day. So this conversion is easy and fast. See\n        // https://en.wikipedia.org/wiki/Indian_national_calendar\n        this.months = {\n            1: { length: 30, month: 3, day: 22, leap: { length: 31, month: 3, day: 21 } },\n            2: { length: 31, month: 4, day: 21 },\n            3: { length: 31, month: 5, day: 22 },\n            4: { length: 31, month: 6, day: 22 },\n            5: { length: 31, month: 7, day: 23 },\n            6: { length: 31, month: 8, day: 23 },\n            7: { length: 30, month: 9, day: 23 },\n            8: { length: 30, month: 10, day: 23 },\n            9: { length: 30, month: 11, day: 22 },\n            10: { length: 30, month: 12, day: 22 },\n            11: { length: 30, month: 1, nextYear: true, day: 21 },\n            12: { length: 30, month: 2, nextYear: true, day: 20 }\n        };\n        // https://bugs.chromium.org/p/v8/issues/detail?id=10529 causes Intl's Indian\n        // calendar output to fail for all dates before 0001-01-01 ISO.  For example,\n        // in Node 12 0000-01-01 is calculated as 6146/12/-583 instead of 10/11/-79 as\n        // expected.\n        this.vulnerableToBceBug = new Date('0000-01-01T00:00Z').toLocaleDateString('en-US-u-ca-indian', { timeZone: 'UTC' }) !== '10/11/-79 Saka';\n    }\n    inLeapYear(calendarDate) {\n        // From https://en.wikipedia.org/wiki/Indian_national_calendar:\n        // Years are counted in the Saka era, which starts its year 0 in the year 78\n        // of the Common Era. To determine leap years, add 78 to the Saka year  if\n        // the result is a leap year in the Gregorian calendar, then the Saka year\n        // is a leap year as well.\n        return isGregorianLeapYear(calendarDate.year + 78);\n    }\n    monthsInYear( /* calendarYear, cache */) {\n        return 12;\n    }\n    minimumMonthLength(calendarDate) {\n        return this.getMonthInfo(calendarDate).length;\n    }\n    maximumMonthLength(calendarDate) {\n        return this.getMonthInfo(calendarDate).length;\n    }\n    getMonthInfo(calendarDate) {\n        const { month } = calendarDate;\n        let monthInfo = this.months[month];\n        if (monthInfo === undefined)\n            throw new RangeError(`Invalid month: ${month}`);\n        if (this.inLeapYear(calendarDate) && monthInfo.leap)\n            monthInfo = monthInfo.leap;\n        return monthInfo;\n    }\n    estimateIsoDate(calendarDateParam) {\n        // FYI, this \"estimate\" is always the exact ISO date, which makes the Indian\n        // calendar fast!\n        const calendarDate = this.adjustCalendarDate(calendarDateParam);\n        const monthInfo = this.getMonthInfo(calendarDate);\n        const isoYear = calendarDate.year + 78 + (monthInfo.nextYear ? 1 : 0);\n        const isoMonth = monthInfo.month;\n        const isoDay = monthInfo.day;\n        const isoDate = AddISODate(isoYear, isoMonth, isoDay, 0, 0, 0, calendarDate.day - 1, 'constrain');\n        return isoDate;\n    }\n    checkIcuBugs(isoDate) {\n        if (this.vulnerableToBceBug && isoDate.year < 1) {\n            throw new RangeError(`calendar '${this.id}' is broken for ISO dates before 0001-01-01` +\n                ' (see https://bugs.chromium.org/p/v8/issues/detail?id=10529)');\n        }\n    }\n}\n/**\n * This function adds additional metadata that makes it easier to work with\n * eras. Note that it mutates and normalizes the original era objects, which is\n * OK because this is non-observable, internal-only metadata.\n *\n * The result is an array of eras with the shape defined above.\n * */\nfunction adjustEras(erasParam) {\n    let eras = erasParam;\n    if (eras.length === 0) {\n        throw new RangeError('Invalid era data: eras are required');\n    }\n    if (eras.length === 1 && eras[0].reverseOf) {\n        throw new RangeError('Invalid era data: anchor era cannot count years backwards');\n    }\n    if (eras.length === 1 && !eras[0].name) {\n        throw new RangeError('Invalid era data: at least one named era is required');\n    }\n    if (eras.filter((e) => e.reverseOf != null).length > 1) {\n        throw new RangeError('Invalid era data: only one era can count years backwards');\n    }\n    // Find the \"anchor era\" which is the era used for (era-less) `year`. Reversed\n    // eras can never be anchors. The era without an `anchorEpoch` property is the\n    // anchor.\n    let anchorEra;\n    eras.forEach((e) => {\n        if (e.isAnchor || (!e.anchorEpoch && !e.reverseOf)) {\n            if (anchorEra)\n                throw new RangeError('Invalid era data: cannot have multiple anchor eras');\n            anchorEra = e;\n            e.anchorEpoch = { year: e.hasYearZero ? 0 : 1 };\n        }\n        else if (!e.name) {\n            throw new RangeError('If era name is blank, it must be the anchor era');\n        }\n    });\n    // If the era name is undefined, then it's an anchor that doesn't interact\n    // with eras at all. For example, Japanese `year` is always the same as ISO\n    // `year`.  So this \"era\" is the anchor era but isn't used for era matching.\n    // Strip it from the list that's returned.\n    eras = eras.filter((e) => e.name);\n    eras.forEach((e) => {\n        // Some eras are mirror images of another era e.g. B.C. is the reverse of A.D.\n        // Replace the string-valued \"reverseOf\" property with the actual era object\n        // that's reversed.\n        const { reverseOf } = e;\n        if (reverseOf) {\n            const reversedEra = eras.find((era) => era.name === reverseOf);\n            if (reversedEra === undefined)\n                throw new RangeError(`Invalid era data: unmatched reverseOf era: ${reverseOf}`);\n            e.reverseOf = reversedEra;\n            e.anchorEpoch = reversedEra.anchorEpoch;\n            e.isoEpoch = reversedEra.isoEpoch;\n        }\n        if (e.anchorEpoch.month === undefined)\n            e.anchorEpoch.month = 1;\n        if (e.anchorEpoch.day === undefined)\n            e.anchorEpoch.day = 1;\n    });\n    // Ensure that the latest epoch is first in the array. This lets us try to\n    // match eras in index order, with the last era getting the remaining older\n    // years. Any reverse-signed era must be at the end.\n    ArraySort.call(eras, (e1, e2) => {\n        if (e1.reverseOf)\n            return 1;\n        if (e2.reverseOf)\n            return -1;\n        if (!e1.isoEpoch || !e2.isoEpoch)\n            throw new RangeError('Invalid era data: missing ISO epoch');\n        return e2.isoEpoch.year - e1.isoEpoch.year;\n    });\n    // If there's a reversed era, then the one before it must be the era that's\n    // being reversed.\n    const lastEraReversed = eras[eras.length - 1].reverseOf;\n    if (lastEraReversed) {\n        if (lastEraReversed !== eras[eras.length - 2])\n            throw new RangeError('Invalid era data: invalid reverse-sign era');\n    }\n    // Finally, add a \"genericName\" property in the format \"era{n} where `n` is\n    // zero-based index, with the oldest era being zero. This format is used by\n    // older versions of ICU data.\n    eras.forEach((e, i) => {\n        e.genericName = `era${eras.length - 1 - i}`;\n    });\n    return { eras: eras, anchorEra: (anchorEra || eras[0]) };\n}\nfunction isGregorianLeapYear(year) {\n    return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);\n}\n/** Base for all Gregorian-like calendars. */\nclass GregorianBaseHelper extends HelperBase {\n    constructor(id, originalEras) {\n        super();\n        this.calendarType = 'solar';\n        // Several calendars based on the Gregorian calendar use Julian dates (not\n        // proleptic Gregorian dates) before the Julian switchover in Oct 1582. See\n        // https://bugs.chromium.org/p/chromium/issues/detail?id=1173158.\n        this.v8IsVulnerableToJulianBug = new Date('+001001-01-01T00:00Z')\n            .toLocaleDateString('en-US-u-ca-japanese', { timeZone: 'UTC' })\n            .startsWith('12');\n        this.calendarIsVulnerableToJulianBug = false;\n        this.id = id;\n        const { eras, anchorEra } = adjustEras(originalEras);\n        this.anchorEra = anchorEra;\n        this.eras = eras;\n    }\n    inLeapYear(calendarDate) {\n        // Calendars that don't override this method use the same months and leap\n        // years as Gregorian. Once we know the ISO year corresponding to the\n        // calendar year, we'll know if it's a leap year or not.\n        const { year } = this.estimateIsoDate({ month: 1, day: 1, year: calendarDate.year });\n        return isGregorianLeapYear(year);\n    }\n    monthsInYear( /* calendarDate */) {\n        return 12;\n    }\n    minimumMonthLength(calendarDate) {\n        const { month } = calendarDate;\n        if (month === 2)\n            return this.inLeapYear(calendarDate) ? 29 : 28;\n        return [4, 6, 9, 11].indexOf(month) >= 0 ? 30 : 31;\n    }\n    maximumMonthLength(calendarDate) {\n        return this.minimumMonthLength(calendarDate);\n    }\n    /** Fill in missing parts of the (year, era, eraYear) tuple */\n    completeEraYear(calendarDate) {\n        const checkField = (name, value) => {\n            const currentValue = calendarDate[name];\n            if (currentValue != null && currentValue != value) {\n                throw new RangeError(`Input ${name} ${currentValue} doesn't match calculated value ${value}`);\n            }\n        };\n        const eraFromYear = (year) => {\n            let eraYear;\n            const adjustedCalendarDate = { ...calendarDate, year };\n            const matchingEra = this.eras.find((e, i) => {\n                if (i === this.eras.length - 1) {\n                    if (e.reverseOf) {\n                        // This is a reverse-sign era (like BCE) which must be the oldest\n                        // era. Count years backwards.\n                        if (year > 0)\n                            throw new RangeError(`Signed year ${year} is invalid for era ${e.name}`);\n                        eraYear = e.anchorEpoch.year - year;\n                        return true;\n                    }\n                    // last era always gets all \"leftover\" (older than epoch) years,\n                    // so no need for a comparison like below.\n                    eraYear = year - e.anchorEpoch.year + (e.hasYearZero ? 0 : 1);\n                    return true;\n                }\n                const comparison = this.compareCalendarDates(adjustedCalendarDate, e.anchorEpoch);\n                if (comparison >= 0) {\n                    eraYear = year - e.anchorEpoch.year + (e.hasYearZero ? 0 : 1);\n                    return true;\n                }\n                return false;\n            });\n            if (!matchingEra)\n                throw new RangeError(`Year ${year} was not matched by any era`);\n            return { eraYear: eraYear, era: matchingEra.name };\n        };\n        let { year, eraYear, era } = calendarDate;\n        if (year != null) {\n            ({ eraYear, era } = eraFromYear(year));\n            checkField('era', era);\n            checkField('eraYear', eraYear);\n        }\n        else if (eraYear != null) {\n            const matchingEra = era === undefined ? undefined : this.eras.find((e) => e.name === era || e.genericName === era);\n            if (!matchingEra)\n                throw new RangeError(`Era ${era} (ISO year ${eraYear}) was not matched by any era`);\n            if (eraYear < 1 && matchingEra.reverseOf) {\n                throw new RangeError(`Years in ${era} era must be positive, not ${year}`);\n            }\n            if (matchingEra.reverseOf) {\n                year = matchingEra.anchorEpoch.year - eraYear;\n            }\n            else {\n                year = eraYear + matchingEra.anchorEpoch.year - (matchingEra.hasYearZero ? 0 : 1);\n            }\n            checkField('year', year);\n            // We'll accept dates where the month/day is earlier than the start of\n            // the era or after its end as long as it's in the same year. If that\n            // happens, we'll adjust the era/eraYear pair to be the correct era for\n            // the `year`.\n            ({ eraYear, era } = eraFromYear(year));\n        }\n        else {\n            throw new RangeError('Either `year` or `eraYear` and `era` are required');\n        }\n        return { ...calendarDate, year, eraYear, era };\n    }\n    adjustCalendarDate(calendarDateParam, cache, overflow = 'constrain') {\n        let calendarDate = calendarDateParam;\n        // Because this is not a lunisolar calendar, it's safe to convert monthCode to a number\n        const { month, monthCode } = calendarDate;\n        if (month === undefined)\n            calendarDate = { ...calendarDate, month: monthCodeNumberPart(monthCode) };\n        this.validateCalendarDate(calendarDate);\n        calendarDate = this.completeEraYear(calendarDate);\n        return super.adjustCalendarDate(calendarDate, cache, overflow);\n    }\n    estimateIsoDate(calendarDateParam) {\n        const calendarDate = this.adjustCalendarDate(calendarDateParam);\n        const { year, month, day } = calendarDate;\n        const { anchorEra } = this;\n        const isoYearEstimate = year + anchorEra.isoEpoch.year - (anchorEra.hasYearZero ? 0 : 1);\n        return RegulateISODate(isoYearEstimate, month, day, 'constrain');\n    }\n    checkIcuBugs(isoDate) {\n        if (this.calendarIsVulnerableToJulianBug && this.v8IsVulnerableToJulianBug) {\n            const beforeJulianSwitch = CompareISODate(isoDate.year, isoDate.month, isoDate.day, 1582, 10, 15) < 0;\n            if (beforeJulianSwitch) {\n                throw new RangeError(`calendar '${this.id}' is broken for ISO dates before 1582-10-15` +\n                    ' (see https://bugs.chromium.org/p/chromium/issues/detail?id=1173158)');\n            }\n        }\n    }\n}\nclass OrthodoxBaseHelper extends GregorianBaseHelper {\n    constructor(id, originalEras) {\n        super(id, originalEras);\n    }\n    inLeapYear(calendarDate) {\n        // Leap years happen one year before the Julian leap year. Note that this\n        // calendar is based on the Julian calendar which has a leap year every 4\n        // years, unlike the Gregorian calendar which doesn't have leap years on\n        // years divisible by 100 except years divisible by 400.\n        //\n        // Note that we're assuming that leap years in before-epoch times match\n        // how leap years are defined now. This is probably not accurate but I'm\n        // not sure how better to do it.\n        const { year } = calendarDate;\n        return (year + 1) % 4 === 0;\n    }\n    monthsInYear( /* calendarDate */) {\n        return 13;\n    }\n    minimumMonthLength(calendarDate) {\n        const { month } = calendarDate;\n        // Ethiopian/Coptic calendars have 12 30-day months and an extra 5-6 day 13th month.\n        if (month === 13)\n            return this.inLeapYear(calendarDate) ? 6 : 5;\n        return 30;\n    }\n    maximumMonthLength(calendarDate) {\n        return this.minimumMonthLength(calendarDate);\n    }\n}\n// `coptic` and `ethiopic` calendars are very similar to `ethioaa` calendar,\n// with the following differences:\n// - Coptic uses BCE-like positive numbers for years before its epoch (the other\n//   two use negative year numbers before epoch)\n// - Coptic has a different epoch date\n// - Ethiopic has an additional second era that starts at the same date as the\n//   zero era of ethioaa.\nclass EthioaaHelper extends OrthodoxBaseHelper {\n    constructor() {\n        super('ethioaa', [{ name: 'era0', isoEpoch: { year: -5492, month: 7, day: 17 } }]);\n    }\n}\nclass CopticHelper extends OrthodoxBaseHelper {\n    constructor() {\n        super('coptic', [\n            { name: 'era1', isoEpoch: { year: 284, month: 8, day: 29 } },\n            { name: 'era0', reverseOf: 'era1' }\n        ]);\n    }\n}\n// Anchor is currently the older era to match ethioaa, but should it be the newer era?\n// See https://github.com/tc39/ecma402/issues/534 for discussion.\nclass EthiopicHelper extends OrthodoxBaseHelper {\n    constructor() {\n        super('ethiopic', [\n            { name: 'era0', isoEpoch: { year: -5492, month: 7, day: 17 } },\n            { name: 'era1', isoEpoch: { year: 8, month: 8, day: 27 }, anchorEpoch: { year: 5501 } }\n        ]);\n    }\n}\nclass RocHelper extends GregorianBaseHelper {\n    constructor() {\n        super('roc', [\n            { name: 'minguo', isoEpoch: { year: 1912, month: 1, day: 1 } },\n            { name: 'before-roc', reverseOf: 'minguo' }\n        ]);\n        this.calendarIsVulnerableToJulianBug = true;\n    }\n}\nclass BuddhistHelper extends GregorianBaseHelper {\n    constructor() {\n        super('buddhist', [{ name: 'be', hasYearZero: true, isoEpoch: { year: -543, month: 1, day: 1 } }]);\n        this.calendarIsVulnerableToJulianBug = true;\n    }\n}\nclass GregoryHelper extends GregorianBaseHelper {\n    constructor() {\n        super('gregory', [\n            { name: 'ce', isoEpoch: { year: 1, month: 1, day: 1 } },\n            { name: 'bce', reverseOf: 'ce' }\n        ]);\n    }\n    reviseIntlEra(calendarDate /*, isoDate: IsoDate*/) {\n        let { era, eraYear } = calendarDate;\n        // Firefox 96 introduced a bug where the `'short'` format of the era\n        // option mistakenly returns the one-letter (narrow) format instead. The\n        // code below handles either the correct or Firefox-buggy format. See\n        // https://bugzilla.mozilla.org/show_bug.cgi?id=1752253\n        if (era === 'bc' || era === 'b')\n            era = 'bce';\n        if (era === 'ad' || era === 'a')\n            era = 'ce';\n        return { era, eraYear };\n    }\n}\n// NOTE: Only the 5 modern eras (Meiji and later) are included. For dates\n// before Meiji 1, the `ce` and `bce` eras are used. Challenges with pre-Meiji\n// eras include:\n// - Start/end dates of older eras are not precisely defined, which is\n//   challenging given Temporal's need for precision\n// - Some era dates and/or names are disputed by historians\n// - As historical research proceeds, new eras are discovered and existing era\n//   dates are modified, leading to considerable churn which is not good for\n//   Temporal use.\n//  - The earliest era (in 645 CE) may not end up being the earliest depending\n//    on future historical scholarship\n//  - Before Meiji, Japan used a lunar (or lunisolar?) calendar but AFAIK\n//    that's not reflected in the ICU implementation.\n//\n// For more discussion: https://github.com/tc39/proposal-temporal/issues/526.\n//\n// Here's a full list of CLDR/ICU eras:\n// https://github.com/unicode-org/icu/blob/master/icu4c/source/data/locales/root.txt#L1582-L1818\n// https://github.com/unicode-org/cldr/blob/master/common/supplemental/supplementalData.xml#L4310-L4546\n//\n// NOTE: Japan started using the Gregorian calendar in 6 Meiji, replacing a\n// lunisolar calendar. So the day before January 1 of 6 Meiji (1873) was not\n// December 31, but December 2, of 5 Meiji (1872). The existing Ecma-402\n// Japanese calendar doesn't seem to take this into account, so neither do we:\n// > args = ['en-ca-u-ca-japanese', { era: 'short' }]\n// > new Date('1873-01-01T12:00').toLocaleString(...args)\n// '1 1, 6 Meiji, 12:00:00 PM'\n// > new Date('1872-12-31T12:00').toLocaleString(...args)\n// '12 31, 5 Meiji, 12:00:00 PM'\nclass JapaneseHelper extends GregorianBaseHelper {\n    constructor() {\n        super('japanese', [\n            // The Japanese calendar `year` is just the ISO year, because (unlike other\n            // ICU calendars) there's no obvious \"default era\", we use the ISO year.\n            { name: 'reiwa', isoEpoch: { year: 2019, month: 5, day: 1 }, anchorEpoch: { year: 2019, month: 5, day: 1 } },\n            { name: 'heisei', isoEpoch: { year: 1989, month: 1, day: 8 }, anchorEpoch: { year: 1989, month: 1, day: 8 } },\n            { name: 'showa', isoEpoch: { year: 1926, month: 12, day: 25 }, anchorEpoch: { year: 1926, month: 12, day: 25 } },\n            { name: 'taisho', isoEpoch: { year: 1912, month: 7, day: 30 }, anchorEpoch: { year: 1912, month: 7, day: 30 } },\n            { name: 'meiji', isoEpoch: { year: 1868, month: 9, day: 8 }, anchorEpoch: { year: 1868, month: 9, day: 8 } },\n            { name: 'ce', isoEpoch: { year: 1, month: 1, day: 1 } },\n            { name: 'bce', reverseOf: 'ce' }\n        ]);\n        this.calendarIsVulnerableToJulianBug = true;\n        // The last 3 Japanese eras confusingly return only one character in the\n        // default \"short\" era, so need to use the long format.\n        this.eraLength = 'long';\n    }\n    reviseIntlEra(calendarDate, isoDate) {\n        const { era, eraYear } = calendarDate;\n        const { year: isoYear } = isoDate;\n        if (this.eras.find((e) => e.name === era))\n            return { era, eraYear };\n        return (isoYear < 1 ? { era: 'bce', eraYear: 1 - isoYear } : { era: 'ce', eraYear: isoYear });\n    }\n}\nclass ChineseBaseHelper extends HelperBase {\n    constructor() {\n        super(...arguments);\n        this.calendarType = 'lunisolar';\n        // All built-in calendars except Chinese/Dangi and Hebrew use an era\n        this.hasEra = false;\n    }\n    inLeapYear(calendarDate, cache) {\n        const months = this.getMonthList(calendarDate.year, cache);\n        return ObjectEntries(months).length === 13;\n    }\n    monthsInYear(calendarDate, cache) {\n        return this.inLeapYear(calendarDate, cache) ? 13 : 12;\n    }\n    minimumMonthLength( /* calendarDate */) {\n        return 29;\n    }\n    maximumMonthLength( /* calendarDate */) {\n        return 30;\n    }\n    getMonthList(calendarYear, cache) {\n        if (calendarYear === undefined) {\n            throw new TypeError('Missing year');\n        }\n        const key = JSON.stringify({ func: 'getMonthList', calendarYear, id: this.id });\n        const cached = cache.get(key);\n        if (cached)\n            return cached;\n        const dateTimeFormat = this.getFormatter();\n        const getCalendarDate = (isoYear, daysPastFeb1) => {\n            const isoStringFeb1 = toUtcIsoDateString({ isoYear, isoMonth: 2, isoDay: 1 });\n            const legacyDate = new Date(isoStringFeb1);\n            // Now add the requested number of days, which may wrap to the next month.\n            legacyDate.setUTCDate(daysPastFeb1 + 1);\n            const newYearGuess = dateTimeFormat.formatToParts(legacyDate);\n            const calendarMonthString = newYearGuess.find((tv) => tv.type === 'month').value;\n            const calendarDay = +newYearGuess.find((tv) => tv.type === 'day').value;\n            let calendarYearToVerify = newYearGuess.find((tv) => tv.type === 'relatedYear');\n            if (calendarYearToVerify !== undefined) {\n                calendarYearToVerify = +calendarYearToVerify.value;\n            }\n            else {\n                // Node 12 has outdated ICU data that lacks the `relatedYear` field in the\n                // output of Intl.DateTimeFormat.formatToParts.\n                throw new RangeError(`Intl.DateTimeFormat.formatToParts lacks relatedYear in ${this.id} calendar. Try Node 14+ or modern browsers.`);\n            }\n            return { calendarMonthString, calendarDay, calendarYearToVerify };\n        };\n        // First, find a date close to Chinese New Year. Feb 17 will either be in\n        // the first month or near the end of the last month of the previous year.\n        let isoDaysDelta = 17;\n        let { calendarMonthString, calendarDay, calendarYearToVerify } = getCalendarDate(calendarYear, isoDaysDelta);\n        // If we didn't guess the first month correctly, add (almost in some months)\n        // a lunar month\n        if (calendarMonthString !== '1') {\n            isoDaysDelta += 29;\n            ({ calendarMonthString, calendarDay } = getCalendarDate(calendarYear, isoDaysDelta));\n        }\n        // Now back up to near the start of the first month, but not too near that\n        // off-by-one issues matter.\n        isoDaysDelta -= calendarDay - 5;\n        const result = {};\n        let monthIndex = 1;\n        let oldCalendarDay;\n        let oldMonthString;\n        let done = false;\n        do {\n            ({ calendarMonthString, calendarDay, calendarYearToVerify } = getCalendarDate(calendarYear, isoDaysDelta));\n            if (oldCalendarDay) {\n                result[oldMonthString].daysInMonth = oldCalendarDay + 30 - calendarDay;\n            }\n            if (calendarYearToVerify !== calendarYear) {\n                done = true;\n            }\n            else {\n                result[calendarMonthString] = { monthIndex: monthIndex++ };\n                // Move to the next month. Because months are sometimes 29 days, the day of the\n                // calendar month will move forward slowly but not enough to flip over to a new\n                // month before the loop ends at 12-13 months.\n                isoDaysDelta += 30;\n            }\n            oldCalendarDay = calendarDay;\n            oldMonthString = calendarMonthString;\n        } while (!done);\n        result[oldMonthString].daysInMonth = oldCalendarDay + 30 - calendarDay;\n        cache.set(key, result);\n        return result;\n    }\n    estimateIsoDate(calendarDate) {\n        const { year, month } = calendarDate;\n        return { year, month: month >= 12 ? 12 : month + 1, day: 1 };\n    }\n    adjustCalendarDate(calendarDate, cache, overflow = 'constrain', fromLegacyDate = false) {\n        let { year, month, monthExtra, day, monthCode, eraYear } = calendarDate;\n        if (fromLegacyDate) {\n            // Legacy Date output returns a string that's an integer with an optional\n            // \"bis\" suffix used only by the Chinese/Dangi calendar to indicate a leap\n            // month. Below we'll normalize the output.\n            year = eraYear;\n            if (monthExtra && monthExtra !== 'bis')\n                throw new RangeError(`Unexpected leap month suffix: ${monthExtra}`);\n            const monthCode = buildMonthCode(month, monthExtra !== undefined);\n            const monthString = `${month}${monthExtra || ''}`;\n            const months = this.getMonthList(year, cache);\n            const monthInfo = months[monthString];\n            if (monthInfo === undefined)\n                throw new RangeError(`Unmatched month ${monthString} in Chinese year ${year}`);\n            month = monthInfo.monthIndex;\n            return { year: year, month, day: day, era: undefined, eraYear, monthCode };\n        }\n        else {\n            // When called without input coming from legacy Date output,\n            // simply ensure that all fields are present.\n            this.validateCalendarDate(calendarDate);\n            if (year === undefined)\n                year = eraYear;\n            if (eraYear === undefined)\n                eraYear = year;\n            if (month === undefined) {\n                const months = this.getMonthList(year, cache);\n                let numberPart = monthCode.replace('L', 'bis').slice(1);\n                if (numberPart[0] === '0')\n                    numberPart = numberPart.slice(1);\n                let monthInfo = months[numberPart];\n                month = monthInfo && monthInfo.monthIndex;\n                // If this leap month isn't present in this year, constrain down to the last day of the previous month.\n                if (month === undefined &&\n                    monthCode.endsWith('L') &&\n                    !ArrayIncludes.call(['M01L', 'M12L', 'M13L'], monthCode) &&\n                    overflow === 'constrain') {\n                    let withoutML = monthCode.slice(1, -1);\n                    if (withoutML[0] === '0')\n                        withoutML = withoutML.slice(1);\n                    monthInfo = months[withoutML];\n                    if (monthInfo) {\n                        ({ daysInMonth: day, monthIndex: month } = monthInfo);\n                        monthCode = buildMonthCode(withoutML);\n                    }\n                }\n                if (month === undefined) {\n                    throw new RangeError(`Unmatched month ${monthCode} in Chinese year ${year}`);\n                }\n            }\n            else if (monthCode === undefined) {\n                const months = this.getMonthList(year, cache);\n                const monthEntries = ObjectEntries(months);\n                const largestMonth = monthEntries.length;\n                if (overflow === 'reject') {\n                    RejectToRange(month, 1, largestMonth);\n                    RejectToRange(day, 1, this.maximumMonthLength());\n                }\n                else {\n                    month = ConstrainToRange(month, 1, largestMonth);\n                    day = ConstrainToRange(day, 1, this.maximumMonthLength());\n                }\n                const matchingMonthEntry = monthEntries.find(([, v]) => v.monthIndex === month);\n                if (matchingMonthEntry === undefined) {\n                    throw new RangeError(`Invalid month ${month} in Chinese year ${year}`);\n                }\n                monthCode = buildMonthCode(matchingMonthEntry[0].replace('bis', ''), matchingMonthEntry[0].indexOf('bis') !== -1);\n            }\n            else {\n                // Both month and monthCode are present. Make sure they don't conflict.\n                const months = this.getMonthList(year, cache);\n                let numberPart = monthCode.replace('L', 'bis').slice(1);\n                if (numberPart[0] === '0')\n                    numberPart = numberPart.slice(1);\n                const monthInfo = months[numberPart];\n                if (!monthInfo)\n                    throw new RangeError(`Unmatched monthCode ${monthCode} in Chinese year ${year}`);\n                if (month !== monthInfo.monthIndex) {\n                    throw new RangeError(`monthCode ${monthCode} doesn't correspond to month ${month} in Chinese year ${year}`);\n                }\n            }\n            return {\n                ...calendarDate,\n                year: year,\n                eraYear,\n                month,\n                monthCode: monthCode,\n                day: day\n            };\n        }\n    }\n}\nclass ChineseHelper extends ChineseBaseHelper {\n    constructor() {\n        super(...arguments);\n        this.id = 'chinese';\n    }\n}\n// Dangi (Korean) calendar has same implementation as Chinese\nclass DangiHelper extends ChineseBaseHelper {\n    constructor() {\n        super(...arguments);\n        this.id = 'dangi';\n    }\n}\n/**\n * Common implementation of all non-ISO calendars.\n * Per-calendar id and logic live in `id` and `helper` properties attached later.\n * This split allowed an easy separation between code that was similar between\n * ISO and non-ISO implementations vs. code that was very different.\n */\nconst nonIsoImpl = {\n    // `helper` is added when this object is spread into each calendar's\n    // implementation\n    helper: undefined,\n    dateFromFields(fieldsParam, options, calendar) {\n        const overflow = ToTemporalOverflow(options);\n        const cache = new OneObjectCache();\n        // Intentionally alphabetical\n        const fields = PrepareTemporalFields(fieldsParam, [\n            ['day'],\n            ['era', undefined],\n            ['eraYear', undefined],\n            ['month', undefined],\n            ['monthCode', undefined],\n            ['year', undefined]\n        ]);\n        const { year, month, day } = this.helper.calendarToIsoDate(fields, overflow, cache);\n        const result = CreateTemporalDate(year, month, day, calendar);\n        cache.setObject(result);\n        return result;\n    },\n    yearMonthFromFields(fieldsParam, options, calendar) {\n        const overflow = ToTemporalOverflow(options);\n        const cache = new OneObjectCache();\n        // Intentionally alphabetical\n        const fields = PrepareTemporalFields(fieldsParam, [\n            ['era', undefined],\n            ['eraYear', undefined],\n            ['month', undefined],\n            ['monthCode', undefined],\n            ['year', undefined]\n        ]);\n        const { year, month, day } = this.helper.calendarToIsoDate({ ...fields, day: 1 }, overflow, cache);\n        const result = CreateTemporalYearMonth(year, month, calendar, /* referenceISODay = */ day);\n        cache.setObject(result);\n        return result;\n    },\n    monthDayFromFields(fieldsParam, options, calendar) {\n        const overflow = ToTemporalOverflow(options);\n        // All built-in calendars require `day`, but some allow other fields to be\n        // substituted for `month`. And for lunisolar calendars, either `monthCode`\n        // or `year` must be provided because `month` is ambiguous without a year or\n        // a code.\n        const cache = new OneObjectCache();\n        const fields = PrepareTemporalFields(fieldsParam, [\n            ['day'],\n            ['era', undefined],\n            ['eraYear', undefined],\n            ['month', undefined],\n            ['monthCode', undefined],\n            ['year', undefined]\n        ]);\n        const { year, month, day } = this.helper.monthDayFromFields(fields, overflow, cache);\n        // `year` is a reference year where this month/day exists in this calendar\n        const result = CreateTemporalMonthDay(month, day, calendar, /* referenceISOYear = */ year);\n        cache.setObject(result);\n        return result;\n    },\n    fields(fieldsParam) {\n        let fields = fieldsParam;\n        if (ArrayIncludes.call(fields, 'year'))\n            fields = [...fields, 'era', 'eraYear'];\n        return fields;\n    },\n    mergeFields(fields, additionalFields) {\n        const fieldsCopy = { ...fields };\n        const additionalFieldsCopy = { ...additionalFields };\n        // era and eraYear are intentionally unused\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        const { month, monthCode, year, era, eraYear, ...original } = fieldsCopy;\n        const { month: newMonth, monthCode: newMonthCode, year: newYear, era: newEra, eraYear: newEraYear } = additionalFieldsCopy;\n        if (newMonth === undefined && newMonthCode === undefined) {\n            original.month = month;\n            original.monthCode = monthCode;\n        }\n        if (newYear === undefined && newEra === undefined && newEraYear === undefined) {\n            // Only `year` is needed. We don't set era and eraYear because it's\n            // possible to create a conflict for eras that start or end mid-year. See\n            // https://github.com/tc39/proposal-temporal/issues/1784.\n            original.year = year;\n        }\n        return { ...original, ...additionalFieldsCopy };\n    },\n    dateAdd(date, years, months, weeks, days, overflow, calendar) {\n        const cache = OneObjectCache.getCacheForObject(date);\n        const calendarDate = this.helper.temporalToCalendarDate(date, cache);\n        const added = this.helper.addCalendar(calendarDate, { years, months, weeks, days }, overflow, cache);\n        const isoAdded = this.helper.calendarToIsoDate(added, 'constrain', cache);\n        const { year, month, day } = isoAdded;\n        const newTemporalObject = CreateTemporalDate(year, month, day, calendar);\n        // The new object's cache starts with the cache of the old object\n        const newCache = new OneObjectCache(cache);\n        newCache.setObject(newTemporalObject);\n        return newTemporalObject;\n    },\n    dateUntil(one, two, largestUnit) {\n        const cacheOne = OneObjectCache.getCacheForObject(one);\n        const cacheTwo = OneObjectCache.getCacheForObject(two);\n        const calendarOne = this.helper.temporalToCalendarDate(one, cacheOne);\n        const calendarTwo = this.helper.temporalToCalendarDate(two, cacheTwo);\n        const result = this.helper.untilCalendar(calendarOne, calendarTwo, largestUnit, cacheOne);\n        return result;\n    },\n    year(date) {\n        const cache = OneObjectCache.getCacheForObject(date);\n        const calendarDate = this.helper.temporalToCalendarDate(date, cache);\n        return calendarDate.year;\n    },\n    month(date) {\n        const cache = OneObjectCache.getCacheForObject(date);\n        const calendarDate = this.helper.temporalToCalendarDate(date, cache);\n        return calendarDate.month;\n    },\n    day(date) {\n        const cache = OneObjectCache.getCacheForObject(date);\n        const calendarDate = this.helper.temporalToCalendarDate(date, cache);\n        return calendarDate.day;\n    },\n    era(date) {\n        if (!this.helper.hasEra)\n            return undefined;\n        const cache = OneObjectCache.getCacheForObject(date);\n        const calendarDate = this.helper.temporalToCalendarDate(date, cache);\n        return calendarDate.era;\n    },\n    eraYear(date) {\n        if (!this.helper.hasEra)\n            return undefined;\n        const cache = OneObjectCache.getCacheForObject(date);\n        const calendarDate = this.helper.temporalToCalendarDate(date, cache);\n        return calendarDate.eraYear;\n    },\n    monthCode(date) {\n        const cache = OneObjectCache.getCacheForObject(date);\n        const calendarDate = this.helper.temporalToCalendarDate(date, cache);\n        return calendarDate.monthCode;\n    },\n    dayOfWeek(date) {\n        return impl['iso8601'].dayOfWeek(date);\n    },\n    dayOfYear(date) {\n        const cache = OneObjectCache.getCacheForObject(date);\n        const calendarDate = this.helper.isoToCalendarDate(date, cache);\n        const startOfYear = this.helper.startOfCalendarYear(calendarDate);\n        const diffDays = this.helper.calendarDaysUntil(startOfYear, calendarDate, cache);\n        return diffDays + 1;\n    },\n    weekOfYear(date) {\n        return impl['iso8601'].weekOfYear(date);\n    },\n    daysInWeek(date) {\n        return impl['iso8601'].daysInWeek(date);\n    },\n    daysInMonth(date) {\n        const cache = OneObjectCache.getCacheForObject(date);\n        const calendarDate = this.helper.temporalToCalendarDate(date, cache);\n        // Easy case: if the helper knows the length without any heavy calculation.\n        const max = this.helper.maximumMonthLength(calendarDate);\n        const min = this.helper.minimumMonthLength(calendarDate);\n        if (max === min)\n            return max;\n        // The harder case is where months vary every year, e.g. islamic calendars.\n        // Find the answer by calculating the difference in days between the first\n        // day of the current month and the first day of the next month.\n        const startOfMonthCalendar = this.helper.startOfCalendarMonth(calendarDate);\n        const startOfNextMonthCalendar = this.helper.addMonthsCalendar(startOfMonthCalendar, 1, 'constrain', cache);\n        const result = this.helper.calendarDaysUntil(startOfMonthCalendar, startOfNextMonthCalendar, cache);\n        return result;\n    },\n    daysInYear(dateParam) {\n        let date = dateParam;\n        if (!HasSlot(date, ISO_YEAR))\n            date = ToTemporalDate(date);\n        const cache = OneObjectCache.getCacheForObject(date);\n        const calendarDate = this.helper.temporalToCalendarDate(date, cache);\n        const startOfYearCalendar = this.helper.startOfCalendarYear(calendarDate);\n        const startOfNextYearCalendar = this.helper.addCalendar(startOfYearCalendar, { years: 1 }, 'constrain', cache);\n        const result = this.helper.calendarDaysUntil(startOfYearCalendar, startOfNextYearCalendar, cache);\n        return result;\n    },\n    monthsInYear(date) {\n        const cache = OneObjectCache.getCacheForObject(date);\n        const calendarDate = this.helper.temporalToCalendarDate(date, cache);\n        const result = this.helper.monthsInYear(calendarDate, cache);\n        return result;\n    },\n    inLeapYear(dateParam) {\n        let date = dateParam;\n        if (!HasSlot(date, ISO_YEAR))\n            date = ToTemporalDate(date);\n        const cache = OneObjectCache.getCacheForObject(date);\n        const calendarDate = this.helper.temporalToCalendarDate(date, cache);\n        const result = this.helper.inLeapYear(calendarDate, cache);\n        return result;\n    }\n};\nfor (const Helper of [\n    HebrewHelper,\n    PersianHelper,\n    EthiopicHelper,\n    EthioaaHelper,\n    CopticHelper,\n    ChineseHelper,\n    DangiHelper,\n    RocHelper,\n    IndianHelper,\n    BuddhistHelper,\n    GregoryHelper,\n    JapaneseHelper,\n    IslamicHelper,\n    IslamicUmalquraHelper,\n    IslamicTblaHelper,\n    IslamicCivilHelper,\n    IslamicRgsaHelper,\n    IslamicCcHelper\n]) {\n    const helper = new Helper();\n    // Clone the singleton non-ISO implementation that's the same for all\n    // calendars. The `helper` property contains per-calendar logic.\n    impl[helper.id] = { ...nonIsoImpl, helper };\n}\nconst BUILTIN_CALENDAR_IDS = Object.keys(impl);\nfunction IsBuiltinCalendar(id) {\n    return ArrayIncludes.call(BUILTIN_CALENDAR_IDS, id);\n}\n\nconst tzComponent = /\\.[-A-Za-z_]|\\.\\.[-A-Za-z._]{1,12}|\\.[-A-Za-z_][-A-Za-z._]{0,12}|[A-Za-z_][-A-Za-z._]{0,13}/;\nconst offsetNoCapture = /(?:[+\\u2212-][0-2][0-9](?::?[0-5][0-9](?::?[0-5][0-9](?:[.,]\\d{1,9})?)?)?)/;\nconst timeZoneID = new RegExp(`(?:(?:${tzComponent.source})(?:\\\\/(?:${tzComponent.source}))*|Etc/GMT[-+]\\\\d{1,2}|${offsetNoCapture.source})`);\nconst calComponent = /[A-Za-z0-9]{3,8}/;\nconst calendarID = new RegExp(`(?:${calComponent.source}(?:-${calComponent.source})*)`);\nconst yearpart = /(?:[+\\u2212-]\\d{6}|\\d{4})/;\nconst monthpart = /(?:0[1-9]|1[0-2])/;\nconst daypart = /(?:0[1-9]|[12]\\d|3[01])/;\nconst datesplit = new RegExp(`(${yearpart.source})(?:-(${monthpart.source})-(${daypart.source})|(${monthpart.source})(${daypart.source}))`);\nconst timesplit = /(\\d{2})(?::(\\d{2})(?::(\\d{2})(?:[.,](\\d{1,9}))?)?|(\\d{2})(?:(\\d{2})(?:[.,](\\d{1,9}))?)?)?/;\nconst offset = /([+\\u2212-])([01][0-9]|2[0-3])(?::?([0-5][0-9])(?::?([0-5][0-9])(?:[.,](\\d{1,9}))?)?)?/;\nconst zonesplit = new RegExp(`(?:([zZ])|(?:${offset.source})?)(?:\\\\[(${timeZoneID.source})\\\\])?`);\nconst calendar = new RegExp(`\\\\[u-ca=(${calendarID.source})\\\\]`);\nconst zoneddatetime = new RegExp(`^${datesplit.source}(?:(?:T|\\\\s+)${timesplit.source})?${zonesplit.source}(?:${calendar.source})?$`, 'i');\nconst time = new RegExp(`^T?${timesplit.source}(?:${zonesplit.source})?(?:${calendar.source})?$`, 'i');\n// The short forms of YearMonth and MonthDay are only for the ISO calendar.\n// Non-ISO calendar YearMonth and MonthDay have to parse as a Temporal.PlainDate,\n// with the reference fields.\n// YYYYMM forbidden by ISO 8601 because ambiguous with YYMMDD, but allowed by\n// RFC 3339 and we don't allow 2-digit years, so we allow it.\n// Not ambiguous with HHMMSS because that requires a 'T' prefix\nconst yearmonth = new RegExp(`^(${yearpart.source})-?(${monthpart.source})$`);\nconst monthday = new RegExp(`^(?:--)?(${monthpart.source})-?(${daypart.source})$`);\nconst fraction = /(\\d+)(?:[.,](\\d{1,9}))?/;\nconst durationDate = /(?:(\\d+)Y)?(?:(\\d+)M)?(?:(\\d+)W)?(?:(\\d+)D)?/;\nconst durationTime = new RegExp(`(?:${fraction.source}H)?(?:${fraction.source}M)?(?:${fraction.source}S)?`);\nconst duration = new RegExp(`^([+\\u2212-])?P${durationDate.source}(?:T(?!$)${durationTime.source})?$`, 'i');\n\nconst ArrayPrototypePush$1 = Array.prototype.push;\nconst IntlDateTimeFormat$1 = globalThis.Intl.DateTimeFormat;\nconst MathMin = Math.min;\nconst MathMax = Math.max;\nconst MathAbs = Math.abs;\nconst MathFloor = Math.floor;\nconst MathSign = Math.sign;\nconst MathTrunc = Math.trunc;\nconst NumberIsNaN = Number.isNaN;\nconst NumberIsFinite = Number.isFinite;\nconst NumberCtor = Number;\nconst StringCtor = String;\nconst NumberMaxSafeInteger = Number.MAX_SAFE_INTEGER;\nconst ObjectCreate$2 = Object.create;\nconst ObjectDefineProperty = Object.defineProperty;\nconst ObjectIs = Object.is;\nconst ReflectApply$1 = Reflect.apply;\nconst ZERO = jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(0);\nconst ONE = jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(1);\nconst SIXTY = jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(60);\nconst THOUSAND = jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(1e3);\nconst MILLION = jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(1e6);\nconst BILLION = jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(1e9);\nconst NEGATIVE_ONE = jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(-1);\nconst DAY_SECONDS = 86400;\nconst DAY_NANOS = jsbi__WEBPACK_IMPORTED_MODULE_0__.multiply(jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(DAY_SECONDS), BILLION);\nconst NS_MIN = jsbi__WEBPACK_IMPORTED_MODULE_0__.multiply(jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(-86400), jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(1e17));\nconst NS_MAX = jsbi__WEBPACK_IMPORTED_MODULE_0__.multiply(jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(86400), jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(1e17));\nconst YEAR_MIN = -271821;\nconst YEAR_MAX = 275760;\nconst BEFORE_FIRST_OFFSET_TRANSITION = jsbi__WEBPACK_IMPORTED_MODULE_0__.multiply(jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(-388152), jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(1e13)); // 1847-01-01T00:00:00Z\nconst ABOUT_TEN_YEARS_NANOS = jsbi__WEBPACK_IMPORTED_MODULE_0__.multiply(DAY_NANOS, jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(366 * 10));\nconst ABOUT_ONE_YEAR_NANOS = jsbi__WEBPACK_IMPORTED_MODULE_0__.multiply(DAY_NANOS, jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(366 * 1));\nconst TWO_WEEKS_NANOS = jsbi__WEBPACK_IMPORTED_MODULE_0__.multiply(DAY_NANOS, jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(2 * 7));\nfunction IsInteger(value) {\n    if (typeof value !== 'number' || !NumberIsFinite(value))\n        return false;\n    const abs = MathAbs(value);\n    return MathFloor(abs) === abs;\n}\nfunction IsObject(value) {\n    return (typeof value === 'object' && value !== null) || typeof value === 'function';\n}\nfunction ToNumber(value) {\n    if (typeof value === 'bigint')\n        throw new TypeError('Cannot convert BigInt to number');\n    return NumberCtor(value);\n}\nfunction ToInteger(value) {\n    const num = ToNumber(value);\n    if (NumberIsNaN(num))\n        return 0;\n    const integer = MathTrunc(num);\n    if (num === 0)\n        return 0;\n    return integer;\n}\nfunction ToString(value) {\n    if (typeof value === 'symbol') {\n        throw new TypeError('Cannot convert a Symbol value to a String');\n    }\n    return StringCtor(value);\n}\nfunction ToIntegerThrowOnInfinity(value) {\n    const integer = ToInteger(value);\n    if (!NumberIsFinite(integer)) {\n        throw new RangeError('infinity is out of range');\n    }\n    return integer;\n}\nfunction ToPositiveInteger(valueParam, property) {\n    const value = ToInteger(valueParam);\n    if (!NumberIsFinite(value)) {\n        throw new RangeError('infinity is out of range');\n    }\n    if (value < 1) {\n        if (property !== undefined) {\n            throw new RangeError(`property '${property}' cannot be a a number less than one`);\n        }\n        throw new RangeError('Cannot convert a number less than one to a positive integer');\n    }\n    return value;\n}\nfunction ToIntegerWithoutRounding(valueParam) {\n    const value = ToNumber(valueParam);\n    if (NumberIsNaN(value))\n        return 0;\n    if (!NumberIsFinite(value)) {\n        throw new RangeError('infinity is out of range');\n    }\n    if (!IsInteger(value)) {\n        throw new RangeError(`unsupported fractional value ${value}`);\n    }\n    return ToInteger(value); // (value) in spec text; converts -0 to 0\n}\nfunction divmod(x, y) {\n    const quotient = jsbi__WEBPACK_IMPORTED_MODULE_0__.divide(x, y);\n    const remainder = jsbi__WEBPACK_IMPORTED_MODULE_0__.remainder(x, y);\n    return { quotient, remainder };\n}\nfunction abs(x) {\n    if (jsbi__WEBPACK_IMPORTED_MODULE_0__.lessThan(x, ZERO))\n        return jsbi__WEBPACK_IMPORTED_MODULE_0__.multiply(x, NEGATIVE_ONE);\n    return x;\n}\nconst BUILTIN_CASTS = new Map([\n    ['year', ToIntegerThrowOnInfinity],\n    ['month', ToPositiveInteger],\n    ['monthCode', ToString],\n    ['day', ToPositiveInteger],\n    ['hour', ToIntegerThrowOnInfinity],\n    ['minute', ToIntegerThrowOnInfinity],\n    ['second', ToIntegerThrowOnInfinity],\n    ['millisecond', ToIntegerThrowOnInfinity],\n    ['microsecond', ToIntegerThrowOnInfinity],\n    ['nanosecond', ToIntegerThrowOnInfinity],\n    ['years', ToIntegerWithoutRounding],\n    ['months', ToIntegerWithoutRounding],\n    ['weeks', ToIntegerWithoutRounding],\n    ['days', ToIntegerWithoutRounding],\n    ['hours', ToIntegerWithoutRounding],\n    ['minutes', ToIntegerWithoutRounding],\n    ['seconds', ToIntegerWithoutRounding],\n    ['milliseconds', ToIntegerWithoutRounding],\n    ['microseconds', ToIntegerWithoutRounding],\n    ['nanoseconds', ToIntegerWithoutRounding],\n    ['era', ToString],\n    ['eraYear', ToInteger],\n    ['offset', ToString]\n]);\nconst ALLOWED_UNITS = [\n    'year',\n    'month',\n    'week',\n    'day',\n    'hour',\n    'minute',\n    'second',\n    'millisecond',\n    'microsecond',\n    'nanosecond'\n];\nconst SINGULAR_PLURAL_UNITS = [\n    ['years', 'year'],\n    ['months', 'month'],\n    ['weeks', 'week'],\n    ['days', 'day'],\n    ['hours', 'hour'],\n    ['minutes', 'minute'],\n    ['seconds', 'second'],\n    ['milliseconds', 'millisecond'],\n    ['microseconds', 'microsecond'],\n    ['nanoseconds', 'nanosecond']\n];\nconst IntlDateTimeFormatEnUsCache = new Map();\nfunction getIntlDateTimeFormatEnUsForTimeZone(timeZoneIdentifier) {\n    let instance = IntlDateTimeFormatEnUsCache.get(timeZoneIdentifier);\n    if (instance === undefined) {\n        instance = new IntlDateTimeFormat$1('en-us', {\n            timeZone: StringCtor(timeZoneIdentifier),\n            hour12: false,\n            era: 'short',\n            year: 'numeric',\n            month: 'numeric',\n            day: 'numeric',\n            hour: 'numeric',\n            minute: 'numeric',\n            second: 'numeric'\n        });\n        IntlDateTimeFormatEnUsCache.set(timeZoneIdentifier, instance);\n    }\n    return instance;\n}\nfunction IsTemporalInstant(item) {\n    return HasSlot(item, EPOCHNANOSECONDS) && !HasSlot(item, TIME_ZONE, CALENDAR);\n}\nfunction IsTemporalTimeZone(item) {\n    return HasSlot(item, TIMEZONE_ID);\n}\nfunction IsTemporalCalendar(item) {\n    return HasSlot(item, CALENDAR_ID);\n}\nfunction IsTemporalDuration(item) {\n    return HasSlot(item, YEARS, MONTHS, DAYS, HOURS, MINUTES, SECONDS, MILLISECONDS, MICROSECONDS, NANOSECONDS);\n}\nfunction IsTemporalDate(item) {\n    return HasSlot(item, DATE_BRAND);\n}\nfunction IsTemporalTime(item) {\n    return (HasSlot(item, ISO_HOUR, ISO_MINUTE, ISO_SECOND, ISO_MILLISECOND, ISO_MICROSECOND, ISO_NANOSECOND) &&\n        !HasSlot(item, ISO_YEAR, ISO_MONTH, ISO_DAY));\n}\nfunction IsTemporalDateTime(item) {\n    return HasSlot(item, ISO_YEAR, ISO_MONTH, ISO_DAY, ISO_HOUR, ISO_MINUTE, ISO_SECOND, ISO_MILLISECOND, ISO_MICROSECOND, ISO_NANOSECOND);\n}\nfunction IsTemporalYearMonth(item) {\n    return HasSlot(item, YEAR_MONTH_BRAND);\n}\nfunction IsTemporalMonthDay(item) {\n    return HasSlot(item, MONTH_DAY_BRAND);\n}\nfunction IsTemporalZonedDateTime(item) {\n    return HasSlot(item, EPOCHNANOSECONDS, TIME_ZONE, CALENDAR);\n}\nfunction RejectObjectWithCalendarOrTimeZone(item) {\n    if (HasSlot(item, CALENDAR) || HasSlot(item, TIME_ZONE)) {\n        throw new TypeError('with() does not support a calendar or timeZone property');\n    }\n    if (item.calendar !== undefined) {\n        throw new TypeError('with() does not support a calendar property');\n    }\n    if (item.timeZone !== undefined) {\n        throw new TypeError('with() does not support a timeZone property');\n    }\n}\nfunction ParseTemporalTimeZone(stringIdent) {\n    let { ianaName, offset, z } = ParseTemporalTimeZoneString(stringIdent);\n    if (ianaName)\n        return ianaName;\n    if (z)\n        return 'UTC';\n    return offset; // if !ianaName && !z then offset must be present\n}\nfunction FormatCalendarAnnotation(id, showCalendar) {\n    if (showCalendar === 'never')\n        return '';\n    if (showCalendar === 'auto' && id === 'iso8601')\n        return '';\n    return `[u-ca=${id}]`;\n}\nfunction ParseISODateTime(isoString) {\n    // ZDT is the superset of fields for every other Temporal type\n    const match = zoneddatetime.exec(isoString);\n    if (!match)\n        throw new RangeError(`invalid ISO 8601 string: ${isoString}`);\n    let yearString = match[1];\n    if (yearString[0] === '\\u2212')\n        yearString = `-${yearString.slice(1)}`;\n    if (yearString === '-000000')\n        throw new RangeError(`invalid ISO 8601 string: ${isoString}`);\n    const year = ToInteger(yearString);\n    const month = ToInteger(match[2] || match[4]);\n    const day = ToInteger(match[3] || match[5]);\n    const hour = ToInteger(match[6]);\n    const hasTime = match[6] !== undefined;\n    const minute = ToInteger(match[7] || match[10]);\n    let second = ToInteger(match[8] || match[11]);\n    if (second === 60)\n        second = 59;\n    const fraction = (match[9] || match[12]) + '000000000';\n    const millisecond = ToInteger(fraction.slice(0, 3));\n    const microsecond = ToInteger(fraction.slice(3, 6));\n    const nanosecond = ToInteger(fraction.slice(6, 9));\n    let offset;\n    let z = false;\n    if (match[13]) {\n        offset = undefined;\n        z = true;\n    }\n    else if (match[14] && match[15]) {\n        const offsetSign = match[14] === '-' || match[14] === '\\u2212' ? '-' : '+';\n        const offsetHours = match[15] || '00';\n        const offsetMinutes = match[16] || '00';\n        const offsetSeconds = match[17] || '00';\n        let offsetFraction = match[18] || '0';\n        offset = `${offsetSign}${offsetHours}:${offsetMinutes}`;\n        if (+offsetFraction) {\n            while (offsetFraction.endsWith('0'))\n                offsetFraction = offsetFraction.slice(0, -1);\n            offset += `:${offsetSeconds}.${offsetFraction}`;\n        }\n        else if (+offsetSeconds) {\n            offset += `:${offsetSeconds}`;\n        }\n        if (offset === '-00:00')\n            offset = '+00:00';\n    }\n    let ianaName = match[19];\n    if (ianaName) {\n        try {\n            // Canonicalize name if it is an IANA link name or is capitalized wrong\n            ianaName = GetCanonicalTimeZoneIdentifier(ianaName).toString();\n        }\n        catch {\n            // Not an IANA name, may be a custom ID, pass through unchanged\n        }\n    }\n    const calendar = match[20];\n    return {\n        year,\n        month,\n        day,\n        hasTime,\n        hour,\n        minute,\n        second,\n        millisecond,\n        microsecond,\n        nanosecond,\n        ianaName,\n        offset,\n        z,\n        calendar\n    };\n}\nfunction ParseTemporalInstantString(isoString) {\n    const result = ParseISODateTime(isoString);\n    if (!result.z && !result.offset)\n        throw new RangeError('Temporal.Instant requires a time zone offset');\n    return result;\n}\nfunction ParseTemporalZonedDateTimeString(isoString) {\n    const result = ParseISODateTime(isoString);\n    if (!result.ianaName)\n        throw new RangeError('Temporal.ZonedDateTime requires a time zone ID in brackets');\n    return result;\n}\nfunction ParseTemporalDateTimeString(isoString) {\n    return ParseISODateTime(isoString);\n}\nfunction ParseTemporalDateString(isoString) {\n    return ParseISODateTime(isoString);\n}\nfunction ParseTemporalTimeString(isoString) {\n    const match = time.exec(isoString);\n    let hour, minute, second, millisecond, microsecond, nanosecond, calendar;\n    if (match) {\n        hour = ToInteger(match[1]);\n        minute = ToInteger(match[2] || match[5]);\n        second = ToInteger(match[3] || match[6]);\n        if (second === 60)\n            second = 59;\n        const fraction = (match[4] || match[7]) + '000000000';\n        millisecond = ToInteger(fraction.slice(0, 3));\n        microsecond = ToInteger(fraction.slice(3, 6));\n        nanosecond = ToInteger(fraction.slice(6, 9));\n        calendar = match[15];\n    }\n    else {\n        let z, hasTime;\n        ({ hasTime, hour, minute, second, millisecond, microsecond, nanosecond, calendar, z } =\n            ParseISODateTime(isoString));\n        if (!hasTime)\n            throw new RangeError(`time is missing in string: ${isoString}`);\n        if (z)\n            throw new RangeError('Z designator not supported for PlainTime');\n    }\n    // if it's a date-time string, OK\n    if (/[tT ][0-9][0-9]/.test(isoString)) {\n        return { hour, minute, second, millisecond, microsecond, nanosecond, calendar };\n    }\n    // slow but non-grammar-dependent way to ensure that time-only strings that\n    // are also valid PlainMonthDay and PlainYearMonth throw. corresponds to\n    // assertion in spec text\n    try {\n        const { month, day } = ParseTemporalMonthDayString(isoString);\n        RejectISODate(1972, month, day);\n    }\n    catch {\n        try {\n            const { year, month } = ParseTemporalYearMonthString(isoString);\n            RejectISODate(year, month, 1);\n        }\n        catch {\n            return { hour, minute, second, millisecond, microsecond, nanosecond, calendar };\n        }\n    }\n    throw new RangeError(`invalid ISO 8601 time-only string ${isoString}; may need a T prefix`);\n}\nfunction ParseTemporalYearMonthString(isoString) {\n    const match = yearmonth.exec(isoString);\n    let year, month, calendar, referenceISODay;\n    if (match) {\n        let yearString = match[1];\n        if (yearString[0] === '\\u2212')\n            yearString = `-${yearString.slice(1)}`;\n        if (yearString === '-000000')\n            throw new RangeError(`invalid ISO 8601 string: ${isoString}`);\n        year = ToInteger(yearString);\n        month = ToInteger(match[2]);\n        calendar = match[3];\n    }\n    else {\n        let z;\n        ({ year, month, calendar, day: referenceISODay, z } = ParseISODateTime(isoString));\n        if (z)\n            throw new RangeError('Z designator not supported for PlainYearMonth');\n    }\n    return { year, month, calendar, referenceISODay };\n}\nfunction ParseTemporalMonthDayString(isoString) {\n    const match = monthday.exec(isoString);\n    let month, day, calendar, referenceISOYear;\n    if (match) {\n        month = ToInteger(match[1]);\n        day = ToInteger(match[2]);\n    }\n    else {\n        let z;\n        ({ month, day, calendar, year: referenceISOYear, z } = ParseISODateTime(isoString));\n        if (z)\n            throw new RangeError('Z designator not supported for PlainMonthDay');\n    }\n    return { month, day, calendar, referenceISOYear };\n}\nfunction ParseTemporalTimeZoneString(stringIdent) {\n    try {\n        let canonicalIdent = GetCanonicalTimeZoneIdentifier(stringIdent);\n        if (canonicalIdent) {\n            canonicalIdent = canonicalIdent.toString();\n            if (TestTimeZoneOffsetString(canonicalIdent))\n                return { offset: canonicalIdent };\n            return { ianaName: canonicalIdent };\n        }\n    }\n    catch {\n        // fall through\n    }\n    try {\n        // Try parsing ISO string instead\n        const result = ParseISODateTime(stringIdent);\n        if (result.z || result.offset || result.ianaName) {\n            return result;\n        }\n    }\n    catch {\n        // fall through\n    }\n    throw new RangeError(`Invalid time zone: ${stringIdent}`);\n}\nfunction ParseTemporalDurationString(isoString) {\n    const match = duration.exec(isoString);\n    if (!match)\n        throw new RangeError(`invalid duration: ${isoString}`);\n    if (match.slice(2).every((element) => element === undefined)) {\n        throw new RangeError(`invalid duration: ${isoString}`);\n    }\n    const sign = match[1] === '-' || match[1] === '\\u2212' ? -1 : 1;\n    const years = ToInteger(match[2]) * sign;\n    const months = ToInteger(match[3]) * sign;\n    const weeks = ToInteger(match[4]) * sign;\n    const days = ToInteger(match[5]) * sign;\n    const hours = ToInteger(match[6]) * sign;\n    let fHours = match[7];\n    let minutes = ToInteger(match[8]) * sign;\n    let fMinutes = match[9];\n    let seconds = ToInteger(match[10]) * sign;\n    const fSeconds = match[11] + '000000000';\n    let milliseconds = ToInteger(fSeconds.slice(0, 3)) * sign;\n    let microseconds = ToInteger(fSeconds.slice(3, 6)) * sign;\n    let nanoseconds = ToInteger(fSeconds.slice(6, 9)) * sign;\n    fHours = fHours ? (sign * ToInteger(fHours)) / 10 ** fHours.length : 0;\n    fMinutes = fMinutes ? (sign * ToInteger(fMinutes)) / 10 ** fMinutes.length : 0;\n    ({ minutes, seconds, milliseconds, microseconds, nanoseconds } = DurationHandleFractions(fHours, minutes, fMinutes, seconds, milliseconds, microseconds, nanoseconds));\n    return { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds };\n}\nfunction ParseTemporalInstant(isoString) {\n    const { year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, offset, z } = ParseTemporalInstantString(isoString);\n    const epochNs = GetEpochFromISOParts(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond);\n    if (epochNs === null)\n        throw new RangeError('DateTime outside of supported range');\n    const offsetNs = z ? 0 : ParseTimeZoneOffsetString(offset);\n    return jsbi__WEBPACK_IMPORTED_MODULE_0__.subtract(epochNs, jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(offsetNs));\n}\nfunction RegulateISODate(yearParam, monthParam, dayParam, overflow) {\n    let year = yearParam;\n    let month = monthParam;\n    let day = dayParam;\n    switch (overflow) {\n        case 'reject':\n            RejectISODate(year, month, day);\n            break;\n        case 'constrain':\n            ({ year, month, day } = ConstrainISODate(year, month, day));\n            break;\n    }\n    return { year, month, day };\n}\nfunction RegulateTime(hourParam, minuteParam, secondParam, millisecondParam, microsecondParam, nanosecondParam, overflow) {\n    let hour = hourParam;\n    let minute = minuteParam;\n    let second = secondParam;\n    let millisecond = millisecondParam;\n    let microsecond = microsecondParam;\n    let nanosecond = nanosecondParam;\n    switch (overflow) {\n        case 'reject':\n            RejectTime(hour, minute, second, millisecond, microsecond, nanosecond);\n            break;\n        case 'constrain':\n            ({ hour, minute, second, millisecond, microsecond, nanosecond } = ConstrainTime(hour, minute, second, millisecond, microsecond, nanosecond));\n            break;\n    }\n    return { hour, minute, second, millisecond, microsecond, nanosecond };\n}\nfunction RegulateISOYearMonth(yearParam, monthParam, overflow) {\n    let year = yearParam;\n    let month = monthParam;\n    const referenceISODay = 1;\n    switch (overflow) {\n        case 'reject':\n            RejectISODate(year, month, referenceISODay);\n            break;\n        case 'constrain':\n            ({ year, month } = ConstrainISODate(year, month));\n            break;\n    }\n    return { year, month };\n}\nfunction DurationHandleFractions(fHoursParam, minutesParam, fMinutesParam, secondsParam, millisecondsParam, microsecondsParam, nanosecondsParam) {\n    let fHours = fHoursParam;\n    let minutes = minutesParam;\n    let fMinutes = fMinutesParam;\n    let seconds = secondsParam;\n    let milliseconds = millisecondsParam;\n    let microseconds = microsecondsParam;\n    let nanoseconds = nanosecondsParam;\n    if (fHours !== 0) {\n        [minutes, fMinutes, seconds, milliseconds, microseconds, nanoseconds].forEach((val) => {\n            if (val !== 0)\n                throw new RangeError('only the smallest unit can be fractional');\n        });\n        const mins = fHours * 60;\n        minutes = MathTrunc(mins);\n        fMinutes = mins % 1;\n    }\n    if (fMinutes !== 0) {\n        [seconds, milliseconds, microseconds, nanoseconds].forEach((val) => {\n            if (val !== 0)\n                throw new RangeError('only the smallest unit can be fractional');\n        });\n        const secs = fMinutes * 60;\n        seconds = MathTrunc(secs);\n        const fSeconds = secs % 1;\n        if (fSeconds !== 0) {\n            const mils = fSeconds * 1000;\n            milliseconds = MathTrunc(mils);\n            const fMilliseconds = mils % 1;\n            if (fMilliseconds !== 0) {\n                const mics = fMilliseconds * 1000;\n                microseconds = MathTrunc(mics);\n                const fMicroseconds = mics % 1;\n                if (fMicroseconds !== 0) {\n                    const nans = fMicroseconds * 1000;\n                    nanoseconds = MathTrunc(nans);\n                }\n            }\n        }\n    }\n    return { minutes, seconds, milliseconds, microseconds, nanoseconds };\n}\nfunction ToTemporalDurationRecord(item) {\n    if (IsTemporalDuration(item)) {\n        return {\n            years: GetSlot(item, YEARS),\n            months: GetSlot(item, MONTHS),\n            weeks: GetSlot(item, WEEKS),\n            days: GetSlot(item, DAYS),\n            hours: GetSlot(item, HOURS),\n            minutes: GetSlot(item, MINUTES),\n            seconds: GetSlot(item, SECONDS),\n            milliseconds: GetSlot(item, MILLISECONDS),\n            microseconds: GetSlot(item, MICROSECONDS),\n            nanoseconds: GetSlot(item, NANOSECONDS)\n        };\n    }\n    const props = ToPartialRecord(item, [\n        'days',\n        'hours',\n        'microseconds',\n        'milliseconds',\n        'minutes',\n        'months',\n        'nanoseconds',\n        'seconds',\n        'weeks',\n        'years'\n    ]);\n    if (!props)\n        throw new TypeError('invalid duration-like');\n    const { years = 0, months = 0, weeks = 0, days = 0, hours = 0, minutes = 0, seconds = 0, milliseconds = 0, microseconds = 0, nanoseconds = 0 } = props;\n    return { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds };\n}\nfunction ToLimitedTemporalDuration(item, disallowedProperties = []) {\n    let record;\n    if (IsObject(item)) {\n        record = ToTemporalDurationRecord(item);\n    }\n    else {\n        const str = ToString(item);\n        record = ParseTemporalDurationString(str);\n    }\n    const { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = record;\n    RejectDuration(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n    for (const property of disallowedProperties) {\n        if (record[property] !== 0) {\n            throw new RangeError(`Duration field ${property} not supported by Temporal.Instant. Try Temporal.ZonedDateTime instead.`);\n        }\n    }\n    return record;\n}\nfunction ToTemporalOverflow(options) {\n    return GetOption(options, 'overflow', ['constrain', 'reject'], 'constrain');\n}\nfunction ToTemporalDisambiguation(options) {\n    return GetOption(options, 'disambiguation', ['compatible', 'earlier', 'later', 'reject'], 'compatible');\n}\nfunction ToTemporalRoundingMode(options, fallback) {\n    return GetOption(options, 'roundingMode', ['ceil', 'floor', 'trunc', 'halfExpand'], fallback);\n}\nfunction NegateTemporalRoundingMode(roundingMode) {\n    switch (roundingMode) {\n        case 'ceil':\n            return 'floor';\n        case 'floor':\n            return 'ceil';\n        default:\n            return roundingMode;\n    }\n}\nfunction ToTemporalOffset(options, fallback) {\n    return GetOption(options, 'offset', ['prefer', 'use', 'ignore', 'reject'], fallback);\n}\nfunction ToShowCalendarOption(options) {\n    return GetOption(options, 'calendarName', ['auto', 'always', 'never'], 'auto');\n}\nfunction ToShowTimeZoneNameOption(options) {\n    return GetOption(options, 'timeZoneName', ['auto', 'never'], 'auto');\n}\nfunction ToShowOffsetOption(options) {\n    return GetOption(options, 'offset', ['auto', 'never'], 'auto');\n}\nfunction ToTemporalRoundingIncrement(options, dividend, inclusive) {\n    let maximum = Infinity;\n    if (dividend !== undefined)\n        maximum = dividend;\n    if (!inclusive && dividend !== undefined)\n        maximum = dividend > 1 ? dividend - 1 : 1;\n    const increment = GetNumberOption(options, 'roundingIncrement', 1, maximum, 1);\n    if (dividend !== undefined && dividend % increment !== 0) {\n        throw new RangeError(`Rounding increment must divide evenly into ${dividend}`);\n    }\n    return increment;\n}\nfunction ToTemporalDateTimeRoundingIncrement(options, smallestUnit) {\n    const maximumIncrements = {\n        year: undefined,\n        month: undefined,\n        week: undefined,\n        day: undefined,\n        hour: 24,\n        minute: 60,\n        second: 60,\n        millisecond: 1000,\n        microsecond: 1000,\n        nanosecond: 1000\n    };\n    return ToTemporalRoundingIncrement(options, maximumIncrements[smallestUnit], false);\n}\nfunction ToSecondsStringPrecision(options) {\n    const smallestUnit = ToSmallestTemporalUnit(options, undefined, ['year', 'month', 'week', 'day', 'hour']);\n    switch (smallestUnit) {\n        case 'minute':\n            return { precision: 'minute', unit: 'minute', increment: 1 };\n        case 'second':\n            return { precision: 0, unit: 'second', increment: 1 };\n        case 'millisecond':\n            return { precision: 3, unit: 'millisecond', increment: 1 };\n        case 'microsecond':\n            return { precision: 6, unit: 'microsecond', increment: 1 };\n        case 'nanosecond':\n            return { precision: 9, unit: 'nanosecond', increment: 1 };\n    }\n    let digits = options.fractionalSecondDigits;\n    if (digits === undefined)\n        digits = 'auto';\n    if (typeof digits !== 'number') {\n        const stringDigits = ToString(digits);\n        if (stringDigits === 'auto')\n            return { precision: 'auto', unit: 'nanosecond', increment: 1 };\n        throw new RangeError(`fractionalSecondDigits must be 'auto' or 0 through 9, not ${stringDigits}`);\n    }\n    if (NumberIsNaN(digits) || digits < 0 || digits > 9) {\n        throw new RangeError(`fractionalSecondDigits must be 'auto' or 0 through 9, not ${digits}`);\n    }\n    const precision = MathFloor(digits);\n    switch (precision) {\n        case 0:\n            return { precision, unit: 'second', increment: 1 };\n        case 1:\n        case 2:\n        case 3:\n            return { precision, unit: 'millisecond', increment: 10 ** (3 - precision) };\n        case 4:\n        case 5:\n        case 6:\n            return { precision, unit: 'microsecond', increment: 10 ** (6 - precision) };\n        case 7:\n        case 8:\n        case 9:\n            return { precision, unit: 'nanosecond', increment: 10 ** (9 - precision) };\n        default:\n            throw new RangeError(`fractionalSecondDigits must be 'auto' or 0 through 9, not ${digits}`);\n    }\n}\nfunction ToLargestTemporalUnit(options, fallback, disallowedStrings = [], autoValue) {\n    const singular = new Map(SINGULAR_PLURAL_UNITS.filter(([, sing]) => !disallowedStrings.includes(sing)));\n    const allowed = new Set(ALLOWED_UNITS);\n    for (const s of disallowedStrings) {\n        allowed.delete(s);\n    }\n    const retval = GetOption(options, 'largestUnit', ['auto', ...allowed, ...singular.keys()], fallback);\n    if (retval === 'auto' && autoValue !== undefined)\n        return autoValue;\n    if (singular.has(retval)) {\n        return singular.get(retval);\n    }\n    return retval;\n}\nfunction ToSmallestTemporalUnit(options, fallback, disallowedStrings = []) {\n    const singular = new Map(SINGULAR_PLURAL_UNITS.filter(([, sing]) => !disallowedStrings.includes(sing)));\n    const allowed = new Set(ALLOWED_UNITS);\n    for (const s of disallowedStrings) {\n        allowed.delete(s);\n    }\n    const value = GetOption(options, 'smallestUnit', [...allowed, ...singular.keys()], fallback);\n    if (singular.has(value)) {\n        return singular.get(value);\n    }\n    return value;\n}\nfunction ToTemporalDurationTotalUnit(options) {\n    // This AO is identical to ToSmallestTemporalUnit, except:\n    // - default is always `undefined` (caller will throw if omitted)\n    // - option is named `unit` (not `smallestUnit`)\n    // - all units are valid (no `disallowedStrings`)\n    const singular = new Map(SINGULAR_PLURAL_UNITS);\n    const value = GetOption(options, 'unit', [...singular.values(), ...singular.keys()], undefined);\n    if (singular.has(value)) {\n        return singular.get(value);\n    }\n    return value;\n}\nfunction ToRelativeTemporalObject(options) {\n    const relativeTo = options.relativeTo;\n    if (relativeTo === undefined)\n        return relativeTo;\n    let offsetBehaviour = 'option';\n    let matchMinutes = false;\n    let year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar, timeZone, offset;\n    if (IsObject(relativeTo)) {\n        if (IsTemporalZonedDateTime(relativeTo) || IsTemporalDate(relativeTo))\n            return relativeTo;\n        if (IsTemporalDateTime(relativeTo))\n            return TemporalDateTimeToDate(relativeTo);\n        calendar = GetTemporalCalendarWithISODefault(relativeTo);\n        const fieldNames = CalendarFields(calendar, [\n            'day',\n            'hour',\n            'microsecond',\n            'millisecond',\n            'minute',\n            'month',\n            'monthCode',\n            'nanosecond',\n            'second',\n            'year'\n        ]);\n        const fields = ToTemporalDateTimeFields(relativeTo, fieldNames);\n        const dateOptions = ObjectCreate$2(null);\n        dateOptions.overflow = 'constrain';\n        ({ year, month, day, hour, minute, second, millisecond, microsecond, nanosecond } = InterpretTemporalDateTimeFields(calendar, fields, dateOptions));\n        // The `offset` and `timeZone` properties only exist on ZonedDateTime (or\n        // ZonedDateTimeLike-property bags). The assertions below are used to avoid\n        // TS errors while not diverging runtime code from proposal-temporal.\n        offset = relativeTo.offset;\n        if (offset === undefined)\n            offsetBehaviour = 'wall';\n        timeZone = relativeTo.timeZone;\n    }\n    else {\n        let ianaName, z;\n        ({ year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar, ianaName, offset, z } =\n            ParseISODateTime(ToString(relativeTo)));\n        if (ianaName)\n            timeZone = ianaName;\n        if (z) {\n            offsetBehaviour = 'exact';\n        }\n        else if (!offset) {\n            offsetBehaviour = 'wall';\n        }\n        if (!calendar)\n            calendar = GetISO8601Calendar();\n        calendar = ToTemporalCalendar(calendar);\n        matchMinutes = true;\n    }\n    if (timeZone) {\n        timeZone = ToTemporalTimeZone(timeZone);\n        let offsetNs = 0;\n        if (offsetBehaviour === 'option')\n            offsetNs = ParseTimeZoneOffsetString(ToString(offset));\n        const epochNanoseconds = InterpretISODateTimeOffset(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, offsetBehaviour, offsetNs, timeZone, 'compatible', 'reject', matchMinutes);\n        return CreateTemporalZonedDateTime(epochNanoseconds, timeZone, calendar);\n    }\n    return CreateTemporalDate(year, month, day, calendar);\n}\nfunction ValidateTemporalUnitRange(largestUnit, smallestUnit) {\n    if (ALLOWED_UNITS.indexOf(largestUnit) > ALLOWED_UNITS.indexOf(smallestUnit)) {\n        throw new RangeError(`largestUnit ${largestUnit} cannot be smaller than smallestUnit ${smallestUnit}`);\n    }\n}\nfunction DefaultTemporalLargestUnit(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds) {\n    const singular = new Map(SINGULAR_PLURAL_UNITS);\n    for (const [prop, v] of [\n        ['years', years],\n        ['months', months],\n        ['weeks', weeks],\n        ['days', days],\n        ['hours', hours],\n        ['minutes', minutes],\n        ['seconds', seconds],\n        ['milliseconds', milliseconds],\n        ['microseconds', microseconds],\n        ['nanoseconds', nanoseconds]\n    ]) {\n        if (v !== 0)\n            return singular.get(prop);\n    }\n    return 'nanosecond';\n}\nfunction LargerOfTwoTemporalUnits(unit1, unit2) {\n    if (ALLOWED_UNITS.indexOf(unit1) > ALLOWED_UNITS.indexOf(unit2))\n        return unit2;\n    return unit1;\n}\nfunction ToPartialRecord(bagParam, fieldsParam) {\n    // External callers are limited to specific types, but this function's\n    // implementation uses generic property types. The casts below (and at the\n    // end) convert to/from generic records.\n    const bag = bagParam;\n    const fields = fieldsParam;\n    let any = false;\n    let result = {};\n    for (const property of fields) {\n        const value = bag[property];\n        if (value !== undefined) {\n            any = true;\n            if (BUILTIN_CASTS.has(property)) {\n                result[property] = BUILTIN_CASTS.get(property)(value);\n            }\n            else {\n                result[property] = value;\n            }\n        }\n    }\n    return any ? result : false;\n}\nfunction PrepareTemporalFields(bagParam, fieldsParam) {\n    // External callers are limited to specific types, but this function's\n    // implementation uses generic property types. The casts below (and at the\n    // end) convert to/from generic records.\n    const bag = bagParam;\n    const fields = fieldsParam;\n    const result = {};\n    let any = false;\n    for (const fieldRecord of fields) {\n        const [property, defaultValue] = fieldRecord;\n        let value = bag[property];\n        if (value === undefined) {\n            if (fieldRecord.length === 1) {\n                throw new TypeError(`required property '${property}' missing or undefined`);\n            }\n            value = defaultValue;\n        }\n        else {\n            any = true;\n            if (BUILTIN_CASTS.has(property)) {\n                value = BUILTIN_CASTS.get(property)(value);\n            }\n        }\n        result[property] = value;\n    }\n    if (!any) {\n        throw new TypeError('no supported properties found');\n    }\n    if ((result['era'] === undefined) !==\n        (result['eraYear'] === undefined)) {\n        throw new RangeError(\"properties 'era' and 'eraYear' must be provided together\");\n    }\n    return result;\n}\n// field access in the following operations is intentionally alphabetical\nfunction ToTemporalDateFields(bag, fieldNames) {\n    const entries = [\n        ['day', undefined],\n        ['month', undefined],\n        ['monthCode', undefined],\n        ['year', undefined]\n    ];\n    // Add extra fields from the calendar at the end\n    fieldNames.forEach((fieldName) => {\n        if (!entries.some(([name]) => name === fieldName)) {\n            entries.push([fieldName, undefined]);\n        }\n    });\n    return PrepareTemporalFields(bag, entries);\n}\nfunction ToTemporalDateTimeFields(bag, fieldNames) {\n    const entries = [\n        ['day', undefined],\n        ['hour', 0],\n        ['microsecond', 0],\n        ['millisecond', 0],\n        ['minute', 0],\n        ['month', undefined],\n        ['monthCode', undefined],\n        ['nanosecond', 0],\n        ['second', 0],\n        ['year', undefined]\n    ];\n    // Add extra fields from the calendar at the end\n    fieldNames.forEach((fieldName) => {\n        if (!entries.some(([name]) => name === fieldName)) {\n            entries.push([fieldName, undefined]);\n        }\n    });\n    return PrepareTemporalFields(bag, entries);\n}\nfunction ToTemporalMonthDayFields(bag, fieldNames) {\n    const entries = [\n        ['day', undefined],\n        ['month', undefined],\n        ['monthCode', undefined],\n        ['year', undefined]\n    ];\n    // Add extra fields from the calendar at the end\n    fieldNames.forEach((fieldName) => {\n        if (!entries.some(([name]) => name === fieldName)) {\n            entries.push([fieldName, undefined]);\n        }\n    });\n    return PrepareTemporalFields(bag, entries);\n}\nfunction ToTemporalTimeRecord(bag) {\n    return PrepareTemporalFields(bag, [\n        ['hour', 0],\n        ['microsecond', 0],\n        ['millisecond', 0],\n        ['minute', 0],\n        ['nanosecond', 0],\n        ['second', 0]\n    ]);\n}\nfunction ToTemporalYearMonthFields(bag, fieldNames) {\n    const entries = [\n        ['month', undefined],\n        ['monthCode', undefined],\n        ['year', undefined]\n    ];\n    // Add extra fields from the calendar at the end\n    fieldNames.forEach((fieldName) => {\n        if (!entries.some(([name]) => name === fieldName)) {\n            entries.push([fieldName, undefined]);\n        }\n    });\n    return PrepareTemporalFields(bag, entries);\n}\nfunction ToTemporalZonedDateTimeFields(bag, fieldNames) {\n    const entries = [\n        ['day', undefined],\n        ['hour', 0],\n        ['microsecond', 0],\n        ['millisecond', 0],\n        ['minute', 0],\n        ['month', undefined],\n        ['monthCode', undefined],\n        ['nanosecond', 0],\n        ['second', 0],\n        ['year', undefined],\n        ['offset', undefined],\n        ['timeZone']\n    ];\n    // Add extra fields from the calendar at the end\n    fieldNames.forEach((fieldName) => {\n        if (!entries.some(([name]) => name === fieldName)) {\n            entries.push([fieldName, undefined]);\n        }\n    });\n    return PrepareTemporalFields(bag, entries);\n}\nfunction ToTemporalDate(itemParam, options = ObjectCreate$2(null)) {\n    let item = itemParam;\n    if (IsObject(item)) {\n        if (IsTemporalDate(item))\n            return item;\n        if (IsTemporalZonedDateTime(item)) {\n            item = BuiltinTimeZoneGetPlainDateTimeFor(GetSlot(item, TIME_ZONE), GetSlot(item, INSTANT), GetSlot(item, CALENDAR));\n        }\n        if (IsTemporalDateTime(item)) {\n            return CreateTemporalDate(GetSlot(item, ISO_YEAR), GetSlot(item, ISO_MONTH), GetSlot(item, ISO_DAY), GetSlot(item, CALENDAR));\n        }\n        const calendar = GetTemporalCalendarWithISODefault(item);\n        const fieldNames = CalendarFields(calendar, ['day', 'month', 'monthCode', 'year']);\n        const fields = ToTemporalDateFields(item, fieldNames);\n        return DateFromFields(calendar, fields, options);\n    }\n    ToTemporalOverflow(options); // validate and ignore\n    const { year, month, day, calendar, z } = ParseTemporalDateString(ToString(item));\n    if (z)\n        throw new RangeError('Z designator not supported for PlainDate');\n    const TemporalPlainDate = GetIntrinsic('%Temporal.PlainDate%');\n    return new TemporalPlainDate(year, month, day, calendar); // include validation\n}\nfunction InterpretTemporalDateTimeFields(calendar, fields, options) {\n    let { hour, minute, second, millisecond, microsecond, nanosecond } = ToTemporalTimeRecord(fields);\n    const overflow = ToTemporalOverflow(options);\n    const date = DateFromFields(calendar, fields, options);\n    const year = GetSlot(date, ISO_YEAR);\n    const month = GetSlot(date, ISO_MONTH);\n    const day = GetSlot(date, ISO_DAY);\n    ({ hour, minute, second, millisecond, microsecond, nanosecond } = RegulateTime(hour, minute, second, millisecond, microsecond, nanosecond, overflow));\n    return { year, month, day, hour, minute, second, millisecond, microsecond, nanosecond };\n}\nfunction ToTemporalDateTime(item, options = ObjectCreate$2(null)) {\n    let year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar;\n    if (IsObject(item)) {\n        if (IsTemporalDateTime(item))\n            return item;\n        if (IsTemporalZonedDateTime(item)) {\n            return BuiltinTimeZoneGetPlainDateTimeFor(GetSlot(item, TIME_ZONE), GetSlot(item, INSTANT), GetSlot(item, CALENDAR));\n        }\n        if (IsTemporalDate(item)) {\n            return CreateTemporalDateTime(GetSlot(item, ISO_YEAR), GetSlot(item, ISO_MONTH), GetSlot(item, ISO_DAY), 0, 0, 0, 0, 0, 0, GetSlot(item, CALENDAR));\n        }\n        calendar = GetTemporalCalendarWithISODefault(item);\n        const fieldNames = CalendarFields(calendar, [\n            'day',\n            'hour',\n            'microsecond',\n            'millisecond',\n            'minute',\n            'month',\n            'monthCode',\n            'nanosecond',\n            'second',\n            'year'\n        ]);\n        const fields = ToTemporalDateTimeFields(item, fieldNames);\n        ({ year, month, day, hour, minute, second, millisecond, microsecond, nanosecond } = InterpretTemporalDateTimeFields(calendar, fields, options));\n    }\n    else {\n        ToTemporalOverflow(options); // validate and ignore\n        let z;\n        ({ year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar, z } =\n            ParseTemporalDateTimeString(ToString(item)));\n        if (z)\n            throw new RangeError('Z designator not supported for PlainDateTime');\n        RejectDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond);\n        if (calendar === undefined)\n            calendar = GetISO8601Calendar();\n        calendar = ToTemporalCalendar(calendar);\n    }\n    return CreateTemporalDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar);\n}\nfunction ToTemporalDuration(item) {\n    let years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds;\n    if (IsObject(item)) {\n        if (IsTemporalDuration(item))\n            return item;\n        ({ years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } =\n            ToTemporalDurationRecord(item));\n    }\n    else {\n        ({ years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } =\n            ParseTemporalDurationString(ToString(item)));\n    }\n    const TemporalDuration = GetIntrinsic('%Temporal.Duration%');\n    return new TemporalDuration(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n}\nfunction ToTemporalInstant(item) {\n    if (IsTemporalInstant(item))\n        return item;\n    if (IsTemporalZonedDateTime(item)) {\n        const TemporalInstant = GetIntrinsic('%Temporal.Instant%');\n        return new TemporalInstant(GetSlot(item, EPOCHNANOSECONDS));\n    }\n    const ns = ParseTemporalInstant(ToString(item));\n    const TemporalInstant = GetIntrinsic('%Temporal.Instant%');\n    return new TemporalInstant(ns);\n}\nfunction ToTemporalMonthDay(item, options = ObjectCreate$2(null)) {\n    if (IsObject(item)) {\n        if (IsTemporalMonthDay(item))\n            return item;\n        let calendar, calendarAbsent;\n        if (HasSlot(item, CALENDAR)) {\n            calendar = GetSlot(item, CALENDAR);\n            calendarAbsent = false;\n        }\n        else {\n            let maybeStringCalendar = item.calendar;\n            calendarAbsent = maybeStringCalendar === undefined;\n            if (maybeStringCalendar === undefined)\n                maybeStringCalendar = GetISO8601Calendar();\n            calendar = ToTemporalCalendar(maybeStringCalendar);\n        }\n        const fieldNames = CalendarFields(calendar, ['day', 'month', 'monthCode', 'year']);\n        const fields = ToTemporalMonthDayFields(item, fieldNames);\n        // Callers who omit the calendar are not writing calendar-independent\n        // code. In that case, `monthCode`/`year` can be omitted; `month` and\n        // `day` are sufficient. Add a `year` to satisfy calendar validation.\n        if (calendarAbsent && fields.month !== undefined && fields.monthCode === undefined && fields.year === undefined) {\n            fields.year = 1972;\n        }\n        return MonthDayFromFields(calendar, fields, options);\n    }\n    ToTemporalOverflow(options); // validate and ignore\n    let { month, day, referenceISOYear, calendar: maybeStringCalendar } = ParseTemporalMonthDayString(ToString(item));\n    let calendar = maybeStringCalendar;\n    if (calendar === undefined)\n        calendar = GetISO8601Calendar();\n    calendar = ToTemporalCalendar(calendar);\n    if (referenceISOYear === undefined) {\n        RejectISODate(1972, month, day);\n        return CreateTemporalMonthDay(month, day, calendar);\n    }\n    const result = CreateTemporalMonthDay(month, day, calendar, referenceISOYear);\n    const canonicalOptions = ObjectCreate$2(null);\n    return MonthDayFromFields(calendar, result, canonicalOptions);\n}\nfunction ToTemporalTime(itemParam, overflow = 'constrain') {\n    let item = itemParam;\n    let hour, minute, second, millisecond, microsecond, nanosecond, calendar;\n    if (IsObject(item)) {\n        if (IsTemporalTime(item))\n            return item;\n        if (IsTemporalZonedDateTime(item)) {\n            item = BuiltinTimeZoneGetPlainDateTimeFor(GetSlot(item, TIME_ZONE), GetSlot(item, INSTANT), GetSlot(item, CALENDAR));\n        }\n        if (IsTemporalDateTime(item)) {\n            const TemporalPlainTime = GetIntrinsic('%Temporal.PlainTime%');\n            return new TemporalPlainTime(GetSlot(item, ISO_HOUR), GetSlot(item, ISO_MINUTE), GetSlot(item, ISO_SECOND), GetSlot(item, ISO_MILLISECOND), GetSlot(item, ISO_MICROSECOND), GetSlot(item, ISO_NANOSECOND));\n        }\n        calendar = GetTemporalCalendarWithISODefault(item);\n        if (ToString(calendar) !== 'iso8601') {\n            throw new RangeError('PlainTime can only have iso8601 calendar');\n        }\n        ({ hour, minute, second, millisecond, microsecond, nanosecond } = ToTemporalTimeRecord(item));\n        ({ hour, minute, second, millisecond, microsecond, nanosecond } = RegulateTime(hour, minute, second, millisecond, microsecond, nanosecond, overflow));\n    }\n    else {\n        ({ hour, minute, second, millisecond, microsecond, nanosecond, calendar } = ParseTemporalTimeString(ToString(item)));\n        RejectTime(hour, minute, second, millisecond, microsecond, nanosecond);\n        if (calendar !== undefined && calendar !== 'iso8601') {\n            throw new RangeError('PlainTime can only have iso8601 calendar');\n        }\n    }\n    const TemporalPlainTime = GetIntrinsic('%Temporal.PlainTime%');\n    return new TemporalPlainTime(hour, minute, second, millisecond, microsecond, nanosecond);\n}\nfunction ToTemporalYearMonth(item, options = ObjectCreate$2(null)) {\n    if (IsObject(item)) {\n        if (IsTemporalYearMonth(item))\n            return item;\n        const calendar = GetTemporalCalendarWithISODefault(item);\n        const fieldNames = CalendarFields(calendar, ['month', 'monthCode', 'year']);\n        const fields = ToTemporalYearMonthFields(item, fieldNames);\n        return YearMonthFromFields(calendar, fields, options);\n    }\n    ToTemporalOverflow(options); // validate and ignore\n    let { year, month, referenceISODay, calendar: maybeStringCalendar } = ParseTemporalYearMonthString(ToString(item));\n    // TODO: replace with ternary?\n    let calendar = maybeStringCalendar;\n    if (calendar === undefined)\n        calendar = GetISO8601Calendar();\n    calendar = ToTemporalCalendar(calendar);\n    if (referenceISODay === undefined) {\n        RejectISODate(year, month, 1);\n        return CreateTemporalYearMonth(year, month, calendar);\n    }\n    const result = CreateTemporalYearMonth(year, month, calendar, referenceISODay);\n    const canonicalOptions = ObjectCreate$2(null);\n    return YearMonthFromFields(calendar, result, canonicalOptions);\n}\nfunction InterpretISODateTimeOffset(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, offsetBehaviour, offsetNs, timeZone, disambiguation, offsetOpt, matchMinute) {\n    const DateTime = GetIntrinsic('%Temporal.PlainDateTime%');\n    const dt = new DateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond);\n    if (offsetBehaviour === 'wall' || offsetOpt === 'ignore') {\n        // Simple case: ISO string without a TZ offset (or caller wants to ignore\n        // the offset), so just convert DateTime to Instant in the given time zone\n        const instant = BuiltinTimeZoneGetInstantFor(timeZone, dt, disambiguation);\n        return GetSlot(instant, EPOCHNANOSECONDS);\n    }\n    // The caller wants the offset to always win ('use') OR the caller is OK\n    // with the offset winning ('prefer' or 'reject') as long as it's valid\n    // for this timezone and date/time.\n    if (offsetBehaviour === 'exact' || offsetOpt === 'use') {\n        // Calculate the instant for the input's date/time and offset\n        const epochNs = GetEpochFromISOParts(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond);\n        if (epochNs === null)\n            throw new RangeError('ZonedDateTime outside of supported range');\n        return jsbi__WEBPACK_IMPORTED_MODULE_0__.subtract(epochNs, jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(offsetNs));\n    }\n    // \"prefer\" or \"reject\"\n    const possibleInstants = GetPossibleInstantsFor(timeZone, dt);\n    for (const candidate of possibleInstants) {\n        const candidateOffset = GetOffsetNanosecondsFor(timeZone, candidate);\n        const roundedCandidateOffset = jsbi__WEBPACK_IMPORTED_MODULE_0__.toNumber(RoundNumberToIncrement(jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(candidateOffset), 60e9, 'halfExpand'));\n        if (candidateOffset === offsetNs || (matchMinute && roundedCandidateOffset === offsetNs)) {\n            return GetSlot(candidate, EPOCHNANOSECONDS);\n        }\n    }\n    // the user-provided offset doesn't match any instants for this time\n    // zone and date/time.\n    if (offsetOpt === 'reject') {\n        const offsetStr = FormatTimeZoneOffsetString(offsetNs);\n        const timeZoneString = IsTemporalTimeZone(timeZone) ? GetSlot(timeZone, TIMEZONE_ID) : 'time zone';\n        // The tsc emit for this line rewrites to invoke the PlainDateTime's valueOf method, NOT\n        // toString (which is invoked by Node when using template literals directly).\n        // See https://github.com/microsoft/TypeScript/issues/39744 for the proposed fix in tsc emit\n        throw new RangeError(`Offset ${offsetStr} is invalid for ${dt.toString()} in ${timeZoneString}`);\n    }\n    // fall through: offsetOpt === 'prefer', but the offset doesn't match\n    // so fall back to use the time zone instead.\n    const instant = DisambiguatePossibleInstants(possibleInstants, timeZone, dt, disambiguation);\n    return GetSlot(instant, EPOCHNANOSECONDS);\n}\nfunction ToTemporalZonedDateTime(item, options = ObjectCreate$2(null)) {\n    let year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, timeZone, offset, calendar;\n    let matchMinute = false;\n    let offsetBehaviour = 'option';\n    if (IsObject(item)) {\n        if (IsTemporalZonedDateTime(item))\n            return item;\n        calendar = GetTemporalCalendarWithISODefault(item);\n        const fieldNames = CalendarFields(calendar, [\n            'day',\n            'hour',\n            'microsecond',\n            'millisecond',\n            'minute',\n            'month',\n            'monthCode',\n            'nanosecond',\n            'second',\n            'year'\n        ]);\n        const fields = ToTemporalZonedDateTimeFields(item, fieldNames);\n        ({ year, month, day, hour, minute, second, millisecond, microsecond, nanosecond } = InterpretTemporalDateTimeFields(calendar, fields, options));\n        timeZone = ToTemporalTimeZone(fields.timeZone);\n        offset = fields.offset;\n        if (offset === undefined) {\n            offsetBehaviour = 'wall';\n        }\n        else {\n            offset = ToString(offset);\n        }\n    }\n    else {\n        ToTemporalOverflow(options); // validate and ignore\n        let ianaName, z;\n        ({ year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, ianaName, offset, z, calendar } =\n            ParseTemporalZonedDateTimeString(ToString(item)));\n        if (!ianaName)\n            throw new RangeError('time zone ID required in brackets');\n        if (z) {\n            offsetBehaviour = 'exact';\n        }\n        else if (!offset) {\n            offsetBehaviour = 'wall';\n        }\n        const TemporalTimeZone = GetIntrinsic('%Temporal.TimeZone%');\n        timeZone = new TemporalTimeZone(ianaName);\n        if (!calendar)\n            calendar = GetISO8601Calendar();\n        calendar = ToTemporalCalendar(calendar);\n        matchMinute = true; // ISO strings may specify offset with less precision\n    }\n    let offsetNs = 0;\n    // The code above guarantees that if offsetBehaviour === 'option', then\n    // `offset` is not undefined.\n    if (offsetBehaviour === 'option')\n        offsetNs = ParseTimeZoneOffsetString(offset);\n    const disambiguation = ToTemporalDisambiguation(options);\n    const offsetOpt = ToTemporalOffset(options, 'reject');\n    const epochNanoseconds = InterpretISODateTimeOffset(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, offsetBehaviour, offsetNs, timeZone, disambiguation, offsetOpt, matchMinute);\n    return CreateTemporalZonedDateTime(epochNanoseconds, timeZone, calendar);\n}\nfunction CreateTemporalDateSlots(result, isoYear, isoMonth, isoDay, calendar) {\n    RejectISODate(isoYear, isoMonth, isoDay);\n    RejectDateRange(isoYear, isoMonth, isoDay);\n    CreateSlots(result);\n    SetSlot(result, ISO_YEAR, isoYear);\n    SetSlot(result, ISO_MONTH, isoMonth);\n    SetSlot(result, ISO_DAY, isoDay);\n    SetSlot(result, CALENDAR, calendar);\n    SetSlot(result, DATE_BRAND, true);\n    {\n        ObjectDefineProperty(result, '_repr_', {\n            value: `${result[Symbol.toStringTag]} <${TemporalDateToString(result)}>`,\n            writable: false,\n            enumerable: false,\n            configurable: false\n        });\n    }\n}\nfunction CreateTemporalDate(isoYear, isoMonth, isoDay, calendar = GetISO8601Calendar()) {\n    const TemporalPlainDate = GetIntrinsic('%Temporal.PlainDate%');\n    const result = ObjectCreate$2(TemporalPlainDate.prototype);\n    CreateTemporalDateSlots(result, isoYear, isoMonth, isoDay, calendar);\n    return result;\n}\nfunction CreateTemporalDateTimeSlots(result, isoYear, isoMonth, isoDay, h, min, s, ms, s, ns, calendar) {\n    RejectDateTime(isoYear, isoMonth, isoDay, h, min, s, ms, s, ns);\n    RejectDateTimeRange(isoYear, isoMonth, isoDay, h, min, s, ms, s, ns);\n    CreateSlots(result);\n    SetSlot(result, ISO_YEAR, isoYear);\n    SetSlot(result, ISO_MONTH, isoMonth);\n    SetSlot(result, ISO_DAY, isoDay);\n    SetSlot(result, ISO_HOUR, h);\n    SetSlot(result, ISO_MINUTE, min);\n    SetSlot(result, ISO_SECOND, s);\n    SetSlot(result, ISO_MILLISECOND, ms);\n    SetSlot(result, ISO_MICROSECOND, s);\n    SetSlot(result, ISO_NANOSECOND, ns);\n    SetSlot(result, CALENDAR, calendar);\n    {\n        Object.defineProperty(result, '_repr_', {\n            value: `${result[Symbol.toStringTag]} <${TemporalDateTimeToString(result, 'auto')}>`,\n            writable: false,\n            enumerable: false,\n            configurable: false\n        });\n    }\n}\nfunction CreateTemporalDateTime(isoYear, isoMonth, isoDay, h, min, s, ms, s, ns, calendar = GetISO8601Calendar()) {\n    const TemporalPlainDateTime = GetIntrinsic('%Temporal.PlainDateTime%');\n    const result = ObjectCreate$2(TemporalPlainDateTime.prototype);\n    CreateTemporalDateTimeSlots(result, isoYear, isoMonth, isoDay, h, min, s, ms, s, ns, calendar);\n    return result;\n}\nfunction CreateTemporalMonthDaySlots(result, isoMonth, isoDay, calendar, referenceISOYear) {\n    RejectISODate(referenceISOYear, isoMonth, isoDay);\n    RejectDateRange(referenceISOYear, isoMonth, isoDay);\n    CreateSlots(result);\n    SetSlot(result, ISO_MONTH, isoMonth);\n    SetSlot(result, ISO_DAY, isoDay);\n    SetSlot(result, ISO_YEAR, referenceISOYear);\n    SetSlot(result, CALENDAR, calendar);\n    SetSlot(result, MONTH_DAY_BRAND, true);\n    {\n        Object.defineProperty(result, '_repr_', {\n            value: `${result[Symbol.toStringTag]} <${TemporalMonthDayToString(result)}>`,\n            writable: false,\n            enumerable: false,\n            configurable: false\n        });\n    }\n}\nfunction CreateTemporalMonthDay(isoMonth, isoDay, calendar = GetISO8601Calendar(), referenceISOYear = 1972) {\n    const TemporalPlainMonthDay = GetIntrinsic('%Temporal.PlainMonthDay%');\n    const result = ObjectCreate$2(TemporalPlainMonthDay.prototype);\n    CreateTemporalMonthDaySlots(result, isoMonth, isoDay, calendar, referenceISOYear);\n    return result;\n}\nfunction CreateTemporalYearMonthSlots(result, isoYear, isoMonth, calendar, referenceISODay) {\n    RejectISODate(isoYear, isoMonth, referenceISODay);\n    RejectYearMonthRange(isoYear, isoMonth);\n    CreateSlots(result);\n    SetSlot(result, ISO_YEAR, isoYear);\n    SetSlot(result, ISO_MONTH, isoMonth);\n    SetSlot(result, ISO_DAY, referenceISODay);\n    SetSlot(result, CALENDAR, calendar);\n    SetSlot(result, YEAR_MONTH_BRAND, true);\n    {\n        Object.defineProperty(result, '_repr_', {\n            value: `${result[Symbol.toStringTag]} <${TemporalYearMonthToString(result)}>`,\n            writable: false,\n            enumerable: false,\n            configurable: false\n        });\n    }\n}\nfunction CreateTemporalYearMonth(isoYear, isoMonth, calendar = GetISO8601Calendar(), referenceISODay = 1) {\n    const TemporalPlainYearMonth = GetIntrinsic('%Temporal.PlainYearMonth%');\n    const result = ObjectCreate$2(TemporalPlainYearMonth.prototype);\n    CreateTemporalYearMonthSlots(result, isoYear, isoMonth, calendar, referenceISODay);\n    return result;\n}\nfunction CreateTemporalZonedDateTimeSlots(result, epochNanoseconds, timeZone, calendar) {\n    ValidateEpochNanoseconds(epochNanoseconds);\n    CreateSlots(result);\n    SetSlot(result, EPOCHNANOSECONDS, epochNanoseconds);\n    SetSlot(result, TIME_ZONE, timeZone);\n    SetSlot(result, CALENDAR, calendar);\n    const TemporalInstant = GetIntrinsic('%Temporal.Instant%');\n    const instant = new TemporalInstant(GetSlot(result, EPOCHNANOSECONDS));\n    SetSlot(result, INSTANT, instant);\n    {\n        Object.defineProperty(result, '_repr_', {\n            value: `${result[Symbol.toStringTag]} <${TemporalZonedDateTimeToString(result, 'auto')}>`,\n            writable: false,\n            enumerable: false,\n            configurable: false\n        });\n    }\n}\nfunction CreateTemporalZonedDateTime(epochNanoseconds, timeZone, calendar = GetISO8601Calendar()) {\n    const TemporalZonedDateTime = GetIntrinsic('%Temporal.ZonedDateTime%');\n    const result = ObjectCreate$2(TemporalZonedDateTime.prototype);\n    CreateTemporalZonedDateTimeSlots(result, epochNanoseconds, timeZone, calendar);\n    return result;\n}\nfunction GetISO8601Calendar() {\n    const TemporalCalendar = GetIntrinsic('%Temporal.Calendar%');\n    return new TemporalCalendar('iso8601');\n}\n// TODO: should (can?) we make this generic so the field names are checked\n// against the type that the calendar is a property of?\nfunction CalendarFields(calendar, fieldNamesParam) {\n    let fieldNames = fieldNamesParam;\n    if (calendar.fields) {\n        fieldNames = calendar.fields(fieldNames);\n    }\n    const result = [];\n    for (const name of fieldNames) {\n        if (typeof name !== 'string')\n            throw new TypeError('bad return from calendar.fields()');\n        ArrayPrototypePush$1.call(result, name);\n    }\n    return result;\n}\nfunction CalendarMergeFields(calendar, fields, additionalFields) {\n    const calMergeFields = calendar.mergeFields;\n    if (!calMergeFields) {\n        return { ...fields, ...additionalFields };\n    }\n    const result = Reflect.apply(calMergeFields, calendar, [fields, additionalFields]);\n    if (!IsObject(result))\n        throw new TypeError('bad return from calendar.mergeFields()');\n    return result;\n}\nfunction CalendarDateAdd(calendar, date, duration, options, dateAddParam) {\n    let dateAdd = dateAddParam;\n    if (dateAdd === undefined) {\n        dateAdd = calendar.dateAdd;\n    }\n    const result = ReflectApply$1(dateAdd, calendar, [date, duration, options]);\n    if (!IsTemporalDate(result))\n        throw new TypeError('invalid result');\n    return result;\n}\nfunction CalendarDateUntil(calendar, date, otherDate, options, dateUntilParam) {\n    let dateUntil = dateUntilParam;\n    if (dateUntil === undefined) {\n        dateUntil = calendar.dateUntil;\n    }\n    const result = ReflectApply$1(dateUntil, calendar, [date, otherDate, options]);\n    if (!IsTemporalDuration(result))\n        throw new TypeError('invalid result');\n    return result;\n}\nfunction CalendarYear(calendar, dateLike) {\n    const result = calendar.year(dateLike);\n    if (result === undefined) {\n        throw new RangeError('calendar year result must be an integer');\n    }\n    return ToIntegerThrowOnInfinity(result);\n}\nfunction CalendarMonth(calendar, dateLike) {\n    const result = calendar.month(dateLike);\n    if (result === undefined) {\n        throw new RangeError('calendar month result must be a positive integer');\n    }\n    return ToPositiveInteger(result);\n}\nfunction CalendarMonthCode(calendar, dateLike) {\n    const result = calendar.monthCode(dateLike);\n    if (result === undefined) {\n        throw new RangeError('calendar monthCode result must be a string');\n    }\n    return ToString(result);\n}\nfunction CalendarDay(calendar, dateLike) {\n    const result = calendar.day(dateLike);\n    if (result === undefined) {\n        throw new RangeError('calendar day result must be a positive integer');\n    }\n    return ToPositiveInteger(result);\n}\nfunction CalendarEra(calendar, dateLike) {\n    let result = calendar.era(dateLike);\n    if (result !== undefined) {\n        result = ToString(result);\n    }\n    return result;\n}\nfunction CalendarEraYear(calendar, dateLike) {\n    let result = calendar.eraYear(dateLike);\n    if (result !== undefined) {\n        result = ToIntegerThrowOnInfinity(result);\n    }\n    return result;\n}\nfunction CalendarDayOfWeek(calendar, dateLike) {\n    return calendar.dayOfWeek(dateLike);\n}\nfunction CalendarDayOfYear(calendar, dateLike) {\n    return calendar.dayOfYear(dateLike);\n}\nfunction CalendarWeekOfYear(calendar, dateLike) {\n    return calendar.weekOfYear(dateLike);\n}\nfunction CalendarDaysInWeek(calendar, dateLike) {\n    return calendar.daysInWeek(dateLike);\n}\nfunction CalendarDaysInMonth(calendar, dateLike) {\n    return calendar.daysInMonth(dateLike);\n}\nfunction CalendarDaysInYear(calendar, dateLike) {\n    return calendar.daysInYear(dateLike);\n}\nfunction CalendarMonthsInYear(calendar, dateLike) {\n    return calendar.monthsInYear(dateLike);\n}\nfunction CalendarInLeapYear(calendar, dateLike) {\n    return calendar.inLeapYear(dateLike);\n}\nfunction ToTemporalCalendar(calendarLikeParam) {\n    let calendarLike = calendarLikeParam;\n    if (IsObject(calendarLike)) {\n        if (HasSlot(calendarLike, CALENDAR))\n            return GetSlot(calendarLike, CALENDAR);\n        if (!('calendar' in calendarLike))\n            return calendarLike;\n        calendarLike = calendarLike.calendar;\n        if (IsObject(calendarLike) && !('calendar' in calendarLike))\n            return calendarLike;\n    }\n    const identifier = ToString(calendarLike);\n    const TemporalCalendar = GetIntrinsic('%Temporal.Calendar%');\n    if (IsBuiltinCalendar(identifier))\n        return new TemporalCalendar(identifier);\n    let calendar;\n    try {\n        ({ calendar } = ParseISODateTime(identifier));\n    }\n    catch {\n        throw new RangeError(`Invalid calendar: ${identifier}`);\n    }\n    if (!calendar)\n        calendar = 'iso8601';\n    return new TemporalCalendar(calendar);\n}\nfunction GetTemporalCalendarWithISODefault(item) {\n    if (HasSlot(item, CALENDAR))\n        return GetSlot(item, CALENDAR);\n    const { calendar } = item;\n    if (calendar === undefined)\n        return GetISO8601Calendar();\n    return ToTemporalCalendar(calendar);\n}\nfunction CalendarEquals(one, two) {\n    if (one === two)\n        return true;\n    const cal1 = ToString(one);\n    const cal2 = ToString(two);\n    return cal1 === cal2;\n}\nfunction ConsolidateCalendars(one, two) {\n    if (one === two)\n        return two;\n    const sOne = ToString(one);\n    const sTwo = ToString(two);\n    if (sOne === sTwo || sOne === 'iso8601') {\n        return two;\n    }\n    else if (sTwo === 'iso8601') {\n        return one;\n    }\n    else {\n        throw new RangeError('irreconcilable calendars');\n    }\n}\nfunction DateFromFields(calendar, fields, options) {\n    const result = calendar.dateFromFields(fields, options);\n    if (!IsTemporalDate(result))\n        throw new TypeError('invalid result');\n    return result;\n}\nfunction YearMonthFromFields(calendar, fields, options) {\n    const result = calendar.yearMonthFromFields(fields, options);\n    if (!IsTemporalYearMonth(result))\n        throw new TypeError('invalid result');\n    return result;\n}\nfunction MonthDayFromFields(calendar, fields, options) {\n    const result = calendar.monthDayFromFields(fields, options);\n    if (!IsTemporalMonthDay(result))\n        throw new TypeError('invalid result');\n    return result;\n}\nfunction ToTemporalTimeZone(temporalTimeZoneLikeParam) {\n    let temporalTimeZoneLike = temporalTimeZoneLikeParam;\n    if (IsObject(temporalTimeZoneLike)) {\n        if (IsTemporalZonedDateTime(temporalTimeZoneLike))\n            return GetSlot(temporalTimeZoneLike, TIME_ZONE);\n        if (!('timeZone' in temporalTimeZoneLike))\n            return temporalTimeZoneLike;\n        temporalTimeZoneLike = temporalTimeZoneLike.timeZone;\n        if (IsObject(temporalTimeZoneLike) && !('timeZone' in temporalTimeZoneLike)) {\n            return temporalTimeZoneLike;\n        }\n    }\n    const identifier = ToString(temporalTimeZoneLike);\n    const timeZone = ParseTemporalTimeZone(identifier);\n    const TemporalTimeZone = GetIntrinsic('%Temporal.TimeZone%');\n    return new TemporalTimeZone(timeZone);\n}\nfunction TimeZoneEquals(one, two) {\n    if (one === two)\n        return true;\n    const tz1 = ToString(one);\n    const tz2 = ToString(two);\n    return tz1 === tz2;\n}\nfunction TemporalDateTimeToDate(dateTime) {\n    return CreateTemporalDate(GetSlot(dateTime, ISO_YEAR), GetSlot(dateTime, ISO_MONTH), GetSlot(dateTime, ISO_DAY), GetSlot(dateTime, CALENDAR));\n}\nfunction TemporalDateTimeToTime(dateTime) {\n    const Time = GetIntrinsic('%Temporal.PlainTime%');\n    return new Time(GetSlot(dateTime, ISO_HOUR), GetSlot(dateTime, ISO_MINUTE), GetSlot(dateTime, ISO_SECOND), GetSlot(dateTime, ISO_MILLISECOND), GetSlot(dateTime, ISO_MICROSECOND), GetSlot(dateTime, ISO_NANOSECOND));\n}\nfunction GetOffsetNanosecondsFor(timeZone, instant) {\n    let getOffsetNanosecondsFor = timeZone.getOffsetNanosecondsFor;\n    if (typeof getOffsetNanosecondsFor !== 'function') {\n        throw new TypeError('getOffsetNanosecondsFor not callable');\n    }\n    const offsetNs = Reflect.apply(getOffsetNanosecondsFor, timeZone, [instant]);\n    if (typeof offsetNs !== 'number') {\n        throw new TypeError('bad return from getOffsetNanosecondsFor');\n    }\n    if (!IsInteger(offsetNs) || MathAbs(offsetNs) > 86400e9) {\n        throw new RangeError('out-of-range return from getOffsetNanosecondsFor');\n    }\n    return offsetNs;\n}\nfunction BuiltinTimeZoneGetOffsetStringFor(timeZone, instant) {\n    const offsetNs = GetOffsetNanosecondsFor(timeZone, instant);\n    return FormatTimeZoneOffsetString(offsetNs);\n}\nfunction BuiltinTimeZoneGetPlainDateTimeFor(timeZone, instant, calendar) {\n    const ns = GetSlot(instant, EPOCHNANOSECONDS);\n    const offsetNs = GetOffsetNanosecondsFor(timeZone, instant);\n    let { year, month, day, hour, minute, second, millisecond, microsecond, nanosecond } = GetISOPartsFromEpoch(ns);\n    ({ year, month, day, hour, minute, second, millisecond, microsecond, nanosecond } = BalanceISODateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond + offsetNs));\n    return CreateTemporalDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar);\n}\nfunction BuiltinTimeZoneGetInstantFor(timeZone, dateTime, disambiguation) {\n    const possibleInstants = GetPossibleInstantsFor(timeZone, dateTime);\n    return DisambiguatePossibleInstants(possibleInstants, timeZone, dateTime, disambiguation);\n}\nfunction DisambiguatePossibleInstants(possibleInstants, timeZone, dateTime, disambiguation) {\n    const Instant = GetIntrinsic('%Temporal.Instant%');\n    const numInstants = possibleInstants.length;\n    if (numInstants === 1)\n        return possibleInstants[0];\n    if (numInstants) {\n        switch (disambiguation) {\n            case 'compatible':\n            // fall through because 'compatible' means 'earlier' for \"fall back\" transitions\n            case 'earlier':\n                return possibleInstants[0];\n            case 'later':\n                return possibleInstants[numInstants - 1];\n            case 'reject': {\n                throw new RangeError('multiple instants found');\n            }\n        }\n    }\n    const year = GetSlot(dateTime, ISO_YEAR);\n    const month = GetSlot(dateTime, ISO_MONTH);\n    const day = GetSlot(dateTime, ISO_DAY);\n    const hour = GetSlot(dateTime, ISO_HOUR);\n    const minute = GetSlot(dateTime, ISO_MINUTE);\n    const second = GetSlot(dateTime, ISO_SECOND);\n    const millisecond = GetSlot(dateTime, ISO_MILLISECOND);\n    const microsecond = GetSlot(dateTime, ISO_MICROSECOND);\n    const nanosecond = GetSlot(dateTime, ISO_NANOSECOND);\n    const utcns = GetEpochFromISOParts(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond);\n    if (utcns === null)\n        throw new RangeError('DateTime outside of supported range');\n    const dayBefore = new Instant(jsbi__WEBPACK_IMPORTED_MODULE_0__.subtract(utcns, DAY_NANOS));\n    const dayAfter = new Instant(jsbi__WEBPACK_IMPORTED_MODULE_0__.add(utcns, DAY_NANOS));\n    const offsetBefore = GetOffsetNanosecondsFor(timeZone, dayBefore);\n    const offsetAfter = GetOffsetNanosecondsFor(timeZone, dayAfter);\n    const nanoseconds = offsetAfter - offsetBefore;\n    switch (disambiguation) {\n        case 'earlier': {\n            const calendar = GetSlot(dateTime, CALENDAR);\n            const PlainDateTime = GetIntrinsic('%Temporal.PlainDateTime%');\n            const earlier = AddDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar, 0, 0, 0, 0, 0, 0, 0, 0, 0, -nanoseconds, undefined);\n            const earlierPlainDateTime = new PlainDateTime(earlier.year, earlier.month, earlier.day, earlier.hour, earlier.minute, earlier.second, earlier.millisecond, earlier.microsecond, earlier.nanosecond, calendar);\n            return GetPossibleInstantsFor(timeZone, earlierPlainDateTime)[0];\n        }\n        case 'compatible':\n        // fall through because 'compatible' means 'later' for \"spring forward\" transitions\n        case 'later': {\n            const calendar = GetSlot(dateTime, CALENDAR);\n            const PlainDateTime = GetIntrinsic('%Temporal.PlainDateTime%');\n            const later = AddDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar, 0, 0, 0, 0, 0, 0, 0, 0, 0, nanoseconds, undefined);\n            const laterPlainDateTime = new PlainDateTime(later.year, later.month, later.day, later.hour, later.minute, later.second, later.millisecond, later.microsecond, later.nanosecond, calendar);\n            const possible = GetPossibleInstantsFor(timeZone, laterPlainDateTime);\n            return possible[possible.length - 1];\n        }\n        case 'reject': {\n            throw new RangeError('no such instant found');\n        }\n    }\n}\nfunction GetPossibleInstantsFor(timeZone, dateTime) {\n    const possibleInstants = timeZone.getPossibleInstantsFor(dateTime);\n    const result = [];\n    for (const instant of possibleInstants) {\n        if (!IsTemporalInstant(instant)) {\n            throw new TypeError('bad return from getPossibleInstantsFor');\n        }\n        ArrayPrototypePush$1.call(result, instant);\n    }\n    return result;\n}\nfunction ISOYearString(year) {\n    let yearString;\n    if (year < 1000 || year > 9999) {\n        const sign = year < 0 ? '-' : '+';\n        const yearNumber = MathAbs(year);\n        yearString = sign + `000000${yearNumber}`.slice(-6);\n    }\n    else {\n        yearString = `${year}`;\n    }\n    return yearString;\n}\nfunction ISODateTimePartString(part) {\n    return `00${part}`.slice(-2);\n}\nfunction FormatSecondsStringPart(second, millisecond, microsecond, nanosecond, precision) {\n    if (precision === 'minute')\n        return '';\n    const secs = `:${ISODateTimePartString(second)}`;\n    let fractionNumber = millisecond * 1e6 + microsecond * 1e3 + nanosecond;\n    let fraction;\n    if (precision === 'auto') {\n        if (fractionNumber === 0)\n            return secs;\n        fraction = `${fractionNumber}`.padStart(9, '0');\n        while (fraction[fraction.length - 1] === '0')\n            fraction = fraction.slice(0, -1);\n    }\n    else {\n        if (precision === 0)\n            return secs;\n        fraction = `${fractionNumber}`.padStart(9, '0').slice(0, precision);\n    }\n    return `${secs}.${fraction}`;\n}\nfunction TemporalInstantToString(instant, timeZone, precision) {\n    let outputTimeZone = timeZone;\n    if (outputTimeZone === undefined) {\n        const TemporalTimeZone = GetIntrinsic('%Temporal.TimeZone%');\n        outputTimeZone = new TemporalTimeZone('UTC');\n    }\n    const iso = GetISO8601Calendar();\n    const dateTime = BuiltinTimeZoneGetPlainDateTimeFor(outputTimeZone, instant, iso);\n    const year = ISOYearString(GetSlot(dateTime, ISO_YEAR));\n    const month = ISODateTimePartString(GetSlot(dateTime, ISO_MONTH));\n    const day = ISODateTimePartString(GetSlot(dateTime, ISO_DAY));\n    const hour = ISODateTimePartString(GetSlot(dateTime, ISO_HOUR));\n    const minute = ISODateTimePartString(GetSlot(dateTime, ISO_MINUTE));\n    const seconds = FormatSecondsStringPart(GetSlot(dateTime, ISO_SECOND), GetSlot(dateTime, ISO_MILLISECOND), GetSlot(dateTime, ISO_MICROSECOND), GetSlot(dateTime, ISO_NANOSECOND), precision);\n    let timeZoneString = 'Z';\n    if (timeZone !== undefined) {\n        const offsetNs = GetOffsetNanosecondsFor(outputTimeZone, instant);\n        timeZoneString = FormatISOTimeZoneOffsetString(offsetNs);\n    }\n    return `${year}-${month}-${day}T${hour}:${minute}${seconds}${timeZoneString}`;\n}\nfunction TemporalDurationToString(duration, precision = 'auto', options = undefined) {\n    function formatNumber(num) {\n        if (num <= NumberMaxSafeInteger)\n            return num.toString(10);\n        return jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(num).toString(10);\n    }\n    const years = GetSlot(duration, YEARS);\n    const months = GetSlot(duration, MONTHS);\n    const weeks = GetSlot(duration, WEEKS);\n    const days = GetSlot(duration, DAYS);\n    const hours = GetSlot(duration, HOURS);\n    const minutes = GetSlot(duration, MINUTES);\n    let seconds = GetSlot(duration, SECONDS);\n    let ms = GetSlot(duration, MILLISECONDS);\n    let s = GetSlot(duration, MICROSECONDS);\n    let ns = GetSlot(duration, NANOSECONDS);\n    const sign = DurationSign(years, months, weeks, days, hours, minutes, seconds, ms, s, ns);\n    if (options) {\n        const { unit, increment, roundingMode } = options;\n        ({\n            seconds,\n            milliseconds: ms,\n            microseconds: s,\n            nanoseconds: ns\n        } = RoundDuration(0, 0, 0, 0, 0, 0, seconds, ms, s, ns, increment, unit, roundingMode));\n    }\n    const dateParts = [];\n    if (years)\n        dateParts.push(`${formatNumber(MathAbs(years))}Y`);\n    if (months)\n        dateParts.push(`${formatNumber(MathAbs(months))}M`);\n    if (weeks)\n        dateParts.push(`${formatNumber(MathAbs(weeks))}W`);\n    if (days)\n        dateParts.push(`${formatNumber(MathAbs(days))}D`);\n    const timeParts = [];\n    if (hours)\n        timeParts.push(`${formatNumber(MathAbs(hours))}H`);\n    if (minutes)\n        timeParts.push(`${formatNumber(MathAbs(minutes))}M`);\n    const secondParts = [];\n    let total = TotalDurationNanoseconds(0, 0, 0, seconds, ms, s, ns, 0);\n    let nsBigInt, sBigInt, msBigInt, secondsBigInt;\n    ({ quotient: total, remainder: nsBigInt } = divmod(total, THOUSAND));\n    ({ quotient: total, remainder: sBigInt } = divmod(total, THOUSAND));\n    ({ quotient: secondsBigInt, remainder: msBigInt } = divmod(total, THOUSAND));\n    const fraction = MathAbs(jsbi__WEBPACK_IMPORTED_MODULE_0__.toNumber(msBigInt)) * 1e6 + MathAbs(jsbi__WEBPACK_IMPORTED_MODULE_0__.toNumber(sBigInt)) * 1e3 + MathAbs(jsbi__WEBPACK_IMPORTED_MODULE_0__.toNumber(nsBigInt));\n    let decimalPart;\n    if (precision === 'auto') {\n        if (fraction !== 0) {\n            decimalPart = `${fraction}`.padStart(9, '0');\n            while (decimalPart[decimalPart.length - 1] === '0') {\n                decimalPart = decimalPart.slice(0, -1);\n            }\n        }\n    }\n    else if (precision !== 0) {\n        decimalPart = `${fraction}`.padStart(9, '0').slice(0, precision);\n    }\n    if (decimalPart)\n        secondParts.unshift('.', decimalPart);\n    if (!jsbi__WEBPACK_IMPORTED_MODULE_0__.equal(secondsBigInt, ZERO) || secondParts.length || precision !== 'auto') {\n        secondParts.unshift(abs(secondsBigInt).toString());\n    }\n    if (secondParts.length)\n        timeParts.push(`${secondParts.join('')}S`);\n    if (timeParts.length)\n        timeParts.unshift('T');\n    if (!dateParts.length && !timeParts.length)\n        return 'PT0S';\n    return `${sign < 0 ? '-' : ''}P${dateParts.join('')}${timeParts.join('')}`;\n}\nfunction TemporalDateToString(date, showCalendar = 'auto') {\n    const year = ISOYearString(GetSlot(date, ISO_YEAR));\n    const month = ISODateTimePartString(GetSlot(date, ISO_MONTH));\n    const day = ISODateTimePartString(GetSlot(date, ISO_DAY));\n    const calendarID = ToString(GetSlot(date, CALENDAR));\n    const calendar = FormatCalendarAnnotation(calendarID, showCalendar);\n    return `${year}-${month}-${day}${calendar}`;\n}\nfunction TemporalDateTimeToString(dateTime, precision, showCalendar = 'auto', options = undefined) {\n    let year = GetSlot(dateTime, ISO_YEAR);\n    let month = GetSlot(dateTime, ISO_MONTH);\n    let day = GetSlot(dateTime, ISO_DAY);\n    let hour = GetSlot(dateTime, ISO_HOUR);\n    let minute = GetSlot(dateTime, ISO_MINUTE);\n    let second = GetSlot(dateTime, ISO_SECOND);\n    let millisecond = GetSlot(dateTime, ISO_MILLISECOND);\n    let microsecond = GetSlot(dateTime, ISO_MICROSECOND);\n    let nanosecond = GetSlot(dateTime, ISO_NANOSECOND);\n    if (options) {\n        const { unit, increment, roundingMode } = options;\n        ({ year, month, day, hour, minute, second, millisecond, microsecond, nanosecond } = RoundISODateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, increment, unit, roundingMode));\n    }\n    const yearString = ISOYearString(year);\n    const monthString = ISODateTimePartString(month);\n    const dayString = ISODateTimePartString(day);\n    const hourString = ISODateTimePartString(hour);\n    const minuteString = ISODateTimePartString(minute);\n    const secondsString = FormatSecondsStringPart(second, millisecond, microsecond, nanosecond, precision);\n    const calendarID = ToString(GetSlot(dateTime, CALENDAR));\n    const calendar = FormatCalendarAnnotation(calendarID, showCalendar);\n    return `${yearString}-${monthString}-${dayString}T${hourString}:${minuteString}${secondsString}${calendar}`;\n}\nfunction TemporalMonthDayToString(monthDay, showCalendar = 'auto') {\n    const month = ISODateTimePartString(GetSlot(monthDay, ISO_MONTH));\n    const day = ISODateTimePartString(GetSlot(monthDay, ISO_DAY));\n    let resultString = `${month}-${day}`;\n    const calendar = GetSlot(monthDay, CALENDAR);\n    const calendarID = ToString(calendar);\n    if (calendarID !== 'iso8601') {\n        const year = ISOYearString(GetSlot(monthDay, ISO_YEAR));\n        resultString = `${year}-${resultString}`;\n    }\n    const calendarString = FormatCalendarAnnotation(calendarID, showCalendar);\n    if (calendarString)\n        resultString += calendarString;\n    return resultString;\n}\nfunction TemporalYearMonthToString(yearMonth, showCalendar = 'auto') {\n    const year = ISOYearString(GetSlot(yearMonth, ISO_YEAR));\n    const month = ISODateTimePartString(GetSlot(yearMonth, ISO_MONTH));\n    let resultString = `${year}-${month}`;\n    const calendar = GetSlot(yearMonth, CALENDAR);\n    const calendarID = ToString(calendar);\n    if (calendarID !== 'iso8601') {\n        const day = ISODateTimePartString(GetSlot(yearMonth, ISO_DAY));\n        resultString += `-${day}`;\n    }\n    const calendarString = FormatCalendarAnnotation(calendarID, showCalendar);\n    if (calendarString)\n        resultString += calendarString;\n    return resultString;\n}\nfunction TemporalZonedDateTimeToString(zdt, precision, showCalendar = 'auto', showTimeZone = 'auto', showOffset = 'auto', options = undefined) {\n    let instant = GetSlot(zdt, INSTANT);\n    if (options) {\n        const { unit, increment, roundingMode } = options;\n        const ns = RoundInstant(GetSlot(zdt, EPOCHNANOSECONDS), increment, unit, roundingMode);\n        const TemporalInstant = GetIntrinsic('%Temporal.Instant%');\n        instant = new TemporalInstant(ns);\n    }\n    const tz = GetSlot(zdt, TIME_ZONE);\n    const iso = GetISO8601Calendar();\n    const dateTime = BuiltinTimeZoneGetPlainDateTimeFor(tz, instant, iso);\n    const year = ISOYearString(GetSlot(dateTime, ISO_YEAR));\n    const month = ISODateTimePartString(GetSlot(dateTime, ISO_MONTH));\n    const day = ISODateTimePartString(GetSlot(dateTime, ISO_DAY));\n    const hour = ISODateTimePartString(GetSlot(dateTime, ISO_HOUR));\n    const minute = ISODateTimePartString(GetSlot(dateTime, ISO_MINUTE));\n    const seconds = FormatSecondsStringPart(GetSlot(dateTime, ISO_SECOND), GetSlot(dateTime, ISO_MILLISECOND), GetSlot(dateTime, ISO_MICROSECOND), GetSlot(dateTime, ISO_NANOSECOND), precision);\n    let result = `${year}-${month}-${day}T${hour}:${minute}${seconds}`;\n    if (showOffset !== 'never') {\n        const offsetNs = GetOffsetNanosecondsFor(tz, instant);\n        result += FormatISOTimeZoneOffsetString(offsetNs);\n    }\n    if (showTimeZone !== 'never')\n        result += `[${tz}]`;\n    const calendarID = ToString(GetSlot(zdt, CALENDAR));\n    result += FormatCalendarAnnotation(calendarID, showCalendar);\n    return result;\n}\nfunction TestTimeZoneOffsetString(string) {\n    return OFFSET.test(StringCtor(string));\n}\nfunction ParseTimeZoneOffsetString(string) {\n    const match = OFFSET.exec(StringCtor(string));\n    if (!match) {\n        throw new RangeError(`invalid time zone offset: ${string}`);\n    }\n    const sign = match[1] === '-' || match[1] === '\\u2212' ? -1 : +1;\n    const hours = +match[2];\n    const minutes = +(match[3] || 0);\n    const seconds = +(match[4] || 0);\n    const nanoseconds = +((match[5] || 0) + '000000000').slice(0, 9);\n    return sign * (((hours * 60 + minutes) * 60 + seconds) * 1e9 + nanoseconds);\n}\nfunction GetCanonicalTimeZoneIdentifier(timeZoneIdentifier) {\n    if (TestTimeZoneOffsetString(timeZoneIdentifier)) {\n        const offsetNs = ParseTimeZoneOffsetString(timeZoneIdentifier);\n        return FormatTimeZoneOffsetString(offsetNs);\n    }\n    const formatter = getIntlDateTimeFormatEnUsForTimeZone(StringCtor(timeZoneIdentifier));\n    return formatter.resolvedOptions().timeZone;\n}\nfunction GetIANATimeZoneOffsetNanoseconds(epochNanoseconds, id) {\n    const { year, month, day, hour, minute, second, millisecond, microsecond, nanosecond } = GetIANATimeZoneDateTimeParts(epochNanoseconds, id);\n    const utc = GetEpochFromISOParts(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond);\n    if (utc === null)\n        throw new RangeError('Date outside of supported range');\n    return jsbi__WEBPACK_IMPORTED_MODULE_0__.toNumber(jsbi__WEBPACK_IMPORTED_MODULE_0__.subtract(utc, epochNanoseconds));\n}\nfunction FormatTimeZoneOffsetString(offsetNanosecondsParam) {\n    const sign = offsetNanosecondsParam < 0 ? '-' : '+';\n    const offsetNanoseconds = MathAbs(offsetNanosecondsParam);\n    const nanoseconds = offsetNanoseconds % 1e9;\n    const seconds = MathFloor(offsetNanoseconds / 1e9) % 60;\n    const minutes = MathFloor(offsetNanoseconds / 60e9) % 60;\n    const hours = MathFloor(offsetNanoseconds / 3600e9);\n    const hourString = ISODateTimePartString(hours);\n    const minuteString = ISODateTimePartString(minutes);\n    const secondString = ISODateTimePartString(seconds);\n    let post = '';\n    if (nanoseconds) {\n        let fraction = `${nanoseconds}`.padStart(9, '0');\n        while (fraction[fraction.length - 1] === '0')\n            fraction = fraction.slice(0, -1);\n        post = `:${secondString}.${fraction}`;\n    }\n    else if (seconds) {\n        post = `:${secondString}`;\n    }\n    return `${sign}${hourString}:${minuteString}${post}`;\n}\nfunction FormatISOTimeZoneOffsetString(offsetNanosecondsParam) {\n    let offsetNanoseconds = jsbi__WEBPACK_IMPORTED_MODULE_0__.toNumber(RoundNumberToIncrement(jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(offsetNanosecondsParam), 60e9, 'halfExpand'));\n    const sign = offsetNanoseconds < 0 ? '-' : '+';\n    offsetNanoseconds = MathAbs(offsetNanoseconds);\n    const minutes = (offsetNanoseconds / 60e9) % 60;\n    const hours = MathFloor(offsetNanoseconds / 3600e9);\n    const hourString = ISODateTimePartString(hours);\n    const minuteString = ISODateTimePartString(minutes);\n    return `${sign}${hourString}:${minuteString}`;\n}\nfunction GetEpochFromISOParts(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond) {\n    // Note: Date.UTC() interprets one and two-digit years as being in the\n    // 20th century, so don't use it\n    const legacyDate = new Date();\n    legacyDate.setUTCHours(hour, minute, second, millisecond);\n    legacyDate.setUTCFullYear(year, month - 1, day);\n    const ms = legacyDate.getTime();\n    if (NumberIsNaN(ms))\n        return null;\n    let ns = jsbi__WEBPACK_IMPORTED_MODULE_0__.multiply(jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(ms), MILLION);\n    ns = jsbi__WEBPACK_IMPORTED_MODULE_0__.add(ns, jsbi__WEBPACK_IMPORTED_MODULE_0__.multiply(jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(microsecond), THOUSAND));\n    ns = jsbi__WEBPACK_IMPORTED_MODULE_0__.add(ns, jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(nanosecond));\n    if (jsbi__WEBPACK_IMPORTED_MODULE_0__.lessThan(ns, NS_MIN) || jsbi__WEBPACK_IMPORTED_MODULE_0__.greaterThan(ns, NS_MAX))\n        return null;\n    return ns;\n}\nfunction GetISOPartsFromEpoch(epochNanoseconds) {\n    const { quotient, remainder } = divmod(epochNanoseconds, MILLION);\n    let epochMilliseconds = jsbi__WEBPACK_IMPORTED_MODULE_0__.toNumber(quotient);\n    let nanos = jsbi__WEBPACK_IMPORTED_MODULE_0__.toNumber(remainder);\n    if (nanos < 0) {\n        nanos += 1e6;\n        epochMilliseconds -= 1;\n    }\n    const microsecond = MathFloor(nanos / 1e3) % 1e3;\n    const nanosecond = nanos % 1e3;\n    const item = new Date(epochMilliseconds);\n    const year = item.getUTCFullYear();\n    const month = item.getUTCMonth() + 1;\n    const day = item.getUTCDate();\n    const hour = item.getUTCHours();\n    const minute = item.getUTCMinutes();\n    const second = item.getUTCSeconds();\n    const millisecond = item.getUTCMilliseconds();\n    return { epochMilliseconds, year, month, day, hour, minute, second, millisecond, microsecond, nanosecond };\n}\n// ts-prune-ignore-next TODO: remove this after tests are converted to TS\nfunction GetIANATimeZoneDateTimeParts(epochNanoseconds, id) {\n    const { epochMilliseconds, millisecond, microsecond, nanosecond } = GetISOPartsFromEpoch(epochNanoseconds);\n    const { year, month, day, hour, minute, second } = GetFormatterParts(id, epochMilliseconds);\n    return BalanceISODateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond);\n}\nfunction maxJSBI(one, two) {\n    return jsbi__WEBPACK_IMPORTED_MODULE_0__.lessThan(one, two) ? two : one;\n}\n/**\n * Our best guess at how far in advance new rules will be put into the TZDB for\n * future offset transitions. We'll pick 10 years but can always revise it if\n * we find that countries are being unusually proactive in their announcing\n * of offset changes.\n */\nfunction afterLatestPossibleTzdbRuleChange() {\n    return jsbi__WEBPACK_IMPORTED_MODULE_0__.add(SystemUTCEpochNanoSeconds(), ABOUT_TEN_YEARS_NANOS);\n}\nfunction GetIANATimeZoneNextTransition(epochNanoseconds, id) {\n    // Decide how far in the future after `epochNanoseconds` we'll look for an\n    // offset change. There are two cases:\n    // 1. If it's a past date (or a date in the near future) then it's possible\n    //    that the time zone may have newly added DST in the next few years. So\n    //    we'll have to look from the provided time until a few years after the\n    //    current system time. (Changes to DST policy are usually announced a few\n    //    years in the future.) Note that the first DST anywhere started in 1847,\n    //    so we'll start checks in 1847 instead of wasting cycles on years where\n    //    there will never be transitions.\n    // 2. If it's a future date beyond the next few years, then we'll just assume\n    //    that the latest DST policy in TZDB will still be in effect.  In this\n    //    case, we only need to look one year in the future to see if there are\n    //    any DST transitions.  We actually only need to look 9-10 months because\n    //    DST has two transitions per year, but we'll use a year just to be safe.\n    const oneYearLater = jsbi__WEBPACK_IMPORTED_MODULE_0__.add(epochNanoseconds, ABOUT_ONE_YEAR_NANOS);\n    const uppercap = maxJSBI(afterLatestPossibleTzdbRuleChange(), oneYearLater);\n    // The first transition (in any timezone) recorded in the TZDB was in 1847, so\n    // start there if an earlier date is supplied.\n    let leftNanos = maxJSBI(BEFORE_FIRST_OFFSET_TRANSITION, epochNanoseconds);\n    const leftOffsetNs = GetIANATimeZoneOffsetNanoseconds(leftNanos, id);\n    let rightNanos = leftNanos;\n    let rightOffsetNs = leftOffsetNs;\n    while (leftOffsetNs === rightOffsetNs && jsbi__WEBPACK_IMPORTED_MODULE_0__.lessThan(jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(leftNanos), uppercap)) {\n        rightNanos = jsbi__WEBPACK_IMPORTED_MODULE_0__.add(leftNanos, TWO_WEEKS_NANOS);\n        rightOffsetNs = GetIANATimeZoneOffsetNanoseconds(rightNanos, id);\n        if (leftOffsetNs === rightOffsetNs) {\n            leftNanos = rightNanos;\n        }\n    }\n    if (leftOffsetNs === rightOffsetNs)\n        return null;\n    const result = bisect((epochNs) => GetIANATimeZoneOffsetNanoseconds(epochNs, id), leftNanos, rightNanos, leftOffsetNs, rightOffsetNs);\n    return result;\n}\nfunction GetIANATimeZonePreviousTransition(epochNanoseconds, id) {\n    // If a time zone uses DST (at the time of `epochNanoseconds`), then we only\n    // have to look back one year to find a transition. But if it doesn't use DST,\n    // then we need to look all the way back to 1847 (the earliest rule in the\n    // TZDB) to see if it had other offset transitions in the past. Looping back\n    // from a far-future date to 1847 is very slow (minutes of 100% CPU!), and is\n    // also unnecessary because DST rules aren't put into the TZDB more than a few\n    // years in the future because the political changes in time zones happen with\n    // only a few years' warning. Therefore, if a far-future date is provided,\n    // then we'll run the check in two parts:\n    // 1. First, we'll look back for up to one year to see if the latest TZDB\n    //    rules have DST.\n    // 2. If not, then we'll \"fast-reverse\" back to a few years later than the\n    //    current system time, and then look back to 1847. This reduces the\n    //    worst-case loop from 273K years to 175 years, for a ~1500x improvement\n    //    in worst-case perf.\n    const afterLatestRule = afterLatestPossibleTzdbRuleChange();\n    const isFarFuture = jsbi__WEBPACK_IMPORTED_MODULE_0__.greaterThan(epochNanoseconds, afterLatestRule);\n    const lowercap = isFarFuture ? jsbi__WEBPACK_IMPORTED_MODULE_0__.subtract(epochNanoseconds, ABOUT_ONE_YEAR_NANOS) : BEFORE_FIRST_OFFSET_TRANSITION;\n    let rightNanos = jsbi__WEBPACK_IMPORTED_MODULE_0__.subtract(epochNanoseconds, ONE);\n    const rightOffsetNs = GetIANATimeZoneOffsetNanoseconds(rightNanos, id);\n    let leftNanos = rightNanos;\n    let leftOffsetNs = rightOffsetNs;\n    while (rightOffsetNs === leftOffsetNs && jsbi__WEBPACK_IMPORTED_MODULE_0__.greaterThan(rightNanos, lowercap)) {\n        leftNanos = jsbi__WEBPACK_IMPORTED_MODULE_0__.subtract(rightNanos, TWO_WEEKS_NANOS);\n        leftOffsetNs = GetIANATimeZoneOffsetNanoseconds(leftNanos, id);\n        if (rightOffsetNs === leftOffsetNs) {\n            rightNanos = leftNanos;\n        }\n    }\n    if (rightOffsetNs === leftOffsetNs) {\n        if (isFarFuture) {\n            // There was no DST after looking back one year, which means that the most\n            // recent TZDB rules don't have any recurring transitions. To check for\n            // transitions in older rules, back up to a few years after the current\n            // date and then look all the way back to 1847. Note that we move back one\n            // day from the latest possible rule so that when the recursion runs it\n            // won't consider the new time to be \"far future\" because the system clock\n            // has advanced in the meantime.\n            const newTimeToCheck = jsbi__WEBPACK_IMPORTED_MODULE_0__.subtract(afterLatestRule, DAY_NANOS);\n            return GetIANATimeZonePreviousTransition(newTimeToCheck, id);\n        }\n        return null;\n    }\n    const result = bisect((epochNs) => GetIANATimeZoneOffsetNanoseconds(epochNs, id), leftNanos, rightNanos, leftOffsetNs, rightOffsetNs);\n    return result;\n}\n// ts-prune-ignore-next TODO: remove this after tests are converted to TS\nfunction parseFromEnUsFormat(datetime) {\n    const parts = datetime.split(/[^\\w]+/);\n    if (parts.length !== 7) {\n        throw new RangeError(`expected 7 parts in \"${datetime}`);\n    }\n    const month = +parts[0];\n    const day = +parts[1];\n    let year = +parts[2];\n    const era = parts[3].toUpperCase();\n    if (era === 'B' || era === 'BC') {\n        year = -year + 1;\n    }\n    else if (era !== 'A' && era !== 'AD') {\n        throw new RangeError(`Unknown era ${era} in \"${datetime}`);\n    }\n    let hour = +parts[4];\n    if (hour === 24) {\n        // bugs.chromium.org/p/chromium/issues/detail?id=1045791\n        hour = 0;\n    }\n    const minute = +parts[5];\n    const second = +parts[6];\n    if (!NumberIsFinite(year) ||\n        !NumberIsFinite(month) ||\n        !NumberIsFinite(day) ||\n        !NumberIsFinite(hour) ||\n        !NumberIsFinite(minute) ||\n        !NumberIsFinite(second)) {\n        throw new RangeError(`Invalid number in \"${datetime}`);\n    }\n    return { year, month, day, hour, minute, second };\n}\n// ts-prune-ignore-next TODO: remove this after tests are converted to TS\nfunction GetFormatterParts(timeZone, epochMilliseconds) {\n    const formatter = getIntlDateTimeFormatEnUsForTimeZone(timeZone);\n    // Using `format` instead of `formatToParts` for compatibility with older clients\n    const datetime = formatter.format(new Date(epochMilliseconds));\n    return parseFromEnUsFormat(datetime);\n}\nfunction GetIANATimeZoneEpochValue(id, year, month, day, hour, minute, second, millisecond, microsecond, nanosecond) {\n    const ns = GetEpochFromISOParts(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond);\n    if (ns === null)\n        throw new RangeError('DateTime outside of supported range');\n    let nsEarlier = jsbi__WEBPACK_IMPORTED_MODULE_0__.subtract(ns, DAY_NANOS);\n    if (jsbi__WEBPACK_IMPORTED_MODULE_0__.lessThan(nsEarlier, NS_MIN))\n        nsEarlier = ns;\n    let nsLater = jsbi__WEBPACK_IMPORTED_MODULE_0__.add(ns, DAY_NANOS);\n    if (jsbi__WEBPACK_IMPORTED_MODULE_0__.greaterThan(nsLater, NS_MAX))\n        nsLater = ns;\n    const earliest = GetIANATimeZoneOffsetNanoseconds(nsEarlier, id);\n    const latest = GetIANATimeZoneOffsetNanoseconds(nsLater, id);\n    const found = earliest === latest ? [earliest] : [earliest, latest];\n    return found\n        .map((offsetNanoseconds) => {\n        const epochNanoseconds = jsbi__WEBPACK_IMPORTED_MODULE_0__.subtract(ns, jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(offsetNanoseconds));\n        const parts = GetIANATimeZoneDateTimeParts(epochNanoseconds, id);\n        if (year !== parts.year ||\n            month !== parts.month ||\n            day !== parts.day ||\n            hour !== parts.hour ||\n            minute !== parts.minute ||\n            second !== parts.second ||\n            millisecond !== parts.millisecond ||\n            microsecond !== parts.microsecond ||\n            nanosecond !== parts.nanosecond) {\n            return undefined;\n        }\n        return epochNanoseconds;\n    })\n        .filter((x) => x !== undefined);\n}\nfunction LeapYear(year) {\n    if (undefined === year)\n        return false;\n    const isDiv4 = year % 4 === 0;\n    const isDiv100 = year % 100 === 0;\n    const isDiv400 = year % 400 === 0;\n    return isDiv4 && (!isDiv100 || isDiv400);\n}\nfunction ISODaysInMonth(year, month) {\n    const DoM = {\n        standard: [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],\n        leapyear: [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n    };\n    return DoM[LeapYear(year) ? 'leapyear' : 'standard'][month - 1];\n}\nfunction DayOfWeek(year, month, day) {\n    const m = month + (month < 3 ? 10 : -2);\n    const Y = year - (month < 3 ? 1 : 0);\n    const c = MathFloor(Y / 100);\n    const y = Y - c * 100;\n    const d = day;\n    const pD = d;\n    const pM = MathFloor(2.6 * m - 0.2);\n    const pY = y + MathFloor(y / 4);\n    const pC = MathFloor(c / 4) - 2 * c;\n    const dow = (pD + pM + pY + pC) % 7;\n    return dow + (dow <= 0 ? 7 : 0);\n}\nfunction DayOfYear(year, month, day) {\n    let days = day;\n    for (let m = month - 1; m > 0; m--) {\n        days += ISODaysInMonth(year, m);\n    }\n    return days;\n}\nfunction WeekOfYear(year, month, day) {\n    const doy = DayOfYear(year, month, day);\n    const dow = DayOfWeek(year, month, day) || 7;\n    const doj = DayOfWeek(year, 1, 1);\n    const week = MathFloor((doy - dow + 10) / 7);\n    if (week < 1) {\n        if (doj === 5 || (doj === 6 && LeapYear(year - 1))) {\n            return 53;\n        }\n        else {\n            return 52;\n        }\n    }\n    if (week === 53) {\n        if ((LeapYear(year) ? 366 : 365) - doy < 4 - dow) {\n            return 1;\n        }\n    }\n    return week;\n}\nfunction DurationSign(y, mon, w, d, h, min, s, ms, s, ns) {\n    for (const prop of [y, mon, w, d, h, min, s, ms, s, ns]) {\n        if (prop !== 0)\n            return prop < 0 ? -1 : 1;\n    }\n    return 0;\n}\nfunction BalanceISOYearMonth(yearParam, monthParam) {\n    let year = yearParam;\n    let month = monthParam;\n    if (!NumberIsFinite(year) || !NumberIsFinite(month))\n        throw new RangeError('infinity is out of range');\n    month -= 1;\n    year += MathFloor(month / 12);\n    month %= 12;\n    if (month < 0)\n        month += 12;\n    month += 1;\n    return { year, month };\n}\nfunction BalanceISODate(yearParam, monthParam, dayParam) {\n    let year = yearParam;\n    let month = monthParam;\n    let day = dayParam;\n    if (!NumberIsFinite(day))\n        throw new RangeError('infinity is out of range');\n    ({ year, month } = BalanceISOYearMonth(year, month));\n    let daysInYear = 0;\n    let testYear = month > 2 ? year : year - 1;\n    while (((daysInYear = LeapYear(testYear) ? 366 : 365), day < -daysInYear)) {\n        year -= 1;\n        testYear -= 1;\n        day += daysInYear;\n    }\n    testYear += 1;\n    while (((daysInYear = LeapYear(testYear) ? 366 : 365), day > daysInYear)) {\n        year += 1;\n        testYear += 1;\n        day -= daysInYear;\n    }\n    while (day < 1) {\n        ({ year, month } = BalanceISOYearMonth(year, month - 1));\n        day += ISODaysInMonth(year, month);\n    }\n    while (day > ISODaysInMonth(year, month)) {\n        day -= ISODaysInMonth(year, month);\n        ({ year, month } = BalanceISOYearMonth(year, month + 1));\n    }\n    return { year, month, day };\n}\nfunction BalanceISODateTime(yearParam, monthParam, dayParam, hourParam, minuteParam, secondParam, millisecondParam, microsecondParam, nanosecondParam) {\n    const { deltaDays, hour, minute, second, millisecond, microsecond, nanosecond } = BalanceTime(hourParam, minuteParam, secondParam, millisecondParam, microsecondParam, nanosecondParam);\n    const { year, month, day } = BalanceISODate(yearParam, monthParam, dayParam + deltaDays);\n    return { year, month, day, hour, minute, second, millisecond, microsecond, nanosecond };\n}\nfunction BalanceTime(hourParam, minuteParam, secondParam, millisecondParam, microsecondParam, nanosecondParam) {\n    let hour = hourParam;\n    let minute = minuteParam;\n    let second = secondParam;\n    let millisecond = millisecondParam;\n    let microsecond = microsecondParam;\n    let nanosecond = nanosecondParam;\n    if (!NumberIsFinite(hour) ||\n        !NumberIsFinite(minute) ||\n        !NumberIsFinite(second) ||\n        !NumberIsFinite(millisecond) ||\n        !NumberIsFinite(microsecond) ||\n        !NumberIsFinite(nanosecond)) {\n        throw new RangeError('infinity is out of range');\n    }\n    microsecond += MathFloor(nanosecond / 1000);\n    nanosecond = NonNegativeModulo(nanosecond, 1000);\n    millisecond += MathFloor(microsecond / 1000);\n    microsecond = NonNegativeModulo(microsecond, 1000);\n    second += MathFloor(millisecond / 1000);\n    millisecond = NonNegativeModulo(millisecond, 1000);\n    minute += MathFloor(second / 60);\n    second = NonNegativeModulo(second, 60);\n    hour += MathFloor(minute / 60);\n    minute = NonNegativeModulo(minute, 60);\n    const deltaDays = MathFloor(hour / 24);\n    hour = NonNegativeModulo(hour, 24);\n    return { deltaDays, hour, minute, second, millisecond, microsecond, nanosecond };\n}\nfunction TotalDurationNanoseconds(daysParam, hoursParam, minutesParam, secondsParam, millisecondsParam, microsecondsParam, nanosecondsParam, offsetShift) {\n    const days = jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(daysParam);\n    let nanoseconds = jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(nanosecondsParam);\n    if (daysParam !== 0)\n        nanoseconds = jsbi__WEBPACK_IMPORTED_MODULE_0__.subtract(jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(nanosecondsParam), jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(offsetShift));\n    const hours = jsbi__WEBPACK_IMPORTED_MODULE_0__.add(jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(hoursParam), jsbi__WEBPACK_IMPORTED_MODULE_0__.multiply(days, jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(24)));\n    const minutes = jsbi__WEBPACK_IMPORTED_MODULE_0__.add(jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(minutesParam), jsbi__WEBPACK_IMPORTED_MODULE_0__.multiply(hours, SIXTY));\n    const seconds = jsbi__WEBPACK_IMPORTED_MODULE_0__.add(jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(secondsParam), jsbi__WEBPACK_IMPORTED_MODULE_0__.multiply(minutes, SIXTY));\n    const milliseconds = jsbi__WEBPACK_IMPORTED_MODULE_0__.add(jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(millisecondsParam), jsbi__WEBPACK_IMPORTED_MODULE_0__.multiply(seconds, THOUSAND));\n    const microseconds = jsbi__WEBPACK_IMPORTED_MODULE_0__.add(jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(microsecondsParam), jsbi__WEBPACK_IMPORTED_MODULE_0__.multiply(milliseconds, THOUSAND));\n    return jsbi__WEBPACK_IMPORTED_MODULE_0__.add(jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(nanoseconds), jsbi__WEBPACK_IMPORTED_MODULE_0__.multiply(microseconds, THOUSAND));\n}\nfunction NanosecondsToDays(nanosecondsParam, relativeTo) {\n    const TemporalInstant = GetIntrinsic('%Temporal.Instant%');\n    const sign = MathSign(jsbi__WEBPACK_IMPORTED_MODULE_0__.toNumber(nanosecondsParam));\n    let nanoseconds = jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(nanosecondsParam);\n    let dayLengthNs = 86400e9;\n    if (sign === 0)\n        return { days: 0, nanoseconds: ZERO, dayLengthNs };\n    if (!IsTemporalZonedDateTime(relativeTo)) {\n        let days;\n        ({ quotient: days, remainder: nanoseconds } = divmod(nanoseconds, jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(dayLengthNs)));\n        return { days: jsbi__WEBPACK_IMPORTED_MODULE_0__.toNumber(days), nanoseconds, dayLengthNs };\n    }\n    const startNs = GetSlot(relativeTo, EPOCHNANOSECONDS);\n    const start = GetSlot(relativeTo, INSTANT);\n    const endNs = jsbi__WEBPACK_IMPORTED_MODULE_0__.add(startNs, nanoseconds);\n    const end = new TemporalInstant(endNs);\n    const timeZone = GetSlot(relativeTo, TIME_ZONE);\n    const calendar = GetSlot(relativeTo, CALENDAR);\n    // Find the difference in days only.\n    const dtStart = BuiltinTimeZoneGetPlainDateTimeFor(timeZone, start, calendar);\n    const dtEnd = BuiltinTimeZoneGetPlainDateTimeFor(timeZone, end, calendar);\n    let { days } = DifferenceISODateTime(GetSlot(dtStart, ISO_YEAR), GetSlot(dtStart, ISO_MONTH), GetSlot(dtStart, ISO_DAY), GetSlot(dtStart, ISO_HOUR), GetSlot(dtStart, ISO_MINUTE), GetSlot(dtStart, ISO_SECOND), GetSlot(dtStart, ISO_MILLISECOND), GetSlot(dtStart, ISO_MICROSECOND), GetSlot(dtStart, ISO_NANOSECOND), GetSlot(dtEnd, ISO_YEAR), GetSlot(dtEnd, ISO_MONTH), GetSlot(dtEnd, ISO_DAY), GetSlot(dtEnd, ISO_HOUR), GetSlot(dtEnd, ISO_MINUTE), GetSlot(dtEnd, ISO_SECOND), GetSlot(dtEnd, ISO_MILLISECOND), GetSlot(dtEnd, ISO_MICROSECOND), GetSlot(dtEnd, ISO_NANOSECOND), calendar, 'day');\n    let intermediateNs = AddZonedDateTime(start, timeZone, calendar, 0, 0, 0, days, 0, 0, 0, 0, 0, 0);\n    // may disambiguate\n    // If clock time after addition was in the middle of a skipped period, the\n    // endpoint was disambiguated to a later clock time. So it's possible that\n    // the resulting disambiguated result is later than endNs. If so, then back\n    // up one day and try again. Repeat if necessary (some transitions are\n    // > 24 hours) until either there's zero days left or the date duration is\n    // back inside the period where it belongs. Note that this case only can\n    // happen for positive durations because the only direction that\n    // `disambiguation: 'compatible'` can change clock time is forwards.\n    if (sign === 1) {\n        while (days > 0 && jsbi__WEBPACK_IMPORTED_MODULE_0__.greaterThan(intermediateNs, endNs)) {\n            --days;\n            intermediateNs = AddZonedDateTime(start, timeZone, calendar, 0, 0, 0, days, 0, 0, 0, 0, 0, 0);\n            // may do disambiguation\n        }\n    }\n    nanoseconds = jsbi__WEBPACK_IMPORTED_MODULE_0__.subtract(endNs, intermediateNs);\n    let isOverflow = false;\n    let relativeInstant = new TemporalInstant(intermediateNs);\n    do {\n        // calculate length of the next day (day that contains the time remainder)\n        const oneDayFartherNs = AddZonedDateTime(relativeInstant, timeZone, calendar, 0, 0, 0, sign, 0, 0, 0, 0, 0, 0);\n        const relativeNs = GetSlot(relativeInstant, EPOCHNANOSECONDS);\n        dayLengthNs = jsbi__WEBPACK_IMPORTED_MODULE_0__.toNumber(jsbi__WEBPACK_IMPORTED_MODULE_0__.subtract(oneDayFartherNs, relativeNs));\n        isOverflow = jsbi__WEBPACK_IMPORTED_MODULE_0__.greaterThan(jsbi__WEBPACK_IMPORTED_MODULE_0__.multiply(jsbi__WEBPACK_IMPORTED_MODULE_0__.subtract(nanoseconds, jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(dayLengthNs)), jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(sign)), ZERO);\n        if (isOverflow) {\n            nanoseconds = jsbi__WEBPACK_IMPORTED_MODULE_0__.subtract(nanoseconds, jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(dayLengthNs));\n            relativeInstant = new TemporalInstant(oneDayFartherNs);\n            days += sign;\n        }\n    } while (isOverflow);\n    return { days, nanoseconds, dayLengthNs: MathAbs(dayLengthNs) };\n}\nfunction BalanceDuration(daysParam, hoursParam, minutesParam, secondsParam, millisecondsParam, microsecondsParam, nanosecondsParam, largestUnit, relativeTo = undefined) {\n    let days = daysParam;\n    let nanosecondsBigInt, microsecondsBigInt, millisecondsBigInt, secondsBigInt, minutesBigInt, hoursBigInt;\n    if (IsTemporalZonedDateTime(relativeTo)) {\n        const endNs = AddZonedDateTime(GetSlot(relativeTo, INSTANT), GetSlot(relativeTo, TIME_ZONE), GetSlot(relativeTo, CALENDAR), 0, 0, 0, days, hoursParam, minutesParam, secondsParam, millisecondsParam, microsecondsParam, nanosecondsParam);\n        const startNs = GetSlot(relativeTo, EPOCHNANOSECONDS);\n        nanosecondsBigInt = jsbi__WEBPACK_IMPORTED_MODULE_0__.subtract(endNs, startNs);\n    }\n    else {\n        nanosecondsBigInt = TotalDurationNanoseconds(days, hoursParam, minutesParam, secondsParam, millisecondsParam, microsecondsParam, nanosecondsParam, 0);\n    }\n    if (largestUnit === 'year' || largestUnit === 'month' || largestUnit === 'week' || largestUnit === 'day') {\n        ({ days, nanoseconds: nanosecondsBigInt } = NanosecondsToDays(nanosecondsBigInt, relativeTo));\n    }\n    else {\n        days = 0;\n    }\n    const sign = jsbi__WEBPACK_IMPORTED_MODULE_0__.lessThan(nanosecondsBigInt, ZERO) ? -1 : 1;\n    nanosecondsBigInt = abs(nanosecondsBigInt);\n    microsecondsBigInt = millisecondsBigInt = secondsBigInt = minutesBigInt = hoursBigInt = ZERO;\n    switch (largestUnit) {\n        case 'year':\n        case 'month':\n        case 'week':\n        case 'day':\n        case 'hour':\n            ({ quotient: microsecondsBigInt, remainder: nanosecondsBigInt } = divmod(nanosecondsBigInt, THOUSAND));\n            ({ quotient: millisecondsBigInt, remainder: microsecondsBigInt } = divmod(microsecondsBigInt, THOUSAND));\n            ({ quotient: secondsBigInt, remainder: millisecondsBigInt } = divmod(millisecondsBigInt, THOUSAND));\n            ({ quotient: minutesBigInt, remainder: secondsBigInt } = divmod(secondsBigInt, SIXTY));\n            ({ quotient: hoursBigInt, remainder: minutesBigInt } = divmod(minutesBigInt, SIXTY));\n            break;\n        case 'minute':\n            ({ quotient: microsecondsBigInt, remainder: nanosecondsBigInt } = divmod(nanosecondsBigInt, THOUSAND));\n            ({ quotient: millisecondsBigInt, remainder: microsecondsBigInt } = divmod(microsecondsBigInt, THOUSAND));\n            ({ quotient: secondsBigInt, remainder: millisecondsBigInt } = divmod(millisecondsBigInt, THOUSAND));\n            ({ quotient: minutesBigInt, remainder: secondsBigInt } = divmod(secondsBigInt, SIXTY));\n            break;\n        case 'second':\n            ({ quotient: microsecondsBigInt, remainder: nanosecondsBigInt } = divmod(nanosecondsBigInt, THOUSAND));\n            ({ quotient: millisecondsBigInt, remainder: microsecondsBigInt } = divmod(microsecondsBigInt, THOUSAND));\n            ({ quotient: secondsBigInt, remainder: millisecondsBigInt } = divmod(millisecondsBigInt, THOUSAND));\n            break;\n        case 'millisecond':\n            ({ quotient: microsecondsBigInt, remainder: nanosecondsBigInt } = divmod(nanosecondsBigInt, THOUSAND));\n            ({ quotient: millisecondsBigInt, remainder: microsecondsBigInt } = divmod(microsecondsBigInt, THOUSAND));\n            break;\n        case 'microsecond':\n            ({ quotient: microsecondsBigInt, remainder: nanosecondsBigInt } = divmod(nanosecondsBigInt, THOUSAND));\n            break;\n        case 'nanosecond':\n            break;\n        default:\n            throw new Error('assert not reached');\n    }\n    const hours = jsbi__WEBPACK_IMPORTED_MODULE_0__.toNumber(hoursBigInt) * sign;\n    const minutes = jsbi__WEBPACK_IMPORTED_MODULE_0__.toNumber(minutesBigInt) * sign;\n    const seconds = jsbi__WEBPACK_IMPORTED_MODULE_0__.toNumber(secondsBigInt) * sign;\n    const milliseconds = jsbi__WEBPACK_IMPORTED_MODULE_0__.toNumber(millisecondsBigInt) * sign;\n    const microseconds = jsbi__WEBPACK_IMPORTED_MODULE_0__.toNumber(microsecondsBigInt) * sign;\n    const nanoseconds = jsbi__WEBPACK_IMPORTED_MODULE_0__.toNumber(nanosecondsBigInt) * sign;\n    return { days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds };\n}\nfunction UnbalanceDurationRelative(yearsParam, monthsParam, weeksParam, daysParam, largestUnit, relativeToParam) {\n    let years = yearsParam;\n    let months = monthsParam;\n    let weeks = weeksParam;\n    let days = daysParam;\n    const TemporalDuration = GetIntrinsic('%Temporal.Duration%');\n    const sign = DurationSign(years, months, weeks, days, 0, 0, 0, 0, 0, 0);\n    let calendar;\n    let relativeTo;\n    if (relativeToParam) {\n        relativeTo = ToTemporalDate(relativeToParam);\n        calendar = GetSlot(relativeTo, CALENDAR);\n    }\n    const oneYear = new TemporalDuration(sign);\n    const oneMonth = new TemporalDuration(0, sign);\n    const oneWeek = new TemporalDuration(0, 0, sign);\n    switch (largestUnit) {\n        case 'year':\n            // no-op\n            break;\n        case 'month':\n            {\n                if (!calendar)\n                    throw new RangeError('a starting point is required for months balancing');\n                // balance years down to months\n                const dateAdd = calendar.dateAdd;\n                const dateUntil = calendar.dateUntil;\n                let relativeToDateOnly = relativeTo;\n                while (MathAbs(years) > 0) {\n                    const addOptions = ObjectCreate$2(null);\n                    const newRelativeTo = CalendarDateAdd(calendar, relativeToDateOnly, oneYear, addOptions, dateAdd);\n                    const untilOptions = ObjectCreate$2(null);\n                    untilOptions.largestUnit = 'month';\n                    const untilResult = CalendarDateUntil(calendar, relativeToDateOnly, newRelativeTo, untilOptions, dateUntil);\n                    const oneYearMonths = GetSlot(untilResult, MONTHS);\n                    relativeToDateOnly = newRelativeTo;\n                    months += oneYearMonths;\n                    years -= sign;\n                }\n            }\n            break;\n        case 'week':\n            if (!calendar)\n                throw new RangeError('a starting point is required for weeks balancing');\n            // balance years down to days\n            while (MathAbs(years) > 0) {\n                let oneYearDays;\n                ({ relativeTo, days: oneYearDays } = MoveRelativeDate(calendar, relativeTo, oneYear));\n                days += oneYearDays;\n                years -= sign;\n            }\n            // balance months down to days\n            while (MathAbs(months) > 0) {\n                let oneMonthDays;\n                ({ relativeTo, days: oneMonthDays } = MoveRelativeDate(calendar, relativeTo, oneMonth));\n                days += oneMonthDays;\n                months -= sign;\n            }\n            break;\n        default:\n            // balance years down to days\n            while (MathAbs(years) > 0) {\n                if (!calendar)\n                    throw new RangeError('a starting point is required for balancing calendar units');\n                let oneYearDays;\n                ({ relativeTo, days: oneYearDays } = MoveRelativeDate(calendar, relativeTo, oneYear));\n                days += oneYearDays;\n                years -= sign;\n            }\n            // balance months down to days\n            while (MathAbs(months) > 0) {\n                if (!calendar)\n                    throw new RangeError('a starting point is required for balancing calendar units');\n                let oneMonthDays;\n                ({ relativeTo, days: oneMonthDays } = MoveRelativeDate(calendar, relativeTo, oneMonth));\n                days += oneMonthDays;\n                months -= sign;\n            }\n            // balance weeks down to days\n            while (MathAbs(weeks) > 0) {\n                if (!calendar)\n                    throw new RangeError('a starting point is required for balancing calendar units');\n                let oneWeekDays;\n                ({ relativeTo, days: oneWeekDays } = MoveRelativeDate(calendar, relativeTo, oneWeek));\n                days += oneWeekDays;\n                weeks -= sign;\n            }\n            break;\n    }\n    return { years, months, weeks, days };\n}\nfunction BalanceDurationRelative(yearsParam, monthsParam, weeksParam, daysParam, largestUnit, relativeToParam) {\n    let years = yearsParam;\n    let months = monthsParam;\n    let weeks = weeksParam;\n    let days = daysParam;\n    const TemporalDuration = GetIntrinsic('%Temporal.Duration%');\n    const sign = DurationSign(years, months, weeks, days, 0, 0, 0, 0, 0, 0);\n    if (sign === 0)\n        return { years, months, weeks, days };\n    let calendar;\n    let relativeTo;\n    if (relativeToParam) {\n        relativeTo = ToTemporalDate(relativeToParam);\n        calendar = GetSlot(relativeTo, CALENDAR);\n    }\n    const oneYear = new TemporalDuration(sign);\n    const oneMonth = new TemporalDuration(0, sign);\n    const oneWeek = new TemporalDuration(0, 0, sign);\n    switch (largestUnit) {\n        case 'year': {\n            if (!calendar)\n                throw new RangeError('a starting point is required for years balancing');\n            // balance days up to years\n            let newRelativeTo, oneYearDays;\n            ({ relativeTo: newRelativeTo, days: oneYearDays } = MoveRelativeDate(calendar, relativeTo, oneYear));\n            while (MathAbs(days) >= MathAbs(oneYearDays)) {\n                days -= oneYearDays;\n                years += sign;\n                relativeTo = newRelativeTo;\n                ({ relativeTo: newRelativeTo, days: oneYearDays } = MoveRelativeDate(calendar, relativeTo, oneYear));\n            }\n            // balance days up to months\n            let oneMonthDays;\n            ({ relativeTo: newRelativeTo, days: oneMonthDays } = MoveRelativeDate(calendar, relativeTo, oneMonth));\n            while (MathAbs(days) >= MathAbs(oneMonthDays)) {\n                days -= oneMonthDays;\n                months += sign;\n                relativeTo = newRelativeTo;\n                ({ relativeTo: newRelativeTo, days: oneMonthDays } = MoveRelativeDate(calendar, relativeTo, oneMonth));\n            }\n            // balance months up to years\n            const dateAdd = calendar.dateAdd;\n            const addOptions = ObjectCreate$2(null);\n            newRelativeTo = CalendarDateAdd(calendar, relativeTo, oneYear, addOptions, dateAdd);\n            const dateUntil = calendar.dateUntil;\n            const untilOptions = ObjectCreate$2(null);\n            untilOptions.largestUnit = 'month';\n            let untilResult = CalendarDateUntil(calendar, relativeTo, newRelativeTo, untilOptions, dateUntil);\n            let oneYearMonths = GetSlot(untilResult, MONTHS);\n            while (MathAbs(months) >= MathAbs(oneYearMonths)) {\n                months -= oneYearMonths;\n                years += sign;\n                relativeTo = newRelativeTo;\n                const addOptions = ObjectCreate$2(null);\n                newRelativeTo = CalendarDateAdd(calendar, relativeTo, oneYear, addOptions, dateAdd);\n                const untilOptions = ObjectCreate$2(null);\n                untilOptions.largestUnit = 'month';\n                untilResult = CalendarDateUntil(calendar, relativeTo, newRelativeTo, untilOptions, dateUntil);\n                oneYearMonths = GetSlot(untilResult, MONTHS);\n            }\n            break;\n        }\n        case 'month': {\n            if (!calendar)\n                throw new RangeError('a starting point is required for months balancing');\n            // balance days up to months\n            let newRelativeTo, oneMonthDays;\n            ({ relativeTo: newRelativeTo, days: oneMonthDays } = MoveRelativeDate(calendar, relativeTo, oneMonth));\n            while (MathAbs(days) >= MathAbs(oneMonthDays)) {\n                days -= oneMonthDays;\n                months += sign;\n                relativeTo = newRelativeTo;\n                ({ relativeTo: newRelativeTo, days: oneMonthDays } = MoveRelativeDate(calendar, relativeTo, oneMonth));\n            }\n            break;\n        }\n        case 'week': {\n            if (!calendar)\n                throw new RangeError('a starting point is required for weeks balancing');\n            // balance days up to weeks\n            let newRelativeTo, oneWeekDays;\n            ({ relativeTo: newRelativeTo, days: oneWeekDays } = MoveRelativeDate(calendar, relativeTo, oneWeek));\n            while (MathAbs(days) >= MathAbs(oneWeekDays)) {\n                days -= oneWeekDays;\n                weeks += sign;\n                relativeTo = newRelativeTo;\n                ({ relativeTo: newRelativeTo, days: oneWeekDays } = MoveRelativeDate(calendar, relativeTo, oneWeek));\n            }\n            break;\n        }\n    }\n    return { years, months, weeks, days };\n}\nfunction CalculateOffsetShift(relativeTo, y, mon, w, d, h, min, s, ms, s, ns) {\n    if (IsTemporalZonedDateTime(relativeTo)) {\n        const instant = GetSlot(relativeTo, INSTANT);\n        const timeZone = GetSlot(relativeTo, TIME_ZONE);\n        const calendar = GetSlot(relativeTo, CALENDAR);\n        const offsetBefore = GetOffsetNanosecondsFor(timeZone, instant);\n        const after = AddZonedDateTime(instant, timeZone, calendar, y, mon, w, d, h, min, s, ms, s, ns);\n        const TemporalInstant = GetIntrinsic('%Temporal.Instant%');\n        const instantAfter = new TemporalInstant(after);\n        const offsetAfter = GetOffsetNanosecondsFor(timeZone, instantAfter);\n        return offsetAfter - offsetBefore;\n    }\n    return 0;\n}\nfunction CreateNegatedTemporalDuration(duration) {\n    const TemporalDuration = GetIntrinsic('%Temporal.Duration%');\n    return new TemporalDuration(-GetSlot(duration, YEARS), -GetSlot(duration, MONTHS), -GetSlot(duration, WEEKS), -GetSlot(duration, DAYS), -GetSlot(duration, HOURS), -GetSlot(duration, MINUTES), -GetSlot(duration, SECONDS), -GetSlot(duration, MILLISECONDS), -GetSlot(duration, MICROSECONDS), -GetSlot(duration, NANOSECONDS));\n}\nfunction ConstrainToRange(value, min, max) {\n    // Math.Max accepts undefined values and returns NaN. Undefined values are\n    // used for optional params in the method below.\n    return MathMin(max, MathMax(min, value));\n}\nfunction ConstrainISODate(year, monthParam, dayParam) {\n    const month = ConstrainToRange(monthParam, 1, 12);\n    const day = ConstrainToRange(dayParam, 1, ISODaysInMonth(year, month));\n    return { year, month, day };\n}\nfunction ConstrainTime(hourParam, minuteParam, secondParam, millisecondParam, microsecondParam, nanosecondParam) {\n    const hour = ConstrainToRange(hourParam, 0, 23);\n    const minute = ConstrainToRange(minuteParam, 0, 59);\n    const second = ConstrainToRange(secondParam, 0, 59);\n    const millisecond = ConstrainToRange(millisecondParam, 0, 999);\n    const microsecond = ConstrainToRange(microsecondParam, 0, 999);\n    const nanosecond = ConstrainToRange(nanosecondParam, 0, 999);\n    return { hour, minute, second, millisecond, microsecond, nanosecond };\n}\nfunction RejectToRange(value, min, max) {\n    if (value < min || value > max)\n        throw new RangeError(`value out of range: ${min} <= ${value} <= ${max}`);\n}\nfunction RejectISODate(year, month, day) {\n    RejectToRange(month, 1, 12);\n    RejectToRange(day, 1, ISODaysInMonth(year, month));\n}\nfunction RejectDateRange(year, month, day) {\n    // Noon avoids trouble at edges of DateTime range (excludes midnight)\n    RejectDateTimeRange(year, month, day, 12, 0, 0, 0, 0, 0);\n}\nfunction RejectTime(hour, minute, second, millisecond, microsecond, nanosecond) {\n    RejectToRange(hour, 0, 23);\n    RejectToRange(minute, 0, 59);\n    RejectToRange(second, 0, 59);\n    RejectToRange(millisecond, 0, 999);\n    RejectToRange(microsecond, 0, 999);\n    RejectToRange(nanosecond, 0, 999);\n}\nfunction RejectDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond) {\n    RejectISODate(year, month, day);\n    RejectTime(hour, minute, second, millisecond, microsecond, nanosecond);\n}\nfunction RejectDateTimeRange(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond) {\n    RejectToRange(year, YEAR_MIN, YEAR_MAX);\n    // Reject any DateTime 24 hours or more outside the Instant range\n    if ((year === YEAR_MIN &&\n        null ==\n            GetEpochFromISOParts(year, month, day + 1, hour, minute, second, millisecond, microsecond, nanosecond - 1)) ||\n        (year === YEAR_MAX &&\n            null ==\n                GetEpochFromISOParts(year, month, day - 1, hour, minute, second, millisecond, microsecond, nanosecond + 1))) {\n        throw new RangeError('DateTime outside of supported range');\n    }\n}\nfunction ValidateEpochNanoseconds(epochNanoseconds) {\n    if (jsbi__WEBPACK_IMPORTED_MODULE_0__.lessThan(epochNanoseconds, NS_MIN) || jsbi__WEBPACK_IMPORTED_MODULE_0__.greaterThan(epochNanoseconds, NS_MAX)) {\n        throw new RangeError('Instant outside of supported range');\n    }\n}\nfunction RejectYearMonthRange(year, month) {\n    RejectToRange(year, YEAR_MIN, YEAR_MAX);\n    if (year === YEAR_MIN) {\n        RejectToRange(month, 4, 12);\n    }\n    else if (year === YEAR_MAX) {\n        RejectToRange(month, 1, 9);\n    }\n}\nfunction RejectDuration(y, mon, w, d, h, min, s, ms, s, ns) {\n    const sign = DurationSign(y, mon, w, d, h, min, s, ms, s, ns);\n    for (const prop of [y, mon, w, d, h, min, s, ms, s, ns]) {\n        if (!NumberIsFinite(prop))\n            throw new RangeError('infinite values not allowed as duration fields');\n        const propSign = MathSign(prop);\n        if (propSign !== 0 && propSign !== sign)\n            throw new RangeError('mixed-sign values not allowed as duration fields');\n    }\n}\nfunction DifferenceISODate(y1, m1, d1, y2, m2, d2, largestUnit) {\n    switch (largestUnit) {\n        case 'year':\n        case 'month': {\n            const sign = -CompareISODate(y1, m1, d1, y2, m2, d2);\n            if (sign === 0)\n                return { years: 0, months: 0, weeks: 0, days: 0 };\n            const start = { year: y1, month: m1, day: d1 };\n            const end = { year: y2, month: m2, day: d2 };\n            let years = end.year - start.year;\n            let mid = AddISODate(y1, m1, d1, years, 0, 0, 0, 'constrain');\n            let midSign = -CompareISODate(mid.year, mid.month, mid.day, y2, m2, d2);\n            if (midSign === 0) {\n                return largestUnit === 'year'\n                    ? { years, months: 0, weeks: 0, days: 0 }\n                    : { years: 0, months: years * 12, weeks: 0, days: 0 };\n            }\n            let months = end.month - start.month;\n            if (midSign !== sign) {\n                years -= sign;\n                months += sign * 12;\n            }\n            mid = AddISODate(y1, m1, d1, years, months, 0, 0, 'constrain');\n            midSign = -CompareISODate(mid.year, mid.month, mid.day, y2, m2, d2);\n            if (midSign === 0) {\n                return largestUnit === 'year'\n                    ? { years, months, weeks: 0, days: 0 }\n                    : { years: 0, months: months + years * 12, weeks: 0, days: 0 };\n            }\n            if (midSign !== sign) {\n                // The end date is later in the month than mid date (or earlier for\n                // negative durations). Back up one month.\n                months -= sign;\n                if (months === -sign) {\n                    years -= sign;\n                    months = 11 * sign;\n                }\n                mid = AddISODate(y1, m1, d1, years, months, 0, 0, 'constrain');\n                midSign = -CompareISODate(y1, m1, d1, mid.year, mid.month, mid.day);\n            }\n            let days = 0;\n            // If we get here, months and years are correct (no overflow), and `mid`\n            // is within the range from `start` to `end`. To count the days between\n            // `mid` and `end`, there are 3 cases:\n            // 1) same month: use simple subtraction\n            // 2) end is previous month from intermediate (negative duration)\n            // 3) end is next month from intermediate (positive duration)\n            if (mid.month === end.month) {\n                // 1) same month: use simple subtraction\n                days = end.day - mid.day;\n            }\n            else if (sign < 0) {\n                // 2) end is previous month from intermediate (negative duration)\n                // Example: intermediate: Feb 1, end: Jan 30, DaysInMonth = 31, days = -2\n                days = -mid.day - (ISODaysInMonth(end.year, end.month) - end.day);\n            }\n            else {\n                // 3) end is next month from intermediate (positive duration)\n                // Example: intermediate: Jan 29, end: Feb 1, DaysInMonth = 31, days = 3\n                days = end.day + (ISODaysInMonth(mid.year, mid.month) - mid.day);\n            }\n            if (largestUnit === 'month') {\n                months += years * 12;\n                years = 0;\n            }\n            return { years, months, weeks: 0, days };\n        }\n        case 'week':\n        case 'day': {\n            let larger, smaller, sign;\n            if (CompareISODate(y1, m1, d1, y2, m2, d2) < 0) {\n                smaller = { year: y1, month: m1, day: d1 };\n                larger = { year: y2, month: m2, day: d2 };\n                sign = 1;\n            }\n            else {\n                smaller = { year: y2, month: m2, day: d2 };\n                larger = { year: y1, month: m1, day: d1 };\n                sign = -1;\n            }\n            let days = DayOfYear(larger.year, larger.month, larger.day) - DayOfYear(smaller.year, smaller.month, smaller.day);\n            for (let year = smaller.year; year < larger.year; ++year) {\n                days += LeapYear(year) ? 366 : 365;\n            }\n            let weeks = 0;\n            if (largestUnit === 'week') {\n                weeks = MathFloor(days / 7);\n                days %= 7;\n            }\n            weeks *= sign;\n            days *= sign;\n            return { years: 0, months: 0, weeks, days };\n        }\n        default:\n            throw new Error('assert not reached');\n    }\n}\nfunction DifferenceTime(h1, min1, s1, ms1, s1, ns1, h2, min2, s2, ms2, s2, ns2) {\n    let hours = h2 - h1;\n    let minutes = min2 - min1;\n    let seconds = s2 - s1;\n    let milliseconds = ms2 - ms1;\n    let microseconds = s2 - s1;\n    let nanoseconds = ns2 - ns1;\n    const sign = DurationSign(0, 0, 0, 0, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n    hours *= sign;\n    minutes *= sign;\n    seconds *= sign;\n    milliseconds *= sign;\n    microseconds *= sign;\n    nanoseconds *= sign;\n    let deltaDays = 0;\n    ({\n        deltaDays,\n        hour: hours,\n        minute: minutes,\n        second: seconds,\n        millisecond: milliseconds,\n        microsecond: microseconds,\n        nanosecond: nanoseconds\n    } = BalanceTime(hours, minutes, seconds, milliseconds, microseconds, nanoseconds));\n    deltaDays *= sign;\n    hours *= sign;\n    minutes *= sign;\n    seconds *= sign;\n    milliseconds *= sign;\n    microseconds *= sign;\n    nanoseconds *= sign;\n    return { deltaDays, hours, minutes, seconds, milliseconds, microseconds, nanoseconds };\n}\nfunction DifferenceInstant(ns1, ns2, increment, unit, roundingMode) {\n    const diff = jsbi__WEBPACK_IMPORTED_MODULE_0__.subtract(ns2, ns1);\n    const remainder = jsbi__WEBPACK_IMPORTED_MODULE_0__.remainder(diff, jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(86400e9));\n    const wholeDays = jsbi__WEBPACK_IMPORTED_MODULE_0__.subtract(diff, remainder);\n    const roundedRemainder = RoundNumberToIncrement(remainder, nsPerTimeUnit[unit] * increment, roundingMode);\n    const roundedDiff = jsbi__WEBPACK_IMPORTED_MODULE_0__.add(wholeDays, roundedRemainder);\n    const nanoseconds = jsbi__WEBPACK_IMPORTED_MODULE_0__.toNumber(jsbi__WEBPACK_IMPORTED_MODULE_0__.remainder(roundedDiff, THOUSAND));\n    const microseconds = jsbi__WEBPACK_IMPORTED_MODULE_0__.toNumber(jsbi__WEBPACK_IMPORTED_MODULE_0__.remainder(jsbi__WEBPACK_IMPORTED_MODULE_0__.divide(roundedDiff, THOUSAND), THOUSAND));\n    const milliseconds = jsbi__WEBPACK_IMPORTED_MODULE_0__.toNumber(jsbi__WEBPACK_IMPORTED_MODULE_0__.remainder(jsbi__WEBPACK_IMPORTED_MODULE_0__.divide(roundedDiff, MILLION), THOUSAND));\n    const seconds = jsbi__WEBPACK_IMPORTED_MODULE_0__.toNumber(jsbi__WEBPACK_IMPORTED_MODULE_0__.divide(roundedDiff, BILLION));\n    return { seconds, milliseconds, microseconds, nanoseconds };\n}\nfunction DifferenceISODateTime(y1Param, mon1Param, d1Param, h1, min1, s1, ms1, s1, ns1, y2, mon2, d2, h2, min2, s2, ms2, s2, ns2, calendar, largestUnit, options = ObjectCreate$2(null)) {\n    let y1 = y1Param;\n    let mon1 = mon1Param;\n    let d1 = d1Param;\n    let { deltaDays, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = DifferenceTime(h1, min1, s1, ms1, s1, ns1, h2, min2, s2, ms2, s2, ns2);\n    const timeSign = DurationSign(0, 0, 0, deltaDays, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n    ({ year: y1, month: mon1, day: d1 } = BalanceISODate(y1, mon1, d1 + deltaDays));\n    const dateSign = CompareISODate(y2, mon2, d2, y1, mon1, d1);\n    if (dateSign === -timeSign) {\n        ({ year: y1, month: mon1, day: d1 } = BalanceISODate(y1, mon1, d1 - timeSign));\n        ({ hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = BalanceDuration(-timeSign, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, largestUnit));\n    }\n    const date1 = CreateTemporalDate(y1, mon1, d1, calendar);\n    const date2 = CreateTemporalDate(y2, mon2, d2, calendar);\n    const dateLargestUnit = LargerOfTwoTemporalUnits('day', largestUnit);\n    const untilOptions = { ...options, largestUnit: dateLargestUnit };\n    let { years, months, weeks, days } = CalendarDateUntil(calendar, date1, date2, untilOptions);\n    // Signs of date part and time part may not agree; balance them together\n    ({ days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = BalanceDuration(days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, largestUnit));\n    return { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds };\n}\nfunction DifferenceZonedDateTime(ns1, ns2, timeZone, calendar, largestUnit, options) {\n    const nsDiff = jsbi__WEBPACK_IMPORTED_MODULE_0__.subtract(ns2, ns1);\n    if (jsbi__WEBPACK_IMPORTED_MODULE_0__.equal(nsDiff, ZERO)) {\n        return {\n            years: 0,\n            months: 0,\n            weeks: 0,\n            days: 0,\n            hours: 0,\n            minutes: 0,\n            seconds: 0,\n            milliseconds: 0,\n            microseconds: 0,\n            nanoseconds: 0\n        };\n    }\n    // Find the difference in dates only.\n    const TemporalInstant = GetIntrinsic('%Temporal.Instant%');\n    const start = new TemporalInstant(ns1);\n    const end = new TemporalInstant(ns2);\n    const dtStart = BuiltinTimeZoneGetPlainDateTimeFor(timeZone, start, calendar);\n    const dtEnd = BuiltinTimeZoneGetPlainDateTimeFor(timeZone, end, calendar);\n    let { years, months, weeks, days } = DifferenceISODateTime(GetSlot(dtStart, ISO_YEAR), GetSlot(dtStart, ISO_MONTH), GetSlot(dtStart, ISO_DAY), GetSlot(dtStart, ISO_HOUR), GetSlot(dtStart, ISO_MINUTE), GetSlot(dtStart, ISO_SECOND), GetSlot(dtStart, ISO_MILLISECOND), GetSlot(dtStart, ISO_MICROSECOND), GetSlot(dtStart, ISO_NANOSECOND), GetSlot(dtEnd, ISO_YEAR), GetSlot(dtEnd, ISO_MONTH), GetSlot(dtEnd, ISO_DAY), GetSlot(dtEnd, ISO_HOUR), GetSlot(dtEnd, ISO_MINUTE), GetSlot(dtEnd, ISO_SECOND), GetSlot(dtEnd, ISO_MILLISECOND), GetSlot(dtEnd, ISO_MICROSECOND), GetSlot(dtEnd, ISO_NANOSECOND), calendar, largestUnit, options);\n    const intermediateNs = AddZonedDateTime(start, timeZone, calendar, years, months, weeks, 0, 0, 0, 0, 0, 0, 0);\n    // may disambiguate\n    let timeRemainderNs = jsbi__WEBPACK_IMPORTED_MODULE_0__.subtract(ns2, intermediateNs);\n    const intermediate = CreateTemporalZonedDateTime(intermediateNs, timeZone, calendar);\n    ({ nanoseconds: timeRemainderNs, days } = NanosecondsToDays(timeRemainderNs, intermediate));\n    // Finally, merge the date and time durations and return the merged result.\n    const { hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = BalanceDuration(0, 0, 0, 0, 0, 0, jsbi__WEBPACK_IMPORTED_MODULE_0__.toNumber(timeRemainderNs), 'hour');\n    return { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds };\n}\nfunction AddISODate(yearParam, monthParam, dayParam, yearsParam, monthsParam, weeksParam, daysParam, overflow) {\n    let year = yearParam;\n    let month = monthParam;\n    let day = dayParam;\n    let years = yearsParam;\n    let months = monthsParam;\n    let weeks = weeksParam;\n    let days = daysParam;\n    year += years;\n    month += months;\n    ({ year, month } = BalanceISOYearMonth(year, month));\n    ({ year, month, day } = RegulateISODate(year, month, day, overflow));\n    days += 7 * weeks;\n    day += days;\n    ({ year, month, day } = BalanceISODate(year, month, day));\n    return { year, month, day };\n}\nfunction AddTime(hourParam, minuteParam, secondParam, millisecondParam, microsecondParam, nanosecondParam, hours, minutes, seconds, milliseconds, microseconds, nanoseconds) {\n    let hour = hourParam;\n    let minute = minuteParam;\n    let second = secondParam;\n    let millisecond = millisecondParam;\n    let microsecond = microsecondParam;\n    let nanosecond = nanosecondParam;\n    hour += hours;\n    minute += minutes;\n    second += seconds;\n    millisecond += milliseconds;\n    microsecond += microseconds;\n    nanosecond += nanoseconds;\n    let deltaDays = 0;\n    ({ deltaDays, hour, minute, second, millisecond, microsecond, nanosecond } = BalanceTime(hour, minute, second, millisecond, microsecond, nanosecond));\n    return { deltaDays, hour, minute, second, millisecond, microsecond, nanosecond };\n}\nfunction AddDuration(y1, mon1, w1, d1, h1, min1, s1, ms1, s1, ns1, y2, mon2, w2, d2, h2, min2, s2, ms2, s2, ns2, relativeTo) {\n    const largestUnit1 = DefaultTemporalLargestUnit(y1, mon1, w1, d1, h1, min1, s1, ms1, s1, ns1);\n    const largestUnit2 = DefaultTemporalLargestUnit(y2, mon2, w2, d2, h2, min2, s2, ms2, s2, ns2);\n    const largestUnit = LargerOfTwoTemporalUnits(largestUnit1, largestUnit2);\n    let years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds;\n    if (!relativeTo) {\n        if (largestUnit === 'year' || largestUnit === 'month' || largestUnit === 'week') {\n            throw new RangeError('relativeTo is required for years, months, or weeks arithmetic');\n        }\n        years = months = weeks = 0;\n        ({ days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = BalanceDuration(d1 + d2, h1 + h2, min1 + min2, s1 + s2, ms1 + ms2, s1 + s2, ns1 + ns2, largestUnit));\n    }\n    else if (IsTemporalDate(relativeTo)) {\n        const TemporalDuration = GetIntrinsic('%Temporal.Duration%');\n        const calendar = GetSlot(relativeTo, CALENDAR);\n        const dateDuration1 = new TemporalDuration(y1, mon1, w1, d1, 0, 0, 0, 0, 0, 0);\n        const dateDuration2 = new TemporalDuration(y2, mon2, w2, d2, 0, 0, 0, 0, 0, 0);\n        const dateAdd = calendar.dateAdd;\n        const firstAddOptions = ObjectCreate$2(null);\n        const intermediate = CalendarDateAdd(calendar, relativeTo, dateDuration1, firstAddOptions, dateAdd);\n        const secondAddOptions = ObjectCreate$2(null);\n        const end = CalendarDateAdd(calendar, intermediate, dateDuration2, secondAddOptions, dateAdd);\n        const dateLargestUnit = LargerOfTwoTemporalUnits('day', largestUnit);\n        const differenceOptions = ObjectCreate$2(null);\n        differenceOptions.largestUnit = dateLargestUnit;\n        ({ years, months, weeks, days } = CalendarDateUntil(calendar, relativeTo, end, differenceOptions));\n        // Signs of date part and time part may not agree; balance them together\n        ({ days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = BalanceDuration(days, h1 + h2, min1 + min2, s1 + s2, ms1 + ms2, s1 + s2, ns1 + ns2, largestUnit));\n    }\n    else {\n        // relativeTo is a ZonedDateTime\n        const TemporalInstant = GetIntrinsic('%Temporal.Instant%');\n        const timeZone = GetSlot(relativeTo, TIME_ZONE);\n        const calendar = GetSlot(relativeTo, CALENDAR);\n        const intermediateNs = AddZonedDateTime(GetSlot(relativeTo, INSTANT), timeZone, calendar, y1, mon1, w1, d1, h1, min1, s1, ms1, s1, ns1);\n        const endNs = AddZonedDateTime(new TemporalInstant(intermediateNs), timeZone, calendar, y2, mon2, w2, d2, h2, min2, s2, ms2, s2, ns2);\n        if (largestUnit !== 'year' && largestUnit !== 'month' && largestUnit !== 'week' && largestUnit !== 'day') {\n            // The user is only asking for a time difference, so return difference of instants.\n            years = 0;\n            months = 0;\n            weeks = 0;\n            days = 0;\n            ({ seconds, milliseconds, microseconds, nanoseconds } = DifferenceInstant(GetSlot(relativeTo, EPOCHNANOSECONDS), endNs, 1, 'nanosecond', 'halfExpand'));\n            ({ hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = BalanceDuration(0, 0, 0, seconds, milliseconds, microseconds, nanoseconds, largestUnit));\n        }\n        else {\n            ({ years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } =\n                DifferenceZonedDateTime(GetSlot(relativeTo, EPOCHNANOSECONDS), endNs, timeZone, calendar, largestUnit));\n        }\n    }\n    RejectDuration(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n    return { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds };\n}\nfunction AddInstant(epochNanoseconds, h, min, s, ms, s, ns) {\n    let sum = ZERO;\n    sum = jsbi__WEBPACK_IMPORTED_MODULE_0__.add(sum, jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(ns));\n    sum = jsbi__WEBPACK_IMPORTED_MODULE_0__.add(sum, jsbi__WEBPACK_IMPORTED_MODULE_0__.multiply(jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(s), THOUSAND));\n    sum = jsbi__WEBPACK_IMPORTED_MODULE_0__.add(sum, jsbi__WEBPACK_IMPORTED_MODULE_0__.multiply(jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(ms), MILLION));\n    sum = jsbi__WEBPACK_IMPORTED_MODULE_0__.add(sum, jsbi__WEBPACK_IMPORTED_MODULE_0__.multiply(jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(s), BILLION));\n    sum = jsbi__WEBPACK_IMPORTED_MODULE_0__.add(sum, jsbi__WEBPACK_IMPORTED_MODULE_0__.multiply(jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(min), jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(60 * 1e9)));\n    sum = jsbi__WEBPACK_IMPORTED_MODULE_0__.add(sum, jsbi__WEBPACK_IMPORTED_MODULE_0__.multiply(jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(h), jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(60 * 60 * 1e9)));\n    const result = jsbi__WEBPACK_IMPORTED_MODULE_0__.add(epochNanoseconds, sum);\n    ValidateEpochNanoseconds(result);\n    return result;\n}\nfunction AddDateTime(year, month, day, hourParam, minuteParam, secondParam, millisecondParam, microsecondParam, nanosecondParam, calendar, years, months, weeks, daysParam, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, options) {\n    let days = daysParam;\n    // Add the time part\n    let { deltaDays, hour, minute, second, millisecond, microsecond, nanosecond } = AddTime(hourParam, minuteParam, secondParam, millisecondParam, microsecondParam, nanosecondParam, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n    days += deltaDays;\n    // Delegate the date part addition to the calendar\n    const TemporalDuration = GetIntrinsic('%Temporal.Duration%');\n    const datePart = CreateTemporalDate(year, month, day, calendar);\n    const dateDuration = new TemporalDuration(years, months, weeks, days, 0, 0, 0, 0, 0, 0);\n    const addedDate = CalendarDateAdd(calendar, datePart, dateDuration, options);\n    return {\n        year: GetSlot(addedDate, ISO_YEAR),\n        month: GetSlot(addedDate, ISO_MONTH),\n        day: GetSlot(addedDate, ISO_DAY),\n        hour,\n        minute,\n        second,\n        millisecond,\n        microsecond,\n        nanosecond\n    };\n}\nfunction AddZonedDateTime(instant, timeZone, calendar, years, months, weeks, days, h, min, s, ms, s, ns, options) {\n    // If only time is to be added, then use Instant math. It's not OK to fall\n    // through to the date/time code below because compatible disambiguation in\n    // the PlainDateTime=>Instant conversion will change the offset of any\n    // ZonedDateTime in the repeated clock time after a backwards transition.\n    // When adding/subtracting time units and not dates, this disambiguation is\n    // not expected and so is avoided below via a fast path for time-only\n    // arithmetic.\n    // BTW, this behavior is similar in spirit to offset: 'prefer' in `with`.\n    const TemporalDuration = GetIntrinsic('%Temporal.Duration%');\n    if (DurationSign(years, months, weeks, days, 0, 0, 0, 0, 0, 0) === 0) {\n        return AddInstant(GetSlot(instant, EPOCHNANOSECONDS), h, min, s, ms, s, ns);\n    }\n    // RFC 5545 requires the date portion to be added in calendar days and the\n    // time portion to be added in exact time.\n    const dt = BuiltinTimeZoneGetPlainDateTimeFor(timeZone, instant, calendar);\n    const datePart = CreateTemporalDate(GetSlot(dt, ISO_YEAR), GetSlot(dt, ISO_MONTH), GetSlot(dt, ISO_DAY), calendar);\n    const dateDuration = new TemporalDuration(years, months, weeks, days, 0, 0, 0, 0, 0, 0);\n    const addedDate = CalendarDateAdd(calendar, datePart, dateDuration, options);\n    const dtIntermediate = CreateTemporalDateTime(GetSlot(addedDate, ISO_YEAR), GetSlot(addedDate, ISO_MONTH), GetSlot(addedDate, ISO_DAY), GetSlot(dt, ISO_HOUR), GetSlot(dt, ISO_MINUTE), GetSlot(dt, ISO_SECOND), GetSlot(dt, ISO_MILLISECOND), GetSlot(dt, ISO_MICROSECOND), GetSlot(dt, ISO_NANOSECOND), calendar);\n    // Note that 'compatible' is used below because this disambiguation behavior\n    // is required by RFC 5545.\n    const instantIntermediate = BuiltinTimeZoneGetInstantFor(timeZone, dtIntermediate, 'compatible');\n    return AddInstant(GetSlot(instantIntermediate, EPOCHNANOSECONDS), h, min, s, ms, s, ns);\n}\nfunction RoundNumberToIncrement(quantity, increment, mode) {\n    if (increment === 1)\n        return quantity;\n    let { quotient, remainder } = divmod(quantity, jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(increment));\n    if (jsbi__WEBPACK_IMPORTED_MODULE_0__.equal(remainder, ZERO))\n        return quantity;\n    const sign = jsbi__WEBPACK_IMPORTED_MODULE_0__.lessThan(remainder, ZERO) ? -1 : 1;\n    switch (mode) {\n        case 'ceil':\n            if (sign > 0)\n                quotient = jsbi__WEBPACK_IMPORTED_MODULE_0__.add(quotient, jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(sign));\n            break;\n        case 'floor':\n            if (sign < 0)\n                quotient = jsbi__WEBPACK_IMPORTED_MODULE_0__.add(quotient, jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(sign));\n            break;\n        case 'trunc':\n            // no change needed, because divmod is a truncation\n            break;\n        case 'halfExpand':\n            // \"half up away from zero\"\n            if (jsbi__WEBPACK_IMPORTED_MODULE_0__.toNumber(abs(jsbi__WEBPACK_IMPORTED_MODULE_0__.multiply(remainder, jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(2)))) >= increment) {\n                quotient = jsbi__WEBPACK_IMPORTED_MODULE_0__.add(quotient, jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(sign));\n            }\n            break;\n    }\n    return jsbi__WEBPACK_IMPORTED_MODULE_0__.multiply(quotient, jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(increment));\n}\nfunction RoundInstant(epochNs, increment, unit, roundingMode) {\n    // Note: NonNegativeModulo, but with BigInt\n    let remainder = jsbi__WEBPACK_IMPORTED_MODULE_0__.remainder(epochNs, jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(86400e9));\n    if (jsbi__WEBPACK_IMPORTED_MODULE_0__.lessThan(remainder, ZERO))\n        remainder = jsbi__WEBPACK_IMPORTED_MODULE_0__.add(remainder, jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(86400e9));\n    const wholeDays = jsbi__WEBPACK_IMPORTED_MODULE_0__.subtract(epochNs, remainder);\n    const roundedRemainder = RoundNumberToIncrement(remainder, nsPerTimeUnit[unit] * increment, roundingMode);\n    return jsbi__WEBPACK_IMPORTED_MODULE_0__.add(wholeDays, roundedRemainder);\n}\nfunction RoundISODateTime(yearParam, monthParam, dayParam, hourParam, minuteParam, secondParam, millisecondParam, microsecondParam, nanosecondParam, increment, unit, roundingMode, dayLengthNs = 86400e9) {\n    const { deltaDays, hour, minute, second, millisecond, microsecond, nanosecond } = RoundTime(hourParam, minuteParam, secondParam, millisecondParam, microsecondParam, nanosecondParam, increment, unit, roundingMode, dayLengthNs);\n    const { year, month, day } = BalanceISODate(yearParam, monthParam, dayParam + deltaDays);\n    return { year, month, day, hour, minute, second, millisecond, microsecond, nanosecond };\n}\nfunction RoundTime(hour, minute, second, millisecond, microsecond, nanosecond, increment, unit, roundingMode, dayLengthNs = 86400e9) {\n    let quantity = ZERO;\n    switch (unit) {\n        case 'day':\n        case 'hour':\n            quantity = jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(hour);\n        // fall through\n        case 'minute':\n            quantity = jsbi__WEBPACK_IMPORTED_MODULE_0__.add(jsbi__WEBPACK_IMPORTED_MODULE_0__.multiply(quantity, SIXTY), jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(minute));\n        // fall through\n        case 'second':\n            quantity = jsbi__WEBPACK_IMPORTED_MODULE_0__.add(jsbi__WEBPACK_IMPORTED_MODULE_0__.multiply(quantity, SIXTY), jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(second));\n        // fall through\n        case 'millisecond':\n            quantity = jsbi__WEBPACK_IMPORTED_MODULE_0__.add(jsbi__WEBPACK_IMPORTED_MODULE_0__.multiply(quantity, THOUSAND), jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(millisecond));\n        // fall through\n        case 'microsecond':\n            quantity = jsbi__WEBPACK_IMPORTED_MODULE_0__.add(jsbi__WEBPACK_IMPORTED_MODULE_0__.multiply(quantity, THOUSAND), jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(microsecond));\n        // fall through\n        case 'nanosecond':\n            quantity = jsbi__WEBPACK_IMPORTED_MODULE_0__.add(jsbi__WEBPACK_IMPORTED_MODULE_0__.multiply(quantity, THOUSAND), jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(nanosecond));\n    }\n    const nsPerUnit = unit === 'day' ? dayLengthNs : nsPerTimeUnit[unit];\n    const rounded = RoundNumberToIncrement(quantity, nsPerUnit * increment, roundingMode);\n    const result = jsbi__WEBPACK_IMPORTED_MODULE_0__.toNumber(jsbi__WEBPACK_IMPORTED_MODULE_0__.divide(rounded, jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(nsPerUnit)));\n    switch (unit) {\n        case 'day':\n            return { deltaDays: result, hour: 0, minute: 0, second: 0, millisecond: 0, microsecond: 0, nanosecond: 0 };\n        case 'hour':\n            return BalanceTime(result, 0, 0, 0, 0, 0);\n        case 'minute':\n            return BalanceTime(hour, result, 0, 0, 0, 0);\n        case 'second':\n            return BalanceTime(hour, minute, result, 0, 0, 0);\n        case 'millisecond':\n            return BalanceTime(hour, minute, second, result, 0, 0);\n        case 'microsecond':\n            return BalanceTime(hour, minute, second, millisecond, result, 0);\n        case 'nanosecond':\n            return BalanceTime(hour, minute, second, millisecond, microsecond, result);\n        default:\n            throw new Error(`Invalid unit ${unit}`);\n    }\n}\nfunction DaysUntil(earlier, later) {\n    return DifferenceISODate(GetSlot(earlier, ISO_YEAR), GetSlot(earlier, ISO_MONTH), GetSlot(earlier, ISO_DAY), GetSlot(later, ISO_YEAR), GetSlot(later, ISO_MONTH), GetSlot(later, ISO_DAY), 'day').days;\n}\nfunction MoveRelativeDate(calendar, relativeToParam, duration) {\n    const options = ObjectCreate$2(null);\n    const later = CalendarDateAdd(calendar, relativeToParam, duration, options);\n    const days = DaysUntil(relativeToParam, later);\n    return { relativeTo: later, days };\n}\nfunction MoveRelativeZonedDateTime(relativeTo, years, months, weeks, days) {\n    const timeZone = GetSlot(relativeTo, TIME_ZONE);\n    const calendar = GetSlot(relativeTo, CALENDAR);\n    const intermediateNs = AddZonedDateTime(GetSlot(relativeTo, INSTANT), timeZone, calendar, years, months, weeks, days, 0, 0, 0, 0, 0, 0);\n    return CreateTemporalZonedDateTime(intermediateNs, timeZone, calendar);\n}\nfunction AdjustRoundedDurationDays(yearsParam, monthsParam, weeksParam, daysParam, hoursParam, minutesParam, secondsParam, millisecondsParam, microsecondsParam, nanosecondsParam, increment, unit, roundingMode, relativeTo) {\n    let years = yearsParam;\n    let months = monthsParam;\n    let weeks = weeksParam;\n    let days = daysParam;\n    let hours = hoursParam;\n    let minutes = minutesParam;\n    let seconds = secondsParam;\n    let milliseconds = millisecondsParam;\n    let microseconds = microsecondsParam;\n    let nanoseconds = nanosecondsParam;\n    if (!IsTemporalZonedDateTime(relativeTo) ||\n        unit === 'year' ||\n        unit === 'month' ||\n        unit === 'week' ||\n        unit === 'day' ||\n        (unit === 'nanosecond' && increment === 1)) {\n        return { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds };\n    }\n    // There's one more round of rounding possible: if relativeTo is a\n    // ZonedDateTime, the time units could have rounded up into enough hours\n    // to exceed the day length. If this happens, grow the date part by a\n    // single day and re-run exact time rounding on the smaller remainder. DO\n    // NOT RECURSE, because once the extra hours are sucked up into the date\n    // duration, there's no way for another full day to come from the next\n    // round of rounding. And if it were possible (e.g. contrived calendar\n    // with 30-minute-long \"days\") then it'd risk an infinite loop.\n    let timeRemainderNs = TotalDurationNanoseconds(0, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, 0);\n    const direction = MathSign(jsbi__WEBPACK_IMPORTED_MODULE_0__.toNumber(timeRemainderNs));\n    const timeZone = GetSlot(relativeTo, TIME_ZONE);\n    const calendar = GetSlot(relativeTo, CALENDAR);\n    const dayStart = AddZonedDateTime(GetSlot(relativeTo, INSTANT), timeZone, calendar, years, months, weeks, days, 0, 0, 0, 0, 0, 0);\n    const TemporalInstant = GetIntrinsic('%Temporal.Instant%');\n    const dayEnd = AddZonedDateTime(new TemporalInstant(dayStart), timeZone, calendar, 0, 0, 0, direction, 0, 0, 0, 0, 0, 0);\n    const dayLengthNs = jsbi__WEBPACK_IMPORTED_MODULE_0__.subtract(dayEnd, dayStart);\n    if (jsbi__WEBPACK_IMPORTED_MODULE_0__.greaterThanOrEqual(jsbi__WEBPACK_IMPORTED_MODULE_0__.multiply(jsbi__WEBPACK_IMPORTED_MODULE_0__.subtract(timeRemainderNs, dayLengthNs), jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(direction)), ZERO)) {\n        ({ years, months, weeks, days } = AddDuration(years, months, weeks, days, 0, 0, 0, 0, 0, 0, 0, 0, 0, direction, 0, 0, 0, 0, 0, 0, relativeTo));\n        timeRemainderNs = RoundInstant(jsbi__WEBPACK_IMPORTED_MODULE_0__.subtract(timeRemainderNs, dayLengthNs), increment, unit, roundingMode);\n        ({ hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = BalanceDuration(0, 0, 0, 0, 0, 0, jsbi__WEBPACK_IMPORTED_MODULE_0__.toNumber(timeRemainderNs), 'hour'));\n    }\n    return { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds };\n}\nfunction RoundDuration(yearsParam, monthsParam, weeksParam, daysParam, hoursParam, minutesParam, secondsParam, millisecondsParam, microsecondsParam, nanosecondsParam, increment, unit, roundingMode, relativeToParam = undefined) {\n    let years = yearsParam;\n    let months = monthsParam;\n    let weeks = weeksParam;\n    let days = daysParam;\n    let hours = hoursParam;\n    let minutes = minutesParam;\n    let seconds = secondsParam;\n    let milliseconds = millisecondsParam;\n    let microseconds = microsecondsParam;\n    let nanoseconds = jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(nanosecondsParam);\n    const TemporalDuration = GetIntrinsic('%Temporal.Duration%');\n    let calendar, zdtRelative;\n    // A cast is used below because relativeTo will be either PlainDate or\n    // undefined for the rest of this long method (after any ZDT=>PlainDate\n    // conversion below), and TS isn't smart enough to know that the type has\n    // changed. See https://github.com/microsoft/TypeScript/issues/27706.\n    let relativeTo = relativeToParam;\n    if (relativeTo) {\n        if (IsTemporalZonedDateTime(relativeTo)) {\n            zdtRelative = relativeTo;\n            relativeTo = ToTemporalDate(relativeTo);\n        }\n        else if (!IsTemporalDate(relativeTo)) {\n            throw new TypeError('starting point must be PlainDate or ZonedDateTime');\n        }\n        calendar = GetSlot(relativeTo, CALENDAR);\n    }\n    // First convert time units up to days, if rounding to days or higher units.\n    // If rounding relative to a ZonedDateTime, then some days may not be 24h.\n    // TS doesn't know that `dayLengthNs` is only used if the unit is day or\n    // larger. We'll cast away `undefined` when it's used lower down below.\n    let dayLengthNs;\n    if (unit === 'year' || unit === 'month' || unit === 'week' || unit === 'day') {\n        nanoseconds = TotalDurationNanoseconds(0, hours, minutes, seconds, milliseconds, microseconds, nanosecondsParam, 0);\n        let intermediate;\n        if (zdtRelative) {\n            intermediate = MoveRelativeZonedDateTime(zdtRelative, years, months, weeks, days);\n        }\n        let deltaDays;\n        let dayLength;\n        ({ days: deltaDays, nanoseconds, dayLengthNs: dayLength } = NanosecondsToDays(nanoseconds, intermediate));\n        dayLengthNs = jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(dayLength);\n        days += deltaDays;\n        hours = minutes = seconds = milliseconds = microseconds = 0;\n    }\n    let total;\n    switch (unit) {\n        case 'year': {\n            if (!calendar)\n                throw new RangeError('A starting point is required for years rounding');\n            // convert months and weeks to days by calculating difference(\n            // relativeTo + years, relativeTo + { years, months, weeks })\n            const yearsDuration = new TemporalDuration(years);\n            const dateAdd = calendar.dateAdd;\n            const firstAddOptions = ObjectCreate$2(null);\n            const yearsLater = CalendarDateAdd(calendar, relativeTo, yearsDuration, firstAddOptions, dateAdd);\n            const yearsMonthsWeeks = new TemporalDuration(years, months, weeks);\n            const secondAddOptions = ObjectCreate$2(null);\n            const yearsMonthsWeeksLater = CalendarDateAdd(calendar, relativeTo, yearsMonthsWeeks, secondAddOptions, dateAdd);\n            const monthsWeeksInDays = DaysUntil(yearsLater, yearsMonthsWeeksLater);\n            relativeTo = yearsLater;\n            days += monthsWeeksInDays;\n            const thirdAddOptions = ObjectCreate$2(null);\n            const daysLater = CalendarDateAdd(calendar, relativeTo, { days }, thirdAddOptions, dateAdd);\n            const untilOptions = ObjectCreate$2(null);\n            untilOptions.largestUnit = 'year';\n            const yearsPassed = CalendarDateUntil(calendar, relativeTo, daysLater, untilOptions).years;\n            years += yearsPassed;\n            const oldRelativeTo = relativeTo;\n            const fourthAddOptions = ObjectCreate$2(null);\n            relativeTo = CalendarDateAdd(calendar, relativeTo, { years: yearsPassed }, fourthAddOptions, dateAdd);\n            const daysPassed = DaysUntil(oldRelativeTo, relativeTo);\n            days -= daysPassed;\n            const oneYear = new TemporalDuration(days < 0 ? -1 : 1);\n            let { days: oneYearDays } = MoveRelativeDate(calendar, relativeTo, oneYear);\n            // Note that `nanoseconds` below (here and in similar code for months,\n            // weeks, and days further below) isn't actually nanoseconds for the\n            // full date range.  Instead, it's a BigInt representation of total\n            // days multiplied by the number of nanoseconds in the last day of\n            // the duration. This lets us do days-or-larger rounding using BigInt\n            // math which reduces precision loss.\n            oneYearDays = MathAbs(oneYearDays);\n            // dayLengthNs is never undefined if unit is `day` or larger.\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            const divisor = jsbi__WEBPACK_IMPORTED_MODULE_0__.multiply(jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(oneYearDays), dayLengthNs);\n            nanoseconds = jsbi__WEBPACK_IMPORTED_MODULE_0__.add(\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            jsbi__WEBPACK_IMPORTED_MODULE_0__.add(jsbi__WEBPACK_IMPORTED_MODULE_0__.multiply(divisor, jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(years)), jsbi__WEBPACK_IMPORTED_MODULE_0__.multiply(jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(days), dayLengthNs)), nanoseconds);\n            const rounded = RoundNumberToIncrement(nanoseconds, jsbi__WEBPACK_IMPORTED_MODULE_0__.toNumber(jsbi__WEBPACK_IMPORTED_MODULE_0__.multiply(divisor, jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(increment))), roundingMode);\n            total = jsbi__WEBPACK_IMPORTED_MODULE_0__.toNumber(nanoseconds) / jsbi__WEBPACK_IMPORTED_MODULE_0__.toNumber(divisor);\n            years = jsbi__WEBPACK_IMPORTED_MODULE_0__.toNumber(jsbi__WEBPACK_IMPORTED_MODULE_0__.divide(rounded, divisor));\n            nanoseconds = ZERO;\n            months = weeks = days = 0;\n            break;\n        }\n        case 'month': {\n            if (!calendar)\n                throw new RangeError('A starting point is required for months rounding');\n            // convert weeks to days by calculating difference(relativeTo +\n            //   { years, months }, relativeTo + { years, months, weeks })\n            const yearsMonths = new TemporalDuration(years, months);\n            const dateAdd = calendar.dateAdd;\n            const firstAddOptions = ObjectCreate$2(null);\n            const yearsMonthsLater = CalendarDateAdd(calendar, relativeTo, yearsMonths, firstAddOptions, dateAdd);\n            const yearsMonthsWeeks = new TemporalDuration(years, months, weeks);\n            const secondAddOptions = ObjectCreate$2(null);\n            const yearsMonthsWeeksLater = CalendarDateAdd(calendar, relativeTo, yearsMonthsWeeks, secondAddOptions, dateAdd);\n            const weeksInDays = DaysUntil(yearsMonthsLater, yearsMonthsWeeksLater);\n            relativeTo = yearsMonthsLater;\n            days += weeksInDays;\n            // Months may be different lengths of days depending on the calendar,\n            // convert days to months in a loop as described above under 'years'.\n            const sign = MathSign(days);\n            const oneMonth = new TemporalDuration(0, days < 0 ? -1 : 1);\n            let oneMonthDays;\n            ({ relativeTo, days: oneMonthDays } = MoveRelativeDate(calendar, relativeTo, oneMonth));\n            while (MathAbs(days) >= MathAbs(oneMonthDays)) {\n                months += sign;\n                days -= oneMonthDays;\n                ({ relativeTo, days: oneMonthDays } = MoveRelativeDate(calendar, relativeTo, oneMonth));\n            }\n            oneMonthDays = MathAbs(oneMonthDays);\n            // dayLengthNs is never undefined if unit is `day` or larger.\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            const divisor = jsbi__WEBPACK_IMPORTED_MODULE_0__.multiply(jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(oneMonthDays), dayLengthNs);\n            nanoseconds = jsbi__WEBPACK_IMPORTED_MODULE_0__.add(\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            jsbi__WEBPACK_IMPORTED_MODULE_0__.add(jsbi__WEBPACK_IMPORTED_MODULE_0__.multiply(divisor, jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(months)), jsbi__WEBPACK_IMPORTED_MODULE_0__.multiply(jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(days), dayLengthNs)), nanoseconds);\n            const rounded = RoundNumberToIncrement(nanoseconds, jsbi__WEBPACK_IMPORTED_MODULE_0__.toNumber(jsbi__WEBPACK_IMPORTED_MODULE_0__.multiply(divisor, jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(increment))), roundingMode);\n            total = jsbi__WEBPACK_IMPORTED_MODULE_0__.toNumber(nanoseconds) / jsbi__WEBPACK_IMPORTED_MODULE_0__.toNumber(divisor);\n            months = jsbi__WEBPACK_IMPORTED_MODULE_0__.toNumber(jsbi__WEBPACK_IMPORTED_MODULE_0__.divide(rounded, divisor));\n            nanoseconds = ZERO;\n            weeks = days = 0;\n            break;\n        }\n        case 'week': {\n            if (!calendar)\n                throw new RangeError('A starting point is required for weeks rounding');\n            // Weeks may be different lengths of days depending on the calendar,\n            // convert days to weeks in a loop as described above under 'years'.\n            const sign = MathSign(days);\n            const oneWeek = new TemporalDuration(0, 0, days < 0 ? -1 : 1);\n            let oneWeekDays;\n            ({ relativeTo, days: oneWeekDays } = MoveRelativeDate(calendar, relativeTo, oneWeek));\n            while (MathAbs(days) >= MathAbs(oneWeekDays)) {\n                weeks += sign;\n                days -= oneWeekDays;\n                ({ relativeTo, days: oneWeekDays } = MoveRelativeDate(calendar, relativeTo, oneWeek));\n            }\n            oneWeekDays = MathAbs(oneWeekDays);\n            // dayLengthNs is never undefined if unit is `day` or larger.\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            const divisor = jsbi__WEBPACK_IMPORTED_MODULE_0__.multiply(jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(oneWeekDays), dayLengthNs);\n            nanoseconds = jsbi__WEBPACK_IMPORTED_MODULE_0__.add(\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            jsbi__WEBPACK_IMPORTED_MODULE_0__.add(jsbi__WEBPACK_IMPORTED_MODULE_0__.multiply(divisor, jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(weeks)), jsbi__WEBPACK_IMPORTED_MODULE_0__.multiply(jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(days), dayLengthNs)), nanoseconds);\n            const rounded = RoundNumberToIncrement(nanoseconds, jsbi__WEBPACK_IMPORTED_MODULE_0__.toNumber(jsbi__WEBPACK_IMPORTED_MODULE_0__.multiply(divisor, jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(increment))), roundingMode);\n            total = jsbi__WEBPACK_IMPORTED_MODULE_0__.toNumber(nanoseconds) / jsbi__WEBPACK_IMPORTED_MODULE_0__.toNumber(divisor);\n            weeks = jsbi__WEBPACK_IMPORTED_MODULE_0__.toNumber(jsbi__WEBPACK_IMPORTED_MODULE_0__.divide(rounded, divisor));\n            nanoseconds = ZERO;\n            days = 0;\n            break;\n        }\n        case 'day': {\n            // dayLengthNs is never undefined if unit is `day` or larger.\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            const divisor = dayLengthNs;\n            nanoseconds = jsbi__WEBPACK_IMPORTED_MODULE_0__.add(jsbi__WEBPACK_IMPORTED_MODULE_0__.multiply(divisor, jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(days)), nanoseconds);\n            const rounded = RoundNumberToIncrement(nanoseconds, jsbi__WEBPACK_IMPORTED_MODULE_0__.toNumber(jsbi__WEBPACK_IMPORTED_MODULE_0__.multiply(divisor, jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(increment))), roundingMode);\n            total = jsbi__WEBPACK_IMPORTED_MODULE_0__.toNumber(nanoseconds) / jsbi__WEBPACK_IMPORTED_MODULE_0__.toNumber(divisor);\n            days = jsbi__WEBPACK_IMPORTED_MODULE_0__.toNumber(jsbi__WEBPACK_IMPORTED_MODULE_0__.divide(rounded, divisor));\n            nanoseconds = ZERO;\n            break;\n        }\n        case 'hour': {\n            const divisor = 3600e9;\n            let allNanoseconds = jsbi__WEBPACK_IMPORTED_MODULE_0__.multiply(jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(hours), jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(3600e9));\n            allNanoseconds = jsbi__WEBPACK_IMPORTED_MODULE_0__.add(allNanoseconds, jsbi__WEBPACK_IMPORTED_MODULE_0__.multiply(jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(minutes), jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(60e9)));\n            allNanoseconds = jsbi__WEBPACK_IMPORTED_MODULE_0__.add(allNanoseconds, jsbi__WEBPACK_IMPORTED_MODULE_0__.multiply(jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(seconds), BILLION));\n            allNanoseconds = jsbi__WEBPACK_IMPORTED_MODULE_0__.add(allNanoseconds, jsbi__WEBPACK_IMPORTED_MODULE_0__.multiply(jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(milliseconds), MILLION));\n            allNanoseconds = jsbi__WEBPACK_IMPORTED_MODULE_0__.add(allNanoseconds, jsbi__WEBPACK_IMPORTED_MODULE_0__.multiply(jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(microseconds), THOUSAND));\n            allNanoseconds = jsbi__WEBPACK_IMPORTED_MODULE_0__.add(allNanoseconds, nanoseconds);\n            total = jsbi__WEBPACK_IMPORTED_MODULE_0__.toNumber(allNanoseconds) / divisor;\n            const rounded = RoundNumberToIncrement(allNanoseconds, divisor * increment, roundingMode);\n            hours = jsbi__WEBPACK_IMPORTED_MODULE_0__.toNumber(jsbi__WEBPACK_IMPORTED_MODULE_0__.divide(rounded, jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(divisor)));\n            nanoseconds = ZERO;\n            minutes = seconds = milliseconds = microseconds = 0;\n            break;\n        }\n        case 'minute': {\n            const divisor = 60e9;\n            let allNanoseconds = jsbi__WEBPACK_IMPORTED_MODULE_0__.multiply(jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(minutes), jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(60e9));\n            allNanoseconds = jsbi__WEBPACK_IMPORTED_MODULE_0__.add(allNanoseconds, jsbi__WEBPACK_IMPORTED_MODULE_0__.multiply(jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(seconds), BILLION));\n            allNanoseconds = jsbi__WEBPACK_IMPORTED_MODULE_0__.add(allNanoseconds, jsbi__WEBPACK_IMPORTED_MODULE_0__.multiply(jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(milliseconds), MILLION));\n            allNanoseconds = jsbi__WEBPACK_IMPORTED_MODULE_0__.add(allNanoseconds, jsbi__WEBPACK_IMPORTED_MODULE_0__.multiply(jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(microseconds), THOUSAND));\n            allNanoseconds = jsbi__WEBPACK_IMPORTED_MODULE_0__.add(allNanoseconds, nanoseconds);\n            total = jsbi__WEBPACK_IMPORTED_MODULE_0__.toNumber(allNanoseconds) / divisor;\n            const rounded = RoundNumberToIncrement(allNanoseconds, divisor * increment, roundingMode);\n            minutes = jsbi__WEBPACK_IMPORTED_MODULE_0__.toNumber(jsbi__WEBPACK_IMPORTED_MODULE_0__.divide(rounded, jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(divisor)));\n            nanoseconds = ZERO;\n            seconds = milliseconds = microseconds = 0;\n            break;\n        }\n        case 'second': {\n            const divisor = 1e9;\n            let allNanoseconds = jsbi__WEBPACK_IMPORTED_MODULE_0__.multiply(jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(seconds), BILLION);\n            allNanoseconds = jsbi__WEBPACK_IMPORTED_MODULE_0__.add(allNanoseconds, jsbi__WEBPACK_IMPORTED_MODULE_0__.multiply(jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(milliseconds), MILLION));\n            allNanoseconds = jsbi__WEBPACK_IMPORTED_MODULE_0__.add(allNanoseconds, jsbi__WEBPACK_IMPORTED_MODULE_0__.multiply(jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(microseconds), THOUSAND));\n            allNanoseconds = jsbi__WEBPACK_IMPORTED_MODULE_0__.add(allNanoseconds, nanoseconds);\n            total = jsbi__WEBPACK_IMPORTED_MODULE_0__.toNumber(allNanoseconds) / divisor;\n            const rounded = RoundNumberToIncrement(allNanoseconds, divisor * increment, roundingMode);\n            seconds = jsbi__WEBPACK_IMPORTED_MODULE_0__.toNumber(jsbi__WEBPACK_IMPORTED_MODULE_0__.divide(rounded, jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(divisor)));\n            nanoseconds = ZERO;\n            milliseconds = microseconds = 0;\n            break;\n        }\n        case 'millisecond': {\n            const divisor = 1e6;\n            let allNanoseconds = jsbi__WEBPACK_IMPORTED_MODULE_0__.multiply(jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(milliseconds), MILLION);\n            allNanoseconds = jsbi__WEBPACK_IMPORTED_MODULE_0__.add(allNanoseconds, jsbi__WEBPACK_IMPORTED_MODULE_0__.multiply(jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(microseconds), THOUSAND));\n            allNanoseconds = jsbi__WEBPACK_IMPORTED_MODULE_0__.add(allNanoseconds, nanoseconds);\n            total = jsbi__WEBPACK_IMPORTED_MODULE_0__.toNumber(allNanoseconds) / divisor;\n            const rounded = RoundNumberToIncrement(allNanoseconds, divisor * increment, roundingMode);\n            milliseconds = jsbi__WEBPACK_IMPORTED_MODULE_0__.toNumber(jsbi__WEBPACK_IMPORTED_MODULE_0__.divide(rounded, jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(divisor)));\n            nanoseconds = ZERO;\n            microseconds = 0;\n            break;\n        }\n        case 'microsecond': {\n            const divisor = 1e3;\n            let allNanoseconds = jsbi__WEBPACK_IMPORTED_MODULE_0__.multiply(jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(microseconds), THOUSAND);\n            allNanoseconds = jsbi__WEBPACK_IMPORTED_MODULE_0__.add(allNanoseconds, nanoseconds);\n            total = jsbi__WEBPACK_IMPORTED_MODULE_0__.toNumber(allNanoseconds) / divisor;\n            const rounded = RoundNumberToIncrement(allNanoseconds, divisor * increment, roundingMode);\n            microseconds = jsbi__WEBPACK_IMPORTED_MODULE_0__.toNumber(jsbi__WEBPACK_IMPORTED_MODULE_0__.divide(rounded, jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(divisor)));\n            nanoseconds = ZERO;\n            break;\n        }\n        case 'nanosecond': {\n            total = jsbi__WEBPACK_IMPORTED_MODULE_0__.toNumber(nanoseconds);\n            nanoseconds = RoundNumberToIncrement(nanoseconds, increment, roundingMode);\n            break;\n        }\n    }\n    return {\n        years,\n        months,\n        weeks,\n        days,\n        hours,\n        minutes,\n        seconds,\n        milliseconds,\n        microseconds,\n        nanoseconds: jsbi__WEBPACK_IMPORTED_MODULE_0__.toNumber(nanoseconds),\n        total\n    };\n}\nfunction CompareISODate(y1, m1, d1, y2, m2, d2) {\n    for (const [x, y] of [\n        [y1, y2],\n        [m1, m2],\n        [d1, d2]\n    ]) {\n        if (x !== y)\n            return ComparisonResult(x - y);\n    }\n    return 0;\n}\nfunction NonNegativeModulo(x, y) {\n    let result = x % y;\n    if (ObjectIs(result, -0))\n        return 0;\n    if (result < 0)\n        result += y;\n    return result;\n}\nfunction ToBigIntExternal(arg) {\n    const jsbiBI = ToBigInt(arg);\n    if (typeof globalThis.BigInt !== 'undefined')\n        return globalThis.BigInt(jsbiBI.toString(10));\n    return jsbiBI;\n}\nfunction ToBigInt(arg) {\n    if (arg instanceof jsbi__WEBPACK_IMPORTED_MODULE_0__) {\n        return arg;\n    }\n    let prim = arg;\n    if (typeof arg === 'object') {\n        const toPrimFn = arg[Symbol.toPrimitive];\n        if (toPrimFn && typeof toPrimFn === 'function') {\n            prim = ReflectApply$1(toPrimFn, arg, ['number']);\n        }\n    }\n    switch (typeof prim) {\n        case 'undefined':\n        case 'object':\n        case 'number':\n        case 'symbol':\n        default:\n            throw new TypeError(`cannot convert ${typeof arg} to bigint`);\n        case 'string':\n            if (!prim.match(/^\\s*(?:[+-]?\\d+\\s*)?$/)) {\n                throw new SyntaxError('invalid BigInt syntax');\n            }\n        // eslint: no-fallthrough: false\n        case 'bigint':\n            try {\n                return jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(prim.toString());\n            }\n            catch (e) {\n                if (e instanceof Error && e.message.startsWith('Invalid integer'))\n                    throw new SyntaxError(e.message);\n                throw e;\n            }\n        case 'boolean':\n            if (prim) {\n                return ONE;\n            }\n            else {\n                return ZERO;\n            }\n    }\n}\n// Note: This method returns values with bogus nanoseconds based on the previous iteration's\n// milliseconds. That way there is a guarantee that the full nanoseconds are always going to be\n// increasing at least and that the microsecond and nanosecond fields are likely to be non-zero.\nconst SystemUTCEpochNanoSeconds = (() => {\n    let ns = jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(Date.now() % 1e6);\n    return () => {\n        const ms = jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(Date.now());\n        const result = jsbi__WEBPACK_IMPORTED_MODULE_0__.add(jsbi__WEBPACK_IMPORTED_MODULE_0__.multiply(ms, MILLION), ns);\n        ns = jsbi__WEBPACK_IMPORTED_MODULE_0__.divide(ms, MILLION);\n        if (jsbi__WEBPACK_IMPORTED_MODULE_0__.greaterThan(result, NS_MAX))\n            return NS_MAX;\n        if (jsbi__WEBPACK_IMPORTED_MODULE_0__.lessThan(result, NS_MIN))\n            return NS_MIN;\n        return result;\n    };\n})();\nfunction SystemTimeZone() {\n    const fmt = new IntlDateTimeFormat$1('en-us');\n    const TemporalTimeZone = GetIntrinsic('%Temporal.TimeZone%');\n    return new TemporalTimeZone(ParseTemporalTimeZone(fmt.resolvedOptions().timeZone));\n}\nfunction ComparisonResult(value) {\n    return value < 0 ? -1 : value > 0 ? 1 : value;\n}\nfunction GetOptionsObject(options) {\n    if (options === undefined)\n        return ObjectCreate$2(null);\n    if (IsObject(options) && options !== null)\n        return options;\n    throw new TypeError(`Options parameter must be an object, not ${options === null ? 'null' : `${typeof options}`}`);\n}\nfunction CreateOnePropObject(propName, propValue) {\n    const o = ObjectCreate$2(null);\n    o[propName] = propValue;\n    return o;\n}\nfunction GetOption(options, property, allowedValues, fallback) {\n    let value = options[property];\n    if (value !== undefined) {\n        value = ToString(value);\n        if (!allowedValues.includes(value)) {\n            throw new RangeError(`${property} must be one of ${allowedValues.join(', ')}, not ${value}`);\n        }\n        return value;\n    }\n    return fallback;\n}\nfunction GetNumberOption(options, property, minimum, maximum, fallback) {\n    let valueRaw = options[property];\n    if (valueRaw === undefined)\n        return fallback;\n    const value = ToNumber(valueRaw);\n    if (NumberIsNaN(value) || value < minimum || value > maximum) {\n        throw new RangeError(`${property} must be between ${minimum} and ${maximum}, not ${value}`);\n    }\n    return MathFloor(value);\n}\nconst OFFSET = new RegExp(`^${offset.source}$`);\nfunction bisect(getState, leftParam, rightParam, lstateParam = getState(leftParam), rstateParam = getState(rightParam)) {\n    // This doesn't make much sense - why do these get converted unnecessarily?\n    let left = jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(leftParam);\n    let right = jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(rightParam);\n    let lstate = lstateParam;\n    let rstate = rstateParam;\n    while (jsbi__WEBPACK_IMPORTED_MODULE_0__.greaterThan(jsbi__WEBPACK_IMPORTED_MODULE_0__.subtract(right, left), ONE)) {\n        const middle = jsbi__WEBPACK_IMPORTED_MODULE_0__.divide(jsbi__WEBPACK_IMPORTED_MODULE_0__.add(left, right), jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(2));\n        const mstate = getState(middle);\n        if (mstate === lstate) {\n            left = middle;\n            lstate = mstate;\n        }\n        else if (mstate === rstate) {\n            right = middle;\n            rstate = mstate;\n        }\n        else {\n            throw new Error(`invalid state in bisection ${lstate} - ${mstate} - ${rstate}`);\n        }\n    }\n    return right;\n}\nconst nsPerTimeUnit = {\n    hour: 3600e9,\n    minute: 60e9,\n    second: 1e9,\n    millisecond: 1e6,\n    microsecond: 1e3,\n    nanosecond: 1\n};\n\nconst DATE = Symbol('date');\nconst YM = Symbol('ym');\nconst MD = Symbol('md');\nconst TIME = Symbol('time');\nconst DATETIME = Symbol('datetime');\nconst ZONED = Symbol('zoneddatetime');\nconst INST = Symbol('instant');\nconst ORIGINAL = Symbol('original');\nconst TZ_RESOLVED = Symbol('timezone');\nconst TZ_GIVEN = Symbol('timezone-id-given');\nconst CAL_ID = Symbol('calendar-id');\nconst LOCALE = Symbol('locale');\nconst OPTIONS = Symbol('options');\nconst descriptor = (value) => {\n    return {\n        value,\n        enumerable: true,\n        writable: false,\n        configurable: true\n    };\n};\nconst IntlDateTimeFormat = globalThis.Intl.DateTimeFormat;\nconst ObjectAssign$1 = Object.assign;\nconst ObjectHasOwnProperty = Object.prototype.hasOwnProperty;\nconst ReflectApply = Reflect.apply;\n// Construction of built-in Intl.DateTimeFormat objects is sloooooow,\n// so we'll only create those instances when we need them.\n// See https://bugs.chromium.org/p/v8/issues/detail?id=6528\nfunction getPropLazy(obj, prop) {\n    let val = obj[prop];\n    if (typeof val === 'function') {\n        // If we get here, `val` is an \"amender function\". It will take the user's\n        // options and transform them into suitable options to be passed into the\n        // built-in (non-polyfill) Intl.DateTimeFormat constructor. These options\n        // will vary depending on the Temporal type, so that's why we store separate\n        // formatters in separate props on the polyfill's DateTimeFormat instances.\n        // The efficiency happens because we don't create an (expensive) formatter\n        // until the user calls toLocaleString for that Temporal type.\n        val = new IntlDateTimeFormat(obj[LOCALE], val(obj[OPTIONS]));\n        // TODO: can this be typed more cleanly?\n        obj[prop] = val;\n    }\n    return val;\n}\n// Similarly, lazy-init TimeZone instances.\nfunction getResolvedTimeZoneLazy(obj) {\n    let val = obj[TZ_RESOLVED];\n    if (typeof val === 'string') {\n        val = ToTemporalTimeZone(val);\n        obj[TZ_RESOLVED] = val;\n    }\n    return val;\n}\nfunction DateTimeFormatImpl(locale = undefined, optionsParam = {}) {\n    if (!(this instanceof DateTimeFormatImpl)) {\n        return new DateTimeFormatImpl(locale, optionsParam);\n    }\n    const hasOptions = typeof optionsParam !== 'undefined';\n    const options = hasOptions ? ObjectAssign$1({}, optionsParam) : {};\n    // TODO: remove type assertion after Temporal types land in TS lib types\n    const original = new IntlDateTimeFormat(locale, options);\n    const ro = original.resolvedOptions();\n    // DateTimeFormat instances are very expensive to create. Therefore, they will\n    // be lazily created only when needed, using the locale and options provided.\n    // But it's possible for callers to mutate those inputs before lazy creation\n    // happens. For this reason, we clone the inputs instead of caching the\n    // original objects. To avoid the complexity of deep cloning any inputs that\n    // are themselves objects (e.g. the locales array, or options property values\n    // that will be coerced to strings), we rely on `resolvedOptions()` to do the\n    // coercion and cloning for us. Unfortunately, we can't just use the resolved\n    // options as-is because our options-amending logic adds additional fields if\n    // the user doesn't supply any unit fields like year, month, day, hour, etc.\n    // Therefore, we limit the properties in the clone to properties that were\n    // present in the original input.\n    if (hasOptions) {\n        const clonedResolved = ObjectAssign$1({}, ro);\n        for (const prop in clonedResolved) {\n            if (!ReflectApply(ObjectHasOwnProperty, options, [prop])) {\n                delete clonedResolved[prop];\n            }\n        }\n        this[OPTIONS] = clonedResolved;\n    }\n    else {\n        this[OPTIONS] = options;\n    }\n    this[TZ_GIVEN] = options.timeZone ? options.timeZone : null;\n    this[LOCALE] = ro.locale;\n    this[ORIGINAL] = original;\n    this[TZ_RESOLVED] = ro.timeZone;\n    this[CAL_ID] = ro.calendar;\n    this[DATE] = dateAmend;\n    this[YM] = yearMonthAmend;\n    this[MD] = monthDayAmend;\n    this[TIME] = timeAmend;\n    this[DATETIME] = datetimeAmend;\n    this[ZONED] = zonedDateTimeAmend;\n    this[INST] = instantAmend;\n    return undefined; // TODO: I couldn't satisfy TS without adding this. Is there another way?\n}\nObject.defineProperty(DateTimeFormatImpl, 'name', {\n    writable: true,\n    value: 'DateTimeFormat'\n});\nDateTimeFormatImpl.supportedLocalesOf = function (locales, options) {\n    return IntlDateTimeFormat.supportedLocalesOf(locales, options);\n};\nconst properties = {\n    resolvedOptions: descriptor(resolvedOptions),\n    format: descriptor(format),\n    formatRange: descriptor(formatRange)\n};\nif ('formatToParts' in IntlDateTimeFormat.prototype) {\n    properties.formatToParts = descriptor(formatToParts);\n}\nif ('formatRangeToParts' in IntlDateTimeFormat.prototype) {\n    properties.formatRangeToParts = descriptor(formatRangeToParts);\n}\nDateTimeFormatImpl.prototype = Object.create(IntlDateTimeFormat.prototype, properties);\n// Ensure that the prototype isn't writeable.\nObject.defineProperty(DateTimeFormatImpl, 'prototype', {\n    writable: false,\n    enumerable: false,\n    configurable: false\n});\nconst DateTimeFormat = DateTimeFormatImpl;\nfunction resolvedOptions() {\n    return this[ORIGINAL].resolvedOptions();\n}\nfunction adjustFormatterTimeZone(formatter, timeZone) {\n    if (!timeZone)\n        return formatter;\n    const options = formatter.resolvedOptions();\n    if (options.timeZone === timeZone)\n        return formatter;\n    // Existing Intl isn't typed to accept Temporal-specific options, but will not\n    // break at runtime if we pass them. Also, the lib types for resolved options\n    // are less restrictive than the types for options. For example, `weekday` is\n    // `'long' | 'short' | 'narrow'` in options but `string` in resolved options.\n    // TODO: investigate why, and file an issue against TS if it's a bug.\n    return new IntlDateTimeFormat(options.locale, { ...options, timeZone });\n}\n// TODO: investigate why there's a rest parameter here. Does this function really need to accept extra params?\n// And if so, why doesn't formatRange also accept extra params?\nfunction format(datetime, ...rest) {\n    let { instant, formatter, timeZone } = extractOverrides(datetime, this);\n    if (instant && formatter) {\n        formatter = adjustFormatterTimeZone(formatter, timeZone);\n        return formatter.format(instant.epochMilliseconds);\n    }\n    return this[ORIGINAL].format(datetime, ...rest);\n}\nfunction formatToParts(datetime, ...rest) {\n    let { instant, formatter, timeZone } = extractOverrides(datetime, this);\n    if (instant && formatter) {\n        formatter = adjustFormatterTimeZone(formatter, timeZone);\n        return formatter.formatToParts(instant.epochMilliseconds);\n    }\n    return this[ORIGINAL].formatToParts(datetime, ...rest);\n}\nfunction formatRange(a, b) {\n    if (isTemporalObject(a) || isTemporalObject(b)) {\n        if (!sameTemporalType(a, b)) {\n            throw new TypeError('Intl.DateTimeFormat.formatRange accepts two values of the same type');\n        }\n        const { instant: aa, formatter: aformatter, timeZone: atz } = extractOverrides(a, this);\n        const { instant: bb, formatter: bformatter, timeZone: btz } = extractOverrides(b, this);\n        if (atz && btz && atz !== btz) {\n            throw new RangeError('cannot format range between different time zones');\n        }\n        if (aa && bb && aformatter && bformatter && aformatter === bformatter) {\n            const formatter = adjustFormatterTimeZone(aformatter, atz);\n            // TODO: Remove type assertion after this method lands in TS lib types\n            return formatter.formatRange(aa.epochMilliseconds, bb.epochMilliseconds);\n        }\n    }\n    // TODO: Remove type assertion after this method lands in TS lib types\n    return this[ORIGINAL].formatRange(a, b);\n}\nfunction formatRangeToParts(a, b) {\n    if (isTemporalObject(a) || isTemporalObject(b)) {\n        if (!sameTemporalType(a, b)) {\n            throw new TypeError('Intl.DateTimeFormat.formatRangeToParts accepts two values of the same type');\n        }\n        const { instant: aa, formatter: aformatter, timeZone: atz } = extractOverrides(a, this);\n        const { instant: bb, formatter: bformatter, timeZone: btz } = extractOverrides(b, this);\n        if (atz && btz && atz !== btz) {\n            throw new RangeError('cannot format range between different time zones');\n        }\n        if (aa && bb && aformatter && bformatter && aformatter === bformatter) {\n            const formatter = adjustFormatterTimeZone(aformatter, atz);\n            // TODO: Remove type assertion after this method lands in TS lib types\n            return formatter.formatRangeToParts(aa.epochMilliseconds, bb.epochMilliseconds);\n        }\n    }\n    // TODO: Remove type assertion after this method lands in TS lib types\n    return this[ORIGINAL].formatRangeToParts(a, b);\n}\nfunction amend(optionsParam = {}, amended = {}) {\n    const options = ObjectAssign$1({}, optionsParam);\n    for (const opt of [\n        'year',\n        'month',\n        'day',\n        'hour',\n        'minute',\n        'second',\n        'weekday',\n        'dayPeriod',\n        'timeZoneName',\n        'dateStyle',\n        'timeStyle'\n    ]) {\n        options[opt] = opt in amended ? amended[opt] : options[opt];\n        if (options[opt] === false || options[opt] === undefined)\n            delete options[opt];\n    }\n    return options;\n}\nfunction timeAmend(optionsParam) {\n    let options = amend(optionsParam, {\n        year: false,\n        month: false,\n        day: false,\n        weekday: false,\n        timeZoneName: false,\n        dateStyle: false\n    });\n    if (!hasTimeOptions(options)) {\n        options = ObjectAssign$1({}, options, {\n            hour: 'numeric',\n            minute: 'numeric',\n            second: 'numeric'\n        });\n    }\n    return options;\n}\nfunction yearMonthAmend(optionsParam) {\n    let options = amend(optionsParam, {\n        day: false,\n        hour: false,\n        minute: false,\n        second: false,\n        weekday: false,\n        dayPeriod: false,\n        timeZoneName: false,\n        dateStyle: false,\n        timeStyle: false\n    });\n    if (!('year' in options || 'month' in options)) {\n        options = ObjectAssign$1(options, { year: 'numeric', month: 'numeric' });\n    }\n    return options;\n}\nfunction monthDayAmend(optionsParam) {\n    let options = amend(optionsParam, {\n        year: false,\n        hour: false,\n        minute: false,\n        second: false,\n        weekday: false,\n        dayPeriod: false,\n        timeZoneName: false,\n        dateStyle: false,\n        timeStyle: false\n    });\n    if (!('month' in options || 'day' in options)) {\n        options = ObjectAssign$1({}, options, { month: 'numeric', day: 'numeric' });\n    }\n    return options;\n}\nfunction dateAmend(optionsParam) {\n    let options = amend(optionsParam, {\n        hour: false,\n        minute: false,\n        second: false,\n        dayPeriod: false,\n        timeZoneName: false,\n        timeStyle: false\n    });\n    if (!hasDateOptions(options)) {\n        options = ObjectAssign$1({}, options, {\n            year: 'numeric',\n            month: 'numeric',\n            day: 'numeric'\n        });\n    }\n    return options;\n}\nfunction datetimeAmend(optionsParam) {\n    let options = amend(optionsParam, { timeZoneName: false });\n    if (!hasTimeOptions(options) && !hasDateOptions(options)) {\n        options = ObjectAssign$1({}, options, {\n            year: 'numeric',\n            month: 'numeric',\n            day: 'numeric',\n            hour: 'numeric',\n            minute: 'numeric',\n            second: 'numeric'\n        });\n    }\n    return options;\n}\nfunction zonedDateTimeAmend(optionsParam) {\n    let options = optionsParam;\n    if (!hasTimeOptions(options) && !hasDateOptions(options)) {\n        options = ObjectAssign$1({}, options, {\n            year: 'numeric',\n            month: 'numeric',\n            day: 'numeric',\n            hour: 'numeric',\n            minute: 'numeric',\n            second: 'numeric'\n        });\n        if (options.timeZoneName === undefined)\n            options.timeZoneName = 'short';\n    }\n    return options;\n}\nfunction instantAmend(optionsParam) {\n    let options = optionsParam;\n    if (!hasTimeOptions(options) && !hasDateOptions(options)) {\n        options = ObjectAssign$1({}, options, {\n            year: 'numeric',\n            month: 'numeric',\n            day: 'numeric',\n            hour: 'numeric',\n            minute: 'numeric',\n            second: 'numeric'\n        });\n    }\n    return options;\n}\nfunction hasDateOptions(options) {\n    return 'year' in options || 'month' in options || 'day' in options || 'weekday' in options || 'dateStyle' in options;\n}\nfunction hasTimeOptions(options) {\n    return ('hour' in options || 'minute' in options || 'second' in options || 'timeStyle' in options || 'dayPeriod' in options);\n}\nfunction isTemporalObject(obj) {\n    return (IsTemporalDate(obj) ||\n        IsTemporalTime(obj) ||\n        IsTemporalDateTime(obj) ||\n        IsTemporalZonedDateTime(obj) ||\n        IsTemporalYearMonth(obj) ||\n        IsTemporalMonthDay(obj) ||\n        IsTemporalInstant(obj));\n}\nfunction sameTemporalType(x, y) {\n    if (!isTemporalObject(x) || !isTemporalObject(y))\n        return false;\n    if (IsTemporalTime(x) && !IsTemporalTime(y))\n        return false;\n    if (IsTemporalDate(x) && !IsTemporalDate(y))\n        return false;\n    if (IsTemporalDateTime(x) && !IsTemporalDateTime(y))\n        return false;\n    if (IsTemporalZonedDateTime(x) && !IsTemporalZonedDateTime(y))\n        return false;\n    if (IsTemporalYearMonth(x) && !IsTemporalYearMonth(y))\n        return false;\n    if (IsTemporalMonthDay(x) && !IsTemporalMonthDay(y))\n        return false;\n    if (IsTemporalInstant(x) && !IsTemporalInstant(y))\n        return false;\n    return true;\n}\nfunction extractOverrides(temporalObj, main) {\n    const DateTime = GetIntrinsic('%Temporal.PlainDateTime%');\n    if (IsTemporalTime(temporalObj)) {\n        const hour = GetSlot(temporalObj, ISO_HOUR);\n        const minute = GetSlot(temporalObj, ISO_MINUTE);\n        const second = GetSlot(temporalObj, ISO_SECOND);\n        const millisecond = GetSlot(temporalObj, ISO_MILLISECOND);\n        const microsecond = GetSlot(temporalObj, ISO_MICROSECOND);\n        const nanosecond = GetSlot(temporalObj, ISO_NANOSECOND);\n        const datetime = new DateTime(1970, 1, 1, hour, minute, second, millisecond, microsecond, nanosecond, main[CAL_ID]);\n        return {\n            instant: BuiltinTimeZoneGetInstantFor(getResolvedTimeZoneLazy(main), datetime, 'compatible'),\n            formatter: getPropLazy(main, TIME)\n        };\n    }\n    if (IsTemporalYearMonth(temporalObj)) {\n        const isoYear = GetSlot(temporalObj, ISO_YEAR);\n        const isoMonth = GetSlot(temporalObj, ISO_MONTH);\n        const referenceISODay = GetSlot(temporalObj, ISO_DAY);\n        const calendar = ToString(GetSlot(temporalObj, CALENDAR));\n        if (calendar !== main[CAL_ID]) {\n            throw new RangeError(`cannot format PlainYearMonth with calendar ${calendar} in locale with calendar ${main[CAL_ID]}`);\n        }\n        const datetime = new DateTime(isoYear, isoMonth, referenceISODay, 12, 0, 0, 0, 0, 0, calendar);\n        return {\n            instant: BuiltinTimeZoneGetInstantFor(getResolvedTimeZoneLazy(main), datetime, 'compatible'),\n            formatter: getPropLazy(main, YM)\n        };\n    }\n    if (IsTemporalMonthDay(temporalObj)) {\n        const referenceISOYear = GetSlot(temporalObj, ISO_YEAR);\n        const isoMonth = GetSlot(temporalObj, ISO_MONTH);\n        const isoDay = GetSlot(temporalObj, ISO_DAY);\n        const calendar = ToString(GetSlot(temporalObj, CALENDAR));\n        if (calendar !== main[CAL_ID]) {\n            throw new RangeError(`cannot format PlainMonthDay with calendar ${calendar} in locale with calendar ${main[CAL_ID]}`);\n        }\n        const datetime = new DateTime(referenceISOYear, isoMonth, isoDay, 12, 0, 0, 0, 0, 0, calendar);\n        return {\n            instant: BuiltinTimeZoneGetInstantFor(getResolvedTimeZoneLazy(main), datetime, 'compatible'),\n            formatter: getPropLazy(main, MD)\n        };\n    }\n    if (IsTemporalDate(temporalObj)) {\n        const isoYear = GetSlot(temporalObj, ISO_YEAR);\n        const isoMonth = GetSlot(temporalObj, ISO_MONTH);\n        const isoDay = GetSlot(temporalObj, ISO_DAY);\n        const calendar = ToString(GetSlot(temporalObj, CALENDAR));\n        if (calendar !== 'iso8601' && calendar !== main[CAL_ID]) {\n            throw new RangeError(`cannot format PlainDate with calendar ${calendar} in locale with calendar ${main[CAL_ID]}`);\n        }\n        const datetime = new DateTime(isoYear, isoMonth, isoDay, 12, 0, 0, 0, 0, 0, main[CAL_ID]);\n        return {\n            instant: BuiltinTimeZoneGetInstantFor(getResolvedTimeZoneLazy(main), datetime, 'compatible'),\n            formatter: getPropLazy(main, DATE)\n        };\n    }\n    if (IsTemporalDateTime(temporalObj)) {\n        const isoYear = GetSlot(temporalObj, ISO_YEAR);\n        const isoMonth = GetSlot(temporalObj, ISO_MONTH);\n        const isoDay = GetSlot(temporalObj, ISO_DAY);\n        const hour = GetSlot(temporalObj, ISO_HOUR);\n        const minute = GetSlot(temporalObj, ISO_MINUTE);\n        const second = GetSlot(temporalObj, ISO_SECOND);\n        const millisecond = GetSlot(temporalObj, ISO_MILLISECOND);\n        const microsecond = GetSlot(temporalObj, ISO_MICROSECOND);\n        const nanosecond = GetSlot(temporalObj, ISO_NANOSECOND);\n        const calendar = ToString(GetSlot(temporalObj, CALENDAR));\n        if (calendar !== 'iso8601' && calendar !== main[CAL_ID]) {\n            throw new RangeError(`cannot format PlainDateTime with calendar ${calendar} in locale with calendar ${main[CAL_ID]}`);\n        }\n        let datetime = temporalObj;\n        if (calendar === 'iso8601') {\n            datetime = new DateTime(isoYear, isoMonth, isoDay, hour, minute, second, millisecond, microsecond, nanosecond, main[CAL_ID]);\n        }\n        return {\n            instant: BuiltinTimeZoneGetInstantFor(getResolvedTimeZoneLazy(main), datetime, 'compatible'),\n            formatter: getPropLazy(main, DATETIME)\n        };\n    }\n    if (IsTemporalZonedDateTime(temporalObj)) {\n        const calendar = ToString(GetSlot(temporalObj, CALENDAR));\n        if (calendar !== 'iso8601' && calendar !== main[CAL_ID]) {\n            throw new RangeError(`cannot format ZonedDateTime with calendar ${calendar} in locale with calendar ${main[CAL_ID]}`);\n        }\n        const timeZone = GetSlot(temporalObj, TIME_ZONE);\n        const objTimeZone = ToString(timeZone);\n        if (main[TZ_GIVEN] && main[TZ_GIVEN] !== objTimeZone) {\n            throw new RangeError(`timeZone option ${main[TZ_GIVEN]} doesn't match actual time zone ${objTimeZone}`);\n        }\n        return {\n            instant: GetSlot(temporalObj, INSTANT),\n            formatter: getPropLazy(main, ZONED),\n            timeZone: objTimeZone\n        };\n    }\n    if (IsTemporalInstant(temporalObj)) {\n        return {\n            instant: temporalObj,\n            formatter: getPropLazy(main, INST)\n        };\n    }\n    return {};\n}\n\nvar intl = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    DateTimeFormat: DateTimeFormat\n});\n\nconst DISALLOWED_UNITS$3 = ['year', 'month', 'week', 'day'];\nconst MAX_DIFFERENCE_INCREMENTS = {\n    hour: 24,\n    minute: 60,\n    second: 60,\n    millisecond: 1000,\n    microsecond: 1000,\n    nanosecond: 1000\n};\nclass Instant {\n    constructor(epochNanoseconds) {\n        // Note: if the argument is not passed, ToBigInt(undefined) will throw. This check exists only\n        //       to improve the error message.\n        if (arguments.length < 1) {\n            throw new TypeError('missing argument: epochNanoseconds is required');\n        }\n        const ns = ToBigInt(epochNanoseconds);\n        ValidateEpochNanoseconds(ns);\n        CreateSlots(this);\n        SetSlot(this, EPOCHNANOSECONDS, ns);\n        {\n            const repr = TemporalInstantToString(this, undefined, 'auto');\n            Object.defineProperty(this, '_repr_', {\n                value: `${this[Symbol.toStringTag]} <${repr}>`,\n                writable: false,\n                enumerable: false,\n                configurable: false\n            });\n        }\n    }\n    get epochSeconds() {\n        if (!IsTemporalInstant(this))\n            throw new TypeError('invalid receiver');\n        const value = GetSlot(this, EPOCHNANOSECONDS);\n        return jsbi__WEBPACK_IMPORTED_MODULE_0__.toNumber(jsbi__WEBPACK_IMPORTED_MODULE_0__.divide(value, BILLION));\n    }\n    get epochMilliseconds() {\n        if (!IsTemporalInstant(this))\n            throw new TypeError('invalid receiver');\n        const value = jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(GetSlot(this, EPOCHNANOSECONDS));\n        return jsbi__WEBPACK_IMPORTED_MODULE_0__.toNumber(jsbi__WEBPACK_IMPORTED_MODULE_0__.divide(value, MILLION));\n    }\n    get epochMicroseconds() {\n        if (!IsTemporalInstant(this))\n            throw new TypeError('invalid receiver');\n        const value = jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(GetSlot(this, EPOCHNANOSECONDS));\n        return ToBigIntExternal(jsbi__WEBPACK_IMPORTED_MODULE_0__.divide(value, THOUSAND));\n    }\n    get epochNanoseconds() {\n        if (!IsTemporalInstant(this))\n            throw new TypeError('invalid receiver');\n        return ToBigIntExternal(jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(GetSlot(this, EPOCHNANOSECONDS)));\n    }\n    add(temporalDurationLike) {\n        if (!IsTemporalInstant(this))\n            throw new TypeError('invalid receiver');\n        const { hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = ToLimitedTemporalDuration(temporalDurationLike, ['years', 'months', 'weeks', 'days']);\n        const ns = AddInstant(GetSlot(this, EPOCHNANOSECONDS), hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n        return new Instant(ns);\n    }\n    subtract(temporalDurationLike) {\n        if (!IsTemporalInstant(this))\n            throw new TypeError('invalid receiver');\n        const { hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = ToLimitedTemporalDuration(temporalDurationLike, ['years', 'months', 'weeks', 'days']);\n        const ns = AddInstant(GetSlot(this, EPOCHNANOSECONDS), -hours, -minutes, -seconds, -milliseconds, -microseconds, -nanoseconds);\n        return new Instant(ns);\n    }\n    until(otherParam, optionsParam = undefined) {\n        if (!IsTemporalInstant(this))\n            throw new TypeError('invalid receiver');\n        const other = ToTemporalInstant(otherParam);\n        const options = GetOptionsObject(optionsParam);\n        const smallestUnit = ToSmallestTemporalUnit(options, 'nanosecond', DISALLOWED_UNITS$3);\n        const defaultLargestUnit = LargerOfTwoTemporalUnits('second', smallestUnit);\n        const largestUnit = ToLargestTemporalUnit(options, 'auto', DISALLOWED_UNITS$3, defaultLargestUnit);\n        ValidateTemporalUnitRange(largestUnit, smallestUnit);\n        const roundingMode = ToTemporalRoundingMode(options, 'trunc');\n        const roundingIncrement = ToTemporalRoundingIncrement(options, MAX_DIFFERENCE_INCREMENTS[smallestUnit], false);\n        const onens = GetSlot(this, EPOCHNANOSECONDS);\n        const twons = GetSlot(other, EPOCHNANOSECONDS);\n        let { seconds, milliseconds, microseconds, nanoseconds } = DifferenceInstant(onens, twons, roundingIncrement, smallestUnit, roundingMode);\n        let hours, minutes;\n        ({ hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = BalanceDuration(0, 0, 0, seconds, milliseconds, microseconds, nanoseconds, largestUnit));\n        const Duration = GetIntrinsic('%Temporal.Duration%');\n        return new Duration(0, 0, 0, 0, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n    }\n    since(otherParam, optionsParam = undefined) {\n        if (!IsTemporalInstant(this))\n            throw new TypeError('invalid receiver');\n        const other = ToTemporalInstant(otherParam);\n        const options = GetOptionsObject(optionsParam);\n        const smallestUnit = ToSmallestTemporalUnit(options, 'nanosecond', DISALLOWED_UNITS$3);\n        const defaultLargestUnit = LargerOfTwoTemporalUnits('second', smallestUnit);\n        const largestUnit = ToLargestTemporalUnit(options, 'auto', DISALLOWED_UNITS$3, defaultLargestUnit);\n        ValidateTemporalUnitRange(largestUnit, smallestUnit);\n        const roundingMode = ToTemporalRoundingMode(options, 'trunc');\n        const roundingIncrement = ToTemporalRoundingIncrement(options, MAX_DIFFERENCE_INCREMENTS[smallestUnit], false);\n        const onens = GetSlot(other, EPOCHNANOSECONDS);\n        const twons = GetSlot(this, EPOCHNANOSECONDS);\n        let { seconds, milliseconds, microseconds, nanoseconds } = DifferenceInstant(onens, twons, roundingIncrement, smallestUnit, roundingMode);\n        let hours, minutes;\n        ({ hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = BalanceDuration(0, 0, 0, seconds, milliseconds, microseconds, nanoseconds, largestUnit));\n        const Duration = GetIntrinsic('%Temporal.Duration%');\n        return new Duration(0, 0, 0, 0, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n    }\n    round(optionsParam) {\n        if (!IsTemporalInstant(this))\n            throw new TypeError('invalid receiver');\n        if (optionsParam === undefined)\n            throw new TypeError('options parameter is required');\n        const options = typeof optionsParam === 'string'\n            ? CreateOnePropObject('smallestUnit', optionsParam)\n            : GetOptionsObject(optionsParam);\n        const smallestUnit = ToSmallestTemporalUnit(options, undefined, DISALLOWED_UNITS$3);\n        if (smallestUnit === undefined)\n            throw new RangeError('smallestUnit is required');\n        const roundingMode = ToTemporalRoundingMode(options, 'halfExpand');\n        const maximumIncrements = {\n            hour: 24,\n            minute: 1440,\n            second: 86400,\n            millisecond: 86400e3,\n            microsecond: 86400e6,\n            nanosecond: 86400e9\n        };\n        const roundingIncrement = ToTemporalRoundingIncrement(options, maximumIncrements[smallestUnit], true);\n        const ns = GetSlot(this, EPOCHNANOSECONDS);\n        const roundedNs = RoundInstant(ns, roundingIncrement, smallestUnit, roundingMode);\n        return new Instant(roundedNs);\n    }\n    equals(otherParam) {\n        if (!IsTemporalInstant(this))\n            throw new TypeError('invalid receiver');\n        const other = ToTemporalInstant(otherParam);\n        const one = GetSlot(this, EPOCHNANOSECONDS);\n        const two = GetSlot(other, EPOCHNANOSECONDS);\n        return jsbi__WEBPACK_IMPORTED_MODULE_0__.equal(jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(one), jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(two));\n    }\n    toString(optionsParam = undefined) {\n        if (!IsTemporalInstant(this))\n            throw new TypeError('invalid receiver');\n        const options = GetOptionsObject(optionsParam);\n        let timeZone = options.timeZone;\n        if (timeZone !== undefined)\n            timeZone = ToTemporalTimeZone(timeZone);\n        // Although TS doesn't acknowledge it, below here `timeZone` is a Temporal.TimeZoneProtocol\n        const { precision, unit, increment } = ToSecondsStringPrecision(options);\n        const roundingMode = ToTemporalRoundingMode(options, 'trunc');\n        const ns = GetSlot(this, EPOCHNANOSECONDS);\n        const roundedNs = RoundInstant(ns, increment, unit, roundingMode);\n        const roundedInstant = new Instant(roundedNs);\n        return TemporalInstantToString(roundedInstant, timeZone, precision);\n    }\n    toJSON() {\n        if (!IsTemporalInstant(this))\n            throw new TypeError('invalid receiver');\n        return TemporalInstantToString(this, undefined, 'auto');\n    }\n    toLocaleString(locales = undefined, options = undefined) {\n        if (!IsTemporalInstant(this))\n            throw new TypeError('invalid receiver');\n        return new DateTimeFormat(locales, options).format(this);\n    }\n    valueOf() {\n        throw new TypeError('use compare() or equals() to compare Temporal.Instant');\n    }\n    toZonedDateTime(item) {\n        if (!IsTemporalInstant(this))\n            throw new TypeError('invalid receiver');\n        if (!IsObject(item)) {\n            throw new TypeError('invalid argument in toZonedDateTime');\n        }\n        const calendarLike = item.calendar;\n        if (calendarLike === undefined) {\n            throw new TypeError('missing calendar property in toZonedDateTime');\n        }\n        const calendar = ToTemporalCalendar(calendarLike);\n        const temporalTimeZoneLike = item.timeZone;\n        if (temporalTimeZoneLike === undefined) {\n            throw new TypeError('missing timeZone property in toZonedDateTime');\n        }\n        const timeZone = ToTemporalTimeZone(temporalTimeZoneLike);\n        return CreateTemporalZonedDateTime(GetSlot(this, EPOCHNANOSECONDS), timeZone, calendar);\n    }\n    toZonedDateTimeISO(itemParam) {\n        let item = itemParam;\n        if (!IsTemporalInstant(this))\n            throw new TypeError('invalid receiver');\n        if (IsObject(item)) {\n            const timeZoneProperty = item.timeZone;\n            if (timeZoneProperty !== undefined) {\n                item = timeZoneProperty;\n            }\n        }\n        const timeZone = ToTemporalTimeZone(item);\n        const calendar = GetISO8601Calendar();\n        return CreateTemporalZonedDateTime(GetSlot(this, EPOCHNANOSECONDS), timeZone, calendar);\n    }\n    static fromEpochSeconds(epochSecondsParam) {\n        const epochSeconds = ToNumber(epochSecondsParam);\n        const epochNanoseconds = jsbi__WEBPACK_IMPORTED_MODULE_0__.multiply(jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(epochSeconds), BILLION);\n        ValidateEpochNanoseconds(epochNanoseconds);\n        return new Instant(epochNanoseconds);\n    }\n    static fromEpochMilliseconds(epochMillisecondsParam) {\n        const epochMilliseconds = ToNumber(epochMillisecondsParam);\n        const epochNanoseconds = jsbi__WEBPACK_IMPORTED_MODULE_0__.multiply(jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(epochMilliseconds), MILLION);\n        ValidateEpochNanoseconds(epochNanoseconds);\n        return new Instant(epochNanoseconds);\n    }\n    static fromEpochMicroseconds(epochMicrosecondsParam) {\n        const epochMicroseconds = ToBigInt(epochMicrosecondsParam);\n        const epochNanoseconds = jsbi__WEBPACK_IMPORTED_MODULE_0__.multiply(epochMicroseconds, THOUSAND);\n        ValidateEpochNanoseconds(epochNanoseconds);\n        return new Instant(epochNanoseconds);\n    }\n    static fromEpochNanoseconds(epochNanosecondsParam) {\n        const epochNanoseconds = ToBigInt(epochNanosecondsParam);\n        ValidateEpochNanoseconds(epochNanoseconds);\n        return new Instant(epochNanoseconds);\n    }\n    static from(item) {\n        if (IsTemporalInstant(item)) {\n            return new Instant(GetSlot(item, EPOCHNANOSECONDS));\n        }\n        return ToTemporalInstant(item);\n    }\n    static compare(oneParam, twoParam) {\n        const one = ToTemporalInstant(oneParam);\n        const two = ToTemporalInstant(twoParam);\n        const oneNs = GetSlot(one, EPOCHNANOSECONDS);\n        const twoNs = GetSlot(two, EPOCHNANOSECONDS);\n        if (jsbi__WEBPACK_IMPORTED_MODULE_0__.lessThan(oneNs, twoNs))\n            return -1;\n        if (jsbi__WEBPACK_IMPORTED_MODULE_0__.greaterThan(oneNs, twoNs))\n            return 1;\n        return 0;\n    }\n}\nMakeIntrinsicClass(Instant, 'Temporal.Instant');\n\nconst DISALLOWED_UNITS$2 = ['hour', 'minute', 'second', 'millisecond', 'microsecond', 'nanosecond'];\nclass PlainDate {\n    constructor(isoYearParam, isoMonthParam, isoDayParam, calendarParam = GetISO8601Calendar()) {\n        const isoYear = ToIntegerThrowOnInfinity(isoYearParam);\n        const isoMonth = ToIntegerThrowOnInfinity(isoMonthParam);\n        const isoDay = ToIntegerThrowOnInfinity(isoDayParam);\n        const calendar = ToTemporalCalendar(calendarParam);\n        // Note: if the arguments are not passed,\n        //       ToIntegerThrowOnInfinity(undefined) will have returned 0, which will\n        //       be rejected by RejectISODate in CreateTemporalDateSlots. This check\n        //       exists only to improve the error message.\n        if (arguments.length < 3) {\n            throw new RangeError('missing argument: isoYear, isoMonth and isoDay are required');\n        }\n        CreateTemporalDateSlots(this, isoYear, isoMonth, isoDay, calendar);\n    }\n    get calendar() {\n        if (!IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, CALENDAR);\n    }\n    get era() {\n        if (!IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        return CalendarEra(GetSlot(this, CALENDAR), this);\n    }\n    get eraYear() {\n        if (!IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        return CalendarEraYear(GetSlot(this, CALENDAR), this);\n    }\n    get year() {\n        if (!IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        return CalendarYear(GetSlot(this, CALENDAR), this);\n    }\n    get month() {\n        if (!IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        return CalendarMonth(GetSlot(this, CALENDAR), this);\n    }\n    get monthCode() {\n        if (!IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        return CalendarMonthCode(GetSlot(this, CALENDAR), this);\n    }\n    get day() {\n        if (!IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        return CalendarDay(GetSlot(this, CALENDAR), this);\n    }\n    get dayOfWeek() {\n        if (!IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        return CalendarDayOfWeek(GetSlot(this, CALENDAR), this);\n    }\n    get dayOfYear() {\n        if (!IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        return CalendarDayOfYear(GetSlot(this, CALENDAR), this);\n    }\n    get weekOfYear() {\n        if (!IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        return CalendarWeekOfYear(GetSlot(this, CALENDAR), this);\n    }\n    get daysInWeek() {\n        if (!IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        return CalendarDaysInWeek(GetSlot(this, CALENDAR), this);\n    }\n    get daysInMonth() {\n        if (!IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        return CalendarDaysInMonth(GetSlot(this, CALENDAR), this);\n    }\n    get daysInYear() {\n        if (!IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        return CalendarDaysInYear(GetSlot(this, CALENDAR), this);\n    }\n    get monthsInYear() {\n        if (!IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        return CalendarMonthsInYear(GetSlot(this, CALENDAR), this);\n    }\n    get inLeapYear() {\n        if (!IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        return CalendarInLeapYear(GetSlot(this, CALENDAR), this);\n    }\n    with(temporalDateLike, optionsParam = undefined) {\n        if (!IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        if (!IsObject(temporalDateLike)) {\n            throw new TypeError('invalid argument');\n        }\n        RejectObjectWithCalendarOrTimeZone(temporalDateLike);\n        const calendar = GetSlot(this, CALENDAR);\n        const fieldNames = CalendarFields(calendar, ['day', 'month', 'monthCode', 'year']);\n        const props = ToPartialRecord(temporalDateLike, fieldNames);\n        if (!props) {\n            throw new TypeError('invalid date-like');\n        }\n        let fields = ToTemporalDateFields(this, fieldNames);\n        fields = CalendarMergeFields(calendar, fields, props);\n        fields = ToTemporalDateFields(fields, fieldNames);\n        const options = GetOptionsObject(optionsParam);\n        return DateFromFields(calendar, fields, options);\n    }\n    withCalendar(calendarParam) {\n        if (!IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        const calendar = ToTemporalCalendar(calendarParam);\n        return new PlainDate(GetSlot(this, ISO_YEAR), GetSlot(this, ISO_MONTH), GetSlot(this, ISO_DAY), calendar);\n    }\n    add(temporalDurationLike, optionsParam = undefined) {\n        if (!IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        const duration = ToTemporalDuration(temporalDurationLike);\n        const options = GetOptionsObject(optionsParam);\n        return CalendarDateAdd(GetSlot(this, CALENDAR), this, duration, options);\n    }\n    subtract(temporalDurationLike, optionsParam = undefined) {\n        if (!IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        const duration = CreateNegatedTemporalDuration(ToTemporalDuration(temporalDurationLike));\n        const options = GetOptionsObject(optionsParam);\n        return CalendarDateAdd(GetSlot(this, CALENDAR), this, duration, options);\n    }\n    until(otherParam, optionsParam = undefined) {\n        if (!IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        const other = ToTemporalDate(otherParam);\n        const calendar = GetSlot(this, CALENDAR);\n        const otherCalendar = GetSlot(other, CALENDAR);\n        const calendarId = ToString(calendar);\n        const otherCalendarId = ToString(otherCalendar);\n        if (calendarId !== otherCalendarId) {\n            throw new RangeError(`cannot compute difference between dates of ${calendarId} and ${otherCalendarId} calendars`);\n        }\n        const options = GetOptionsObject(optionsParam);\n        const smallestUnit = ToSmallestTemporalUnit(options, 'day', DISALLOWED_UNITS$2);\n        const defaultLargestUnit = LargerOfTwoTemporalUnits('day', smallestUnit);\n        const largestUnit = ToLargestTemporalUnit(options, 'auto', DISALLOWED_UNITS$2, defaultLargestUnit);\n        ValidateTemporalUnitRange(largestUnit, smallestUnit);\n        const roundingMode = ToTemporalRoundingMode(options, 'trunc');\n        const roundingIncrement = ToTemporalRoundingIncrement(options, undefined, false);\n        const untilOptions = { ...options, largestUnit };\n        const result = CalendarDateUntil(calendar, this, other, untilOptions);\n        if (smallestUnit === 'day' && roundingIncrement === 1)\n            return result;\n        let { years, months, weeks, days } = result;\n        ({ years, months, weeks, days } = RoundDuration(years, months, weeks, days, 0, 0, 0, 0, 0, 0, roundingIncrement, smallestUnit, roundingMode, this));\n        const Duration = GetIntrinsic('%Temporal.Duration%');\n        return new Duration(years, months, weeks, days, 0, 0, 0, 0, 0, 0);\n    }\n    since(otherParam, optionsParam = undefined) {\n        if (!IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        const other = ToTemporalDate(otherParam);\n        const calendar = GetSlot(this, CALENDAR);\n        const otherCalendar = GetSlot(other, CALENDAR);\n        const calendarId = ToString(calendar);\n        const otherCalendarId = ToString(otherCalendar);\n        if (calendarId !== otherCalendarId) {\n            throw new RangeError(`cannot compute difference between dates of ${calendarId} and ${otherCalendarId} calendars`);\n        }\n        const options = GetOptionsObject(optionsParam);\n        const smallestUnit = ToSmallestTemporalUnit(options, 'day', DISALLOWED_UNITS$2);\n        const defaultLargestUnit = LargerOfTwoTemporalUnits('day', smallestUnit);\n        const largestUnit = ToLargestTemporalUnit(options, 'auto', DISALLOWED_UNITS$2, defaultLargestUnit);\n        ValidateTemporalUnitRange(largestUnit, smallestUnit);\n        const roundingMode = ToTemporalRoundingMode(options, 'trunc');\n        const roundingIncrement = ToTemporalRoundingIncrement(options, undefined, false);\n        const untilOptions = { ...options, largestUnit };\n        let { years, months, weeks, days } = CalendarDateUntil(calendar, this, other, untilOptions);\n        const Duration = GetIntrinsic('%Temporal.Duration%');\n        if (smallestUnit === 'day' && roundingIncrement === 1) {\n            return new Duration(-years, -months, -weeks, -days, 0, 0, 0, 0, 0, 0);\n        }\n        ({ years, months, weeks, days } = RoundDuration(years, months, weeks, days, 0, 0, 0, 0, 0, 0, roundingIncrement, smallestUnit, NegateTemporalRoundingMode(roundingMode), this));\n        return new Duration(-years, -months, -weeks, -days, 0, 0, 0, 0, 0, 0);\n    }\n    equals(otherParam) {\n        if (!IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        const other = ToTemporalDate(otherParam);\n        for (const slot of [ISO_YEAR, ISO_MONTH, ISO_DAY]) {\n            const val1 = GetSlot(this, slot);\n            const val2 = GetSlot(other, slot);\n            if (val1 !== val2)\n                return false;\n        }\n        return CalendarEquals(GetSlot(this, CALENDAR), GetSlot(other, CALENDAR));\n    }\n    toString(optionsParam = undefined) {\n        if (!IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        const options = GetOptionsObject(optionsParam);\n        const showCalendar = ToShowCalendarOption(options);\n        return TemporalDateToString(this, showCalendar);\n    }\n    toJSON() {\n        if (!IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        return TemporalDateToString(this);\n    }\n    toLocaleString(locales = undefined, options = undefined) {\n        if (!IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        return new DateTimeFormat(locales, options).format(this);\n    }\n    valueOf() {\n        throw new TypeError('use compare() or equals() to compare Temporal.PlainDate');\n    }\n    toPlainDateTime(temporalTimeParam = undefined) {\n        if (!IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        const year = GetSlot(this, ISO_YEAR);\n        const month = GetSlot(this, ISO_MONTH);\n        const day = GetSlot(this, ISO_DAY);\n        const calendar = GetSlot(this, CALENDAR);\n        if (temporalTimeParam === undefined)\n            return CreateTemporalDateTime(year, month, day, 0, 0, 0, 0, 0, 0, calendar);\n        const temporalTime = ToTemporalTime(temporalTimeParam);\n        const hour = GetSlot(temporalTime, ISO_HOUR);\n        const minute = GetSlot(temporalTime, ISO_MINUTE);\n        const second = GetSlot(temporalTime, ISO_SECOND);\n        const millisecond = GetSlot(temporalTime, ISO_MILLISECOND);\n        const microsecond = GetSlot(temporalTime, ISO_MICROSECOND);\n        const nanosecond = GetSlot(temporalTime, ISO_NANOSECOND);\n        return CreateTemporalDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar);\n    }\n    toZonedDateTime(item) {\n        if (!IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        let timeZone, temporalTime;\n        if (IsObject(item)) {\n            const timeZoneLike = item.timeZone;\n            if (timeZoneLike === undefined) {\n                // The cast below is needed because it's possible here for\n                // `timeZoneLike` here to be `{ plainTime: Temporal.PlainTimeLike }`,\n                // not a TimeZoneProtocol.\n                // TODO: should we check for that shape to improve on the (bad) error\n                // message that the caller will get from ToTemporalTimeZone?\n                timeZone = ToTemporalTimeZone(item);\n            }\n            else {\n                timeZone = ToTemporalTimeZone(timeZoneLike);\n                temporalTime = item.plainTime;\n            }\n        }\n        else {\n            timeZone = ToTemporalTimeZone(item);\n        }\n        const year = GetSlot(this, ISO_YEAR);\n        const month = GetSlot(this, ISO_MONTH);\n        const day = GetSlot(this, ISO_DAY);\n        const calendar = GetSlot(this, CALENDAR);\n        let hour = 0, minute = 0, second = 0, millisecond = 0, microsecond = 0, nanosecond = 0;\n        if (temporalTime !== undefined) {\n            temporalTime = ToTemporalTime(temporalTime);\n            hour = GetSlot(temporalTime, ISO_HOUR);\n            minute = GetSlot(temporalTime, ISO_MINUTE);\n            second = GetSlot(temporalTime, ISO_SECOND);\n            millisecond = GetSlot(temporalTime, ISO_MILLISECOND);\n            microsecond = GetSlot(temporalTime, ISO_MICROSECOND);\n            nanosecond = GetSlot(temporalTime, ISO_NANOSECOND);\n        }\n        const dt = CreateTemporalDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar);\n        const instant = BuiltinTimeZoneGetInstantFor(timeZone, dt, 'compatible');\n        return CreateTemporalZonedDateTime(GetSlot(instant, EPOCHNANOSECONDS), timeZone, calendar);\n    }\n    toPlainYearMonth() {\n        if (!IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        const calendar = GetSlot(this, CALENDAR);\n        const fieldNames = CalendarFields(calendar, ['monthCode', 'year']);\n        const fields = ToTemporalYearMonthFields(this, fieldNames);\n        return YearMonthFromFields(calendar, fields);\n    }\n    toPlainMonthDay() {\n        if (!IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        const calendar = GetSlot(this, CALENDAR);\n        const fieldNames = CalendarFields(calendar, ['day', 'monthCode']);\n        const fields = ToTemporalMonthDayFields(this, fieldNames);\n        return MonthDayFromFields(calendar, fields);\n    }\n    getISOFields() {\n        if (!IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        return {\n            calendar: GetSlot(this, CALENDAR),\n            isoDay: GetSlot(this, ISO_DAY),\n            isoMonth: GetSlot(this, ISO_MONTH),\n            isoYear: GetSlot(this, ISO_YEAR)\n        };\n    }\n    static from(item, optionsParam = undefined) {\n        const options = GetOptionsObject(optionsParam);\n        if (IsTemporalDate(item)) {\n            ToTemporalOverflow(options); // validate and ignore\n            return CreateTemporalDate(GetSlot(item, ISO_YEAR), GetSlot(item, ISO_MONTH), GetSlot(item, ISO_DAY), GetSlot(item, CALENDAR));\n        }\n        return ToTemporalDate(item, options);\n    }\n    static compare(oneParam, twoParam) {\n        const one = ToTemporalDate(oneParam);\n        const two = ToTemporalDate(twoParam);\n        return CompareISODate(GetSlot(one, ISO_YEAR), GetSlot(one, ISO_MONTH), GetSlot(one, ISO_DAY), GetSlot(two, ISO_YEAR), GetSlot(two, ISO_MONTH), GetSlot(two, ISO_DAY));\n    }\n}\nMakeIntrinsicClass(PlainDate, 'Temporal.PlainDate');\n\nclass PlainDateTime {\n    constructor(isoYearParam, isoMonthParam, isoDayParam, hourParam = 0, minuteParam = 0, secondParam = 0, millisecondParam = 0, microsecondParam = 0, nanosecondParam = 0, calendarParam = GetISO8601Calendar()) {\n        const isoYear = ToIntegerThrowOnInfinity(isoYearParam);\n        const isoMonth = ToIntegerThrowOnInfinity(isoMonthParam);\n        const isoDay = ToIntegerThrowOnInfinity(isoDayParam);\n        const hour = ToIntegerThrowOnInfinity(hourParam);\n        const minute = ToIntegerThrowOnInfinity(minuteParam);\n        const second = ToIntegerThrowOnInfinity(secondParam);\n        const millisecond = ToIntegerThrowOnInfinity(millisecondParam);\n        const microsecond = ToIntegerThrowOnInfinity(microsecondParam);\n        const nanosecond = ToIntegerThrowOnInfinity(nanosecondParam);\n        const calendar = ToTemporalCalendar(calendarParam);\n        // Note: if the arguments are not passed,\n        //       ToIntegerThrowOnInfinity(undefined) will have returned 0, which will\n        //       be rejected by RejectDateTime in CreateTemporalDateTimeSlots. This\n        //       check exists only to improve the error message.\n        if (arguments.length < 3) {\n            throw new RangeError('missing argument: isoYear, isoMonth and isoDay are required');\n        }\n        CreateTemporalDateTimeSlots(this, isoYear, isoMonth, isoDay, hour, minute, second, millisecond, microsecond, nanosecond, calendar);\n    }\n    get calendar() {\n        if (!IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, CALENDAR);\n    }\n    get year() {\n        if (!IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        return CalendarYear(GetSlot(this, CALENDAR), this);\n    }\n    get month() {\n        if (!IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        return CalendarMonth(GetSlot(this, CALENDAR), this);\n    }\n    get monthCode() {\n        if (!IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        return CalendarMonthCode(GetSlot(this, CALENDAR), this);\n    }\n    get day() {\n        if (!IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        return CalendarDay(GetSlot(this, CALENDAR), this);\n    }\n    get hour() {\n        if (!IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, ISO_HOUR);\n    }\n    get minute() {\n        if (!IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, ISO_MINUTE);\n    }\n    get second() {\n        if (!IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, ISO_SECOND);\n    }\n    get millisecond() {\n        if (!IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, ISO_MILLISECOND);\n    }\n    get microsecond() {\n        if (!IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, ISO_MICROSECOND);\n    }\n    get nanosecond() {\n        if (!IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, ISO_NANOSECOND);\n    }\n    get era() {\n        if (!IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        return CalendarEra(GetSlot(this, CALENDAR), this);\n    }\n    get eraYear() {\n        if (!IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        return CalendarEraYear(GetSlot(this, CALENDAR), this);\n    }\n    get dayOfWeek() {\n        if (!IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        return CalendarDayOfWeek(GetSlot(this, CALENDAR), this);\n    }\n    get dayOfYear() {\n        if (!IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        return CalendarDayOfYear(GetSlot(this, CALENDAR), this);\n    }\n    get weekOfYear() {\n        if (!IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        return CalendarWeekOfYear(GetSlot(this, CALENDAR), this);\n    }\n    get daysInWeek() {\n        if (!IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        return CalendarDaysInWeek(GetSlot(this, CALENDAR), this);\n    }\n    get daysInYear() {\n        if (!IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        return CalendarDaysInYear(GetSlot(this, CALENDAR), this);\n    }\n    get daysInMonth() {\n        if (!IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        return CalendarDaysInMonth(GetSlot(this, CALENDAR), this);\n    }\n    get monthsInYear() {\n        if (!IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        return CalendarMonthsInYear(GetSlot(this, CALENDAR), this);\n    }\n    get inLeapYear() {\n        if (!IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        return CalendarInLeapYear(GetSlot(this, CALENDAR), this);\n    }\n    with(temporalDateTimeLike, optionsParam = undefined) {\n        if (!IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        if (!IsObject(temporalDateTimeLike)) {\n            throw new TypeError('invalid argument');\n        }\n        RejectObjectWithCalendarOrTimeZone(temporalDateTimeLike);\n        const options = GetOptionsObject(optionsParam);\n        const calendar = GetSlot(this, CALENDAR);\n        const fieldNames = CalendarFields(calendar, [\n            'day',\n            'hour',\n            'microsecond',\n            'millisecond',\n            'minute',\n            'month',\n            'monthCode',\n            'nanosecond',\n            'second',\n            'year'\n        ]);\n        const props = ToPartialRecord(temporalDateTimeLike, fieldNames);\n        if (!props) {\n            throw new TypeError('invalid date-time-like');\n        }\n        let fields = ToTemporalDateTimeFields(this, fieldNames);\n        fields = CalendarMergeFields(calendar, fields, props);\n        fields = ToTemporalDateTimeFields(fields, fieldNames);\n        const { year, month, day, hour, minute, second, millisecond, microsecond, nanosecond } = InterpretTemporalDateTimeFields(calendar, fields, options);\n        return CreateTemporalDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar);\n    }\n    withPlainTime(temporalTimeParam = undefined) {\n        if (!IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        const year = GetSlot(this, ISO_YEAR);\n        const month = GetSlot(this, ISO_MONTH);\n        const day = GetSlot(this, ISO_DAY);\n        const calendar = GetSlot(this, CALENDAR);\n        if (temporalTimeParam === undefined)\n            return CreateTemporalDateTime(year, month, day, 0, 0, 0, 0, 0, 0, calendar);\n        const temporalTime = ToTemporalTime(temporalTimeParam);\n        const hour = GetSlot(temporalTime, ISO_HOUR);\n        const minute = GetSlot(temporalTime, ISO_MINUTE);\n        const second = GetSlot(temporalTime, ISO_SECOND);\n        const millisecond = GetSlot(temporalTime, ISO_MILLISECOND);\n        const microsecond = GetSlot(temporalTime, ISO_MICROSECOND);\n        const nanosecond = GetSlot(temporalTime, ISO_NANOSECOND);\n        return CreateTemporalDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar);\n    }\n    withPlainDate(temporalDateParam) {\n        if (!IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        const temporalDate = ToTemporalDate(temporalDateParam);\n        const year = GetSlot(temporalDate, ISO_YEAR);\n        const month = GetSlot(temporalDate, ISO_MONTH);\n        const day = GetSlot(temporalDate, ISO_DAY);\n        let calendar = GetSlot(temporalDate, CALENDAR);\n        const hour = GetSlot(this, ISO_HOUR);\n        const minute = GetSlot(this, ISO_MINUTE);\n        const second = GetSlot(this, ISO_SECOND);\n        const millisecond = GetSlot(this, ISO_MILLISECOND);\n        const microsecond = GetSlot(this, ISO_MICROSECOND);\n        const nanosecond = GetSlot(this, ISO_NANOSECOND);\n        calendar = ConsolidateCalendars(GetSlot(this, CALENDAR), calendar);\n        return CreateTemporalDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar);\n    }\n    withCalendar(calendarParam) {\n        if (!IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        const calendar = ToTemporalCalendar(calendarParam);\n        return new PlainDateTime(GetSlot(this, ISO_YEAR), GetSlot(this, ISO_MONTH), GetSlot(this, ISO_DAY), GetSlot(this, ISO_HOUR), GetSlot(this, ISO_MINUTE), GetSlot(this, ISO_SECOND), GetSlot(this, ISO_MILLISECOND), GetSlot(this, ISO_MICROSECOND), GetSlot(this, ISO_NANOSECOND), calendar);\n    }\n    add(temporalDurationLike, optionsParam = undefined) {\n        if (!IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        const duration = ToLimitedTemporalDuration(temporalDurationLike);\n        const { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = duration;\n        const options = GetOptionsObject(optionsParam);\n        const calendar = GetSlot(this, CALENDAR);\n        const { year, month, day, hour, minute, second, millisecond, microsecond, nanosecond } = AddDateTime(GetSlot(this, ISO_YEAR), GetSlot(this, ISO_MONTH), GetSlot(this, ISO_DAY), GetSlot(this, ISO_HOUR), GetSlot(this, ISO_MINUTE), GetSlot(this, ISO_SECOND), GetSlot(this, ISO_MILLISECOND), GetSlot(this, ISO_MICROSECOND), GetSlot(this, ISO_NANOSECOND), calendar, years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, options);\n        return CreateTemporalDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar);\n    }\n    subtract(temporalDurationLike, optionsParam = undefined) {\n        if (!IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        const duration = ToLimitedTemporalDuration(temporalDurationLike);\n        const { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = duration;\n        const options = GetOptionsObject(optionsParam);\n        const calendar = GetSlot(this, CALENDAR);\n        const { year, month, day, hour, minute, second, millisecond, microsecond, nanosecond } = AddDateTime(GetSlot(this, ISO_YEAR), GetSlot(this, ISO_MONTH), GetSlot(this, ISO_DAY), GetSlot(this, ISO_HOUR), GetSlot(this, ISO_MINUTE), GetSlot(this, ISO_SECOND), GetSlot(this, ISO_MILLISECOND), GetSlot(this, ISO_MICROSECOND), GetSlot(this, ISO_NANOSECOND), calendar, -years, -months, -weeks, -days, -hours, -minutes, -seconds, -milliseconds, -microseconds, -nanoseconds, options);\n        return CreateTemporalDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar);\n    }\n    until(otherParam, optionsParam = undefined) {\n        if (!IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        const other = ToTemporalDateTime(otherParam);\n        const calendar = GetSlot(this, CALENDAR);\n        const otherCalendar = GetSlot(other, CALENDAR);\n        const calendarId = ToString(calendar);\n        const otherCalendarId = ToString(otherCalendar);\n        if (calendarId !== otherCalendarId) {\n            throw new RangeError(`cannot compute difference between dates of ${calendarId} and ${otherCalendarId} calendars`);\n        }\n        const options = GetOptionsObject(optionsParam);\n        const smallestUnit = ToSmallestTemporalUnit(options, 'nanosecond');\n        const defaultLargestUnit = LargerOfTwoTemporalUnits('day', smallestUnit);\n        const largestUnit = ToLargestTemporalUnit(options, 'auto', [], defaultLargestUnit);\n        ValidateTemporalUnitRange(largestUnit, smallestUnit);\n        const roundingMode = ToTemporalRoundingMode(options, 'trunc');\n        const roundingIncrement = ToTemporalDateTimeRoundingIncrement(options, smallestUnit);\n        let { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = DifferenceISODateTime(GetSlot(this, ISO_YEAR), GetSlot(this, ISO_MONTH), GetSlot(this, ISO_DAY), GetSlot(this, ISO_HOUR), GetSlot(this, ISO_MINUTE), GetSlot(this, ISO_SECOND), GetSlot(this, ISO_MILLISECOND), GetSlot(this, ISO_MICROSECOND), GetSlot(this, ISO_NANOSECOND), GetSlot(other, ISO_YEAR), GetSlot(other, ISO_MONTH), GetSlot(other, ISO_DAY), GetSlot(other, ISO_HOUR), GetSlot(other, ISO_MINUTE), GetSlot(other, ISO_SECOND), GetSlot(other, ISO_MILLISECOND), GetSlot(other, ISO_MICROSECOND), GetSlot(other, ISO_NANOSECOND), calendar, largestUnit, options);\n        const relativeTo = TemporalDateTimeToDate(this);\n        ({ years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } =\n            RoundDuration(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, roundingIncrement, smallestUnit, roundingMode, relativeTo));\n        ({ days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = BalanceDuration(days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, largestUnit));\n        const Duration = GetIntrinsic('%Temporal.Duration%');\n        return new Duration(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n    }\n    since(otherParam, optionsParam = undefined) {\n        if (!IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        const other = ToTemporalDateTime(otherParam);\n        const calendar = GetSlot(this, CALENDAR);\n        const otherCalendar = GetSlot(other, CALENDAR);\n        const calendarId = ToString(calendar);\n        const otherCalendarId = ToString(otherCalendar);\n        if (calendarId !== otherCalendarId) {\n            throw new RangeError(`cannot compute difference between dates of ${calendarId} and ${otherCalendarId} calendars`);\n        }\n        const options = GetOptionsObject(optionsParam);\n        const smallestUnit = ToSmallestTemporalUnit(options, 'nanosecond');\n        const defaultLargestUnit = LargerOfTwoTemporalUnits('day', smallestUnit);\n        const largestUnit = ToLargestTemporalUnit(options, 'auto', [], defaultLargestUnit);\n        ValidateTemporalUnitRange(largestUnit, smallestUnit);\n        const roundingMode = ToTemporalRoundingMode(options, 'trunc');\n        const roundingIncrement = ToTemporalDateTimeRoundingIncrement(options, smallestUnit);\n        let { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = DifferenceISODateTime(GetSlot(this, ISO_YEAR), GetSlot(this, ISO_MONTH), GetSlot(this, ISO_DAY), GetSlot(this, ISO_HOUR), GetSlot(this, ISO_MINUTE), GetSlot(this, ISO_SECOND), GetSlot(this, ISO_MILLISECOND), GetSlot(this, ISO_MICROSECOND), GetSlot(this, ISO_NANOSECOND), GetSlot(other, ISO_YEAR), GetSlot(other, ISO_MONTH), GetSlot(other, ISO_DAY), GetSlot(other, ISO_HOUR), GetSlot(other, ISO_MINUTE), GetSlot(other, ISO_SECOND), GetSlot(other, ISO_MILLISECOND), GetSlot(other, ISO_MICROSECOND), GetSlot(other, ISO_NANOSECOND), calendar, largestUnit, options);\n        const relativeTo = TemporalDateTimeToDate(this);\n        ({ years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } =\n            RoundDuration(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, roundingIncrement, smallestUnit, NegateTemporalRoundingMode(roundingMode), relativeTo));\n        ({ days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = BalanceDuration(days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, largestUnit));\n        const Duration = GetIntrinsic('%Temporal.Duration%');\n        return new Duration(-years, -months, -weeks, -days, -hours, -minutes, -seconds, -milliseconds, -microseconds, -nanoseconds);\n    }\n    round(optionsParam) {\n        if (!IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        if (optionsParam === undefined)\n            throw new TypeError('options parameter is required');\n        const options = typeof optionsParam === 'string'\n            ? CreateOnePropObject('smallestUnit', optionsParam)\n            : GetOptionsObject(optionsParam);\n        const smallestUnit = ToSmallestTemporalUnit(options, undefined, ['year', 'month', 'week']);\n        if (smallestUnit === undefined)\n            throw new RangeError('smallestUnit is required');\n        const roundingMode = ToTemporalRoundingMode(options, 'halfExpand');\n        const maximumIncrements = {\n            day: 1,\n            hour: 24,\n            minute: 60,\n            second: 60,\n            millisecond: 1000,\n            microsecond: 1000,\n            nanosecond: 1000\n        };\n        const roundingIncrement = ToTemporalRoundingIncrement(options, maximumIncrements[smallestUnit], false);\n        let year = GetSlot(this, ISO_YEAR);\n        let month = GetSlot(this, ISO_MONTH);\n        let day = GetSlot(this, ISO_DAY);\n        let hour = GetSlot(this, ISO_HOUR);\n        let minute = GetSlot(this, ISO_MINUTE);\n        let second = GetSlot(this, ISO_SECOND);\n        let millisecond = GetSlot(this, ISO_MILLISECOND);\n        let microsecond = GetSlot(this, ISO_MICROSECOND);\n        let nanosecond = GetSlot(this, ISO_NANOSECOND);\n        ({ year, month, day, hour, minute, second, millisecond, microsecond, nanosecond } = RoundISODateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, roundingIncrement, smallestUnit, roundingMode));\n        return CreateTemporalDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, GetSlot(this, CALENDAR));\n    }\n    equals(otherParam) {\n        if (!IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        const other = ToTemporalDateTime(otherParam);\n        for (const slot of [\n            ISO_YEAR,\n            ISO_MONTH,\n            ISO_DAY,\n            ISO_HOUR,\n            ISO_MINUTE,\n            ISO_SECOND,\n            ISO_MILLISECOND,\n            ISO_MICROSECOND,\n            ISO_NANOSECOND\n        ]) {\n            const val1 = GetSlot(this, slot);\n            const val2 = GetSlot(other, slot);\n            if (val1 !== val2)\n                return false;\n        }\n        return CalendarEquals(GetSlot(this, CALENDAR), GetSlot(other, CALENDAR));\n    }\n    toString(optionsParam = undefined) {\n        if (!IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        const options = GetOptionsObject(optionsParam);\n        const { precision, unit, increment } = ToSecondsStringPrecision(options);\n        const showCalendar = ToShowCalendarOption(options);\n        const roundingMode = ToTemporalRoundingMode(options, 'trunc');\n        return TemporalDateTimeToString(this, precision, showCalendar, { unit, increment, roundingMode });\n    }\n    toJSON() {\n        if (!IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        return TemporalDateTimeToString(this, 'auto');\n    }\n    toLocaleString(locales = undefined, options = undefined) {\n        if (!IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        return new DateTimeFormat(locales, options).format(this);\n    }\n    valueOf() {\n        throw new TypeError('use compare() or equals() to compare Temporal.PlainDateTime');\n    }\n    toZonedDateTime(temporalTimeZoneLike, optionsParam = undefined) {\n        if (!IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        const timeZone = ToTemporalTimeZone(temporalTimeZoneLike);\n        const options = GetOptionsObject(optionsParam);\n        const disambiguation = ToTemporalDisambiguation(options);\n        const instant = BuiltinTimeZoneGetInstantFor(timeZone, this, disambiguation);\n        return CreateTemporalZonedDateTime(GetSlot(instant, EPOCHNANOSECONDS), timeZone, GetSlot(this, CALENDAR));\n    }\n    toPlainDate() {\n        if (!IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        return TemporalDateTimeToDate(this);\n    }\n    toPlainYearMonth() {\n        if (!IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        const calendar = GetSlot(this, CALENDAR);\n        const fieldNames = CalendarFields(calendar, ['monthCode', 'year']);\n        const fields = ToTemporalYearMonthFields(this, fieldNames);\n        return YearMonthFromFields(calendar, fields);\n    }\n    toPlainMonthDay() {\n        if (!IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        const calendar = GetSlot(this, CALENDAR);\n        const fieldNames = CalendarFields(calendar, ['day', 'monthCode']);\n        const fields = ToTemporalMonthDayFields(this, fieldNames);\n        return MonthDayFromFields(calendar, fields);\n    }\n    toPlainTime() {\n        if (!IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        return TemporalDateTimeToTime(this);\n    }\n    getISOFields() {\n        if (!IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        return {\n            calendar: GetSlot(this, CALENDAR),\n            isoDay: GetSlot(this, ISO_DAY),\n            isoHour: GetSlot(this, ISO_HOUR),\n            isoMicrosecond: GetSlot(this, ISO_MICROSECOND),\n            isoMillisecond: GetSlot(this, ISO_MILLISECOND),\n            isoMinute: GetSlot(this, ISO_MINUTE),\n            isoMonth: GetSlot(this, ISO_MONTH),\n            isoNanosecond: GetSlot(this, ISO_NANOSECOND),\n            isoSecond: GetSlot(this, ISO_SECOND),\n            isoYear: GetSlot(this, ISO_YEAR)\n        };\n    }\n    static from(item, optionsParam = undefined) {\n        const options = GetOptionsObject(optionsParam);\n        if (IsTemporalDateTime(item)) {\n            ToTemporalOverflow(options); // validate and ignore\n            return CreateTemporalDateTime(GetSlot(item, ISO_YEAR), GetSlot(item, ISO_MONTH), GetSlot(item, ISO_DAY), GetSlot(item, ISO_HOUR), GetSlot(item, ISO_MINUTE), GetSlot(item, ISO_SECOND), GetSlot(item, ISO_MILLISECOND), GetSlot(item, ISO_MICROSECOND), GetSlot(item, ISO_NANOSECOND), GetSlot(item, CALENDAR));\n        }\n        return ToTemporalDateTime(item, options);\n    }\n    static compare(oneParam, twoParam) {\n        const one = ToTemporalDateTime(oneParam);\n        const two = ToTemporalDateTime(twoParam);\n        for (const slot of [\n            ISO_YEAR,\n            ISO_MONTH,\n            ISO_DAY,\n            ISO_HOUR,\n            ISO_MINUTE,\n            ISO_SECOND,\n            ISO_MILLISECOND,\n            ISO_MICROSECOND,\n            ISO_NANOSECOND\n        ]) {\n            const val1 = GetSlot(one, slot);\n            const val2 = GetSlot(two, slot);\n            if (val1 !== val2)\n                return ComparisonResult(val1 - val2);\n        }\n        return 0;\n    }\n}\nMakeIntrinsicClass(PlainDateTime, 'Temporal.PlainDateTime');\n\nclass Duration {\n    constructor(yearsParam = 0, monthsParam = 0, weeksParam = 0, daysParam = 0, hoursParam = 0, minutesParam = 0, secondsParam = 0, millisecondsParam = 0, microsecondsParam = 0, nanosecondsParam = 0) {\n        const years = ToIntegerWithoutRounding(yearsParam);\n        const months = ToIntegerWithoutRounding(monthsParam);\n        const weeks = ToIntegerWithoutRounding(weeksParam);\n        const days = ToIntegerWithoutRounding(daysParam);\n        const hours = ToIntegerWithoutRounding(hoursParam);\n        const minutes = ToIntegerWithoutRounding(minutesParam);\n        const seconds = ToIntegerWithoutRounding(secondsParam);\n        const milliseconds = ToIntegerWithoutRounding(millisecondsParam);\n        const microseconds = ToIntegerWithoutRounding(microsecondsParam);\n        const nanoseconds = ToIntegerWithoutRounding(nanosecondsParam);\n        const sign = DurationSign(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n        for (const prop of [years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds]) {\n            if (!Number.isFinite(prop))\n                throw new RangeError('infinite values not allowed as duration fields');\n            const propSign = Math.sign(prop);\n            if (propSign !== 0 && propSign !== sign)\n                throw new RangeError('mixed-sign values not allowed as duration fields');\n        }\n        CreateSlots(this);\n        SetSlot(this, YEARS, years);\n        SetSlot(this, MONTHS, months);\n        SetSlot(this, WEEKS, weeks);\n        SetSlot(this, DAYS, days);\n        SetSlot(this, HOURS, hours);\n        SetSlot(this, MINUTES, minutes);\n        SetSlot(this, SECONDS, seconds);\n        SetSlot(this, MILLISECONDS, milliseconds);\n        SetSlot(this, MICROSECONDS, microseconds);\n        SetSlot(this, NANOSECONDS, nanoseconds);\n        {\n            Object.defineProperty(this, '_repr_', {\n                value: `${this[Symbol.toStringTag]} <${TemporalDurationToString(this)}>`,\n                writable: false,\n                enumerable: false,\n                configurable: false\n            });\n        }\n    }\n    get years() {\n        if (!IsTemporalDuration(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, YEARS);\n    }\n    get months() {\n        if (!IsTemporalDuration(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, MONTHS);\n    }\n    get weeks() {\n        if (!IsTemporalDuration(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, WEEKS);\n    }\n    get days() {\n        if (!IsTemporalDuration(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, DAYS);\n    }\n    get hours() {\n        if (!IsTemporalDuration(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, HOURS);\n    }\n    get minutes() {\n        if (!IsTemporalDuration(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, MINUTES);\n    }\n    get seconds() {\n        if (!IsTemporalDuration(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, SECONDS);\n    }\n    get milliseconds() {\n        if (!IsTemporalDuration(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, MILLISECONDS);\n    }\n    get microseconds() {\n        if (!IsTemporalDuration(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, MICROSECONDS);\n    }\n    get nanoseconds() {\n        if (!IsTemporalDuration(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, NANOSECONDS);\n    }\n    get sign() {\n        if (!IsTemporalDuration(this))\n            throw new TypeError('invalid receiver');\n        return DurationSign(GetSlot(this, YEARS), GetSlot(this, MONTHS), GetSlot(this, WEEKS), GetSlot(this, DAYS), GetSlot(this, HOURS), GetSlot(this, MINUTES), GetSlot(this, SECONDS), GetSlot(this, MILLISECONDS), GetSlot(this, MICROSECONDS), GetSlot(this, NANOSECONDS));\n    }\n    get blank() {\n        if (!IsTemporalDuration(this))\n            throw new TypeError('invalid receiver');\n        return (DurationSign(GetSlot(this, YEARS), GetSlot(this, MONTHS), GetSlot(this, WEEKS), GetSlot(this, DAYS), GetSlot(this, HOURS), GetSlot(this, MINUTES), GetSlot(this, SECONDS), GetSlot(this, MILLISECONDS), GetSlot(this, MICROSECONDS), GetSlot(this, NANOSECONDS)) === 0);\n    }\n    with(durationLike) {\n        if (!IsTemporalDuration(this))\n            throw new TypeError('invalid receiver');\n        const props = ToPartialRecord(durationLike, [\n            'days',\n            'hours',\n            'microseconds',\n            'milliseconds',\n            'minutes',\n            'months',\n            'nanoseconds',\n            'seconds',\n            'weeks',\n            'years'\n        ]);\n        if (!props) {\n            throw new TypeError('invalid duration-like');\n        }\n        const { years = GetSlot(this, YEARS), months = GetSlot(this, MONTHS), weeks = GetSlot(this, WEEKS), days = GetSlot(this, DAYS), hours = GetSlot(this, HOURS), minutes = GetSlot(this, MINUTES), seconds = GetSlot(this, SECONDS), milliseconds = GetSlot(this, MILLISECONDS), microseconds = GetSlot(this, MICROSECONDS), nanoseconds = GetSlot(this, NANOSECONDS) } = props;\n        return new Duration(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n    }\n    negated() {\n        if (!IsTemporalDuration(this))\n            throw new TypeError('invalid receiver');\n        return CreateNegatedTemporalDuration(this);\n    }\n    abs() {\n        if (!IsTemporalDuration(this))\n            throw new TypeError('invalid receiver');\n        return new Duration(Math.abs(GetSlot(this, YEARS)), Math.abs(GetSlot(this, MONTHS)), Math.abs(GetSlot(this, WEEKS)), Math.abs(GetSlot(this, DAYS)), Math.abs(GetSlot(this, HOURS)), Math.abs(GetSlot(this, MINUTES)), Math.abs(GetSlot(this, SECONDS)), Math.abs(GetSlot(this, MILLISECONDS)), Math.abs(GetSlot(this, MICROSECONDS)), Math.abs(GetSlot(this, NANOSECONDS)));\n    }\n    add(other, optionsParam = undefined) {\n        if (!IsTemporalDuration(this))\n            throw new TypeError('invalid receiver');\n        let { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = ToLimitedTemporalDuration(other);\n        const options = GetOptionsObject(optionsParam);\n        const relativeTo = ToRelativeTemporalObject(options);\n        ({ years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = AddDuration(GetSlot(this, YEARS), GetSlot(this, MONTHS), GetSlot(this, WEEKS), GetSlot(this, DAYS), GetSlot(this, HOURS), GetSlot(this, MINUTES), GetSlot(this, SECONDS), GetSlot(this, MILLISECONDS), GetSlot(this, MICROSECONDS), GetSlot(this, NANOSECONDS), years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, relativeTo));\n        return new Duration(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n    }\n    subtract(other, optionsParam = undefined) {\n        if (!IsTemporalDuration(this))\n            throw new TypeError('invalid receiver');\n        let { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = ToLimitedTemporalDuration(other);\n        const options = GetOptionsObject(optionsParam);\n        const relativeTo = ToRelativeTemporalObject(options);\n        ({ years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = AddDuration(GetSlot(this, YEARS), GetSlot(this, MONTHS), GetSlot(this, WEEKS), GetSlot(this, DAYS), GetSlot(this, HOURS), GetSlot(this, MINUTES), GetSlot(this, SECONDS), GetSlot(this, MILLISECONDS), GetSlot(this, MICROSECONDS), GetSlot(this, NANOSECONDS), -years, -months, -weeks, -days, -hours, -minutes, -seconds, -milliseconds, -microseconds, -nanoseconds, relativeTo));\n        return new Duration(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n    }\n    round(optionsParam) {\n        if (!IsTemporalDuration(this))\n            throw new TypeError('invalid receiver');\n        if (optionsParam === undefined)\n            throw new TypeError('options parameter is required');\n        let years = GetSlot(this, YEARS);\n        let months = GetSlot(this, MONTHS);\n        let weeks = GetSlot(this, WEEKS);\n        let days = GetSlot(this, DAYS);\n        let hours = GetSlot(this, HOURS);\n        let minutes = GetSlot(this, MINUTES);\n        let seconds = GetSlot(this, SECONDS);\n        let milliseconds = GetSlot(this, MILLISECONDS);\n        let microseconds = GetSlot(this, MICROSECONDS);\n        let nanoseconds = GetSlot(this, NANOSECONDS);\n        let defaultLargestUnit = DefaultTemporalLargestUnit(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n        const options = typeof optionsParam === 'string'\n            ? CreateOnePropObject('smallestUnit', optionsParam)\n            : GetOptionsObject(optionsParam);\n        let smallestUnit = ToSmallestTemporalUnit(options, undefined);\n        let smallestUnitPresent = true;\n        if (!smallestUnit) {\n            smallestUnitPresent = false;\n            smallestUnit = 'nanosecond';\n        }\n        defaultLargestUnit = LargerOfTwoTemporalUnits(defaultLargestUnit, smallestUnit);\n        let largestUnit = ToLargestTemporalUnit(options, undefined);\n        let largestUnitPresent = true;\n        if (!largestUnit) {\n            largestUnitPresent = false;\n            largestUnit = defaultLargestUnit;\n        }\n        if (largestUnit === 'auto')\n            largestUnit = defaultLargestUnit;\n        if (!smallestUnitPresent && !largestUnitPresent) {\n            throw new RangeError('at least one of smallestUnit or largestUnit is required');\n        }\n        ValidateTemporalUnitRange(largestUnit, smallestUnit);\n        const roundingMode = ToTemporalRoundingMode(options, 'halfExpand');\n        const roundingIncrement = ToTemporalDateTimeRoundingIncrement(options, smallestUnit);\n        let relativeTo = ToRelativeTemporalObject(options);\n        ({ years, months, weeks, days } = UnbalanceDurationRelative(years, months, weeks, days, largestUnit, relativeTo));\n        ({ years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } =\n            RoundDuration(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, roundingIncrement, smallestUnit, roundingMode, relativeTo));\n        ({ years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } =\n            AdjustRoundedDurationDays(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, roundingIncrement, smallestUnit, roundingMode, relativeTo));\n        ({ years, months, weeks, days } = BalanceDurationRelative(years, months, weeks, days, largestUnit, relativeTo));\n        if (IsTemporalZonedDateTime(relativeTo)) {\n            relativeTo = MoveRelativeZonedDateTime(relativeTo, years, months, weeks, 0);\n        }\n        ({ days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = BalanceDuration(days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, largestUnit, relativeTo));\n        return new Duration(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n    }\n    total(optionsParam) {\n        if (!IsTemporalDuration(this))\n            throw new TypeError('invalid receiver');\n        let years = GetSlot(this, YEARS);\n        let months = GetSlot(this, MONTHS);\n        let weeks = GetSlot(this, WEEKS);\n        let days = GetSlot(this, DAYS);\n        let hours = GetSlot(this, HOURS);\n        let minutes = GetSlot(this, MINUTES);\n        let seconds = GetSlot(this, SECONDS);\n        let milliseconds = GetSlot(this, MILLISECONDS);\n        let microseconds = GetSlot(this, MICROSECONDS);\n        let nanoseconds = GetSlot(this, NANOSECONDS);\n        if (optionsParam === undefined)\n            throw new TypeError('options argument is required');\n        const options = typeof optionsParam === 'string'\n            ? CreateOnePropObject('unit', optionsParam)\n            : GetOptionsObject(optionsParam);\n        const unit = ToTemporalDurationTotalUnit(options);\n        if (unit === undefined)\n            throw new RangeError('unit option is required');\n        const relativeTo = ToRelativeTemporalObject(options);\n        // Convert larger units down to days\n        ({ years, months, weeks, days } = UnbalanceDurationRelative(years, months, weeks, days, unit, relativeTo));\n        // If the unit we're totalling is smaller than `days`, convert days down to that unit.\n        let intermediate;\n        if (IsTemporalZonedDateTime(relativeTo)) {\n            intermediate = MoveRelativeZonedDateTime(relativeTo, years, months, weeks, 0);\n        }\n        ({ days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = BalanceDuration(days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, unit, intermediate));\n        // Finally, truncate to the correct unit and calculate remainder\n        const { total } = RoundDuration(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, 1, unit, 'trunc', relativeTo);\n        return total;\n    }\n    toString(optionsParam = undefined) {\n        if (!IsTemporalDuration(this))\n            throw new TypeError('invalid receiver');\n        const options = GetOptionsObject(optionsParam);\n        const { precision, unit, increment } = ToSecondsStringPrecision(options);\n        if (precision === 'minute')\n            throw new RangeError('smallestUnit must not be \"minute\"');\n        const roundingMode = ToTemporalRoundingMode(options, 'trunc');\n        return TemporalDurationToString(this, precision, { unit, increment, roundingMode });\n    }\n    toJSON() {\n        if (!IsTemporalDuration(this))\n            throw new TypeError('invalid receiver');\n        return TemporalDurationToString(this);\n    }\n    toLocaleString(locales = undefined, options = undefined) {\n        if (!IsTemporalDuration(this))\n            throw new TypeError('invalid receiver');\n        if (typeof Intl !== 'undefined' && typeof Intl.DurationFormat !== 'undefined') {\n            return new Intl.DurationFormat(locales, options).format(this);\n        }\n        console.warn('Temporal.Duration.prototype.toLocaleString() requires Intl.DurationFormat.');\n        return TemporalDurationToString(this);\n    }\n    valueOf() {\n        throw new TypeError('use compare() to compare Temporal.Duration');\n    }\n    static from(item) {\n        if (IsTemporalDuration(item)) {\n            return new Duration(GetSlot(item, YEARS), GetSlot(item, MONTHS), GetSlot(item, WEEKS), GetSlot(item, DAYS), GetSlot(item, HOURS), GetSlot(item, MINUTES), GetSlot(item, SECONDS), GetSlot(item, MILLISECONDS), GetSlot(item, MICROSECONDS), GetSlot(item, NANOSECONDS));\n        }\n        return ToTemporalDuration(item);\n    }\n    static compare(oneParam, twoParam, optionsParam = undefined) {\n        const one = ToTemporalDuration(oneParam);\n        const two = ToTemporalDuration(twoParam);\n        const options = GetOptionsObject(optionsParam);\n        const relativeTo = ToRelativeTemporalObject(options);\n        const y1 = GetSlot(one, YEARS);\n        const mon1 = GetSlot(one, MONTHS);\n        const w1 = GetSlot(one, WEEKS);\n        let d1 = GetSlot(one, DAYS);\n        const h1 = GetSlot(one, HOURS);\n        const min1 = GetSlot(one, MINUTES);\n        const s1 = GetSlot(one, SECONDS);\n        const ms1 = GetSlot(one, MILLISECONDS);\n        const s1 = GetSlot(one, MICROSECONDS);\n        let ns1 = GetSlot(one, NANOSECONDS);\n        const y2 = GetSlot(two, YEARS);\n        const mon2 = GetSlot(two, MONTHS);\n        const w2 = GetSlot(two, WEEKS);\n        let d2 = GetSlot(two, DAYS);\n        const h2 = GetSlot(two, HOURS);\n        const min2 = GetSlot(two, MINUTES);\n        const s2 = GetSlot(two, SECONDS);\n        const ms2 = GetSlot(two, MILLISECONDS);\n        const s2 = GetSlot(two, MICROSECONDS);\n        let ns2 = GetSlot(two, NANOSECONDS);\n        const shift1 = CalculateOffsetShift(relativeTo, y1, mon1, w1, d1, h1, min1, s1, ms1, s1, ns1);\n        const shift2 = CalculateOffsetShift(relativeTo, y2, mon2, w2, d2, h2, min2, s2, ms2, s2, ns2);\n        if (y1 !== 0 || y2 !== 0 || mon1 !== 0 || mon2 !== 0 || w1 !== 0 || w2 !== 0) {\n            ({ days: d1 } = UnbalanceDurationRelative(y1, mon1, w1, d1, 'day', relativeTo));\n            ({ days: d2 } = UnbalanceDurationRelative(y2, mon2, w2, d2, 'day', relativeTo));\n        }\n        const totalNs1 = TotalDurationNanoseconds(d1, h1, min1, s1, ms1, s1, ns1, shift1);\n        const totalNs2 = TotalDurationNanoseconds(d2, h2, min2, s2, ms2, s2, ns2, shift2);\n        return ComparisonResult(jsbi__WEBPACK_IMPORTED_MODULE_0__.toNumber(jsbi__WEBPACK_IMPORTED_MODULE_0__.subtract(totalNs1, totalNs2)));\n    }\n}\nMakeIntrinsicClass(Duration, 'Temporal.Duration');\n\nconst ObjectCreate$1 = Object.create;\nclass PlainMonthDay {\n    constructor(isoMonthParam, isoDayParam, calendarParam = GetISO8601Calendar(), referenceISOYearParam = 1972) {\n        const isoMonth = ToIntegerThrowOnInfinity(isoMonthParam);\n        const isoDay = ToIntegerThrowOnInfinity(isoDayParam);\n        const calendar = ToTemporalCalendar(calendarParam);\n        const referenceISOYear = ToIntegerThrowOnInfinity(referenceISOYearParam);\n        // Note: if the arguments are not passed,\n        //       ToIntegerThrowOnInfinity(undefined) will have returned 0, which will\n        //       be rejected by RejectISODate in CreateTemporalMonthDaySlots. This\n        //       check exists only to improve the error message.\n        if (arguments.length < 2) {\n            throw new RangeError('missing argument: isoMonth and isoDay are required');\n        }\n        CreateTemporalMonthDaySlots(this, isoMonth, isoDay, calendar, referenceISOYear);\n    }\n    get monthCode() {\n        if (!IsTemporalMonthDay(this))\n            throw new TypeError('invalid receiver');\n        return CalendarMonthCode(GetSlot(this, CALENDAR), this);\n    }\n    get day() {\n        if (!IsTemporalMonthDay(this))\n            throw new TypeError('invalid receiver');\n        return CalendarDay(GetSlot(this, CALENDAR), this);\n    }\n    get calendar() {\n        if (!IsTemporalMonthDay(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, CALENDAR);\n    }\n    with(temporalMonthDayLike, optionsParam = undefined) {\n        if (!IsTemporalMonthDay(this))\n            throw new TypeError('invalid receiver');\n        if (!IsObject(temporalMonthDayLike)) {\n            throw new TypeError('invalid argument');\n        }\n        RejectObjectWithCalendarOrTimeZone(temporalMonthDayLike);\n        const calendar = GetSlot(this, CALENDAR);\n        const fieldNames = CalendarFields(calendar, ['day', 'month', 'monthCode', 'year']);\n        const props = ToPartialRecord(temporalMonthDayLike, fieldNames);\n        if (!props) {\n            throw new TypeError('invalid month-day-like');\n        }\n        let fields = ToTemporalMonthDayFields(this, fieldNames);\n        fields = CalendarMergeFields(calendar, fields, props);\n        fields = ToTemporalMonthDayFields(fields, fieldNames);\n        const options = GetOptionsObject(optionsParam);\n        return MonthDayFromFields(calendar, fields, options);\n    }\n    equals(otherParam) {\n        if (!IsTemporalMonthDay(this))\n            throw new TypeError('invalid receiver');\n        const other = ToTemporalMonthDay(otherParam);\n        for (const slot of [ISO_MONTH, ISO_DAY, ISO_YEAR]) {\n            const val1 = GetSlot(this, slot);\n            const val2 = GetSlot(other, slot);\n            if (val1 !== val2)\n                return false;\n        }\n        return CalendarEquals(GetSlot(this, CALENDAR), GetSlot(other, CALENDAR));\n    }\n    toString(optionsParam = undefined) {\n        if (!IsTemporalMonthDay(this))\n            throw new TypeError('invalid receiver');\n        const options = GetOptionsObject(optionsParam);\n        const showCalendar = ToShowCalendarOption(options);\n        return TemporalMonthDayToString(this, showCalendar);\n    }\n    toJSON() {\n        if (!IsTemporalMonthDay(this))\n            throw new TypeError('invalid receiver');\n        return TemporalMonthDayToString(this);\n    }\n    toLocaleString(locales = undefined, options = undefined) {\n        if (!IsTemporalMonthDay(this))\n            throw new TypeError('invalid receiver');\n        return new DateTimeFormat(locales, options).format(this);\n    }\n    valueOf() {\n        throw new TypeError('use equals() to compare Temporal.PlainMonthDay');\n    }\n    toPlainDate(item) {\n        if (!IsTemporalMonthDay(this))\n            throw new TypeError('invalid receiver');\n        if (!IsObject(item))\n            throw new TypeError('argument should be an object');\n        const calendar = GetSlot(this, CALENDAR);\n        const receiverFieldNames = CalendarFields(calendar, ['day', 'monthCode']);\n        const fields = ToTemporalMonthDayFields(this, receiverFieldNames);\n        const inputFieldNames = CalendarFields(calendar, ['year']);\n        const inputEntries = [['year', undefined]];\n        // Add extra fields from the calendar at the end\n        inputFieldNames.forEach((fieldName) => {\n            if (!inputEntries.some(([name]) => name === fieldName)) {\n                inputEntries.push([fieldName, undefined]); // Make TS ignore extra fields\n            }\n        });\n        const inputFields = PrepareTemporalFields(item, inputEntries);\n        let mergedFields = CalendarMergeFields(calendar, fields, inputFields);\n        const mergedFieldNames = [...new Set([...receiverFieldNames, ...inputFieldNames])];\n        const mergedEntries = [];\n        mergedFieldNames.forEach((fieldName) => {\n            if (!mergedEntries.some(([name]) => name === fieldName)) {\n                mergedEntries.push([fieldName, undefined]);\n            }\n        });\n        mergedFields = PrepareTemporalFields(mergedFields, mergedEntries);\n        const options = ObjectCreate$1(null);\n        options.overflow = 'reject';\n        return DateFromFields(calendar, mergedFields, options);\n    }\n    getISOFields() {\n        if (!IsTemporalMonthDay(this))\n            throw new TypeError('invalid receiver');\n        return {\n            calendar: GetSlot(this, CALENDAR),\n            isoDay: GetSlot(this, ISO_DAY),\n            isoMonth: GetSlot(this, ISO_MONTH),\n            isoYear: GetSlot(this, ISO_YEAR)\n        };\n    }\n    static from(item, optionsParam = undefined) {\n        const options = GetOptionsObject(optionsParam);\n        if (IsTemporalMonthDay(item)) {\n            ToTemporalOverflow(options); // validate and ignore\n            return CreateTemporalMonthDay(GetSlot(item, ISO_MONTH), GetSlot(item, ISO_DAY), GetSlot(item, CALENDAR), GetSlot(item, ISO_YEAR));\n        }\n        return ToTemporalMonthDay(item, options);\n    }\n}\nMakeIntrinsicClass(PlainMonthDay, 'Temporal.PlainMonthDay');\n\nconst instant = () => {\n    const Instant = GetIntrinsic('%Temporal.Instant%');\n    return new Instant(SystemUTCEpochNanoSeconds());\n};\nconst plainDateTime = (calendarLike, temporalTimeZoneLike = timeZone()) => {\n    const tZ = ToTemporalTimeZone(temporalTimeZoneLike);\n    const calendar = ToTemporalCalendar(calendarLike);\n    const inst = instant();\n    return BuiltinTimeZoneGetPlainDateTimeFor(tZ, inst, calendar);\n};\nconst plainDateTimeISO = (temporalTimeZoneLike = timeZone()) => {\n    const tZ = ToTemporalTimeZone(temporalTimeZoneLike);\n    const calendar = GetISO8601Calendar();\n    const inst = instant();\n    return BuiltinTimeZoneGetPlainDateTimeFor(tZ, inst, calendar);\n};\nconst zonedDateTime = (calendarLike, temporalTimeZoneLike = timeZone()) => {\n    const tZ = ToTemporalTimeZone(temporalTimeZoneLike);\n    const calendar = ToTemporalCalendar(calendarLike);\n    return CreateTemporalZonedDateTime(SystemUTCEpochNanoSeconds(), tZ, calendar);\n};\nconst zonedDateTimeISO = (temporalTimeZoneLike = timeZone()) => {\n    return zonedDateTime(GetISO8601Calendar(), temporalTimeZoneLike);\n};\nconst plainDate = (calendarLike, temporalTimeZoneLike = timeZone()) => {\n    return TemporalDateTimeToDate(plainDateTime(calendarLike, temporalTimeZoneLike));\n};\nconst plainDateISO = (temporalTimeZoneLike = timeZone()) => {\n    return TemporalDateTimeToDate(plainDateTimeISO(temporalTimeZoneLike));\n};\nconst plainTimeISO = (temporalTimeZoneLike = timeZone()) => {\n    return TemporalDateTimeToTime(plainDateTimeISO(temporalTimeZoneLike));\n};\nconst timeZone = () => {\n    return SystemTimeZone();\n};\nconst Now = {\n    instant,\n    plainDateTime,\n    plainDateTimeISO,\n    plainDate,\n    plainDateISO,\n    plainTimeISO,\n    timeZone,\n    zonedDateTime,\n    zonedDateTimeISO,\n    [Symbol.toStringTag]: 'Temporal.Now'\n};\nObject.defineProperty(Now, Symbol.toStringTag, {\n    value: 'Temporal.Now',\n    writable: false,\n    enumerable: false,\n    configurable: true\n});\n\nconst ObjectAssign = Object.assign;\nconst DISALLOWED_UNITS$1 = ['year', 'month', 'week', 'day'];\nconst MAX_INCREMENTS = {\n    hour: 24,\n    minute: 60,\n    second: 60,\n    millisecond: 1000,\n    microsecond: 1000,\n    nanosecond: 1000\n};\nfunction TemporalTimeToString(time, precision, options = undefined) {\n    let hour = GetSlot(time, ISO_HOUR);\n    let minute = GetSlot(time, ISO_MINUTE);\n    let second = GetSlot(time, ISO_SECOND);\n    let millisecond = GetSlot(time, ISO_MILLISECOND);\n    let microsecond = GetSlot(time, ISO_MICROSECOND);\n    let nanosecond = GetSlot(time, ISO_NANOSECOND);\n    if (options) {\n        const { unit, increment, roundingMode } = options;\n        ({ hour, minute, second, millisecond, microsecond, nanosecond } = RoundTime(hour, minute, second, millisecond, microsecond, nanosecond, increment, unit, roundingMode));\n    }\n    const hourString = ISODateTimePartString(hour);\n    const minuteString = ISODateTimePartString(minute);\n    const seconds = FormatSecondsStringPart(second, millisecond, microsecond, nanosecond, precision);\n    return `${hourString}:${minuteString}${seconds}`;\n}\nclass PlainTime {\n    constructor(isoHourParam = 0, isoMinuteParam = 0, isoSecondParam = 0, isoMillisecondParam = 0, isoMicrosecondParam = 0, isoNanosecondParam = 0) {\n        const isoHour = ToIntegerThrowOnInfinity(isoHourParam);\n        const isoMinute = ToIntegerThrowOnInfinity(isoMinuteParam);\n        const isoSecond = ToIntegerThrowOnInfinity(isoSecondParam);\n        const isoMillisecond = ToIntegerThrowOnInfinity(isoMillisecondParam);\n        const isoMicrosecond = ToIntegerThrowOnInfinity(isoMicrosecondParam);\n        const isoNanosecond = ToIntegerThrowOnInfinity(isoNanosecondParam);\n        RejectTime(isoHour, isoMinute, isoSecond, isoMillisecond, isoMicrosecond, isoNanosecond);\n        CreateSlots(this);\n        SetSlot(this, ISO_HOUR, isoHour);\n        SetSlot(this, ISO_MINUTE, isoMinute);\n        SetSlot(this, ISO_SECOND, isoSecond);\n        SetSlot(this, ISO_MILLISECOND, isoMillisecond);\n        SetSlot(this, ISO_MICROSECOND, isoMicrosecond);\n        SetSlot(this, ISO_NANOSECOND, isoNanosecond);\n        SetSlot(this, CALENDAR, GetISO8601Calendar());\n        {\n            Object.defineProperty(this, '_repr_', {\n                value: `${this[Symbol.toStringTag]} <${TemporalTimeToString(this, 'auto')}>`,\n                writable: false,\n                enumerable: false,\n                configurable: false\n            });\n        }\n    }\n    get calendar() {\n        if (!IsTemporalTime(this))\n            throw new TypeError('invalid receiver');\n        // PlainTime's calendar isn't settable, so can't be a userland calendar\n        return GetSlot(this, CALENDAR);\n    }\n    get hour() {\n        if (!IsTemporalTime(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, ISO_HOUR);\n    }\n    get minute() {\n        if (!IsTemporalTime(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, ISO_MINUTE);\n    }\n    get second() {\n        if (!IsTemporalTime(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, ISO_SECOND);\n    }\n    get millisecond() {\n        if (!IsTemporalTime(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, ISO_MILLISECOND);\n    }\n    get microsecond() {\n        if (!IsTemporalTime(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, ISO_MICROSECOND);\n    }\n    get nanosecond() {\n        if (!IsTemporalTime(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, ISO_NANOSECOND);\n    }\n    with(temporalTimeLike, optionsParam = undefined) {\n        if (!IsTemporalTime(this))\n            throw new TypeError('invalid receiver');\n        if (!IsObject(temporalTimeLike)) {\n            throw new TypeError('invalid argument');\n        }\n        RejectObjectWithCalendarOrTimeZone(temporalTimeLike);\n        const options = GetOptionsObject(optionsParam);\n        const overflow = ToTemporalOverflow(options);\n        const props = ToPartialRecord(temporalTimeLike, [\n            'hour',\n            'microsecond',\n            'millisecond',\n            'minute',\n            'nanosecond',\n            'second'\n        ]);\n        if (!props) {\n            throw new TypeError('invalid time-like');\n        }\n        const fields = ToTemporalTimeRecord(this);\n        let { hour, minute, second, millisecond, microsecond, nanosecond } = ObjectAssign(fields, props);\n        ({ hour, minute, second, millisecond, microsecond, nanosecond } = RegulateTime(hour, minute, second, millisecond, microsecond, nanosecond, overflow));\n        return new PlainTime(hour, minute, second, millisecond, microsecond, nanosecond);\n    }\n    add(temporalDurationLike) {\n        if (!IsTemporalTime(this))\n            throw new TypeError('invalid receiver');\n        const duration = ToLimitedTemporalDuration(temporalDurationLike);\n        const { hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = duration;\n        let hour = GetSlot(this, ISO_HOUR);\n        let minute = GetSlot(this, ISO_MINUTE);\n        let second = GetSlot(this, ISO_SECOND);\n        let millisecond = GetSlot(this, ISO_MILLISECOND);\n        let microsecond = GetSlot(this, ISO_MICROSECOND);\n        let nanosecond = GetSlot(this, ISO_NANOSECOND);\n        ({ hour, minute, second, millisecond, microsecond, nanosecond } = AddTime(hour, minute, second, millisecond, microsecond, nanosecond, hours, minutes, seconds, milliseconds, microseconds, nanoseconds));\n        ({ hour, minute, second, millisecond, microsecond, nanosecond } = RegulateTime(hour, minute, second, millisecond, microsecond, nanosecond, 'reject'));\n        return new PlainTime(hour, minute, second, millisecond, microsecond, nanosecond);\n    }\n    subtract(temporalDurationLike) {\n        if (!IsTemporalTime(this))\n            throw new TypeError('invalid receiver');\n        const duration = ToLimitedTemporalDuration(temporalDurationLike);\n        const { hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = duration;\n        let hour = GetSlot(this, ISO_HOUR);\n        let minute = GetSlot(this, ISO_MINUTE);\n        let second = GetSlot(this, ISO_SECOND);\n        let millisecond = GetSlot(this, ISO_MILLISECOND);\n        let microsecond = GetSlot(this, ISO_MICROSECOND);\n        let nanosecond = GetSlot(this, ISO_NANOSECOND);\n        ({ hour, minute, second, millisecond, microsecond, nanosecond } = AddTime(hour, minute, second, millisecond, microsecond, nanosecond, -hours, -minutes, -seconds, -milliseconds, -microseconds, -nanoseconds));\n        ({ hour, minute, second, millisecond, microsecond, nanosecond } = RegulateTime(hour, minute, second, millisecond, microsecond, nanosecond, 'reject'));\n        return new PlainTime(hour, minute, second, millisecond, microsecond, nanosecond);\n    }\n    until(otherParam, optionsParam = undefined) {\n        if (!IsTemporalTime(this))\n            throw new TypeError('invalid receiver');\n        const other = ToTemporalTime(otherParam);\n        const options = GetOptionsObject(optionsParam);\n        const largestUnit = ToLargestTemporalUnit(options, 'auto', DISALLOWED_UNITS$1, 'hour');\n        const smallestUnit = ToSmallestTemporalUnit(options, 'nanosecond', DISALLOWED_UNITS$1);\n        ValidateTemporalUnitRange(largestUnit, smallestUnit);\n        const roundingMode = ToTemporalRoundingMode(options, 'trunc');\n        const roundingIncrement = ToTemporalRoundingIncrement(options, MAX_INCREMENTS[smallestUnit], false);\n        let { hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = DifferenceTime(GetSlot(this, ISO_HOUR), GetSlot(this, ISO_MINUTE), GetSlot(this, ISO_SECOND), GetSlot(this, ISO_MILLISECOND), GetSlot(this, ISO_MICROSECOND), GetSlot(this, ISO_NANOSECOND), GetSlot(other, ISO_HOUR), GetSlot(other, ISO_MINUTE), GetSlot(other, ISO_SECOND), GetSlot(other, ISO_MILLISECOND), GetSlot(other, ISO_MICROSECOND), GetSlot(other, ISO_NANOSECOND));\n        ({ hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = RoundDuration(0, 0, 0, 0, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, roundingIncrement, smallestUnit, roundingMode));\n        ({ hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = BalanceDuration(0, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, largestUnit));\n        const Duration = GetIntrinsic('%Temporal.Duration%');\n        return new Duration(0, 0, 0, 0, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n    }\n    since(otherParam, optionsParam = undefined) {\n        if (!IsTemporalTime(this))\n            throw new TypeError('invalid receiver');\n        const other = ToTemporalTime(otherParam);\n        const options = GetOptionsObject(optionsParam);\n        const largestUnit = ToLargestTemporalUnit(options, 'auto', DISALLOWED_UNITS$1, 'hour');\n        const smallestUnit = ToSmallestTemporalUnit(options, 'nanosecond', DISALLOWED_UNITS$1);\n        ValidateTemporalUnitRange(largestUnit, smallestUnit);\n        const roundingMode = ToTemporalRoundingMode(options, 'trunc');\n        const roundingIncrement = ToTemporalRoundingIncrement(options, MAX_INCREMENTS[smallestUnit], false);\n        let { hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = DifferenceTime(GetSlot(other, ISO_HOUR), GetSlot(other, ISO_MINUTE), GetSlot(other, ISO_SECOND), GetSlot(other, ISO_MILLISECOND), GetSlot(other, ISO_MICROSECOND), GetSlot(other, ISO_NANOSECOND), GetSlot(this, ISO_HOUR), GetSlot(this, ISO_MINUTE), GetSlot(this, ISO_SECOND), GetSlot(this, ISO_MILLISECOND), GetSlot(this, ISO_MICROSECOND), GetSlot(this, ISO_NANOSECOND));\n        ({ hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = RoundDuration(0, 0, 0, 0, -hours, -minutes, -seconds, -milliseconds, -microseconds, -nanoseconds, roundingIncrement, smallestUnit, NegateTemporalRoundingMode(roundingMode)));\n        hours = -hours;\n        minutes = -minutes;\n        seconds = -seconds;\n        milliseconds = -milliseconds;\n        microseconds = -microseconds;\n        nanoseconds = -nanoseconds;\n        ({ hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = BalanceDuration(0, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, largestUnit));\n        const Duration = GetIntrinsic('%Temporal.Duration%');\n        return new Duration(0, 0, 0, 0, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n    }\n    round(optionsParam) {\n        if (!IsTemporalTime(this))\n            throw new TypeError('invalid receiver');\n        if (optionsParam === undefined)\n            throw new TypeError('options parameter is required');\n        const options = typeof optionsParam === 'string'\n            ? CreateOnePropObject('smallestUnit', optionsParam)\n            : GetOptionsObject(optionsParam);\n        const smallestUnit = ToSmallestTemporalUnit(options, undefined, DISALLOWED_UNITS$1);\n        if (smallestUnit === undefined)\n            throw new RangeError('smallestUnit is required');\n        const roundingMode = ToTemporalRoundingMode(options, 'halfExpand');\n        const roundingIncrement = ToTemporalRoundingIncrement(options, MAX_INCREMENTS[smallestUnit], false);\n        let hour = GetSlot(this, ISO_HOUR);\n        let minute = GetSlot(this, ISO_MINUTE);\n        let second = GetSlot(this, ISO_SECOND);\n        let millisecond = GetSlot(this, ISO_MILLISECOND);\n        let microsecond = GetSlot(this, ISO_MICROSECOND);\n        let nanosecond = GetSlot(this, ISO_NANOSECOND);\n        ({ hour, minute, second, millisecond, microsecond, nanosecond } = RoundTime(hour, minute, second, millisecond, microsecond, nanosecond, roundingIncrement, smallestUnit, roundingMode));\n        return new PlainTime(hour, minute, second, millisecond, microsecond, nanosecond);\n    }\n    equals(otherParam) {\n        if (!IsTemporalTime(this))\n            throw new TypeError('invalid receiver');\n        const other = ToTemporalTime(otherParam);\n        for (const slot of [ISO_HOUR, ISO_MINUTE, ISO_SECOND, ISO_MILLISECOND, ISO_MICROSECOND, ISO_NANOSECOND]) {\n            const val1 = GetSlot(this, slot);\n            const val2 = GetSlot(other, slot);\n            if (val1 !== val2)\n                return false;\n        }\n        return true;\n    }\n    toString(optionsParam = undefined) {\n        if (!IsTemporalTime(this))\n            throw new TypeError('invalid receiver');\n        const options = GetOptionsObject(optionsParam);\n        const { precision, unit, increment } = ToSecondsStringPrecision(options);\n        const roundingMode = ToTemporalRoundingMode(options, 'trunc');\n        return TemporalTimeToString(this, precision, { unit, increment, roundingMode });\n    }\n    toJSON() {\n        if (!IsTemporalTime(this))\n            throw new TypeError('invalid receiver');\n        return TemporalTimeToString(this, 'auto');\n    }\n    toLocaleString(locales = undefined, options = undefined) {\n        if (!IsTemporalTime(this))\n            throw new TypeError('invalid receiver');\n        return new DateTimeFormat(locales, options).format(this);\n    }\n    valueOf() {\n        throw new TypeError('use compare() or equals() to compare Temporal.PlainTime');\n    }\n    toPlainDateTime(temporalDateParam) {\n        if (!IsTemporalTime(this))\n            throw new TypeError('invalid receiver');\n        const temporalDate = ToTemporalDate(temporalDateParam);\n        const year = GetSlot(temporalDate, ISO_YEAR);\n        const month = GetSlot(temporalDate, ISO_MONTH);\n        const day = GetSlot(temporalDate, ISO_DAY);\n        const calendar = GetSlot(temporalDate, CALENDAR);\n        const hour = GetSlot(this, ISO_HOUR);\n        const minute = GetSlot(this, ISO_MINUTE);\n        const second = GetSlot(this, ISO_SECOND);\n        const millisecond = GetSlot(this, ISO_MILLISECOND);\n        const microsecond = GetSlot(this, ISO_MICROSECOND);\n        const nanosecond = GetSlot(this, ISO_NANOSECOND);\n        return CreateTemporalDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar);\n    }\n    toZonedDateTime(item) {\n        if (!IsTemporalTime(this))\n            throw new TypeError('invalid receiver');\n        if (!IsObject(item)) {\n            throw new TypeError('invalid argument');\n        }\n        const dateLike = item.plainDate;\n        if (dateLike === undefined) {\n            throw new TypeError('missing date property');\n        }\n        const temporalDate = ToTemporalDate(dateLike);\n        const timeZoneLike = item.timeZone;\n        if (timeZoneLike === undefined) {\n            throw new TypeError('missing timeZone property');\n        }\n        const timeZone = ToTemporalTimeZone(timeZoneLike);\n        const year = GetSlot(temporalDate, ISO_YEAR);\n        const month = GetSlot(temporalDate, ISO_MONTH);\n        const day = GetSlot(temporalDate, ISO_DAY);\n        const calendar = GetSlot(temporalDate, CALENDAR);\n        const hour = GetSlot(this, ISO_HOUR);\n        const minute = GetSlot(this, ISO_MINUTE);\n        const second = GetSlot(this, ISO_SECOND);\n        const millisecond = GetSlot(this, ISO_MILLISECOND);\n        const microsecond = GetSlot(this, ISO_MICROSECOND);\n        const nanosecond = GetSlot(this, ISO_NANOSECOND);\n        const PlainDateTime = GetIntrinsic('%Temporal.PlainDateTime%');\n        const dt = new PlainDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar);\n        const instant = BuiltinTimeZoneGetInstantFor(timeZone, dt, 'compatible');\n        return CreateTemporalZonedDateTime(GetSlot(instant, EPOCHNANOSECONDS), timeZone, calendar);\n    }\n    getISOFields() {\n        if (!IsTemporalTime(this))\n            throw new TypeError('invalid receiver');\n        return {\n            calendar: GetSlot(this, CALENDAR),\n            isoHour: GetSlot(this, ISO_HOUR),\n            isoMicrosecond: GetSlot(this, ISO_MICROSECOND),\n            isoMillisecond: GetSlot(this, ISO_MILLISECOND),\n            isoMinute: GetSlot(this, ISO_MINUTE),\n            isoNanosecond: GetSlot(this, ISO_NANOSECOND),\n            isoSecond: GetSlot(this, ISO_SECOND)\n        };\n    }\n    static from(item, optionsParam = undefined) {\n        const options = GetOptionsObject(optionsParam);\n        const overflow = ToTemporalOverflow(options);\n        if (IsTemporalTime(item)) {\n            return new PlainTime(GetSlot(item, ISO_HOUR), GetSlot(item, ISO_MINUTE), GetSlot(item, ISO_SECOND), GetSlot(item, ISO_MILLISECOND), GetSlot(item, ISO_MICROSECOND), GetSlot(item, ISO_NANOSECOND));\n        }\n        return ToTemporalTime(item, overflow);\n    }\n    static compare(oneParam, twoParam) {\n        const one = ToTemporalTime(oneParam);\n        const two = ToTemporalTime(twoParam);\n        for (const slot of [ISO_HOUR, ISO_MINUTE, ISO_SECOND, ISO_MILLISECOND, ISO_MICROSECOND, ISO_NANOSECOND]) {\n            const val1 = GetSlot(one, slot);\n            const val2 = GetSlot(two, slot);\n            if (val1 !== val2)\n                return ComparisonResult(val1 - val2);\n        }\n        return 0;\n    }\n}\nMakeIntrinsicClass(PlainTime, 'Temporal.PlainTime');\n\nclass TimeZone {\n    constructor(timeZoneIdentifierParam) {\n        // Note: if the argument is not passed, GetCanonicalTimeZoneIdentifier(undefined) will throw.\n        //       This check exists only to improve the error message.\n        if (arguments.length < 1) {\n            throw new RangeError('missing argument: identifier is required');\n        }\n        const timeZoneIdentifier = GetCanonicalTimeZoneIdentifier(timeZoneIdentifierParam);\n        CreateSlots(this);\n        SetSlot(this, TIMEZONE_ID, timeZoneIdentifier);\n        {\n            Object.defineProperty(this, '_repr_', {\n                value: `${this[Symbol.toStringTag]} <${timeZoneIdentifier}>`,\n                writable: false,\n                enumerable: false,\n                configurable: false\n            });\n        }\n    }\n    get id() {\n        if (!IsTemporalTimeZone(this))\n            throw new TypeError('invalid receiver');\n        return ToString(this);\n    }\n    getOffsetNanosecondsFor(instantParam) {\n        if (!IsTemporalTimeZone(this))\n            throw new TypeError('invalid receiver');\n        const instant = ToTemporalInstant(instantParam);\n        const id = GetSlot(this, TIMEZONE_ID);\n        if (TestTimeZoneOffsetString(id)) {\n            return ParseTimeZoneOffsetString(id);\n        }\n        return GetIANATimeZoneOffsetNanoseconds(GetSlot(instant, EPOCHNANOSECONDS), id);\n    }\n    getOffsetStringFor(instantParam) {\n        if (!IsTemporalTimeZone(this))\n            throw new TypeError('invalid receiver');\n        const instant = ToTemporalInstant(instantParam);\n        return BuiltinTimeZoneGetOffsetStringFor(this, instant);\n    }\n    getPlainDateTimeFor(instantParam, calendarParam = GetISO8601Calendar()) {\n        const instant = ToTemporalInstant(instantParam);\n        const calendar = ToTemporalCalendar(calendarParam);\n        return BuiltinTimeZoneGetPlainDateTimeFor(this, instant, calendar);\n    }\n    getInstantFor(dateTimeParam, optionsParam = undefined) {\n        if (!IsTemporalTimeZone(this))\n            throw new TypeError('invalid receiver');\n        const dateTime = ToTemporalDateTime(dateTimeParam);\n        const options = GetOptionsObject(optionsParam);\n        const disambiguation = ToTemporalDisambiguation(options);\n        return BuiltinTimeZoneGetInstantFor(this, dateTime, disambiguation);\n    }\n    getPossibleInstantsFor(dateTimeParam) {\n        if (!IsTemporalTimeZone(this))\n            throw new TypeError('invalid receiver');\n        const dateTime = ToTemporalDateTime(dateTimeParam);\n        const Instant = GetIntrinsic('%Temporal.Instant%');\n        const id = GetSlot(this, TIMEZONE_ID);\n        if (TestTimeZoneOffsetString(id)) {\n            const epochNs = GetEpochFromISOParts(GetSlot(dateTime, ISO_YEAR), GetSlot(dateTime, ISO_MONTH), GetSlot(dateTime, ISO_DAY), GetSlot(dateTime, ISO_HOUR), GetSlot(dateTime, ISO_MINUTE), GetSlot(dateTime, ISO_SECOND), GetSlot(dateTime, ISO_MILLISECOND), GetSlot(dateTime, ISO_MICROSECOND), GetSlot(dateTime, ISO_NANOSECOND));\n            if (epochNs === null)\n                throw new RangeError('DateTime outside of supported range');\n            const offsetNs = ParseTimeZoneOffsetString(id);\n            return [new Instant(jsbi__WEBPACK_IMPORTED_MODULE_0__.subtract(epochNs, jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(offsetNs)))];\n        }\n        const possibleEpochNs = GetIANATimeZoneEpochValue(id, GetSlot(dateTime, ISO_YEAR), GetSlot(dateTime, ISO_MONTH), GetSlot(dateTime, ISO_DAY), GetSlot(dateTime, ISO_HOUR), GetSlot(dateTime, ISO_MINUTE), GetSlot(dateTime, ISO_SECOND), GetSlot(dateTime, ISO_MILLISECOND), GetSlot(dateTime, ISO_MICROSECOND), GetSlot(dateTime, ISO_NANOSECOND));\n        return possibleEpochNs.map((ns) => new Instant(ns));\n    }\n    getNextTransition(startingPointParam) {\n        if (!IsTemporalTimeZone(this))\n            throw new TypeError('invalid receiver');\n        const startingPoint = ToTemporalInstant(startingPointParam);\n        const id = GetSlot(this, TIMEZONE_ID);\n        // Offset time zones or UTC have no transitions\n        if (TestTimeZoneOffsetString(id) || id === 'UTC') {\n            return null;\n        }\n        let epochNanoseconds = GetSlot(startingPoint, EPOCHNANOSECONDS);\n        const Instant = GetIntrinsic('%Temporal.Instant%');\n        epochNanoseconds = GetIANATimeZoneNextTransition(epochNanoseconds, id);\n        return epochNanoseconds === null ? null : new Instant(epochNanoseconds);\n    }\n    getPreviousTransition(startingPointParam) {\n        if (!IsTemporalTimeZone(this))\n            throw new TypeError('invalid receiver');\n        const startingPoint = ToTemporalInstant(startingPointParam);\n        const id = GetSlot(this, TIMEZONE_ID);\n        // Offset time zones or UTC have no transitions\n        if (TestTimeZoneOffsetString(id) || id === 'UTC') {\n            return null;\n        }\n        let epochNanoseconds = GetSlot(startingPoint, EPOCHNANOSECONDS);\n        const Instant = GetIntrinsic('%Temporal.Instant%');\n        epochNanoseconds = GetIANATimeZonePreviousTransition(epochNanoseconds, id);\n        return epochNanoseconds === null ? null : new Instant(epochNanoseconds);\n    }\n    toString() {\n        if (!IsTemporalTimeZone(this))\n            throw new TypeError('invalid receiver');\n        return ToString(GetSlot(this, TIMEZONE_ID));\n    }\n    toJSON() {\n        if (!IsTemporalTimeZone(this))\n            throw new TypeError('invalid receiver');\n        return ToString(this);\n    }\n    static from(item) {\n        return ToTemporalTimeZone(item);\n    }\n}\nMakeIntrinsicClass(TimeZone, 'Temporal.TimeZone');\n\nconst ObjectCreate = Object.create;\nconst DISALLOWED_UNITS = [\n    'week',\n    'day',\n    'hour',\n    'minute',\n    'second',\n    'millisecond',\n    'microsecond',\n    'nanosecond'\n];\nclass PlainYearMonth {\n    constructor(isoYearParam, isoMonthParam, calendarParam = GetISO8601Calendar(), referenceISODayParam = 1) {\n        const isoYear = ToIntegerThrowOnInfinity(isoYearParam);\n        const isoMonth = ToIntegerThrowOnInfinity(isoMonthParam);\n        const calendar = ToTemporalCalendar(calendarParam);\n        const referenceISODay = ToIntegerThrowOnInfinity(referenceISODayParam);\n        // Note: if the arguments are not passed,\n        //       ToIntegerThrowOnInfinity(undefined) will have returned 0, which will\n        //       be rejected by RejectISODate in CreateTemporalYearMonthSlots. This\n        //       check exists only to improve the error message.\n        if (arguments.length < 2) {\n            throw new RangeError('missing argument: isoYear and isoMonth are required');\n        }\n        CreateTemporalYearMonthSlots(this, isoYear, isoMonth, calendar, referenceISODay);\n    }\n    get year() {\n        if (!IsTemporalYearMonth(this))\n            throw new TypeError('invalid receiver');\n        return CalendarYear(GetSlot(this, CALENDAR), this);\n    }\n    get month() {\n        if (!IsTemporalYearMonth(this))\n            throw new TypeError('invalid receiver');\n        return CalendarMonth(GetSlot(this, CALENDAR), this);\n    }\n    get monthCode() {\n        if (!IsTemporalYearMonth(this))\n            throw new TypeError('invalid receiver');\n        return CalendarMonthCode(GetSlot(this, CALENDAR), this);\n    }\n    get calendar() {\n        if (!IsTemporalYearMonth(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, CALENDAR);\n    }\n    get era() {\n        if (!IsTemporalYearMonth(this))\n            throw new TypeError('invalid receiver');\n        return CalendarEra(GetSlot(this, CALENDAR), this);\n    }\n    get eraYear() {\n        if (!IsTemporalYearMonth(this))\n            throw new TypeError('invalid receiver');\n        return CalendarEraYear(GetSlot(this, CALENDAR), this);\n    }\n    get daysInMonth() {\n        if (!IsTemporalYearMonth(this))\n            throw new TypeError('invalid receiver');\n        return CalendarDaysInMonth(GetSlot(this, CALENDAR), this);\n    }\n    get daysInYear() {\n        if (!IsTemporalYearMonth(this))\n            throw new TypeError('invalid receiver');\n        return CalendarDaysInYear(GetSlot(this, CALENDAR), this);\n    }\n    get monthsInYear() {\n        if (!IsTemporalYearMonth(this))\n            throw new TypeError('invalid receiver');\n        return CalendarMonthsInYear(GetSlot(this, CALENDAR), this);\n    }\n    get inLeapYear() {\n        if (!IsTemporalYearMonth(this))\n            throw new TypeError('invalid receiver');\n        return CalendarInLeapYear(GetSlot(this, CALENDAR), this);\n    }\n    with(temporalYearMonthLike, optionsParam = undefined) {\n        if (!IsTemporalYearMonth(this))\n            throw new TypeError('invalid receiver');\n        if (!IsObject(temporalYearMonthLike)) {\n            throw new TypeError('invalid argument');\n        }\n        RejectObjectWithCalendarOrTimeZone(temporalYearMonthLike);\n        const calendar = GetSlot(this, CALENDAR);\n        const fieldNames = CalendarFields(calendar, ['month', 'monthCode', 'year']);\n        const props = ToPartialRecord(temporalYearMonthLike, fieldNames);\n        if (!props) {\n            throw new TypeError('invalid year-month-like');\n        }\n        let fields = ToTemporalYearMonthFields(this, fieldNames);\n        fields = CalendarMergeFields(calendar, fields, props);\n        fields = ToTemporalYearMonthFields(fields, fieldNames);\n        const options = GetOptionsObject(optionsParam);\n        return YearMonthFromFields(calendar, fields, options);\n    }\n    add(temporalDurationLike, optionsParam = undefined) {\n        if (!IsTemporalYearMonth(this))\n            throw new TypeError('invalid receiver');\n        const duration = ToLimitedTemporalDuration(temporalDurationLike);\n        let { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = duration;\n        ({ days } = BalanceDuration(days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, 'day'));\n        const options = GetOptionsObject(optionsParam);\n        const calendar = GetSlot(this, CALENDAR);\n        const fieldNames = CalendarFields(calendar, ['monthCode', 'year']);\n        const fields = ToTemporalYearMonthFields(this, fieldNames);\n        const sign = DurationSign(years, months, weeks, days, 0, 0, 0, 0, 0, 0);\n        const day = sign < 0 ? ToPositiveInteger(CalendarDaysInMonth(calendar, this)) : 1;\n        const startDate = DateFromFields(calendar, { ...fields, day });\n        const optionsCopy = { ...options };\n        const addedDate = CalendarDateAdd(calendar, startDate, { ...duration, days }, options);\n        const addedDateFields = ToTemporalYearMonthFields(addedDate, fieldNames);\n        return YearMonthFromFields(calendar, addedDateFields, optionsCopy);\n    }\n    subtract(temporalDurationLike, optionsParam = undefined) {\n        if (!IsTemporalYearMonth(this))\n            throw new TypeError('invalid receiver');\n        let duration = ToLimitedTemporalDuration(temporalDurationLike);\n        duration = {\n            years: -duration.years,\n            months: -duration.months,\n            weeks: -duration.weeks,\n            days: -duration.days,\n            hours: -duration.hours,\n            minutes: -duration.minutes,\n            seconds: -duration.seconds,\n            milliseconds: -duration.milliseconds,\n            microseconds: -duration.microseconds,\n            nanoseconds: -duration.nanoseconds\n        };\n        let { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = duration;\n        ({ days } = BalanceDuration(days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, 'day'));\n        const options = GetOptionsObject(optionsParam);\n        const calendar = GetSlot(this, CALENDAR);\n        const fieldNames = CalendarFields(calendar, ['monthCode', 'year']);\n        const fields = ToTemporalYearMonthFields(this, fieldNames);\n        const sign = DurationSign(years, months, weeks, days, 0, 0, 0, 0, 0, 0);\n        const day = sign < 0 ? ToPositiveInteger(CalendarDaysInMonth(calendar, this)) : 1;\n        const startDate = DateFromFields(calendar, { ...fields, day });\n        const optionsCopy = { ...options };\n        const addedDate = CalendarDateAdd(calendar, startDate, { ...duration, days }, options);\n        const addedDateFields = ToTemporalYearMonthFields(addedDate, fieldNames);\n        return YearMonthFromFields(calendar, addedDateFields, optionsCopy);\n    }\n    until(otherParam, optionsParam = undefined) {\n        if (!IsTemporalYearMonth(this))\n            throw new TypeError('invalid receiver');\n        const other = ToTemporalYearMonth(otherParam);\n        const calendar = GetSlot(this, CALENDAR);\n        const otherCalendar = GetSlot(other, CALENDAR);\n        const calendarID = ToString(calendar);\n        const otherCalendarID = ToString(otherCalendar);\n        if (calendarID !== otherCalendarID) {\n            throw new RangeError(`cannot compute difference between months of ${calendarID} and ${otherCalendarID} calendars`);\n        }\n        const options = GetOptionsObject(optionsParam);\n        const smallestUnit = ToSmallestTemporalUnit(options, 'month', DISALLOWED_UNITS);\n        const largestUnit = ToLargestTemporalUnit(options, 'auto', DISALLOWED_UNITS, 'year');\n        ValidateTemporalUnitRange(largestUnit, smallestUnit);\n        const roundingMode = ToTemporalRoundingMode(options, 'trunc');\n        const roundingIncrement = ToTemporalRoundingIncrement(options, undefined, false);\n        const fieldNames = CalendarFields(calendar, ['monthCode', 'year']);\n        const otherFields = ToTemporalYearMonthFields(other, fieldNames);\n        const thisFields = ToTemporalYearMonthFields(this, fieldNames);\n        const otherDate = DateFromFields(calendar, { ...otherFields, day: 1 });\n        const thisDate = DateFromFields(calendar, { ...thisFields, day: 1 });\n        const untilOptions = { ...options, largestUnit };\n        const result = CalendarDateUntil(calendar, thisDate, otherDate, untilOptions);\n        if (smallestUnit === 'month' && roundingIncrement === 1)\n            return result;\n        let { years, months } = result;\n        ({ years, months } = RoundDuration(years, months, 0, 0, 0, 0, 0, 0, 0, 0, roundingIncrement, smallestUnit, roundingMode, thisDate));\n        const Duration = GetIntrinsic('%Temporal.Duration%');\n        return new Duration(years, months, 0, 0, 0, 0, 0, 0, 0, 0);\n    }\n    since(otherParam, optionsParam = undefined) {\n        if (!IsTemporalYearMonth(this))\n            throw new TypeError('invalid receiver');\n        const other = ToTemporalYearMonth(otherParam);\n        const calendar = GetSlot(this, CALENDAR);\n        const otherCalendar = GetSlot(other, CALENDAR);\n        const calendarID = ToString(calendar);\n        const otherCalendarID = ToString(otherCalendar);\n        if (calendarID !== otherCalendarID) {\n            throw new RangeError(`cannot compute difference between months of ${calendarID} and ${otherCalendarID} calendars`);\n        }\n        const options = GetOptionsObject(optionsParam);\n        const smallestUnit = ToSmallestTemporalUnit(options, 'month', DISALLOWED_UNITS);\n        const largestUnit = ToLargestTemporalUnit(options, 'auto', DISALLOWED_UNITS, 'year');\n        ValidateTemporalUnitRange(largestUnit, smallestUnit);\n        const roundingMode = ToTemporalRoundingMode(options, 'trunc');\n        const roundingIncrement = ToTemporalRoundingIncrement(options, undefined, false);\n        const fieldNames = CalendarFields(calendar, ['monthCode', 'year']);\n        const otherFields = ToTemporalYearMonthFields(other, fieldNames);\n        const thisFields = ToTemporalYearMonthFields(this, fieldNames);\n        const otherDate = DateFromFields(calendar, { ...otherFields, day: 1 });\n        const thisDate = DateFromFields(calendar, { ...thisFields, day: 1 });\n        const untilOptions = { ...options, largestUnit };\n        let { years, months } = CalendarDateUntil(calendar, thisDate, otherDate, untilOptions);\n        const Duration = GetIntrinsic('%Temporal.Duration%');\n        if (smallestUnit === 'month' && roundingIncrement === 1) {\n            return new Duration(-years, -months, 0, 0, 0, 0, 0, 0, 0, 0);\n        }\n        ({ years, months } = RoundDuration(years, months, 0, 0, 0, 0, 0, 0, 0, 0, roundingIncrement, smallestUnit, NegateTemporalRoundingMode(roundingMode), thisDate));\n        return new Duration(-years, -months, 0, 0, 0, 0, 0, 0, 0, 0);\n    }\n    equals(otherParam) {\n        if (!IsTemporalYearMonth(this))\n            throw new TypeError('invalid receiver');\n        const other = ToTemporalYearMonth(otherParam);\n        for (const slot of [ISO_YEAR, ISO_MONTH, ISO_DAY]) {\n            const val1 = GetSlot(this, slot);\n            const val2 = GetSlot(other, slot);\n            if (val1 !== val2)\n                return false;\n        }\n        return CalendarEquals(GetSlot(this, CALENDAR), GetSlot(other, CALENDAR));\n    }\n    toString(optionsParam = undefined) {\n        if (!IsTemporalYearMonth(this))\n            throw new TypeError('invalid receiver');\n        const options = GetOptionsObject(optionsParam);\n        const showCalendar = ToShowCalendarOption(options);\n        return TemporalYearMonthToString(this, showCalendar);\n    }\n    toJSON() {\n        if (!IsTemporalYearMonth(this))\n            throw new TypeError('invalid receiver');\n        return TemporalYearMonthToString(this);\n    }\n    toLocaleString(locales = undefined, options = undefined) {\n        if (!IsTemporalYearMonth(this))\n            throw new TypeError('invalid receiver');\n        return new DateTimeFormat(locales, options).format(this);\n    }\n    valueOf() {\n        throw new TypeError('use compare() or equals() to compare Temporal.PlainYearMonth');\n    }\n    toPlainDate(item) {\n        if (!IsTemporalYearMonth(this))\n            throw new TypeError('invalid receiver');\n        if (!IsObject(item))\n            throw new TypeError('argument should be an object');\n        const calendar = GetSlot(this, CALENDAR);\n        const receiverFieldNames = CalendarFields(calendar, ['monthCode', 'year']);\n        const fields = ToTemporalYearMonthFields(this, receiverFieldNames);\n        const inputFieldNames = CalendarFields(calendar, ['day']);\n        const inputEntries = [['day']];\n        // Add extra fields from the calendar at the end\n        inputFieldNames.forEach((fieldName) => {\n            if (!inputEntries.some(([name]) => name === fieldName)) {\n                inputEntries.push([\n                    fieldName,\n                    undefined\n                ]); // Make TS ignore extra fields\n            }\n        });\n        const inputFields = PrepareTemporalFields(item, inputEntries);\n        let mergedFields = CalendarMergeFields(calendar, fields, inputFields);\n        const mergedFieldNames = [...new Set([...receiverFieldNames, ...inputFieldNames])];\n        const mergedEntries = [];\n        mergedFieldNames.forEach((fieldName) => {\n            if (!mergedEntries.some(([name]) => name === fieldName)) {\n                mergedEntries.push([fieldName, undefined]);\n            }\n        });\n        mergedFields = PrepareTemporalFields(mergedFields, mergedEntries);\n        const options = ObjectCreate(null);\n        options.overflow = 'reject';\n        return DateFromFields(calendar, mergedFields, options);\n    }\n    getISOFields() {\n        if (!IsTemporalYearMonth(this))\n            throw new TypeError('invalid receiver');\n        return {\n            calendar: GetSlot(this, CALENDAR),\n            isoDay: GetSlot(this, ISO_DAY),\n            isoMonth: GetSlot(this, ISO_MONTH),\n            isoYear: GetSlot(this, ISO_YEAR)\n        };\n    }\n    static from(item, optionsParam = undefined) {\n        const options = GetOptionsObject(optionsParam);\n        if (IsTemporalYearMonth(item)) {\n            ToTemporalOverflow(options); // validate and ignore\n            return CreateTemporalYearMonth(GetSlot(item, ISO_YEAR), GetSlot(item, ISO_MONTH), GetSlot(item, CALENDAR), GetSlot(item, ISO_DAY));\n        }\n        return ToTemporalYearMonth(item, options);\n    }\n    static compare(oneParam, twoParam) {\n        const one = ToTemporalYearMonth(oneParam);\n        const two = ToTemporalYearMonth(twoParam);\n        return CompareISODate(GetSlot(one, ISO_YEAR), GetSlot(one, ISO_MONTH), GetSlot(one, ISO_DAY), GetSlot(two, ISO_YEAR), GetSlot(two, ISO_MONTH), GetSlot(two, ISO_DAY));\n    }\n}\nMakeIntrinsicClass(PlainYearMonth, 'Temporal.PlainYearMonth');\n\nconst ArrayPrototypePush = Array.prototype.push;\nclass ZonedDateTime {\n    constructor(epochNanosecondsParam, timeZoneParam, calendarParam = GetISO8601Calendar()) {\n        // Note: if the argument is not passed, ToBigInt(undefined) will throw. This check exists only\n        //       to improve the error message.\n        //       ToTemporalTimeZone(undefined) will end up calling TimeZone.from(\"undefined\"), which\n        //       could succeed.\n        if (arguments.length < 1) {\n            throw new TypeError('missing argument: epochNanoseconds is required');\n        }\n        const epochNanoseconds = ToBigInt(epochNanosecondsParam);\n        const timeZone = ToTemporalTimeZone(timeZoneParam);\n        const calendar = ToTemporalCalendar(calendarParam);\n        CreateTemporalZonedDateTimeSlots(this, epochNanoseconds, timeZone, calendar);\n    }\n    get calendar() {\n        if (!IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, CALENDAR);\n    }\n    get timeZone() {\n        if (!IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, TIME_ZONE);\n    }\n    get year() {\n        if (!IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return CalendarYear(GetSlot(this, CALENDAR), dateTime(this));\n    }\n    get month() {\n        if (!IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return CalendarMonth(GetSlot(this, CALENDAR), dateTime(this));\n    }\n    get monthCode() {\n        if (!IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return CalendarMonthCode(GetSlot(this, CALENDAR), dateTime(this));\n    }\n    get day() {\n        if (!IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return CalendarDay(GetSlot(this, CALENDAR), dateTime(this));\n    }\n    get hour() {\n        if (!IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(dateTime(this), ISO_HOUR);\n    }\n    get minute() {\n        if (!IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(dateTime(this), ISO_MINUTE);\n    }\n    get second() {\n        if (!IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(dateTime(this), ISO_SECOND);\n    }\n    get millisecond() {\n        if (!IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(dateTime(this), ISO_MILLISECOND);\n    }\n    get microsecond() {\n        if (!IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(dateTime(this), ISO_MICROSECOND);\n    }\n    get nanosecond() {\n        if (!IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(dateTime(this), ISO_NANOSECOND);\n    }\n    get era() {\n        if (!IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return CalendarEra(GetSlot(this, CALENDAR), dateTime(this));\n    }\n    get eraYear() {\n        if (!IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return CalendarEraYear(GetSlot(this, CALENDAR), dateTime(this));\n    }\n    get epochSeconds() {\n        if (!IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        const value = GetSlot(this, EPOCHNANOSECONDS);\n        return jsbi__WEBPACK_IMPORTED_MODULE_0__.toNumber(jsbi__WEBPACK_IMPORTED_MODULE_0__.divide(value, BILLION));\n    }\n    get epochMilliseconds() {\n        if (!IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        const value = GetSlot(this, EPOCHNANOSECONDS);\n        return jsbi__WEBPACK_IMPORTED_MODULE_0__.toNumber(jsbi__WEBPACK_IMPORTED_MODULE_0__.divide(value, MILLION));\n    }\n    get epochMicroseconds() {\n        if (!IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        const value = GetSlot(this, EPOCHNANOSECONDS);\n        return ToBigIntExternal(jsbi__WEBPACK_IMPORTED_MODULE_0__.divide(value, THOUSAND));\n    }\n    get epochNanoseconds() {\n        if (!IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return ToBigIntExternal(GetSlot(this, EPOCHNANOSECONDS));\n    }\n    get dayOfWeek() {\n        if (!IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return CalendarDayOfWeek(GetSlot(this, CALENDAR), dateTime(this));\n    }\n    get dayOfYear() {\n        if (!IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return CalendarDayOfYear(GetSlot(this, CALENDAR), dateTime(this));\n    }\n    get weekOfYear() {\n        if (!IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return CalendarWeekOfYear(GetSlot(this, CALENDAR), dateTime(this));\n    }\n    get hoursInDay() {\n        if (!IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        const dt = dateTime(this);\n        const DateTime = GetIntrinsic('%Temporal.PlainDateTime%');\n        const year = GetSlot(dt, ISO_YEAR);\n        const month = GetSlot(dt, ISO_MONTH);\n        const day = GetSlot(dt, ISO_DAY);\n        const today = new DateTime(year, month, day, 0, 0, 0, 0, 0, 0);\n        const tomorrowFields = AddISODate(year, month, day, 0, 0, 0, 1, 'reject');\n        const tomorrow = new DateTime(tomorrowFields.year, tomorrowFields.month, tomorrowFields.day, 0, 0, 0, 0, 0, 0);\n        const timeZone = GetSlot(this, TIME_ZONE);\n        const todayNs = GetSlot(BuiltinTimeZoneGetInstantFor(timeZone, today, 'compatible'), EPOCHNANOSECONDS);\n        const tomorrowNs = GetSlot(BuiltinTimeZoneGetInstantFor(timeZone, tomorrow, 'compatible'), EPOCHNANOSECONDS);\n        return jsbi__WEBPACK_IMPORTED_MODULE_0__.toNumber(jsbi__WEBPACK_IMPORTED_MODULE_0__.subtract(tomorrowNs, todayNs)) / 3.6e12;\n    }\n    get daysInWeek() {\n        if (!IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return CalendarDaysInWeek(GetSlot(this, CALENDAR), dateTime(this));\n    }\n    get daysInMonth() {\n        if (!IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return CalendarDaysInMonth(GetSlot(this, CALENDAR), dateTime(this));\n    }\n    get daysInYear() {\n        if (!IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return CalendarDaysInYear(GetSlot(this, CALENDAR), dateTime(this));\n    }\n    get monthsInYear() {\n        if (!IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return CalendarMonthsInYear(GetSlot(this, CALENDAR), dateTime(this));\n    }\n    get inLeapYear() {\n        if (!IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return CalendarInLeapYear(GetSlot(this, CALENDAR), dateTime(this));\n    }\n    get offset() {\n        if (!IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return BuiltinTimeZoneGetOffsetStringFor(GetSlot(this, TIME_ZONE), GetSlot(this, INSTANT));\n    }\n    get offsetNanoseconds() {\n        if (!IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return GetOffsetNanosecondsFor(GetSlot(this, TIME_ZONE), GetSlot(this, INSTANT));\n    }\n    with(temporalZonedDateTimeLike, optionsParam = undefined) {\n        if (!IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        if (!IsObject(temporalZonedDateTimeLike)) {\n            throw new TypeError('invalid zoned-date-time-like');\n        }\n        RejectObjectWithCalendarOrTimeZone(temporalZonedDateTimeLike);\n        const options = GetOptionsObject(optionsParam);\n        const disambiguation = ToTemporalDisambiguation(options);\n        const offset = ToTemporalOffset(options, 'prefer');\n        const timeZone = GetSlot(this, TIME_ZONE);\n        const calendar = GetSlot(this, CALENDAR);\n        const fieldNames = CalendarFields(calendar, [\n            'day',\n            'hour',\n            'microsecond',\n            'millisecond',\n            'minute',\n            'month',\n            'monthCode',\n            'nanosecond',\n            'second',\n            'year'\n        ]);\n        ArrayPrototypePush.call(fieldNames, 'offset');\n        const props = ToPartialRecord(temporalZonedDateTimeLike, fieldNames);\n        if (!props) {\n            throw new TypeError('invalid zoned-date-time-like');\n        }\n        // Unlike ToTemporalZonedDateTimeFields, the offset property will be required.\n        const entries = [\n            ['day', undefined],\n            ['hour', 0],\n            ['microsecond', 0],\n            ['millisecond', 0],\n            ['minute', 0],\n            ['month', undefined],\n            ['monthCode', undefined],\n            ['nanosecond', 0],\n            ['second', 0],\n            ['year', undefined],\n            ['offset'],\n            ['timeZone']\n        ];\n        // Add extra fields from the calendar at the end\n        fieldNames.forEach((fieldName) => {\n            if (!entries.some(([name]) => name === fieldName)) {\n                entries.push([fieldName, undefined]);\n            }\n        });\n        let fields = PrepareTemporalFields(this, entries);\n        fields = CalendarMergeFields(calendar, fields, props);\n        fields = PrepareTemporalFields(fields, entries);\n        const { year, month, day, hour, minute, second, millisecond, microsecond, nanosecond } = InterpretTemporalDateTimeFields(calendar, fields, options);\n        const offsetNs = ParseTimeZoneOffsetString(fields.offset);\n        const epochNanoseconds = InterpretISODateTimeOffset(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, 'option', offsetNs, timeZone, disambiguation, offset, \n        /* matchMinute = */ false);\n        return CreateTemporalZonedDateTime(epochNanoseconds, GetSlot(this, TIME_ZONE), calendar);\n    }\n    withPlainDate(temporalDateParam) {\n        if (!IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        const temporalDate = ToTemporalDate(temporalDateParam);\n        const year = GetSlot(temporalDate, ISO_YEAR);\n        const month = GetSlot(temporalDate, ISO_MONTH);\n        const day = GetSlot(temporalDate, ISO_DAY);\n        let calendar = GetSlot(temporalDate, CALENDAR);\n        const thisDt = dateTime(this);\n        const hour = GetSlot(thisDt, ISO_HOUR);\n        const minute = GetSlot(thisDt, ISO_MINUTE);\n        const second = GetSlot(thisDt, ISO_SECOND);\n        const millisecond = GetSlot(thisDt, ISO_MILLISECOND);\n        const microsecond = GetSlot(thisDt, ISO_MICROSECOND);\n        const nanosecond = GetSlot(thisDt, ISO_NANOSECOND);\n        calendar = ConsolidateCalendars(GetSlot(this, CALENDAR), calendar);\n        const timeZone = GetSlot(this, TIME_ZONE);\n        const PlainDateTime = GetIntrinsic('%Temporal.PlainDateTime%');\n        const dt = new PlainDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar);\n        const instant = BuiltinTimeZoneGetInstantFor(timeZone, dt, 'compatible');\n        return CreateTemporalZonedDateTime(GetSlot(instant, EPOCHNANOSECONDS), timeZone, calendar);\n    }\n    withPlainTime(temporalTimeParam = undefined) {\n        if (!IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        const PlainTime = GetIntrinsic('%Temporal.PlainTime%');\n        const temporalTime = temporalTimeParam == undefined ? new PlainTime() : ToTemporalTime(temporalTimeParam);\n        const thisDt = dateTime(this);\n        const year = GetSlot(thisDt, ISO_YEAR);\n        const month = GetSlot(thisDt, ISO_MONTH);\n        const day = GetSlot(thisDt, ISO_DAY);\n        const calendar = GetSlot(this, CALENDAR);\n        const hour = GetSlot(temporalTime, ISO_HOUR);\n        const minute = GetSlot(temporalTime, ISO_MINUTE);\n        const second = GetSlot(temporalTime, ISO_SECOND);\n        const millisecond = GetSlot(temporalTime, ISO_MILLISECOND);\n        const microsecond = GetSlot(temporalTime, ISO_MICROSECOND);\n        const nanosecond = GetSlot(temporalTime, ISO_NANOSECOND);\n        const timeZone = GetSlot(this, TIME_ZONE);\n        const PlainDateTime = GetIntrinsic('%Temporal.PlainDateTime%');\n        const dt = new PlainDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar);\n        const instant = BuiltinTimeZoneGetInstantFor(timeZone, dt, 'compatible');\n        return CreateTemporalZonedDateTime(GetSlot(instant, EPOCHNANOSECONDS), timeZone, calendar);\n    }\n    withTimeZone(timeZoneParam) {\n        if (!IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        const timeZone = ToTemporalTimeZone(timeZoneParam);\n        return CreateTemporalZonedDateTime(GetSlot(this, EPOCHNANOSECONDS), timeZone, GetSlot(this, CALENDAR));\n    }\n    withCalendar(calendarParam) {\n        if (!IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        const calendar = ToTemporalCalendar(calendarParam);\n        return CreateTemporalZonedDateTime(GetSlot(this, EPOCHNANOSECONDS), GetSlot(this, TIME_ZONE), calendar);\n    }\n    add(temporalDurationLike, optionsParam = undefined) {\n        if (!IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        const duration = ToLimitedTemporalDuration(temporalDurationLike);\n        const { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = duration;\n        const options = GetOptionsObject(optionsParam);\n        const timeZone = GetSlot(this, TIME_ZONE);\n        const calendar = GetSlot(this, CALENDAR);\n        const epochNanoseconds = AddZonedDateTime(GetSlot(this, INSTANT), timeZone, calendar, years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, options);\n        return CreateTemporalZonedDateTime(epochNanoseconds, timeZone, calendar);\n    }\n    subtract(temporalDurationLike, optionsParam = undefined) {\n        if (!IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        const duration = ToLimitedTemporalDuration(temporalDurationLike);\n        const { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = duration;\n        const options = GetOptionsObject(optionsParam);\n        const timeZone = GetSlot(this, TIME_ZONE);\n        const calendar = GetSlot(this, CALENDAR);\n        const epochNanoseconds = AddZonedDateTime(GetSlot(this, INSTANT), timeZone, calendar, -years, -months, -weeks, -days, -hours, -minutes, -seconds, -milliseconds, -microseconds, -nanoseconds, options);\n        return CreateTemporalZonedDateTime(epochNanoseconds, timeZone, calendar);\n    }\n    until(otherParam, optionsParam = undefined) {\n        if (!IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        const other = ToTemporalZonedDateTime(otherParam);\n        const calendar = GetSlot(this, CALENDAR);\n        const otherCalendar = GetSlot(other, CALENDAR);\n        const calendarId = ToString(calendar);\n        const otherCalendarId = ToString(otherCalendar);\n        if (calendarId !== otherCalendarId) {\n            throw new RangeError(`cannot compute difference between dates of ${calendarId} and ${otherCalendarId} calendars`);\n        }\n        const options = GetOptionsObject(optionsParam);\n        const smallestUnit = ToSmallestTemporalUnit(options, 'nanosecond');\n        const defaultLargestUnit = LargerOfTwoTemporalUnits('hour', smallestUnit);\n        const largestUnit = ToLargestTemporalUnit(options, 'auto', [], defaultLargestUnit);\n        ValidateTemporalUnitRange(largestUnit, smallestUnit);\n        const roundingMode = ToTemporalRoundingMode(options, 'trunc');\n        const roundingIncrement = ToTemporalDateTimeRoundingIncrement(options, smallestUnit);\n        const ns1 = GetSlot(this, EPOCHNANOSECONDS);\n        const ns2 = GetSlot(other, EPOCHNANOSECONDS);\n        let years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds;\n        if (largestUnit !== 'year' && largestUnit !== 'month' && largestUnit !== 'week' && largestUnit !== 'day') {\n            // The user is only asking for a time difference, so return difference of instants.\n            years = 0;\n            months = 0;\n            weeks = 0;\n            days = 0;\n            ({ seconds, milliseconds, microseconds, nanoseconds } = DifferenceInstant(ns1, ns2, roundingIncrement, smallestUnit, roundingMode));\n            ({ hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = BalanceDuration(0, 0, 0, seconds, milliseconds, microseconds, nanoseconds, largestUnit));\n        }\n        else {\n            const timeZone = GetSlot(this, TIME_ZONE);\n            if (!TimeZoneEquals(timeZone, GetSlot(other, TIME_ZONE))) {\n                throw new RangeError(\"When calculating difference between time zones, largestUnit must be 'hours' \" +\n                    'or smaller because day lengths can vary between time zones due to DST or time zone offset changes.');\n            }\n            const untilOptions = { ...options, largestUnit };\n            ({ years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } =\n                DifferenceZonedDateTime(ns1, ns2, timeZone, calendar, largestUnit, untilOptions));\n            ({ years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } =\n                RoundDuration(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, roundingIncrement, smallestUnit, roundingMode, this));\n            ({ years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } =\n                AdjustRoundedDurationDays(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, roundingIncrement, smallestUnit, roundingMode, this));\n        }\n        const Duration = GetIntrinsic('%Temporal.Duration%');\n        return new Duration(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n    }\n    since(otherParam, optionsParam = undefined) {\n        if (!IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        const other = ToTemporalZonedDateTime(otherParam);\n        const calendar = GetSlot(this, CALENDAR);\n        const otherCalendar = GetSlot(other, CALENDAR);\n        const calendarId = ToString(calendar);\n        const otherCalendarId = ToString(otherCalendar);\n        if (calendarId !== otherCalendarId) {\n            throw new RangeError(`cannot compute difference between dates of ${calendarId} and ${otherCalendarId} calendars`);\n        }\n        const options = GetOptionsObject(optionsParam);\n        const smallestUnit = ToSmallestTemporalUnit(options, 'nanosecond');\n        const defaultLargestUnit = LargerOfTwoTemporalUnits('hour', smallestUnit);\n        const largestUnit = ToLargestTemporalUnit(options, 'auto', [], defaultLargestUnit);\n        ValidateTemporalUnitRange(largestUnit, smallestUnit);\n        let roundingMode = ToTemporalRoundingMode(options, 'trunc');\n        roundingMode = NegateTemporalRoundingMode(roundingMode);\n        const roundingIncrement = ToTemporalDateTimeRoundingIncrement(options, smallestUnit);\n        const ns1 = GetSlot(this, EPOCHNANOSECONDS);\n        const ns2 = GetSlot(other, EPOCHNANOSECONDS);\n        let years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds;\n        if (largestUnit !== 'year' && largestUnit !== 'month' && largestUnit !== 'week' && largestUnit !== 'day') {\n            // The user is only asking for a time difference, so return difference of instants.\n            years = 0;\n            months = 0;\n            weeks = 0;\n            days = 0;\n            ({ seconds, milliseconds, microseconds, nanoseconds } = DifferenceInstant(ns1, ns2, roundingIncrement, smallestUnit, roundingMode));\n            ({ hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = BalanceDuration(0, 0, 0, seconds, milliseconds, microseconds, nanoseconds, largestUnit));\n        }\n        else {\n            const timeZone = GetSlot(this, TIME_ZONE);\n            if (!TimeZoneEquals(timeZone, GetSlot(other, TIME_ZONE))) {\n                throw new RangeError(\"When calculating difference between time zones, largestUnit must be 'hours' \" +\n                    'or smaller because day lengths can vary between time zones due to DST or time zone offset changes.');\n            }\n            const untilOptions = { ...options, largestUnit };\n            ({ years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } =\n                DifferenceZonedDateTime(ns1, ns2, timeZone, calendar, largestUnit, untilOptions));\n            ({ years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } =\n                RoundDuration(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, roundingIncrement, smallestUnit, roundingMode, this));\n            ({ years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } =\n                AdjustRoundedDurationDays(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, roundingIncrement, smallestUnit, roundingMode, this));\n        }\n        const Duration = GetIntrinsic('%Temporal.Duration%');\n        return new Duration(-years, -months, -weeks, -days, -hours, -minutes, -seconds, -milliseconds, -microseconds, -nanoseconds);\n    }\n    round(optionsParam) {\n        if (!IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        if (optionsParam === undefined)\n            throw new TypeError('options parameter is required');\n        const options = typeof optionsParam === 'string'\n            ? CreateOnePropObject('smallestUnit', optionsParam)\n            : GetOptionsObject(optionsParam);\n        const smallestUnit = ToSmallestTemporalUnit(options, undefined, ['year', 'month', 'week']);\n        if (smallestUnit === undefined)\n            throw new RangeError('smallestUnit is required');\n        const roundingMode = ToTemporalRoundingMode(options, 'halfExpand');\n        const maximumIncrements = {\n            day: 1,\n            hour: 24,\n            minute: 60,\n            second: 60,\n            millisecond: 1000,\n            microsecond: 1000,\n            nanosecond: 1000\n        };\n        const roundingIncrement = ToTemporalRoundingIncrement(options, maximumIncrements[smallestUnit], false);\n        // first, round the underlying DateTime fields\n        const dt = dateTime(this);\n        let year = GetSlot(dt, ISO_YEAR);\n        let month = GetSlot(dt, ISO_MONTH);\n        let day = GetSlot(dt, ISO_DAY);\n        let hour = GetSlot(dt, ISO_HOUR);\n        let minute = GetSlot(dt, ISO_MINUTE);\n        let second = GetSlot(dt, ISO_SECOND);\n        let millisecond = GetSlot(dt, ISO_MILLISECOND);\n        let microsecond = GetSlot(dt, ISO_MICROSECOND);\n        let nanosecond = GetSlot(dt, ISO_NANOSECOND);\n        const DateTime = GetIntrinsic('%Temporal.PlainDateTime%');\n        const timeZone = GetSlot(this, TIME_ZONE);\n        const calendar = GetSlot(this, CALENDAR);\n        const dtStart = new DateTime(GetSlot(dt, ISO_YEAR), GetSlot(dt, ISO_MONTH), GetSlot(dt, ISO_DAY), 0, 0, 0, 0, 0, 0);\n        const instantStart = BuiltinTimeZoneGetInstantFor(timeZone, dtStart, 'compatible');\n        const endNs = AddZonedDateTime(instantStart, timeZone, calendar, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0);\n        const dayLengthNs = jsbi__WEBPACK_IMPORTED_MODULE_0__.subtract(endNs, jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(GetSlot(instantStart, EPOCHNANOSECONDS)));\n        if (jsbi__WEBPACK_IMPORTED_MODULE_0__.equal(dayLengthNs, ZERO)) {\n            throw new RangeError('cannot round a ZonedDateTime in a calendar with zero-length days');\n        }\n        ({ year, month, day, hour, minute, second, millisecond, microsecond, nanosecond } = RoundISODateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, roundingIncrement, smallestUnit, roundingMode, \n        // Days are guaranteed to be shorter than Number.MAX_SAFE_INTEGER\n        // (which can hold up to 104 days in nanoseconds)\n        jsbi__WEBPACK_IMPORTED_MODULE_0__.toNumber(dayLengthNs)));\n        // Now reset all DateTime fields but leave the TimeZone. The offset will\n        // also be retained if the new date/time values are still OK with the old\n        // offset. Otherwise the offset will be changed to be compatible with the\n        // new date/time values. If DST disambiguation is required, the `compatible`\n        // disambiguation algorithm will be used.\n        const offsetNs = GetOffsetNanosecondsFor(timeZone, GetSlot(this, INSTANT));\n        const epochNanoseconds = InterpretISODateTimeOffset(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, 'option', offsetNs, timeZone, 'compatible', 'prefer', \n        /* matchMinute = */ false);\n        return CreateTemporalZonedDateTime(epochNanoseconds, timeZone, GetSlot(this, CALENDAR));\n    }\n    equals(otherParam) {\n        if (!IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        const other = ToTemporalZonedDateTime(otherParam);\n        const one = GetSlot(this, EPOCHNANOSECONDS);\n        const two = GetSlot(other, EPOCHNANOSECONDS);\n        if (!jsbi__WEBPACK_IMPORTED_MODULE_0__.equal(jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(one), jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(two)))\n            return false;\n        if (!TimeZoneEquals(GetSlot(this, TIME_ZONE), GetSlot(other, TIME_ZONE)))\n            return false;\n        return CalendarEquals(GetSlot(this, CALENDAR), GetSlot(other, CALENDAR));\n    }\n    toString(optionsParam = undefined) {\n        if (!IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        const options = GetOptionsObject(optionsParam);\n        const { precision, unit, increment } = ToSecondsStringPrecision(options);\n        const roundingMode = ToTemporalRoundingMode(options, 'trunc');\n        const showCalendar = ToShowCalendarOption(options);\n        const showTimeZone = ToShowTimeZoneNameOption(options);\n        const showOffset = ToShowOffsetOption(options);\n        return TemporalZonedDateTimeToString(this, precision, showCalendar, showTimeZone, showOffset, {\n            unit,\n            increment,\n            roundingMode\n        });\n    }\n    toLocaleString(locales = undefined, options = undefined) {\n        if (!IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return new DateTimeFormat(locales, options).format(this);\n    }\n    toJSON() {\n        if (!IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return TemporalZonedDateTimeToString(this, 'auto');\n    }\n    valueOf() {\n        throw new TypeError('use compare() or equals() to compare Temporal.ZonedDateTime');\n    }\n    startOfDay() {\n        if (!IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        const dt = dateTime(this);\n        const DateTime = GetIntrinsic('%Temporal.PlainDateTime%');\n        const calendar = GetSlot(this, CALENDAR);\n        const dtStart = new DateTime(GetSlot(dt, ISO_YEAR), GetSlot(dt, ISO_MONTH), GetSlot(dt, ISO_DAY), 0, 0, 0, 0, 0, 0, calendar);\n        const timeZone = GetSlot(this, TIME_ZONE);\n        const instant = BuiltinTimeZoneGetInstantFor(timeZone, dtStart, 'compatible');\n        return CreateTemporalZonedDateTime(GetSlot(instant, EPOCHNANOSECONDS), timeZone, calendar);\n    }\n    toInstant() {\n        if (!IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        const TemporalInstant = GetIntrinsic('%Temporal.Instant%');\n        return new TemporalInstant(GetSlot(this, EPOCHNANOSECONDS));\n    }\n    toPlainDate() {\n        if (!IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return TemporalDateTimeToDate(dateTime(this));\n    }\n    toPlainTime() {\n        if (!IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return TemporalDateTimeToTime(dateTime(this));\n    }\n    toPlainDateTime() {\n        if (!IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return dateTime(this);\n    }\n    toPlainYearMonth() {\n        if (!IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        const calendar = GetSlot(this, CALENDAR);\n        const fieldNames = CalendarFields(calendar, ['monthCode', 'year']);\n        const fields = ToTemporalYearMonthFields(this, fieldNames);\n        return YearMonthFromFields(calendar, fields);\n    }\n    toPlainMonthDay() {\n        if (!IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        const calendar = GetSlot(this, CALENDAR);\n        const fieldNames = CalendarFields(calendar, ['day', 'monthCode']);\n        const fields = ToTemporalMonthDayFields(this, fieldNames);\n        return MonthDayFromFields(calendar, fields);\n    }\n    getISOFields() {\n        if (!IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        const dt = dateTime(this);\n        const tz = GetSlot(this, TIME_ZONE);\n        return {\n            calendar: GetSlot(this, CALENDAR),\n            isoDay: GetSlot(dt, ISO_DAY),\n            isoHour: GetSlot(dt, ISO_HOUR),\n            isoMicrosecond: GetSlot(dt, ISO_MICROSECOND),\n            isoMillisecond: GetSlot(dt, ISO_MILLISECOND),\n            isoMinute: GetSlot(dt, ISO_MINUTE),\n            isoMonth: GetSlot(dt, ISO_MONTH),\n            isoNanosecond: GetSlot(dt, ISO_NANOSECOND),\n            isoSecond: GetSlot(dt, ISO_SECOND),\n            isoYear: GetSlot(dt, ISO_YEAR),\n            offset: BuiltinTimeZoneGetOffsetStringFor(tz, GetSlot(this, INSTANT)),\n            timeZone: tz\n        };\n    }\n    static from(item, optionsParam = undefined) {\n        const options = GetOptionsObject(optionsParam);\n        if (IsTemporalZonedDateTime(item)) {\n            ToTemporalOverflow(options); // validate and ignore\n            ToTemporalDisambiguation(options);\n            ToTemporalOffset(options, 'reject');\n            return CreateTemporalZonedDateTime(GetSlot(item, EPOCHNANOSECONDS), GetSlot(item, TIME_ZONE), GetSlot(item, CALENDAR));\n        }\n        return ToTemporalZonedDateTime(item, options);\n    }\n    static compare(oneParam, twoParam) {\n        const one = ToTemporalZonedDateTime(oneParam);\n        const two = ToTemporalZonedDateTime(twoParam);\n        const ns1 = GetSlot(one, EPOCHNANOSECONDS);\n        const ns2 = GetSlot(two, EPOCHNANOSECONDS);\n        if (jsbi__WEBPACK_IMPORTED_MODULE_0__.lessThan(jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(ns1), jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(ns2)))\n            return -1;\n        if (jsbi__WEBPACK_IMPORTED_MODULE_0__.greaterThan(jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(ns1), jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(ns2)))\n            return 1;\n        return 0;\n    }\n}\nMakeIntrinsicClass(ZonedDateTime, 'Temporal.ZonedDateTime');\nfunction dateTime(zdt) {\n    return BuiltinTimeZoneGetPlainDateTimeFor(GetSlot(zdt, TIME_ZONE), GetSlot(zdt, INSTANT), GetSlot(zdt, CALENDAR));\n}\n\nvar temporal = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    Instant: Instant,\n    Calendar: Calendar,\n    PlainDate: PlainDate,\n    PlainDateTime: PlainDateTime,\n    Duration: Duration,\n    PlainMonthDay: PlainMonthDay,\n    Now: Now,\n    PlainTime: PlainTime,\n    TimeZone: TimeZone,\n    PlainYearMonth: PlainYearMonth,\n    ZonedDateTime: ZonedDateTime\n});\n\nfunction toTemporalInstant() {\n    // Observable access to valueOf is not correct here, but unavoidable\n    const epochNanoseconds = jsbi__WEBPACK_IMPORTED_MODULE_0__.multiply(jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(+this), MILLION);\n    return new Instant(ToBigInt(epochNanoseconds));\n}\n\n// This entry point treats Temporal as a library, and does not polyfill it onto\n// Work around https://github.com/babel/babel/issues/2025.\nconst types = [\n    Instant,\n    Calendar,\n    PlainDate,\n    PlainDateTime,\n    Duration,\n    PlainMonthDay,\n    // Temporal.Now, // plain object (not a constructor), so no `prototype`\n    PlainTime,\n    TimeZone,\n    PlainYearMonth,\n    ZonedDateTime\n];\nfor (const type of types) {\n    const descriptor = Object.getOwnPropertyDescriptor(type, 'prototype');\n    if (descriptor.configurable || descriptor.enumerable || descriptor.writable) {\n        descriptor.configurable = false;\n        descriptor.enumerable = false;\n        descriptor.writable = false;\n        Object.defineProperty(type, 'prototype', descriptor);\n    }\n}\n\n\n//# sourceMappingURL=index.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGpzLXRlbXBvcmFsL3BvbHlmaWxsL2Rpc3QvaW5kZXguZXNtLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBd0I7O0FBRXhCO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QywwQkFBMEIsR0FBRyxLQUFLO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLEtBQUssSUFBSSxzQ0FBc0M7QUFDakY7QUFDQSwwQkFBMEIsZ0NBQWdDO0FBQzFEO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QiwwQkFBMEIsR0FBRyxLQUFLO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLEtBQUs7QUFDNUI7QUFDQTtBQUNBLG9CQUFvQixLQUFLO0FBQ3pCO0FBQ0EscUNBQXFDLE1BQU07QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsR0FBRztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLEdBQUc7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsMEJBQTBCLEdBQUcsR0FBRztBQUMxRDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELEtBQUs7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw2QkFBNkI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx1SUFBdUk7QUFDbkosYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSwrRkFBK0Y7QUFDM0c7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELFVBQVU7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRUFBMkUsU0FBUztBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQiwwRkFBMEYsYUFBYTtBQUN2RztBQUNBO0FBQ0EsMEZBQTBGLE9BQU87QUFDakc7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSw4RkFBOEYsT0FBTztBQUNyRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVywrRUFBK0U7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDhHQUE4RztBQUN6SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLGFBQWEsc0NBQXNDLGFBQWE7QUFDNUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsU0FBUztBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsV0FBVztBQUN0QjtBQUNBO0FBQ0Esa0RBQWtELFdBQVc7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksV0FBVztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsNENBQTRDLG1DQUFtQztBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsbUNBQW1DLGFBQWEsa0NBQWtDO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLHFCQUFxQjtBQUM3RDtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQywwQ0FBYSxDQUFDLHdDQUFXO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsMENBQWEsQ0FBQyx3Q0FBVztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLDBDQUFhO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSwwQ0FBYTtBQUN6QjtBQUNBLFlBQVksNkNBQWdCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRUFBK0UsWUFBWSxNQUFNLGlCQUFpQjtBQUNsSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLGNBQWMsNkJBQTZCO0FBQzNDLFdBQVcsNkJBQTZCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtFQUErRSxZQUFZLE1BQU0saUJBQWlCO0FBQ2xIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0IsY0FBYyw2QkFBNkI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDZCQUE2QjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsbUNBQW1DO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLCtFQUErRTtBQUMvRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLCtGQUErRjtBQUMvRztBQUNBO0FBQ0EsZ0JBQWdCLCtFQUErRTtBQUMvRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsK0ZBQStGO0FBQy9HO0FBQ0E7QUFDQSxnQkFBZ0IsK0VBQStFO0FBQy9GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRUFBK0UsWUFBWSxNQUFNLGlCQUFpQjtBQUNsSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYywrRkFBK0Y7QUFDN0c7QUFDQSxXQUFXLCtGQUErRjtBQUMxRztBQUNBLFdBQVcseUVBQXlFO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtFQUErRSxZQUFZLE1BQU0saUJBQWlCO0FBQ2xIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLCtGQUErRjtBQUM3RztBQUNBLFdBQVcsK0ZBQStGO0FBQzFHO0FBQ0EsV0FBVyx5RUFBeUU7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLCtFQUErRTtBQUMxRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw2QkFBNkI7QUFDN0M7QUFDQTtBQUNBLHlFQUF5RSwrQkFBK0I7QUFDeEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDBCQUEwQixHQUFHLCtCQUErQjtBQUN0RjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw2VkFBNlY7QUFDN1c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYywrRkFBK0Y7QUFDN0c7QUFDQTtBQUNBLFdBQVcsK0ZBQStGO0FBQzFHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLCtGQUErRjtBQUM3RztBQUNBO0FBQ0EsV0FBVywrRkFBK0Y7QUFDMUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDZCQUE2QjtBQUN4QyxXQUFXLCtGQUErRjtBQUMxRztBQUNBLFdBQVcsK0ZBQStGO0FBQzFHO0FBQ0EsV0FBVyw2QkFBNkI7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsV0FBVyx5RUFBeUU7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDZCQUE2QjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyx5RUFBeUU7QUFDcEY7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsNkJBQTZCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCwrQkFBK0I7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFdBQVc7QUFDMUIsZUFBZSxXQUFXO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQywwQ0FBYSxDQUFDLDBDQUFhO0FBQzNEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNEO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsZ0NBQWdDO0FBQ2hELFdBQVcsNkRBQTZEO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxXQUFXLEdBQUcsYUFBYSxFQUFFLFFBQVE7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiwwQkFBMEIsR0FBRyxtQ0FBbUM7QUFDMUY7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDZEQUE2RDtBQUMzRSxXQUFXLDZEQUE2RDtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsbUVBQW1FO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsNkRBQTZEO0FBQ3hFLFdBQVcsNkRBQTZEO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixtRUFBbUU7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyw2REFBNkQ7QUFDeEUsV0FBVyw2REFBNkQ7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxtRUFBbUU7QUFDakYsV0FBVyxtRUFBbUU7QUFDOUUsV0FBVyxtRUFBbUU7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLG1FQUFtRTtBQUNqRixXQUFXLG1FQUFtRTtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLG1FQUFtRTtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsNkRBQTZEO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw2QkFBNkI7QUFDN0M7QUFDQSx1REFBdUQsK0JBQStCO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDBCQUEwQixHQUFHLG1CQUFtQjtBQUMxRTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQywwQ0FBYSxVQUFVLHdDQUFXO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDBDQUFhLENBQUMsd0NBQVc7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsMENBQWEsQ0FBQyx3Q0FBVztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHdDQUFXO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDBDQUFhLENBQUMsMENBQWE7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUM7O0FBRUQ7QUFDQTtBQUNBLDZCQUE2QiwwQ0FBYSxDQUFDLHdDQUFXO0FBQ3REO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVpRTtBQUNqRSIsInNvdXJjZXMiOlsid2VicGFjazovL3RvZG8tbGlzdC8uL25vZGVfbW9kdWxlcy9AanMtdGVtcG9yYWwvcG9seWZpbGwvZGlzdC9pbmRleC5lc20uanM/NjdjYyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgSlNCSSBmcm9tICdqc2JpJztcblxuY29uc3QgSU5UUklOU0lDUyA9IHt9O1xuY29uc3QgY3VzdG9tVXRpbEluc3BlY3RGb3JtYXR0ZXJzID0ge1xuICAgIFsnVGVtcG9yYWwuRHVyYXRpb24nXShkZXB0aCwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBkZXNjciA9IG9wdGlvbnMuc3R5bGl6ZShgJHt0aGlzW1N5bWJvbC50b1N0cmluZ1RhZ119IDwke3RoaXN9PmAsICdzcGVjaWFsJyk7XG4gICAgICAgIGlmIChkZXB0aCA8IDEpXG4gICAgICAgICAgICByZXR1cm4gZGVzY3I7XG4gICAgICAgIGNvbnN0IGVudHJpZXMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBwcm9wIG9mIFtcbiAgICAgICAgICAgICd5ZWFycycsXG4gICAgICAgICAgICAnbW9udGhzJyxcbiAgICAgICAgICAgICd3ZWVrcycsXG4gICAgICAgICAgICAnZGF5cycsXG4gICAgICAgICAgICAnaG91cnMnLFxuICAgICAgICAgICAgJ21pbnV0ZXMnLFxuICAgICAgICAgICAgJ3NlY29uZHMnLFxuICAgICAgICAgICAgJ21pbGxpc2Vjb25kcycsXG4gICAgICAgICAgICAnbWljcm9zZWNvbmRzJyxcbiAgICAgICAgICAgICduYW5vc2Vjb25kcydcbiAgICAgICAgXSkge1xuICAgICAgICAgICAgaWYgKHRoaXNbcHJvcF0gIT09IDApXG4gICAgICAgICAgICAgICAgZW50cmllcy5wdXNoKGAgICR7cHJvcH06ICR7b3B0aW9ucy5zdHlsaXplKHRoaXNbcHJvcF0sICdudW1iZXInKX1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVzY3IgKyAnIHtcXG4nICsgZW50cmllcy5qb2luKCcsXFxuJykgKyAnXFxufSc7XG4gICAgfVxufTtcbmZ1bmN0aW9uIGRlZmF1bHRVdGlsSW5zcGVjdEZvcm1hdHRlcihkZXB0aCwgb3B0aW9ucykge1xuICAgIHJldHVybiBvcHRpb25zLnN0eWxpemUoYCR7dGhpc1tTeW1ib2wudG9TdHJpbmdUYWddfSA8JHt0aGlzfT5gLCAnc3BlY2lhbCcpO1xufVxuZnVuY3Rpb24gTWFrZUludHJpbnNpY0NsYXNzKENsYXNzLCBuYW1lKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENsYXNzLnByb3RvdHlwZSwgU3ltYm9sLnRvU3RyaW5nVGFnLCB7XG4gICAgICAgIHZhbHVlOiBuYW1lLFxuICAgICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDbGFzcy5wcm90b3R5cGUsIFN5bWJvbC5mb3IoJ25vZGVqcy51dGlsLmluc3BlY3QuY3VzdG9tJyksIHtcbiAgICAgICAgICAgIHZhbHVlOiBjdXN0b21VdGlsSW5zcGVjdEZvcm1hdHRlcnNbbmFtZV0gfHwgZGVmYXVsdFV0aWxJbnNwZWN0Rm9ybWF0dGVyLFxuICAgICAgICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgcHJvcCBvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhDbGFzcykpIHtcbiAgICAgICAgLy8gd2Uga25vdyB0aGF0IGBwcm9wYCBpcyBwcmVzZW50LCBzbyB0aGUgZGVzY3JpcHRvciBpcyBuZXZlciB1bmRlZmluZWRcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICAgICAgY29uc3QgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoQ2xhc3MsIHByb3ApO1xuICAgICAgICBpZiAoIWRlc2MuY29uZmlndXJhYmxlIHx8ICFkZXNjLmVudW1lcmFibGUpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgZGVzYy5lbnVtZXJhYmxlID0gZmFsc2U7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDbGFzcywgcHJvcCwgZGVzYyk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgcHJvcCBvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhDbGFzcy5wcm90b3R5cGUpKSB7XG4gICAgICAgIC8vIHdlIGtub3cgdGhhdCBgcHJvcGAgaXMgcHJlc2VudCwgc28gdGhlIGRlc2NyaXB0b3IgaXMgbmV2ZXIgdW5kZWZpbmVkXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICAgIGNvbnN0IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKENsYXNzLnByb3RvdHlwZSwgcHJvcCk7XG4gICAgICAgIGlmICghZGVzYy5jb25maWd1cmFibGUgfHwgIWRlc2MuZW51bWVyYWJsZSlcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBkZXNjLmVudW1lcmFibGUgPSBmYWxzZTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENsYXNzLnByb3RvdHlwZSwgcHJvcCwgZGVzYyk7XG4gICAgfVxuICAgIERlZmluZUludHJpbnNpYyhuYW1lLCBDbGFzcyk7XG4gICAgRGVmaW5lSW50cmluc2ljKGAke25hbWV9LnByb3RvdHlwZWAsIENsYXNzLnByb3RvdHlwZSk7XG59XG5mdW5jdGlvbiBEZWZpbmVJbnRyaW5zaWMobmFtZSwgdmFsdWUpIHtcbiAgICBjb25zdCBrZXkgPSBgJSR7bmFtZX0lYDtcbiAgICBpZiAoSU5UUklOU0lDU1trZXldICE9PSB1bmRlZmluZWQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgaW50cmluc2ljICR7bmFtZX0gYWxyZWFkeSBleGlzdHNgKTtcbiAgICBJTlRSSU5TSUNTW2tleV0gPSB2YWx1ZTtcbn1cbmZ1bmN0aW9uIEdldEludHJpbnNpYyhpbnRyaW5zaWMpIHtcbiAgICByZXR1cm4gSU5UUklOU0lDU1tpbnRyaW5zaWNdO1xufVxuXG4vLyBJbnN0YW50XG5jb25zdCBFUE9DSE5BTk9TRUNPTkRTID0gJ3Nsb3QtZXBvY2hOYW5vU2Vjb25kcyc7XG4vLyBUaW1lWm9uZVxuY29uc3QgVElNRVpPTkVfSUQgPSAnc2xvdC10aW1lem9uZS1pZGVudGlmaWVyJztcbi8vIERhdGVUaW1lLCBEYXRlLCBUaW1lLCBZZWFyTW9udGgsIE1vbnRoRGF5XG5jb25zdCBJU09fWUVBUiA9ICdzbG90LXllYXInO1xuY29uc3QgSVNPX01PTlRIID0gJ3Nsb3QtbW9udGgnO1xuY29uc3QgSVNPX0RBWSA9ICdzbG90LWRheSc7XG5jb25zdCBJU09fSE9VUiA9ICdzbG90LWhvdXInO1xuY29uc3QgSVNPX01JTlVURSA9ICdzbG90LW1pbnV0ZSc7XG5jb25zdCBJU09fU0VDT05EID0gJ3Nsb3Qtc2Vjb25kJztcbmNvbnN0IElTT19NSUxMSVNFQ09ORCA9ICdzbG90LW1pbGxpc2Vjb25kJztcbmNvbnN0IElTT19NSUNST1NFQ09ORCA9ICdzbG90LW1pY3Jvc2Vjb25kJztcbmNvbnN0IElTT19OQU5PU0VDT05EID0gJ3Nsb3QtbmFub3NlY29uZCc7XG5jb25zdCBDQUxFTkRBUiA9ICdzbG90LWNhbGVuZGFyJztcbi8vIERhdGUsIFllYXJNb250aCwgYW5kIE1vbnRoRGF5IGFsbCBoYXZlIHRoZSBzYW1lIHNsb3RzLCBkaXNhbWJpZ3VhdGlvbiBuZWVkZWQ6XG5jb25zdCBEQVRFX0JSQU5EID0gJ3Nsb3QtZGF0ZS1icmFuZCc7XG5jb25zdCBZRUFSX01PTlRIX0JSQU5EID0gJ3Nsb3QteWVhci1tb250aC1icmFuZCc7XG5jb25zdCBNT05USF9EQVlfQlJBTkQgPSAnc2xvdC1tb250aC1kYXktYnJhbmQnO1xuLy8gWm9uZWREYXRlVGltZVxuY29uc3QgSU5TVEFOVCA9ICdzbG90LWNhY2hlZC1pbnN0YW50JztcbmNvbnN0IFRJTUVfWk9ORSA9ICdzbG90LXRpbWUtem9uZSc7XG4vLyBEdXJhdGlvblxuY29uc3QgWUVBUlMgPSAnc2xvdC15ZWFycyc7XG5jb25zdCBNT05USFMgPSAnc2xvdC1tb250aHMnO1xuY29uc3QgV0VFS1MgPSAnc2xvdC13ZWVrcyc7XG5jb25zdCBEQVlTID0gJ3Nsb3QtZGF5cyc7XG5jb25zdCBIT1VSUyA9ICdzbG90LWhvdXJzJztcbmNvbnN0IE1JTlVURVMgPSAnc2xvdC1taW51dGVzJztcbmNvbnN0IFNFQ09ORFMgPSAnc2xvdC1zZWNvbmRzJztcbmNvbnN0IE1JTExJU0VDT05EUyA9ICdzbG90LW1pbGxpc2Vjb25kcyc7XG5jb25zdCBNSUNST1NFQ09ORFMgPSAnc2xvdC1taWNyb3NlY29uZHMnO1xuY29uc3QgTkFOT1NFQ09ORFMgPSAnc2xvdC1uYW5vc2Vjb25kcyc7XG4vLyBDYWxlbmRhclxuY29uc3QgQ0FMRU5EQVJfSUQgPSAnc2xvdC1jYWxlbmRhci1pZGVudGlmaWVyJztcbmNvbnN0IHNsb3RzID0gbmV3IFdlYWtNYXAoKTtcbmZ1bmN0aW9uIENyZWF0ZVNsb3RzKGNvbnRhaW5lcikge1xuICAgIHNsb3RzLnNldChjb250YWluZXIsIE9iamVjdC5jcmVhdGUobnVsbCkpO1xufVxuZnVuY3Rpb24gR2V0U2xvdHMoY29udGFpbmVyKSB7XG4gICAgcmV0dXJuIHNsb3RzLmdldChjb250YWluZXIpO1xufVxuZnVuY3Rpb24gSGFzU2xvdChjb250YWluZXIsIC4uLmlkcykge1xuICAgIGlmICghY29udGFpbmVyIHx8ICdvYmplY3QnICE9PSB0eXBlb2YgY29udGFpbmVyKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgY29uc3QgbXlzbG90cyA9IEdldFNsb3RzKGNvbnRhaW5lcik7XG4gICAgcmV0dXJuICEhbXlzbG90cyAmJiBpZHMucmVkdWNlKChhbGwsIGlkKSA9PiBhbGwgJiYgaWQgaW4gbXlzbG90cywgdHJ1ZSk7XG59XG5mdW5jdGlvbiBHZXRTbG90KGNvbnRhaW5lciwgaWQpIHtcbiAgICBjb25zdCB2YWx1ZSA9IEdldFNsb3RzKGNvbnRhaW5lcilbaWRdO1xuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBNaXNzaW5nIGludGVybmFsIHNsb3QgJHtpZH1gKTtcbiAgICByZXR1cm4gdmFsdWU7XG59XG5mdW5jdGlvbiBTZXRTbG90KGNvbnRhaW5lciwgaWQsIHZhbHVlKSB7XG4gICAgR2V0U2xvdHMoY29udGFpbmVyKVtpZF0gPSB2YWx1ZTtcbn1cblxuY29uc3QgQXJyYXlJbmNsdWRlcyA9IEFycmF5LnByb3RvdHlwZS5pbmNsdWRlcztcbmNvbnN0IEFycmF5UHJvdG90eXBlUHVzaCQyID0gQXJyYXkucHJvdG90eXBlLnB1c2g7XG5jb25zdCBJbnRsRGF0ZVRpbWVGb3JtYXQkMiA9IGdsb2JhbFRoaXMuSW50bC5EYXRlVGltZUZvcm1hdDtcbmNvbnN0IEFycmF5U29ydCA9IEFycmF5LnByb3RvdHlwZS5zb3J0O1xuY29uc3QgTWF0aEFicyQxID0gTWF0aC5hYnM7XG5jb25zdCBNYXRoRmxvb3IkMSA9IE1hdGguZmxvb3I7XG5jb25zdCBPYmplY3RFbnRyaWVzID0gT2JqZWN0LmVudHJpZXM7XG5jb25zdCBPYmplY3RLZXlzID0gT2JqZWN0LmtleXM7XG4vKipcbiAqIEltcGxlbWVudGF0aW9ucyBmb3IgZWFjaCBjYWxlbmRhci4gTm9uLUlTTyBjYWxlbmRhcnMgaGF2ZSBhbiBleHRyYSBgaGVscGVyYFxuICogcHJvcGVydHkgdGhhdCBwcm92aWRlcyBhZGRpdGlvbmFsIHBlci1jYWxlbmRhciBsb2dpYy5cbiAqL1xuY29uc3QgaW1wbCA9IHt9O1xuLyoqXG4gKiBUaGluIHdyYXBwZXIgYXJvdW5kIHRoZSBpbXBsZW1lbnRhdGlvbiBvZiBlYWNoIGJ1aWx0LWluIGNhbGVuZGFyLiBUaGlzXG4gKiBjbGFzcydzIG1ldGhvZHMgZm9sbG93IGEgc2ltaWxhciBwYXR0ZXJuOlxuICogMS4gVmFsaWRhdGUgcGFyYW1ldGVyc1xuICogMi4gRmlsbCBpbiBkZWZhdWx0IG9wdGlvbnMgKGZvciBtZXRob2RzIHdoZXJlIG9wdGlvbnMgYXJlIHByZXNlbnQpXG4gKiAzLiBTaW1wbGlmeSBhbmQvb3Igbm9ybWFsaXplIHBhcmFtZXRlcnMuIEZvciBleGFtcGxlLCBzb21lIG1ldGhvZHMgYWNjZXB0XG4gKiAgICBQbGFpbkRhdGUsIFBsYWluRGF0ZVRpbWUsIFpvbmVkRGF0ZVRpbWUsIGV0Yy4gYW5kIHRoZXNlIGFyZSBub3JtYWxpemVkIHRvXG4gKiAgICBQbGFpbkRhdGUuXG4gKiA0LiBMb29rIHVwIHRoZSBJRCBvZiB0aGUgYnVpbHQtaW4gY2FsZW5kYXJcbiAqIDUuIEZldGNoIHRoZSBpbXBsZW1lbnRhdGlvbiBvYmplY3QgZm9yIHRoYXQgSUQuXG4gKiA2LiBDYWxsIHRoZSBjb3JyZXNwb25kaW5nIG1ldGhvZCBpbiB0aGUgaW1wbGVtZW50YXRpb24gb2JqZWN0LlxuICovXG5jbGFzcyBDYWxlbmRhciB7XG4gICAgY29uc3RydWN0b3IoaWRQYXJhbSkge1xuICAgICAgICAvLyBOb3RlOiBpZiB0aGUgYXJndW1lbnQgaXMgbm90IHBhc3NlZCwgSXNCdWlsdGluQ2FsZW5kYXIoXCJ1bmRlZmluZWRcIikgd2lsbCBmYWlsLiBUaGlzIGNoZWNrXG4gICAgICAgIC8vICAgICAgIGV4aXN0cyBvbmx5IHRvIGltcHJvdmUgdGhlIGVycm9yIG1lc3NhZ2UuXG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ21pc3NpbmcgYXJndW1lbnQ6IGlkIGlzIHJlcXVpcmVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaWQgPSBUb1N0cmluZyhpZFBhcmFtKTtcbiAgICAgICAgaWYgKCFJc0J1aWx0aW5DYWxlbmRhcihpZCkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgaW52YWxpZCBjYWxlbmRhciBpZGVudGlmaWVyICR7aWR9YCk7XG4gICAgICAgIENyZWF0ZVNsb3RzKHRoaXMpO1xuICAgICAgICBTZXRTbG90KHRoaXMsIENBTEVOREFSX0lELCBpZCk7XG4gICAgICAgIHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnX3JlcHJfJywge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBgJHt0aGlzW1N5bWJvbC50b1N0cmluZ1RhZ119IDwke2lkfT5gLFxuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgaWQoKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbENhbGVuZGFyKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICByZXR1cm4gVG9TdHJpbmcodGhpcyk7XG4gICAgfVxuICAgIGRhdGVGcm9tRmllbGRzKGZpZWxkcywgb3B0aW9uc1BhcmFtID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbENhbGVuZGFyKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICBpZiAoIUlzT2JqZWN0KGZpZWxkcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIGZpZWxkcycpO1xuICAgICAgICBjb25zdCBvcHRpb25zID0gR2V0T3B0aW9uc09iamVjdChvcHRpb25zUGFyYW0pO1xuICAgICAgICByZXR1cm4gaW1wbFtHZXRTbG90KHRoaXMsIENBTEVOREFSX0lEKV0uZGF0ZUZyb21GaWVsZHMoZmllbGRzLCBvcHRpb25zLCB0aGlzKTtcbiAgICB9XG4gICAgeWVhck1vbnRoRnJvbUZpZWxkcyhmaWVsZHMsIG9wdGlvbnNQYXJhbSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxDYWxlbmRhcih0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgaWYgKCFJc09iamVjdChmaWVsZHMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBmaWVsZHMnKTtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IEdldE9wdGlvbnNPYmplY3Qob3B0aW9uc1BhcmFtKTtcbiAgICAgICAgcmV0dXJuIGltcGxbR2V0U2xvdCh0aGlzLCBDQUxFTkRBUl9JRCldLnllYXJNb250aEZyb21GaWVsZHMoZmllbGRzLCBvcHRpb25zLCB0aGlzKTtcbiAgICB9XG4gICAgbW9udGhEYXlGcm9tRmllbGRzKGZpZWxkcywgb3B0aW9uc1BhcmFtID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbENhbGVuZGFyKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICBpZiAoIUlzT2JqZWN0KGZpZWxkcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIGZpZWxkcycpO1xuICAgICAgICBjb25zdCBvcHRpb25zID0gR2V0T3B0aW9uc09iamVjdChvcHRpb25zUGFyYW0pO1xuICAgICAgICByZXR1cm4gaW1wbFtHZXRTbG90KHRoaXMsIENBTEVOREFSX0lEKV0ubW9udGhEYXlGcm9tRmllbGRzKGZpZWxkcywgb3B0aW9ucywgdGhpcyk7XG4gICAgfVxuICAgIGZpZWxkcyhmaWVsZHMpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsQ2FsZW5kYXIodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIGNvbnN0IGZpZWxkc0FycmF5ID0gW107XG4gICAgICAgIGNvbnN0IGFsbG93ZWQgPSBuZXcgU2V0KFtcbiAgICAgICAgICAgICd5ZWFyJyxcbiAgICAgICAgICAgICdtb250aCcsXG4gICAgICAgICAgICAnbW9udGhDb2RlJyxcbiAgICAgICAgICAgICdkYXknLFxuICAgICAgICAgICAgJ2hvdXInLFxuICAgICAgICAgICAgJ21pbnV0ZScsXG4gICAgICAgICAgICAnc2Vjb25kJyxcbiAgICAgICAgICAgICdtaWxsaXNlY29uZCcsXG4gICAgICAgICAgICAnbWljcm9zZWNvbmQnLFxuICAgICAgICAgICAgJ25hbm9zZWNvbmQnXG4gICAgICAgIF0pO1xuICAgICAgICBmb3IgKGNvbnN0IG5hbWUgb2YgZmllbGRzKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG5hbWUgIT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgZmllbGRzJyk7XG4gICAgICAgICAgICBpZiAoIWFsbG93ZWQuaGFzKG5hbWUpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBpbnZhbGlkIGZpZWxkIG5hbWUgJHtuYW1lfWApO1xuICAgICAgICAgICAgYWxsb3dlZC5kZWxldGUobmFtZSk7XG4gICAgICAgICAgICBBcnJheVByb3RvdHlwZVB1c2gkMi5jYWxsKGZpZWxkc0FycmF5LCBuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW1wbFtHZXRTbG90KHRoaXMsIENBTEVOREFSX0lEKV0uZmllbGRzKGZpZWxkc0FycmF5KTtcbiAgICB9XG4gICAgbWVyZ2VGaWVsZHMoZmllbGRzLCBhZGRpdGlvbmFsRmllbGRzKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbENhbGVuZGFyKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICByZXR1cm4gaW1wbFtHZXRTbG90KHRoaXMsIENBTEVOREFSX0lEKV0ubWVyZ2VGaWVsZHMoZmllbGRzLCBhZGRpdGlvbmFsRmllbGRzKTtcbiAgICB9XG4gICAgZGF0ZUFkZChkYXRlUGFyYW0sIGR1cmF0aW9uUGFyYW0sIG9wdGlvbnNQYXJhbSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxDYWxlbmRhcih0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgY29uc3QgZGF0ZSA9IFRvVGVtcG9yYWxEYXRlKGRhdGVQYXJhbSk7XG4gICAgICAgIGNvbnN0IGR1cmF0aW9uID0gVG9UZW1wb3JhbER1cmF0aW9uKGR1cmF0aW9uUGFyYW0pO1xuICAgICAgICBjb25zdCBvcHRpb25zID0gR2V0T3B0aW9uc09iamVjdChvcHRpb25zUGFyYW0pO1xuICAgICAgICBjb25zdCBvdmVyZmxvdyA9IFRvVGVtcG9yYWxPdmVyZmxvdyhvcHRpb25zKTtcbiAgICAgICAgY29uc3QgeyBkYXlzIH0gPSBCYWxhbmNlRHVyYXRpb24oR2V0U2xvdChkdXJhdGlvbiwgREFZUyksIEdldFNsb3QoZHVyYXRpb24sIEhPVVJTKSwgR2V0U2xvdChkdXJhdGlvbiwgTUlOVVRFUyksIEdldFNsb3QoZHVyYXRpb24sIFNFQ09ORFMpLCBHZXRTbG90KGR1cmF0aW9uLCBNSUxMSVNFQ09ORFMpLCBHZXRTbG90KGR1cmF0aW9uLCBNSUNST1NFQ09ORFMpLCBHZXRTbG90KGR1cmF0aW9uLCBOQU5PU0VDT05EUyksICdkYXknKTtcbiAgICAgICAgcmV0dXJuIGltcGxbR2V0U2xvdCh0aGlzLCBDQUxFTkRBUl9JRCldLmRhdGVBZGQoZGF0ZSwgR2V0U2xvdChkdXJhdGlvbiwgWUVBUlMpLCBHZXRTbG90KGR1cmF0aW9uLCBNT05USFMpLCBHZXRTbG90KGR1cmF0aW9uLCBXRUVLUyksIGRheXMsIG92ZXJmbG93LCB0aGlzKTtcbiAgICB9XG4gICAgZGF0ZVVudGlsKG9uZVBhcmFtLCB0d29QYXJhbSwgb3B0aW9uc1BhcmFtID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbENhbGVuZGFyKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICBjb25zdCBvbmUgPSBUb1RlbXBvcmFsRGF0ZShvbmVQYXJhbSk7XG4gICAgICAgIGNvbnN0IHR3byA9IFRvVGVtcG9yYWxEYXRlKHR3b1BhcmFtKTtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IEdldE9wdGlvbnNPYmplY3Qob3B0aW9uc1BhcmFtKTtcbiAgICAgICAgY29uc3QgbGFyZ2VzdFVuaXQgPSBUb0xhcmdlc3RUZW1wb3JhbFVuaXQob3B0aW9ucywgJ2F1dG8nLCBbJ2hvdXInLCAnbWludXRlJywgJ3NlY29uZCcsICdtaWxsaXNlY29uZCcsICdtaWNyb3NlY29uZCcsICduYW5vc2Vjb25kJ10sICdkYXknKTtcbiAgICAgICAgY29uc3QgeyB5ZWFycywgbW9udGhzLCB3ZWVrcywgZGF5cyB9ID0gaW1wbFtHZXRTbG90KHRoaXMsIENBTEVOREFSX0lEKV0uZGF0ZVVudGlsKG9uZSwgdHdvLCBsYXJnZXN0VW5pdCk7XG4gICAgICAgIGNvbnN0IER1cmF0aW9uID0gR2V0SW50cmluc2ljKCclVGVtcG9yYWwuRHVyYXRpb24lJyk7XG4gICAgICAgIHJldHVybiBuZXcgRHVyYXRpb24oeWVhcnMsIG1vbnRocywgd2Vla3MsIGRheXMsIDAsIDAsIDAsIDAsIDAsIDApO1xuICAgIH1cbiAgICB5ZWFyKGRhdGVQYXJhbSkge1xuICAgICAgICBsZXQgZGF0ZSA9IGRhdGVQYXJhbTtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsQ2FsZW5kYXIodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbFllYXJNb250aChkYXRlKSlcbiAgICAgICAgICAgIGRhdGUgPSBUb1RlbXBvcmFsRGF0ZShkYXRlKTtcbiAgICAgICAgcmV0dXJuIGltcGxbR2V0U2xvdCh0aGlzLCBDQUxFTkRBUl9JRCldLnllYXIoZGF0ZSk7XG4gICAgfVxuICAgIG1vbnRoKGRhdGVQYXJhbSkge1xuICAgICAgICBsZXQgZGF0ZSA9IGRhdGVQYXJhbTtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsQ2FsZW5kYXIodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIGlmIChJc1RlbXBvcmFsTW9udGhEYXkoZGF0ZSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd1c2UgbW9udGhDb2RlIG9uIFBsYWluTW9udGhEYXkgaW5zdGVhZCcpO1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxZZWFyTW9udGgoZGF0ZSkpXG4gICAgICAgICAgICBkYXRlID0gVG9UZW1wb3JhbERhdGUoZGF0ZSk7XG4gICAgICAgIHJldHVybiBpbXBsW0dldFNsb3QodGhpcywgQ0FMRU5EQVJfSUQpXS5tb250aChkYXRlKTtcbiAgICB9XG4gICAgbW9udGhDb2RlKGRhdGVQYXJhbSkge1xuICAgICAgICBsZXQgZGF0ZSA9IGRhdGVQYXJhbTtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsQ2FsZW5kYXIodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbFllYXJNb250aChkYXRlKSAmJiAhSXNUZW1wb3JhbE1vbnRoRGF5KGRhdGUpKVxuICAgICAgICAgICAgZGF0ZSA9IFRvVGVtcG9yYWxEYXRlKGRhdGUpO1xuICAgICAgICByZXR1cm4gaW1wbFtHZXRTbG90KHRoaXMsIENBTEVOREFSX0lEKV0ubW9udGhDb2RlKGRhdGUpO1xuICAgIH1cbiAgICBkYXkoZGF0ZVBhcmFtKSB7XG4gICAgICAgIGxldCBkYXRlID0gZGF0ZVBhcmFtO1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxDYWxlbmRhcih0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsTW9udGhEYXkoZGF0ZSkpXG4gICAgICAgICAgICBkYXRlID0gVG9UZW1wb3JhbERhdGUoZGF0ZSk7XG4gICAgICAgIHJldHVybiBpbXBsW0dldFNsb3QodGhpcywgQ0FMRU5EQVJfSUQpXS5kYXkoZGF0ZSk7XG4gICAgfVxuICAgIGVyYShkYXRlUGFyYW0pIHtcbiAgICAgICAgbGV0IGRhdGUgPSBkYXRlUGFyYW07XG4gICAgICAgIGlmICghSXNUZW1wb3JhbENhbGVuZGFyKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxZZWFyTW9udGgoZGF0ZSkpXG4gICAgICAgICAgICBkYXRlID0gVG9UZW1wb3JhbERhdGUoZGF0ZSk7XG4gICAgICAgIHJldHVybiBpbXBsW0dldFNsb3QodGhpcywgQ0FMRU5EQVJfSUQpXS5lcmEoZGF0ZSk7XG4gICAgfVxuICAgIGVyYVllYXIoZGF0ZVBhcmFtKSB7XG4gICAgICAgIGxldCBkYXRlID0gZGF0ZVBhcmFtO1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxDYWxlbmRhcih0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsWWVhck1vbnRoKGRhdGUpKVxuICAgICAgICAgICAgZGF0ZSA9IFRvVGVtcG9yYWxEYXRlKGRhdGUpO1xuICAgICAgICByZXR1cm4gaW1wbFtHZXRTbG90KHRoaXMsIENBTEVOREFSX0lEKV0uZXJhWWVhcihkYXRlKTtcbiAgICB9XG4gICAgZGF5T2ZXZWVrKGRhdGVQYXJhbSkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxDYWxlbmRhcih0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgY29uc3QgZGF0ZSA9IFRvVGVtcG9yYWxEYXRlKGRhdGVQYXJhbSk7XG4gICAgICAgIHJldHVybiBpbXBsW0dldFNsb3QodGhpcywgQ0FMRU5EQVJfSUQpXS5kYXlPZldlZWsoZGF0ZSk7XG4gICAgfVxuICAgIGRheU9mWWVhcihkYXRlUGFyYW0pIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsQ2FsZW5kYXIodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIGNvbnN0IGRhdGUgPSBUb1RlbXBvcmFsRGF0ZShkYXRlUGFyYW0pO1xuICAgICAgICByZXR1cm4gaW1wbFtHZXRTbG90KHRoaXMsIENBTEVOREFSX0lEKV0uZGF5T2ZZZWFyKGRhdGUpO1xuICAgIH1cbiAgICB3ZWVrT2ZZZWFyKGRhdGVQYXJhbSkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxDYWxlbmRhcih0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgY29uc3QgZGF0ZSA9IFRvVGVtcG9yYWxEYXRlKGRhdGVQYXJhbSk7XG4gICAgICAgIHJldHVybiBpbXBsW0dldFNsb3QodGhpcywgQ0FMRU5EQVJfSUQpXS53ZWVrT2ZZZWFyKGRhdGUpO1xuICAgIH1cbiAgICBkYXlzSW5XZWVrKGRhdGVQYXJhbSkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxDYWxlbmRhcih0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgY29uc3QgZGF0ZSA9IFRvVGVtcG9yYWxEYXRlKGRhdGVQYXJhbSk7XG4gICAgICAgIHJldHVybiBpbXBsW0dldFNsb3QodGhpcywgQ0FMRU5EQVJfSUQpXS5kYXlzSW5XZWVrKGRhdGUpO1xuICAgIH1cbiAgICBkYXlzSW5Nb250aChkYXRlUGFyYW0pIHtcbiAgICAgICAgbGV0IGRhdGUgPSBkYXRlUGFyYW07XG4gICAgICAgIGlmICghSXNUZW1wb3JhbENhbGVuZGFyKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxZZWFyTW9udGgoZGF0ZSkpXG4gICAgICAgICAgICBkYXRlID0gVG9UZW1wb3JhbERhdGUoZGF0ZSk7XG4gICAgICAgIHJldHVybiBpbXBsW0dldFNsb3QodGhpcywgQ0FMRU5EQVJfSUQpXS5kYXlzSW5Nb250aChkYXRlKTtcbiAgICB9XG4gICAgZGF5c0luWWVhcihkYXRlUGFyYW0pIHtcbiAgICAgICAgbGV0IGRhdGUgPSBkYXRlUGFyYW07XG4gICAgICAgIGlmICghSXNUZW1wb3JhbENhbGVuZGFyKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxZZWFyTW9udGgoZGF0ZSkpXG4gICAgICAgICAgICBkYXRlID0gVG9UZW1wb3JhbERhdGUoZGF0ZSk7XG4gICAgICAgIHJldHVybiBpbXBsW0dldFNsb3QodGhpcywgQ0FMRU5EQVJfSUQpXS5kYXlzSW5ZZWFyKGRhdGUpO1xuICAgIH1cbiAgICBtb250aHNJblllYXIoZGF0ZVBhcmFtKSB7XG4gICAgICAgIGxldCBkYXRlID0gZGF0ZVBhcmFtO1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxDYWxlbmRhcih0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsWWVhck1vbnRoKGRhdGUpKVxuICAgICAgICAgICAgZGF0ZSA9IFRvVGVtcG9yYWxEYXRlKGRhdGUpO1xuICAgICAgICByZXR1cm4gaW1wbFtHZXRTbG90KHRoaXMsIENBTEVOREFSX0lEKV0ubW9udGhzSW5ZZWFyKGRhdGUpO1xuICAgIH1cbiAgICBpbkxlYXBZZWFyKGRhdGVQYXJhbSkge1xuICAgICAgICBsZXQgZGF0ZSA9IGRhdGVQYXJhbTtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsQ2FsZW5kYXIodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbFllYXJNb250aChkYXRlKSlcbiAgICAgICAgICAgIGRhdGUgPSBUb1RlbXBvcmFsRGF0ZShkYXRlKTtcbiAgICAgICAgcmV0dXJuIGltcGxbR2V0U2xvdCh0aGlzLCBDQUxFTkRBUl9JRCldLmluTGVhcFllYXIoZGF0ZSk7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxDYWxlbmRhcih0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgcmV0dXJuIEdldFNsb3QodGhpcywgQ0FMRU5EQVJfSUQpO1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbENhbGVuZGFyKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICByZXR1cm4gVG9TdHJpbmcodGhpcyk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tKGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIFRvVGVtcG9yYWxDYWxlbmRhcihpdGVtKTtcbiAgICB9XG59XG5NYWtlSW50cmluc2ljQ2xhc3MoQ2FsZW5kYXIsICdUZW1wb3JhbC5DYWxlbmRhcicpO1xuRGVmaW5lSW50cmluc2ljKCdUZW1wb3JhbC5DYWxlbmRhci5mcm9tJywgQ2FsZW5kYXIuZnJvbSk7XG4vKipcbiAqIEltcGxlbWVudGF0aW9uIGZvciB0aGUgSVNPIDg2MDEgY2FsZW5kYXIuIFRoaXMgaXMgdGhlIG9ubHkgY2FsZW5kYXIgdGhhdCdzXG4gKiBndWFyYW50ZWVkIHRvIGJlIHN1cHBvcnRlZCBieSBhbGwgRUNNQVNjcmlwdCBpbXBsZW1lbnRhdGlvbnMsIGluY2x1ZGluZyB0aG9zZVxuICogd2l0aG91dCBJbnRsIChFQ01BLTQwMikgc3VwcG9ydC5cbiAqL1xuaW1wbFsnaXNvODYwMSddID0ge1xuICAgIGRhdGVGcm9tRmllbGRzKGZpZWxkc1BhcmFtLCBvcHRpb25zLCBjYWxlbmRhcikge1xuICAgICAgICBjb25zdCBvdmVyZmxvdyA9IFRvVGVtcG9yYWxPdmVyZmxvdyhvcHRpb25zKTtcbiAgICAgICAgbGV0IGZpZWxkcyA9IFByZXBhcmVUZW1wb3JhbEZpZWxkcyhmaWVsZHNQYXJhbSwgW1xuICAgICAgICAgICAgWydkYXknXSxcbiAgICAgICAgICAgIFsnbW9udGgnLCB1bmRlZmluZWRdLFxuICAgICAgICAgICAgWydtb250aENvZGUnLCB1bmRlZmluZWRdLFxuICAgICAgICAgICAgWyd5ZWFyJ11cbiAgICAgICAgXSk7XG4gICAgICAgIGZpZWxkcyA9IHJlc29sdmVOb25MdW5pc29sYXJNb250aChmaWVsZHMpO1xuICAgICAgICBsZXQgeyB5ZWFyLCBtb250aCwgZGF5IH0gPSBmaWVsZHM7XG4gICAgICAgICh7IHllYXIsIG1vbnRoLCBkYXkgfSA9IFJlZ3VsYXRlSVNPRGF0ZSh5ZWFyLCBtb250aCwgZGF5LCBvdmVyZmxvdykpO1xuICAgICAgICByZXR1cm4gQ3JlYXRlVGVtcG9yYWxEYXRlKHllYXIsIG1vbnRoLCBkYXksIGNhbGVuZGFyKTtcbiAgICB9LFxuICAgIHllYXJNb250aEZyb21GaWVsZHMoZmllbGRzUGFyYW0sIG9wdGlvbnMsIGNhbGVuZGFyKSB7XG4gICAgICAgIGNvbnN0IG92ZXJmbG93ID0gVG9UZW1wb3JhbE92ZXJmbG93KG9wdGlvbnMpO1xuICAgICAgICBsZXQgZmllbGRzID0gUHJlcGFyZVRlbXBvcmFsRmllbGRzKGZpZWxkc1BhcmFtLCBbXG4gICAgICAgICAgICBbJ21vbnRoJywgdW5kZWZpbmVkXSxcbiAgICAgICAgICAgIFsnbW9udGhDb2RlJywgdW5kZWZpbmVkXSxcbiAgICAgICAgICAgIFsneWVhciddXG4gICAgICAgIF0pO1xuICAgICAgICBmaWVsZHMgPSByZXNvbHZlTm9uTHVuaXNvbGFyTW9udGgoZmllbGRzKTtcbiAgICAgICAgbGV0IHsgeWVhciwgbW9udGggfSA9IGZpZWxkcztcbiAgICAgICAgKHsgeWVhciwgbW9udGggfSA9IFJlZ3VsYXRlSVNPWWVhck1vbnRoKHllYXIsIG1vbnRoLCBvdmVyZmxvdykpO1xuICAgICAgICByZXR1cm4gQ3JlYXRlVGVtcG9yYWxZZWFyTW9udGgoeWVhciwgbW9udGgsIGNhbGVuZGFyLCAvKiByZWZlcmVuY2VJU09EYXkgPSAqLyAxKTtcbiAgICB9LFxuICAgIG1vbnRoRGF5RnJvbUZpZWxkcyhmaWVsZHNQYXJhbSwgb3B0aW9ucywgY2FsZW5kYXIpIHtcbiAgICAgICAgY29uc3Qgb3ZlcmZsb3cgPSBUb1RlbXBvcmFsT3ZlcmZsb3cob3B0aW9ucyk7XG4gICAgICAgIGxldCBmaWVsZHMgPSBQcmVwYXJlVGVtcG9yYWxGaWVsZHMoZmllbGRzUGFyYW0sIFtcbiAgICAgICAgICAgIFsnZGF5J10sXG4gICAgICAgICAgICBbJ21vbnRoJywgdW5kZWZpbmVkXSxcbiAgICAgICAgICAgIFsnbW9udGhDb2RlJywgdW5kZWZpbmVkXSxcbiAgICAgICAgICAgIFsneWVhcicsIHVuZGVmaW5lZF1cbiAgICAgICAgXSk7XG4gICAgICAgIGlmIChmaWVsZHMubW9udGggIT09IHVuZGVmaW5lZCAmJiBmaWVsZHMueWVhciA9PT0gdW5kZWZpbmVkICYmIGZpZWxkcy5tb250aENvZGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZWl0aGVyIHllYXIgb3IgbW9udGhDb2RlIHJlcXVpcmVkIHdpdGggbW9udGgnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1c2VZZWFyID0gZmllbGRzLm1vbnRoQ29kZSA9PT0gdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCByZWZlcmVuY2VJU09ZZWFyID0gMTk3MjtcbiAgICAgICAgZmllbGRzID0gcmVzb2x2ZU5vbkx1bmlzb2xhck1vbnRoKGZpZWxkcyk7XG4gICAgICAgIGxldCB7IG1vbnRoLCBkYXksIHllYXIgfSA9IGZpZWxkcztcbiAgICAgICAgKHsgbW9udGgsIGRheSB9ID0gUmVndWxhdGVJU09EYXRlKHVzZVllYXIgPyB5ZWFyIDogcmVmZXJlbmNlSVNPWWVhciwgbW9udGgsIGRheSwgb3ZlcmZsb3cpKTtcbiAgICAgICAgcmV0dXJuIENyZWF0ZVRlbXBvcmFsTW9udGhEYXkobW9udGgsIGRheSwgY2FsZW5kYXIsIHJlZmVyZW5jZUlTT1llYXIpO1xuICAgIH0sXG4gICAgZmllbGRzKGZpZWxkcykge1xuICAgICAgICByZXR1cm4gZmllbGRzO1xuICAgIH0sXG4gICAgbWVyZ2VGaWVsZHMoZmllbGRzLCBhZGRpdGlvbmFsRmllbGRzKSB7XG4gICAgICAgIGNvbnN0IG1lcmdlZCA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IG5leHRLZXkgb2YgT2JqZWN0S2V5cyhmaWVsZHMpKSB7XG4gICAgICAgICAgICBpZiAobmV4dEtleSA9PT0gJ21vbnRoJyB8fCBuZXh0S2V5ID09PSAnbW9udGhDb2RlJylcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIG1lcmdlZFtuZXh0S2V5XSA9IGZpZWxkc1tuZXh0S2V5XTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuZXdLZXlzID0gT2JqZWN0S2V5cyhhZGRpdGlvbmFsRmllbGRzKTtcbiAgICAgICAgZm9yIChjb25zdCBuZXh0S2V5IG9mIG5ld0tleXMpIHtcbiAgICAgICAgICAgIG1lcmdlZFtuZXh0S2V5XSA9IGFkZGl0aW9uYWxGaWVsZHNbbmV4dEtleV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFBcnJheUluY2x1ZGVzLmNhbGwobmV3S2V5cywgJ21vbnRoJykgJiYgIUFycmF5SW5jbHVkZXMuY2FsbChuZXdLZXlzLCAnbW9udGhDb2RlJykpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgbW9udGgsIG1vbnRoQ29kZSB9ID0gZmllbGRzO1xuICAgICAgICAgICAgaWYgKG1vbnRoICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgbWVyZ2VkLm1vbnRoID0gbW9udGg7XG4gICAgICAgICAgICBpZiAobW9udGhDb2RlICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgbWVyZ2VkLm1vbnRoQ29kZSA9IG1vbnRoQ29kZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVyZ2VkO1xuICAgIH0sXG4gICAgZGF0ZUFkZChkYXRlLCB5ZWFycywgbW9udGhzLCB3ZWVrcywgZGF5cywgb3ZlcmZsb3csIGNhbGVuZGFyKSB7XG4gICAgICAgIGxldCB5ZWFyID0gR2V0U2xvdChkYXRlLCBJU09fWUVBUik7XG4gICAgICAgIGxldCBtb250aCA9IEdldFNsb3QoZGF0ZSwgSVNPX01PTlRIKTtcbiAgICAgICAgbGV0IGRheSA9IEdldFNsb3QoZGF0ZSwgSVNPX0RBWSk7XG4gICAgICAgICh7IHllYXIsIG1vbnRoLCBkYXkgfSA9IEFkZElTT0RhdGUoeWVhciwgbW9udGgsIGRheSwgeWVhcnMsIG1vbnRocywgd2Vla3MsIGRheXMsIG92ZXJmbG93KSk7XG4gICAgICAgIHJldHVybiBDcmVhdGVUZW1wb3JhbERhdGUoeWVhciwgbW9udGgsIGRheSwgY2FsZW5kYXIpO1xuICAgIH0sXG4gICAgZGF0ZVVudGlsKG9uZSwgdHdvLCBsYXJnZXN0VW5pdCkge1xuICAgICAgICByZXR1cm4gRGlmZmVyZW5jZUlTT0RhdGUoR2V0U2xvdChvbmUsIElTT19ZRUFSKSwgR2V0U2xvdChvbmUsIElTT19NT05USCksIEdldFNsb3Qob25lLCBJU09fREFZKSwgR2V0U2xvdCh0d28sIElTT19ZRUFSKSwgR2V0U2xvdCh0d28sIElTT19NT05USCksIEdldFNsb3QodHdvLCBJU09fREFZKSwgbGFyZ2VzdFVuaXQpO1xuICAgIH0sXG4gICAgeWVhcihkYXRlKSB7XG4gICAgICAgIHJldHVybiBHZXRTbG90KGRhdGUsIElTT19ZRUFSKTtcbiAgICB9LFxuICAgIGVyYSgpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9LFxuICAgIGVyYVllYXIoKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfSxcbiAgICBtb250aChkYXRlKSB7XG4gICAgICAgIHJldHVybiBHZXRTbG90KGRhdGUsIElTT19NT05USCk7XG4gICAgfSxcbiAgICBtb250aENvZGUoZGF0ZSkge1xuICAgICAgICByZXR1cm4gYnVpbGRNb250aENvZGUoR2V0U2xvdChkYXRlLCBJU09fTU9OVEgpKTtcbiAgICB9LFxuICAgIGRheShkYXRlKSB7XG4gICAgICAgIHJldHVybiBHZXRTbG90KGRhdGUsIElTT19EQVkpO1xuICAgIH0sXG4gICAgZGF5T2ZXZWVrKGRhdGUpIHtcbiAgICAgICAgcmV0dXJuIERheU9mV2VlayhHZXRTbG90KGRhdGUsIElTT19ZRUFSKSwgR2V0U2xvdChkYXRlLCBJU09fTU9OVEgpLCBHZXRTbG90KGRhdGUsIElTT19EQVkpKTtcbiAgICB9LFxuICAgIGRheU9mWWVhcihkYXRlKSB7XG4gICAgICAgIHJldHVybiBEYXlPZlllYXIoR2V0U2xvdChkYXRlLCBJU09fWUVBUiksIEdldFNsb3QoZGF0ZSwgSVNPX01PTlRIKSwgR2V0U2xvdChkYXRlLCBJU09fREFZKSk7XG4gICAgfSxcbiAgICB3ZWVrT2ZZZWFyKGRhdGUpIHtcbiAgICAgICAgcmV0dXJuIFdlZWtPZlllYXIoR2V0U2xvdChkYXRlLCBJU09fWUVBUiksIEdldFNsb3QoZGF0ZSwgSVNPX01PTlRIKSwgR2V0U2xvdChkYXRlLCBJU09fREFZKSk7XG4gICAgfSxcbiAgICBkYXlzSW5XZWVrKCkge1xuICAgICAgICByZXR1cm4gNztcbiAgICB9LFxuICAgIGRheXNJbk1vbnRoKGRhdGUpIHtcbiAgICAgICAgcmV0dXJuIElTT0RheXNJbk1vbnRoKEdldFNsb3QoZGF0ZSwgSVNPX1lFQVIpLCBHZXRTbG90KGRhdGUsIElTT19NT05USCkpO1xuICAgIH0sXG4gICAgZGF5c0luWWVhcihkYXRlUGFyYW0pIHtcbiAgICAgICAgbGV0IGRhdGUgPSBkYXRlUGFyYW07XG4gICAgICAgIGlmICghSGFzU2xvdChkYXRlLCBJU09fWUVBUikpXG4gICAgICAgICAgICBkYXRlID0gVG9UZW1wb3JhbERhdGUoZGF0ZSk7XG4gICAgICAgIHJldHVybiBMZWFwWWVhcihHZXRTbG90KGRhdGUsIElTT19ZRUFSKSkgPyAzNjYgOiAzNjU7XG4gICAgfSxcbiAgICBtb250aHNJblllYXIoKSB7XG4gICAgICAgIHJldHVybiAxMjtcbiAgICB9LFxuICAgIGluTGVhcFllYXIoZGF0ZVBhcmFtKSB7XG4gICAgICAgIGxldCBkYXRlID0gZGF0ZVBhcmFtO1xuICAgICAgICBpZiAoIUhhc1Nsb3QoZGF0ZSwgSVNPX1lFQVIpKVxuICAgICAgICAgICAgZGF0ZSA9IFRvVGVtcG9yYWxEYXRlKGRhdGUpO1xuICAgICAgICByZXR1cm4gTGVhcFllYXIoR2V0U2xvdChkYXRlLCBJU09fWUVBUikpO1xuICAgIH1cbn07XG5mdW5jdGlvbiBtb250aENvZGVOdW1iZXJQYXJ0KG1vbnRoQ29kZSkge1xuICAgIGlmICghbW9udGhDb2RlLnN0YXJ0c1dpdGgoJ00nKSkge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgSW52YWxpZCBtb250aCBjb2RlOiAke21vbnRoQ29kZX0uICBNb250aCBjb2RlcyBtdXN0IHN0YXJ0IHdpdGggTS5gKTtcbiAgICB9XG4gICAgY29uc3QgbW9udGggPSArbW9udGhDb2RlLnNsaWNlKDEpO1xuICAgIGlmIChpc05hTihtb250aCkpXG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBJbnZhbGlkIG1vbnRoIGNvZGU6ICR7bW9udGhDb2RlfWApO1xuICAgIHJldHVybiBtb250aDtcbn1cbmZ1bmN0aW9uIGJ1aWxkTW9udGhDb2RlKG1vbnRoLCBsZWFwID0gZmFsc2UpIHtcbiAgICByZXR1cm4gYE0ke21vbnRoLnRvU3RyaW5nKCkucGFkU3RhcnQoMiwgJzAnKX0ke2xlYXAgPyAnTCcgOiAnJ31gO1xufVxuLyoqXG4gKiBTYWZlbHkgbWVyZ2UgYSBtb250aCwgbW9udGhDb2RlIHBhaXIgaW50byBhbiBpbnRlZ2VyIG1vbnRoLlxuICogSWYgYm90aCBhcmUgcHJlc2VudCwgbWFrZSBzdXJlIHRoZXkgbWF0Y2guXG4gKiBUaGlzIGxvZ2ljIGRvZXNuJ3Qgd29yayBmb3IgbHVuaXNvbGFyIGNhbGVuZGFycyFcbiAqICovXG5mdW5jdGlvbiByZXNvbHZlTm9uTHVuaXNvbGFyTW9udGgoY2FsZW5kYXJEYXRlLCBvdmVyZmxvdyA9IHVuZGVmaW5lZCwgbW9udGhzUGVyWWVhciA9IDEyKSB7XG4gICAgbGV0IHsgbW9udGgsIG1vbnRoQ29kZSB9ID0gY2FsZW5kYXJEYXRlO1xuICAgIGlmIChtb250aENvZGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAobW9udGggPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0VpdGhlciBtb250aCBvciBtb250aENvZGUgYXJlIHJlcXVpcmVkJyk7XG4gICAgICAgIC8vIFRoZSBJU08gY2FsZW5kYXIgdXNlcyB0aGUgZGVmYXVsdCAodW5kZWZpbmVkKSB2YWx1ZSBiZWNhdXNlIGl0IGRvZXNcbiAgICAgICAgLy8gY29uc3RyYWluL3JlamVjdCBhZnRlciB0aGlzIG1ldGhvZCByZXR1cm5zLiBOb24tSVNPIGNhbGVuZGFycywgaG93ZXZlcixcbiAgICAgICAgLy8gcmVseSBvbiB0aGlzIGZ1bmN0aW9uIHRvIGNvbnN0cmFpbi9yZWplY3Qgb3V0LW9mLXJhbmdlIGBtb250aGAgdmFsdWVzLlxuICAgICAgICBpZiAob3ZlcmZsb3cgPT09ICdyZWplY3QnKVxuICAgICAgICAgICAgUmVqZWN0VG9SYW5nZShtb250aCwgMSwgbW9udGhzUGVyWWVhcik7XG4gICAgICAgIGlmIChvdmVyZmxvdyA9PT0gJ2NvbnN0cmFpbicpXG4gICAgICAgICAgICBtb250aCA9IENvbnN0cmFpblRvUmFuZ2UobW9udGgsIDEsIG1vbnRoc1BlclllYXIpO1xuICAgICAgICBtb250aENvZGUgPSBidWlsZE1vbnRoQ29kZShtb250aCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBudW1iZXJQYXJ0ID0gbW9udGhDb2RlTnVtYmVyUGFydChtb250aENvZGUpO1xuICAgICAgICBpZiAobW9udGggIT09IHVuZGVmaW5lZCAmJiBtb250aCAhPT0gbnVtYmVyUGFydCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYG1vbnRoQ29kZSAke21vbnRoQ29kZX0gYW5kIG1vbnRoICR7bW9udGh9IG11c3QgbWF0Y2ggaWYgYm90aCBhcmUgcHJlc2VudGApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtb250aENvZGUgIT09IGJ1aWxkTW9udGhDb2RlKG51bWJlclBhcnQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgSW52YWxpZCBtb250aCBjb2RlOiAke21vbnRoQ29kZX1gKTtcbiAgICAgICAgfVxuICAgICAgICBtb250aCA9IG51bWJlclBhcnQ7XG4gICAgICAgIGlmIChtb250aCA8IDEgfHwgbW9udGggPiBtb250aHNQZXJZZWFyKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYEludmFsaWQgbW9udGhDb2RlOiAke21vbnRoQ29kZX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgLi4uY2FsZW5kYXJEYXRlLCBtb250aCwgbW9udGhDb2RlIH07XG59XG4vKipcbiAqIFRoaXMgcHJvdG90eXBlIGltcGxlbWVudGF0aW9uIG9mIG5vbi1JU08gY2FsZW5kYXJzIG1ha2VzIG1hbnkgcmVwZWF0ZWQgY2FsbHNcbiAqIHRvIEludGwgQVBJcyB3aGljaCBtYXkgYmUgc2xvdyAoZS5nLiA+MC4ybXMpLiBUaGlzIHRyaXZpYWwgY2FjaGUgd2lsbCBzcGVlZFxuICogdXAgdGhlc2UgcmVwZWF0IGFjY2Vzc2VzLiBFYWNoIGNhY2hlIGluc3RhbmNlIGlzIGFzc29jaWF0ZWQgKHZpYSBhIFdlYWtNYXApXG4gKiB0byBhIHNwZWNpZmljIFRlbXBvcmFsIG9iamVjdCwgd2hpY2ggc3BlZWRzIHVwIG11bHRpcGxlIGNhbGVuZGFyIGNhbGxzIG9uIHRoZVxuICogc2FtZSBUZW1wb3JhbCBvYmplY3QgaW5zdGFuY2UuICBObyBpbnZhbGlkYXRpb24gb3IgcHJ1bmluZyBpcyBuZWNlc3NhcnlcbiAqIGJlY2F1c2UgZWFjaCBvYmplY3QncyBjYWNoZSBpcyB0aHJvd24gYXdheSB3aGVuIHRoZSBvYmplY3QgaXMgR0MtZWQuXG4gKi9cbmNsYXNzIE9uZU9iamVjdENhY2hlIHtcbiAgICBjb25zdHJ1Y3RvcihjYWNoZVRvQ2xvbmUpIHtcbiAgICAgICAgdGhpcy5tYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuY2FsbHMgPSAwO1xuICAgICAgICB0aGlzLmhpdHMgPSAwO1xuICAgICAgICB0aGlzLm1pc3NlcyA9IDA7XG4gICAgICAgIHRoaXMubm93ID0gZ2xvYmFsVGhpcy5wZXJmb3JtYW5jZSA/IGdsb2JhbFRoaXMucGVyZm9ybWFuY2Uubm93KCkgOiBEYXRlLm5vdygpO1xuICAgICAgICBpZiAoY2FjaGVUb0Nsb25lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZW50cnkgb2YgY2FjaGVUb0Nsb25lLm1hcC5lbnRyaWVzKCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoKytpID4gT25lT2JqZWN0Q2FjaGUuTUFYX0NBQ0hFX0VOVFJJRVMpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIHRoaXMubWFwLnNldCguLi5lbnRyeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0KGtleSkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLm1hcC5nZXQoa2V5KTtcbiAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgdGhpcy5oaXRzKys7XG4gICAgICAgICAgICB0aGlzLnJlcG9ydCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2FsbHMrKztcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgc2V0KGtleSwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5tYXAuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICB0aGlzLm1pc3NlcysrO1xuICAgICAgICB0aGlzLnJlcG9ydCgpO1xuICAgIH1cbiAgICByZXBvcnQoKSB7XG4gICAgICAgIC8qXG4gICAgICAgIGlmICh0aGlzLmNhbGxzID09PSAwKSByZXR1cm47XG4gICAgICAgIGNvbnN0IG1zID0gKGdsb2JhbFRoaXMucGVyZm9ybWFuY2UgPyBnbG9iYWxUaGlzLnBlcmZvcm1hbmNlLm5vdygpIDogRGF0ZS5ub3coKSkgLSB0aGlzLm5vdztcbiAgICAgICAgY29uc3QgaGl0UmF0ZSA9ICgoMTAwICogdGhpcy5oaXRzKSAvIHRoaXMuY2FsbHMpLnRvRml4ZWQoMCk7XG4gICAgICAgIGNvbnNvbGUubG9nKGAke3RoaXMuY2FsbHN9IGNhbGxzIGluICR7bXMudG9GaXhlZCgyKX1tcy4gSGl0czogJHt0aGlzLmhpdHN9ICgke2hpdFJhdGV9JSkuIE1pc3NlczogJHt0aGlzLm1pc3Nlc30uYCk7XG4gICAgICAgICovXG4gICAgfVxuICAgIHNldE9iamVjdChvYmopIHtcbiAgICAgICAgaWYgKE9uZU9iamVjdENhY2hlLm9iamVjdE1hcC5nZXQob2JqKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdvYmplY3QgYWxyZWFkeSBjYWNoZWQnKTtcbiAgICAgICAgT25lT2JqZWN0Q2FjaGUub2JqZWN0TWFwLnNldChvYmosIHRoaXMpO1xuICAgICAgICB0aGlzLnJlcG9ydCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgV2Vha01hcC1iYWNrZWQgY2FjaGUgdGhhdCdzIHVzZWQgdG8gc3RvcmUgZXhwZW5zaXZlIHJlc3VsdHNcbiAgICAgKiB0aGF0IGFyZSBhc3NvY2lhdGVkIHdpdGggYSBwYXJ0aWN1bGFyIFRlbXBvcmFsIG9iamVjdCBpbnN0YW5jZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvYmogLSBvYmplY3QgdG8gYXNzb2NpYXRlIHdpdGggdGhlIGNhY2hlXG4gICAgICovXG4gICAgc3RhdGljIGdldENhY2hlRm9yT2JqZWN0KG9iaikge1xuICAgICAgICBsZXQgY2FjaGUgPSBPbmVPYmplY3RDYWNoZS5vYmplY3RNYXAuZ2V0KG9iaik7XG4gICAgICAgIGlmICghY2FjaGUpIHtcbiAgICAgICAgICAgIGNhY2hlID0gbmV3IE9uZU9iamVjdENhY2hlKCk7XG4gICAgICAgICAgICBPbmVPYmplY3RDYWNoZS5vYmplY3RNYXAuc2V0KG9iaiwgY2FjaGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjYWNoZTtcbiAgICB9XG59XG5PbmVPYmplY3RDYWNoZS5vYmplY3RNYXAgPSBuZXcgV2Vha01hcCgpO1xuT25lT2JqZWN0Q2FjaGUuTUFYX0NBQ0hFX0VOVFJJRVMgPSAxMDAwO1xuZnVuY3Rpb24gdG9VdGNJc29EYXRlU3RyaW5nKHsgaXNvWWVhciwgaXNvTW9udGgsIGlzb0RheSB9KSB7XG4gICAgY29uc3QgeWVhclN0cmluZyA9IElTT1llYXJTdHJpbmcoaXNvWWVhcik7XG4gICAgY29uc3QgbW9udGhTdHJpbmcgPSBJU09EYXRlVGltZVBhcnRTdHJpbmcoaXNvTW9udGgpO1xuICAgIGNvbnN0IGRheVN0cmluZyA9IElTT0RhdGVUaW1lUGFydFN0cmluZyhpc29EYXkpO1xuICAgIHJldHVybiBgJHt5ZWFyU3RyaW5nfS0ke21vbnRoU3RyaW5nfS0ke2RheVN0cmluZ31UMDA6MDBaYDtcbn1cbmZ1bmN0aW9uIHNpbXBsZURhdGVEaWZmKG9uZSwgdHdvKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgeWVhcnM6IG9uZS55ZWFyIC0gdHdvLnllYXIsXG4gICAgICAgIG1vbnRoczogb25lLm1vbnRoIC0gdHdvLm1vbnRoLFxuICAgICAgICBkYXlzOiBvbmUuZGF5IC0gdHdvLmRheVxuICAgIH07XG59XG4vKipcbiAqIEltcGxlbWVudGF0aW9uIGhlbHBlciB0aGF0J3MgY29tbW9uIHRvIGFsbCBub24tSVNPIGNhbGVuZGFyc1xuICovXG5jbGFzcyBIZWxwZXJCYXNlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgLy8gVGhlIHNob3J0IGVyYSBmb3JtYXQgd29ya3MgZm9yIGFsbCBjYWxlbmRhcnMgZXhjZXB0IEphcGFuZXNlLCB3aGljaCB3aWxsXG4gICAgICAgIC8vIG92ZXJyaWRlLlxuICAgICAgICB0aGlzLmVyYUxlbmd0aCA9ICdzaG9ydCc7XG4gICAgICAgIC8vIEFsbCBidWlsdC1pbiBjYWxlbmRhcnMgZXhjZXB0IENoaW5lc2UvRGFuZ2kgYW5kIEhlYnJldyB1c2UgYW4gZXJhXG4gICAgICAgIHRoaXMuaGFzRXJhID0gdHJ1ZTtcbiAgICB9XG4gICAgZ2V0Rm9ybWF0dGVyKCkge1xuICAgICAgICAvLyBgbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQoKWAgaXMgYW1hemluZ2x5IHNsb3cgYW5kIGNoZXdzIHVwIFJBTS4gUGVyXG4gICAgICAgIC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTY1MjgjYzQsIHdlIGNhY2hlIG9uZVxuICAgICAgICAvLyBEYXRlVGltZUZvcm1hdCBpbnN0YW5jZSBwZXIgY2FsZW5kYXIuIENhY2hpbmcgaXMgbGF6eSBzbyB3ZSBvbmx5IHBheSBmb3JcbiAgICAgICAgLy8gY2FsZW5kYXJzIHRoYXQgYXJlIHVzZWQuIE5vdGUgdGhhdCB0aGUgbm9uSXNvSGVscGVyQmFzZSBvYmplY3QgaXMgc3ByZWFkXG4gICAgICAgIC8vIGludG8gZWFjaCBlYWNoIGNhbGVuZGFyJ3MgaW1wbGVtZW50YXRpb24gYmVmb3JlIGFueSBjYWNoZSBpcyBjcmVhdGVkLCBzb1xuICAgICAgICAvLyBlYWNoIGNhbGVuZGFyIGdldHMgaXRzIG93biBzZXBhcmF0ZSBjYWNoZWQgZm9ybWF0dGVyLlxuICAgICAgICBpZiAodHlwZW9mIHRoaXMuZm9ybWF0dGVyID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhpcy5mb3JtYXR0ZXIgPSBuZXcgSW50bERhdGVUaW1lRm9ybWF0JDIoYGVuLVVTLXUtY2EtJHt0aGlzLmlkfWAsIHtcbiAgICAgICAgICAgICAgICBkYXk6ICdudW1lcmljJyxcbiAgICAgICAgICAgICAgICBtb250aDogJ251bWVyaWMnLFxuICAgICAgICAgICAgICAgIHllYXI6ICdudW1lcmljJyxcbiAgICAgICAgICAgICAgICBlcmE6IHRoaXMuZXJhTGVuZ3RoLFxuICAgICAgICAgICAgICAgIHRpbWVab25lOiAnVVRDJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZm9ybWF0dGVyO1xuICAgIH1cbiAgICBpc29Ub0NhbGVuZGFyRGF0ZShpc29EYXRlLCBjYWNoZSkge1xuICAgICAgICBjb25zdCB7IHllYXI6IGlzb1llYXIsIG1vbnRoOiBpc29Nb250aCwgZGF5OiBpc29EYXkgfSA9IGlzb0RhdGU7XG4gICAgICAgIGNvbnN0IGtleSA9IEpTT04uc3RyaW5naWZ5KHsgZnVuYzogJ2lzb1RvQ2FsZW5kYXJEYXRlJywgaXNvWWVhciwgaXNvTW9udGgsIGlzb0RheSwgaWQ6IHRoaXMuaWQgfSk7XG4gICAgICAgIGNvbnN0IGNhY2hlZCA9IGNhY2hlLmdldChrZXkpO1xuICAgICAgICBpZiAoY2FjaGVkKVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZDtcbiAgICAgICAgY29uc3QgZGF0ZVRpbWVGb3JtYXQgPSB0aGlzLmdldEZvcm1hdHRlcigpO1xuICAgICAgICBsZXQgcGFydHMsIGlzb1N0cmluZztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlzb1N0cmluZyA9IHRvVXRjSXNvRGF0ZVN0cmluZyh7IGlzb1llYXIsIGlzb01vbnRoLCBpc29EYXkgfSk7XG4gICAgICAgICAgICBwYXJ0cyA9IGRhdGVUaW1lRm9ybWF0LmZvcm1hdFRvUGFydHMobmV3IERhdGUoaXNvU3RyaW5nKSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBJbnZhbGlkIElTTyBkYXRlOiAke0pTT04uc3RyaW5naWZ5KHsgaXNvWWVhciwgaXNvTW9udGgsIGlzb0RheSB9KX1gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICAgICAgZm9yIChsZXQgeyB0eXBlLCB2YWx1ZSB9IG9mIHBhcnRzKSB7XG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gJ3llYXInKVxuICAgICAgICAgICAgICAgIHJlc3VsdC5lcmFZZWFyID0gK3ZhbHVlO1xuICAgICAgICAgICAgLy8gVE9ETzogcmVtb3ZlIHRoaXMgdHlwZSBhbm5vdGF0aW9uIHdoZW4gYHJlbGF0ZWRZZWFyYCBnZXRzIGludG8gVFMgbGliIHR5cGVzXG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gJ3JlbGF0ZWRZZWFyJylcbiAgICAgICAgICAgICAgICByZXN1bHQuZXJhWWVhciA9ICt2YWx1ZTtcbiAgICAgICAgICAgIGlmICh0eXBlID09PSAnbW9udGgnKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWF0Y2hlcyA9IC9eKFswLTldKikoLio/KSQvLmV4ZWModmFsdWUpO1xuICAgICAgICAgICAgICAgIGlmICghbWF0Y2hlcyB8fCBtYXRjaGVzLmxlbmd0aCAhPSAzIHx8ICghbWF0Y2hlc1sxXSAmJiAhbWF0Y2hlc1syXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYFVuZXhwZWN0ZWQgbW9udGg6ICR7dmFsdWV9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBtb250aCBoYXMgbm8gbnVtZXJpYyBwYXJ0IChzaG91bGQgb25seSBzZWUgdGhpcyBmb3IgdGhlIEhlYnJld1xuICAgICAgICAgICAgICAgIC8vIGNhbGVuZGFyIHdpdGggbmV3ZXIgRkYgLyBDaHJvbWl1bSB2ZXJzaW9uczsgc2VlXG4gICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTc1MTgzMykgdGhlbiBzZXQgYVxuICAgICAgICAgICAgICAgIC8vIHBsYWNlaG9sZGVyIG1vbnRoIGluZGV4IG9mIGAxYCBhbmQgcmVseSBvbiB0aGUgZGVyaXZlZCBjbGFzcyB0b1xuICAgICAgICAgICAgICAgIC8vIGNhbGN1bGF0ZSB0aGUgY29ycmVjdCBtb250aCBpbmRleCBmcm9tIHRoZSBtb250aCBuYW1lIHN0b3JlZCBpblxuICAgICAgICAgICAgICAgIC8vIGBtb250aEV4dHJhYC5cbiAgICAgICAgICAgICAgICByZXN1bHQubW9udGggPSBtYXRjaGVzWzFdID8gK21hdGNoZXNbMV0gOiAxO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQubW9udGggPCAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBJbnZhbGlkIG1vbnRoICR7dmFsdWV9IGZyb20gJHtpc29TdHJpbmd9W3UtY2EtJHt0aGlzLmlkfV1gICtcbiAgICAgICAgICAgICAgICAgICAgICAgICcgKHByb2JhYmx5IGR1ZSB0byBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0xMDUyNyknKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5tb250aCA+IDEzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBJbnZhbGlkIG1vbnRoICR7dmFsdWV9IGZyb20gJHtpc29TdHJpbmd9W3UtY2EtJHt0aGlzLmlkfV1gICtcbiAgICAgICAgICAgICAgICAgICAgICAgICcgKHByb2JhYmx5IGR1ZSB0byBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0xMDUyOSknKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gVGhlIElDVSBmb3JtYXRzIGZvciB0aGUgSGVicmV3IGNhbGVuZGFyIG5vIGxvbmdlciBzdXBwb3J0IGEgbnVtZXJpY1xuICAgICAgICAgICAgICAgIC8vIG1vbnRoIGZvcm1hdC4gU28gd2UnbGwgcmVseSBvbiB0aGUgZGVyaXZlZCBjbGFzcyB0byBpbnRlcnByZXQgaXQuXG4gICAgICAgICAgICAgICAgLy8gYG1vbnRoRXh0cmFgIGlzIGFsc28gdXNlZCBvbiB0aGUgQ2hpbmVzZSBjYWxlbmRhciB0byBoYW5kbGUgYSBzdWZmaXhcbiAgICAgICAgICAgICAgICAvLyBcImJpc1wiIGluZGljYXRpbmcgYSBsZWFwIG1vbnRoLlxuICAgICAgICAgICAgICAgIGlmIChtYXRjaGVzWzJdKVxuICAgICAgICAgICAgICAgICAgICByZXN1bHQubW9udGhFeHRyYSA9IG1hdGNoZXNbMl07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gJ2RheScpXG4gICAgICAgICAgICAgICAgcmVzdWx0LmRheSA9ICt2YWx1ZTtcbiAgICAgICAgICAgIGlmICh0aGlzLmhhc0VyYSAmJiB0eXBlID09PSAnZXJhJyAmJiB2YWx1ZSAhPSBudWxsICYmIHZhbHVlICE9PSAnJykge1xuICAgICAgICAgICAgICAgIC8vIFRoZSBjb252ZW50aW9uIGZvciBUZW1wb3JhbCBlcmEgdmFsdWVzIGlzIGxvd2VyY2FzZSwgc28gZm9sbG93aW5nXG4gICAgICAgICAgICAgICAgLy8gdGhhdCBjb252ZW50aW9uIGluIHRoaXMgcHJvdG90eXBlLiBQdW5jdHVhdGlvbiBpcyByZW1vdmVkLCBhY2NlbnRlZFxuICAgICAgICAgICAgICAgIC8vIGxldHRlcnMgYXJlIG5vcm1hbGl6ZWQsIGFuZCBzcGFjZXMgYXJlIHJlcGxhY2VkIHdpdGggZGFzaGVzLlxuICAgICAgICAgICAgICAgIC8vIEUuZy46IFwiRVJBMFwiID0+IFwiZXJhMFwiLCBcIkJlZm9yZSBSLk8uQy5cIiA9PiBcImJlZm9yZS1yb2NcIiwgXCJFbuKAmcWNXCIgPT4gXCJlbm9cIlxuICAgICAgICAgICAgICAgIC8vIFRoZSBjYWxsIHRvIG5vcm1hbGl6ZSgpIGFuZCB0aGUgcmVwbGFjZW1lbnQgcmVnZXggZGVhbHMgd2l0aCBlcmFcbiAgICAgICAgICAgICAgICAvLyBuYW1lcyB0aGF0IGNvbnRhaW4gbm9uLUFTQ0lJIGNoYXJhY3RlcnMgbGlrZSBKYXBhbmVzZSBlcmFzLiBBbHNvXG4gICAgICAgICAgICAgICAgLy8gaWdub3JlIGV4dHJhIGNvbnRlbnQgaW4gcGFyZW50aGVzZXMgbGlrZSBKUE4gZXJhIGRhdGUgcmFuZ2VzLlxuICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuc3BsaXQoJyAoJylbMF07XG4gICAgICAgICAgICAgICAgcmVzdWx0LmVyYSA9IHZhbHVlXG4gICAgICAgICAgICAgICAgICAgIC5ub3JtYWxpemUoJ05GRCcpXG4gICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9bXi0wLTkgXFxwe0x9XS9ndSwgJycpXG4gICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKCcgJywgJy0nKVxuICAgICAgICAgICAgICAgICAgICAudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0LmVyYVllYXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gTm9kZSAxMiBoYXMgb3V0ZGF0ZWQgSUNVIGRhdGEgdGhhdCBsYWNrcyB0aGUgYHJlbGF0ZWRZZWFyYCBmaWVsZCBpbiB0aGVcbiAgICAgICAgICAgIC8vIG91dHB1dCBvZiBJbnRsLkRhdGVUaW1lRm9ybWF0LmZvcm1hdFRvUGFydHMuXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgSW50bC5EYXRlVGltZUZvcm1hdC5mb3JtYXRUb1BhcnRzIGxhY2tzIHJlbGF0ZWRZZWFyIGluICR7dGhpcy5pZH0gY2FsZW5kYXIuIFRyeSBOb2RlIDE0KyBvciBtb2Rlcm4gYnJvd3NlcnMuYCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVHJhbnNsYXRlIGVyYXMgdGhhdCBtYXkgYmUgaGFuZGxlZCBkaWZmZXJlbnRseSBieSBUZW1wb3JhbCB2cy4gYnkgSW50bFxuICAgICAgICAvLyAoZS5nLiBKYXBhbmVzZSBwcmUtTWVpamkgZXJhcykuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC10ZW1wb3JhbC9pc3N1ZXMvNTI2LlxuICAgICAgICBpZiAodGhpcy5yZXZpc2VJbnRsRXJhKSB7XG4gICAgICAgICAgICBjb25zdCB7IGVyYSwgZXJhWWVhciB9ID0gdGhpcy5yZXZpc2VJbnRsRXJhKHJlc3VsdCwgaXNvRGF0ZSk7XG4gICAgICAgICAgICByZXN1bHQuZXJhID0gZXJhO1xuICAgICAgICAgICAgcmVzdWx0LmVyYVllYXIgPSBlcmFZZWFyO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNoZWNrSWN1QnVncylcbiAgICAgICAgICAgIHRoaXMuY2hlY2tJY3VCdWdzKGlzb0RhdGUpO1xuICAgICAgICBjb25zdCBjYWxlbmRhckRhdGUgPSB0aGlzLmFkanVzdENhbGVuZGFyRGF0ZShyZXN1bHQsIGNhY2hlLCAnY29uc3RyYWluJywgdHJ1ZSk7XG4gICAgICAgIGlmIChjYWxlbmRhckRhdGUueWVhciA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYE1pc3NpbmcgeWVhciBjb252ZXJ0aW5nICR7SlNPTi5zdHJpbmdpZnkoaXNvRGF0ZSl9YCk7XG4gICAgICAgIGlmIChjYWxlbmRhckRhdGUubW9udGggPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBNaXNzaW5nIG1vbnRoIGNvbnZlcnRpbmcgJHtKU09OLnN0cmluZ2lmeShpc29EYXRlKX1gKTtcbiAgICAgICAgaWYgKGNhbGVuZGFyRGF0ZS5kYXkgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBNaXNzaW5nIGRheSBjb252ZXJ0aW5nICR7SlNPTi5zdHJpbmdpZnkoaXNvRGF0ZSl9YCk7XG4gICAgICAgIGNhY2hlLnNldChrZXksIGNhbGVuZGFyRGF0ZSk7XG4gICAgICAgIC8vIEFsc28gY2FjaGUgdGhlIHJldmVyc2UgbWFwcGluZ1xuICAgICAgICBbJ2NvbnN0cmFpbicsICdyZWplY3QnXS5mb3JFYWNoKChvdmVyZmxvdykgPT4ge1xuICAgICAgICAgICAgY29uc3Qga2V5UmV2ZXJzZSA9IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICBmdW5jOiAnY2FsZW5kYXJUb0lzb0RhdGUnLFxuICAgICAgICAgICAgICAgIHllYXI6IGNhbGVuZGFyRGF0ZS55ZWFyLFxuICAgICAgICAgICAgICAgIG1vbnRoOiBjYWxlbmRhckRhdGUubW9udGgsXG4gICAgICAgICAgICAgICAgZGF5OiBjYWxlbmRhckRhdGUuZGF5LFxuICAgICAgICAgICAgICAgIG92ZXJmbG93LFxuICAgICAgICAgICAgICAgIGlkOiB0aGlzLmlkXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNhY2hlLnNldChrZXlSZXZlcnNlLCBpc29EYXRlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjYWxlbmRhckRhdGU7XG4gICAgfVxuICAgIHZhbGlkYXRlQ2FsZW5kYXJEYXRlKGNhbGVuZGFyRGF0ZSkge1xuICAgICAgICBjb25zdCB7IGVyYSwgbW9udGgsIHllYXIsIGRheSwgZXJhWWVhciwgbW9udGhDb2RlLCBtb250aEV4dHJhIH0gPSBjYWxlbmRhckRhdGU7XG4gICAgICAgIC8vIFdoZW4gdGhlcmUncyBhIHN1ZmZpeCAoZS5nLiBcIjViaXNcIiBmb3IgYSBsZWFwIG1vbnRoIGluIENoaW5lc2UgY2FsZW5kYXIpXG4gICAgICAgIC8vIHRoZSBkZXJpdmVkIGNsYXNzIG11c3QgZGVhbCB3aXRoIGl0LlxuICAgICAgICBpZiAobW9udGhFeHRyYSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1VuZXhwZWN0ZWQgYG1vbnRoRXh0cmFgIHZhbHVlJyk7XG4gICAgICAgIGlmICh5ZWFyID09PSB1bmRlZmluZWQgJiYgZXJhWWVhciA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigneWVhciBvciBlcmFZZWFyIGlzIHJlcXVpcmVkJyk7XG4gICAgICAgIGlmIChtb250aCA9PT0gdW5kZWZpbmVkICYmIG1vbnRoQ29kZSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbW9udGggb3IgbW9udGhDb2RlIGlzIHJlcXVpcmVkJyk7XG4gICAgICAgIGlmIChkYXkgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdNaXNzaW5nIGRheScpO1xuICAgICAgICBpZiAobW9udGhDb2RlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbW9udGhDb2RlICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBtb250aENvZGUgbXVzdCBiZSBhIHN0cmluZywgbm90ICR7dHlwZW9mIG1vbnRoQ29kZX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghL15NKFswMV0/XFxkKShMPykkLy50ZXN0KG1vbnRoQ29kZSkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYEludmFsaWQgbW9udGhDb2RlOiAke21vbnRoQ29kZX1gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jb25zdGFudEVyYSkge1xuICAgICAgICAgICAgaWYgKGVyYSAhPT0gdW5kZWZpbmVkICYmIGVyYSAhPT0gdGhpcy5jb25zdGFudEVyYSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBlcmEgbXVzdCBiZSAke3RoaXMuY29uc3RhbnRFcmF9LCBub3QgJHtlcmF9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZXJhWWVhciAhPT0gdW5kZWZpbmVkICYmIHllYXIgIT09IHVuZGVmaW5lZCAmJiBlcmFZZWFyICE9PSB5ZWFyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYGVyYVllYXIgJHtlcmFZZWFyfSBkb2VzIG5vdCBtYXRjaCB5ZWFyICR7eWVhcn1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBbGxvd3MgZGVyaXZlZCBjYWxlbmRhcnMgdG8gYWRkIGFkZGl0aW9uYWwgZmllbGRzIGFuZC9vciB0byBtYWtlXG4gICAgICogYWRqdXN0bWVudHMgZS5nLiB0byBzZXQgdGhlIGVyYSBiYXNlZCBvbiB0aGUgZGF0ZSBvciB0byByZXZpc2UgdGhlIG1vbnRoXG4gICAgICogbnVtYmVyIGluIGx1bmlzb2xhciBjYWxlbmRhcnMgcGVyXG4gICAgICogaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtdGVtcG9yYWwvaXNzdWVzLzEyMDMuXG4gICAgICpcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBmaWxscyBpbiBtaXNzaW5nIHZhbHVlcyBieSBhc3N1bWluZyB0aGUgc2ltcGxlc3RcbiAgICAgKiBwb3NzaWJsZSBjYWxlbmRhcjpcbiAgICAgKiAtIG5vIGVyYXMgb3IgYSBjb25zdGFudCBlcmEgZGVmaW5lZCBpbiBgLmNvbnN0YW50RXJhYFxuICAgICAqIC0gbm9uLWx1bmlzb2xhciBjYWxlbmRhciAobm8gbGVhcCBtb250aHMpXG4gICAgICogKi9cbiAgICBhZGp1c3RDYWxlbmRhckRhdGUoY2FsZW5kYXJEYXRlUGFyYW0sIGNhY2hlID0gdW5kZWZpbmVkLCBvdmVyZmxvdyA9ICdjb25zdHJhaW4nLCBcbiAgICAvLyBUaGlzIHBhcmFtIGlzIG9ubHkgdXNlZCBieSBkZXJpdmVkIGNsYXNzZXNcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgZnJvbUxlZ2FjeURhdGUgPSBmYWxzZSkge1xuICAgICAgICBpZiAodGhpcy5jYWxlbmRhclR5cGUgPT09ICdsdW5pc29sYXInKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ092ZXJyaWRlIHJlcXVpcmVkIGZvciBsdW5pc29sYXIgY2FsZW5kYXJzJyk7XG4gICAgICAgIGxldCBjYWxlbmRhckRhdGUgPSBjYWxlbmRhckRhdGVQYXJhbTtcbiAgICAgICAgdGhpcy52YWxpZGF0ZUNhbGVuZGFyRGF0ZShjYWxlbmRhckRhdGUpO1xuICAgICAgICAvLyBGb3IgY2FsZW5kYXJzIHRoYXQgYWx3YXlzIHVzZSB0aGUgc2FtZSBlcmEsIHNldCBpdCBoZXJlIHNvIHRoYXQgZGVyaXZlZFxuICAgICAgICAvLyBjYWxlbmRhcnMgd29uJ3QgbmVlZCB0byBpbXBsZW1lbnQgdGhpcyBtZXRob2Qgc2ltcGx5IHRvIHNldCB0aGUgZXJhLlxuICAgICAgICBpZiAodGhpcy5jb25zdGFudEVyYSkge1xuICAgICAgICAgICAgLy8geWVhciBhbmQgZXJhWWVhciBhbHdheXMgbWF0Y2ggd2hlbiB0aGVyZSdzIG9ubHkgb25lIHBvc3NpYmxlIGVyYVxuICAgICAgICAgICAgY29uc3QgeyB5ZWFyLCBlcmFZZWFyIH0gPSBjYWxlbmRhckRhdGU7XG4gICAgICAgICAgICBjYWxlbmRhckRhdGUgPSB7XG4gICAgICAgICAgICAgICAgLi4uY2FsZW5kYXJEYXRlLFxuICAgICAgICAgICAgICAgIGVyYTogdGhpcy5jb25zdGFudEVyYSxcbiAgICAgICAgICAgICAgICB5ZWFyOiB5ZWFyICE9PSB1bmRlZmluZWQgPyB5ZWFyIDogZXJhWWVhcixcbiAgICAgICAgICAgICAgICBlcmFZZWFyOiBlcmFZZWFyICE9PSB1bmRlZmluZWQgPyBlcmFZZWFyIDogeWVhclxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsYXJnZXN0TW9udGggPSB0aGlzLm1vbnRoc0luWWVhcihjYWxlbmRhckRhdGUsIGNhY2hlKTtcbiAgICAgICAgbGV0IHsgbW9udGgsIG1vbnRoQ29kZSB9ID0gY2FsZW5kYXJEYXRlO1xuICAgICAgICAoeyBtb250aCwgbW9udGhDb2RlIH0gPSByZXNvbHZlTm9uTHVuaXNvbGFyTW9udGgoY2FsZW5kYXJEYXRlLCBvdmVyZmxvdywgbGFyZ2VzdE1vbnRoKSk7XG4gICAgICAgIHJldHVybiB7IC4uLmNhbGVuZGFyRGF0ZSwgbW9udGgsIG1vbnRoQ29kZSB9O1xuICAgIH1cbiAgICByZWd1bGF0ZU1vbnRoRGF5TmFpdmUoY2FsZW5kYXJEYXRlLCBvdmVyZmxvdywgY2FjaGUpIHtcbiAgICAgICAgY29uc3QgbGFyZ2VzdE1vbnRoID0gdGhpcy5tb250aHNJblllYXIoY2FsZW5kYXJEYXRlLCBjYWNoZSk7XG4gICAgICAgIGxldCB7IG1vbnRoLCBkYXkgfSA9IGNhbGVuZGFyRGF0ZTtcbiAgICAgICAgaWYgKG92ZXJmbG93ID09PSAncmVqZWN0Jykge1xuICAgICAgICAgICAgUmVqZWN0VG9SYW5nZShtb250aCwgMSwgbGFyZ2VzdE1vbnRoKTtcbiAgICAgICAgICAgIFJlamVjdFRvUmFuZ2UoZGF5LCAxLCB0aGlzLm1heGltdW1Nb250aExlbmd0aChjYWxlbmRhckRhdGUpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1vbnRoID0gQ29uc3RyYWluVG9SYW5nZShtb250aCwgMSwgbGFyZ2VzdE1vbnRoKTtcbiAgICAgICAgICAgIGRheSA9IENvbnN0cmFpblRvUmFuZ2UoZGF5LCAxLCB0aGlzLm1heGltdW1Nb250aExlbmd0aCh7IC4uLmNhbGVuZGFyRGF0ZSwgbW9udGggfSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IC4uLmNhbGVuZGFyRGF0ZSwgbW9udGgsIGRheSB9O1xuICAgIH1cbiAgICBjYWxlbmRhclRvSXNvRGF0ZShkYXRlUGFyYW0sIG92ZXJmbG93ID0gJ2NvbnN0cmFpbicsIGNhY2hlKSB7XG4gICAgICAgIGNvbnN0IG9yaWdpbmFsRGF0ZSA9IGRhdGVQYXJhbTtcbiAgICAgICAgLy8gRmlyc3QsIG5vcm1hbGl6ZSB0aGUgY2FsZW5kYXIgZGF0ZSB0byBlbnN1cmUgdGhhdCAoeWVhciwgbW9udGgsIGRheSlcbiAgICAgICAgLy8gYXJlIGFsbCBwcmVzZW50LCBjb252ZXJ0aW5nIG1vbnRoQ29kZSBhbmQgZXJhWWVhciBpZiBuZWVkZWQuXG4gICAgICAgIGxldCBkYXRlID0gdGhpcy5hZGp1c3RDYWxlbmRhckRhdGUoZGF0ZVBhcmFtLCBjYWNoZSwgb3ZlcmZsb3csIGZhbHNlKTtcbiAgICAgICAgLy8gRml4IG9idmlvdXNseSBvdXQtb2YtYm91bmRzIHZhbHVlcy4gVmFsdWVzIHRoYXQgYXJlIHZhbGlkIGdlbmVyYWxseSwgYnV0XG4gICAgICAgIC8vIG5vdCBpbiB0aGlzIHBhcnRpY3VsYXIgeWVhciwgbWF5IG5vdCBiZSBjYXVnaHQgaGVyZSBmb3Igc29tZSBjYWxlbmRhcnMuXG4gICAgICAgIC8vIElmIHNvLCB0aGVzZSB3aWxsIGJlIGhhbmRsZWQgbG93ZXIgYmVsb3cuXG4gICAgICAgIGRhdGUgPSB0aGlzLnJlZ3VsYXRlTW9udGhEYXlOYWl2ZShkYXRlLCBvdmVyZmxvdywgY2FjaGUpO1xuICAgICAgICBjb25zdCB7IHllYXIsIG1vbnRoLCBkYXkgfSA9IGRhdGU7XG4gICAgICAgIGNvbnN0IGtleSA9IEpTT04uc3RyaW5naWZ5KHsgZnVuYzogJ2NhbGVuZGFyVG9Jc29EYXRlJywgeWVhciwgbW9udGgsIGRheSwgb3ZlcmZsb3csIGlkOiB0aGlzLmlkIH0pO1xuICAgICAgICBsZXQgY2FjaGVkID0gY2FjaGUuZ2V0KGtleSk7XG4gICAgICAgIGlmIChjYWNoZWQpXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkO1xuICAgICAgICAvLyBJZiBZTUQgYXJlIHByZXNlbnQgaW4gdGhlIGlucHV0IGJ1dCB0aGUgaW5wdXQgaGFzIGJlZW4gY29uc3RyYWluZWRcbiAgICAgICAgLy8gYWxyZWFkeSwgdGhlbiBjYWNoZSBib3RoIHRoZSBvcmlnaW5hbCB2YWx1ZSBhbmQgdGhlIGNvbnN0cmFpbmVkIHZhbHVlLlxuICAgICAgICBsZXQga2V5T3JpZ2luYWw7XG4gICAgICAgIGlmIChvcmlnaW5hbERhdGUueWVhciAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICBvcmlnaW5hbERhdGUubW9udGggIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgb3JpZ2luYWxEYXRlLmRheSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob3JpZ2luYWxEYXRlLnllYXIgIT09IGRhdGUueWVhciB8fCBvcmlnaW5hbERhdGUubW9udGggIT09IGRhdGUubW9udGggfHwgb3JpZ2luYWxEYXRlLmRheSAhPT0gZGF0ZS5kYXkpKSB7XG4gICAgICAgICAgICBrZXlPcmlnaW5hbCA9IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICBmdW5jOiAnY2FsZW5kYXJUb0lzb0RhdGUnLFxuICAgICAgICAgICAgICAgIHllYXI6IG9yaWdpbmFsRGF0ZS55ZWFyLFxuICAgICAgICAgICAgICAgIG1vbnRoOiBvcmlnaW5hbERhdGUubW9udGgsXG4gICAgICAgICAgICAgICAgZGF5OiBvcmlnaW5hbERhdGUuZGF5LFxuICAgICAgICAgICAgICAgIG92ZXJmbG93LFxuICAgICAgICAgICAgICAgIGlkOiB0aGlzLmlkXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNhY2hlZCA9IGNhY2hlLmdldChrZXlPcmlnaW5hbCk7XG4gICAgICAgICAgICBpZiAoY2FjaGVkKVxuICAgICAgICAgICAgICAgIHJldHVybiBjYWNoZWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRmlyc3QsIHRyeSB0byByb3VnaGx5IGd1ZXNzIHRoZSByZXN1bHRcbiAgICAgICAgbGV0IGlzb0VzdGltYXRlID0gdGhpcy5lc3RpbWF0ZUlzb0RhdGUoeyB5ZWFyLCBtb250aCwgZGF5IH0pO1xuICAgICAgICBjb25zdCBjYWxjdWxhdGVTYW1lTW9udGhSZXN1bHQgPSAoZGlmZkRheXMpID0+IHtcbiAgICAgICAgICAgIC8vIElmIHRoZSBlc3RpbWF0ZSBpcyBpbiB0aGUgc2FtZSB5ZWFyICYgbW9udGggYXMgdGhlIHRhcmdldCwgdGhlbiB3ZSBjYW5cbiAgICAgICAgICAgIC8vIGNhbGN1bGF0ZSB0aGUgcmVzdWx0IGV4YWN0bHkgYW5kIHNob3J0LWNpcmN1aXQgYW55IGFkZGl0aW9uYWwgbG9naWMuXG4gICAgICAgICAgICAvLyBUaGlzIG9wdGltaXphdGlvbiBhc3N1bWVzIHRoYXQgbW9udGhzIGFyZSBjb250aW51b3VzLiBJdCB3b3VsZCBicmVhayBpZlxuICAgICAgICAgICAgLy8gYSBjYWxlbmRhciBza2lwcGVkIGRheXMsIGxpa2UgdGhlIEp1bGlhbi0+R3JlZ29yaWFuIHN3aXRjaG92ZXIuIEJ1dCB0aGVcbiAgICAgICAgICAgIC8vIG9ubHkgSUNVIGNhbGVuZGFycyB0aGF0IGN1cnJlbnRseSBza2lwIGRheXMgKGphcGFuZXNlL3JvYy9idWRkaGlzdCkgaXNcbiAgICAgICAgICAgIC8vIGEgYnVnIChodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0xMTczMTU4KVxuICAgICAgICAgICAgLy8gdGhhdCdzIGN1cnJlbnRseSBkZXRlY3RlZCBieSBgY2hlY2tJY3VCdWdzKClgIHdoaWNoIHdpbGwgdGhyb3cuIFNvXG4gICAgICAgICAgICAvLyB0aGlzIG9wdGltaXphdGlvbiBzaG91bGQgYmUgc2FmZSBmb3IgYWxsIElDVSBjYWxlbmRhcnMuXG4gICAgICAgICAgICBsZXQgdGVzdElzb0VzdGltYXRlID0gdGhpcy5hZGREYXlzSXNvKGlzb0VzdGltYXRlLCBkaWZmRGF5cyk7XG4gICAgICAgICAgICBpZiAoZGF0ZS5kYXkgPiB0aGlzLm1pbmltdW1Nb250aExlbmd0aChkYXRlKSkge1xuICAgICAgICAgICAgICAgIC8vIFRoZXJlJ3MgYSBjaGFuY2UgdGhhdCB0aGUgY2FsZW5kYXIgZGF0ZSBpcyBvdXQgb2YgcmFuZ2UuIFRocm93IG9yXG4gICAgICAgICAgICAgICAgLy8gY29uc3RyYWluIGlmIHNvLlxuICAgICAgICAgICAgICAgIGxldCB0ZXN0Q2FsZW5kYXJEYXRlID0gdGhpcy5pc29Ub0NhbGVuZGFyRGF0ZSh0ZXN0SXNvRXN0aW1hdGUsIGNhY2hlKTtcbiAgICAgICAgICAgICAgICB3aGlsZSAodGVzdENhbGVuZGFyRGF0ZS5tb250aCAhPT0gbW9udGggfHwgdGVzdENhbGVuZGFyRGF0ZS55ZWFyICE9PSB5ZWFyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvdmVyZmxvdyA9PT0gJ3JlamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBkYXkgJHtkYXl9IGRvZXMgbm90IGV4aXN0IGluIG1vbnRoICR7bW9udGh9IG9mIHllYXIgJHt5ZWFyfWApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIEJhY2sgdXAgYSBkYXkgYXQgYSB0aW1lIHVudGlsIHdlJ3JlIG5vdCBoYW5naW5nIG92ZXIgdGhlIG1vbnRoIGVuZFxuICAgICAgICAgICAgICAgICAgICB0ZXN0SXNvRXN0aW1hdGUgPSB0aGlzLmFkZERheXNJc28odGVzdElzb0VzdGltYXRlLCAtMSk7XG4gICAgICAgICAgICAgICAgICAgIHRlc3RDYWxlbmRhckRhdGUgPSB0aGlzLmlzb1RvQ2FsZW5kYXJEYXRlKHRlc3RJc29Fc3RpbWF0ZSwgY2FjaGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0ZXN0SXNvRXN0aW1hdGU7XG4gICAgICAgIH07XG4gICAgICAgIGxldCBzaWduID0gMDtcbiAgICAgICAgbGV0IHJvdW5kdHJpcEVzdGltYXRlID0gdGhpcy5pc29Ub0NhbGVuZGFyRGF0ZShpc29Fc3RpbWF0ZSwgY2FjaGUpO1xuICAgICAgICBsZXQgZGlmZiA9IHNpbXBsZURhdGVEaWZmKGRhdGUsIHJvdW5kdHJpcEVzdGltYXRlKTtcbiAgICAgICAgaWYgKGRpZmYueWVhcnMgIT09IDAgfHwgZGlmZi5tb250aHMgIT09IDAgfHwgZGlmZi5kYXlzICE9PSAwKSB7XG4gICAgICAgICAgICBjb25zdCBkaWZmVG90YWxEYXlzRXN0aW1hdGUgPSBkaWZmLnllYXJzICogMzY1ICsgZGlmZi5tb250aHMgKiAzMCArIGRpZmYuZGF5cztcbiAgICAgICAgICAgIGlzb0VzdGltYXRlID0gdGhpcy5hZGREYXlzSXNvKGlzb0VzdGltYXRlLCBkaWZmVG90YWxEYXlzRXN0aW1hdGUpO1xuICAgICAgICAgICAgcm91bmR0cmlwRXN0aW1hdGUgPSB0aGlzLmlzb1RvQ2FsZW5kYXJEYXRlKGlzb0VzdGltYXRlLCBjYWNoZSk7XG4gICAgICAgICAgICBkaWZmID0gc2ltcGxlRGF0ZURpZmYoZGF0ZSwgcm91bmR0cmlwRXN0aW1hdGUpO1xuICAgICAgICAgICAgaWYgKGRpZmYueWVhcnMgPT09IDAgJiYgZGlmZi5tb250aHMgPT09IDApIHtcbiAgICAgICAgICAgICAgICBpc29Fc3RpbWF0ZSA9IGNhbGN1bGF0ZVNhbWVNb250aFJlc3VsdChkaWZmLmRheXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc2lnbiA9IHRoaXMuY29tcGFyZUNhbGVuZGFyRGF0ZXMoZGF0ZSwgcm91bmR0cmlwRXN0aW1hdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoZSBpbml0aWFsIGd1ZXNzIGlzIG5vdCBpbiB0aGUgc2FtZSBtb250aCwgdGhlbiB0aGVuIGJpc2VjdCB0aGVcbiAgICAgICAgLy8gZGlzdGFuY2UgdG8gdGhlIHRhcmdldCwgc3RhcnRpbmcgd2l0aCA4IGRheXMgcGVyIHN0ZXAuXG4gICAgICAgIGxldCBpbmNyZW1lbnQgPSA4O1xuICAgICAgICBsZXQgbWF5YmVDb25zdHJhaW5lZCA9IGZhbHNlO1xuICAgICAgICB3aGlsZSAoc2lnbikge1xuICAgICAgICAgICAgaXNvRXN0aW1hdGUgPSB0aGlzLmFkZERheXNJc28oaXNvRXN0aW1hdGUsIHNpZ24gKiBpbmNyZW1lbnQpO1xuICAgICAgICAgICAgY29uc3Qgb2xkUm91bmR0cmlwRXN0aW1hdGUgPSByb3VuZHRyaXBFc3RpbWF0ZTtcbiAgICAgICAgICAgIHJvdW5kdHJpcEVzdGltYXRlID0gdGhpcy5pc29Ub0NhbGVuZGFyRGF0ZShpc29Fc3RpbWF0ZSwgY2FjaGUpO1xuICAgICAgICAgICAgY29uc3Qgb2xkU2lnbiA9IHNpZ247XG4gICAgICAgICAgICBzaWduID0gdGhpcy5jb21wYXJlQ2FsZW5kYXJEYXRlcyhkYXRlLCByb3VuZHRyaXBFc3RpbWF0ZSk7XG4gICAgICAgICAgICBpZiAoc2lnbikge1xuICAgICAgICAgICAgICAgIGRpZmYgPSBzaW1wbGVEYXRlRGlmZihkYXRlLCByb3VuZHRyaXBFc3RpbWF0ZSk7XG4gICAgICAgICAgICAgICAgaWYgKGRpZmYueWVhcnMgPT09IDAgJiYgZGlmZi5tb250aHMgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgaXNvRXN0aW1hdGUgPSBjYWxjdWxhdGVTYW1lTW9udGhSZXN1bHQoZGlmZi5kYXlzKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2lnbmFsIHRoZSBsb29wIGNvbmRpdGlvbiB0aGF0IHRoZXJlJ3MgYSBtYXRjaC5cbiAgICAgICAgICAgICAgICAgICAgc2lnbiA9IDA7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBjYWxlbmRhciBkYXkgaXMgbGFyZ2VyIHRoYW4gdGhlIG1pbmltYWwgbGVuZ3RoIGZvciB0aGlzXG4gICAgICAgICAgICAgICAgICAgIC8vIG1vbnRoLCB0aGVuIGl0IG1pZ2h0IGJlIGxhcmdlciB0aGFuIHRoZSBhY3R1YWwgbGVuZ3RoIG9mIHRoZSBtb250aC5cbiAgICAgICAgICAgICAgICAgICAgLy8gU28gd2Ugd29uJ3QgY2FjaGUgaXQgYXMgdGhlIGNvcnJlY3QgY2FsZW5kYXIgZGF0ZSBmb3IgdGhpcyBJU09cbiAgICAgICAgICAgICAgICAgICAgLy8gZGF0ZS5cbiAgICAgICAgICAgICAgICAgICAgbWF5YmVDb25zdHJhaW5lZCA9IGRhdGUuZGF5ID4gdGhpcy5taW5pbXVtTW9udGhMZW5ndGgoZGF0ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG9sZFNpZ24gJiYgc2lnbiAhPT0gb2xkU2lnbikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5jcmVtZW50ID4gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIGVzdGltYXRlIG92ZXJzaG90IHRoZSB0YXJnZXQsIHRyeSBhZ2FpbiB3aXRoIGEgc21hbGxlciBpbmNyZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGluIHRoZSByZXZlcnNlIGRpcmVjdGlvbi5cbiAgICAgICAgICAgICAgICAgICAgICAgIGluY3JlbWVudCAvPSAyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSW5jcmVtZW50IGlzIDEsIGFuZCBuZWl0aGVyIHRoZSBwcmV2aW91cyBlc3RpbWF0ZSBub3IgdGhlIG5ld1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXN0aW1hdGUgaXMgY29ycmVjdC4gVGhlIG9ubHkgd2F5IHRoYXQgY2FuIGhhcHBlbiBpcyBpZiB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9yaWdpbmFsIGRhdGUgd2FzIGFuIGludmFsaWQgdmFsdWUgdGhhdCB3aWxsIGJlIGNvbnN0cmFpbmVkIG9yXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyByZWplY3RlZCBoZXJlLlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG92ZXJmbG93ID09PSAncmVqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBDYW4ndCBmaW5kIElTTyBkYXRlIGZyb20gY2FsZW5kYXIgZGF0ZTogJHtKU09OLnN0cmluZ2lmeSh7IC4uLm9yaWdpbmFsRGF0ZSB9KX1gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRvIGNvbnN0cmFpbiwgcGljayB0aGUgZWFybGllc3QgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBvcmRlciA9IHRoaXMuY29tcGFyZUNhbGVuZGFyRGF0ZXMocm91bmR0cmlwRXN0aW1hdGUsIG9sZFJvdW5kdHJpcEVzdGltYXRlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBjdXJyZW50IHZhbHVlIGlzIGxhcmdlciwgdGhlbiBiYWNrIHVwIHRvIHRoZSBwcmV2aW91cyB2YWx1ZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob3JkZXIgPiAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc29Fc3RpbWF0ZSA9IHRoaXMuYWRkRGF5c0lzbyhpc29Fc3RpbWF0ZSwgLTEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1heWJlQ29uc3RyYWluZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpZ24gPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhY2hlLnNldChrZXksIGlzb0VzdGltYXRlKTtcbiAgICAgICAgaWYgKGtleU9yaWdpbmFsKVxuICAgICAgICAgICAgY2FjaGUuc2V0KGtleU9yaWdpbmFsLCBpc29Fc3RpbWF0ZSk7XG4gICAgICAgIGlmIChkYXRlLnllYXIgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgZGF0ZS5tb250aCA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICBkYXRlLmRheSA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICBkYXRlLm1vbnRoQ29kZSA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICAodGhpcy5oYXNFcmEgJiYgKGRhdGUuZXJhID09PSB1bmRlZmluZWQgfHwgZGF0ZS5lcmFZZWFyID09PSB1bmRlZmluZWQpKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1VuZXhwZWN0ZWQgbWlzc2luZyBwcm9wZXJ0eScpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghbWF5YmVDb25zdHJhaW5lZCkge1xuICAgICAgICAgICAgLy8gQWxzbyBjYWNoZSB0aGUgcmV2ZXJzZSBtYXBwaW5nXG4gICAgICAgICAgICBjb25zdCBrZXlSZXZlcnNlID0gSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgIGZ1bmM6ICdpc29Ub0NhbGVuZGFyRGF0ZScsXG4gICAgICAgICAgICAgICAgaXNvWWVhcjogaXNvRXN0aW1hdGUueWVhcixcbiAgICAgICAgICAgICAgICBpc29Nb250aDogaXNvRXN0aW1hdGUubW9udGgsXG4gICAgICAgICAgICAgICAgaXNvRGF5OiBpc29Fc3RpbWF0ZS5kYXksXG4gICAgICAgICAgICAgICAgaWQ6IHRoaXMuaWRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY2FjaGUuc2V0KGtleVJldmVyc2UsIGRhdGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpc29Fc3RpbWF0ZTtcbiAgICB9XG4gICAgdGVtcG9yYWxUb0NhbGVuZGFyRGF0ZShkYXRlLCBjYWNoZSkge1xuICAgICAgICBjb25zdCBpc29EYXRlID0geyB5ZWFyOiBHZXRTbG90KGRhdGUsIElTT19ZRUFSKSwgbW9udGg6IEdldFNsb3QoZGF0ZSwgSVNPX01PTlRIKSwgZGF5OiBHZXRTbG90KGRhdGUsIElTT19EQVkpIH07XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuaXNvVG9DYWxlbmRhckRhdGUoaXNvRGF0ZSwgY2FjaGUpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBjb21wYXJlQ2FsZW5kYXJEYXRlcyhkYXRlMVBhcmFtLCBkYXRlMlBhcmFtKSB7XG4gICAgICAgIC8vIGBkYXRlMWAgYW5kIGBkYXRlMmAgYXJlIGFscmVhZHkgcmVjb3Jkcy4gVGhlIGNhbGxzIGJlbG93IHNpbXBseSB2YWxpZGF0ZVxuICAgICAgICAvLyB0aGF0IGFsbCB0aHJlZSByZXF1aXJlZCBmaWVsZHMgYXJlIHByZXNlbnQuXG4gICAgICAgIGNvbnN0IGRhdGUxID0gUHJlcGFyZVRlbXBvcmFsRmllbGRzKGRhdGUxUGFyYW0sIFtbJ2RheSddLCBbJ21vbnRoJ10sIFsneWVhciddXSk7XG4gICAgICAgIGNvbnN0IGRhdGUyID0gUHJlcGFyZVRlbXBvcmFsRmllbGRzKGRhdGUyUGFyYW0sIFtbJ2RheSddLCBbJ21vbnRoJ10sIFsneWVhciddXSk7XG4gICAgICAgIGlmIChkYXRlMS55ZWFyICE9PSBkYXRlMi55ZWFyKVxuICAgICAgICAgICAgcmV0dXJuIENvbXBhcmlzb25SZXN1bHQoZGF0ZTEueWVhciAtIGRhdGUyLnllYXIpO1xuICAgICAgICBpZiAoZGF0ZTEubW9udGggIT09IGRhdGUyLm1vbnRoKVxuICAgICAgICAgICAgcmV0dXJuIENvbXBhcmlzb25SZXN1bHQoZGF0ZTEubW9udGggLSBkYXRlMi5tb250aCk7XG4gICAgICAgIGlmIChkYXRlMS5kYXkgIT09IGRhdGUyLmRheSlcbiAgICAgICAgICAgIHJldHVybiBDb21wYXJpc29uUmVzdWx0KGRhdGUxLmRheSAtIGRhdGUyLmRheSk7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICAvKiogRW5zdXJlIHRoYXQgYSBjYWxlbmRhciBkYXRlIGFjdHVhbGx5IGV4aXN0cy4gSWYgbm90LCByZXR1cm4gdGhlIGNsb3Nlc3QgZWFybGllciBkYXRlLiAqL1xuICAgIHJlZ3VsYXRlRGF0ZShjYWxlbmRhckRhdGUsIG92ZXJmbG93ID0gJ2NvbnN0cmFpbicsIGNhY2hlKSB7XG4gICAgICAgIGNvbnN0IGlzb0RhdGUgPSB0aGlzLmNhbGVuZGFyVG9Jc29EYXRlKGNhbGVuZGFyRGF0ZSwgb3ZlcmZsb3csIGNhY2hlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNvVG9DYWxlbmRhckRhdGUoaXNvRGF0ZSwgY2FjaGUpO1xuICAgIH1cbiAgICBhZGREYXlzSXNvKGlzb0RhdGUsIGRheXMpIHtcbiAgICAgICAgY29uc3QgYWRkZWQgPSBBZGRJU09EYXRlKGlzb0RhdGUueWVhciwgaXNvRGF0ZS5tb250aCwgaXNvRGF0ZS5kYXksIDAsIDAsIDAsIGRheXMsICdjb25zdHJhaW4nKTtcbiAgICAgICAgcmV0dXJuIGFkZGVkO1xuICAgIH1cbiAgICBhZGREYXlzQ2FsZW5kYXIoY2FsZW5kYXJEYXRlLCBkYXlzLCBjYWNoZSkge1xuICAgICAgICBjb25zdCBpc29EYXRlID0gdGhpcy5jYWxlbmRhclRvSXNvRGF0ZShjYWxlbmRhckRhdGUsICdjb25zdHJhaW4nLCBjYWNoZSk7XG4gICAgICAgIGNvbnN0IGFkZGVkSXNvID0gdGhpcy5hZGREYXlzSXNvKGlzb0RhdGUsIGRheXMpO1xuICAgICAgICBjb25zdCBhZGRlZENhbGVuZGFyID0gdGhpcy5pc29Ub0NhbGVuZGFyRGF0ZShhZGRlZElzbywgY2FjaGUpO1xuICAgICAgICByZXR1cm4gYWRkZWRDYWxlbmRhcjtcbiAgICB9XG4gICAgYWRkTW9udGhzQ2FsZW5kYXIoY2FsZW5kYXJEYXRlUGFyYW0sIG1vbnRocywgb3ZlcmZsb3csIGNhY2hlKSB7XG4gICAgICAgIGxldCBjYWxlbmRhckRhdGUgPSBjYWxlbmRhckRhdGVQYXJhbTtcbiAgICAgICAgY29uc3QgeyBkYXkgfSA9IGNhbGVuZGFyRGF0ZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGFic01vbnRocyA9IE1hdGhBYnMkMShtb250aHMpOyBpIDwgYWJzTW9udGhzOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHsgbW9udGggfSA9IGNhbGVuZGFyRGF0ZTtcbiAgICAgICAgICAgIGNvbnN0IG9sZENhbGVuZGFyRGF0ZSA9IGNhbGVuZGFyRGF0ZTtcbiAgICAgICAgICAgIGNvbnN0IGRheXMgPSBtb250aHMgPCAwXG4gICAgICAgICAgICAgICAgPyAtTWF0aC5tYXgoZGF5LCB0aGlzLmRheXNJblByZXZpb3VzTW9udGgoY2FsZW5kYXJEYXRlLCBjYWNoZSkpXG4gICAgICAgICAgICAgICAgOiB0aGlzLmRheXNJbk1vbnRoKGNhbGVuZGFyRGF0ZSwgY2FjaGUpO1xuICAgICAgICAgICAgY29uc3QgaXNvRGF0ZSA9IHRoaXMuY2FsZW5kYXJUb0lzb0RhdGUoY2FsZW5kYXJEYXRlLCAnY29uc3RyYWluJywgY2FjaGUpO1xuICAgICAgICAgICAgbGV0IGFkZGVkSXNvID0gdGhpcy5hZGREYXlzSXNvKGlzb0RhdGUsIGRheXMpO1xuICAgICAgICAgICAgY2FsZW5kYXJEYXRlID0gdGhpcy5pc29Ub0NhbGVuZGFyRGF0ZShhZGRlZElzbywgY2FjaGUpO1xuICAgICAgICAgICAgLy8gTm9ybWFsbHksIHdlIGNhbiBhZHZhbmNlIG9uZSBtb250aCBieSBhZGRpbmcgdGhlIG51bWJlciBvZiBkYXlzIGluIHRoZVxuICAgICAgICAgICAgLy8gY3VycmVudCBtb250aC4gSG93ZXZlciwgaWYgd2UncmUgYXQgdGhlIGVuZCBvZiB0aGUgY3VycmVudCBtb250aCBhbmRcbiAgICAgICAgICAgIC8vIHRoZSBuZXh0IG1vbnRoIGhhcyBmZXdlciBkYXlzLCB0aGVuIHdlIHJvbGxlZCBvdmVyIHRvIHRoZSBhZnRlci1uZXh0XG4gICAgICAgICAgICAvLyBtb250aC4gQmVsb3cgd2UgZGV0ZWN0IHRoaXMgY29uZGl0aW9uIGFuZCBiYWNrIHVwIHVudGlsIHdlJ3JlIGJhY2sgaW5cbiAgICAgICAgICAgIC8vIHRoZSBkZXNpcmVkIG1vbnRoLlxuICAgICAgICAgICAgaWYgKG1vbnRocyA+IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtb250aHNJbk9sZFllYXIgPSB0aGlzLm1vbnRoc0luWWVhcihvbGRDYWxlbmRhckRhdGUsIGNhY2hlKTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoY2FsZW5kYXJEYXRlLm1vbnRoIC0gMSAhPT0gbW9udGggJSBtb250aHNJbk9sZFllYXIpIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkZWRJc28gPSB0aGlzLmFkZERheXNJc28oYWRkZWRJc28sIC0xKTtcbiAgICAgICAgICAgICAgICAgICAgY2FsZW5kYXJEYXRlID0gdGhpcy5pc29Ub0NhbGVuZGFyRGF0ZShhZGRlZElzbywgY2FjaGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjYWxlbmRhckRhdGUuZGF5ICE9PSBkYXkpIHtcbiAgICAgICAgICAgICAgICAvLyB0cnkgdG8gcmV0YWluIHRoZSBvcmlnaW5hbCBkYXktb2YtbW9udGgsIGlmIHBvc3NpYmxlXG4gICAgICAgICAgICAgICAgY2FsZW5kYXJEYXRlID0gdGhpcy5yZWd1bGF0ZURhdGUoeyAuLi5jYWxlbmRhckRhdGUsIGRheSB9LCAnY29uc3RyYWluJywgY2FjaGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChvdmVyZmxvdyA9PT0gJ3JlamVjdCcgJiYgY2FsZW5kYXJEYXRlLmRheSAhPT0gZGF5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgRGF5ICR7ZGF5fSBkb2VzIG5vdCBleGlzdCBpbiByZXN1bHRpbmcgY2FsZW5kYXIgbW9udGhgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2FsZW5kYXJEYXRlO1xuICAgIH1cbiAgICBhZGRDYWxlbmRhcihjYWxlbmRhckRhdGUsIHsgeWVhcnMgPSAwLCBtb250aHMgPSAwLCB3ZWVrcyA9IDAsIGRheXMgPSAwIH0sIG92ZXJmbG93LCBjYWNoZSkge1xuICAgICAgICBjb25zdCB7IHllYXIsIG1vbnRoLCBkYXkgfSA9IGNhbGVuZGFyRGF0ZTtcbiAgICAgICAgY29uc3QgYWRkZWRNb250aHMgPSB0aGlzLmFkZE1vbnRoc0NhbGVuZGFyKHsgeWVhcjogeWVhciArIHllYXJzLCBtb250aCwgZGF5IH0sIG1vbnRocywgb3ZlcmZsb3csIGNhY2hlKTtcbiAgICAgICAgY29uc3QgaW5pdGlhbERheXMgPSBkYXlzICsgd2Vla3MgKiA3O1xuICAgICAgICBjb25zdCBhZGRlZERheXMgPSB0aGlzLmFkZERheXNDYWxlbmRhcihhZGRlZE1vbnRocywgaW5pdGlhbERheXMsIGNhY2hlKTtcbiAgICAgICAgcmV0dXJuIGFkZGVkRGF5cztcbiAgICB9XG4gICAgdW50aWxDYWxlbmRhcihjYWxlbmRhck9uZSwgY2FsZW5kYXJUd28sIGxhcmdlc3RVbml0LCBjYWNoZSkge1xuICAgICAgICBsZXQgZGF5cyA9IDA7XG4gICAgICAgIGxldCB3ZWVrcyA9IDA7XG4gICAgICAgIGxldCBtb250aHMgPSAwO1xuICAgICAgICBsZXQgeWVhcnMgPSAwO1xuICAgICAgICBzd2l0Y2ggKGxhcmdlc3RVbml0KSB7XG4gICAgICAgICAgICBjYXNlICdkYXknOlxuICAgICAgICAgICAgICAgIGRheXMgPSB0aGlzLmNhbGVuZGFyRGF5c1VudGlsKGNhbGVuZGFyT25lLCBjYWxlbmRhclR3bywgY2FjaGUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnd2Vlayc6IHtcbiAgICAgICAgICAgICAgICBjb25zdCB0b3RhbERheXMgPSB0aGlzLmNhbGVuZGFyRGF5c1VudGlsKGNhbGVuZGFyT25lLCBjYWxlbmRhclR3bywgY2FjaGUpO1xuICAgICAgICAgICAgICAgIGRheXMgPSB0b3RhbERheXMgJSA3O1xuICAgICAgICAgICAgICAgIHdlZWtzID0gKHRvdGFsRGF5cyAtIGRheXMpIC8gNztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ21vbnRoJzpcbiAgICAgICAgICAgIGNhc2UgJ3llYXInOiB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGlmZlllYXJzID0gY2FsZW5kYXJUd28ueWVhciAtIGNhbGVuZGFyT25lLnllYXI7XG4gICAgICAgICAgICAgICAgY29uc3QgZGlmZk1vbnRocyA9IGNhbGVuZGFyVHdvLm1vbnRoIC0gY2FsZW5kYXJPbmUubW9udGg7XG4gICAgICAgICAgICAgICAgY29uc3QgZGlmZkRheXMgPSBjYWxlbmRhclR3by5kYXkgLSBjYWxlbmRhck9uZS5kYXk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2lnbiA9IHRoaXMuY29tcGFyZUNhbGVuZGFyRGF0ZXMoY2FsZW5kYXJUd28sIGNhbGVuZGFyT25lKTtcbiAgICAgICAgICAgICAgICBpZiAobGFyZ2VzdFVuaXQgPT09ICd5ZWFyJyAmJiBkaWZmWWVhcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaXNPbmVGdXJ0aGVySW5ZZWFyID0gZGlmZk1vbnRocyAqIHNpZ24gPCAwIHx8IChkaWZmTW9udGhzID09PSAwICYmIGRpZmZEYXlzICogc2lnbiA8IDApO1xuICAgICAgICAgICAgICAgICAgICB5ZWFycyA9IGlzT25lRnVydGhlckluWWVhciA/IGRpZmZZZWFycyAtIHNpZ24gOiBkaWZmWWVhcnM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHllYXJzQWRkZWQgPSB5ZWFycyA/IHRoaXMuYWRkQ2FsZW5kYXIoY2FsZW5kYXJPbmUsIHsgeWVhcnMgfSwgJ2NvbnN0cmFpbicsIGNhY2hlKSA6IGNhbGVuZGFyT25lO1xuICAgICAgICAgICAgICAgIC8vIE5vdyB3ZSBoYXZlIGxlc3MgdGhhbiBvbmUgeWVhciByZW1haW5pbmcuIEFkZCBvbmUgbW9udGggYXQgYSB0aW1lXG4gICAgICAgICAgICAgICAgLy8gdW50aWwgd2UgZ28gb3ZlciB0aGUgdGFyZ2V0LCB0aGVuIGJhY2sgdXAgb25lIG1vbnRoIGFuZCBjYWxjdWxhdGVcbiAgICAgICAgICAgICAgICAvLyByZW1haW5pbmcgZGF5cyBhbmQgd2Vla3MuXG4gICAgICAgICAgICAgICAgbGV0IGN1cnJlbnQ7XG4gICAgICAgICAgICAgICAgbGV0IG5leHQgPSB5ZWFyc0FkZGVkO1xuICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgbW9udGhzICs9IHNpZ247XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBuZXh0O1xuICAgICAgICAgICAgICAgICAgICBuZXh0ID0gdGhpcy5hZGRNb250aHNDYWxlbmRhcihjdXJyZW50LCBzaWduLCAnY29uc3RyYWluJywgY2FjaGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dC5kYXkgIT09IGNhbGVuZGFyT25lLmRheSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSW4gY2FzZSB0aGUgZGF5IHdhcyBjb25zdHJhaW5lZCBkb3duLCB0cnkgdG8gdW4tY29uc3RyYWluIGl0XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0ID0gdGhpcy5yZWd1bGF0ZURhdGUoeyAuLi5uZXh0LCBkYXk6IGNhbGVuZGFyT25lLmRheSB9LCAnY29uc3RyYWluJywgY2FjaGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSB3aGlsZSAodGhpcy5jb21wYXJlQ2FsZW5kYXJEYXRlcyhjYWxlbmRhclR3bywgbmV4dCkgKiBzaWduID49IDApO1xuICAgICAgICAgICAgICAgIG1vbnRocyAtPSBzaWduOyAvLyBjb3JyZWN0IGZvciBsb29wIGFib3ZlIHdoaWNoIG92ZXJzaG9vdHMgYnkgMVxuICAgICAgICAgICAgICAgIGNvbnN0IHJlbWFpbmluZ0RheXMgPSB0aGlzLmNhbGVuZGFyRGF5c1VudGlsKGN1cnJlbnQsIGNhbGVuZGFyVHdvLCBjYWNoZSk7XG4gICAgICAgICAgICAgICAgZGF5cyA9IHJlbWFpbmluZ0RheXM7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgeWVhcnMsIG1vbnRocywgd2Vla3MsIGRheXMgfTtcbiAgICB9XG4gICAgZGF5c0luTW9udGgoY2FsZW5kYXJEYXRlLCBjYWNoZSkge1xuICAgICAgICAvLyBBZGQgZW5vdWdoIGRheXMgdG8gcm9sbCBvdmVyIHRvIHRoZSBuZXh0IG1vbnRoLiBPbmUgd2UncmUgaW4gdGhlIG5leHRcbiAgICAgICAgLy8gbW9udGgsIHdlIGNhbiBjYWxjdWxhdGUgdGhlIGxlbmd0aCBvZiB0aGUgY3VycmVudCBtb250aC4gTk9URTogVGhpc1xuICAgICAgICAvLyBhbGdvcml0aG0gYXNzdW1lcyB0aGF0IG1vbnRocyBhcmUgY29udGludW91cy4gSXQgd291bGQgYnJlYWsgaWYgYVxuICAgICAgICAvLyBjYWxlbmRhciBza2lwcGVkIGRheXMsIGxpa2UgdGhlIEp1bGlhbi0+R3JlZ29yaWFuIHN3aXRjaG92ZXIuIEJ1dCB0aGVcbiAgICAgICAgLy8gb25seSBJQ1UgY2FsZW5kYXJzIHRoYXQgY3VycmVudGx5IHNraXAgZGF5cyAoamFwYW5lc2Uvcm9jL2J1ZGRoaXN0KSBpcyBhXG4gICAgICAgIC8vIGJ1ZyAoaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MTE3MzE1OClcbiAgICAgICAgLy8gdGhhdCdzIGN1cnJlbnRseSBkZXRlY3RlZCBieSBgY2hlY2tJY3VCdWdzKClgIHdoaWNoIHdpbGwgdGhyb3cuIFNvIHRoaXNcbiAgICAgICAgLy8gY29kZSBzaG91bGQgYmUgc2FmZSBmb3IgYWxsIElDVSBjYWxlbmRhcnMuXG4gICAgICAgIGNvbnN0IHsgZGF5IH0gPSBjYWxlbmRhckRhdGU7XG4gICAgICAgIGNvbnN0IG1heCA9IHRoaXMubWF4aW11bU1vbnRoTGVuZ3RoKGNhbGVuZGFyRGF0ZSk7XG4gICAgICAgIGNvbnN0IG1pbiA9IHRoaXMubWluaW11bU1vbnRoTGVuZ3RoKGNhbGVuZGFyRGF0ZSk7XG4gICAgICAgIC8vIGVhc2llc3QgY2FzZTogd2UgYWxyZWFkeSBrbm93IHRoZSBtb250aCBsZW5ndGggaWYgbWluIGFuZCBtYXggYXJlIHRoZSBzYW1lLlxuICAgICAgICBpZiAobWluID09PSBtYXgpXG4gICAgICAgICAgICByZXR1cm4gbWluO1xuICAgICAgICAvLyBBZGQgZW5vdWdoIGRheXMgdG8gZ2V0IGludG8gdGhlIG5leHQgbW9udGgsIHdpdGhvdXQgc2tpcHBpbmcgaXRcbiAgICAgICAgY29uc3QgaW5jcmVtZW50ID0gZGF5IDw9IG1heCAtIG1pbiA/IG1heCA6IG1pbjtcbiAgICAgICAgY29uc3QgaXNvRGF0ZSA9IHRoaXMuY2FsZW5kYXJUb0lzb0RhdGUoY2FsZW5kYXJEYXRlLCAnY29uc3RyYWluJywgY2FjaGUpO1xuICAgICAgICBjb25zdCBhZGRlZElzb0RhdGUgPSB0aGlzLmFkZERheXNJc28oaXNvRGF0ZSwgaW5jcmVtZW50KTtcbiAgICAgICAgY29uc3QgYWRkZWRDYWxlbmRhckRhdGUgPSB0aGlzLmlzb1RvQ2FsZW5kYXJEYXRlKGFkZGVkSXNvRGF0ZSwgY2FjaGUpO1xuICAgICAgICAvLyBOb3cgYmFjayB1cCB0byB0aGUgbGFzdCBkYXkgb2YgdGhlIG9yaWdpbmFsIG1vbnRoXG4gICAgICAgIGNvbnN0IGVuZE9mTW9udGhJc28gPSB0aGlzLmFkZERheXNJc28oYWRkZWRJc29EYXRlLCAtYWRkZWRDYWxlbmRhckRhdGUuZGF5KTtcbiAgICAgICAgY29uc3QgZW5kT2ZNb250aENhbGVuZGFyID0gdGhpcy5pc29Ub0NhbGVuZGFyRGF0ZShlbmRPZk1vbnRoSXNvLCBjYWNoZSk7XG4gICAgICAgIHJldHVybiBlbmRPZk1vbnRoQ2FsZW5kYXIuZGF5O1xuICAgIH1cbiAgICBkYXlzSW5QcmV2aW91c01vbnRoKGNhbGVuZGFyRGF0ZSwgY2FjaGUpIHtcbiAgICAgICAgY29uc3QgeyBkYXksIG1vbnRoLCB5ZWFyIH0gPSBjYWxlbmRhckRhdGU7XG4gICAgICAgIC8vIENoZWNrIHRvIHNlZSBpZiB3ZSBhbHJlYWR5IGtub3cgdGhlIG1vbnRoIGxlbmd0aCwgYW5kIHJldHVybiBpdCBpZiBzb1xuICAgICAgICBjb25zdCBwcmV2aW91c01vbnRoWWVhciA9IG1vbnRoID4gMSA/IHllYXIgOiB5ZWFyIC0gMTtcbiAgICAgICAgbGV0IHByZXZpb3VzTW9udGhEYXRlID0geyB5ZWFyOiBwcmV2aW91c01vbnRoWWVhciwgbW9udGgsIGRheTogMSB9O1xuICAgICAgICBjb25zdCBwcmV2aW91c01vbnRoID0gbW9udGggPiAxID8gbW9udGggLSAxIDogdGhpcy5tb250aHNJblllYXIocHJldmlvdXNNb250aERhdGUsIGNhY2hlKTtcbiAgICAgICAgcHJldmlvdXNNb250aERhdGUgPSB7IC4uLnByZXZpb3VzTW9udGhEYXRlLCBtb250aDogcHJldmlvdXNNb250aCB9O1xuICAgICAgICBjb25zdCBtaW4gPSB0aGlzLm1pbmltdW1Nb250aExlbmd0aChwcmV2aW91c01vbnRoRGF0ZSk7XG4gICAgICAgIGNvbnN0IG1heCA9IHRoaXMubWF4aW11bU1vbnRoTGVuZ3RoKHByZXZpb3VzTW9udGhEYXRlKTtcbiAgICAgICAgaWYgKG1pbiA9PT0gbWF4KVxuICAgICAgICAgICAgcmV0dXJuIG1heDtcbiAgICAgICAgY29uc3QgaXNvRGF0ZSA9IHRoaXMuY2FsZW5kYXJUb0lzb0RhdGUoY2FsZW5kYXJEYXRlLCAnY29uc3RyYWluJywgY2FjaGUpO1xuICAgICAgICBjb25zdCBsYXN0RGF5T2ZQcmV2aW91c01vbnRoSXNvID0gdGhpcy5hZGREYXlzSXNvKGlzb0RhdGUsIC1kYXkpO1xuICAgICAgICBjb25zdCBsYXN0RGF5T2ZQcmV2aW91c01vbnRoQ2FsZW5kYXIgPSB0aGlzLmlzb1RvQ2FsZW5kYXJEYXRlKGxhc3REYXlPZlByZXZpb3VzTW9udGhJc28sIGNhY2hlKTtcbiAgICAgICAgcmV0dXJuIGxhc3REYXlPZlByZXZpb3VzTW9udGhDYWxlbmRhci5kYXk7XG4gICAgfVxuICAgIHN0YXJ0T2ZDYWxlbmRhclllYXIoY2FsZW5kYXJEYXRlKSB7XG4gICAgICAgIHJldHVybiB7IHllYXI6IGNhbGVuZGFyRGF0ZS55ZWFyLCBtb250aDogMSwgZGF5OiAxIH07XG4gICAgfVxuICAgIHN0YXJ0T2ZDYWxlbmRhck1vbnRoKGNhbGVuZGFyRGF0ZSkge1xuICAgICAgICByZXR1cm4geyB5ZWFyOiBjYWxlbmRhckRhdGUueWVhciwgbW9udGg6IGNhbGVuZGFyRGF0ZS5tb250aCwgZGF5OiAxIH07XG4gICAgfVxuICAgIGNhbGVuZGFyRGF5c1VudGlsKGNhbGVuZGFyT25lLCBjYWxlbmRhclR3bywgY2FjaGUpIHtcbiAgICAgICAgY29uc3Qgb25lSXNvID0gdGhpcy5jYWxlbmRhclRvSXNvRGF0ZShjYWxlbmRhck9uZSwgJ2NvbnN0cmFpbicsIGNhY2hlKTtcbiAgICAgICAgY29uc3QgdHdvSXNvID0gdGhpcy5jYWxlbmRhclRvSXNvRGF0ZShjYWxlbmRhclR3bywgJ2NvbnN0cmFpbicsIGNhY2hlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNvRGF5c1VudGlsKG9uZUlzbywgdHdvSXNvKTtcbiAgICB9XG4gICAgaXNvRGF5c1VudGlsKG9uZUlzbywgdHdvSXNvKSB7XG4gICAgICAgIGNvbnN0IGR1cmF0aW9uID0gRGlmZmVyZW5jZUlTT0RhdGUob25lSXNvLnllYXIsIG9uZUlzby5tb250aCwgb25lSXNvLmRheSwgdHdvSXNvLnllYXIsIHR3b0lzby5tb250aCwgdHdvSXNvLmRheSwgJ2RheScpO1xuICAgICAgICByZXR1cm4gZHVyYXRpb24uZGF5cztcbiAgICB9XG4gICAgbW9udGhEYXlGcm9tRmllbGRzKGZpZWxkcywgb3ZlcmZsb3csIGNhY2hlKSB7XG4gICAgICAgIGxldCB7IHllYXIsIG1vbnRoLCBtb250aENvZGUsIGRheSwgZXJhLCBlcmFZZWFyIH0gPSBmaWVsZHM7XG4gICAgICAgIGlmIChtb250aENvZGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKHllYXIgPT09IHVuZGVmaW5lZCAmJiAoZXJhID09PSB1bmRlZmluZWQgfHwgZXJhWWVhciA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2Btb250aENvZGVgLCBgeWVhcmAsIG9yIGBlcmFgIGFuZCBgZXJhWWVhcmAgaXMgcmVxdWlyZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICh7IG1vbnRoQ29kZSwgeWVhciB9ID0gdGhpcy5hZGp1c3RDYWxlbmRhckRhdGUoeyB5ZWFyLCBtb250aCwgbW9udGhDb2RlLCBkYXksIGVyYSwgZXJhWWVhciB9LCBjYWNoZSwgb3ZlcmZsb3cpKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgaXNvWWVhciwgaXNvTW9udGgsIGlzb0RheTtcbiAgICAgICAgbGV0IGNsb3Nlc3RDYWxlbmRhciwgY2xvc2VzdElzbztcbiAgICAgICAgLy8gTG9vayBiYWNrd2FyZHMgc3RhcnRpbmcgZnJvbSB0aGUgY2FsZW5kYXIgeWVhciBvZiAxOTcyLTAxLTAxIHVwIHRvIDEwMFxuICAgICAgICAvLyBjYWxlbmRhciB5ZWFycyB0byBmaW5kIGEgeWVhciB0aGF0IGhhcyB0aGlzIG1vbnRoIGFuZCBkYXkuIE5vcm1hbCBtb250aHNcbiAgICAgICAgLy8gYW5kIGRheXMgd2lsbCBtYXRjaCBpbW1lZGlhdGVseSwgYnV0IGZvciBsZWFwIGRheXMgYW5kIGxlYXAgbW9udGhzIHdlIG1heVxuICAgICAgICAvLyBoYXZlIHRvIGxvb2sgZm9yIGEgd2hpbGUuXG4gICAgICAgIGNvbnN0IHN0YXJ0RGF0ZUlzbyA9IHsgeWVhcjogMTk3MiwgbW9udGg6IDEsIGRheTogMSB9O1xuICAgICAgICBjb25zdCB7IHllYXI6IGNhbGVuZGFyWWVhciB9ID0gdGhpcy5pc29Ub0NhbGVuZGFyRGF0ZShzdGFydERhdGVJc28sIGNhY2hlKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxMDA7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgdGVzdENhbGVuZGFyRGF0ZSA9IHRoaXMuYWRqdXN0Q2FsZW5kYXJEYXRlKHsgZGF5LCBtb250aENvZGUsIHllYXI6IGNhbGVuZGFyWWVhciAtIGkgfSwgY2FjaGUpO1xuICAgICAgICAgICAgY29uc3QgaXNvRGF0ZSA9IHRoaXMuY2FsZW5kYXJUb0lzb0RhdGUodGVzdENhbGVuZGFyRGF0ZSwgJ2NvbnN0cmFpbicsIGNhY2hlKTtcbiAgICAgICAgICAgIGNvbnN0IHJvdW5kVHJpcENhbGVuZGFyRGF0ZSA9IHRoaXMuaXNvVG9DYWxlbmRhckRhdGUoaXNvRGF0ZSwgY2FjaGUpO1xuICAgICAgICAgICAgKHsgeWVhcjogaXNvWWVhciwgbW9udGg6IGlzb01vbnRoLCBkYXk6IGlzb0RheSB9ID0gaXNvRGF0ZSk7XG4gICAgICAgICAgICBpZiAocm91bmRUcmlwQ2FsZW5kYXJEYXRlLm1vbnRoQ29kZSA9PT0gbW9udGhDb2RlICYmIHJvdW5kVHJpcENhbGVuZGFyRGF0ZS5kYXkgPT09IGRheSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IG1vbnRoOiBpc29Nb250aCwgZGF5OiBpc29EYXksIHllYXI6IGlzb1llYXIgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG92ZXJmbG93ID09PSAnY29uc3RyYWluJykge1xuICAgICAgICAgICAgICAgIC8vIG5vbi1JU08gY29uc3RyYWluIGFsZ29yaXRobSB0cmllcyB0byBmaW5kIHRoZSBjbG9zZXN0IGRhdGUgaW4gYSBtYXRjaGluZyBtb250aFxuICAgICAgICAgICAgICAgIGlmIChjbG9zZXN0Q2FsZW5kYXIgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgICAgICAgICAocm91bmRUcmlwQ2FsZW5kYXJEYXRlLm1vbnRoQ29kZSA9PT0gY2xvc2VzdENhbGVuZGFyLm1vbnRoQ29kZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgcm91bmRUcmlwQ2FsZW5kYXJEYXRlLmRheSA+IGNsb3Nlc3RDYWxlbmRhci5kYXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsb3Nlc3RDYWxlbmRhciA9IHJvdW5kVHJpcENhbGVuZGFyRGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgY2xvc2VzdElzbyA9IGlzb0RhdGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChvdmVyZmxvdyA9PT0gJ2NvbnN0cmFpbicgJiYgY2xvc2VzdElzbyAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmV0dXJuIGNsb3Nlc3RJc287XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBObyByZWNlbnQgJHt0aGlzLmlkfSB5ZWFyIHdpdGggbW9udGhDb2RlICR7bW9udGhDb2RlfSBhbmQgZGF5ICR7ZGF5fWApO1xuICAgIH1cbn1cbmNsYXNzIEhlYnJld0hlbHBlciBleHRlbmRzIEhlbHBlckJhc2Uge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLmlkID0gJ2hlYnJldyc7XG4gICAgICAgIHRoaXMuY2FsZW5kYXJUeXBlID0gJ2x1bmlzb2xhcic7XG4gICAgICAgIHRoaXMubW9udGhzID0ge1xuICAgICAgICAgICAgVGlzaHJpOiB7IGxlYXA6IDEsIHJlZ3VsYXI6IDEsIG1vbnRoQ29kZTogJ00wMScsIGRheXM6IDMwIH0sXG4gICAgICAgICAgICBIZXNodmFuOiB7IGxlYXA6IDIsIHJlZ3VsYXI6IDIsIG1vbnRoQ29kZTogJ00wMicsIGRheXM6IHsgbWluOiAyOSwgbWF4OiAzMCB9IH0sXG4gICAgICAgICAgICBLaXNsZXY6IHsgbGVhcDogMywgcmVndWxhcjogMywgbW9udGhDb2RlOiAnTTAzJywgZGF5czogeyBtaW46IDI5LCBtYXg6IDMwIH0gfSxcbiAgICAgICAgICAgIFRldmV0OiB7IGxlYXA6IDQsIHJlZ3VsYXI6IDQsIG1vbnRoQ29kZTogJ00wNCcsIGRheXM6IDI5IH0sXG4gICAgICAgICAgICBTaGV2YXQ6IHsgbGVhcDogNSwgcmVndWxhcjogNSwgbW9udGhDb2RlOiAnTTA1JywgZGF5czogMzAgfSxcbiAgICAgICAgICAgIEFkYXI6IHsgbGVhcDogdW5kZWZpbmVkLCByZWd1bGFyOiA2LCBtb250aENvZGU6ICdNMDYnLCBkYXlzOiAyOSB9LFxuICAgICAgICAgICAgJ0FkYXIgSSc6IHsgbGVhcDogNiwgcmVndWxhcjogdW5kZWZpbmVkLCBtb250aENvZGU6ICdNMDVMJywgZGF5czogMzAgfSxcbiAgICAgICAgICAgICdBZGFyIElJJzogeyBsZWFwOiA3LCByZWd1bGFyOiB1bmRlZmluZWQsIG1vbnRoQ29kZTogJ00wNicsIGRheXM6IDI5IH0sXG4gICAgICAgICAgICBOaXNhbjogeyBsZWFwOiA4LCByZWd1bGFyOiA3LCBtb250aENvZGU6ICdNMDcnLCBkYXlzOiAzMCB9LFxuICAgICAgICAgICAgSXlhcjogeyBsZWFwOiA5LCByZWd1bGFyOiA4LCBtb250aENvZGU6ICdNMDgnLCBkYXlzOiAyOSB9LFxuICAgICAgICAgICAgU2l2YW46IHsgbGVhcDogMTAsIHJlZ3VsYXI6IDksIG1vbnRoQ29kZTogJ00wOScsIGRheXM6IDMwIH0sXG4gICAgICAgICAgICBUYW11ejogeyBsZWFwOiAxMSwgcmVndWxhcjogMTAsIG1vbnRoQ29kZTogJ00xMCcsIGRheXM6IDI5IH0sXG4gICAgICAgICAgICBBdjogeyBsZWFwOiAxMiwgcmVndWxhcjogMTEsIG1vbnRoQ29kZTogJ00xMScsIGRheXM6IDMwIH0sXG4gICAgICAgICAgICBFbHVsOiB7IGxlYXA6IDEzLCByZWd1bGFyOiAxMiwgbW9udGhDb2RlOiAnTTEyJywgZGF5czogMjkgfVxuICAgICAgICB9O1xuICAgICAgICAvLyBBbGwgYnVpbHQtaW4gY2FsZW5kYXJzIGV4Y2VwdCBDaGluZXNlL0RhbmdpIGFuZCBIZWJyZXcgdXNlIGFuIGVyYVxuICAgICAgICB0aGlzLmhhc0VyYSA9IGZhbHNlO1xuICAgIH1cbiAgICBpbkxlYXBZZWFyKGNhbGVuZGFyRGF0ZSkge1xuICAgICAgICBjb25zdCB7IHllYXIgfSA9IGNhbGVuZGFyRGF0ZTtcbiAgICAgICAgLy8gRllJOiBJbiBhZGRpdGlvbiB0byBhZGRpbmcgYSBtb250aCBpbiBsZWFwIHllYXJzLCB0aGUgSGVicmV3IGNhbGVuZGFyXG4gICAgICAgIC8vIGFsc28gaGFzIHBlci15ZWFyIGNoYW5nZXMgdG8gdGhlIG51bWJlciBvZiBkYXlzIG9mIEhlc2h2YW4gYW5kIEtpc2xldi5cbiAgICAgICAgLy8gR2l2ZW4gdGhhdCB0aGVzZSBjYW4gYmUgY2FsY3VsYXRlZCBieSBjb3VudGluZyB0aGUgbnVtYmVyIG9mIGRheXMgaW5cbiAgICAgICAgLy8gdGhvc2UgbW9udGhzLCBJIGFzc3VtZSB0aGF0IHRoZXNlIERPIE5PVCBuZWVkIHRvIGJlIGV4cG9zZWQgYXNcbiAgICAgICAgLy8gSGVicmV3LW9ubHkgcHJvdG90eXBlIGZpZWxkcyBvciBtZXRob2RzLlxuICAgICAgICByZXR1cm4gKDcgKiB5ZWFyICsgMSkgJSAxOSA8IDc7XG4gICAgfVxuICAgIG1vbnRoc0luWWVhcihjYWxlbmRhckRhdGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5MZWFwWWVhcihjYWxlbmRhckRhdGUpID8gMTMgOiAxMjtcbiAgICB9XG4gICAgbWluaW11bU1vbnRoTGVuZ3RoKGNhbGVuZGFyRGF0ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5taW5NYXhNb250aExlbmd0aChjYWxlbmRhckRhdGUsICdtaW4nKTtcbiAgICB9XG4gICAgbWF4aW11bU1vbnRoTGVuZ3RoKGNhbGVuZGFyRGF0ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5taW5NYXhNb250aExlbmd0aChjYWxlbmRhckRhdGUsICdtYXgnKTtcbiAgICB9XG4gICAgbWluTWF4TW9udGhMZW5ndGgoY2FsZW5kYXJEYXRlLCBtaW5Pck1heCkge1xuICAgICAgICBjb25zdCB7IG1vbnRoLCB5ZWFyIH0gPSBjYWxlbmRhckRhdGU7XG4gICAgICAgIGNvbnN0IG1vbnRoQ29kZSA9IHRoaXMuZ2V0TW9udGhDb2RlKHllYXIsIG1vbnRoKTtcbiAgICAgICAgY29uc3QgbW9udGhJbmZvID0gT2JqZWN0RW50cmllcyh0aGlzLm1vbnRocykuZmluZCgobSkgPT4gbVsxXS5tb250aENvZGUgPT09IG1vbnRoQ29kZSk7XG4gICAgICAgIGlmIChtb250aEluZm8gPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGB1bm1hdGNoZWQgSGVicmV3IG1vbnRoOiAke21vbnRofWApO1xuICAgICAgICBjb25zdCBkYXlzSW5Nb250aCA9IG1vbnRoSW5mb1sxXS5kYXlzO1xuICAgICAgICByZXR1cm4gdHlwZW9mIGRheXNJbk1vbnRoID09PSAnbnVtYmVyJyA/IGRheXNJbk1vbnRoIDogZGF5c0luTW9udGhbbWluT3JNYXhdO1xuICAgIH1cbiAgICAvKiogVGFrZSBhIGd1ZXNzIGF0IHdoYXQgSVNPIGRhdGUgYSBwYXJ0aWN1bGFyIGNhbGVuZGFyIGRhdGUgY29ycmVzcG9uZHMgdG8gKi9cbiAgICBlc3RpbWF0ZUlzb0RhdGUoY2FsZW5kYXJEYXRlKSB7XG4gICAgICAgIGNvbnN0IHsgeWVhciB9ID0gY2FsZW5kYXJEYXRlO1xuICAgICAgICByZXR1cm4geyB5ZWFyOiB5ZWFyIC0gMzc2MCwgbW9udGg6IDEsIGRheTogMSB9O1xuICAgIH1cbiAgICBnZXRNb250aENvZGUoeWVhciwgbW9udGgpIHtcbiAgICAgICAgaWYgKHRoaXMuaW5MZWFwWWVhcih7IHllYXIgfSkpIHtcbiAgICAgICAgICAgIHJldHVybiBtb250aCA9PT0gNiA/IGJ1aWxkTW9udGhDb2RlKDUsIHRydWUpIDogYnVpbGRNb250aENvZGUobW9udGggPCA2ID8gbW9udGggOiBtb250aCAtIDEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGJ1aWxkTW9udGhDb2RlKG1vbnRoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhZGp1c3RDYWxlbmRhckRhdGUoY2FsZW5kYXJEYXRlLCBjYWNoZSwgb3ZlcmZsb3cgPSAnY29uc3RyYWluJywgZnJvbUxlZ2FjeURhdGUgPSBmYWxzZSkge1xuICAgICAgICAvLyBUaGUgaW5jb21pbmcgdHlwZSBpcyBhY3R1YWxseSBDYWxlbmRhckRhdGUgKHNhbWUgYXMgYXJncyB0b1xuICAgICAgICAvLyBDYWxlbmRhci5kYXRlRnJvbVBhcmFtcykgYnV0IFRTIGlzbid0IHNtYXJ0IGVub3VnaCB0byBmb2xsb3cgYWxsIHRoZVxuICAgICAgICAvLyByZWFzc2lnbm1lbnRzIGJlbG93LCBzbyBhcyBhbiBhbHRlcm5hdGl2ZSB0byAxMCsgdHlwZSBjYXN0cywgd2UnbGwgbGllXG4gICAgICAgIC8vIGhlcmUgYW5kIGNsYWltIHRoYXQgdGhlIHR5cGUgaGFzIGBkYXlgIGFuZCBgeWVhcmAgZmlsbGVkIGluIGFscmVhZHkuXG4gICAgICAgIGxldCB7IHllYXIsIGVyYVllYXIsIG1vbnRoLCBtb250aENvZGUsIGRheSwgbW9udGhFeHRyYSB9ID0gY2FsZW5kYXJEYXRlO1xuICAgICAgICBpZiAoeWVhciA9PT0gdW5kZWZpbmVkICYmIGVyYVllYXIgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHllYXIgPSBlcmFZZWFyO1xuICAgICAgICBpZiAoZXJhWWVhciA9PT0gdW5kZWZpbmVkICYmIHllYXIgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIGVyYVllYXIgPSB5ZWFyO1xuICAgICAgICBpZiAoZnJvbUxlZ2FjeURhdGUpIHtcbiAgICAgICAgICAgIC8vIEluIFByZSBOb2RlLTE0IFY4LCBEYXRlVGltZUZvcm1hdC5mb3JtYXRUb1BhcnRzIGBtb250aDogJ251bWVyaWMnYFxuICAgICAgICAgICAgLy8gb3V0cHV0IHJldHVybnMgdGhlIG51bWVyaWMgZXF1aXZhbGVudCBvZiBgbW9udGhgIGFzIGEgc3RyaW5nLCBtZWFuaW5nXG4gICAgICAgICAgICAvLyB0aGF0IGAnNidgIGluIGEgbGVhcCB5ZWFyIGlzIEFkYXIgSSwgd2hpbGUgYCc2J2AgaW4gYSBub24tbGVhcCB5ZWFyXG4gICAgICAgICAgICAvLyBtZWFucyBBZGFyLiBJbiB0aGlzIGNhc2UsIGBtb250aGAgd2lsbCBhbHJlYWR5IGJlIGNvcnJlY3QgYW5kIG5vIGFjdGlvblxuICAgICAgICAgICAgLy8gaXMgbmVlZGVkLiBIb3dldmVyLCBpbiBOb2RlIDE0IGFuZCBsYXRlciBmb3JtYXRUb1BhcnRzIHJldHVybnMgdGhlIG5hbWVcbiAgICAgICAgICAgIC8vIG9mIHRoZSBIZWJyZXcgbW9udGggKGUuZy4gXCJUZXZldFwiKSwgc28gd2UnbGwgbmVlZCB0byBsb29rIHVwIHRoZVxuICAgICAgICAgICAgLy8gY29ycmVjdCBgbW9udGhgIHVzaW5nIHRoZSBzdHJpbmcgbmFtZSBhcyBhIGtleS5cbiAgICAgICAgICAgIGlmIChtb250aEV4dHJhKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbW9udGhJbmZvID0gdGhpcy5tb250aHNbbW9udGhFeHRyYV07XG4gICAgICAgICAgICAgICAgaWYgKCFtb250aEluZm8pXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBVbnJlY29nbml6ZWQgbW9udGggZnJvbSBmb3JtYXRUb1BhcnRzOiAke21vbnRoRXh0cmF9YCk7XG4gICAgICAgICAgICAgICAgbW9udGggPSB0aGlzLmluTGVhcFllYXIoeyB5ZWFyIH0pID8gbW9udGhJbmZvLmxlYXAgOiBtb250aEluZm8ucmVndWxhcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEJlY2F1c2Ugd2UncmUgZ2V0dGluZyBkYXRhIGZyb20gbGVnYWN5IERhdGUsIHRoZW4gYG1vbnRoYCB3aWxsIGFsd2F5cyBiZSBwcmVzZW50XG4gICAgICAgICAgICBtb250aENvZGUgPSB0aGlzLmdldE1vbnRoQ29kZSh5ZWFyLCBtb250aCk7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSB7IHllYXIsIG1vbnRoOiBtb250aCwgZGF5LCBlcmE6IHVuZGVmaW5lZCwgZXJhWWVhciwgbW9udGhDb2RlIH07XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gV2hlbiBjYWxsZWQgd2l0aG91dCBpbnB1dCBjb21pbmcgZnJvbSBsZWdhY3kgRGF0ZSBvdXRwdXQsIHNpbXBseSBlbnN1cmVcbiAgICAgICAgICAgIC8vIHRoYXQgYWxsIGZpZWxkcyBhcmUgcHJlc2VudC5cbiAgICAgICAgICAgIHRoaXMudmFsaWRhdGVDYWxlbmRhckRhdGUoY2FsZW5kYXJEYXRlKTtcbiAgICAgICAgICAgIGlmIChtb250aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1vbnRoQ29kZS5lbmRzV2l0aCgnTCcpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtb250aENvZGUgIT09ICdNMDVMJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYEhlYnJldyBsZWFwIG1vbnRoIG11c3QgaGF2ZSBtb250aENvZGUgTTA1TCwgbm90ICR7bW9udGhDb2RlfWApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG1vbnRoID0gNjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmluTGVhcFllYXIoeyB5ZWFyIH0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3ZlcmZsb3cgPT09ICdyZWplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYEhlYnJldyBtb250aENvZGUgTTA1TCBpcyBpbnZhbGlkIGluIHllYXIgJHt5ZWFyfSB3aGljaCBpcyBub3QgYSBsZWFwIHllYXJgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbnN0cmFpbiB0byBsYXN0IGRheSBvZiBwcmV2aW91cyBtb250aCAoQXYpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9udGggPSA1O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRheSA9IDMwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vbnRoQ29kZSA9ICdNMDUnO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtb250aCA9IG1vbnRoQ29kZU51bWJlclBhcnQobW9udGhDb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgbGVhcCBtb250aCBpcyBiZWZvcmUgdGhpcyBvbmUsIHRoZSBtb250aCBpbmRleCBpcyBvbmUgbW9yZSB0aGFuIHRoZSBtb250aCBjb2RlXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmluTGVhcFllYXIoeyB5ZWFyIH0pICYmIG1vbnRoID4gNilcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vbnRoKys7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxhcmdlc3RNb250aCA9IHRoaXMubW9udGhzSW5ZZWFyKHsgeWVhciB9KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1vbnRoIDwgMSB8fCBtb250aCA+IGxhcmdlc3RNb250aClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBJbnZhbGlkIG1vbnRoQ29kZTogJHttb250aENvZGV9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKG92ZXJmbG93ID09PSAncmVqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICBSZWplY3RUb1JhbmdlKG1vbnRoLCAxLCB0aGlzLm1vbnRoc0luWWVhcih7IHllYXIgfSkpO1xuICAgICAgICAgICAgICAgICAgICBSZWplY3RUb1JhbmdlKGRheSwgMSwgdGhpcy5tYXhpbXVtTW9udGhMZW5ndGgoeyB5ZWFyLCBtb250aCB9KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtb250aCA9IENvbnN0cmFpblRvUmFuZ2UobW9udGgsIDEsIHRoaXMubW9udGhzSW5ZZWFyKHsgeWVhciB9KSk7XG4gICAgICAgICAgICAgICAgICAgIGRheSA9IENvbnN0cmFpblRvUmFuZ2UoZGF5LCAxLCB0aGlzLm1heGltdW1Nb250aExlbmd0aCh7IHllYXIsIG1vbnRoIH0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG1vbnRoQ29kZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIG1vbnRoQ29kZSA9IHRoaXMuZ2V0TW9udGhDb2RlKHllYXIsIG1vbnRoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNhbGN1bGF0ZWRNb250aENvZGUgPSB0aGlzLmdldE1vbnRoQ29kZSh5ZWFyLCBtb250aCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjYWxjdWxhdGVkTW9udGhDb2RlICE9PSBtb250aENvZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBtb250aENvZGUgJHttb250aENvZGV9IGRvZXNuJ3QgY29ycmVzcG9uZCB0byBtb250aCAke21vbnRofSBpbiBIZWJyZXcgeWVhciAke3llYXJ9YCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyAuLi5jYWxlbmRhckRhdGUsIGRheSwgbW9udGgsIG1vbnRoQ29kZTogbW9udGhDb2RlLCB5ZWFyLCBlcmFZZWFyIH07XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIEZvciBUZW1wb3JhbCBwdXJwb3NlcywgdGhlIElzbGFtaWMgY2FsZW5kYXIgaXMgc2ltcGxlIGJlY2F1c2UgaXQncyBhbHdheXMgdGhlXG4gKiBzYW1lIDEyIG1vbnRocyBpbiB0aGUgc2FtZSBvcmRlci5cbiAqL1xuY2xhc3MgSXNsYW1pY0Jhc2VIZWxwZXIgZXh0ZW5kcyBIZWxwZXJCYXNlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5jYWxlbmRhclR5cGUgPSAnbHVuYXInO1xuICAgICAgICB0aGlzLkRBWVNfUEVSX0lTTEFNSUNfWUVBUiA9IDM1NCArIDExIC8gMzA7XG4gICAgICAgIHRoaXMuREFZU19QRVJfSVNPX1lFQVIgPSAzNjUuMjQyNTtcbiAgICAgICAgdGhpcy5jb25zdGFudEVyYSA9ICdhaCc7XG4gICAgfVxuICAgIGluTGVhcFllYXIoY2FsZW5kYXJEYXRlLCBjYWNoZSkge1xuICAgICAgICAvLyBJbiBsZWFwIHllYXJzLCB0aGUgMTJ0aCBtb250aCBoYXMgMzAgZGF5cy4gSW4gbm9uLWxlYXAgeWVhcnM6IDI5LlxuICAgICAgICBjb25zdCBkYXlzID0gdGhpcy5kYXlzSW5Nb250aCh7IHllYXI6IGNhbGVuZGFyRGF0ZS55ZWFyLCBtb250aDogMTIsIGRheTogMSB9LCBjYWNoZSk7XG4gICAgICAgIHJldHVybiBkYXlzID09PSAzMDtcbiAgICB9XG4gICAgbW9udGhzSW5ZZWFyKCAvKiBjYWxlbmRhclllYXIsIGNhY2hlICovKSB7XG4gICAgICAgIHJldHVybiAxMjtcbiAgICB9XG4gICAgbWluaW11bU1vbnRoTGVuZ3RoKCAvKiBjYWxlbmRhckRhdGUgKi8pIHtcbiAgICAgICAgcmV0dXJuIDI5O1xuICAgIH1cbiAgICBtYXhpbXVtTW9udGhMZW5ndGgoIC8qIGNhbGVuZGFyRGF0ZSAqLykge1xuICAgICAgICByZXR1cm4gMzA7XG4gICAgfVxuICAgIGVzdGltYXRlSXNvRGF0ZShjYWxlbmRhckRhdGUpIHtcbiAgICAgICAgY29uc3QgeyB5ZWFyIH0gPSB0aGlzLmFkanVzdENhbGVuZGFyRGF0ZShjYWxlbmRhckRhdGUpO1xuICAgICAgICByZXR1cm4geyB5ZWFyOiBNYXRoRmxvb3IkMSgoeWVhciAqIHRoaXMuREFZU19QRVJfSVNMQU1JQ19ZRUFSKSAvIHRoaXMuREFZU19QRVJfSVNPX1lFQVIpICsgNjIyLCBtb250aDogMSwgZGF5OiAxIH07XG4gICAgfVxufVxuLy8gVGhlcmUgYXJlIDYgSXNsYW1pYyBjYWxlbmRhcnMgd2l0aCB0aGUgc2FtZSBpbXBsZW1lbnRhdGlvbiBpbiB0aGlzIHBvbHlmaWxsLlxuLy8gVGhleSB2YXJ5IG9ubHkgaW4gdGhlaXIgSUQuIFRoZXkgZG8gZW1pdCBkaWZmZXJlbnQgb3V0cHV0IGZyb20gdGhlIHVuZGVybHlpbmdcbi8vIEludGwgaW1wbGVtZW50YXRpb24sIGJ1dCBvdXIgY29kZSBmb3IgZWFjaCBvZiB0aGVtIGlzIGlkZW50aWNhbC5cbmNsYXNzIElzbGFtaWNIZWxwZXIgZXh0ZW5kcyBJc2xhbWljQmFzZUhlbHBlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuaWQgPSAnaXNsYW1pYyc7XG4gICAgfVxufVxuY2xhc3MgSXNsYW1pY1VtYWxxdXJhSGVscGVyIGV4dGVuZHMgSXNsYW1pY0Jhc2VIZWxwZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLmlkID0gJ2lzbGFtaWMtdW1hbHF1cmEnO1xuICAgIH1cbn1cbmNsYXNzIElzbGFtaWNUYmxhSGVscGVyIGV4dGVuZHMgSXNsYW1pY0Jhc2VIZWxwZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLmlkID0gJ2lzbGFtaWMtdGJsYSc7XG4gICAgfVxufVxuY2xhc3MgSXNsYW1pY0NpdmlsSGVscGVyIGV4dGVuZHMgSXNsYW1pY0Jhc2VIZWxwZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLmlkID0gJ2lzbGFtaWMtY2l2aWwnO1xuICAgIH1cbn1cbmNsYXNzIElzbGFtaWNSZ3NhSGVscGVyIGV4dGVuZHMgSXNsYW1pY0Jhc2VIZWxwZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLmlkID0gJ2lzbGFtaWMtcmdzYSc7XG4gICAgfVxufVxuY2xhc3MgSXNsYW1pY0NjSGVscGVyIGV4dGVuZHMgSXNsYW1pY0Jhc2VIZWxwZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLmlkID0gJ2lzbGFtaWNjJztcbiAgICB9XG59XG5jbGFzcyBQZXJzaWFuSGVscGVyIGV4dGVuZHMgSGVscGVyQmFzZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuaWQgPSAncGVyc2lhbic7XG4gICAgICAgIHRoaXMuY2FsZW5kYXJUeXBlID0gJ3NvbGFyJztcbiAgICAgICAgdGhpcy5jb25zdGFudEVyYSA9ICdhcCc7XG4gICAgfVxuICAgIGluTGVhcFllYXIoY2FsZW5kYXJEYXRlLCBjYWNoZSkge1xuICAgICAgICAvLyBTYW1lIGxvZ2ljIChjb3VudCBkYXlzIGluIHRoZSBsYXN0IG1vbnRoKSBmb3IgUGVyc2lhbiBhcyBmb3IgSXNsYW1pYyxcbiAgICAgICAgLy8gZXZlbiB0aG91Z2ggUGVyc2lhbiBpcyBzb2xhciBhbmQgSXNsYW1pYyBpcyBsdW5hci5cbiAgICAgICAgcmV0dXJuIElzbGFtaWNIZWxwZXIucHJvdG90eXBlLmluTGVhcFllYXIuY2FsbCh0aGlzLCBjYWxlbmRhckRhdGUsIGNhY2hlKTtcbiAgICB9XG4gICAgbW9udGhzSW5ZZWFyKCAvKiBjYWxlbmRhclllYXIsIGNhY2hlICovKSB7XG4gICAgICAgIHJldHVybiAxMjtcbiAgICB9XG4gICAgbWluaW11bU1vbnRoTGVuZ3RoKGNhbGVuZGFyRGF0ZSkge1xuICAgICAgICBjb25zdCB7IG1vbnRoIH0gPSBjYWxlbmRhckRhdGU7XG4gICAgICAgIGlmIChtb250aCA9PT0gMTIpXG4gICAgICAgICAgICByZXR1cm4gMjk7XG4gICAgICAgIHJldHVybiBtb250aCA8PSA2ID8gMzEgOiAzMDtcbiAgICB9XG4gICAgbWF4aW11bU1vbnRoTGVuZ3RoKGNhbGVuZGFyRGF0ZSkge1xuICAgICAgICBjb25zdCB7IG1vbnRoIH0gPSBjYWxlbmRhckRhdGU7XG4gICAgICAgIGlmIChtb250aCA9PT0gMTIpXG4gICAgICAgICAgICByZXR1cm4gMzA7XG4gICAgICAgIHJldHVybiBtb250aCA8PSA2ID8gMzEgOiAzMDtcbiAgICB9XG4gICAgZXN0aW1hdGVJc29EYXRlKGNhbGVuZGFyRGF0ZSkge1xuICAgICAgICBjb25zdCB7IHllYXIgfSA9IHRoaXMuYWRqdXN0Q2FsZW5kYXJEYXRlKGNhbGVuZGFyRGF0ZSk7XG4gICAgICAgIHJldHVybiB7IHllYXI6IHllYXIgKyA2MjEsIG1vbnRoOiAxLCBkYXk6IDEgfTtcbiAgICB9XG59XG5jbGFzcyBJbmRpYW5IZWxwZXIgZXh0ZW5kcyBIZWxwZXJCYXNlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5pZCA9ICdpbmRpYW4nO1xuICAgICAgICB0aGlzLmNhbGVuZGFyVHlwZSA9ICdzb2xhcic7XG4gICAgICAgIHRoaXMuY29uc3RhbnRFcmEgPSAnc2FrYSc7XG4gICAgICAgIC8vIEluZGlhbiBtb250aHMgYWx3YXlzIHN0YXJ0IGF0IHRoZSBzYW1lIHdlbGwta25vd24gR3JlZ29yaWFuIG1vbnRoIGFuZFxuICAgICAgICAvLyBkYXkuIFNvIHRoaXMgY29udmVyc2lvbiBpcyBlYXN5IGFuZCBmYXN0LiBTZWVcbiAgICAgICAgLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSW5kaWFuX25hdGlvbmFsX2NhbGVuZGFyXG4gICAgICAgIHRoaXMubW9udGhzID0ge1xuICAgICAgICAgICAgMTogeyBsZW5ndGg6IDMwLCBtb250aDogMywgZGF5OiAyMiwgbGVhcDogeyBsZW5ndGg6IDMxLCBtb250aDogMywgZGF5OiAyMSB9IH0sXG4gICAgICAgICAgICAyOiB7IGxlbmd0aDogMzEsIG1vbnRoOiA0LCBkYXk6IDIxIH0sXG4gICAgICAgICAgICAzOiB7IGxlbmd0aDogMzEsIG1vbnRoOiA1LCBkYXk6IDIyIH0sXG4gICAgICAgICAgICA0OiB7IGxlbmd0aDogMzEsIG1vbnRoOiA2LCBkYXk6IDIyIH0sXG4gICAgICAgICAgICA1OiB7IGxlbmd0aDogMzEsIG1vbnRoOiA3LCBkYXk6IDIzIH0sXG4gICAgICAgICAgICA2OiB7IGxlbmd0aDogMzEsIG1vbnRoOiA4LCBkYXk6IDIzIH0sXG4gICAgICAgICAgICA3OiB7IGxlbmd0aDogMzAsIG1vbnRoOiA5LCBkYXk6IDIzIH0sXG4gICAgICAgICAgICA4OiB7IGxlbmd0aDogMzAsIG1vbnRoOiAxMCwgZGF5OiAyMyB9LFxuICAgICAgICAgICAgOTogeyBsZW5ndGg6IDMwLCBtb250aDogMTEsIGRheTogMjIgfSxcbiAgICAgICAgICAgIDEwOiB7IGxlbmd0aDogMzAsIG1vbnRoOiAxMiwgZGF5OiAyMiB9LFxuICAgICAgICAgICAgMTE6IHsgbGVuZ3RoOiAzMCwgbW9udGg6IDEsIG5leHRZZWFyOiB0cnVlLCBkYXk6IDIxIH0sXG4gICAgICAgICAgICAxMjogeyBsZW5ndGg6IDMwLCBtb250aDogMiwgbmV4dFllYXI6IHRydWUsIGRheTogMjAgfVxuICAgICAgICB9O1xuICAgICAgICAvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0xMDUyOSBjYXVzZXMgSW50bCdzIEluZGlhblxuICAgICAgICAvLyBjYWxlbmRhciBvdXRwdXQgdG8gZmFpbCBmb3IgYWxsIGRhdGVzIGJlZm9yZSAwMDAxLTAxLTAxIElTTy4gIEZvciBleGFtcGxlLFxuICAgICAgICAvLyBpbiBOb2RlIDEyIDAwMDAtMDEtMDEgaXMgY2FsY3VsYXRlZCBhcyA2MTQ2LzEyLy01ODMgaW5zdGVhZCBvZiAxMC8xMS8tNzkgYXNcbiAgICAgICAgLy8gZXhwZWN0ZWQuXG4gICAgICAgIHRoaXMudnVsbmVyYWJsZVRvQmNlQnVnID0gbmV3IERhdGUoJzAwMDAtMDEtMDFUMDA6MDBaJykudG9Mb2NhbGVEYXRlU3RyaW5nKCdlbi1VUy11LWNhLWluZGlhbicsIHsgdGltZVpvbmU6ICdVVEMnIH0pICE9PSAnMTAvMTEvLTc5IFNha2EnO1xuICAgIH1cbiAgICBpbkxlYXBZZWFyKGNhbGVuZGFyRGF0ZSkge1xuICAgICAgICAvLyBGcm9tIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0luZGlhbl9uYXRpb25hbF9jYWxlbmRhcjpcbiAgICAgICAgLy8gWWVhcnMgYXJlIGNvdW50ZWQgaW4gdGhlIFNha2EgZXJhLCB3aGljaCBzdGFydHMgaXRzIHllYXIgMCBpbiB0aGUgeWVhciA3OFxuICAgICAgICAvLyBvZiB0aGUgQ29tbW9uIEVyYS4gVG8gZGV0ZXJtaW5lIGxlYXAgeWVhcnMsIGFkZCA3OCB0byB0aGUgU2FrYSB5ZWFyIOKAkyBpZlxuICAgICAgICAvLyB0aGUgcmVzdWx0IGlzIGEgbGVhcCB5ZWFyIGluIHRoZSBHcmVnb3JpYW4gY2FsZW5kYXIsIHRoZW4gdGhlIFNha2EgeWVhclxuICAgICAgICAvLyBpcyBhIGxlYXAgeWVhciBhcyB3ZWxsLlxuICAgICAgICByZXR1cm4gaXNHcmVnb3JpYW5MZWFwWWVhcihjYWxlbmRhckRhdGUueWVhciArIDc4KTtcbiAgICB9XG4gICAgbW9udGhzSW5ZZWFyKCAvKiBjYWxlbmRhclllYXIsIGNhY2hlICovKSB7XG4gICAgICAgIHJldHVybiAxMjtcbiAgICB9XG4gICAgbWluaW11bU1vbnRoTGVuZ3RoKGNhbGVuZGFyRGF0ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRNb250aEluZm8oY2FsZW5kYXJEYXRlKS5sZW5ndGg7XG4gICAgfVxuICAgIG1heGltdW1Nb250aExlbmd0aChjYWxlbmRhckRhdGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TW9udGhJbmZvKGNhbGVuZGFyRGF0ZSkubGVuZ3RoO1xuICAgIH1cbiAgICBnZXRNb250aEluZm8oY2FsZW5kYXJEYXRlKSB7XG4gICAgICAgIGNvbnN0IHsgbW9udGggfSA9IGNhbGVuZGFyRGF0ZTtcbiAgICAgICAgbGV0IG1vbnRoSW5mbyA9IHRoaXMubW9udGhzW21vbnRoXTtcbiAgICAgICAgaWYgKG1vbnRoSW5mbyA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYEludmFsaWQgbW9udGg6ICR7bW9udGh9YCk7XG4gICAgICAgIGlmICh0aGlzLmluTGVhcFllYXIoY2FsZW5kYXJEYXRlKSAmJiBtb250aEluZm8ubGVhcClcbiAgICAgICAgICAgIG1vbnRoSW5mbyA9IG1vbnRoSW5mby5sZWFwO1xuICAgICAgICByZXR1cm4gbW9udGhJbmZvO1xuICAgIH1cbiAgICBlc3RpbWF0ZUlzb0RhdGUoY2FsZW5kYXJEYXRlUGFyYW0pIHtcbiAgICAgICAgLy8gRllJLCB0aGlzIFwiZXN0aW1hdGVcIiBpcyBhbHdheXMgdGhlIGV4YWN0IElTTyBkYXRlLCB3aGljaCBtYWtlcyB0aGUgSW5kaWFuXG4gICAgICAgIC8vIGNhbGVuZGFyIGZhc3QhXG4gICAgICAgIGNvbnN0IGNhbGVuZGFyRGF0ZSA9IHRoaXMuYWRqdXN0Q2FsZW5kYXJEYXRlKGNhbGVuZGFyRGF0ZVBhcmFtKTtcbiAgICAgICAgY29uc3QgbW9udGhJbmZvID0gdGhpcy5nZXRNb250aEluZm8oY2FsZW5kYXJEYXRlKTtcbiAgICAgICAgY29uc3QgaXNvWWVhciA9IGNhbGVuZGFyRGF0ZS55ZWFyICsgNzggKyAobW9udGhJbmZvLm5leHRZZWFyID8gMSA6IDApO1xuICAgICAgICBjb25zdCBpc29Nb250aCA9IG1vbnRoSW5mby5tb250aDtcbiAgICAgICAgY29uc3QgaXNvRGF5ID0gbW9udGhJbmZvLmRheTtcbiAgICAgICAgY29uc3QgaXNvRGF0ZSA9IEFkZElTT0RhdGUoaXNvWWVhciwgaXNvTW9udGgsIGlzb0RheSwgMCwgMCwgMCwgY2FsZW5kYXJEYXRlLmRheSAtIDEsICdjb25zdHJhaW4nKTtcbiAgICAgICAgcmV0dXJuIGlzb0RhdGU7XG4gICAgfVxuICAgIGNoZWNrSWN1QnVncyhpc29EYXRlKSB7XG4gICAgICAgIGlmICh0aGlzLnZ1bG5lcmFibGVUb0JjZUJ1ZyAmJiBpc29EYXRlLnllYXIgPCAxKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgY2FsZW5kYXIgJyR7dGhpcy5pZH0nIGlzIGJyb2tlbiBmb3IgSVNPIGRhdGVzIGJlZm9yZSAwMDAxLTAxLTAxYCArXG4gICAgICAgICAgICAgICAgJyAoc2VlIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTEwNTI5KScpO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGFkZHMgYWRkaXRpb25hbCBtZXRhZGF0YSB0aGF0IG1ha2VzIGl0IGVhc2llciB0byB3b3JrIHdpdGhcbiAqIGVyYXMuIE5vdGUgdGhhdCBpdCBtdXRhdGVzIGFuZCBub3JtYWxpemVzIHRoZSBvcmlnaW5hbCBlcmEgb2JqZWN0cywgd2hpY2ggaXNcbiAqIE9LIGJlY2F1c2UgdGhpcyBpcyBub24tb2JzZXJ2YWJsZSwgaW50ZXJuYWwtb25seSBtZXRhZGF0YS5cbiAqXG4gKiBUaGUgcmVzdWx0IGlzIGFuIGFycmF5IG9mIGVyYXMgd2l0aCB0aGUgc2hhcGUgZGVmaW5lZCBhYm92ZS5cbiAqICovXG5mdW5jdGlvbiBhZGp1c3RFcmFzKGVyYXNQYXJhbSkge1xuICAgIGxldCBlcmFzID0gZXJhc1BhcmFtO1xuICAgIGlmIChlcmFzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW52YWxpZCBlcmEgZGF0YTogZXJhcyBhcmUgcmVxdWlyZWQnKTtcbiAgICB9XG4gICAgaWYgKGVyYXMubGVuZ3RoID09PSAxICYmIGVyYXNbMF0ucmV2ZXJzZU9mKSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbnZhbGlkIGVyYSBkYXRhOiBhbmNob3IgZXJhIGNhbm5vdCBjb3VudCB5ZWFycyBiYWNrd2FyZHMnKTtcbiAgICB9XG4gICAgaWYgKGVyYXMubGVuZ3RoID09PSAxICYmICFlcmFzWzBdLm5hbWUpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0ludmFsaWQgZXJhIGRhdGE6IGF0IGxlYXN0IG9uZSBuYW1lZCBlcmEgaXMgcmVxdWlyZWQnKTtcbiAgICB9XG4gICAgaWYgKGVyYXMuZmlsdGVyKChlKSA9PiBlLnJldmVyc2VPZiAhPSBudWxsKS5sZW5ndGggPiAxKSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbnZhbGlkIGVyYSBkYXRhOiBvbmx5IG9uZSBlcmEgY2FuIGNvdW50IHllYXJzIGJhY2t3YXJkcycpO1xuICAgIH1cbiAgICAvLyBGaW5kIHRoZSBcImFuY2hvciBlcmFcIiB3aGljaCBpcyB0aGUgZXJhIHVzZWQgZm9yIChlcmEtbGVzcykgYHllYXJgLiBSZXZlcnNlZFxuICAgIC8vIGVyYXMgY2FuIG5ldmVyIGJlIGFuY2hvcnMuIFRoZSBlcmEgd2l0aG91dCBhbiBgYW5jaG9yRXBvY2hgIHByb3BlcnR5IGlzIHRoZVxuICAgIC8vIGFuY2hvci5cbiAgICBsZXQgYW5jaG9yRXJhO1xuICAgIGVyYXMuZm9yRWFjaCgoZSkgPT4ge1xuICAgICAgICBpZiAoZS5pc0FuY2hvciB8fCAoIWUuYW5jaG9yRXBvY2ggJiYgIWUucmV2ZXJzZU9mKSkge1xuICAgICAgICAgICAgaWYgKGFuY2hvckVyYSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW52YWxpZCBlcmEgZGF0YTogY2Fubm90IGhhdmUgbXVsdGlwbGUgYW5jaG9yIGVyYXMnKTtcbiAgICAgICAgICAgIGFuY2hvckVyYSA9IGU7XG4gICAgICAgICAgICBlLmFuY2hvckVwb2NoID0geyB5ZWFyOiBlLmhhc1llYXJaZXJvID8gMCA6IDEgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghZS5uYW1lKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSWYgZXJhIG5hbWUgaXMgYmxhbmssIGl0IG11c3QgYmUgdGhlIGFuY2hvciBlcmEnKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIC8vIElmIHRoZSBlcmEgbmFtZSBpcyB1bmRlZmluZWQsIHRoZW4gaXQncyBhbiBhbmNob3IgdGhhdCBkb2Vzbid0IGludGVyYWN0XG4gICAgLy8gd2l0aCBlcmFzIGF0IGFsbC4gRm9yIGV4YW1wbGUsIEphcGFuZXNlIGB5ZWFyYCBpcyBhbHdheXMgdGhlIHNhbWUgYXMgSVNPXG4gICAgLy8gYHllYXJgLiAgU28gdGhpcyBcImVyYVwiIGlzIHRoZSBhbmNob3IgZXJhIGJ1dCBpc24ndCB1c2VkIGZvciBlcmEgbWF0Y2hpbmcuXG4gICAgLy8gU3RyaXAgaXQgZnJvbSB0aGUgbGlzdCB0aGF0J3MgcmV0dXJuZWQuXG4gICAgZXJhcyA9IGVyYXMuZmlsdGVyKChlKSA9PiBlLm5hbWUpO1xuICAgIGVyYXMuZm9yRWFjaCgoZSkgPT4ge1xuICAgICAgICAvLyBTb21lIGVyYXMgYXJlIG1pcnJvciBpbWFnZXMgb2YgYW5vdGhlciBlcmEgZS5nLiBCLkMuIGlzIHRoZSByZXZlcnNlIG9mIEEuRC5cbiAgICAgICAgLy8gUmVwbGFjZSB0aGUgc3RyaW5nLXZhbHVlZCBcInJldmVyc2VPZlwiIHByb3BlcnR5IHdpdGggdGhlIGFjdHVhbCBlcmEgb2JqZWN0XG4gICAgICAgIC8vIHRoYXQncyByZXZlcnNlZC5cbiAgICAgICAgY29uc3QgeyByZXZlcnNlT2YgfSA9IGU7XG4gICAgICAgIGlmIChyZXZlcnNlT2YpIHtcbiAgICAgICAgICAgIGNvbnN0IHJldmVyc2VkRXJhID0gZXJhcy5maW5kKChlcmEpID0+IGVyYS5uYW1lID09PSByZXZlcnNlT2YpO1xuICAgICAgICAgICAgaWYgKHJldmVyc2VkRXJhID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYEludmFsaWQgZXJhIGRhdGE6IHVubWF0Y2hlZCByZXZlcnNlT2YgZXJhOiAke3JldmVyc2VPZn1gKTtcbiAgICAgICAgICAgIGUucmV2ZXJzZU9mID0gcmV2ZXJzZWRFcmE7XG4gICAgICAgICAgICBlLmFuY2hvckVwb2NoID0gcmV2ZXJzZWRFcmEuYW5jaG9yRXBvY2g7XG4gICAgICAgICAgICBlLmlzb0Vwb2NoID0gcmV2ZXJzZWRFcmEuaXNvRXBvY2g7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGUuYW5jaG9yRXBvY2gubW9udGggPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIGUuYW5jaG9yRXBvY2gubW9udGggPSAxO1xuICAgICAgICBpZiAoZS5hbmNob3JFcG9jaC5kYXkgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIGUuYW5jaG9yRXBvY2guZGF5ID0gMTtcbiAgICB9KTtcbiAgICAvLyBFbnN1cmUgdGhhdCB0aGUgbGF0ZXN0IGVwb2NoIGlzIGZpcnN0IGluIHRoZSBhcnJheS4gVGhpcyBsZXRzIHVzIHRyeSB0b1xuICAgIC8vIG1hdGNoIGVyYXMgaW4gaW5kZXggb3JkZXIsIHdpdGggdGhlIGxhc3QgZXJhIGdldHRpbmcgdGhlIHJlbWFpbmluZyBvbGRlclxuICAgIC8vIHllYXJzLiBBbnkgcmV2ZXJzZS1zaWduZWQgZXJhIG11c3QgYmUgYXQgdGhlIGVuZC5cbiAgICBBcnJheVNvcnQuY2FsbChlcmFzLCAoZTEsIGUyKSA9PiB7XG4gICAgICAgIGlmIChlMS5yZXZlcnNlT2YpXG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgaWYgKGUyLnJldmVyc2VPZilcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgaWYgKCFlMS5pc29FcG9jaCB8fCAhZTIuaXNvRXBvY2gpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW52YWxpZCBlcmEgZGF0YTogbWlzc2luZyBJU08gZXBvY2gnKTtcbiAgICAgICAgcmV0dXJuIGUyLmlzb0Vwb2NoLnllYXIgLSBlMS5pc29FcG9jaC55ZWFyO1xuICAgIH0pO1xuICAgIC8vIElmIHRoZXJlJ3MgYSByZXZlcnNlZCBlcmEsIHRoZW4gdGhlIG9uZSBiZWZvcmUgaXQgbXVzdCBiZSB0aGUgZXJhIHRoYXQnc1xuICAgIC8vIGJlaW5nIHJldmVyc2VkLlxuICAgIGNvbnN0IGxhc3RFcmFSZXZlcnNlZCA9IGVyYXNbZXJhcy5sZW5ndGggLSAxXS5yZXZlcnNlT2Y7XG4gICAgaWYgKGxhc3RFcmFSZXZlcnNlZCkge1xuICAgICAgICBpZiAobGFzdEVyYVJldmVyc2VkICE9PSBlcmFzW2VyYXMubGVuZ3RoIC0gMl0pXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW52YWxpZCBlcmEgZGF0YTogaW52YWxpZCByZXZlcnNlLXNpZ24gZXJhJyk7XG4gICAgfVxuICAgIC8vIEZpbmFsbHksIGFkZCBhIFwiZ2VuZXJpY05hbWVcIiBwcm9wZXJ0eSBpbiB0aGUgZm9ybWF0IFwiZXJhe259IHdoZXJlIGBuYCBpc1xuICAgIC8vIHplcm8tYmFzZWQgaW5kZXgsIHdpdGggdGhlIG9sZGVzdCBlcmEgYmVpbmcgemVyby4gVGhpcyBmb3JtYXQgaXMgdXNlZCBieVxuICAgIC8vIG9sZGVyIHZlcnNpb25zIG9mIElDVSBkYXRhLlxuICAgIGVyYXMuZm9yRWFjaCgoZSwgaSkgPT4ge1xuICAgICAgICBlLmdlbmVyaWNOYW1lID0gYGVyYSR7ZXJhcy5sZW5ndGggLSAxIC0gaX1gO1xuICAgIH0pO1xuICAgIHJldHVybiB7IGVyYXM6IGVyYXMsIGFuY2hvckVyYTogKGFuY2hvckVyYSB8fCBlcmFzWzBdKSB9O1xufVxuZnVuY3Rpb24gaXNHcmVnb3JpYW5MZWFwWWVhcih5ZWFyKSB7XG4gICAgcmV0dXJuIHllYXIgJSA0ID09PSAwICYmICh5ZWFyICUgMTAwICE9PSAwIHx8IHllYXIgJSA0MDAgPT09IDApO1xufVxuLyoqIEJhc2UgZm9yIGFsbCBHcmVnb3JpYW4tbGlrZSBjYWxlbmRhcnMuICovXG5jbGFzcyBHcmVnb3JpYW5CYXNlSGVscGVyIGV4dGVuZHMgSGVscGVyQmFzZSB7XG4gICAgY29uc3RydWN0b3IoaWQsIG9yaWdpbmFsRXJhcykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmNhbGVuZGFyVHlwZSA9ICdzb2xhcic7XG4gICAgICAgIC8vIFNldmVyYWwgY2FsZW5kYXJzIGJhc2VkIG9uIHRoZSBHcmVnb3JpYW4gY2FsZW5kYXIgdXNlIEp1bGlhbiBkYXRlcyAobm90XG4gICAgICAgIC8vIHByb2xlcHRpYyBHcmVnb3JpYW4gZGF0ZXMpIGJlZm9yZSB0aGUgSnVsaWFuIHN3aXRjaG92ZXIgaW4gT2N0IDE1ODIuIFNlZVxuICAgICAgICAvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0xMTczMTU4LlxuICAgICAgICB0aGlzLnY4SXNWdWxuZXJhYmxlVG9KdWxpYW5CdWcgPSBuZXcgRGF0ZSgnKzAwMTAwMS0wMS0wMVQwMDowMFonKVxuICAgICAgICAgICAgLnRvTG9jYWxlRGF0ZVN0cmluZygnZW4tVVMtdS1jYS1qYXBhbmVzZScsIHsgdGltZVpvbmU6ICdVVEMnIH0pXG4gICAgICAgICAgICAuc3RhcnRzV2l0aCgnMTInKTtcbiAgICAgICAgdGhpcy5jYWxlbmRhcklzVnVsbmVyYWJsZVRvSnVsaWFuQnVnID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaWQgPSBpZDtcbiAgICAgICAgY29uc3QgeyBlcmFzLCBhbmNob3JFcmEgfSA9IGFkanVzdEVyYXMob3JpZ2luYWxFcmFzKTtcbiAgICAgICAgdGhpcy5hbmNob3JFcmEgPSBhbmNob3JFcmE7XG4gICAgICAgIHRoaXMuZXJhcyA9IGVyYXM7XG4gICAgfVxuICAgIGluTGVhcFllYXIoY2FsZW5kYXJEYXRlKSB7XG4gICAgICAgIC8vIENhbGVuZGFycyB0aGF0IGRvbid0IG92ZXJyaWRlIHRoaXMgbWV0aG9kIHVzZSB0aGUgc2FtZSBtb250aHMgYW5kIGxlYXBcbiAgICAgICAgLy8geWVhcnMgYXMgR3JlZ29yaWFuLiBPbmNlIHdlIGtub3cgdGhlIElTTyB5ZWFyIGNvcnJlc3BvbmRpbmcgdG8gdGhlXG4gICAgICAgIC8vIGNhbGVuZGFyIHllYXIsIHdlJ2xsIGtub3cgaWYgaXQncyBhIGxlYXAgeWVhciBvciBub3QuXG4gICAgICAgIGNvbnN0IHsgeWVhciB9ID0gdGhpcy5lc3RpbWF0ZUlzb0RhdGUoeyBtb250aDogMSwgZGF5OiAxLCB5ZWFyOiBjYWxlbmRhckRhdGUueWVhciB9KTtcbiAgICAgICAgcmV0dXJuIGlzR3JlZ29yaWFuTGVhcFllYXIoeWVhcik7XG4gICAgfVxuICAgIG1vbnRoc0luWWVhciggLyogY2FsZW5kYXJEYXRlICovKSB7XG4gICAgICAgIHJldHVybiAxMjtcbiAgICB9XG4gICAgbWluaW11bU1vbnRoTGVuZ3RoKGNhbGVuZGFyRGF0ZSkge1xuICAgICAgICBjb25zdCB7IG1vbnRoIH0gPSBjYWxlbmRhckRhdGU7XG4gICAgICAgIGlmIChtb250aCA9PT0gMilcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmluTGVhcFllYXIoY2FsZW5kYXJEYXRlKSA/IDI5IDogMjg7XG4gICAgICAgIHJldHVybiBbNCwgNiwgOSwgMTFdLmluZGV4T2YobW9udGgpID49IDAgPyAzMCA6IDMxO1xuICAgIH1cbiAgICBtYXhpbXVtTW9udGhMZW5ndGgoY2FsZW5kYXJEYXRlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pbmltdW1Nb250aExlbmd0aChjYWxlbmRhckRhdGUpO1xuICAgIH1cbiAgICAvKiogRmlsbCBpbiBtaXNzaW5nIHBhcnRzIG9mIHRoZSAoeWVhciwgZXJhLCBlcmFZZWFyKSB0dXBsZSAqL1xuICAgIGNvbXBsZXRlRXJhWWVhcihjYWxlbmRhckRhdGUpIHtcbiAgICAgICAgY29uc3QgY2hlY2tGaWVsZCA9IChuYW1lLCB2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgY3VycmVudFZhbHVlID0gY2FsZW5kYXJEYXRlW25hbWVdO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRWYWx1ZSAhPSBudWxsICYmIGN1cnJlbnRWYWx1ZSAhPSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBJbnB1dCAke25hbWV9ICR7Y3VycmVudFZhbHVlfSBkb2Vzbid0IG1hdGNoIGNhbGN1bGF0ZWQgdmFsdWUgJHt2YWx1ZX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgZXJhRnJvbVllYXIgPSAoeWVhcikgPT4ge1xuICAgICAgICAgICAgbGV0IGVyYVllYXI7XG4gICAgICAgICAgICBjb25zdCBhZGp1c3RlZENhbGVuZGFyRGF0ZSA9IHsgLi4uY2FsZW5kYXJEYXRlLCB5ZWFyIH07XG4gICAgICAgICAgICBjb25zdCBtYXRjaGluZ0VyYSA9IHRoaXMuZXJhcy5maW5kKChlLCBpKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGkgPT09IHRoaXMuZXJhcy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlLnJldmVyc2VPZikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBpcyBhIHJldmVyc2Utc2lnbiBlcmEgKGxpa2UgQkNFKSB3aGljaCBtdXN0IGJlIHRoZSBvbGRlc3RcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVyYS4gQ291bnQgeWVhcnMgYmFja3dhcmRzLlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHllYXIgPiAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBTaWduZWQgeWVhciAke3llYXJ9IGlzIGludmFsaWQgZm9yIGVyYSAke2UubmFtZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVyYVllYXIgPSBlLmFuY2hvckVwb2NoLnllYXIgLSB5ZWFyO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gbGFzdCBlcmEgYWx3YXlzIGdldHMgYWxsIFwibGVmdG92ZXJcIiAob2xkZXIgdGhhbiBlcG9jaCkgeWVhcnMsXG4gICAgICAgICAgICAgICAgICAgIC8vIHNvIG5vIG5lZWQgZm9yIGEgY29tcGFyaXNvbiBsaWtlIGJlbG93LlxuICAgICAgICAgICAgICAgICAgICBlcmFZZWFyID0geWVhciAtIGUuYW5jaG9yRXBvY2gueWVhciArIChlLmhhc1llYXJaZXJvID8gMCA6IDEpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgY29tcGFyaXNvbiA9IHRoaXMuY29tcGFyZUNhbGVuZGFyRGF0ZXMoYWRqdXN0ZWRDYWxlbmRhckRhdGUsIGUuYW5jaG9yRXBvY2gpO1xuICAgICAgICAgICAgICAgIGlmIChjb21wYXJpc29uID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZXJhWWVhciA9IHllYXIgLSBlLmFuY2hvckVwb2NoLnllYXIgKyAoZS5oYXNZZWFyWmVybyA/IDAgOiAxKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKCFtYXRjaGluZ0VyYSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgWWVhciAke3llYXJ9IHdhcyBub3QgbWF0Y2hlZCBieSBhbnkgZXJhYCk7XG4gICAgICAgICAgICByZXR1cm4geyBlcmFZZWFyOiBlcmFZZWFyLCBlcmE6IG1hdGNoaW5nRXJhLm5hbWUgfTtcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IHsgeWVhciwgZXJhWWVhciwgZXJhIH0gPSBjYWxlbmRhckRhdGU7XG4gICAgICAgIGlmICh5ZWFyICE9IG51bGwpIHtcbiAgICAgICAgICAgICh7IGVyYVllYXIsIGVyYSB9ID0gZXJhRnJvbVllYXIoeWVhcikpO1xuICAgICAgICAgICAgY2hlY2tGaWVsZCgnZXJhJywgZXJhKTtcbiAgICAgICAgICAgIGNoZWNrRmllbGQoJ2VyYVllYXInLCBlcmFZZWFyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChlcmFZZWFyICE9IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IG1hdGNoaW5nRXJhID0gZXJhID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiB0aGlzLmVyYXMuZmluZCgoZSkgPT4gZS5uYW1lID09PSBlcmEgfHwgZS5nZW5lcmljTmFtZSA9PT0gZXJhKTtcbiAgICAgICAgICAgIGlmICghbWF0Y2hpbmdFcmEpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYEVyYSAke2VyYX0gKElTTyB5ZWFyICR7ZXJhWWVhcn0pIHdhcyBub3QgbWF0Y2hlZCBieSBhbnkgZXJhYCk7XG4gICAgICAgICAgICBpZiAoZXJhWWVhciA8IDEgJiYgbWF0Y2hpbmdFcmEucmV2ZXJzZU9mKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYFllYXJzIGluICR7ZXJhfSBlcmEgbXVzdCBiZSBwb3NpdGl2ZSwgbm90ICR7eWVhcn1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtYXRjaGluZ0VyYS5yZXZlcnNlT2YpIHtcbiAgICAgICAgICAgICAgICB5ZWFyID0gbWF0Y2hpbmdFcmEuYW5jaG9yRXBvY2gueWVhciAtIGVyYVllYXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB5ZWFyID0gZXJhWWVhciArIG1hdGNoaW5nRXJhLmFuY2hvckVwb2NoLnllYXIgLSAobWF0Y2hpbmdFcmEuaGFzWWVhclplcm8gPyAwIDogMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjaGVja0ZpZWxkKCd5ZWFyJywgeWVhcik7XG4gICAgICAgICAgICAvLyBXZSdsbCBhY2NlcHQgZGF0ZXMgd2hlcmUgdGhlIG1vbnRoL2RheSBpcyBlYXJsaWVyIHRoYW4gdGhlIHN0YXJ0IG9mXG4gICAgICAgICAgICAvLyB0aGUgZXJhIG9yIGFmdGVyIGl0cyBlbmQgYXMgbG9uZyBhcyBpdCdzIGluIHRoZSBzYW1lIHllYXIuIElmIHRoYXRcbiAgICAgICAgICAgIC8vIGhhcHBlbnMsIHdlJ2xsIGFkanVzdCB0aGUgZXJhL2VyYVllYXIgcGFpciB0byBiZSB0aGUgY29ycmVjdCBlcmEgZm9yXG4gICAgICAgICAgICAvLyB0aGUgYHllYXJgLlxuICAgICAgICAgICAgKHsgZXJhWWVhciwgZXJhIH0gPSBlcmFGcm9tWWVhcih5ZWFyKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignRWl0aGVyIGB5ZWFyYCBvciBgZXJhWWVhcmAgYW5kIGBlcmFgIGFyZSByZXF1aXJlZCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IC4uLmNhbGVuZGFyRGF0ZSwgeWVhciwgZXJhWWVhciwgZXJhIH07XG4gICAgfVxuICAgIGFkanVzdENhbGVuZGFyRGF0ZShjYWxlbmRhckRhdGVQYXJhbSwgY2FjaGUsIG92ZXJmbG93ID0gJ2NvbnN0cmFpbicpIHtcbiAgICAgICAgbGV0IGNhbGVuZGFyRGF0ZSA9IGNhbGVuZGFyRGF0ZVBhcmFtO1xuICAgICAgICAvLyBCZWNhdXNlIHRoaXMgaXMgbm90IGEgbHVuaXNvbGFyIGNhbGVuZGFyLCBpdCdzIHNhZmUgdG8gY29udmVydCBtb250aENvZGUgdG8gYSBudW1iZXJcbiAgICAgICAgY29uc3QgeyBtb250aCwgbW9udGhDb2RlIH0gPSBjYWxlbmRhckRhdGU7XG4gICAgICAgIGlmIChtb250aCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgY2FsZW5kYXJEYXRlID0geyAuLi5jYWxlbmRhckRhdGUsIG1vbnRoOiBtb250aENvZGVOdW1iZXJQYXJ0KG1vbnRoQ29kZSkgfTtcbiAgICAgICAgdGhpcy52YWxpZGF0ZUNhbGVuZGFyRGF0ZShjYWxlbmRhckRhdGUpO1xuICAgICAgICBjYWxlbmRhckRhdGUgPSB0aGlzLmNvbXBsZXRlRXJhWWVhcihjYWxlbmRhckRhdGUpO1xuICAgICAgICByZXR1cm4gc3VwZXIuYWRqdXN0Q2FsZW5kYXJEYXRlKGNhbGVuZGFyRGF0ZSwgY2FjaGUsIG92ZXJmbG93KTtcbiAgICB9XG4gICAgZXN0aW1hdGVJc29EYXRlKGNhbGVuZGFyRGF0ZVBhcmFtKSB7XG4gICAgICAgIGNvbnN0IGNhbGVuZGFyRGF0ZSA9IHRoaXMuYWRqdXN0Q2FsZW5kYXJEYXRlKGNhbGVuZGFyRGF0ZVBhcmFtKTtcbiAgICAgICAgY29uc3QgeyB5ZWFyLCBtb250aCwgZGF5IH0gPSBjYWxlbmRhckRhdGU7XG4gICAgICAgIGNvbnN0IHsgYW5jaG9yRXJhIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCBpc29ZZWFyRXN0aW1hdGUgPSB5ZWFyICsgYW5jaG9yRXJhLmlzb0Vwb2NoLnllYXIgLSAoYW5jaG9yRXJhLmhhc1llYXJaZXJvID8gMCA6IDEpO1xuICAgICAgICByZXR1cm4gUmVndWxhdGVJU09EYXRlKGlzb1llYXJFc3RpbWF0ZSwgbW9udGgsIGRheSwgJ2NvbnN0cmFpbicpO1xuICAgIH1cbiAgICBjaGVja0ljdUJ1Z3MoaXNvRGF0ZSkge1xuICAgICAgICBpZiAodGhpcy5jYWxlbmRhcklzVnVsbmVyYWJsZVRvSnVsaWFuQnVnICYmIHRoaXMudjhJc1Z1bG5lcmFibGVUb0p1bGlhbkJ1Zykge1xuICAgICAgICAgICAgY29uc3QgYmVmb3JlSnVsaWFuU3dpdGNoID0gQ29tcGFyZUlTT0RhdGUoaXNvRGF0ZS55ZWFyLCBpc29EYXRlLm1vbnRoLCBpc29EYXRlLmRheSwgMTU4MiwgMTAsIDE1KSA8IDA7XG4gICAgICAgICAgICBpZiAoYmVmb3JlSnVsaWFuU3dpdGNoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYGNhbGVuZGFyICcke3RoaXMuaWR9JyBpcyBicm9rZW4gZm9yIElTTyBkYXRlcyBiZWZvcmUgMTU4Mi0xMC0xNWAgK1xuICAgICAgICAgICAgICAgICAgICAnIChzZWUgaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MTE3MzE1OCknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmNsYXNzIE9ydGhvZG94QmFzZUhlbHBlciBleHRlbmRzIEdyZWdvcmlhbkJhc2VIZWxwZXIge1xuICAgIGNvbnN0cnVjdG9yKGlkLCBvcmlnaW5hbEVyYXMpIHtcbiAgICAgICAgc3VwZXIoaWQsIG9yaWdpbmFsRXJhcyk7XG4gICAgfVxuICAgIGluTGVhcFllYXIoY2FsZW5kYXJEYXRlKSB7XG4gICAgICAgIC8vIExlYXAgeWVhcnMgaGFwcGVuIG9uZSB5ZWFyIGJlZm9yZSB0aGUgSnVsaWFuIGxlYXAgeWVhci4gTm90ZSB0aGF0IHRoaXNcbiAgICAgICAgLy8gY2FsZW5kYXIgaXMgYmFzZWQgb24gdGhlIEp1bGlhbiBjYWxlbmRhciB3aGljaCBoYXMgYSBsZWFwIHllYXIgZXZlcnkgNFxuICAgICAgICAvLyB5ZWFycywgdW5saWtlIHRoZSBHcmVnb3JpYW4gY2FsZW5kYXIgd2hpY2ggZG9lc24ndCBoYXZlIGxlYXAgeWVhcnMgb25cbiAgICAgICAgLy8geWVhcnMgZGl2aXNpYmxlIGJ5IDEwMCBleGNlcHQgeWVhcnMgZGl2aXNpYmxlIGJ5IDQwMC5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gTm90ZSB0aGF0IHdlJ3JlIGFzc3VtaW5nIHRoYXQgbGVhcCB5ZWFycyBpbiBiZWZvcmUtZXBvY2ggdGltZXMgbWF0Y2hcbiAgICAgICAgLy8gaG93IGxlYXAgeWVhcnMgYXJlIGRlZmluZWQgbm93LiBUaGlzIGlzIHByb2JhYmx5IG5vdCBhY2N1cmF0ZSBidXQgSSdtXG4gICAgICAgIC8vIG5vdCBzdXJlIGhvdyBiZXR0ZXIgdG8gZG8gaXQuXG4gICAgICAgIGNvbnN0IHsgeWVhciB9ID0gY2FsZW5kYXJEYXRlO1xuICAgICAgICByZXR1cm4gKHllYXIgKyAxKSAlIDQgPT09IDA7XG4gICAgfVxuICAgIG1vbnRoc0luWWVhciggLyogY2FsZW5kYXJEYXRlICovKSB7XG4gICAgICAgIHJldHVybiAxMztcbiAgICB9XG4gICAgbWluaW11bU1vbnRoTGVuZ3RoKGNhbGVuZGFyRGF0ZSkge1xuICAgICAgICBjb25zdCB7IG1vbnRoIH0gPSBjYWxlbmRhckRhdGU7XG4gICAgICAgIC8vIEV0aGlvcGlhbi9Db3B0aWMgY2FsZW5kYXJzIGhhdmUgMTIgMzAtZGF5IG1vbnRocyBhbmQgYW4gZXh0cmEgNS02IGRheSAxM3RoIG1vbnRoLlxuICAgICAgICBpZiAobW9udGggPT09IDEzKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5MZWFwWWVhcihjYWxlbmRhckRhdGUpID8gNiA6IDU7XG4gICAgICAgIHJldHVybiAzMDtcbiAgICB9XG4gICAgbWF4aW11bU1vbnRoTGVuZ3RoKGNhbGVuZGFyRGF0ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5taW5pbXVtTW9udGhMZW5ndGgoY2FsZW5kYXJEYXRlKTtcbiAgICB9XG59XG4vLyBgY29wdGljYCBhbmQgYGV0aGlvcGljYCBjYWxlbmRhcnMgYXJlIHZlcnkgc2ltaWxhciB0byBgZXRoaW9hYWAgY2FsZW5kYXIsXG4vLyB3aXRoIHRoZSBmb2xsb3dpbmcgZGlmZmVyZW5jZXM6XG4vLyAtIENvcHRpYyB1c2VzIEJDRS1saWtlIHBvc2l0aXZlIG51bWJlcnMgZm9yIHllYXJzIGJlZm9yZSBpdHMgZXBvY2ggKHRoZSBvdGhlclxuLy8gICB0d28gdXNlIG5lZ2F0aXZlIHllYXIgbnVtYmVycyBiZWZvcmUgZXBvY2gpXG4vLyAtIENvcHRpYyBoYXMgYSBkaWZmZXJlbnQgZXBvY2ggZGF0ZVxuLy8gLSBFdGhpb3BpYyBoYXMgYW4gYWRkaXRpb25hbCBzZWNvbmQgZXJhIHRoYXQgc3RhcnRzIGF0IHRoZSBzYW1lIGRhdGUgYXMgdGhlXG4vLyAgIHplcm8gZXJhIG9mIGV0aGlvYWEuXG5jbGFzcyBFdGhpb2FhSGVscGVyIGV4dGVuZHMgT3J0aG9kb3hCYXNlSGVscGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoJ2V0aGlvYWEnLCBbeyBuYW1lOiAnZXJhMCcsIGlzb0Vwb2NoOiB7IHllYXI6IC01NDkyLCBtb250aDogNywgZGF5OiAxNyB9IH1dKTtcbiAgICB9XG59XG5jbGFzcyBDb3B0aWNIZWxwZXIgZXh0ZW5kcyBPcnRob2RveEJhc2VIZWxwZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcignY29wdGljJywgW1xuICAgICAgICAgICAgeyBuYW1lOiAnZXJhMScsIGlzb0Vwb2NoOiB7IHllYXI6IDI4NCwgbW9udGg6IDgsIGRheTogMjkgfSB9LFxuICAgICAgICAgICAgeyBuYW1lOiAnZXJhMCcsIHJldmVyc2VPZjogJ2VyYTEnIH1cbiAgICAgICAgXSk7XG4gICAgfVxufVxuLy8gQW5jaG9yIGlzIGN1cnJlbnRseSB0aGUgb2xkZXIgZXJhIHRvIG1hdGNoIGV0aGlvYWEsIGJ1dCBzaG91bGQgaXQgYmUgdGhlIG5ld2VyIGVyYT9cbi8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9lY21hNDAyL2lzc3Vlcy81MzQgZm9yIGRpc2N1c3Npb24uXG5jbGFzcyBFdGhpb3BpY0hlbHBlciBleHRlbmRzIE9ydGhvZG94QmFzZUhlbHBlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCdldGhpb3BpYycsIFtcbiAgICAgICAgICAgIHsgbmFtZTogJ2VyYTAnLCBpc29FcG9jaDogeyB5ZWFyOiAtNTQ5MiwgbW9udGg6IDcsIGRheTogMTcgfSB9LFxuICAgICAgICAgICAgeyBuYW1lOiAnZXJhMScsIGlzb0Vwb2NoOiB7IHllYXI6IDgsIG1vbnRoOiA4LCBkYXk6IDI3IH0sIGFuY2hvckVwb2NoOiB7IHllYXI6IDU1MDEgfSB9XG4gICAgICAgIF0pO1xuICAgIH1cbn1cbmNsYXNzIFJvY0hlbHBlciBleHRlbmRzIEdyZWdvcmlhbkJhc2VIZWxwZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigncm9jJywgW1xuICAgICAgICAgICAgeyBuYW1lOiAnbWluZ3VvJywgaXNvRXBvY2g6IHsgeWVhcjogMTkxMiwgbW9udGg6IDEsIGRheTogMSB9IH0sXG4gICAgICAgICAgICB7IG5hbWU6ICdiZWZvcmUtcm9jJywgcmV2ZXJzZU9mOiAnbWluZ3VvJyB9XG4gICAgICAgIF0pO1xuICAgICAgICB0aGlzLmNhbGVuZGFySXNWdWxuZXJhYmxlVG9KdWxpYW5CdWcgPSB0cnVlO1xuICAgIH1cbn1cbmNsYXNzIEJ1ZGRoaXN0SGVscGVyIGV4dGVuZHMgR3JlZ29yaWFuQmFzZUhlbHBlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCdidWRkaGlzdCcsIFt7IG5hbWU6ICdiZScsIGhhc1llYXJaZXJvOiB0cnVlLCBpc29FcG9jaDogeyB5ZWFyOiAtNTQzLCBtb250aDogMSwgZGF5OiAxIH0gfV0pO1xuICAgICAgICB0aGlzLmNhbGVuZGFySXNWdWxuZXJhYmxlVG9KdWxpYW5CdWcgPSB0cnVlO1xuICAgIH1cbn1cbmNsYXNzIEdyZWdvcnlIZWxwZXIgZXh0ZW5kcyBHcmVnb3JpYW5CYXNlSGVscGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoJ2dyZWdvcnknLCBbXG4gICAgICAgICAgICB7IG5hbWU6ICdjZScsIGlzb0Vwb2NoOiB7IHllYXI6IDEsIG1vbnRoOiAxLCBkYXk6IDEgfSB9LFxuICAgICAgICAgICAgeyBuYW1lOiAnYmNlJywgcmV2ZXJzZU9mOiAnY2UnIH1cbiAgICAgICAgXSk7XG4gICAgfVxuICAgIHJldmlzZUludGxFcmEoY2FsZW5kYXJEYXRlIC8qLCBpc29EYXRlOiBJc29EYXRlKi8pIHtcbiAgICAgICAgbGV0IHsgZXJhLCBlcmFZZWFyIH0gPSBjYWxlbmRhckRhdGU7XG4gICAgICAgIC8vIEZpcmVmb3ggOTYgaW50cm9kdWNlZCBhIGJ1ZyB3aGVyZSB0aGUgYCdzaG9ydCdgIGZvcm1hdCBvZiB0aGUgZXJhXG4gICAgICAgIC8vIG9wdGlvbiBtaXN0YWtlbmx5IHJldHVybnMgdGhlIG9uZS1sZXR0ZXIgKG5hcnJvdykgZm9ybWF0IGluc3RlYWQuIFRoZVxuICAgICAgICAvLyBjb2RlIGJlbG93IGhhbmRsZXMgZWl0aGVyIHRoZSBjb3JyZWN0IG9yIEZpcmVmb3gtYnVnZ3kgZm9ybWF0LiBTZWVcbiAgICAgICAgLy8gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTc1MjI1M1xuICAgICAgICBpZiAoZXJhID09PSAnYmMnIHx8IGVyYSA9PT0gJ2InKVxuICAgICAgICAgICAgZXJhID0gJ2JjZSc7XG4gICAgICAgIGlmIChlcmEgPT09ICdhZCcgfHwgZXJhID09PSAnYScpXG4gICAgICAgICAgICBlcmEgPSAnY2UnO1xuICAgICAgICByZXR1cm4geyBlcmEsIGVyYVllYXIgfTtcbiAgICB9XG59XG4vLyBOT1RFOiBPbmx5IHRoZSA1IG1vZGVybiBlcmFzIChNZWlqaSBhbmQgbGF0ZXIpIGFyZSBpbmNsdWRlZC4gRm9yIGRhdGVzXG4vLyBiZWZvcmUgTWVpamkgMSwgdGhlIGBjZWAgYW5kIGBiY2VgIGVyYXMgYXJlIHVzZWQuIENoYWxsZW5nZXMgd2l0aCBwcmUtTWVpamlcbi8vIGVyYXMgaW5jbHVkZTpcbi8vIC0gU3RhcnQvZW5kIGRhdGVzIG9mIG9sZGVyIGVyYXMgYXJlIG5vdCBwcmVjaXNlbHkgZGVmaW5lZCwgd2hpY2ggaXNcbi8vICAgY2hhbGxlbmdpbmcgZ2l2ZW4gVGVtcG9yYWwncyBuZWVkIGZvciBwcmVjaXNpb25cbi8vIC0gU29tZSBlcmEgZGF0ZXMgYW5kL29yIG5hbWVzIGFyZSBkaXNwdXRlZCBieSBoaXN0b3JpYW5zXG4vLyAtIEFzIGhpc3RvcmljYWwgcmVzZWFyY2ggcHJvY2VlZHMsIG5ldyBlcmFzIGFyZSBkaXNjb3ZlcmVkIGFuZCBleGlzdGluZyBlcmFcbi8vICAgZGF0ZXMgYXJlIG1vZGlmaWVkLCBsZWFkaW5nIHRvIGNvbnNpZGVyYWJsZSBjaHVybiB3aGljaCBpcyBub3QgZ29vZCBmb3Jcbi8vICAgVGVtcG9yYWwgdXNlLlxuLy8gIC0gVGhlIGVhcmxpZXN0IGVyYSAoaW4gNjQ1IENFKSBtYXkgbm90IGVuZCB1cCBiZWluZyB0aGUgZWFybGllc3QgZGVwZW5kaW5nXG4vLyAgICBvbiBmdXR1cmUgaGlzdG9yaWNhbCBzY2hvbGFyc2hpcFxuLy8gIC0gQmVmb3JlIE1laWppLCBKYXBhbiB1c2VkIGEgbHVuYXIgKG9yIGx1bmlzb2xhcj8pIGNhbGVuZGFyIGJ1dCBBRkFJS1xuLy8gICAgdGhhdCdzIG5vdCByZWZsZWN0ZWQgaW4gdGhlIElDVSBpbXBsZW1lbnRhdGlvbi5cbi8vXG4vLyBGb3IgbW9yZSBkaXNjdXNzaW9uOiBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC10ZW1wb3JhbC9pc3N1ZXMvNTI2LlxuLy9cbi8vIEhlcmUncyBhIGZ1bGwgbGlzdCBvZiBDTERSL0lDVSBlcmFzOlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3VuaWNvZGUtb3JnL2ljdS9ibG9iL21hc3Rlci9pY3U0Yy9zb3VyY2UvZGF0YS9sb2NhbGVzL3Jvb3QudHh0I0wxNTgyLUwxODE4XG4vLyBodHRwczovL2dpdGh1Yi5jb20vdW5pY29kZS1vcmcvY2xkci9ibG9iL21hc3Rlci9jb21tb24vc3VwcGxlbWVudGFsL3N1cHBsZW1lbnRhbERhdGEueG1sI0w0MzEwLUw0NTQ2XG4vL1xuLy8gTk9URTogSmFwYW4gc3RhcnRlZCB1c2luZyB0aGUgR3JlZ29yaWFuIGNhbGVuZGFyIGluIDYgTWVpamksIHJlcGxhY2luZyBhXG4vLyBsdW5pc29sYXIgY2FsZW5kYXIuIFNvIHRoZSBkYXkgYmVmb3JlIEphbnVhcnkgMSBvZiA2IE1laWppICgxODczKSB3YXMgbm90XG4vLyBEZWNlbWJlciAzMSwgYnV0IERlY2VtYmVyIDIsIG9mIDUgTWVpamkgKDE4NzIpLiBUaGUgZXhpc3RpbmcgRWNtYS00MDJcbi8vIEphcGFuZXNlIGNhbGVuZGFyIGRvZXNuJ3Qgc2VlbSB0byB0YWtlIHRoaXMgaW50byBhY2NvdW50LCBzbyBuZWl0aGVyIGRvIHdlOlxuLy8gPiBhcmdzID0gWydlbi1jYS11LWNhLWphcGFuZXNlJywgeyBlcmE6ICdzaG9ydCcgfV1cbi8vID4gbmV3IERhdGUoJzE4NzMtMDEtMDFUMTI6MDAnKS50b0xvY2FsZVN0cmluZyguLi5hcmdzKVxuLy8gJzEgMSwgNiBNZWlqaSwgMTI6MDA6MDAgUE0nXG4vLyA+IG5ldyBEYXRlKCcxODcyLTEyLTMxVDEyOjAwJykudG9Mb2NhbGVTdHJpbmcoLi4uYXJncylcbi8vICcxMiAzMSwgNSBNZWlqaSwgMTI6MDA6MDAgUE0nXG5jbGFzcyBKYXBhbmVzZUhlbHBlciBleHRlbmRzIEdyZWdvcmlhbkJhc2VIZWxwZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcignamFwYW5lc2UnLCBbXG4gICAgICAgICAgICAvLyBUaGUgSmFwYW5lc2UgY2FsZW5kYXIgYHllYXJgIGlzIGp1c3QgdGhlIElTTyB5ZWFyLCBiZWNhdXNlICh1bmxpa2Ugb3RoZXJcbiAgICAgICAgICAgIC8vIElDVSBjYWxlbmRhcnMpIHRoZXJlJ3Mgbm8gb2J2aW91cyBcImRlZmF1bHQgZXJhXCIsIHdlIHVzZSB0aGUgSVNPIHllYXIuXG4gICAgICAgICAgICB7IG5hbWU6ICdyZWl3YScsIGlzb0Vwb2NoOiB7IHllYXI6IDIwMTksIG1vbnRoOiA1LCBkYXk6IDEgfSwgYW5jaG9yRXBvY2g6IHsgeWVhcjogMjAxOSwgbW9udGg6IDUsIGRheTogMSB9IH0sXG4gICAgICAgICAgICB7IG5hbWU6ICdoZWlzZWknLCBpc29FcG9jaDogeyB5ZWFyOiAxOTg5LCBtb250aDogMSwgZGF5OiA4IH0sIGFuY2hvckVwb2NoOiB7IHllYXI6IDE5ODksIG1vbnRoOiAxLCBkYXk6IDggfSB9LFxuICAgICAgICAgICAgeyBuYW1lOiAnc2hvd2EnLCBpc29FcG9jaDogeyB5ZWFyOiAxOTI2LCBtb250aDogMTIsIGRheTogMjUgfSwgYW5jaG9yRXBvY2g6IHsgeWVhcjogMTkyNiwgbW9udGg6IDEyLCBkYXk6IDI1IH0gfSxcbiAgICAgICAgICAgIHsgbmFtZTogJ3RhaXNobycsIGlzb0Vwb2NoOiB7IHllYXI6IDE5MTIsIG1vbnRoOiA3LCBkYXk6IDMwIH0sIGFuY2hvckVwb2NoOiB7IHllYXI6IDE5MTIsIG1vbnRoOiA3LCBkYXk6IDMwIH0gfSxcbiAgICAgICAgICAgIHsgbmFtZTogJ21laWppJywgaXNvRXBvY2g6IHsgeWVhcjogMTg2OCwgbW9udGg6IDksIGRheTogOCB9LCBhbmNob3JFcG9jaDogeyB5ZWFyOiAxODY4LCBtb250aDogOSwgZGF5OiA4IH0gfSxcbiAgICAgICAgICAgIHsgbmFtZTogJ2NlJywgaXNvRXBvY2g6IHsgeWVhcjogMSwgbW9udGg6IDEsIGRheTogMSB9IH0sXG4gICAgICAgICAgICB7IG5hbWU6ICdiY2UnLCByZXZlcnNlT2Y6ICdjZScgfVxuICAgICAgICBdKTtcbiAgICAgICAgdGhpcy5jYWxlbmRhcklzVnVsbmVyYWJsZVRvSnVsaWFuQnVnID0gdHJ1ZTtcbiAgICAgICAgLy8gVGhlIGxhc3QgMyBKYXBhbmVzZSBlcmFzIGNvbmZ1c2luZ2x5IHJldHVybiBvbmx5IG9uZSBjaGFyYWN0ZXIgaW4gdGhlXG4gICAgICAgIC8vIGRlZmF1bHQgXCJzaG9ydFwiIGVyYSwgc28gbmVlZCB0byB1c2UgdGhlIGxvbmcgZm9ybWF0LlxuICAgICAgICB0aGlzLmVyYUxlbmd0aCA9ICdsb25nJztcbiAgICB9XG4gICAgcmV2aXNlSW50bEVyYShjYWxlbmRhckRhdGUsIGlzb0RhdGUpIHtcbiAgICAgICAgY29uc3QgeyBlcmEsIGVyYVllYXIgfSA9IGNhbGVuZGFyRGF0ZTtcbiAgICAgICAgY29uc3QgeyB5ZWFyOiBpc29ZZWFyIH0gPSBpc29EYXRlO1xuICAgICAgICBpZiAodGhpcy5lcmFzLmZpbmQoKGUpID0+IGUubmFtZSA9PT0gZXJhKSlcbiAgICAgICAgICAgIHJldHVybiB7IGVyYSwgZXJhWWVhciB9O1xuICAgICAgICByZXR1cm4gKGlzb1llYXIgPCAxID8geyBlcmE6ICdiY2UnLCBlcmFZZWFyOiAxIC0gaXNvWWVhciB9IDogeyBlcmE6ICdjZScsIGVyYVllYXI6IGlzb1llYXIgfSk7XG4gICAgfVxufVxuY2xhc3MgQ2hpbmVzZUJhc2VIZWxwZXIgZXh0ZW5kcyBIZWxwZXJCYXNlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5jYWxlbmRhclR5cGUgPSAnbHVuaXNvbGFyJztcbiAgICAgICAgLy8gQWxsIGJ1aWx0LWluIGNhbGVuZGFycyBleGNlcHQgQ2hpbmVzZS9EYW5naSBhbmQgSGVicmV3IHVzZSBhbiBlcmFcbiAgICAgICAgdGhpcy5oYXNFcmEgPSBmYWxzZTtcbiAgICB9XG4gICAgaW5MZWFwWWVhcihjYWxlbmRhckRhdGUsIGNhY2hlKSB7XG4gICAgICAgIGNvbnN0IG1vbnRocyA9IHRoaXMuZ2V0TW9udGhMaXN0KGNhbGVuZGFyRGF0ZS55ZWFyLCBjYWNoZSk7XG4gICAgICAgIHJldHVybiBPYmplY3RFbnRyaWVzKG1vbnRocykubGVuZ3RoID09PSAxMztcbiAgICB9XG4gICAgbW9udGhzSW5ZZWFyKGNhbGVuZGFyRGF0ZSwgY2FjaGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5MZWFwWWVhcihjYWxlbmRhckRhdGUsIGNhY2hlKSA/IDEzIDogMTI7XG4gICAgfVxuICAgIG1pbmltdW1Nb250aExlbmd0aCggLyogY2FsZW5kYXJEYXRlICovKSB7XG4gICAgICAgIHJldHVybiAyOTtcbiAgICB9XG4gICAgbWF4aW11bU1vbnRoTGVuZ3RoKCAvKiBjYWxlbmRhckRhdGUgKi8pIHtcbiAgICAgICAgcmV0dXJuIDMwO1xuICAgIH1cbiAgICBnZXRNb250aExpc3QoY2FsZW5kYXJZZWFyLCBjYWNoZSkge1xuICAgICAgICBpZiAoY2FsZW5kYXJZZWFyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ01pc3NpbmcgeWVhcicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGtleSA9IEpTT04uc3RyaW5naWZ5KHsgZnVuYzogJ2dldE1vbnRoTGlzdCcsIGNhbGVuZGFyWWVhciwgaWQ6IHRoaXMuaWQgfSk7XG4gICAgICAgIGNvbnN0IGNhY2hlZCA9IGNhY2hlLmdldChrZXkpO1xuICAgICAgICBpZiAoY2FjaGVkKVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZDtcbiAgICAgICAgY29uc3QgZGF0ZVRpbWVGb3JtYXQgPSB0aGlzLmdldEZvcm1hdHRlcigpO1xuICAgICAgICBjb25zdCBnZXRDYWxlbmRhckRhdGUgPSAoaXNvWWVhciwgZGF5c1Bhc3RGZWIxKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBpc29TdHJpbmdGZWIxID0gdG9VdGNJc29EYXRlU3RyaW5nKHsgaXNvWWVhciwgaXNvTW9udGg6IDIsIGlzb0RheTogMSB9KTtcbiAgICAgICAgICAgIGNvbnN0IGxlZ2FjeURhdGUgPSBuZXcgRGF0ZShpc29TdHJpbmdGZWIxKTtcbiAgICAgICAgICAgIC8vIE5vdyBhZGQgdGhlIHJlcXVlc3RlZCBudW1iZXIgb2YgZGF5cywgd2hpY2ggbWF5IHdyYXAgdG8gdGhlIG5leHQgbW9udGguXG4gICAgICAgICAgICBsZWdhY3lEYXRlLnNldFVUQ0RhdGUoZGF5c1Bhc3RGZWIxICsgMSk7XG4gICAgICAgICAgICBjb25zdCBuZXdZZWFyR3Vlc3MgPSBkYXRlVGltZUZvcm1hdC5mb3JtYXRUb1BhcnRzKGxlZ2FjeURhdGUpO1xuICAgICAgICAgICAgY29uc3QgY2FsZW5kYXJNb250aFN0cmluZyA9IG5ld1llYXJHdWVzcy5maW5kKCh0dikgPT4gdHYudHlwZSA9PT0gJ21vbnRoJykudmFsdWU7XG4gICAgICAgICAgICBjb25zdCBjYWxlbmRhckRheSA9ICtuZXdZZWFyR3Vlc3MuZmluZCgodHYpID0+IHR2LnR5cGUgPT09ICdkYXknKS52YWx1ZTtcbiAgICAgICAgICAgIGxldCBjYWxlbmRhclllYXJUb1ZlcmlmeSA9IG5ld1llYXJHdWVzcy5maW5kKCh0dikgPT4gdHYudHlwZSA9PT0gJ3JlbGF0ZWRZZWFyJyk7XG4gICAgICAgICAgICBpZiAoY2FsZW5kYXJZZWFyVG9WZXJpZnkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGNhbGVuZGFyWWVhclRvVmVyaWZ5ID0gK2NhbGVuZGFyWWVhclRvVmVyaWZ5LnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gTm9kZSAxMiBoYXMgb3V0ZGF0ZWQgSUNVIGRhdGEgdGhhdCBsYWNrcyB0aGUgYHJlbGF0ZWRZZWFyYCBmaWVsZCBpbiB0aGVcbiAgICAgICAgICAgICAgICAvLyBvdXRwdXQgb2YgSW50bC5EYXRlVGltZUZvcm1hdC5mb3JtYXRUb1BhcnRzLlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBJbnRsLkRhdGVUaW1lRm9ybWF0LmZvcm1hdFRvUGFydHMgbGFja3MgcmVsYXRlZFllYXIgaW4gJHt0aGlzLmlkfSBjYWxlbmRhci4gVHJ5IE5vZGUgMTQrIG9yIG1vZGVybiBicm93c2Vycy5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7IGNhbGVuZGFyTW9udGhTdHJpbmcsIGNhbGVuZGFyRGF5LCBjYWxlbmRhclllYXJUb1ZlcmlmeSB9O1xuICAgICAgICB9O1xuICAgICAgICAvLyBGaXJzdCwgZmluZCBhIGRhdGUgY2xvc2UgdG8gQ2hpbmVzZSBOZXcgWWVhci4gRmViIDE3IHdpbGwgZWl0aGVyIGJlIGluXG4gICAgICAgIC8vIHRoZSBmaXJzdCBtb250aCBvciBuZWFyIHRoZSBlbmQgb2YgdGhlIGxhc3QgbW9udGggb2YgdGhlIHByZXZpb3VzIHllYXIuXG4gICAgICAgIGxldCBpc29EYXlzRGVsdGEgPSAxNztcbiAgICAgICAgbGV0IHsgY2FsZW5kYXJNb250aFN0cmluZywgY2FsZW5kYXJEYXksIGNhbGVuZGFyWWVhclRvVmVyaWZ5IH0gPSBnZXRDYWxlbmRhckRhdGUoY2FsZW5kYXJZZWFyLCBpc29EYXlzRGVsdGEpO1xuICAgICAgICAvLyBJZiB3ZSBkaWRuJ3QgZ3Vlc3MgdGhlIGZpcnN0IG1vbnRoIGNvcnJlY3RseSwgYWRkIChhbG1vc3QgaW4gc29tZSBtb250aHMpXG4gICAgICAgIC8vIGEgbHVuYXIgbW9udGhcbiAgICAgICAgaWYgKGNhbGVuZGFyTW9udGhTdHJpbmcgIT09ICcxJykge1xuICAgICAgICAgICAgaXNvRGF5c0RlbHRhICs9IDI5O1xuICAgICAgICAgICAgKHsgY2FsZW5kYXJNb250aFN0cmluZywgY2FsZW5kYXJEYXkgfSA9IGdldENhbGVuZGFyRGF0ZShjYWxlbmRhclllYXIsIGlzb0RheXNEZWx0YSkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5vdyBiYWNrIHVwIHRvIG5lYXIgdGhlIHN0YXJ0IG9mIHRoZSBmaXJzdCBtb250aCwgYnV0IG5vdCB0b28gbmVhciB0aGF0XG4gICAgICAgIC8vIG9mZi1ieS1vbmUgaXNzdWVzIG1hdHRlci5cbiAgICAgICAgaXNvRGF5c0RlbHRhIC09IGNhbGVuZGFyRGF5IC0gNTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgICAgIGxldCBtb250aEluZGV4ID0gMTtcbiAgICAgICAgbGV0IG9sZENhbGVuZGFyRGF5O1xuICAgICAgICBsZXQgb2xkTW9udGhTdHJpbmc7XG4gICAgICAgIGxldCBkb25lID0gZmFsc2U7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgICh7IGNhbGVuZGFyTW9udGhTdHJpbmcsIGNhbGVuZGFyRGF5LCBjYWxlbmRhclllYXJUb1ZlcmlmeSB9ID0gZ2V0Q2FsZW5kYXJEYXRlKGNhbGVuZGFyWWVhciwgaXNvRGF5c0RlbHRhKSk7XG4gICAgICAgICAgICBpZiAob2xkQ2FsZW5kYXJEYXkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRbb2xkTW9udGhTdHJpbmddLmRheXNJbk1vbnRoID0gb2xkQ2FsZW5kYXJEYXkgKyAzMCAtIGNhbGVuZGFyRGF5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNhbGVuZGFyWWVhclRvVmVyaWZ5ICE9PSBjYWxlbmRhclllYXIpIHtcbiAgICAgICAgICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdFtjYWxlbmRhck1vbnRoU3RyaW5nXSA9IHsgbW9udGhJbmRleDogbW9udGhJbmRleCsrIH07XG4gICAgICAgICAgICAgICAgLy8gTW92ZSB0byB0aGUgbmV4dCBtb250aC4gQmVjYXVzZSBtb250aHMgYXJlIHNvbWV0aW1lcyAyOSBkYXlzLCB0aGUgZGF5IG9mIHRoZVxuICAgICAgICAgICAgICAgIC8vIGNhbGVuZGFyIG1vbnRoIHdpbGwgbW92ZSBmb3J3YXJkIHNsb3dseSBidXQgbm90IGVub3VnaCB0byBmbGlwIG92ZXIgdG8gYSBuZXdcbiAgICAgICAgICAgICAgICAvLyBtb250aCBiZWZvcmUgdGhlIGxvb3AgZW5kcyBhdCAxMi0xMyBtb250aHMuXG4gICAgICAgICAgICAgICAgaXNvRGF5c0RlbHRhICs9IDMwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2xkQ2FsZW5kYXJEYXkgPSBjYWxlbmRhckRheTtcbiAgICAgICAgICAgIG9sZE1vbnRoU3RyaW5nID0gY2FsZW5kYXJNb250aFN0cmluZztcbiAgICAgICAgfSB3aGlsZSAoIWRvbmUpO1xuICAgICAgICByZXN1bHRbb2xkTW9udGhTdHJpbmddLmRheXNJbk1vbnRoID0gb2xkQ2FsZW5kYXJEYXkgKyAzMCAtIGNhbGVuZGFyRGF5O1xuICAgICAgICBjYWNoZS5zZXQoa2V5LCByZXN1bHQpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBlc3RpbWF0ZUlzb0RhdGUoY2FsZW5kYXJEYXRlKSB7XG4gICAgICAgIGNvbnN0IHsgeWVhciwgbW9udGggfSA9IGNhbGVuZGFyRGF0ZTtcbiAgICAgICAgcmV0dXJuIHsgeWVhciwgbW9udGg6IG1vbnRoID49IDEyID8gMTIgOiBtb250aCArIDEsIGRheTogMSB9O1xuICAgIH1cbiAgICBhZGp1c3RDYWxlbmRhckRhdGUoY2FsZW5kYXJEYXRlLCBjYWNoZSwgb3ZlcmZsb3cgPSAnY29uc3RyYWluJywgZnJvbUxlZ2FjeURhdGUgPSBmYWxzZSkge1xuICAgICAgICBsZXQgeyB5ZWFyLCBtb250aCwgbW9udGhFeHRyYSwgZGF5LCBtb250aENvZGUsIGVyYVllYXIgfSA9IGNhbGVuZGFyRGF0ZTtcbiAgICAgICAgaWYgKGZyb21MZWdhY3lEYXRlKSB7XG4gICAgICAgICAgICAvLyBMZWdhY3kgRGF0ZSBvdXRwdXQgcmV0dXJucyBhIHN0cmluZyB0aGF0J3MgYW4gaW50ZWdlciB3aXRoIGFuIG9wdGlvbmFsXG4gICAgICAgICAgICAvLyBcImJpc1wiIHN1ZmZpeCB1c2VkIG9ubHkgYnkgdGhlIENoaW5lc2UvRGFuZ2kgY2FsZW5kYXIgdG8gaW5kaWNhdGUgYSBsZWFwXG4gICAgICAgICAgICAvLyBtb250aC4gQmVsb3cgd2UnbGwgbm9ybWFsaXplIHRoZSBvdXRwdXQuXG4gICAgICAgICAgICB5ZWFyID0gZXJhWWVhcjtcbiAgICAgICAgICAgIGlmIChtb250aEV4dHJhICYmIG1vbnRoRXh0cmEgIT09ICdiaXMnKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBVbmV4cGVjdGVkIGxlYXAgbW9udGggc3VmZml4OiAke21vbnRoRXh0cmF9YCk7XG4gICAgICAgICAgICBjb25zdCBtb250aENvZGUgPSBidWlsZE1vbnRoQ29kZShtb250aCwgbW9udGhFeHRyYSAhPT0gdW5kZWZpbmVkKTtcbiAgICAgICAgICAgIGNvbnN0IG1vbnRoU3RyaW5nID0gYCR7bW9udGh9JHttb250aEV4dHJhIHx8ICcnfWA7XG4gICAgICAgICAgICBjb25zdCBtb250aHMgPSB0aGlzLmdldE1vbnRoTGlzdCh5ZWFyLCBjYWNoZSk7XG4gICAgICAgICAgICBjb25zdCBtb250aEluZm8gPSBtb250aHNbbW9udGhTdHJpbmddO1xuICAgICAgICAgICAgaWYgKG1vbnRoSW5mbyA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBVbm1hdGNoZWQgbW9udGggJHttb250aFN0cmluZ30gaW4gQ2hpbmVzZSB5ZWFyICR7eWVhcn1gKTtcbiAgICAgICAgICAgIG1vbnRoID0gbW9udGhJbmZvLm1vbnRoSW5kZXg7XG4gICAgICAgICAgICByZXR1cm4geyB5ZWFyOiB5ZWFyLCBtb250aCwgZGF5OiBkYXksIGVyYTogdW5kZWZpbmVkLCBlcmFZZWFyLCBtb250aENvZGUgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIFdoZW4gY2FsbGVkIHdpdGhvdXQgaW5wdXQgY29taW5nIGZyb20gbGVnYWN5IERhdGUgb3V0cHV0LFxuICAgICAgICAgICAgLy8gc2ltcGx5IGVuc3VyZSB0aGF0IGFsbCBmaWVsZHMgYXJlIHByZXNlbnQuXG4gICAgICAgICAgICB0aGlzLnZhbGlkYXRlQ2FsZW5kYXJEYXRlKGNhbGVuZGFyRGF0ZSk7XG4gICAgICAgICAgICBpZiAoeWVhciA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIHllYXIgPSBlcmFZZWFyO1xuICAgICAgICAgICAgaWYgKGVyYVllYXIgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICBlcmFZZWFyID0geWVhcjtcbiAgICAgICAgICAgIGlmIChtb250aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbW9udGhzID0gdGhpcy5nZXRNb250aExpc3QoeWVhciwgY2FjaGUpO1xuICAgICAgICAgICAgICAgIGxldCBudW1iZXJQYXJ0ID0gbW9udGhDb2RlLnJlcGxhY2UoJ0wnLCAnYmlzJykuc2xpY2UoMSk7XG4gICAgICAgICAgICAgICAgaWYgKG51bWJlclBhcnRbMF0gPT09ICcwJylcbiAgICAgICAgICAgICAgICAgICAgbnVtYmVyUGFydCA9IG51bWJlclBhcnQuc2xpY2UoMSk7XG4gICAgICAgICAgICAgICAgbGV0IG1vbnRoSW5mbyA9IG1vbnRoc1tudW1iZXJQYXJ0XTtcbiAgICAgICAgICAgICAgICBtb250aCA9IG1vbnRoSW5mbyAmJiBtb250aEluZm8ubW9udGhJbmRleDtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGlzIGxlYXAgbW9udGggaXNuJ3QgcHJlc2VudCBpbiB0aGlzIHllYXIsIGNvbnN0cmFpbiBkb3duIHRvIHRoZSBsYXN0IGRheSBvZiB0aGUgcHJldmlvdXMgbW9udGguXG4gICAgICAgICAgICAgICAgaWYgKG1vbnRoID09PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgbW9udGhDb2RlLmVuZHNXaXRoKCdMJykgJiZcbiAgICAgICAgICAgICAgICAgICAgIUFycmF5SW5jbHVkZXMuY2FsbChbJ00wMUwnLCAnTTEyTCcsICdNMTNMJ10sIG1vbnRoQ29kZSkgJiZcbiAgICAgICAgICAgICAgICAgICAgb3ZlcmZsb3cgPT09ICdjb25zdHJhaW4nKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB3aXRob3V0TUwgPSBtb250aENvZGUuc2xpY2UoMSwgLTEpO1xuICAgICAgICAgICAgICAgICAgICBpZiAod2l0aG91dE1MWzBdID09PSAnMCcpXG4gICAgICAgICAgICAgICAgICAgICAgICB3aXRob3V0TUwgPSB3aXRob3V0TUwuc2xpY2UoMSk7XG4gICAgICAgICAgICAgICAgICAgIG1vbnRoSW5mbyA9IG1vbnRoc1t3aXRob3V0TUxdO1xuICAgICAgICAgICAgICAgICAgICBpZiAobW9udGhJbmZvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAoeyBkYXlzSW5Nb250aDogZGF5LCBtb250aEluZGV4OiBtb250aCB9ID0gbW9udGhJbmZvKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vbnRoQ29kZSA9IGJ1aWxkTW9udGhDb2RlKHdpdGhvdXRNTCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG1vbnRoID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYFVubWF0Y2hlZCBtb250aCAke21vbnRoQ29kZX0gaW4gQ2hpbmVzZSB5ZWFyICR7eWVhcn1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChtb250aENvZGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1vbnRocyA9IHRoaXMuZ2V0TW9udGhMaXN0KHllYXIsIGNhY2hlKTtcbiAgICAgICAgICAgICAgICBjb25zdCBtb250aEVudHJpZXMgPSBPYmplY3RFbnRyaWVzKG1vbnRocyk7XG4gICAgICAgICAgICAgICAgY29uc3QgbGFyZ2VzdE1vbnRoID0gbW9udGhFbnRyaWVzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBpZiAob3ZlcmZsb3cgPT09ICdyZWplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgIFJlamVjdFRvUmFuZ2UobW9udGgsIDEsIGxhcmdlc3RNb250aCk7XG4gICAgICAgICAgICAgICAgICAgIFJlamVjdFRvUmFuZ2UoZGF5LCAxLCB0aGlzLm1heGltdW1Nb250aExlbmd0aCgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG1vbnRoID0gQ29uc3RyYWluVG9SYW5nZShtb250aCwgMSwgbGFyZ2VzdE1vbnRoKTtcbiAgICAgICAgICAgICAgICAgICAgZGF5ID0gQ29uc3RyYWluVG9SYW5nZShkYXksIDEsIHRoaXMubWF4aW11bU1vbnRoTGVuZ3RoKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBtYXRjaGluZ01vbnRoRW50cnkgPSBtb250aEVudHJpZXMuZmluZCgoWywgdl0pID0+IHYubW9udGhJbmRleCA9PT0gbW9udGgpO1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaGluZ01vbnRoRW50cnkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgSW52YWxpZCBtb250aCAke21vbnRofSBpbiBDaGluZXNlIHllYXIgJHt5ZWFyfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtb250aENvZGUgPSBidWlsZE1vbnRoQ29kZShtYXRjaGluZ01vbnRoRW50cnlbMF0ucmVwbGFjZSgnYmlzJywgJycpLCBtYXRjaGluZ01vbnRoRW50cnlbMF0uaW5kZXhPZignYmlzJykgIT09IC0xKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEJvdGggbW9udGggYW5kIG1vbnRoQ29kZSBhcmUgcHJlc2VudC4gTWFrZSBzdXJlIHRoZXkgZG9uJ3QgY29uZmxpY3QuXG4gICAgICAgICAgICAgICAgY29uc3QgbW9udGhzID0gdGhpcy5nZXRNb250aExpc3QoeWVhciwgY2FjaGUpO1xuICAgICAgICAgICAgICAgIGxldCBudW1iZXJQYXJ0ID0gbW9udGhDb2RlLnJlcGxhY2UoJ0wnLCAnYmlzJykuc2xpY2UoMSk7XG4gICAgICAgICAgICAgICAgaWYgKG51bWJlclBhcnRbMF0gPT09ICcwJylcbiAgICAgICAgICAgICAgICAgICAgbnVtYmVyUGFydCA9IG51bWJlclBhcnQuc2xpY2UoMSk7XG4gICAgICAgICAgICAgICAgY29uc3QgbW9udGhJbmZvID0gbW9udGhzW251bWJlclBhcnRdO1xuICAgICAgICAgICAgICAgIGlmICghbW9udGhJbmZvKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgVW5tYXRjaGVkIG1vbnRoQ29kZSAke21vbnRoQ29kZX0gaW4gQ2hpbmVzZSB5ZWFyICR7eWVhcn1gKTtcbiAgICAgICAgICAgICAgICBpZiAobW9udGggIT09IG1vbnRoSW5mby5tb250aEluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBtb250aENvZGUgJHttb250aENvZGV9IGRvZXNuJ3QgY29ycmVzcG9uZCB0byBtb250aCAke21vbnRofSBpbiBDaGluZXNlIHllYXIgJHt5ZWFyfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgLi4uY2FsZW5kYXJEYXRlLFxuICAgICAgICAgICAgICAgIHllYXI6IHllYXIsXG4gICAgICAgICAgICAgICAgZXJhWWVhcixcbiAgICAgICAgICAgICAgICBtb250aCxcbiAgICAgICAgICAgICAgICBtb250aENvZGU6IG1vbnRoQ29kZSxcbiAgICAgICAgICAgICAgICBkYXk6IGRheVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmNsYXNzIENoaW5lc2VIZWxwZXIgZXh0ZW5kcyBDaGluZXNlQmFzZUhlbHBlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuaWQgPSAnY2hpbmVzZSc7XG4gICAgfVxufVxuLy8gRGFuZ2kgKEtvcmVhbikgY2FsZW5kYXIgaGFzIHNhbWUgaW1wbGVtZW50YXRpb24gYXMgQ2hpbmVzZVxuY2xhc3MgRGFuZ2lIZWxwZXIgZXh0ZW5kcyBDaGluZXNlQmFzZUhlbHBlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuaWQgPSAnZGFuZ2knO1xuICAgIH1cbn1cbi8qKlxuICogQ29tbW9uIGltcGxlbWVudGF0aW9uIG9mIGFsbCBub24tSVNPIGNhbGVuZGFycy5cbiAqIFBlci1jYWxlbmRhciBpZCBhbmQgbG9naWMgbGl2ZSBpbiBgaWRgIGFuZCBgaGVscGVyYCBwcm9wZXJ0aWVzIGF0dGFjaGVkIGxhdGVyLlxuICogVGhpcyBzcGxpdCBhbGxvd2VkIGFuIGVhc3kgc2VwYXJhdGlvbiBiZXR3ZWVuIGNvZGUgdGhhdCB3YXMgc2ltaWxhciBiZXR3ZWVuXG4gKiBJU08gYW5kIG5vbi1JU08gaW1wbGVtZW50YXRpb25zIHZzLiBjb2RlIHRoYXQgd2FzIHZlcnkgZGlmZmVyZW50LlxuICovXG5jb25zdCBub25Jc29JbXBsID0ge1xuICAgIC8vIGBoZWxwZXJgIGlzIGFkZGVkIHdoZW4gdGhpcyBvYmplY3QgaXMgc3ByZWFkIGludG8gZWFjaCBjYWxlbmRhcidzXG4gICAgLy8gaW1wbGVtZW50YXRpb25cbiAgICBoZWxwZXI6IHVuZGVmaW5lZCxcbiAgICBkYXRlRnJvbUZpZWxkcyhmaWVsZHNQYXJhbSwgb3B0aW9ucywgY2FsZW5kYXIpIHtcbiAgICAgICAgY29uc3Qgb3ZlcmZsb3cgPSBUb1RlbXBvcmFsT3ZlcmZsb3cob3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IGNhY2hlID0gbmV3IE9uZU9iamVjdENhY2hlKCk7XG4gICAgICAgIC8vIEludGVudGlvbmFsbHkgYWxwaGFiZXRpY2FsXG4gICAgICAgIGNvbnN0IGZpZWxkcyA9IFByZXBhcmVUZW1wb3JhbEZpZWxkcyhmaWVsZHNQYXJhbSwgW1xuICAgICAgICAgICAgWydkYXknXSxcbiAgICAgICAgICAgIFsnZXJhJywgdW5kZWZpbmVkXSxcbiAgICAgICAgICAgIFsnZXJhWWVhcicsIHVuZGVmaW5lZF0sXG4gICAgICAgICAgICBbJ21vbnRoJywgdW5kZWZpbmVkXSxcbiAgICAgICAgICAgIFsnbW9udGhDb2RlJywgdW5kZWZpbmVkXSxcbiAgICAgICAgICAgIFsneWVhcicsIHVuZGVmaW5lZF1cbiAgICAgICAgXSk7XG4gICAgICAgIGNvbnN0IHsgeWVhciwgbW9udGgsIGRheSB9ID0gdGhpcy5oZWxwZXIuY2FsZW5kYXJUb0lzb0RhdGUoZmllbGRzLCBvdmVyZmxvdywgY2FjaGUpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBDcmVhdGVUZW1wb3JhbERhdGUoeWVhciwgbW9udGgsIGRheSwgY2FsZW5kYXIpO1xuICAgICAgICBjYWNoZS5zZXRPYmplY3QocmVzdWx0KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuICAgIHllYXJNb250aEZyb21GaWVsZHMoZmllbGRzUGFyYW0sIG9wdGlvbnMsIGNhbGVuZGFyKSB7XG4gICAgICAgIGNvbnN0IG92ZXJmbG93ID0gVG9UZW1wb3JhbE92ZXJmbG93KG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBjYWNoZSA9IG5ldyBPbmVPYmplY3RDYWNoZSgpO1xuICAgICAgICAvLyBJbnRlbnRpb25hbGx5IGFscGhhYmV0aWNhbFxuICAgICAgICBjb25zdCBmaWVsZHMgPSBQcmVwYXJlVGVtcG9yYWxGaWVsZHMoZmllbGRzUGFyYW0sIFtcbiAgICAgICAgICAgIFsnZXJhJywgdW5kZWZpbmVkXSxcbiAgICAgICAgICAgIFsnZXJhWWVhcicsIHVuZGVmaW5lZF0sXG4gICAgICAgICAgICBbJ21vbnRoJywgdW5kZWZpbmVkXSxcbiAgICAgICAgICAgIFsnbW9udGhDb2RlJywgdW5kZWZpbmVkXSxcbiAgICAgICAgICAgIFsneWVhcicsIHVuZGVmaW5lZF1cbiAgICAgICAgXSk7XG4gICAgICAgIGNvbnN0IHsgeWVhciwgbW9udGgsIGRheSB9ID0gdGhpcy5oZWxwZXIuY2FsZW5kYXJUb0lzb0RhdGUoeyAuLi5maWVsZHMsIGRheTogMSB9LCBvdmVyZmxvdywgY2FjaGUpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBDcmVhdGVUZW1wb3JhbFllYXJNb250aCh5ZWFyLCBtb250aCwgY2FsZW5kYXIsIC8qIHJlZmVyZW5jZUlTT0RheSA9ICovIGRheSk7XG4gICAgICAgIGNhY2hlLnNldE9iamVjdChyZXN1bHQpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG4gICAgbW9udGhEYXlGcm9tRmllbGRzKGZpZWxkc1BhcmFtLCBvcHRpb25zLCBjYWxlbmRhcikge1xuICAgICAgICBjb25zdCBvdmVyZmxvdyA9IFRvVGVtcG9yYWxPdmVyZmxvdyhvcHRpb25zKTtcbiAgICAgICAgLy8gQWxsIGJ1aWx0LWluIGNhbGVuZGFycyByZXF1aXJlIGBkYXlgLCBidXQgc29tZSBhbGxvdyBvdGhlciBmaWVsZHMgdG8gYmVcbiAgICAgICAgLy8gc3Vic3RpdHV0ZWQgZm9yIGBtb250aGAuIEFuZCBmb3IgbHVuaXNvbGFyIGNhbGVuZGFycywgZWl0aGVyIGBtb250aENvZGVgXG4gICAgICAgIC8vIG9yIGB5ZWFyYCBtdXN0IGJlIHByb3ZpZGVkIGJlY2F1c2UgYG1vbnRoYCBpcyBhbWJpZ3VvdXMgd2l0aG91dCBhIHllYXIgb3JcbiAgICAgICAgLy8gYSBjb2RlLlxuICAgICAgICBjb25zdCBjYWNoZSA9IG5ldyBPbmVPYmplY3RDYWNoZSgpO1xuICAgICAgICBjb25zdCBmaWVsZHMgPSBQcmVwYXJlVGVtcG9yYWxGaWVsZHMoZmllbGRzUGFyYW0sIFtcbiAgICAgICAgICAgIFsnZGF5J10sXG4gICAgICAgICAgICBbJ2VyYScsIHVuZGVmaW5lZF0sXG4gICAgICAgICAgICBbJ2VyYVllYXInLCB1bmRlZmluZWRdLFxuICAgICAgICAgICAgWydtb250aCcsIHVuZGVmaW5lZF0sXG4gICAgICAgICAgICBbJ21vbnRoQ29kZScsIHVuZGVmaW5lZF0sXG4gICAgICAgICAgICBbJ3llYXInLCB1bmRlZmluZWRdXG4gICAgICAgIF0pO1xuICAgICAgICBjb25zdCB7IHllYXIsIG1vbnRoLCBkYXkgfSA9IHRoaXMuaGVscGVyLm1vbnRoRGF5RnJvbUZpZWxkcyhmaWVsZHMsIG92ZXJmbG93LCBjYWNoZSk7XG4gICAgICAgIC8vIGB5ZWFyYCBpcyBhIHJlZmVyZW5jZSB5ZWFyIHdoZXJlIHRoaXMgbW9udGgvZGF5IGV4aXN0cyBpbiB0aGlzIGNhbGVuZGFyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IENyZWF0ZVRlbXBvcmFsTW9udGhEYXkobW9udGgsIGRheSwgY2FsZW5kYXIsIC8qIHJlZmVyZW5jZUlTT1llYXIgPSAqLyB5ZWFyKTtcbiAgICAgICAgY2FjaGUuc2V0T2JqZWN0KHJlc3VsdCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcbiAgICBmaWVsZHMoZmllbGRzUGFyYW0pIHtcbiAgICAgICAgbGV0IGZpZWxkcyA9IGZpZWxkc1BhcmFtO1xuICAgICAgICBpZiAoQXJyYXlJbmNsdWRlcy5jYWxsKGZpZWxkcywgJ3llYXInKSlcbiAgICAgICAgICAgIGZpZWxkcyA9IFsuLi5maWVsZHMsICdlcmEnLCAnZXJhWWVhciddO1xuICAgICAgICByZXR1cm4gZmllbGRzO1xuICAgIH0sXG4gICAgbWVyZ2VGaWVsZHMoZmllbGRzLCBhZGRpdGlvbmFsRmllbGRzKSB7XG4gICAgICAgIGNvbnN0IGZpZWxkc0NvcHkgPSB7IC4uLmZpZWxkcyB9O1xuICAgICAgICBjb25zdCBhZGRpdGlvbmFsRmllbGRzQ29weSA9IHsgLi4uYWRkaXRpb25hbEZpZWxkcyB9O1xuICAgICAgICAvLyBlcmEgYW5kIGVyYVllYXIgYXJlIGludGVudGlvbmFsbHkgdW51c2VkXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICAgICAgY29uc3QgeyBtb250aCwgbW9udGhDb2RlLCB5ZWFyLCBlcmEsIGVyYVllYXIsIC4uLm9yaWdpbmFsIH0gPSBmaWVsZHNDb3B5O1xuICAgICAgICBjb25zdCB7IG1vbnRoOiBuZXdNb250aCwgbW9udGhDb2RlOiBuZXdNb250aENvZGUsIHllYXI6IG5ld1llYXIsIGVyYTogbmV3RXJhLCBlcmFZZWFyOiBuZXdFcmFZZWFyIH0gPSBhZGRpdGlvbmFsRmllbGRzQ29weTtcbiAgICAgICAgaWYgKG5ld01vbnRoID09PSB1bmRlZmluZWQgJiYgbmV3TW9udGhDb2RlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG9yaWdpbmFsLm1vbnRoID0gbW9udGg7XG4gICAgICAgICAgICBvcmlnaW5hbC5tb250aENvZGUgPSBtb250aENvZGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5ld1llYXIgPT09IHVuZGVmaW5lZCAmJiBuZXdFcmEgPT09IHVuZGVmaW5lZCAmJiBuZXdFcmFZZWFyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIE9ubHkgYHllYXJgIGlzIG5lZWRlZC4gV2UgZG9uJ3Qgc2V0IGVyYSBhbmQgZXJhWWVhciBiZWNhdXNlIGl0J3NcbiAgICAgICAgICAgIC8vIHBvc3NpYmxlIHRvIGNyZWF0ZSBhIGNvbmZsaWN0IGZvciBlcmFzIHRoYXQgc3RhcnQgb3IgZW5kIG1pZC15ZWFyLiBTZWVcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLXRlbXBvcmFsL2lzc3Vlcy8xNzg0LlxuICAgICAgICAgICAgb3JpZ2luYWwueWVhciA9IHllYXI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgLi4ub3JpZ2luYWwsIC4uLmFkZGl0aW9uYWxGaWVsZHNDb3B5IH07XG4gICAgfSxcbiAgICBkYXRlQWRkKGRhdGUsIHllYXJzLCBtb250aHMsIHdlZWtzLCBkYXlzLCBvdmVyZmxvdywgY2FsZW5kYXIpIHtcbiAgICAgICAgY29uc3QgY2FjaGUgPSBPbmVPYmplY3RDYWNoZS5nZXRDYWNoZUZvck9iamVjdChkYXRlKTtcbiAgICAgICAgY29uc3QgY2FsZW5kYXJEYXRlID0gdGhpcy5oZWxwZXIudGVtcG9yYWxUb0NhbGVuZGFyRGF0ZShkYXRlLCBjYWNoZSk7XG4gICAgICAgIGNvbnN0IGFkZGVkID0gdGhpcy5oZWxwZXIuYWRkQ2FsZW5kYXIoY2FsZW5kYXJEYXRlLCB7IHllYXJzLCBtb250aHMsIHdlZWtzLCBkYXlzIH0sIG92ZXJmbG93LCBjYWNoZSk7XG4gICAgICAgIGNvbnN0IGlzb0FkZGVkID0gdGhpcy5oZWxwZXIuY2FsZW5kYXJUb0lzb0RhdGUoYWRkZWQsICdjb25zdHJhaW4nLCBjYWNoZSk7XG4gICAgICAgIGNvbnN0IHsgeWVhciwgbW9udGgsIGRheSB9ID0gaXNvQWRkZWQ7XG4gICAgICAgIGNvbnN0IG5ld1RlbXBvcmFsT2JqZWN0ID0gQ3JlYXRlVGVtcG9yYWxEYXRlKHllYXIsIG1vbnRoLCBkYXksIGNhbGVuZGFyKTtcbiAgICAgICAgLy8gVGhlIG5ldyBvYmplY3QncyBjYWNoZSBzdGFydHMgd2l0aCB0aGUgY2FjaGUgb2YgdGhlIG9sZCBvYmplY3RcbiAgICAgICAgY29uc3QgbmV3Q2FjaGUgPSBuZXcgT25lT2JqZWN0Q2FjaGUoY2FjaGUpO1xuICAgICAgICBuZXdDYWNoZS5zZXRPYmplY3QobmV3VGVtcG9yYWxPYmplY3QpO1xuICAgICAgICByZXR1cm4gbmV3VGVtcG9yYWxPYmplY3Q7XG4gICAgfSxcbiAgICBkYXRlVW50aWwob25lLCB0d28sIGxhcmdlc3RVbml0KSB7XG4gICAgICAgIGNvbnN0IGNhY2hlT25lID0gT25lT2JqZWN0Q2FjaGUuZ2V0Q2FjaGVGb3JPYmplY3Qob25lKTtcbiAgICAgICAgY29uc3QgY2FjaGVUd28gPSBPbmVPYmplY3RDYWNoZS5nZXRDYWNoZUZvck9iamVjdCh0d28pO1xuICAgICAgICBjb25zdCBjYWxlbmRhck9uZSA9IHRoaXMuaGVscGVyLnRlbXBvcmFsVG9DYWxlbmRhckRhdGUob25lLCBjYWNoZU9uZSk7XG4gICAgICAgIGNvbnN0IGNhbGVuZGFyVHdvID0gdGhpcy5oZWxwZXIudGVtcG9yYWxUb0NhbGVuZGFyRGF0ZSh0d28sIGNhY2hlVHdvKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5oZWxwZXIudW50aWxDYWxlbmRhcihjYWxlbmRhck9uZSwgY2FsZW5kYXJUd28sIGxhcmdlc3RVbml0LCBjYWNoZU9uZSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcbiAgICB5ZWFyKGRhdGUpIHtcbiAgICAgICAgY29uc3QgY2FjaGUgPSBPbmVPYmplY3RDYWNoZS5nZXRDYWNoZUZvck9iamVjdChkYXRlKTtcbiAgICAgICAgY29uc3QgY2FsZW5kYXJEYXRlID0gdGhpcy5oZWxwZXIudGVtcG9yYWxUb0NhbGVuZGFyRGF0ZShkYXRlLCBjYWNoZSk7XG4gICAgICAgIHJldHVybiBjYWxlbmRhckRhdGUueWVhcjtcbiAgICB9LFxuICAgIG1vbnRoKGRhdGUpIHtcbiAgICAgICAgY29uc3QgY2FjaGUgPSBPbmVPYmplY3RDYWNoZS5nZXRDYWNoZUZvck9iamVjdChkYXRlKTtcbiAgICAgICAgY29uc3QgY2FsZW5kYXJEYXRlID0gdGhpcy5oZWxwZXIudGVtcG9yYWxUb0NhbGVuZGFyRGF0ZShkYXRlLCBjYWNoZSk7XG4gICAgICAgIHJldHVybiBjYWxlbmRhckRhdGUubW9udGg7XG4gICAgfSxcbiAgICBkYXkoZGF0ZSkge1xuICAgICAgICBjb25zdCBjYWNoZSA9IE9uZU9iamVjdENhY2hlLmdldENhY2hlRm9yT2JqZWN0KGRhdGUpO1xuICAgICAgICBjb25zdCBjYWxlbmRhckRhdGUgPSB0aGlzLmhlbHBlci50ZW1wb3JhbFRvQ2FsZW5kYXJEYXRlKGRhdGUsIGNhY2hlKTtcbiAgICAgICAgcmV0dXJuIGNhbGVuZGFyRGF0ZS5kYXk7XG4gICAgfSxcbiAgICBlcmEoZGF0ZSkge1xuICAgICAgICBpZiAoIXRoaXMuaGVscGVyLmhhc0VyYSlcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IGNhY2hlID0gT25lT2JqZWN0Q2FjaGUuZ2V0Q2FjaGVGb3JPYmplY3QoZGF0ZSk7XG4gICAgICAgIGNvbnN0IGNhbGVuZGFyRGF0ZSA9IHRoaXMuaGVscGVyLnRlbXBvcmFsVG9DYWxlbmRhckRhdGUoZGF0ZSwgY2FjaGUpO1xuICAgICAgICByZXR1cm4gY2FsZW5kYXJEYXRlLmVyYTtcbiAgICB9LFxuICAgIGVyYVllYXIoZGF0ZSkge1xuICAgICAgICBpZiAoIXRoaXMuaGVscGVyLmhhc0VyYSlcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IGNhY2hlID0gT25lT2JqZWN0Q2FjaGUuZ2V0Q2FjaGVGb3JPYmplY3QoZGF0ZSk7XG4gICAgICAgIGNvbnN0IGNhbGVuZGFyRGF0ZSA9IHRoaXMuaGVscGVyLnRlbXBvcmFsVG9DYWxlbmRhckRhdGUoZGF0ZSwgY2FjaGUpO1xuICAgICAgICByZXR1cm4gY2FsZW5kYXJEYXRlLmVyYVllYXI7XG4gICAgfSxcbiAgICBtb250aENvZGUoZGF0ZSkge1xuICAgICAgICBjb25zdCBjYWNoZSA9IE9uZU9iamVjdENhY2hlLmdldENhY2hlRm9yT2JqZWN0KGRhdGUpO1xuICAgICAgICBjb25zdCBjYWxlbmRhckRhdGUgPSB0aGlzLmhlbHBlci50ZW1wb3JhbFRvQ2FsZW5kYXJEYXRlKGRhdGUsIGNhY2hlKTtcbiAgICAgICAgcmV0dXJuIGNhbGVuZGFyRGF0ZS5tb250aENvZGU7XG4gICAgfSxcbiAgICBkYXlPZldlZWsoZGF0ZSkge1xuICAgICAgICByZXR1cm4gaW1wbFsnaXNvODYwMSddLmRheU9mV2VlayhkYXRlKTtcbiAgICB9LFxuICAgIGRheU9mWWVhcihkYXRlKSB7XG4gICAgICAgIGNvbnN0IGNhY2hlID0gT25lT2JqZWN0Q2FjaGUuZ2V0Q2FjaGVGb3JPYmplY3QoZGF0ZSk7XG4gICAgICAgIGNvbnN0IGNhbGVuZGFyRGF0ZSA9IHRoaXMuaGVscGVyLmlzb1RvQ2FsZW5kYXJEYXRlKGRhdGUsIGNhY2hlKTtcbiAgICAgICAgY29uc3Qgc3RhcnRPZlllYXIgPSB0aGlzLmhlbHBlci5zdGFydE9mQ2FsZW5kYXJZZWFyKGNhbGVuZGFyRGF0ZSk7XG4gICAgICAgIGNvbnN0IGRpZmZEYXlzID0gdGhpcy5oZWxwZXIuY2FsZW5kYXJEYXlzVW50aWwoc3RhcnRPZlllYXIsIGNhbGVuZGFyRGF0ZSwgY2FjaGUpO1xuICAgICAgICByZXR1cm4gZGlmZkRheXMgKyAxO1xuICAgIH0sXG4gICAgd2Vla09mWWVhcihkYXRlKSB7XG4gICAgICAgIHJldHVybiBpbXBsWydpc284NjAxJ10ud2Vla09mWWVhcihkYXRlKTtcbiAgICB9LFxuICAgIGRheXNJbldlZWsoZGF0ZSkge1xuICAgICAgICByZXR1cm4gaW1wbFsnaXNvODYwMSddLmRheXNJbldlZWsoZGF0ZSk7XG4gICAgfSxcbiAgICBkYXlzSW5Nb250aChkYXRlKSB7XG4gICAgICAgIGNvbnN0IGNhY2hlID0gT25lT2JqZWN0Q2FjaGUuZ2V0Q2FjaGVGb3JPYmplY3QoZGF0ZSk7XG4gICAgICAgIGNvbnN0IGNhbGVuZGFyRGF0ZSA9IHRoaXMuaGVscGVyLnRlbXBvcmFsVG9DYWxlbmRhckRhdGUoZGF0ZSwgY2FjaGUpO1xuICAgICAgICAvLyBFYXN5IGNhc2U6IGlmIHRoZSBoZWxwZXIga25vd3MgdGhlIGxlbmd0aCB3aXRob3V0IGFueSBoZWF2eSBjYWxjdWxhdGlvbi5cbiAgICAgICAgY29uc3QgbWF4ID0gdGhpcy5oZWxwZXIubWF4aW11bU1vbnRoTGVuZ3RoKGNhbGVuZGFyRGF0ZSk7XG4gICAgICAgIGNvbnN0IG1pbiA9IHRoaXMuaGVscGVyLm1pbmltdW1Nb250aExlbmd0aChjYWxlbmRhckRhdGUpO1xuICAgICAgICBpZiAobWF4ID09PSBtaW4pXG4gICAgICAgICAgICByZXR1cm4gbWF4O1xuICAgICAgICAvLyBUaGUgaGFyZGVyIGNhc2UgaXMgd2hlcmUgbW9udGhzIHZhcnkgZXZlcnkgeWVhciwgZS5nLiBpc2xhbWljIGNhbGVuZGFycy5cbiAgICAgICAgLy8gRmluZCB0aGUgYW5zd2VyIGJ5IGNhbGN1bGF0aW5nIHRoZSBkaWZmZXJlbmNlIGluIGRheXMgYmV0d2VlbiB0aGUgZmlyc3RcbiAgICAgICAgLy8gZGF5IG9mIHRoZSBjdXJyZW50IG1vbnRoIGFuZCB0aGUgZmlyc3QgZGF5IG9mIHRoZSBuZXh0IG1vbnRoLlxuICAgICAgICBjb25zdCBzdGFydE9mTW9udGhDYWxlbmRhciA9IHRoaXMuaGVscGVyLnN0YXJ0T2ZDYWxlbmRhck1vbnRoKGNhbGVuZGFyRGF0ZSk7XG4gICAgICAgIGNvbnN0IHN0YXJ0T2ZOZXh0TW9udGhDYWxlbmRhciA9IHRoaXMuaGVscGVyLmFkZE1vbnRoc0NhbGVuZGFyKHN0YXJ0T2ZNb250aENhbGVuZGFyLCAxLCAnY29uc3RyYWluJywgY2FjaGUpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLmhlbHBlci5jYWxlbmRhckRheXNVbnRpbChzdGFydE9mTW9udGhDYWxlbmRhciwgc3RhcnRPZk5leHRNb250aENhbGVuZGFyLCBjYWNoZSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcbiAgICBkYXlzSW5ZZWFyKGRhdGVQYXJhbSkge1xuICAgICAgICBsZXQgZGF0ZSA9IGRhdGVQYXJhbTtcbiAgICAgICAgaWYgKCFIYXNTbG90KGRhdGUsIElTT19ZRUFSKSlcbiAgICAgICAgICAgIGRhdGUgPSBUb1RlbXBvcmFsRGF0ZShkYXRlKTtcbiAgICAgICAgY29uc3QgY2FjaGUgPSBPbmVPYmplY3RDYWNoZS5nZXRDYWNoZUZvck9iamVjdChkYXRlKTtcbiAgICAgICAgY29uc3QgY2FsZW5kYXJEYXRlID0gdGhpcy5oZWxwZXIudGVtcG9yYWxUb0NhbGVuZGFyRGF0ZShkYXRlLCBjYWNoZSk7XG4gICAgICAgIGNvbnN0IHN0YXJ0T2ZZZWFyQ2FsZW5kYXIgPSB0aGlzLmhlbHBlci5zdGFydE9mQ2FsZW5kYXJZZWFyKGNhbGVuZGFyRGF0ZSk7XG4gICAgICAgIGNvbnN0IHN0YXJ0T2ZOZXh0WWVhckNhbGVuZGFyID0gdGhpcy5oZWxwZXIuYWRkQ2FsZW5kYXIoc3RhcnRPZlllYXJDYWxlbmRhciwgeyB5ZWFyczogMSB9LCAnY29uc3RyYWluJywgY2FjaGUpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLmhlbHBlci5jYWxlbmRhckRheXNVbnRpbChzdGFydE9mWWVhckNhbGVuZGFyLCBzdGFydE9mTmV4dFllYXJDYWxlbmRhciwgY2FjaGUpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG4gICAgbW9udGhzSW5ZZWFyKGRhdGUpIHtcbiAgICAgICAgY29uc3QgY2FjaGUgPSBPbmVPYmplY3RDYWNoZS5nZXRDYWNoZUZvck9iamVjdChkYXRlKTtcbiAgICAgICAgY29uc3QgY2FsZW5kYXJEYXRlID0gdGhpcy5oZWxwZXIudGVtcG9yYWxUb0NhbGVuZGFyRGF0ZShkYXRlLCBjYWNoZSk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuaGVscGVyLm1vbnRoc0luWWVhcihjYWxlbmRhckRhdGUsIGNhY2hlKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuICAgIGluTGVhcFllYXIoZGF0ZVBhcmFtKSB7XG4gICAgICAgIGxldCBkYXRlID0gZGF0ZVBhcmFtO1xuICAgICAgICBpZiAoIUhhc1Nsb3QoZGF0ZSwgSVNPX1lFQVIpKVxuICAgICAgICAgICAgZGF0ZSA9IFRvVGVtcG9yYWxEYXRlKGRhdGUpO1xuICAgICAgICBjb25zdCBjYWNoZSA9IE9uZU9iamVjdENhY2hlLmdldENhY2hlRm9yT2JqZWN0KGRhdGUpO1xuICAgICAgICBjb25zdCBjYWxlbmRhckRhdGUgPSB0aGlzLmhlbHBlci50ZW1wb3JhbFRvQ2FsZW5kYXJEYXRlKGRhdGUsIGNhY2hlKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5oZWxwZXIuaW5MZWFwWWVhcihjYWxlbmRhckRhdGUsIGNhY2hlKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59O1xuZm9yIChjb25zdCBIZWxwZXIgb2YgW1xuICAgIEhlYnJld0hlbHBlcixcbiAgICBQZXJzaWFuSGVscGVyLFxuICAgIEV0aGlvcGljSGVscGVyLFxuICAgIEV0aGlvYWFIZWxwZXIsXG4gICAgQ29wdGljSGVscGVyLFxuICAgIENoaW5lc2VIZWxwZXIsXG4gICAgRGFuZ2lIZWxwZXIsXG4gICAgUm9jSGVscGVyLFxuICAgIEluZGlhbkhlbHBlcixcbiAgICBCdWRkaGlzdEhlbHBlcixcbiAgICBHcmVnb3J5SGVscGVyLFxuICAgIEphcGFuZXNlSGVscGVyLFxuICAgIElzbGFtaWNIZWxwZXIsXG4gICAgSXNsYW1pY1VtYWxxdXJhSGVscGVyLFxuICAgIElzbGFtaWNUYmxhSGVscGVyLFxuICAgIElzbGFtaWNDaXZpbEhlbHBlcixcbiAgICBJc2xhbWljUmdzYUhlbHBlcixcbiAgICBJc2xhbWljQ2NIZWxwZXJcbl0pIHtcbiAgICBjb25zdCBoZWxwZXIgPSBuZXcgSGVscGVyKCk7XG4gICAgLy8gQ2xvbmUgdGhlIHNpbmdsZXRvbiBub24tSVNPIGltcGxlbWVudGF0aW9uIHRoYXQncyB0aGUgc2FtZSBmb3IgYWxsXG4gICAgLy8gY2FsZW5kYXJzLiBUaGUgYGhlbHBlcmAgcHJvcGVydHkgY29udGFpbnMgcGVyLWNhbGVuZGFyIGxvZ2ljLlxuICAgIGltcGxbaGVscGVyLmlkXSA9IHsgLi4ubm9uSXNvSW1wbCwgaGVscGVyIH07XG59XG5jb25zdCBCVUlMVElOX0NBTEVOREFSX0lEUyA9IE9iamVjdC5rZXlzKGltcGwpO1xuZnVuY3Rpb24gSXNCdWlsdGluQ2FsZW5kYXIoaWQpIHtcbiAgICByZXR1cm4gQXJyYXlJbmNsdWRlcy5jYWxsKEJVSUxUSU5fQ0FMRU5EQVJfSURTLCBpZCk7XG59XG5cbmNvbnN0IHR6Q29tcG9uZW50ID0gL1xcLlstQS1aYS16X118XFwuXFwuWy1BLVphLXouX117MSwxMn18XFwuWy1BLVphLXpfXVstQS1aYS16Ll9dezAsMTJ9fFtBLVphLXpfXVstQS1aYS16Ll9dezAsMTN9LztcbmNvbnN0IG9mZnNldE5vQ2FwdHVyZSA9IC8oPzpbK1xcdTIyMTItXVswLTJdWzAtOV0oPzo6P1swLTVdWzAtOV0oPzo6P1swLTVdWzAtOV0oPzpbLixdXFxkezEsOX0pPyk/KT8pLztcbmNvbnN0IHRpbWVab25lSUQgPSBuZXcgUmVnRXhwKGAoPzooPzoke3R6Q29tcG9uZW50LnNvdXJjZX0pKD86XFxcXC8oPzoke3R6Q29tcG9uZW50LnNvdXJjZX0pKSp8RXRjL0dNVFstK11cXFxcZHsxLDJ9fCR7b2Zmc2V0Tm9DYXB0dXJlLnNvdXJjZX0pYCk7XG5jb25zdCBjYWxDb21wb25lbnQgPSAvW0EtWmEtejAtOV17Myw4fS87XG5jb25zdCBjYWxlbmRhcklEID0gbmV3IFJlZ0V4cChgKD86JHtjYWxDb21wb25lbnQuc291cmNlfSg/Oi0ke2NhbENvbXBvbmVudC5zb3VyY2V9KSopYCk7XG5jb25zdCB5ZWFycGFydCA9IC8oPzpbK1xcdTIyMTItXVxcZHs2fXxcXGR7NH0pLztcbmNvbnN0IG1vbnRocGFydCA9IC8oPzowWzEtOV18MVswLTJdKS87XG5jb25zdCBkYXlwYXJ0ID0gLyg/OjBbMS05XXxbMTJdXFxkfDNbMDFdKS87XG5jb25zdCBkYXRlc3BsaXQgPSBuZXcgUmVnRXhwKGAoJHt5ZWFycGFydC5zb3VyY2V9KSg/Oi0oJHttb250aHBhcnQuc291cmNlfSktKCR7ZGF5cGFydC5zb3VyY2V9KXwoJHttb250aHBhcnQuc291cmNlfSkoJHtkYXlwYXJ0LnNvdXJjZX0pKWApO1xuY29uc3QgdGltZXNwbGl0ID0gLyhcXGR7Mn0pKD86OihcXGR7Mn0pKD86OihcXGR7Mn0pKD86Wy4sXShcXGR7MSw5fSkpPyk/fChcXGR7Mn0pKD86KFxcZHsyfSkoPzpbLixdKFxcZHsxLDl9KSk/KT8pPy87XG5jb25zdCBvZmZzZXQgPSAvKFsrXFx1MjIxMi1dKShbMDFdWzAtOV18MlswLTNdKSg/Ojo/KFswLTVdWzAtOV0pKD86Oj8oWzAtNV1bMC05XSkoPzpbLixdKFxcZHsxLDl9KSk/KT8pPy87XG5jb25zdCB6b25lc3BsaXQgPSBuZXcgUmVnRXhwKGAoPzooW3paXSl8KD86JHtvZmZzZXQuc291cmNlfSk/KSg/OlxcXFxbKCR7dGltZVpvbmVJRC5zb3VyY2V9KVxcXFxdKT9gKTtcbmNvbnN0IGNhbGVuZGFyID0gbmV3IFJlZ0V4cChgXFxcXFt1LWNhPSgke2NhbGVuZGFySUQuc291cmNlfSlcXFxcXWApO1xuY29uc3Qgem9uZWRkYXRldGltZSA9IG5ldyBSZWdFeHAoYF4ke2RhdGVzcGxpdC5zb3VyY2V9KD86KD86VHxcXFxccyspJHt0aW1lc3BsaXQuc291cmNlfSk/JHt6b25lc3BsaXQuc291cmNlfSg/OiR7Y2FsZW5kYXIuc291cmNlfSk/JGAsICdpJyk7XG5jb25zdCB0aW1lID0gbmV3IFJlZ0V4cChgXlQ/JHt0aW1lc3BsaXQuc291cmNlfSg/OiR7em9uZXNwbGl0LnNvdXJjZX0pPyg/OiR7Y2FsZW5kYXIuc291cmNlfSk/JGAsICdpJyk7XG4vLyBUaGUgc2hvcnQgZm9ybXMgb2YgWWVhck1vbnRoIGFuZCBNb250aERheSBhcmUgb25seSBmb3IgdGhlIElTTyBjYWxlbmRhci5cbi8vIE5vbi1JU08gY2FsZW5kYXIgWWVhck1vbnRoIGFuZCBNb250aERheSBoYXZlIHRvIHBhcnNlIGFzIGEgVGVtcG9yYWwuUGxhaW5EYXRlLFxuLy8gd2l0aCB0aGUgcmVmZXJlbmNlIGZpZWxkcy5cbi8vIFlZWVlNTSBmb3JiaWRkZW4gYnkgSVNPIDg2MDEgYmVjYXVzZSBhbWJpZ3VvdXMgd2l0aCBZWU1NREQsIGJ1dCBhbGxvd2VkIGJ5XG4vLyBSRkMgMzMzOSBhbmQgd2UgZG9uJ3QgYWxsb3cgMi1kaWdpdCB5ZWFycywgc28gd2UgYWxsb3cgaXQuXG4vLyBOb3QgYW1iaWd1b3VzIHdpdGggSEhNTVNTIGJlY2F1c2UgdGhhdCByZXF1aXJlcyBhICdUJyBwcmVmaXhcbmNvbnN0IHllYXJtb250aCA9IG5ldyBSZWdFeHAoYF4oJHt5ZWFycGFydC5zb3VyY2V9KS0/KCR7bW9udGhwYXJ0LnNvdXJjZX0pJGApO1xuY29uc3QgbW9udGhkYXkgPSBuZXcgUmVnRXhwKGBeKD86LS0pPygke21vbnRocGFydC5zb3VyY2V9KS0/KCR7ZGF5cGFydC5zb3VyY2V9KSRgKTtcbmNvbnN0IGZyYWN0aW9uID0gLyhcXGQrKSg/OlsuLF0oXFxkezEsOX0pKT8vO1xuY29uc3QgZHVyYXRpb25EYXRlID0gLyg/OihcXGQrKVkpPyg/OihcXGQrKU0pPyg/OihcXGQrKVcpPyg/OihcXGQrKUQpPy87XG5jb25zdCBkdXJhdGlvblRpbWUgPSBuZXcgUmVnRXhwKGAoPzoke2ZyYWN0aW9uLnNvdXJjZX1IKT8oPzoke2ZyYWN0aW9uLnNvdXJjZX1NKT8oPzoke2ZyYWN0aW9uLnNvdXJjZX1TKT9gKTtcbmNvbnN0IGR1cmF0aW9uID0gbmV3IFJlZ0V4cChgXihbK1xcdTIyMTItXSk/UCR7ZHVyYXRpb25EYXRlLnNvdXJjZX0oPzpUKD8hJCkke2R1cmF0aW9uVGltZS5zb3VyY2V9KT8kYCwgJ2knKTtcblxuY29uc3QgQXJyYXlQcm90b3R5cGVQdXNoJDEgPSBBcnJheS5wcm90b3R5cGUucHVzaDtcbmNvbnN0IEludGxEYXRlVGltZUZvcm1hdCQxID0gZ2xvYmFsVGhpcy5JbnRsLkRhdGVUaW1lRm9ybWF0O1xuY29uc3QgTWF0aE1pbiA9IE1hdGgubWluO1xuY29uc3QgTWF0aE1heCA9IE1hdGgubWF4O1xuY29uc3QgTWF0aEFicyA9IE1hdGguYWJzO1xuY29uc3QgTWF0aEZsb29yID0gTWF0aC5mbG9vcjtcbmNvbnN0IE1hdGhTaWduID0gTWF0aC5zaWduO1xuY29uc3QgTWF0aFRydW5jID0gTWF0aC50cnVuYztcbmNvbnN0IE51bWJlcklzTmFOID0gTnVtYmVyLmlzTmFOO1xuY29uc3QgTnVtYmVySXNGaW5pdGUgPSBOdW1iZXIuaXNGaW5pdGU7XG5jb25zdCBOdW1iZXJDdG9yID0gTnVtYmVyO1xuY29uc3QgU3RyaW5nQ3RvciA9IFN0cmluZztcbmNvbnN0IE51bWJlck1heFNhZmVJbnRlZ2VyID0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVI7XG5jb25zdCBPYmplY3RDcmVhdGUkMiA9IE9iamVjdC5jcmVhdGU7XG5jb25zdCBPYmplY3REZWZpbmVQcm9wZXJ0eSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbmNvbnN0IE9iamVjdElzID0gT2JqZWN0LmlzO1xuY29uc3QgUmVmbGVjdEFwcGx5JDEgPSBSZWZsZWN0LmFwcGx5O1xuY29uc3QgWkVSTyA9IEpTQkkuQmlnSW50KDApO1xuY29uc3QgT05FID0gSlNCSS5CaWdJbnQoMSk7XG5jb25zdCBTSVhUWSA9IEpTQkkuQmlnSW50KDYwKTtcbmNvbnN0IFRIT1VTQU5EID0gSlNCSS5CaWdJbnQoMWUzKTtcbmNvbnN0IE1JTExJT04gPSBKU0JJLkJpZ0ludCgxZTYpO1xuY29uc3QgQklMTElPTiA9IEpTQkkuQmlnSW50KDFlOSk7XG5jb25zdCBORUdBVElWRV9PTkUgPSBKU0JJLkJpZ0ludCgtMSk7XG5jb25zdCBEQVlfU0VDT05EUyA9IDg2NDAwO1xuY29uc3QgREFZX05BTk9TID0gSlNCSS5tdWx0aXBseShKU0JJLkJpZ0ludChEQVlfU0VDT05EUyksIEJJTExJT04pO1xuY29uc3QgTlNfTUlOID0gSlNCSS5tdWx0aXBseShKU0JJLkJpZ0ludCgtODY0MDApLCBKU0JJLkJpZ0ludCgxZTE3KSk7XG5jb25zdCBOU19NQVggPSBKU0JJLm11bHRpcGx5KEpTQkkuQmlnSW50KDg2NDAwKSwgSlNCSS5CaWdJbnQoMWUxNykpO1xuY29uc3QgWUVBUl9NSU4gPSAtMjcxODIxO1xuY29uc3QgWUVBUl9NQVggPSAyNzU3NjA7XG5jb25zdCBCRUZPUkVfRklSU1RfT0ZGU0VUX1RSQU5TSVRJT04gPSBKU0JJLm11bHRpcGx5KEpTQkkuQmlnSW50KC0zODgxNTIpLCBKU0JJLkJpZ0ludCgxZTEzKSk7IC8vIDE4NDctMDEtMDFUMDA6MDA6MDBaXG5jb25zdCBBQk9VVF9URU5fWUVBUlNfTkFOT1MgPSBKU0JJLm11bHRpcGx5KERBWV9OQU5PUywgSlNCSS5CaWdJbnQoMzY2ICogMTApKTtcbmNvbnN0IEFCT1VUX09ORV9ZRUFSX05BTk9TID0gSlNCSS5tdWx0aXBseShEQVlfTkFOT1MsIEpTQkkuQmlnSW50KDM2NiAqIDEpKTtcbmNvbnN0IFRXT19XRUVLU19OQU5PUyA9IEpTQkkubXVsdGlwbHkoREFZX05BTk9TLCBKU0JJLkJpZ0ludCgyICogNykpO1xuZnVuY3Rpb24gSXNJbnRlZ2VyKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicgfHwgIU51bWJlcklzRmluaXRlKHZhbHVlKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGNvbnN0IGFicyA9IE1hdGhBYnModmFsdWUpO1xuICAgIHJldHVybiBNYXRoRmxvb3IoYWJzKSA9PT0gYWJzO1xufVxuZnVuY3Rpb24gSXNPYmplY3QodmFsdWUpIHtcbiAgICByZXR1cm4gKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgIT09IG51bGwpIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJztcbn1cbmZ1bmN0aW9uIFRvTnVtYmVyKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2JpZ2ludCcpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjb252ZXJ0IEJpZ0ludCB0byBudW1iZXInKTtcbiAgICByZXR1cm4gTnVtYmVyQ3Rvcih2YWx1ZSk7XG59XG5mdW5jdGlvbiBUb0ludGVnZXIodmFsdWUpIHtcbiAgICBjb25zdCBudW0gPSBUb051bWJlcih2YWx1ZSk7XG4gICAgaWYgKE51bWJlcklzTmFOKG51bSkpXG4gICAgICAgIHJldHVybiAwO1xuICAgIGNvbnN0IGludGVnZXIgPSBNYXRoVHJ1bmMobnVtKTtcbiAgICBpZiAobnVtID09PSAwKVxuICAgICAgICByZXR1cm4gMDtcbiAgICByZXR1cm4gaW50ZWdlcjtcbn1cbmZ1bmN0aW9uIFRvU3RyaW5nKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N5bWJvbCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNvbnZlcnQgYSBTeW1ib2wgdmFsdWUgdG8gYSBTdHJpbmcnKTtcbiAgICB9XG4gICAgcmV0dXJuIFN0cmluZ0N0b3IodmFsdWUpO1xufVxuZnVuY3Rpb24gVG9JbnRlZ2VyVGhyb3dPbkluZmluaXR5KHZhbHVlKSB7XG4gICAgY29uc3QgaW50ZWdlciA9IFRvSW50ZWdlcih2YWx1ZSk7XG4gICAgaWYgKCFOdW1iZXJJc0Zpbml0ZShpbnRlZ2VyKSkge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignaW5maW5pdHkgaXMgb3V0IG9mIHJhbmdlJyk7XG4gICAgfVxuICAgIHJldHVybiBpbnRlZ2VyO1xufVxuZnVuY3Rpb24gVG9Qb3NpdGl2ZUludGVnZXIodmFsdWVQYXJhbSwgcHJvcGVydHkpIHtcbiAgICBjb25zdCB2YWx1ZSA9IFRvSW50ZWdlcih2YWx1ZVBhcmFtKTtcbiAgICBpZiAoIU51bWJlcklzRmluaXRlKHZhbHVlKSkge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignaW5maW5pdHkgaXMgb3V0IG9mIHJhbmdlJyk7XG4gICAgfVxuICAgIGlmICh2YWx1ZSA8IDEpIHtcbiAgICAgICAgaWYgKHByb3BlcnR5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBwcm9wZXJ0eSAnJHtwcm9wZXJ0eX0nIGNhbm5vdCBiZSBhIGEgbnVtYmVyIGxlc3MgdGhhbiBvbmVgKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQ2Fubm90IGNvbnZlcnQgYSBudW1iZXIgbGVzcyB0aGFuIG9uZSB0byBhIHBvc2l0aXZlIGludGVnZXInKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gVG9JbnRlZ2VyV2l0aG91dFJvdW5kaW5nKHZhbHVlUGFyYW0pIHtcbiAgICBjb25zdCB2YWx1ZSA9IFRvTnVtYmVyKHZhbHVlUGFyYW0pO1xuICAgIGlmIChOdW1iZXJJc05hTih2YWx1ZSkpXG4gICAgICAgIHJldHVybiAwO1xuICAgIGlmICghTnVtYmVySXNGaW5pdGUodmFsdWUpKSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdpbmZpbml0eSBpcyBvdXQgb2YgcmFuZ2UnKTtcbiAgICB9XG4gICAgaWYgKCFJc0ludGVnZXIodmFsdWUpKSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGB1bnN1cHBvcnRlZCBmcmFjdGlvbmFsIHZhbHVlICR7dmFsdWV9YCk7XG4gICAgfVxuICAgIHJldHVybiBUb0ludGVnZXIodmFsdWUpOyAvLyDihJ0odmFsdWUpIGluIHNwZWMgdGV4dDsgY29udmVydHMgLTAgdG8gMFxufVxuZnVuY3Rpb24gZGl2bW9kKHgsIHkpIHtcbiAgICBjb25zdCBxdW90aWVudCA9IEpTQkkuZGl2aWRlKHgsIHkpO1xuICAgIGNvbnN0IHJlbWFpbmRlciA9IEpTQkkucmVtYWluZGVyKHgsIHkpO1xuICAgIHJldHVybiB7IHF1b3RpZW50LCByZW1haW5kZXIgfTtcbn1cbmZ1bmN0aW9uIGFicyh4KSB7XG4gICAgaWYgKEpTQkkubGVzc1RoYW4oeCwgWkVSTykpXG4gICAgICAgIHJldHVybiBKU0JJLm11bHRpcGx5KHgsIE5FR0FUSVZFX09ORSk7XG4gICAgcmV0dXJuIHg7XG59XG5jb25zdCBCVUlMVElOX0NBU1RTID0gbmV3IE1hcChbXG4gICAgWyd5ZWFyJywgVG9JbnRlZ2VyVGhyb3dPbkluZmluaXR5XSxcbiAgICBbJ21vbnRoJywgVG9Qb3NpdGl2ZUludGVnZXJdLFxuICAgIFsnbW9udGhDb2RlJywgVG9TdHJpbmddLFxuICAgIFsnZGF5JywgVG9Qb3NpdGl2ZUludGVnZXJdLFxuICAgIFsnaG91cicsIFRvSW50ZWdlclRocm93T25JbmZpbml0eV0sXG4gICAgWydtaW51dGUnLCBUb0ludGVnZXJUaHJvd09uSW5maW5pdHldLFxuICAgIFsnc2Vjb25kJywgVG9JbnRlZ2VyVGhyb3dPbkluZmluaXR5XSxcbiAgICBbJ21pbGxpc2Vjb25kJywgVG9JbnRlZ2VyVGhyb3dPbkluZmluaXR5XSxcbiAgICBbJ21pY3Jvc2Vjb25kJywgVG9JbnRlZ2VyVGhyb3dPbkluZmluaXR5XSxcbiAgICBbJ25hbm9zZWNvbmQnLCBUb0ludGVnZXJUaHJvd09uSW5maW5pdHldLFxuICAgIFsneWVhcnMnLCBUb0ludGVnZXJXaXRob3V0Um91bmRpbmddLFxuICAgIFsnbW9udGhzJywgVG9JbnRlZ2VyV2l0aG91dFJvdW5kaW5nXSxcbiAgICBbJ3dlZWtzJywgVG9JbnRlZ2VyV2l0aG91dFJvdW5kaW5nXSxcbiAgICBbJ2RheXMnLCBUb0ludGVnZXJXaXRob3V0Um91bmRpbmddLFxuICAgIFsnaG91cnMnLCBUb0ludGVnZXJXaXRob3V0Um91bmRpbmddLFxuICAgIFsnbWludXRlcycsIFRvSW50ZWdlcldpdGhvdXRSb3VuZGluZ10sXG4gICAgWydzZWNvbmRzJywgVG9JbnRlZ2VyV2l0aG91dFJvdW5kaW5nXSxcbiAgICBbJ21pbGxpc2Vjb25kcycsIFRvSW50ZWdlcldpdGhvdXRSb3VuZGluZ10sXG4gICAgWydtaWNyb3NlY29uZHMnLCBUb0ludGVnZXJXaXRob3V0Um91bmRpbmddLFxuICAgIFsnbmFub3NlY29uZHMnLCBUb0ludGVnZXJXaXRob3V0Um91bmRpbmddLFxuICAgIFsnZXJhJywgVG9TdHJpbmddLFxuICAgIFsnZXJhWWVhcicsIFRvSW50ZWdlcl0sXG4gICAgWydvZmZzZXQnLCBUb1N0cmluZ11cbl0pO1xuY29uc3QgQUxMT1dFRF9VTklUUyA9IFtcbiAgICAneWVhcicsXG4gICAgJ21vbnRoJyxcbiAgICAnd2VlaycsXG4gICAgJ2RheScsXG4gICAgJ2hvdXInLFxuICAgICdtaW51dGUnLFxuICAgICdzZWNvbmQnLFxuICAgICdtaWxsaXNlY29uZCcsXG4gICAgJ21pY3Jvc2Vjb25kJyxcbiAgICAnbmFub3NlY29uZCdcbl07XG5jb25zdCBTSU5HVUxBUl9QTFVSQUxfVU5JVFMgPSBbXG4gICAgWyd5ZWFycycsICd5ZWFyJ10sXG4gICAgWydtb250aHMnLCAnbW9udGgnXSxcbiAgICBbJ3dlZWtzJywgJ3dlZWsnXSxcbiAgICBbJ2RheXMnLCAnZGF5J10sXG4gICAgWydob3VycycsICdob3VyJ10sXG4gICAgWydtaW51dGVzJywgJ21pbnV0ZSddLFxuICAgIFsnc2Vjb25kcycsICdzZWNvbmQnXSxcbiAgICBbJ21pbGxpc2Vjb25kcycsICdtaWxsaXNlY29uZCddLFxuICAgIFsnbWljcm9zZWNvbmRzJywgJ21pY3Jvc2Vjb25kJ10sXG4gICAgWyduYW5vc2Vjb25kcycsICduYW5vc2Vjb25kJ11cbl07XG5jb25zdCBJbnRsRGF0ZVRpbWVGb3JtYXRFblVzQ2FjaGUgPSBuZXcgTWFwKCk7XG5mdW5jdGlvbiBnZXRJbnRsRGF0ZVRpbWVGb3JtYXRFblVzRm9yVGltZVpvbmUodGltZVpvbmVJZGVudGlmaWVyKSB7XG4gICAgbGV0IGluc3RhbmNlID0gSW50bERhdGVUaW1lRm9ybWF0RW5Vc0NhY2hlLmdldCh0aW1lWm9uZUlkZW50aWZpZXIpO1xuICAgIGlmIChpbnN0YW5jZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGluc3RhbmNlID0gbmV3IEludGxEYXRlVGltZUZvcm1hdCQxKCdlbi11cycsIHtcbiAgICAgICAgICAgIHRpbWVab25lOiBTdHJpbmdDdG9yKHRpbWVab25lSWRlbnRpZmllciksXG4gICAgICAgICAgICBob3VyMTI6IGZhbHNlLFxuICAgICAgICAgICAgZXJhOiAnc2hvcnQnLFxuICAgICAgICAgICAgeWVhcjogJ251bWVyaWMnLFxuICAgICAgICAgICAgbW9udGg6ICdudW1lcmljJyxcbiAgICAgICAgICAgIGRheTogJ251bWVyaWMnLFxuICAgICAgICAgICAgaG91cjogJ251bWVyaWMnLFxuICAgICAgICAgICAgbWludXRlOiAnbnVtZXJpYycsXG4gICAgICAgICAgICBzZWNvbmQ6ICdudW1lcmljJ1xuICAgICAgICB9KTtcbiAgICAgICAgSW50bERhdGVUaW1lRm9ybWF0RW5Vc0NhY2hlLnNldCh0aW1lWm9uZUlkZW50aWZpZXIsIGluc3RhbmNlKTtcbiAgICB9XG4gICAgcmV0dXJuIGluc3RhbmNlO1xufVxuZnVuY3Rpb24gSXNUZW1wb3JhbEluc3RhbnQoaXRlbSkge1xuICAgIHJldHVybiBIYXNTbG90KGl0ZW0sIEVQT0NITkFOT1NFQ09ORFMpICYmICFIYXNTbG90KGl0ZW0sIFRJTUVfWk9ORSwgQ0FMRU5EQVIpO1xufVxuZnVuY3Rpb24gSXNUZW1wb3JhbFRpbWVab25lKGl0ZW0pIHtcbiAgICByZXR1cm4gSGFzU2xvdChpdGVtLCBUSU1FWk9ORV9JRCk7XG59XG5mdW5jdGlvbiBJc1RlbXBvcmFsQ2FsZW5kYXIoaXRlbSkge1xuICAgIHJldHVybiBIYXNTbG90KGl0ZW0sIENBTEVOREFSX0lEKTtcbn1cbmZ1bmN0aW9uIElzVGVtcG9yYWxEdXJhdGlvbihpdGVtKSB7XG4gICAgcmV0dXJuIEhhc1Nsb3QoaXRlbSwgWUVBUlMsIE1PTlRIUywgREFZUywgSE9VUlMsIE1JTlVURVMsIFNFQ09ORFMsIE1JTExJU0VDT05EUywgTUlDUk9TRUNPTkRTLCBOQU5PU0VDT05EUyk7XG59XG5mdW5jdGlvbiBJc1RlbXBvcmFsRGF0ZShpdGVtKSB7XG4gICAgcmV0dXJuIEhhc1Nsb3QoaXRlbSwgREFURV9CUkFORCk7XG59XG5mdW5jdGlvbiBJc1RlbXBvcmFsVGltZShpdGVtKSB7XG4gICAgcmV0dXJuIChIYXNTbG90KGl0ZW0sIElTT19IT1VSLCBJU09fTUlOVVRFLCBJU09fU0VDT05ELCBJU09fTUlMTElTRUNPTkQsIElTT19NSUNST1NFQ09ORCwgSVNPX05BTk9TRUNPTkQpICYmXG4gICAgICAgICFIYXNTbG90KGl0ZW0sIElTT19ZRUFSLCBJU09fTU9OVEgsIElTT19EQVkpKTtcbn1cbmZ1bmN0aW9uIElzVGVtcG9yYWxEYXRlVGltZShpdGVtKSB7XG4gICAgcmV0dXJuIEhhc1Nsb3QoaXRlbSwgSVNPX1lFQVIsIElTT19NT05USCwgSVNPX0RBWSwgSVNPX0hPVVIsIElTT19NSU5VVEUsIElTT19TRUNPTkQsIElTT19NSUxMSVNFQ09ORCwgSVNPX01JQ1JPU0VDT05ELCBJU09fTkFOT1NFQ09ORCk7XG59XG5mdW5jdGlvbiBJc1RlbXBvcmFsWWVhck1vbnRoKGl0ZW0pIHtcbiAgICByZXR1cm4gSGFzU2xvdChpdGVtLCBZRUFSX01PTlRIX0JSQU5EKTtcbn1cbmZ1bmN0aW9uIElzVGVtcG9yYWxNb250aERheShpdGVtKSB7XG4gICAgcmV0dXJuIEhhc1Nsb3QoaXRlbSwgTU9OVEhfREFZX0JSQU5EKTtcbn1cbmZ1bmN0aW9uIElzVGVtcG9yYWxab25lZERhdGVUaW1lKGl0ZW0pIHtcbiAgICByZXR1cm4gSGFzU2xvdChpdGVtLCBFUE9DSE5BTk9TRUNPTkRTLCBUSU1FX1pPTkUsIENBTEVOREFSKTtcbn1cbmZ1bmN0aW9uIFJlamVjdE9iamVjdFdpdGhDYWxlbmRhck9yVGltZVpvbmUoaXRlbSkge1xuICAgIGlmIChIYXNTbG90KGl0ZW0sIENBTEVOREFSKSB8fCBIYXNTbG90KGl0ZW0sIFRJTUVfWk9ORSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignd2l0aCgpIGRvZXMgbm90IHN1cHBvcnQgYSBjYWxlbmRhciBvciB0aW1lWm9uZSBwcm9wZXJ0eScpO1xuICAgIH1cbiAgICBpZiAoaXRlbS5jYWxlbmRhciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3dpdGgoKSBkb2VzIG5vdCBzdXBwb3J0IGEgY2FsZW5kYXIgcHJvcGVydHknKTtcbiAgICB9XG4gICAgaWYgKGl0ZW0udGltZVpvbmUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd3aXRoKCkgZG9lcyBub3Qgc3VwcG9ydCBhIHRpbWVab25lIHByb3BlcnR5Jyk7XG4gICAgfVxufVxuZnVuY3Rpb24gUGFyc2VUZW1wb3JhbFRpbWVab25lKHN0cmluZ0lkZW50KSB7XG4gICAgbGV0IHsgaWFuYU5hbWUsIG9mZnNldCwgeiB9ID0gUGFyc2VUZW1wb3JhbFRpbWVab25lU3RyaW5nKHN0cmluZ0lkZW50KTtcbiAgICBpZiAoaWFuYU5hbWUpXG4gICAgICAgIHJldHVybiBpYW5hTmFtZTtcbiAgICBpZiAoeilcbiAgICAgICAgcmV0dXJuICdVVEMnO1xuICAgIHJldHVybiBvZmZzZXQ7IC8vIGlmICFpYW5hTmFtZSAmJiAheiB0aGVuIG9mZnNldCBtdXN0IGJlIHByZXNlbnRcbn1cbmZ1bmN0aW9uIEZvcm1hdENhbGVuZGFyQW5ub3RhdGlvbihpZCwgc2hvd0NhbGVuZGFyKSB7XG4gICAgaWYgKHNob3dDYWxlbmRhciA9PT0gJ25ldmVyJylcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIGlmIChzaG93Q2FsZW5kYXIgPT09ICdhdXRvJyAmJiBpZCA9PT0gJ2lzbzg2MDEnKVxuICAgICAgICByZXR1cm4gJyc7XG4gICAgcmV0dXJuIGBbdS1jYT0ke2lkfV1gO1xufVxuZnVuY3Rpb24gUGFyc2VJU09EYXRlVGltZShpc29TdHJpbmcpIHtcbiAgICAvLyBaRFQgaXMgdGhlIHN1cGVyc2V0IG9mIGZpZWxkcyBmb3IgZXZlcnkgb3RoZXIgVGVtcG9yYWwgdHlwZVxuICAgIGNvbnN0IG1hdGNoID0gem9uZWRkYXRldGltZS5leGVjKGlzb1N0cmluZyk7XG4gICAgaWYgKCFtYXRjaClcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYGludmFsaWQgSVNPIDg2MDEgc3RyaW5nOiAke2lzb1N0cmluZ31gKTtcbiAgICBsZXQgeWVhclN0cmluZyA9IG1hdGNoWzFdO1xuICAgIGlmICh5ZWFyU3RyaW5nWzBdID09PSAnXFx1MjIxMicpXG4gICAgICAgIHllYXJTdHJpbmcgPSBgLSR7eWVhclN0cmluZy5zbGljZSgxKX1gO1xuICAgIGlmICh5ZWFyU3RyaW5nID09PSAnLTAwMDAwMCcpXG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBpbnZhbGlkIElTTyA4NjAxIHN0cmluZzogJHtpc29TdHJpbmd9YCk7XG4gICAgY29uc3QgeWVhciA9IFRvSW50ZWdlcih5ZWFyU3RyaW5nKTtcbiAgICBjb25zdCBtb250aCA9IFRvSW50ZWdlcihtYXRjaFsyXSB8fCBtYXRjaFs0XSk7XG4gICAgY29uc3QgZGF5ID0gVG9JbnRlZ2VyKG1hdGNoWzNdIHx8IG1hdGNoWzVdKTtcbiAgICBjb25zdCBob3VyID0gVG9JbnRlZ2VyKG1hdGNoWzZdKTtcbiAgICBjb25zdCBoYXNUaW1lID0gbWF0Y2hbNl0gIT09IHVuZGVmaW5lZDtcbiAgICBjb25zdCBtaW51dGUgPSBUb0ludGVnZXIobWF0Y2hbN10gfHwgbWF0Y2hbMTBdKTtcbiAgICBsZXQgc2Vjb25kID0gVG9JbnRlZ2VyKG1hdGNoWzhdIHx8IG1hdGNoWzExXSk7XG4gICAgaWYgKHNlY29uZCA9PT0gNjApXG4gICAgICAgIHNlY29uZCA9IDU5O1xuICAgIGNvbnN0IGZyYWN0aW9uID0gKG1hdGNoWzldIHx8IG1hdGNoWzEyXSkgKyAnMDAwMDAwMDAwJztcbiAgICBjb25zdCBtaWxsaXNlY29uZCA9IFRvSW50ZWdlcihmcmFjdGlvbi5zbGljZSgwLCAzKSk7XG4gICAgY29uc3QgbWljcm9zZWNvbmQgPSBUb0ludGVnZXIoZnJhY3Rpb24uc2xpY2UoMywgNikpO1xuICAgIGNvbnN0IG5hbm9zZWNvbmQgPSBUb0ludGVnZXIoZnJhY3Rpb24uc2xpY2UoNiwgOSkpO1xuICAgIGxldCBvZmZzZXQ7XG4gICAgbGV0IHogPSBmYWxzZTtcbiAgICBpZiAobWF0Y2hbMTNdKSB7XG4gICAgICAgIG9mZnNldCA9IHVuZGVmaW5lZDtcbiAgICAgICAgeiA9IHRydWU7XG4gICAgfVxuICAgIGVsc2UgaWYgKG1hdGNoWzE0XSAmJiBtYXRjaFsxNV0pIHtcbiAgICAgICAgY29uc3Qgb2Zmc2V0U2lnbiA9IG1hdGNoWzE0XSA9PT0gJy0nIHx8IG1hdGNoWzE0XSA9PT0gJ1xcdTIyMTInID8gJy0nIDogJysnO1xuICAgICAgICBjb25zdCBvZmZzZXRIb3VycyA9IG1hdGNoWzE1XSB8fCAnMDAnO1xuICAgICAgICBjb25zdCBvZmZzZXRNaW51dGVzID0gbWF0Y2hbMTZdIHx8ICcwMCc7XG4gICAgICAgIGNvbnN0IG9mZnNldFNlY29uZHMgPSBtYXRjaFsxN10gfHwgJzAwJztcbiAgICAgICAgbGV0IG9mZnNldEZyYWN0aW9uID0gbWF0Y2hbMThdIHx8ICcwJztcbiAgICAgICAgb2Zmc2V0ID0gYCR7b2Zmc2V0U2lnbn0ke29mZnNldEhvdXJzfToke29mZnNldE1pbnV0ZXN9YDtcbiAgICAgICAgaWYgKCtvZmZzZXRGcmFjdGlvbikge1xuICAgICAgICAgICAgd2hpbGUgKG9mZnNldEZyYWN0aW9uLmVuZHNXaXRoKCcwJykpXG4gICAgICAgICAgICAgICAgb2Zmc2V0RnJhY3Rpb24gPSBvZmZzZXRGcmFjdGlvbi5zbGljZSgwLCAtMSk7XG4gICAgICAgICAgICBvZmZzZXQgKz0gYDoke29mZnNldFNlY29uZHN9LiR7b2Zmc2V0RnJhY3Rpb259YDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgrb2Zmc2V0U2Vjb25kcykge1xuICAgICAgICAgICAgb2Zmc2V0ICs9IGA6JHtvZmZzZXRTZWNvbmRzfWA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9mZnNldCA9PT0gJy0wMDowMCcpXG4gICAgICAgICAgICBvZmZzZXQgPSAnKzAwOjAwJztcbiAgICB9XG4gICAgbGV0IGlhbmFOYW1lID0gbWF0Y2hbMTldO1xuICAgIGlmIChpYW5hTmFtZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gQ2Fub25pY2FsaXplIG5hbWUgaWYgaXQgaXMgYW4gSUFOQSBsaW5rIG5hbWUgb3IgaXMgY2FwaXRhbGl6ZWQgd3JvbmdcbiAgICAgICAgICAgIGlhbmFOYW1lID0gR2V0Q2Fub25pY2FsVGltZVpvbmVJZGVudGlmaWVyKGlhbmFOYW1lKS50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIHtcbiAgICAgICAgICAgIC8vIE5vdCBhbiBJQU5BIG5hbWUsIG1heSBiZSBhIGN1c3RvbSBJRCwgcGFzcyB0aHJvdWdoIHVuY2hhbmdlZFxuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGNhbGVuZGFyID0gbWF0Y2hbMjBdO1xuICAgIHJldHVybiB7XG4gICAgICAgIHllYXIsXG4gICAgICAgIG1vbnRoLFxuICAgICAgICBkYXksXG4gICAgICAgIGhhc1RpbWUsXG4gICAgICAgIGhvdXIsXG4gICAgICAgIG1pbnV0ZSxcbiAgICAgICAgc2Vjb25kLFxuICAgICAgICBtaWxsaXNlY29uZCxcbiAgICAgICAgbWljcm9zZWNvbmQsXG4gICAgICAgIG5hbm9zZWNvbmQsXG4gICAgICAgIGlhbmFOYW1lLFxuICAgICAgICBvZmZzZXQsXG4gICAgICAgIHosXG4gICAgICAgIGNhbGVuZGFyXG4gICAgfTtcbn1cbmZ1bmN0aW9uIFBhcnNlVGVtcG9yYWxJbnN0YW50U3RyaW5nKGlzb1N0cmluZykge1xuICAgIGNvbnN0IHJlc3VsdCA9IFBhcnNlSVNPRGF0ZVRpbWUoaXNvU3RyaW5nKTtcbiAgICBpZiAoIXJlc3VsdC56ICYmICFyZXN1bHQub2Zmc2V0KVxuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGVtcG9yYWwuSW5zdGFudCByZXF1aXJlcyBhIHRpbWUgem9uZSBvZmZzZXQnKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gUGFyc2VUZW1wb3JhbFpvbmVkRGF0ZVRpbWVTdHJpbmcoaXNvU3RyaW5nKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gUGFyc2VJU09EYXRlVGltZShpc29TdHJpbmcpO1xuICAgIGlmICghcmVzdWx0LmlhbmFOYW1lKVxuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGVtcG9yYWwuWm9uZWREYXRlVGltZSByZXF1aXJlcyBhIHRpbWUgem9uZSBJRCBpbiBicmFja2V0cycpO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBQYXJzZVRlbXBvcmFsRGF0ZVRpbWVTdHJpbmcoaXNvU3RyaW5nKSB7XG4gICAgcmV0dXJuIFBhcnNlSVNPRGF0ZVRpbWUoaXNvU3RyaW5nKTtcbn1cbmZ1bmN0aW9uIFBhcnNlVGVtcG9yYWxEYXRlU3RyaW5nKGlzb1N0cmluZykge1xuICAgIHJldHVybiBQYXJzZUlTT0RhdGVUaW1lKGlzb1N0cmluZyk7XG59XG5mdW5jdGlvbiBQYXJzZVRlbXBvcmFsVGltZVN0cmluZyhpc29TdHJpbmcpIHtcbiAgICBjb25zdCBtYXRjaCA9IHRpbWUuZXhlYyhpc29TdHJpbmcpO1xuICAgIGxldCBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQsIG1pY3Jvc2Vjb25kLCBuYW5vc2Vjb25kLCBjYWxlbmRhcjtcbiAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgaG91ciA9IFRvSW50ZWdlcihtYXRjaFsxXSk7XG4gICAgICAgIG1pbnV0ZSA9IFRvSW50ZWdlcihtYXRjaFsyXSB8fCBtYXRjaFs1XSk7XG4gICAgICAgIHNlY29uZCA9IFRvSW50ZWdlcihtYXRjaFszXSB8fCBtYXRjaFs2XSk7XG4gICAgICAgIGlmIChzZWNvbmQgPT09IDYwKVxuICAgICAgICAgICAgc2Vjb25kID0gNTk7XG4gICAgICAgIGNvbnN0IGZyYWN0aW9uID0gKG1hdGNoWzRdIHx8IG1hdGNoWzddKSArICcwMDAwMDAwMDAnO1xuICAgICAgICBtaWxsaXNlY29uZCA9IFRvSW50ZWdlcihmcmFjdGlvbi5zbGljZSgwLCAzKSk7XG4gICAgICAgIG1pY3Jvc2Vjb25kID0gVG9JbnRlZ2VyKGZyYWN0aW9uLnNsaWNlKDMsIDYpKTtcbiAgICAgICAgbmFub3NlY29uZCA9IFRvSW50ZWdlcihmcmFjdGlvbi5zbGljZSg2LCA5KSk7XG4gICAgICAgIGNhbGVuZGFyID0gbWF0Y2hbMTVdO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbGV0IHosIGhhc1RpbWU7XG4gICAgICAgICh7IGhhc1RpbWUsIGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZCwgbWljcm9zZWNvbmQsIG5hbm9zZWNvbmQsIGNhbGVuZGFyLCB6IH0gPVxuICAgICAgICAgICAgUGFyc2VJU09EYXRlVGltZShpc29TdHJpbmcpKTtcbiAgICAgICAgaWYgKCFoYXNUaW1lKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYHRpbWUgaXMgbWlzc2luZyBpbiBzdHJpbmc6ICR7aXNvU3RyaW5nfWApO1xuICAgICAgICBpZiAoeilcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdaIGRlc2lnbmF0b3Igbm90IHN1cHBvcnRlZCBmb3IgUGxhaW5UaW1lJyk7XG4gICAgfVxuICAgIC8vIGlmIGl0J3MgYSBkYXRlLXRpbWUgc3RyaW5nLCBPS1xuICAgIGlmICgvW3RUIF1bMC05XVswLTldLy50ZXN0KGlzb1N0cmluZykpIHtcbiAgICAgICAgcmV0dXJuIHsgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kLCBtaWNyb3NlY29uZCwgbmFub3NlY29uZCwgY2FsZW5kYXIgfTtcbiAgICB9XG4gICAgLy8gc2xvdyBidXQgbm9uLWdyYW1tYXItZGVwZW5kZW50IHdheSB0byBlbnN1cmUgdGhhdCB0aW1lLW9ubHkgc3RyaW5ncyB0aGF0XG4gICAgLy8gYXJlIGFsc28gdmFsaWQgUGxhaW5Nb250aERheSBhbmQgUGxhaW5ZZWFyTW9udGggdGhyb3cuIGNvcnJlc3BvbmRzIHRvXG4gICAgLy8gYXNzZXJ0aW9uIGluIHNwZWMgdGV4dFxuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHsgbW9udGgsIGRheSB9ID0gUGFyc2VUZW1wb3JhbE1vbnRoRGF5U3RyaW5nKGlzb1N0cmluZyk7XG4gICAgICAgIFJlamVjdElTT0RhdGUoMTk3MiwgbW9udGgsIGRheSk7XG4gICAgfVxuICAgIGNhdGNoIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHsgeWVhciwgbW9udGggfSA9IFBhcnNlVGVtcG9yYWxZZWFyTW9udGhTdHJpbmcoaXNvU3RyaW5nKTtcbiAgICAgICAgICAgIFJlamVjdElTT0RhdGUoeWVhciwgbW9udGgsIDEpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIHtcbiAgICAgICAgICAgIHJldHVybiB7IGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZCwgbWljcm9zZWNvbmQsIG5hbm9zZWNvbmQsIGNhbGVuZGFyIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYGludmFsaWQgSVNPIDg2MDEgdGltZS1vbmx5IHN0cmluZyAke2lzb1N0cmluZ307IG1heSBuZWVkIGEgVCBwcmVmaXhgKTtcbn1cbmZ1bmN0aW9uIFBhcnNlVGVtcG9yYWxZZWFyTW9udGhTdHJpbmcoaXNvU3RyaW5nKSB7XG4gICAgY29uc3QgbWF0Y2ggPSB5ZWFybW9udGguZXhlYyhpc29TdHJpbmcpO1xuICAgIGxldCB5ZWFyLCBtb250aCwgY2FsZW5kYXIsIHJlZmVyZW5jZUlTT0RheTtcbiAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgbGV0IHllYXJTdHJpbmcgPSBtYXRjaFsxXTtcbiAgICAgICAgaWYgKHllYXJTdHJpbmdbMF0gPT09ICdcXHUyMjEyJylcbiAgICAgICAgICAgIHllYXJTdHJpbmcgPSBgLSR7eWVhclN0cmluZy5zbGljZSgxKX1gO1xuICAgICAgICBpZiAoeWVhclN0cmluZyA9PT0gJy0wMDAwMDAnKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYGludmFsaWQgSVNPIDg2MDEgc3RyaW5nOiAke2lzb1N0cmluZ31gKTtcbiAgICAgICAgeWVhciA9IFRvSW50ZWdlcih5ZWFyU3RyaW5nKTtcbiAgICAgICAgbW9udGggPSBUb0ludGVnZXIobWF0Y2hbMl0pO1xuICAgICAgICBjYWxlbmRhciA9IG1hdGNoWzNdO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbGV0IHo7XG4gICAgICAgICh7IHllYXIsIG1vbnRoLCBjYWxlbmRhciwgZGF5OiByZWZlcmVuY2VJU09EYXksIHogfSA9IFBhcnNlSVNPRGF0ZVRpbWUoaXNvU3RyaW5nKSk7XG4gICAgICAgIGlmICh6KVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1ogZGVzaWduYXRvciBub3Qgc3VwcG9ydGVkIGZvciBQbGFpblllYXJNb250aCcpO1xuICAgIH1cbiAgICByZXR1cm4geyB5ZWFyLCBtb250aCwgY2FsZW5kYXIsIHJlZmVyZW5jZUlTT0RheSB9O1xufVxuZnVuY3Rpb24gUGFyc2VUZW1wb3JhbE1vbnRoRGF5U3RyaW5nKGlzb1N0cmluZykge1xuICAgIGNvbnN0IG1hdGNoID0gbW9udGhkYXkuZXhlYyhpc29TdHJpbmcpO1xuICAgIGxldCBtb250aCwgZGF5LCBjYWxlbmRhciwgcmVmZXJlbmNlSVNPWWVhcjtcbiAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgbW9udGggPSBUb0ludGVnZXIobWF0Y2hbMV0pO1xuICAgICAgICBkYXkgPSBUb0ludGVnZXIobWF0Y2hbMl0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbGV0IHo7XG4gICAgICAgICh7IG1vbnRoLCBkYXksIGNhbGVuZGFyLCB5ZWFyOiByZWZlcmVuY2VJU09ZZWFyLCB6IH0gPSBQYXJzZUlTT0RhdGVUaW1lKGlzb1N0cmluZykpO1xuICAgICAgICBpZiAoeilcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdaIGRlc2lnbmF0b3Igbm90IHN1cHBvcnRlZCBmb3IgUGxhaW5Nb250aERheScpO1xuICAgIH1cbiAgICByZXR1cm4geyBtb250aCwgZGF5LCBjYWxlbmRhciwgcmVmZXJlbmNlSVNPWWVhciB9O1xufVxuZnVuY3Rpb24gUGFyc2VUZW1wb3JhbFRpbWVab25lU3RyaW5nKHN0cmluZ0lkZW50KSB7XG4gICAgdHJ5IHtcbiAgICAgICAgbGV0IGNhbm9uaWNhbElkZW50ID0gR2V0Q2Fub25pY2FsVGltZVpvbmVJZGVudGlmaWVyKHN0cmluZ0lkZW50KTtcbiAgICAgICAgaWYgKGNhbm9uaWNhbElkZW50KSB7XG4gICAgICAgICAgICBjYW5vbmljYWxJZGVudCA9IGNhbm9uaWNhbElkZW50LnRvU3RyaW5nKCk7XG4gICAgICAgICAgICBpZiAoVGVzdFRpbWVab25lT2Zmc2V0U3RyaW5nKGNhbm9uaWNhbElkZW50KSlcbiAgICAgICAgICAgICAgICByZXR1cm4geyBvZmZzZXQ6IGNhbm9uaWNhbElkZW50IH07XG4gICAgICAgICAgICByZXR1cm4geyBpYW5hTmFtZTogY2Fub25pY2FsSWRlbnQgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCB7XG4gICAgICAgIC8vIGZhbGwgdGhyb3VnaFxuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyBUcnkgcGFyc2luZyBJU08gc3RyaW5nIGluc3RlYWRcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gUGFyc2VJU09EYXRlVGltZShzdHJpbmdJZGVudCk7XG4gICAgICAgIGlmIChyZXN1bHQueiB8fCByZXN1bHQub2Zmc2V0IHx8IHJlc3VsdC5pYW5hTmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCB7XG4gICAgICAgIC8vIGZhbGwgdGhyb3VnaFxuICAgIH1cbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgSW52YWxpZCB0aW1lIHpvbmU6ICR7c3RyaW5nSWRlbnR9YCk7XG59XG5mdW5jdGlvbiBQYXJzZVRlbXBvcmFsRHVyYXRpb25TdHJpbmcoaXNvU3RyaW5nKSB7XG4gICAgY29uc3QgbWF0Y2ggPSBkdXJhdGlvbi5leGVjKGlzb1N0cmluZyk7XG4gICAgaWYgKCFtYXRjaClcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYGludmFsaWQgZHVyYXRpb246ICR7aXNvU3RyaW5nfWApO1xuICAgIGlmIChtYXRjaC5zbGljZSgyKS5ldmVyeSgoZWxlbWVudCkgPT4gZWxlbWVudCA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgaW52YWxpZCBkdXJhdGlvbjogJHtpc29TdHJpbmd9YCk7XG4gICAgfVxuICAgIGNvbnN0IHNpZ24gPSBtYXRjaFsxXSA9PT0gJy0nIHx8IG1hdGNoWzFdID09PSAnXFx1MjIxMicgPyAtMSA6IDE7XG4gICAgY29uc3QgeWVhcnMgPSBUb0ludGVnZXIobWF0Y2hbMl0pICogc2lnbjtcbiAgICBjb25zdCBtb250aHMgPSBUb0ludGVnZXIobWF0Y2hbM10pICogc2lnbjtcbiAgICBjb25zdCB3ZWVrcyA9IFRvSW50ZWdlcihtYXRjaFs0XSkgKiBzaWduO1xuICAgIGNvbnN0IGRheXMgPSBUb0ludGVnZXIobWF0Y2hbNV0pICogc2lnbjtcbiAgICBjb25zdCBob3VycyA9IFRvSW50ZWdlcihtYXRjaFs2XSkgKiBzaWduO1xuICAgIGxldCBmSG91cnMgPSBtYXRjaFs3XTtcbiAgICBsZXQgbWludXRlcyA9IFRvSW50ZWdlcihtYXRjaFs4XSkgKiBzaWduO1xuICAgIGxldCBmTWludXRlcyA9IG1hdGNoWzldO1xuICAgIGxldCBzZWNvbmRzID0gVG9JbnRlZ2VyKG1hdGNoWzEwXSkgKiBzaWduO1xuICAgIGNvbnN0IGZTZWNvbmRzID0gbWF0Y2hbMTFdICsgJzAwMDAwMDAwMCc7XG4gICAgbGV0IG1pbGxpc2Vjb25kcyA9IFRvSW50ZWdlcihmU2Vjb25kcy5zbGljZSgwLCAzKSkgKiBzaWduO1xuICAgIGxldCBtaWNyb3NlY29uZHMgPSBUb0ludGVnZXIoZlNlY29uZHMuc2xpY2UoMywgNikpICogc2lnbjtcbiAgICBsZXQgbmFub3NlY29uZHMgPSBUb0ludGVnZXIoZlNlY29uZHMuc2xpY2UoNiwgOSkpICogc2lnbjtcbiAgICBmSG91cnMgPSBmSG91cnMgPyAoc2lnbiAqIFRvSW50ZWdlcihmSG91cnMpKSAvIDEwICoqIGZIb3Vycy5sZW5ndGggOiAwO1xuICAgIGZNaW51dGVzID0gZk1pbnV0ZXMgPyAoc2lnbiAqIFRvSW50ZWdlcihmTWludXRlcykpIC8gMTAgKiogZk1pbnV0ZXMubGVuZ3RoIDogMDtcbiAgICAoeyBtaW51dGVzLCBzZWNvbmRzLCBtaWxsaXNlY29uZHMsIG1pY3Jvc2Vjb25kcywgbmFub3NlY29uZHMgfSA9IER1cmF0aW9uSGFuZGxlRnJhY3Rpb25zKGZIb3VycywgbWludXRlcywgZk1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc2Vjb25kcywgbWljcm9zZWNvbmRzLCBuYW5vc2Vjb25kcykpO1xuICAgIHJldHVybiB7IHllYXJzLCBtb250aHMsIHdlZWtzLCBkYXlzLCBob3VycywgbWludXRlcywgc2Vjb25kcywgbWlsbGlzZWNvbmRzLCBtaWNyb3NlY29uZHMsIG5hbm9zZWNvbmRzIH07XG59XG5mdW5jdGlvbiBQYXJzZVRlbXBvcmFsSW5zdGFudChpc29TdHJpbmcpIHtcbiAgICBjb25zdCB7IHllYXIsIG1vbnRoLCBkYXksIGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZCwgbWljcm9zZWNvbmQsIG5hbm9zZWNvbmQsIG9mZnNldCwgeiB9ID0gUGFyc2VUZW1wb3JhbEluc3RhbnRTdHJpbmcoaXNvU3RyaW5nKTtcbiAgICBjb25zdCBlcG9jaE5zID0gR2V0RXBvY2hGcm9tSVNPUGFydHMoeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kLCBtaWNyb3NlY29uZCwgbmFub3NlY29uZCk7XG4gICAgaWYgKGVwb2NoTnMgPT09IG51bGwpXG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdEYXRlVGltZSBvdXRzaWRlIG9mIHN1cHBvcnRlZCByYW5nZScpO1xuICAgIGNvbnN0IG9mZnNldE5zID0geiA/IDAgOiBQYXJzZVRpbWVab25lT2Zmc2V0U3RyaW5nKG9mZnNldCk7XG4gICAgcmV0dXJuIEpTQkkuc3VidHJhY3QoZXBvY2hOcywgSlNCSS5CaWdJbnQob2Zmc2V0TnMpKTtcbn1cbmZ1bmN0aW9uIFJlZ3VsYXRlSVNPRGF0ZSh5ZWFyUGFyYW0sIG1vbnRoUGFyYW0sIGRheVBhcmFtLCBvdmVyZmxvdykge1xuICAgIGxldCB5ZWFyID0geWVhclBhcmFtO1xuICAgIGxldCBtb250aCA9IG1vbnRoUGFyYW07XG4gICAgbGV0IGRheSA9IGRheVBhcmFtO1xuICAgIHN3aXRjaCAob3ZlcmZsb3cpIHtcbiAgICAgICAgY2FzZSAncmVqZWN0JzpcbiAgICAgICAgICAgIFJlamVjdElTT0RhdGUoeWVhciwgbW9udGgsIGRheSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnY29uc3RyYWluJzpcbiAgICAgICAgICAgICh7IHllYXIsIG1vbnRoLCBkYXkgfSA9IENvbnN0cmFpbklTT0RhdGUoeWVhciwgbW9udGgsIGRheSkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiB7IHllYXIsIG1vbnRoLCBkYXkgfTtcbn1cbmZ1bmN0aW9uIFJlZ3VsYXRlVGltZShob3VyUGFyYW0sIG1pbnV0ZVBhcmFtLCBzZWNvbmRQYXJhbSwgbWlsbGlzZWNvbmRQYXJhbSwgbWljcm9zZWNvbmRQYXJhbSwgbmFub3NlY29uZFBhcmFtLCBvdmVyZmxvdykge1xuICAgIGxldCBob3VyID0gaG91clBhcmFtO1xuICAgIGxldCBtaW51dGUgPSBtaW51dGVQYXJhbTtcbiAgICBsZXQgc2Vjb25kID0gc2Vjb25kUGFyYW07XG4gICAgbGV0IG1pbGxpc2Vjb25kID0gbWlsbGlzZWNvbmRQYXJhbTtcbiAgICBsZXQgbWljcm9zZWNvbmQgPSBtaWNyb3NlY29uZFBhcmFtO1xuICAgIGxldCBuYW5vc2Vjb25kID0gbmFub3NlY29uZFBhcmFtO1xuICAgIHN3aXRjaCAob3ZlcmZsb3cpIHtcbiAgICAgICAgY2FzZSAncmVqZWN0JzpcbiAgICAgICAgICAgIFJlamVjdFRpbWUoaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kLCBtaWNyb3NlY29uZCwgbmFub3NlY29uZCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnY29uc3RyYWluJzpcbiAgICAgICAgICAgICh7IGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZCwgbWljcm9zZWNvbmQsIG5hbm9zZWNvbmQgfSA9IENvbnN0cmFpblRpbWUoaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kLCBtaWNyb3NlY29uZCwgbmFub3NlY29uZCkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiB7IGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZCwgbWljcm9zZWNvbmQsIG5hbm9zZWNvbmQgfTtcbn1cbmZ1bmN0aW9uIFJlZ3VsYXRlSVNPWWVhck1vbnRoKHllYXJQYXJhbSwgbW9udGhQYXJhbSwgb3ZlcmZsb3cpIHtcbiAgICBsZXQgeWVhciA9IHllYXJQYXJhbTtcbiAgICBsZXQgbW9udGggPSBtb250aFBhcmFtO1xuICAgIGNvbnN0IHJlZmVyZW5jZUlTT0RheSA9IDE7XG4gICAgc3dpdGNoIChvdmVyZmxvdykge1xuICAgICAgICBjYXNlICdyZWplY3QnOlxuICAgICAgICAgICAgUmVqZWN0SVNPRGF0ZSh5ZWFyLCBtb250aCwgcmVmZXJlbmNlSVNPRGF5KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdjb25zdHJhaW4nOlxuICAgICAgICAgICAgKHsgeWVhciwgbW9udGggfSA9IENvbnN0cmFpbklTT0RhdGUoeWVhciwgbW9udGgpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4geyB5ZWFyLCBtb250aCB9O1xufVxuZnVuY3Rpb24gRHVyYXRpb25IYW5kbGVGcmFjdGlvbnMoZkhvdXJzUGFyYW0sIG1pbnV0ZXNQYXJhbSwgZk1pbnV0ZXNQYXJhbSwgc2Vjb25kc1BhcmFtLCBtaWxsaXNlY29uZHNQYXJhbSwgbWljcm9zZWNvbmRzUGFyYW0sIG5hbm9zZWNvbmRzUGFyYW0pIHtcbiAgICBsZXQgZkhvdXJzID0gZkhvdXJzUGFyYW07XG4gICAgbGV0IG1pbnV0ZXMgPSBtaW51dGVzUGFyYW07XG4gICAgbGV0IGZNaW51dGVzID0gZk1pbnV0ZXNQYXJhbTtcbiAgICBsZXQgc2Vjb25kcyA9IHNlY29uZHNQYXJhbTtcbiAgICBsZXQgbWlsbGlzZWNvbmRzID0gbWlsbGlzZWNvbmRzUGFyYW07XG4gICAgbGV0IG1pY3Jvc2Vjb25kcyA9IG1pY3Jvc2Vjb25kc1BhcmFtO1xuICAgIGxldCBuYW5vc2Vjb25kcyA9IG5hbm9zZWNvbmRzUGFyYW07XG4gICAgaWYgKGZIb3VycyAhPT0gMCkge1xuICAgICAgICBbbWludXRlcywgZk1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc2Vjb25kcywgbWljcm9zZWNvbmRzLCBuYW5vc2Vjb25kc10uZm9yRWFjaCgodmFsKSA9PiB7XG4gICAgICAgICAgICBpZiAodmFsICE9PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdvbmx5IHRoZSBzbWFsbGVzdCB1bml0IGNhbiBiZSBmcmFjdGlvbmFsJyk7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBtaW5zID0gZkhvdXJzICogNjA7XG4gICAgICAgIG1pbnV0ZXMgPSBNYXRoVHJ1bmMobWlucyk7XG4gICAgICAgIGZNaW51dGVzID0gbWlucyAlIDE7XG4gICAgfVxuICAgIGlmIChmTWludXRlcyAhPT0gMCkge1xuICAgICAgICBbc2Vjb25kcywgbWlsbGlzZWNvbmRzLCBtaWNyb3NlY29uZHMsIG5hbm9zZWNvbmRzXS5mb3JFYWNoKCh2YWwpID0+IHtcbiAgICAgICAgICAgIGlmICh2YWwgIT09IDApXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ29ubHkgdGhlIHNtYWxsZXN0IHVuaXQgY2FuIGJlIGZyYWN0aW9uYWwnKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHNlY3MgPSBmTWludXRlcyAqIDYwO1xuICAgICAgICBzZWNvbmRzID0gTWF0aFRydW5jKHNlY3MpO1xuICAgICAgICBjb25zdCBmU2Vjb25kcyA9IHNlY3MgJSAxO1xuICAgICAgICBpZiAoZlNlY29uZHMgIT09IDApIHtcbiAgICAgICAgICAgIGNvbnN0IG1pbHMgPSBmU2Vjb25kcyAqIDEwMDA7XG4gICAgICAgICAgICBtaWxsaXNlY29uZHMgPSBNYXRoVHJ1bmMobWlscyk7XG4gICAgICAgICAgICBjb25zdCBmTWlsbGlzZWNvbmRzID0gbWlscyAlIDE7XG4gICAgICAgICAgICBpZiAoZk1pbGxpc2Vjb25kcyAhPT0gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1pY3MgPSBmTWlsbGlzZWNvbmRzICogMTAwMDtcbiAgICAgICAgICAgICAgICBtaWNyb3NlY29uZHMgPSBNYXRoVHJ1bmMobWljcyk7XG4gICAgICAgICAgICAgICAgY29uc3QgZk1pY3Jvc2Vjb25kcyA9IG1pY3MgJSAxO1xuICAgICAgICAgICAgICAgIGlmIChmTWljcm9zZWNvbmRzICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5hbnMgPSBmTWljcm9zZWNvbmRzICogMTAwMDtcbiAgICAgICAgICAgICAgICAgICAgbmFub3NlY29uZHMgPSBNYXRoVHJ1bmMobmFucyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IG1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc2Vjb25kcywgbWljcm9zZWNvbmRzLCBuYW5vc2Vjb25kcyB9O1xufVxuZnVuY3Rpb24gVG9UZW1wb3JhbER1cmF0aW9uUmVjb3JkKGl0ZW0pIHtcbiAgICBpZiAoSXNUZW1wb3JhbER1cmF0aW9uKGl0ZW0pKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB5ZWFyczogR2V0U2xvdChpdGVtLCBZRUFSUyksXG4gICAgICAgICAgICBtb250aHM6IEdldFNsb3QoaXRlbSwgTU9OVEhTKSxcbiAgICAgICAgICAgIHdlZWtzOiBHZXRTbG90KGl0ZW0sIFdFRUtTKSxcbiAgICAgICAgICAgIGRheXM6IEdldFNsb3QoaXRlbSwgREFZUyksXG4gICAgICAgICAgICBob3VyczogR2V0U2xvdChpdGVtLCBIT1VSUyksXG4gICAgICAgICAgICBtaW51dGVzOiBHZXRTbG90KGl0ZW0sIE1JTlVURVMpLFxuICAgICAgICAgICAgc2Vjb25kczogR2V0U2xvdChpdGVtLCBTRUNPTkRTKSxcbiAgICAgICAgICAgIG1pbGxpc2Vjb25kczogR2V0U2xvdChpdGVtLCBNSUxMSVNFQ09ORFMpLFxuICAgICAgICAgICAgbWljcm9zZWNvbmRzOiBHZXRTbG90KGl0ZW0sIE1JQ1JPU0VDT05EUyksXG4gICAgICAgICAgICBuYW5vc2Vjb25kczogR2V0U2xvdChpdGVtLCBOQU5PU0VDT05EUylcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgcHJvcHMgPSBUb1BhcnRpYWxSZWNvcmQoaXRlbSwgW1xuICAgICAgICAnZGF5cycsXG4gICAgICAgICdob3VycycsXG4gICAgICAgICdtaWNyb3NlY29uZHMnLFxuICAgICAgICAnbWlsbGlzZWNvbmRzJyxcbiAgICAgICAgJ21pbnV0ZXMnLFxuICAgICAgICAnbW9udGhzJyxcbiAgICAgICAgJ25hbm9zZWNvbmRzJyxcbiAgICAgICAgJ3NlY29uZHMnLFxuICAgICAgICAnd2Vla3MnLFxuICAgICAgICAneWVhcnMnXG4gICAgXSk7XG4gICAgaWYgKCFwcm9wcylcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBkdXJhdGlvbi1saWtlJyk7XG4gICAgY29uc3QgeyB5ZWFycyA9IDAsIG1vbnRocyA9IDAsIHdlZWtzID0gMCwgZGF5cyA9IDAsIGhvdXJzID0gMCwgbWludXRlcyA9IDAsIHNlY29uZHMgPSAwLCBtaWxsaXNlY29uZHMgPSAwLCBtaWNyb3NlY29uZHMgPSAwLCBuYW5vc2Vjb25kcyA9IDAgfSA9IHByb3BzO1xuICAgIHJldHVybiB7IHllYXJzLCBtb250aHMsIHdlZWtzLCBkYXlzLCBob3VycywgbWludXRlcywgc2Vjb25kcywgbWlsbGlzZWNvbmRzLCBtaWNyb3NlY29uZHMsIG5hbm9zZWNvbmRzIH07XG59XG5mdW5jdGlvbiBUb0xpbWl0ZWRUZW1wb3JhbER1cmF0aW9uKGl0ZW0sIGRpc2FsbG93ZWRQcm9wZXJ0aWVzID0gW10pIHtcbiAgICBsZXQgcmVjb3JkO1xuICAgIGlmIChJc09iamVjdChpdGVtKSkge1xuICAgICAgICByZWNvcmQgPSBUb1RlbXBvcmFsRHVyYXRpb25SZWNvcmQoaXRlbSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBzdHIgPSBUb1N0cmluZyhpdGVtKTtcbiAgICAgICAgcmVjb3JkID0gUGFyc2VUZW1wb3JhbER1cmF0aW9uU3RyaW5nKHN0cik7XG4gICAgfVxuICAgIGNvbnN0IHsgeWVhcnMsIG1vbnRocywgd2Vla3MsIGRheXMsIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBtaWxsaXNlY29uZHMsIG1pY3Jvc2Vjb25kcywgbmFub3NlY29uZHMgfSA9IHJlY29yZDtcbiAgICBSZWplY3REdXJhdGlvbih5ZWFycywgbW9udGhzLCB3ZWVrcywgZGF5cywgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc2Vjb25kcywgbWljcm9zZWNvbmRzLCBuYW5vc2Vjb25kcyk7XG4gICAgZm9yIChjb25zdCBwcm9wZXJ0eSBvZiBkaXNhbGxvd2VkUHJvcGVydGllcykge1xuICAgICAgICBpZiAocmVjb3JkW3Byb3BlcnR5XSAhPT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYER1cmF0aW9uIGZpZWxkICR7cHJvcGVydHl9IG5vdCBzdXBwb3J0ZWQgYnkgVGVtcG9yYWwuSW5zdGFudC4gVHJ5IFRlbXBvcmFsLlpvbmVkRGF0ZVRpbWUgaW5zdGVhZC5gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVjb3JkO1xufVxuZnVuY3Rpb24gVG9UZW1wb3JhbE92ZXJmbG93KG9wdGlvbnMpIHtcbiAgICByZXR1cm4gR2V0T3B0aW9uKG9wdGlvbnMsICdvdmVyZmxvdycsIFsnY29uc3RyYWluJywgJ3JlamVjdCddLCAnY29uc3RyYWluJyk7XG59XG5mdW5jdGlvbiBUb1RlbXBvcmFsRGlzYW1iaWd1YXRpb24ob3B0aW9ucykge1xuICAgIHJldHVybiBHZXRPcHRpb24ob3B0aW9ucywgJ2Rpc2FtYmlndWF0aW9uJywgWydjb21wYXRpYmxlJywgJ2VhcmxpZXInLCAnbGF0ZXInLCAncmVqZWN0J10sICdjb21wYXRpYmxlJyk7XG59XG5mdW5jdGlvbiBUb1RlbXBvcmFsUm91bmRpbmdNb2RlKG9wdGlvbnMsIGZhbGxiYWNrKSB7XG4gICAgcmV0dXJuIEdldE9wdGlvbihvcHRpb25zLCAncm91bmRpbmdNb2RlJywgWydjZWlsJywgJ2Zsb29yJywgJ3RydW5jJywgJ2hhbGZFeHBhbmQnXSwgZmFsbGJhY2spO1xufVxuZnVuY3Rpb24gTmVnYXRlVGVtcG9yYWxSb3VuZGluZ01vZGUocm91bmRpbmdNb2RlKSB7XG4gICAgc3dpdGNoIChyb3VuZGluZ01vZGUpIHtcbiAgICAgICAgY2FzZSAnY2VpbCc6XG4gICAgICAgICAgICByZXR1cm4gJ2Zsb29yJztcbiAgICAgICAgY2FzZSAnZmxvb3InOlxuICAgICAgICAgICAgcmV0dXJuICdjZWlsJztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiByb3VuZGluZ01vZGU7XG4gICAgfVxufVxuZnVuY3Rpb24gVG9UZW1wb3JhbE9mZnNldChvcHRpb25zLCBmYWxsYmFjaykge1xuICAgIHJldHVybiBHZXRPcHRpb24ob3B0aW9ucywgJ29mZnNldCcsIFsncHJlZmVyJywgJ3VzZScsICdpZ25vcmUnLCAncmVqZWN0J10sIGZhbGxiYWNrKTtcbn1cbmZ1bmN0aW9uIFRvU2hvd0NhbGVuZGFyT3B0aW9uKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gR2V0T3B0aW9uKG9wdGlvbnMsICdjYWxlbmRhck5hbWUnLCBbJ2F1dG8nLCAnYWx3YXlzJywgJ25ldmVyJ10sICdhdXRvJyk7XG59XG5mdW5jdGlvbiBUb1Nob3dUaW1lWm9uZU5hbWVPcHRpb24ob3B0aW9ucykge1xuICAgIHJldHVybiBHZXRPcHRpb24ob3B0aW9ucywgJ3RpbWVab25lTmFtZScsIFsnYXV0bycsICduZXZlciddLCAnYXV0bycpO1xufVxuZnVuY3Rpb24gVG9TaG93T2Zmc2V0T3B0aW9uKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gR2V0T3B0aW9uKG9wdGlvbnMsICdvZmZzZXQnLCBbJ2F1dG8nLCAnbmV2ZXInXSwgJ2F1dG8nKTtcbn1cbmZ1bmN0aW9uIFRvVGVtcG9yYWxSb3VuZGluZ0luY3JlbWVudChvcHRpb25zLCBkaXZpZGVuZCwgaW5jbHVzaXZlKSB7XG4gICAgbGV0IG1heGltdW0gPSBJbmZpbml0eTtcbiAgICBpZiAoZGl2aWRlbmQgIT09IHVuZGVmaW5lZClcbiAgICAgICAgbWF4aW11bSA9IGRpdmlkZW5kO1xuICAgIGlmICghaW5jbHVzaXZlICYmIGRpdmlkZW5kICE9PSB1bmRlZmluZWQpXG4gICAgICAgIG1heGltdW0gPSBkaXZpZGVuZCA+IDEgPyBkaXZpZGVuZCAtIDEgOiAxO1xuICAgIGNvbnN0IGluY3JlbWVudCA9IEdldE51bWJlck9wdGlvbihvcHRpb25zLCAncm91bmRpbmdJbmNyZW1lbnQnLCAxLCBtYXhpbXVtLCAxKTtcbiAgICBpZiAoZGl2aWRlbmQgIT09IHVuZGVmaW5lZCAmJiBkaXZpZGVuZCAlIGluY3JlbWVudCAhPT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgUm91bmRpbmcgaW5jcmVtZW50IG11c3QgZGl2aWRlIGV2ZW5seSBpbnRvICR7ZGl2aWRlbmR9YCk7XG4gICAgfVxuICAgIHJldHVybiBpbmNyZW1lbnQ7XG59XG5mdW5jdGlvbiBUb1RlbXBvcmFsRGF0ZVRpbWVSb3VuZGluZ0luY3JlbWVudChvcHRpb25zLCBzbWFsbGVzdFVuaXQpIHtcbiAgICBjb25zdCBtYXhpbXVtSW5jcmVtZW50cyA9IHtcbiAgICAgICAgeWVhcjogdW5kZWZpbmVkLFxuICAgICAgICBtb250aDogdW5kZWZpbmVkLFxuICAgICAgICB3ZWVrOiB1bmRlZmluZWQsXG4gICAgICAgIGRheTogdW5kZWZpbmVkLFxuICAgICAgICBob3VyOiAyNCxcbiAgICAgICAgbWludXRlOiA2MCxcbiAgICAgICAgc2Vjb25kOiA2MCxcbiAgICAgICAgbWlsbGlzZWNvbmQ6IDEwMDAsXG4gICAgICAgIG1pY3Jvc2Vjb25kOiAxMDAwLFxuICAgICAgICBuYW5vc2Vjb25kOiAxMDAwXG4gICAgfTtcbiAgICByZXR1cm4gVG9UZW1wb3JhbFJvdW5kaW5nSW5jcmVtZW50KG9wdGlvbnMsIG1heGltdW1JbmNyZW1lbnRzW3NtYWxsZXN0VW5pdF0sIGZhbHNlKTtcbn1cbmZ1bmN0aW9uIFRvU2Vjb25kc1N0cmluZ1ByZWNpc2lvbihvcHRpb25zKSB7XG4gICAgY29uc3Qgc21hbGxlc3RVbml0ID0gVG9TbWFsbGVzdFRlbXBvcmFsVW5pdChvcHRpb25zLCB1bmRlZmluZWQsIFsneWVhcicsICdtb250aCcsICd3ZWVrJywgJ2RheScsICdob3VyJ10pO1xuICAgIHN3aXRjaCAoc21hbGxlc3RVbml0KSB7XG4gICAgICAgIGNhc2UgJ21pbnV0ZSc6XG4gICAgICAgICAgICByZXR1cm4geyBwcmVjaXNpb246ICdtaW51dGUnLCB1bml0OiAnbWludXRlJywgaW5jcmVtZW50OiAxIH07XG4gICAgICAgIGNhc2UgJ3NlY29uZCc6XG4gICAgICAgICAgICByZXR1cm4geyBwcmVjaXNpb246IDAsIHVuaXQ6ICdzZWNvbmQnLCBpbmNyZW1lbnQ6IDEgfTtcbiAgICAgICAgY2FzZSAnbWlsbGlzZWNvbmQnOlxuICAgICAgICAgICAgcmV0dXJuIHsgcHJlY2lzaW9uOiAzLCB1bml0OiAnbWlsbGlzZWNvbmQnLCBpbmNyZW1lbnQ6IDEgfTtcbiAgICAgICAgY2FzZSAnbWljcm9zZWNvbmQnOlxuICAgICAgICAgICAgcmV0dXJuIHsgcHJlY2lzaW9uOiA2LCB1bml0OiAnbWljcm9zZWNvbmQnLCBpbmNyZW1lbnQ6IDEgfTtcbiAgICAgICAgY2FzZSAnbmFub3NlY29uZCc6XG4gICAgICAgICAgICByZXR1cm4geyBwcmVjaXNpb246IDksIHVuaXQ6ICduYW5vc2Vjb25kJywgaW5jcmVtZW50OiAxIH07XG4gICAgfVxuICAgIGxldCBkaWdpdHMgPSBvcHRpb25zLmZyYWN0aW9uYWxTZWNvbmREaWdpdHM7XG4gICAgaWYgKGRpZ2l0cyA9PT0gdW5kZWZpbmVkKVxuICAgICAgICBkaWdpdHMgPSAnYXV0byc7XG4gICAgaWYgKHR5cGVvZiBkaWdpdHMgIT09ICdudW1iZXInKSB7XG4gICAgICAgIGNvbnN0IHN0cmluZ0RpZ2l0cyA9IFRvU3RyaW5nKGRpZ2l0cyk7XG4gICAgICAgIGlmIChzdHJpbmdEaWdpdHMgPT09ICdhdXRvJylcbiAgICAgICAgICAgIHJldHVybiB7IHByZWNpc2lvbjogJ2F1dG8nLCB1bml0OiAnbmFub3NlY29uZCcsIGluY3JlbWVudDogMSB9O1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgZnJhY3Rpb25hbFNlY29uZERpZ2l0cyBtdXN0IGJlICdhdXRvJyBvciAwIHRocm91Z2ggOSwgbm90ICR7c3RyaW5nRGlnaXRzfWApO1xuICAgIH1cbiAgICBpZiAoTnVtYmVySXNOYU4oZGlnaXRzKSB8fCBkaWdpdHMgPCAwIHx8IGRpZ2l0cyA+IDkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYGZyYWN0aW9uYWxTZWNvbmREaWdpdHMgbXVzdCBiZSAnYXV0bycgb3IgMCB0aHJvdWdoIDksIG5vdCAke2RpZ2l0c31gKTtcbiAgICB9XG4gICAgY29uc3QgcHJlY2lzaW9uID0gTWF0aEZsb29yKGRpZ2l0cyk7XG4gICAgc3dpdGNoIChwcmVjaXNpb24pIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgcmV0dXJuIHsgcHJlY2lzaW9uLCB1bml0OiAnc2Vjb25kJywgaW5jcmVtZW50OiAxIH07XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICByZXR1cm4geyBwcmVjaXNpb24sIHVuaXQ6ICdtaWxsaXNlY29uZCcsIGluY3JlbWVudDogMTAgKiogKDMgLSBwcmVjaXNpb24pIH07XG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgY2FzZSA1OlxuICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICByZXR1cm4geyBwcmVjaXNpb24sIHVuaXQ6ICdtaWNyb3NlY29uZCcsIGluY3JlbWVudDogMTAgKiogKDYgLSBwcmVjaXNpb24pIH07XG4gICAgICAgIGNhc2UgNzpcbiAgICAgICAgY2FzZSA4OlxuICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICByZXR1cm4geyBwcmVjaXNpb24sIHVuaXQ6ICduYW5vc2Vjb25kJywgaW5jcmVtZW50OiAxMCAqKiAoOSAtIHByZWNpc2lvbikgfTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBmcmFjdGlvbmFsU2Vjb25kRGlnaXRzIG11c3QgYmUgJ2F1dG8nIG9yIDAgdGhyb3VnaCA5LCBub3QgJHtkaWdpdHN9YCk7XG4gICAgfVxufVxuZnVuY3Rpb24gVG9MYXJnZXN0VGVtcG9yYWxVbml0KG9wdGlvbnMsIGZhbGxiYWNrLCBkaXNhbGxvd2VkU3RyaW5ncyA9IFtdLCBhdXRvVmFsdWUpIHtcbiAgICBjb25zdCBzaW5ndWxhciA9IG5ldyBNYXAoU0lOR1VMQVJfUExVUkFMX1VOSVRTLmZpbHRlcigoWywgc2luZ10pID0+ICFkaXNhbGxvd2VkU3RyaW5ncy5pbmNsdWRlcyhzaW5nKSkpO1xuICAgIGNvbnN0IGFsbG93ZWQgPSBuZXcgU2V0KEFMTE9XRURfVU5JVFMpO1xuICAgIGZvciAoY29uc3QgcyBvZiBkaXNhbGxvd2VkU3RyaW5ncykge1xuICAgICAgICBhbGxvd2VkLmRlbGV0ZShzKTtcbiAgICB9XG4gICAgY29uc3QgcmV0dmFsID0gR2V0T3B0aW9uKG9wdGlvbnMsICdsYXJnZXN0VW5pdCcsIFsnYXV0bycsIC4uLmFsbG93ZWQsIC4uLnNpbmd1bGFyLmtleXMoKV0sIGZhbGxiYWNrKTtcbiAgICBpZiAocmV0dmFsID09PSAnYXV0bycgJiYgYXV0b1ZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiBhdXRvVmFsdWU7XG4gICAgaWYgKHNpbmd1bGFyLmhhcyhyZXR2YWwpKSB7XG4gICAgICAgIHJldHVybiBzaW5ndWxhci5nZXQocmV0dmFsKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldHZhbDtcbn1cbmZ1bmN0aW9uIFRvU21hbGxlc3RUZW1wb3JhbFVuaXQob3B0aW9ucywgZmFsbGJhY2ssIGRpc2FsbG93ZWRTdHJpbmdzID0gW10pIHtcbiAgICBjb25zdCBzaW5ndWxhciA9IG5ldyBNYXAoU0lOR1VMQVJfUExVUkFMX1VOSVRTLmZpbHRlcigoWywgc2luZ10pID0+ICFkaXNhbGxvd2VkU3RyaW5ncy5pbmNsdWRlcyhzaW5nKSkpO1xuICAgIGNvbnN0IGFsbG93ZWQgPSBuZXcgU2V0KEFMTE9XRURfVU5JVFMpO1xuICAgIGZvciAoY29uc3QgcyBvZiBkaXNhbGxvd2VkU3RyaW5ncykge1xuICAgICAgICBhbGxvd2VkLmRlbGV0ZShzKTtcbiAgICB9XG4gICAgY29uc3QgdmFsdWUgPSBHZXRPcHRpb24ob3B0aW9ucywgJ3NtYWxsZXN0VW5pdCcsIFsuLi5hbGxvd2VkLCAuLi5zaW5ndWxhci5rZXlzKCldLCBmYWxsYmFjayk7XG4gICAgaWYgKHNpbmd1bGFyLmhhcyh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHNpbmd1bGFyLmdldCh2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIFRvVGVtcG9yYWxEdXJhdGlvblRvdGFsVW5pdChvcHRpb25zKSB7XG4gICAgLy8gVGhpcyBBTyBpcyBpZGVudGljYWwgdG8gVG9TbWFsbGVzdFRlbXBvcmFsVW5pdCwgZXhjZXB0OlxuICAgIC8vIC0gZGVmYXVsdCBpcyBhbHdheXMgYHVuZGVmaW5lZGAgKGNhbGxlciB3aWxsIHRocm93IGlmIG9taXR0ZWQpXG4gICAgLy8gLSBvcHRpb24gaXMgbmFtZWQgYHVuaXRgIChub3QgYHNtYWxsZXN0VW5pdGApXG4gICAgLy8gLSBhbGwgdW5pdHMgYXJlIHZhbGlkIChubyBgZGlzYWxsb3dlZFN0cmluZ3NgKVxuICAgIGNvbnN0IHNpbmd1bGFyID0gbmV3IE1hcChTSU5HVUxBUl9QTFVSQUxfVU5JVFMpO1xuICAgIGNvbnN0IHZhbHVlID0gR2V0T3B0aW9uKG9wdGlvbnMsICd1bml0JywgWy4uLnNpbmd1bGFyLnZhbHVlcygpLCAuLi5zaW5ndWxhci5rZXlzKCldLCB1bmRlZmluZWQpO1xuICAgIGlmIChzaW5ndWxhci5oYXModmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBzaW5ndWxhci5nZXQodmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59XG5mdW5jdGlvbiBUb1JlbGF0aXZlVGVtcG9yYWxPYmplY3Qob3B0aW9ucykge1xuICAgIGNvbnN0IHJlbGF0aXZlVG8gPSBvcHRpb25zLnJlbGF0aXZlVG87XG4gICAgaWYgKHJlbGF0aXZlVG8gPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIHJlbGF0aXZlVG87XG4gICAgbGV0IG9mZnNldEJlaGF2aW91ciA9ICdvcHRpb24nO1xuICAgIGxldCBtYXRjaE1pbnV0ZXMgPSBmYWxzZTtcbiAgICBsZXQgeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kLCBtaWNyb3NlY29uZCwgbmFub3NlY29uZCwgY2FsZW5kYXIsIHRpbWVab25lLCBvZmZzZXQ7XG4gICAgaWYgKElzT2JqZWN0KHJlbGF0aXZlVG8pKSB7XG4gICAgICAgIGlmIChJc1RlbXBvcmFsWm9uZWREYXRlVGltZShyZWxhdGl2ZVRvKSB8fCBJc1RlbXBvcmFsRGF0ZShyZWxhdGl2ZVRvKSlcbiAgICAgICAgICAgIHJldHVybiByZWxhdGl2ZVRvO1xuICAgICAgICBpZiAoSXNUZW1wb3JhbERhdGVUaW1lKHJlbGF0aXZlVG8pKVxuICAgICAgICAgICAgcmV0dXJuIFRlbXBvcmFsRGF0ZVRpbWVUb0RhdGUocmVsYXRpdmVUbyk7XG4gICAgICAgIGNhbGVuZGFyID0gR2V0VGVtcG9yYWxDYWxlbmRhcldpdGhJU09EZWZhdWx0KHJlbGF0aXZlVG8pO1xuICAgICAgICBjb25zdCBmaWVsZE5hbWVzID0gQ2FsZW5kYXJGaWVsZHMoY2FsZW5kYXIsIFtcbiAgICAgICAgICAgICdkYXknLFxuICAgICAgICAgICAgJ2hvdXInLFxuICAgICAgICAgICAgJ21pY3Jvc2Vjb25kJyxcbiAgICAgICAgICAgICdtaWxsaXNlY29uZCcsXG4gICAgICAgICAgICAnbWludXRlJyxcbiAgICAgICAgICAgICdtb250aCcsXG4gICAgICAgICAgICAnbW9udGhDb2RlJyxcbiAgICAgICAgICAgICduYW5vc2Vjb25kJyxcbiAgICAgICAgICAgICdzZWNvbmQnLFxuICAgICAgICAgICAgJ3llYXInXG4gICAgICAgIF0pO1xuICAgICAgICBjb25zdCBmaWVsZHMgPSBUb1RlbXBvcmFsRGF0ZVRpbWVGaWVsZHMocmVsYXRpdmVUbywgZmllbGROYW1lcyk7XG4gICAgICAgIGNvbnN0IGRhdGVPcHRpb25zID0gT2JqZWN0Q3JlYXRlJDIobnVsbCk7XG4gICAgICAgIGRhdGVPcHRpb25zLm92ZXJmbG93ID0gJ2NvbnN0cmFpbic7XG4gICAgICAgICh7IHllYXIsIG1vbnRoLCBkYXksIGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZCwgbWljcm9zZWNvbmQsIG5hbm9zZWNvbmQgfSA9IEludGVycHJldFRlbXBvcmFsRGF0ZVRpbWVGaWVsZHMoY2FsZW5kYXIsIGZpZWxkcywgZGF0ZU9wdGlvbnMpKTtcbiAgICAgICAgLy8gVGhlIGBvZmZzZXRgIGFuZCBgdGltZVpvbmVgIHByb3BlcnRpZXMgb25seSBleGlzdCBvbiBab25lZERhdGVUaW1lIChvclxuICAgICAgICAvLyBab25lZERhdGVUaW1lTGlrZS1wcm9wZXJ0eSBiYWdzKS4gVGhlIGFzc2VydGlvbnMgYmVsb3cgYXJlIHVzZWQgdG8gYXZvaWRcbiAgICAgICAgLy8gVFMgZXJyb3JzIHdoaWxlIG5vdCBkaXZlcmdpbmcgcnVudGltZSBjb2RlIGZyb20gcHJvcG9zYWwtdGVtcG9yYWwuXG4gICAgICAgIG9mZnNldCA9IHJlbGF0aXZlVG8ub2Zmc2V0O1xuICAgICAgICBpZiAob2Zmc2V0ID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICBvZmZzZXRCZWhhdmlvdXIgPSAnd2FsbCc7XG4gICAgICAgIHRpbWVab25lID0gcmVsYXRpdmVUby50aW1lWm9uZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGxldCBpYW5hTmFtZSwgejtcbiAgICAgICAgKHsgeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kLCBtaWNyb3NlY29uZCwgbmFub3NlY29uZCwgY2FsZW5kYXIsIGlhbmFOYW1lLCBvZmZzZXQsIHogfSA9XG4gICAgICAgICAgICBQYXJzZUlTT0RhdGVUaW1lKFRvU3RyaW5nKHJlbGF0aXZlVG8pKSk7XG4gICAgICAgIGlmIChpYW5hTmFtZSlcbiAgICAgICAgICAgIHRpbWVab25lID0gaWFuYU5hbWU7XG4gICAgICAgIGlmICh6KSB7XG4gICAgICAgICAgICBvZmZzZXRCZWhhdmlvdXIgPSAnZXhhY3QnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFvZmZzZXQpIHtcbiAgICAgICAgICAgIG9mZnNldEJlaGF2aW91ciA9ICd3YWxsJztcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNhbGVuZGFyKVxuICAgICAgICAgICAgY2FsZW5kYXIgPSBHZXRJU084NjAxQ2FsZW5kYXIoKTtcbiAgICAgICAgY2FsZW5kYXIgPSBUb1RlbXBvcmFsQ2FsZW5kYXIoY2FsZW5kYXIpO1xuICAgICAgICBtYXRjaE1pbnV0ZXMgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAodGltZVpvbmUpIHtcbiAgICAgICAgdGltZVpvbmUgPSBUb1RlbXBvcmFsVGltZVpvbmUodGltZVpvbmUpO1xuICAgICAgICBsZXQgb2Zmc2V0TnMgPSAwO1xuICAgICAgICBpZiAob2Zmc2V0QmVoYXZpb3VyID09PSAnb3B0aW9uJylcbiAgICAgICAgICAgIG9mZnNldE5zID0gUGFyc2VUaW1lWm9uZU9mZnNldFN0cmluZyhUb1N0cmluZyhvZmZzZXQpKTtcbiAgICAgICAgY29uc3QgZXBvY2hOYW5vc2Vjb25kcyA9IEludGVycHJldElTT0RhdGVUaW1lT2Zmc2V0KHllYXIsIG1vbnRoLCBkYXksIGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZCwgbWljcm9zZWNvbmQsIG5hbm9zZWNvbmQsIG9mZnNldEJlaGF2aW91ciwgb2Zmc2V0TnMsIHRpbWVab25lLCAnY29tcGF0aWJsZScsICdyZWplY3QnLCBtYXRjaE1pbnV0ZXMpO1xuICAgICAgICByZXR1cm4gQ3JlYXRlVGVtcG9yYWxab25lZERhdGVUaW1lKGVwb2NoTmFub3NlY29uZHMsIHRpbWVab25lLCBjYWxlbmRhcik7XG4gICAgfVxuICAgIHJldHVybiBDcmVhdGVUZW1wb3JhbERhdGUoeWVhciwgbW9udGgsIGRheSwgY2FsZW5kYXIpO1xufVxuZnVuY3Rpb24gVmFsaWRhdGVUZW1wb3JhbFVuaXRSYW5nZShsYXJnZXN0VW5pdCwgc21hbGxlc3RVbml0KSB7XG4gICAgaWYgKEFMTE9XRURfVU5JVFMuaW5kZXhPZihsYXJnZXN0VW5pdCkgPiBBTExPV0VEX1VOSVRTLmluZGV4T2Yoc21hbGxlc3RVbml0KSkge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgbGFyZ2VzdFVuaXQgJHtsYXJnZXN0VW5pdH0gY2Fubm90IGJlIHNtYWxsZXIgdGhhbiBzbWFsbGVzdFVuaXQgJHtzbWFsbGVzdFVuaXR9YCk7XG4gICAgfVxufVxuZnVuY3Rpb24gRGVmYXVsdFRlbXBvcmFsTGFyZ2VzdFVuaXQoeWVhcnMsIG1vbnRocywgd2Vla3MsIGRheXMsIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBtaWxsaXNlY29uZHMsIG1pY3Jvc2Vjb25kcywgbmFub3NlY29uZHMpIHtcbiAgICBjb25zdCBzaW5ndWxhciA9IG5ldyBNYXAoU0lOR1VMQVJfUExVUkFMX1VOSVRTKTtcbiAgICBmb3IgKGNvbnN0IFtwcm9wLCB2XSBvZiBbXG4gICAgICAgIFsneWVhcnMnLCB5ZWFyc10sXG4gICAgICAgIFsnbW9udGhzJywgbW9udGhzXSxcbiAgICAgICAgWyd3ZWVrcycsIHdlZWtzXSxcbiAgICAgICAgWydkYXlzJywgZGF5c10sXG4gICAgICAgIFsnaG91cnMnLCBob3Vyc10sXG4gICAgICAgIFsnbWludXRlcycsIG1pbnV0ZXNdLFxuICAgICAgICBbJ3NlY29uZHMnLCBzZWNvbmRzXSxcbiAgICAgICAgWydtaWxsaXNlY29uZHMnLCBtaWxsaXNlY29uZHNdLFxuICAgICAgICBbJ21pY3Jvc2Vjb25kcycsIG1pY3Jvc2Vjb25kc10sXG4gICAgICAgIFsnbmFub3NlY29uZHMnLCBuYW5vc2Vjb25kc11cbiAgICBdKSB7XG4gICAgICAgIGlmICh2ICE9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIHNpbmd1bGFyLmdldChwcm9wKTtcbiAgICB9XG4gICAgcmV0dXJuICduYW5vc2Vjb25kJztcbn1cbmZ1bmN0aW9uIExhcmdlck9mVHdvVGVtcG9yYWxVbml0cyh1bml0MSwgdW5pdDIpIHtcbiAgICBpZiAoQUxMT1dFRF9VTklUUy5pbmRleE9mKHVuaXQxKSA+IEFMTE9XRURfVU5JVFMuaW5kZXhPZih1bml0MikpXG4gICAgICAgIHJldHVybiB1bml0MjtcbiAgICByZXR1cm4gdW5pdDE7XG59XG5mdW5jdGlvbiBUb1BhcnRpYWxSZWNvcmQoYmFnUGFyYW0sIGZpZWxkc1BhcmFtKSB7XG4gICAgLy8gRXh0ZXJuYWwgY2FsbGVycyBhcmUgbGltaXRlZCB0byBzcGVjaWZpYyB0eXBlcywgYnV0IHRoaXMgZnVuY3Rpb24nc1xuICAgIC8vIGltcGxlbWVudGF0aW9uIHVzZXMgZ2VuZXJpYyBwcm9wZXJ0eSB0eXBlcy4gVGhlIGNhc3RzIGJlbG93IChhbmQgYXQgdGhlXG4gICAgLy8gZW5kKSBjb252ZXJ0IHRvL2Zyb20gZ2VuZXJpYyByZWNvcmRzLlxuICAgIGNvbnN0IGJhZyA9IGJhZ1BhcmFtO1xuICAgIGNvbnN0IGZpZWxkcyA9IGZpZWxkc1BhcmFtO1xuICAgIGxldCBhbnkgPSBmYWxzZTtcbiAgICBsZXQgcmVzdWx0ID0ge307XG4gICAgZm9yIChjb25zdCBwcm9wZXJ0eSBvZiBmaWVsZHMpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBiYWdbcHJvcGVydHldO1xuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgYW55ID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChCVUlMVElOX0NBU1RTLmhhcyhwcm9wZXJ0eSkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRbcHJvcGVydHldID0gQlVJTFRJTl9DQVNUUy5nZXQocHJvcGVydHkpKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdFtwcm9wZXJ0eV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYW55ID8gcmVzdWx0IDogZmFsc2U7XG59XG5mdW5jdGlvbiBQcmVwYXJlVGVtcG9yYWxGaWVsZHMoYmFnUGFyYW0sIGZpZWxkc1BhcmFtKSB7XG4gICAgLy8gRXh0ZXJuYWwgY2FsbGVycyBhcmUgbGltaXRlZCB0byBzcGVjaWZpYyB0eXBlcywgYnV0IHRoaXMgZnVuY3Rpb24nc1xuICAgIC8vIGltcGxlbWVudGF0aW9uIHVzZXMgZ2VuZXJpYyBwcm9wZXJ0eSB0eXBlcy4gVGhlIGNhc3RzIGJlbG93IChhbmQgYXQgdGhlXG4gICAgLy8gZW5kKSBjb252ZXJ0IHRvL2Zyb20gZ2VuZXJpYyByZWNvcmRzLlxuICAgIGNvbnN0IGJhZyA9IGJhZ1BhcmFtO1xuICAgIGNvbnN0IGZpZWxkcyA9IGZpZWxkc1BhcmFtO1xuICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgIGxldCBhbnkgPSBmYWxzZTtcbiAgICBmb3IgKGNvbnN0IGZpZWxkUmVjb3JkIG9mIGZpZWxkcykge1xuICAgICAgICBjb25zdCBbcHJvcGVydHksIGRlZmF1bHRWYWx1ZV0gPSBmaWVsZFJlY29yZDtcbiAgICAgICAgbGV0IHZhbHVlID0gYmFnW3Byb3BlcnR5XTtcbiAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmIChmaWVsZFJlY29yZC5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGByZXF1aXJlZCBwcm9wZXJ0eSAnJHtwcm9wZXJ0eX0nIG1pc3Npbmcgb3IgdW5kZWZpbmVkYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YWx1ZSA9IGRlZmF1bHRWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGFueSA9IHRydWU7XG4gICAgICAgICAgICBpZiAoQlVJTFRJTl9DQVNUUy5oYXMocHJvcGVydHkpKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBCVUlMVElOX0NBU1RTLmdldChwcm9wZXJ0eSkodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlc3VsdFtwcm9wZXJ0eV0gPSB2YWx1ZTtcbiAgICB9XG4gICAgaWYgKCFhbnkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbm8gc3VwcG9ydGVkIHByb3BlcnRpZXMgZm91bmQnKTtcbiAgICB9XG4gICAgaWYgKChyZXN1bHRbJ2VyYSddID09PSB1bmRlZmluZWQpICE9PVxuICAgICAgICAocmVzdWx0WydlcmFZZWFyJ10gPT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJwcm9wZXJ0aWVzICdlcmEnIGFuZCAnZXJhWWVhcicgbXVzdCBiZSBwcm92aWRlZCB0b2dldGhlclwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8vIGZpZWxkIGFjY2VzcyBpbiB0aGUgZm9sbG93aW5nIG9wZXJhdGlvbnMgaXMgaW50ZW50aW9uYWxseSBhbHBoYWJldGljYWxcbmZ1bmN0aW9uIFRvVGVtcG9yYWxEYXRlRmllbGRzKGJhZywgZmllbGROYW1lcykge1xuICAgIGNvbnN0IGVudHJpZXMgPSBbXG4gICAgICAgIFsnZGF5JywgdW5kZWZpbmVkXSxcbiAgICAgICAgWydtb250aCcsIHVuZGVmaW5lZF0sXG4gICAgICAgIFsnbW9udGhDb2RlJywgdW5kZWZpbmVkXSxcbiAgICAgICAgWyd5ZWFyJywgdW5kZWZpbmVkXVxuICAgIF07XG4gICAgLy8gQWRkIGV4dHJhIGZpZWxkcyBmcm9tIHRoZSBjYWxlbmRhciBhdCB0aGUgZW5kXG4gICAgZmllbGROYW1lcy5mb3JFYWNoKChmaWVsZE5hbWUpID0+IHtcbiAgICAgICAgaWYgKCFlbnRyaWVzLnNvbWUoKFtuYW1lXSkgPT4gbmFtZSA9PT0gZmllbGROYW1lKSkge1xuICAgICAgICAgICAgZW50cmllcy5wdXNoKFtmaWVsZE5hbWUsIHVuZGVmaW5lZF0pO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIFByZXBhcmVUZW1wb3JhbEZpZWxkcyhiYWcsIGVudHJpZXMpO1xufVxuZnVuY3Rpb24gVG9UZW1wb3JhbERhdGVUaW1lRmllbGRzKGJhZywgZmllbGROYW1lcykge1xuICAgIGNvbnN0IGVudHJpZXMgPSBbXG4gICAgICAgIFsnZGF5JywgdW5kZWZpbmVkXSxcbiAgICAgICAgWydob3VyJywgMF0sXG4gICAgICAgIFsnbWljcm9zZWNvbmQnLCAwXSxcbiAgICAgICAgWydtaWxsaXNlY29uZCcsIDBdLFxuICAgICAgICBbJ21pbnV0ZScsIDBdLFxuICAgICAgICBbJ21vbnRoJywgdW5kZWZpbmVkXSxcbiAgICAgICAgWydtb250aENvZGUnLCB1bmRlZmluZWRdLFxuICAgICAgICBbJ25hbm9zZWNvbmQnLCAwXSxcbiAgICAgICAgWydzZWNvbmQnLCAwXSxcbiAgICAgICAgWyd5ZWFyJywgdW5kZWZpbmVkXVxuICAgIF07XG4gICAgLy8gQWRkIGV4dHJhIGZpZWxkcyBmcm9tIHRoZSBjYWxlbmRhciBhdCB0aGUgZW5kXG4gICAgZmllbGROYW1lcy5mb3JFYWNoKChmaWVsZE5hbWUpID0+IHtcbiAgICAgICAgaWYgKCFlbnRyaWVzLnNvbWUoKFtuYW1lXSkgPT4gbmFtZSA9PT0gZmllbGROYW1lKSkge1xuICAgICAgICAgICAgZW50cmllcy5wdXNoKFtmaWVsZE5hbWUsIHVuZGVmaW5lZF0pO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIFByZXBhcmVUZW1wb3JhbEZpZWxkcyhiYWcsIGVudHJpZXMpO1xufVxuZnVuY3Rpb24gVG9UZW1wb3JhbE1vbnRoRGF5RmllbGRzKGJhZywgZmllbGROYW1lcykge1xuICAgIGNvbnN0IGVudHJpZXMgPSBbXG4gICAgICAgIFsnZGF5JywgdW5kZWZpbmVkXSxcbiAgICAgICAgWydtb250aCcsIHVuZGVmaW5lZF0sXG4gICAgICAgIFsnbW9udGhDb2RlJywgdW5kZWZpbmVkXSxcbiAgICAgICAgWyd5ZWFyJywgdW5kZWZpbmVkXVxuICAgIF07XG4gICAgLy8gQWRkIGV4dHJhIGZpZWxkcyBmcm9tIHRoZSBjYWxlbmRhciBhdCB0aGUgZW5kXG4gICAgZmllbGROYW1lcy5mb3JFYWNoKChmaWVsZE5hbWUpID0+IHtcbiAgICAgICAgaWYgKCFlbnRyaWVzLnNvbWUoKFtuYW1lXSkgPT4gbmFtZSA9PT0gZmllbGROYW1lKSkge1xuICAgICAgICAgICAgZW50cmllcy5wdXNoKFtmaWVsZE5hbWUsIHVuZGVmaW5lZF0pO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIFByZXBhcmVUZW1wb3JhbEZpZWxkcyhiYWcsIGVudHJpZXMpO1xufVxuZnVuY3Rpb24gVG9UZW1wb3JhbFRpbWVSZWNvcmQoYmFnKSB7XG4gICAgcmV0dXJuIFByZXBhcmVUZW1wb3JhbEZpZWxkcyhiYWcsIFtcbiAgICAgICAgWydob3VyJywgMF0sXG4gICAgICAgIFsnbWljcm9zZWNvbmQnLCAwXSxcbiAgICAgICAgWydtaWxsaXNlY29uZCcsIDBdLFxuICAgICAgICBbJ21pbnV0ZScsIDBdLFxuICAgICAgICBbJ25hbm9zZWNvbmQnLCAwXSxcbiAgICAgICAgWydzZWNvbmQnLCAwXVxuICAgIF0pO1xufVxuZnVuY3Rpb24gVG9UZW1wb3JhbFllYXJNb250aEZpZWxkcyhiYWcsIGZpZWxkTmFtZXMpIHtcbiAgICBjb25zdCBlbnRyaWVzID0gW1xuICAgICAgICBbJ21vbnRoJywgdW5kZWZpbmVkXSxcbiAgICAgICAgWydtb250aENvZGUnLCB1bmRlZmluZWRdLFxuICAgICAgICBbJ3llYXInLCB1bmRlZmluZWRdXG4gICAgXTtcbiAgICAvLyBBZGQgZXh0cmEgZmllbGRzIGZyb20gdGhlIGNhbGVuZGFyIGF0IHRoZSBlbmRcbiAgICBmaWVsZE5hbWVzLmZvckVhY2goKGZpZWxkTmFtZSkgPT4ge1xuICAgICAgICBpZiAoIWVudHJpZXMuc29tZSgoW25hbWVdKSA9PiBuYW1lID09PSBmaWVsZE5hbWUpKSB7XG4gICAgICAgICAgICBlbnRyaWVzLnB1c2goW2ZpZWxkTmFtZSwgdW5kZWZpbmVkXSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gUHJlcGFyZVRlbXBvcmFsRmllbGRzKGJhZywgZW50cmllcyk7XG59XG5mdW5jdGlvbiBUb1RlbXBvcmFsWm9uZWREYXRlVGltZUZpZWxkcyhiYWcsIGZpZWxkTmFtZXMpIHtcbiAgICBjb25zdCBlbnRyaWVzID0gW1xuICAgICAgICBbJ2RheScsIHVuZGVmaW5lZF0sXG4gICAgICAgIFsnaG91cicsIDBdLFxuICAgICAgICBbJ21pY3Jvc2Vjb25kJywgMF0sXG4gICAgICAgIFsnbWlsbGlzZWNvbmQnLCAwXSxcbiAgICAgICAgWydtaW51dGUnLCAwXSxcbiAgICAgICAgWydtb250aCcsIHVuZGVmaW5lZF0sXG4gICAgICAgIFsnbW9udGhDb2RlJywgdW5kZWZpbmVkXSxcbiAgICAgICAgWyduYW5vc2Vjb25kJywgMF0sXG4gICAgICAgIFsnc2Vjb25kJywgMF0sXG4gICAgICAgIFsneWVhcicsIHVuZGVmaW5lZF0sXG4gICAgICAgIFsnb2Zmc2V0JywgdW5kZWZpbmVkXSxcbiAgICAgICAgWyd0aW1lWm9uZSddXG4gICAgXTtcbiAgICAvLyBBZGQgZXh0cmEgZmllbGRzIGZyb20gdGhlIGNhbGVuZGFyIGF0IHRoZSBlbmRcbiAgICBmaWVsZE5hbWVzLmZvckVhY2goKGZpZWxkTmFtZSkgPT4ge1xuICAgICAgICBpZiAoIWVudHJpZXMuc29tZSgoW25hbWVdKSA9PiBuYW1lID09PSBmaWVsZE5hbWUpKSB7XG4gICAgICAgICAgICBlbnRyaWVzLnB1c2goW2ZpZWxkTmFtZSwgdW5kZWZpbmVkXSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gUHJlcGFyZVRlbXBvcmFsRmllbGRzKGJhZywgZW50cmllcyk7XG59XG5mdW5jdGlvbiBUb1RlbXBvcmFsRGF0ZShpdGVtUGFyYW0sIG9wdGlvbnMgPSBPYmplY3RDcmVhdGUkMihudWxsKSkge1xuICAgIGxldCBpdGVtID0gaXRlbVBhcmFtO1xuICAgIGlmIChJc09iamVjdChpdGVtKSkge1xuICAgICAgICBpZiAoSXNUZW1wb3JhbERhdGUoaXRlbSkpXG4gICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgaWYgKElzVGVtcG9yYWxab25lZERhdGVUaW1lKGl0ZW0pKSB7XG4gICAgICAgICAgICBpdGVtID0gQnVpbHRpblRpbWVab25lR2V0UGxhaW5EYXRlVGltZUZvcihHZXRTbG90KGl0ZW0sIFRJTUVfWk9ORSksIEdldFNsb3QoaXRlbSwgSU5TVEFOVCksIEdldFNsb3QoaXRlbSwgQ0FMRU5EQVIpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoSXNUZW1wb3JhbERhdGVUaW1lKGl0ZW0pKSB7XG4gICAgICAgICAgICByZXR1cm4gQ3JlYXRlVGVtcG9yYWxEYXRlKEdldFNsb3QoaXRlbSwgSVNPX1lFQVIpLCBHZXRTbG90KGl0ZW0sIElTT19NT05USCksIEdldFNsb3QoaXRlbSwgSVNPX0RBWSksIEdldFNsb3QoaXRlbSwgQ0FMRU5EQVIpKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjYWxlbmRhciA9IEdldFRlbXBvcmFsQ2FsZW5kYXJXaXRoSVNPRGVmYXVsdChpdGVtKTtcbiAgICAgICAgY29uc3QgZmllbGROYW1lcyA9IENhbGVuZGFyRmllbGRzKGNhbGVuZGFyLCBbJ2RheScsICdtb250aCcsICdtb250aENvZGUnLCAneWVhciddKTtcbiAgICAgICAgY29uc3QgZmllbGRzID0gVG9UZW1wb3JhbERhdGVGaWVsZHMoaXRlbSwgZmllbGROYW1lcyk7XG4gICAgICAgIHJldHVybiBEYXRlRnJvbUZpZWxkcyhjYWxlbmRhciwgZmllbGRzLCBvcHRpb25zKTtcbiAgICB9XG4gICAgVG9UZW1wb3JhbE92ZXJmbG93KG9wdGlvbnMpOyAvLyB2YWxpZGF0ZSBhbmQgaWdub3JlXG4gICAgY29uc3QgeyB5ZWFyLCBtb250aCwgZGF5LCBjYWxlbmRhciwgeiB9ID0gUGFyc2VUZW1wb3JhbERhdGVTdHJpbmcoVG9TdHJpbmcoaXRlbSkpO1xuICAgIGlmICh6KVxuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignWiBkZXNpZ25hdG9yIG5vdCBzdXBwb3J0ZWQgZm9yIFBsYWluRGF0ZScpO1xuICAgIGNvbnN0IFRlbXBvcmFsUGxhaW5EYXRlID0gR2V0SW50cmluc2ljKCclVGVtcG9yYWwuUGxhaW5EYXRlJScpO1xuICAgIHJldHVybiBuZXcgVGVtcG9yYWxQbGFpbkRhdGUoeWVhciwgbW9udGgsIGRheSwgY2FsZW5kYXIpOyAvLyBpbmNsdWRlIHZhbGlkYXRpb25cbn1cbmZ1bmN0aW9uIEludGVycHJldFRlbXBvcmFsRGF0ZVRpbWVGaWVsZHMoY2FsZW5kYXIsIGZpZWxkcywgb3B0aW9ucykge1xuICAgIGxldCB7IGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZCwgbWljcm9zZWNvbmQsIG5hbm9zZWNvbmQgfSA9IFRvVGVtcG9yYWxUaW1lUmVjb3JkKGZpZWxkcyk7XG4gICAgY29uc3Qgb3ZlcmZsb3cgPSBUb1RlbXBvcmFsT3ZlcmZsb3cob3B0aW9ucyk7XG4gICAgY29uc3QgZGF0ZSA9IERhdGVGcm9tRmllbGRzKGNhbGVuZGFyLCBmaWVsZHMsIG9wdGlvbnMpO1xuICAgIGNvbnN0IHllYXIgPSBHZXRTbG90KGRhdGUsIElTT19ZRUFSKTtcbiAgICBjb25zdCBtb250aCA9IEdldFNsb3QoZGF0ZSwgSVNPX01PTlRIKTtcbiAgICBjb25zdCBkYXkgPSBHZXRTbG90KGRhdGUsIElTT19EQVkpO1xuICAgICh7IGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZCwgbWljcm9zZWNvbmQsIG5hbm9zZWNvbmQgfSA9IFJlZ3VsYXRlVGltZShob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQsIG1pY3Jvc2Vjb25kLCBuYW5vc2Vjb25kLCBvdmVyZmxvdykpO1xuICAgIHJldHVybiB7IHllYXIsIG1vbnRoLCBkYXksIGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZCwgbWljcm9zZWNvbmQsIG5hbm9zZWNvbmQgfTtcbn1cbmZ1bmN0aW9uIFRvVGVtcG9yYWxEYXRlVGltZShpdGVtLCBvcHRpb25zID0gT2JqZWN0Q3JlYXRlJDIobnVsbCkpIHtcbiAgICBsZXQgeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kLCBtaWNyb3NlY29uZCwgbmFub3NlY29uZCwgY2FsZW5kYXI7XG4gICAgaWYgKElzT2JqZWN0KGl0ZW0pKSB7XG4gICAgICAgIGlmIChJc1RlbXBvcmFsRGF0ZVRpbWUoaXRlbSkpXG4gICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgaWYgKElzVGVtcG9yYWxab25lZERhdGVUaW1lKGl0ZW0pKSB7XG4gICAgICAgICAgICByZXR1cm4gQnVpbHRpblRpbWVab25lR2V0UGxhaW5EYXRlVGltZUZvcihHZXRTbG90KGl0ZW0sIFRJTUVfWk9ORSksIEdldFNsb3QoaXRlbSwgSU5TVEFOVCksIEdldFNsb3QoaXRlbSwgQ0FMRU5EQVIpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoSXNUZW1wb3JhbERhdGUoaXRlbSkpIHtcbiAgICAgICAgICAgIHJldHVybiBDcmVhdGVUZW1wb3JhbERhdGVUaW1lKEdldFNsb3QoaXRlbSwgSVNPX1lFQVIpLCBHZXRTbG90KGl0ZW0sIElTT19NT05USCksIEdldFNsb3QoaXRlbSwgSVNPX0RBWSksIDAsIDAsIDAsIDAsIDAsIDAsIEdldFNsb3QoaXRlbSwgQ0FMRU5EQVIpKTtcbiAgICAgICAgfVxuICAgICAgICBjYWxlbmRhciA9IEdldFRlbXBvcmFsQ2FsZW5kYXJXaXRoSVNPRGVmYXVsdChpdGVtKTtcbiAgICAgICAgY29uc3QgZmllbGROYW1lcyA9IENhbGVuZGFyRmllbGRzKGNhbGVuZGFyLCBbXG4gICAgICAgICAgICAnZGF5JyxcbiAgICAgICAgICAgICdob3VyJyxcbiAgICAgICAgICAgICdtaWNyb3NlY29uZCcsXG4gICAgICAgICAgICAnbWlsbGlzZWNvbmQnLFxuICAgICAgICAgICAgJ21pbnV0ZScsXG4gICAgICAgICAgICAnbW9udGgnLFxuICAgICAgICAgICAgJ21vbnRoQ29kZScsXG4gICAgICAgICAgICAnbmFub3NlY29uZCcsXG4gICAgICAgICAgICAnc2Vjb25kJyxcbiAgICAgICAgICAgICd5ZWFyJ1xuICAgICAgICBdKTtcbiAgICAgICAgY29uc3QgZmllbGRzID0gVG9UZW1wb3JhbERhdGVUaW1lRmllbGRzKGl0ZW0sIGZpZWxkTmFtZXMpO1xuICAgICAgICAoeyB5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQsIG1pY3Jvc2Vjb25kLCBuYW5vc2Vjb25kIH0gPSBJbnRlcnByZXRUZW1wb3JhbERhdGVUaW1lRmllbGRzKGNhbGVuZGFyLCBmaWVsZHMsIG9wdGlvbnMpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIFRvVGVtcG9yYWxPdmVyZmxvdyhvcHRpb25zKTsgLy8gdmFsaWRhdGUgYW5kIGlnbm9yZVxuICAgICAgICBsZXQgejtcbiAgICAgICAgKHsgeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kLCBtaWNyb3NlY29uZCwgbmFub3NlY29uZCwgY2FsZW5kYXIsIHogfSA9XG4gICAgICAgICAgICBQYXJzZVRlbXBvcmFsRGF0ZVRpbWVTdHJpbmcoVG9TdHJpbmcoaXRlbSkpKTtcbiAgICAgICAgaWYgKHopXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignWiBkZXNpZ25hdG9yIG5vdCBzdXBwb3J0ZWQgZm9yIFBsYWluRGF0ZVRpbWUnKTtcbiAgICAgICAgUmVqZWN0RGF0ZVRpbWUoeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kLCBtaWNyb3NlY29uZCwgbmFub3NlY29uZCk7XG4gICAgICAgIGlmIChjYWxlbmRhciA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgY2FsZW5kYXIgPSBHZXRJU084NjAxQ2FsZW5kYXIoKTtcbiAgICAgICAgY2FsZW5kYXIgPSBUb1RlbXBvcmFsQ2FsZW5kYXIoY2FsZW5kYXIpO1xuICAgIH1cbiAgICByZXR1cm4gQ3JlYXRlVGVtcG9yYWxEYXRlVGltZSh5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQsIG1pY3Jvc2Vjb25kLCBuYW5vc2Vjb25kLCBjYWxlbmRhcik7XG59XG5mdW5jdGlvbiBUb1RlbXBvcmFsRHVyYXRpb24oaXRlbSkge1xuICAgIGxldCB5ZWFycywgbW9udGhzLCB3ZWVrcywgZGF5cywgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc2Vjb25kcywgbWljcm9zZWNvbmRzLCBuYW5vc2Vjb25kcztcbiAgICBpZiAoSXNPYmplY3QoaXRlbSkpIHtcbiAgICAgICAgaWYgKElzVGVtcG9yYWxEdXJhdGlvbihpdGVtKSlcbiAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICAoeyB5ZWFycywgbW9udGhzLCB3ZWVrcywgZGF5cywgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc2Vjb25kcywgbWljcm9zZWNvbmRzLCBuYW5vc2Vjb25kcyB9ID1cbiAgICAgICAgICAgIFRvVGVtcG9yYWxEdXJhdGlvblJlY29yZChpdGVtKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAoeyB5ZWFycywgbW9udGhzLCB3ZWVrcywgZGF5cywgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc2Vjb25kcywgbWljcm9zZWNvbmRzLCBuYW5vc2Vjb25kcyB9ID1cbiAgICAgICAgICAgIFBhcnNlVGVtcG9yYWxEdXJhdGlvblN0cmluZyhUb1N0cmluZyhpdGVtKSkpO1xuICAgIH1cbiAgICBjb25zdCBUZW1wb3JhbER1cmF0aW9uID0gR2V0SW50cmluc2ljKCclVGVtcG9yYWwuRHVyYXRpb24lJyk7XG4gICAgcmV0dXJuIG5ldyBUZW1wb3JhbER1cmF0aW9uKHllYXJzLCBtb250aHMsIHdlZWtzLCBkYXlzLCBob3VycywgbWludXRlcywgc2Vjb25kcywgbWlsbGlzZWNvbmRzLCBtaWNyb3NlY29uZHMsIG5hbm9zZWNvbmRzKTtcbn1cbmZ1bmN0aW9uIFRvVGVtcG9yYWxJbnN0YW50KGl0ZW0pIHtcbiAgICBpZiAoSXNUZW1wb3JhbEluc3RhbnQoaXRlbSkpXG4gICAgICAgIHJldHVybiBpdGVtO1xuICAgIGlmIChJc1RlbXBvcmFsWm9uZWREYXRlVGltZShpdGVtKSkge1xuICAgICAgICBjb25zdCBUZW1wb3JhbEluc3RhbnQgPSBHZXRJbnRyaW5zaWMoJyVUZW1wb3JhbC5JbnN0YW50JScpO1xuICAgICAgICByZXR1cm4gbmV3IFRlbXBvcmFsSW5zdGFudChHZXRTbG90KGl0ZW0sIEVQT0NITkFOT1NFQ09ORFMpKTtcbiAgICB9XG4gICAgY29uc3QgbnMgPSBQYXJzZVRlbXBvcmFsSW5zdGFudChUb1N0cmluZyhpdGVtKSk7XG4gICAgY29uc3QgVGVtcG9yYWxJbnN0YW50ID0gR2V0SW50cmluc2ljKCclVGVtcG9yYWwuSW5zdGFudCUnKTtcbiAgICByZXR1cm4gbmV3IFRlbXBvcmFsSW5zdGFudChucyk7XG59XG5mdW5jdGlvbiBUb1RlbXBvcmFsTW9udGhEYXkoaXRlbSwgb3B0aW9ucyA9IE9iamVjdENyZWF0ZSQyKG51bGwpKSB7XG4gICAgaWYgKElzT2JqZWN0KGl0ZW0pKSB7XG4gICAgICAgIGlmIChJc1RlbXBvcmFsTW9udGhEYXkoaXRlbSkpXG4gICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgbGV0IGNhbGVuZGFyLCBjYWxlbmRhckFic2VudDtcbiAgICAgICAgaWYgKEhhc1Nsb3QoaXRlbSwgQ0FMRU5EQVIpKSB7XG4gICAgICAgICAgICBjYWxlbmRhciA9IEdldFNsb3QoaXRlbSwgQ0FMRU5EQVIpO1xuICAgICAgICAgICAgY2FsZW5kYXJBYnNlbnQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBtYXliZVN0cmluZ0NhbGVuZGFyID0gaXRlbS5jYWxlbmRhcjtcbiAgICAgICAgICAgIGNhbGVuZGFyQWJzZW50ID0gbWF5YmVTdHJpbmdDYWxlbmRhciA9PT0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKG1heWJlU3RyaW5nQ2FsZW5kYXIgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICBtYXliZVN0cmluZ0NhbGVuZGFyID0gR2V0SVNPODYwMUNhbGVuZGFyKCk7XG4gICAgICAgICAgICBjYWxlbmRhciA9IFRvVGVtcG9yYWxDYWxlbmRhcihtYXliZVN0cmluZ0NhbGVuZGFyKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmaWVsZE5hbWVzID0gQ2FsZW5kYXJGaWVsZHMoY2FsZW5kYXIsIFsnZGF5JywgJ21vbnRoJywgJ21vbnRoQ29kZScsICd5ZWFyJ10pO1xuICAgICAgICBjb25zdCBmaWVsZHMgPSBUb1RlbXBvcmFsTW9udGhEYXlGaWVsZHMoaXRlbSwgZmllbGROYW1lcyk7XG4gICAgICAgIC8vIENhbGxlcnMgd2hvIG9taXQgdGhlIGNhbGVuZGFyIGFyZSBub3Qgd3JpdGluZyBjYWxlbmRhci1pbmRlcGVuZGVudFxuICAgICAgICAvLyBjb2RlLiBJbiB0aGF0IGNhc2UsIGBtb250aENvZGVgL2B5ZWFyYCBjYW4gYmUgb21pdHRlZDsgYG1vbnRoYCBhbmRcbiAgICAgICAgLy8gYGRheWAgYXJlIHN1ZmZpY2llbnQuIEFkZCBhIGB5ZWFyYCB0byBzYXRpc2Z5IGNhbGVuZGFyIHZhbGlkYXRpb24uXG4gICAgICAgIGlmIChjYWxlbmRhckFic2VudCAmJiBmaWVsZHMubW9udGggIT09IHVuZGVmaW5lZCAmJiBmaWVsZHMubW9udGhDb2RlID09PSB1bmRlZmluZWQgJiYgZmllbGRzLnllYXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZmllbGRzLnllYXIgPSAxOTcyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBNb250aERheUZyb21GaWVsZHMoY2FsZW5kYXIsIGZpZWxkcywgb3B0aW9ucyk7XG4gICAgfVxuICAgIFRvVGVtcG9yYWxPdmVyZmxvdyhvcHRpb25zKTsgLy8gdmFsaWRhdGUgYW5kIGlnbm9yZVxuICAgIGxldCB7IG1vbnRoLCBkYXksIHJlZmVyZW5jZUlTT1llYXIsIGNhbGVuZGFyOiBtYXliZVN0cmluZ0NhbGVuZGFyIH0gPSBQYXJzZVRlbXBvcmFsTW9udGhEYXlTdHJpbmcoVG9TdHJpbmcoaXRlbSkpO1xuICAgIGxldCBjYWxlbmRhciA9IG1heWJlU3RyaW5nQ2FsZW5kYXI7XG4gICAgaWYgKGNhbGVuZGFyID09PSB1bmRlZmluZWQpXG4gICAgICAgIGNhbGVuZGFyID0gR2V0SVNPODYwMUNhbGVuZGFyKCk7XG4gICAgY2FsZW5kYXIgPSBUb1RlbXBvcmFsQ2FsZW5kYXIoY2FsZW5kYXIpO1xuICAgIGlmIChyZWZlcmVuY2VJU09ZZWFyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgUmVqZWN0SVNPRGF0ZSgxOTcyLCBtb250aCwgZGF5KTtcbiAgICAgICAgcmV0dXJuIENyZWF0ZVRlbXBvcmFsTW9udGhEYXkobW9udGgsIGRheSwgY2FsZW5kYXIpO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSBDcmVhdGVUZW1wb3JhbE1vbnRoRGF5KG1vbnRoLCBkYXksIGNhbGVuZGFyLCByZWZlcmVuY2VJU09ZZWFyKTtcbiAgICBjb25zdCBjYW5vbmljYWxPcHRpb25zID0gT2JqZWN0Q3JlYXRlJDIobnVsbCk7XG4gICAgcmV0dXJuIE1vbnRoRGF5RnJvbUZpZWxkcyhjYWxlbmRhciwgcmVzdWx0LCBjYW5vbmljYWxPcHRpb25zKTtcbn1cbmZ1bmN0aW9uIFRvVGVtcG9yYWxUaW1lKGl0ZW1QYXJhbSwgb3ZlcmZsb3cgPSAnY29uc3RyYWluJykge1xuICAgIGxldCBpdGVtID0gaXRlbVBhcmFtO1xuICAgIGxldCBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQsIG1pY3Jvc2Vjb25kLCBuYW5vc2Vjb25kLCBjYWxlbmRhcjtcbiAgICBpZiAoSXNPYmplY3QoaXRlbSkpIHtcbiAgICAgICAgaWYgKElzVGVtcG9yYWxUaW1lKGl0ZW0pKVxuICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgIGlmIChJc1RlbXBvcmFsWm9uZWREYXRlVGltZShpdGVtKSkge1xuICAgICAgICAgICAgaXRlbSA9IEJ1aWx0aW5UaW1lWm9uZUdldFBsYWluRGF0ZVRpbWVGb3IoR2V0U2xvdChpdGVtLCBUSU1FX1pPTkUpLCBHZXRTbG90KGl0ZW0sIElOU1RBTlQpLCBHZXRTbG90KGl0ZW0sIENBTEVOREFSKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKElzVGVtcG9yYWxEYXRlVGltZShpdGVtKSkge1xuICAgICAgICAgICAgY29uc3QgVGVtcG9yYWxQbGFpblRpbWUgPSBHZXRJbnRyaW5zaWMoJyVUZW1wb3JhbC5QbGFpblRpbWUlJyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFRlbXBvcmFsUGxhaW5UaW1lKEdldFNsb3QoaXRlbSwgSVNPX0hPVVIpLCBHZXRTbG90KGl0ZW0sIElTT19NSU5VVEUpLCBHZXRTbG90KGl0ZW0sIElTT19TRUNPTkQpLCBHZXRTbG90KGl0ZW0sIElTT19NSUxMSVNFQ09ORCksIEdldFNsb3QoaXRlbSwgSVNPX01JQ1JPU0VDT05EKSwgR2V0U2xvdChpdGVtLCBJU09fTkFOT1NFQ09ORCkpO1xuICAgICAgICB9XG4gICAgICAgIGNhbGVuZGFyID0gR2V0VGVtcG9yYWxDYWxlbmRhcldpdGhJU09EZWZhdWx0KGl0ZW0pO1xuICAgICAgICBpZiAoVG9TdHJpbmcoY2FsZW5kYXIpICE9PSAnaXNvODYwMScpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdQbGFpblRpbWUgY2FuIG9ubHkgaGF2ZSBpc284NjAxIGNhbGVuZGFyJyk7XG4gICAgICAgIH1cbiAgICAgICAgKHsgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kLCBtaWNyb3NlY29uZCwgbmFub3NlY29uZCB9ID0gVG9UZW1wb3JhbFRpbWVSZWNvcmQoaXRlbSkpO1xuICAgICAgICAoeyBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQsIG1pY3Jvc2Vjb25kLCBuYW5vc2Vjb25kIH0gPSBSZWd1bGF0ZVRpbWUoaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kLCBtaWNyb3NlY29uZCwgbmFub3NlY29uZCwgb3ZlcmZsb3cpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgICh7IGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZCwgbWljcm9zZWNvbmQsIG5hbm9zZWNvbmQsIGNhbGVuZGFyIH0gPSBQYXJzZVRlbXBvcmFsVGltZVN0cmluZyhUb1N0cmluZyhpdGVtKSkpO1xuICAgICAgICBSZWplY3RUaW1lKGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZCwgbWljcm9zZWNvbmQsIG5hbm9zZWNvbmQpO1xuICAgICAgICBpZiAoY2FsZW5kYXIgIT09IHVuZGVmaW5lZCAmJiBjYWxlbmRhciAhPT0gJ2lzbzg2MDEnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignUGxhaW5UaW1lIGNhbiBvbmx5IGhhdmUgaXNvODYwMSBjYWxlbmRhcicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IFRlbXBvcmFsUGxhaW5UaW1lID0gR2V0SW50cmluc2ljKCclVGVtcG9yYWwuUGxhaW5UaW1lJScpO1xuICAgIHJldHVybiBuZXcgVGVtcG9yYWxQbGFpblRpbWUoaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kLCBtaWNyb3NlY29uZCwgbmFub3NlY29uZCk7XG59XG5mdW5jdGlvbiBUb1RlbXBvcmFsWWVhck1vbnRoKGl0ZW0sIG9wdGlvbnMgPSBPYmplY3RDcmVhdGUkMihudWxsKSkge1xuICAgIGlmIChJc09iamVjdChpdGVtKSkge1xuICAgICAgICBpZiAoSXNUZW1wb3JhbFllYXJNb250aChpdGVtKSlcbiAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICBjb25zdCBjYWxlbmRhciA9IEdldFRlbXBvcmFsQ2FsZW5kYXJXaXRoSVNPRGVmYXVsdChpdGVtKTtcbiAgICAgICAgY29uc3QgZmllbGROYW1lcyA9IENhbGVuZGFyRmllbGRzKGNhbGVuZGFyLCBbJ21vbnRoJywgJ21vbnRoQ29kZScsICd5ZWFyJ10pO1xuICAgICAgICBjb25zdCBmaWVsZHMgPSBUb1RlbXBvcmFsWWVhck1vbnRoRmllbGRzKGl0ZW0sIGZpZWxkTmFtZXMpO1xuICAgICAgICByZXR1cm4gWWVhck1vbnRoRnJvbUZpZWxkcyhjYWxlbmRhciwgZmllbGRzLCBvcHRpb25zKTtcbiAgICB9XG4gICAgVG9UZW1wb3JhbE92ZXJmbG93KG9wdGlvbnMpOyAvLyB2YWxpZGF0ZSBhbmQgaWdub3JlXG4gICAgbGV0IHsgeWVhciwgbW9udGgsIHJlZmVyZW5jZUlTT0RheSwgY2FsZW5kYXI6IG1heWJlU3RyaW5nQ2FsZW5kYXIgfSA9IFBhcnNlVGVtcG9yYWxZZWFyTW9udGhTdHJpbmcoVG9TdHJpbmcoaXRlbSkpO1xuICAgIC8vIFRPRE86IHJlcGxhY2Ugd2l0aCB0ZXJuYXJ5P1xuICAgIGxldCBjYWxlbmRhciA9IG1heWJlU3RyaW5nQ2FsZW5kYXI7XG4gICAgaWYgKGNhbGVuZGFyID09PSB1bmRlZmluZWQpXG4gICAgICAgIGNhbGVuZGFyID0gR2V0SVNPODYwMUNhbGVuZGFyKCk7XG4gICAgY2FsZW5kYXIgPSBUb1RlbXBvcmFsQ2FsZW5kYXIoY2FsZW5kYXIpO1xuICAgIGlmIChyZWZlcmVuY2VJU09EYXkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBSZWplY3RJU09EYXRlKHllYXIsIG1vbnRoLCAxKTtcbiAgICAgICAgcmV0dXJuIENyZWF0ZVRlbXBvcmFsWWVhck1vbnRoKHllYXIsIG1vbnRoLCBjYWxlbmRhcik7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IENyZWF0ZVRlbXBvcmFsWWVhck1vbnRoKHllYXIsIG1vbnRoLCBjYWxlbmRhciwgcmVmZXJlbmNlSVNPRGF5KTtcbiAgICBjb25zdCBjYW5vbmljYWxPcHRpb25zID0gT2JqZWN0Q3JlYXRlJDIobnVsbCk7XG4gICAgcmV0dXJuIFllYXJNb250aEZyb21GaWVsZHMoY2FsZW5kYXIsIHJlc3VsdCwgY2Fub25pY2FsT3B0aW9ucyk7XG59XG5mdW5jdGlvbiBJbnRlcnByZXRJU09EYXRlVGltZU9mZnNldCh5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQsIG1pY3Jvc2Vjb25kLCBuYW5vc2Vjb25kLCBvZmZzZXRCZWhhdmlvdXIsIG9mZnNldE5zLCB0aW1lWm9uZSwgZGlzYW1iaWd1YXRpb24sIG9mZnNldE9wdCwgbWF0Y2hNaW51dGUpIHtcbiAgICBjb25zdCBEYXRlVGltZSA9IEdldEludHJpbnNpYygnJVRlbXBvcmFsLlBsYWluRGF0ZVRpbWUlJyk7XG4gICAgY29uc3QgZHQgPSBuZXcgRGF0ZVRpbWUoeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kLCBtaWNyb3NlY29uZCwgbmFub3NlY29uZCk7XG4gICAgaWYgKG9mZnNldEJlaGF2aW91ciA9PT0gJ3dhbGwnIHx8IG9mZnNldE9wdCA9PT0gJ2lnbm9yZScpIHtcbiAgICAgICAgLy8gU2ltcGxlIGNhc2U6IElTTyBzdHJpbmcgd2l0aG91dCBhIFRaIG9mZnNldCAob3IgY2FsbGVyIHdhbnRzIHRvIGlnbm9yZVxuICAgICAgICAvLyB0aGUgb2Zmc2V0KSwgc28ganVzdCBjb252ZXJ0IERhdGVUaW1lIHRvIEluc3RhbnQgaW4gdGhlIGdpdmVuIHRpbWUgem9uZVxuICAgICAgICBjb25zdCBpbnN0YW50ID0gQnVpbHRpblRpbWVab25lR2V0SW5zdGFudEZvcih0aW1lWm9uZSwgZHQsIGRpc2FtYmlndWF0aW9uKTtcbiAgICAgICAgcmV0dXJuIEdldFNsb3QoaW5zdGFudCwgRVBPQ0hOQU5PU0VDT05EUyk7XG4gICAgfVxuICAgIC8vIFRoZSBjYWxsZXIgd2FudHMgdGhlIG9mZnNldCB0byBhbHdheXMgd2luICgndXNlJykgT1IgdGhlIGNhbGxlciBpcyBPS1xuICAgIC8vIHdpdGggdGhlIG9mZnNldCB3aW5uaW5nICgncHJlZmVyJyBvciAncmVqZWN0JykgYXMgbG9uZyBhcyBpdCdzIHZhbGlkXG4gICAgLy8gZm9yIHRoaXMgdGltZXpvbmUgYW5kIGRhdGUvdGltZS5cbiAgICBpZiAob2Zmc2V0QmVoYXZpb3VyID09PSAnZXhhY3QnIHx8IG9mZnNldE9wdCA9PT0gJ3VzZScpIHtcbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBpbnN0YW50IGZvciB0aGUgaW5wdXQncyBkYXRlL3RpbWUgYW5kIG9mZnNldFxuICAgICAgICBjb25zdCBlcG9jaE5zID0gR2V0RXBvY2hGcm9tSVNPUGFydHMoeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kLCBtaWNyb3NlY29uZCwgbmFub3NlY29uZCk7XG4gICAgICAgIGlmIChlcG9jaE5zID09PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1pvbmVkRGF0ZVRpbWUgb3V0c2lkZSBvZiBzdXBwb3J0ZWQgcmFuZ2UnKTtcbiAgICAgICAgcmV0dXJuIEpTQkkuc3VidHJhY3QoZXBvY2hOcywgSlNCSS5CaWdJbnQob2Zmc2V0TnMpKTtcbiAgICB9XG4gICAgLy8gXCJwcmVmZXJcIiBvciBcInJlamVjdFwiXG4gICAgY29uc3QgcG9zc2libGVJbnN0YW50cyA9IEdldFBvc3NpYmxlSW5zdGFudHNGb3IodGltZVpvbmUsIGR0KTtcbiAgICBmb3IgKGNvbnN0IGNhbmRpZGF0ZSBvZiBwb3NzaWJsZUluc3RhbnRzKSB7XG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZU9mZnNldCA9IEdldE9mZnNldE5hbm9zZWNvbmRzRm9yKHRpbWVab25lLCBjYW5kaWRhdGUpO1xuICAgICAgICBjb25zdCByb3VuZGVkQ2FuZGlkYXRlT2Zmc2V0ID0gSlNCSS50b051bWJlcihSb3VuZE51bWJlclRvSW5jcmVtZW50KEpTQkkuQmlnSW50KGNhbmRpZGF0ZU9mZnNldCksIDYwZTksICdoYWxmRXhwYW5kJykpO1xuICAgICAgICBpZiAoY2FuZGlkYXRlT2Zmc2V0ID09PSBvZmZzZXROcyB8fCAobWF0Y2hNaW51dGUgJiYgcm91bmRlZENhbmRpZGF0ZU9mZnNldCA9PT0gb2Zmc2V0TnMpKSB7XG4gICAgICAgICAgICByZXR1cm4gR2V0U2xvdChjYW5kaWRhdGUsIEVQT0NITkFOT1NFQ09ORFMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIHRoZSB1c2VyLXByb3ZpZGVkIG9mZnNldCBkb2Vzbid0IG1hdGNoIGFueSBpbnN0YW50cyBmb3IgdGhpcyB0aW1lXG4gICAgLy8gem9uZSBhbmQgZGF0ZS90aW1lLlxuICAgIGlmIChvZmZzZXRPcHQgPT09ICdyZWplY3QnKSB7XG4gICAgICAgIGNvbnN0IG9mZnNldFN0ciA9IEZvcm1hdFRpbWVab25lT2Zmc2V0U3RyaW5nKG9mZnNldE5zKTtcbiAgICAgICAgY29uc3QgdGltZVpvbmVTdHJpbmcgPSBJc1RlbXBvcmFsVGltZVpvbmUodGltZVpvbmUpID8gR2V0U2xvdCh0aW1lWm9uZSwgVElNRVpPTkVfSUQpIDogJ3RpbWUgem9uZSc7XG4gICAgICAgIC8vIFRoZSB0c2MgZW1pdCBmb3IgdGhpcyBsaW5lIHJld3JpdGVzIHRvIGludm9rZSB0aGUgUGxhaW5EYXRlVGltZSdzIHZhbHVlT2YgbWV0aG9kLCBOT1RcbiAgICAgICAgLy8gdG9TdHJpbmcgKHdoaWNoIGlzIGludm9rZWQgYnkgTm9kZSB3aGVuIHVzaW5nIHRlbXBsYXRlIGxpdGVyYWxzIGRpcmVjdGx5KS5cbiAgICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9taWNyb3NvZnQvVHlwZVNjcmlwdC9pc3N1ZXMvMzk3NDQgZm9yIHRoZSBwcm9wb3NlZCBmaXggaW4gdHNjIGVtaXRcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYE9mZnNldCAke29mZnNldFN0cn0gaXMgaW52YWxpZCBmb3IgJHtkdC50b1N0cmluZygpfSBpbiAke3RpbWVab25lU3RyaW5nfWApO1xuICAgIH1cbiAgICAvLyBmYWxsIHRocm91Z2g6IG9mZnNldE9wdCA9PT0gJ3ByZWZlcicsIGJ1dCB0aGUgb2Zmc2V0IGRvZXNuJ3QgbWF0Y2hcbiAgICAvLyBzbyBmYWxsIGJhY2sgdG8gdXNlIHRoZSB0aW1lIHpvbmUgaW5zdGVhZC5cbiAgICBjb25zdCBpbnN0YW50ID0gRGlzYW1iaWd1YXRlUG9zc2libGVJbnN0YW50cyhwb3NzaWJsZUluc3RhbnRzLCB0aW1lWm9uZSwgZHQsIGRpc2FtYmlndWF0aW9uKTtcbiAgICByZXR1cm4gR2V0U2xvdChpbnN0YW50LCBFUE9DSE5BTk9TRUNPTkRTKTtcbn1cbmZ1bmN0aW9uIFRvVGVtcG9yYWxab25lZERhdGVUaW1lKGl0ZW0sIG9wdGlvbnMgPSBPYmplY3RDcmVhdGUkMihudWxsKSkge1xuICAgIGxldCB5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQsIG1pY3Jvc2Vjb25kLCBuYW5vc2Vjb25kLCB0aW1lWm9uZSwgb2Zmc2V0LCBjYWxlbmRhcjtcbiAgICBsZXQgbWF0Y2hNaW51dGUgPSBmYWxzZTtcbiAgICBsZXQgb2Zmc2V0QmVoYXZpb3VyID0gJ29wdGlvbic7XG4gICAgaWYgKElzT2JqZWN0KGl0ZW0pKSB7XG4gICAgICAgIGlmIChJc1RlbXBvcmFsWm9uZWREYXRlVGltZShpdGVtKSlcbiAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICBjYWxlbmRhciA9IEdldFRlbXBvcmFsQ2FsZW5kYXJXaXRoSVNPRGVmYXVsdChpdGVtKTtcbiAgICAgICAgY29uc3QgZmllbGROYW1lcyA9IENhbGVuZGFyRmllbGRzKGNhbGVuZGFyLCBbXG4gICAgICAgICAgICAnZGF5JyxcbiAgICAgICAgICAgICdob3VyJyxcbiAgICAgICAgICAgICdtaWNyb3NlY29uZCcsXG4gICAgICAgICAgICAnbWlsbGlzZWNvbmQnLFxuICAgICAgICAgICAgJ21pbnV0ZScsXG4gICAgICAgICAgICAnbW9udGgnLFxuICAgICAgICAgICAgJ21vbnRoQ29kZScsXG4gICAgICAgICAgICAnbmFub3NlY29uZCcsXG4gICAgICAgICAgICAnc2Vjb25kJyxcbiAgICAgICAgICAgICd5ZWFyJ1xuICAgICAgICBdKTtcbiAgICAgICAgY29uc3QgZmllbGRzID0gVG9UZW1wb3JhbFpvbmVkRGF0ZVRpbWVGaWVsZHMoaXRlbSwgZmllbGROYW1lcyk7XG4gICAgICAgICh7IHllYXIsIG1vbnRoLCBkYXksIGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZCwgbWljcm9zZWNvbmQsIG5hbm9zZWNvbmQgfSA9IEludGVycHJldFRlbXBvcmFsRGF0ZVRpbWVGaWVsZHMoY2FsZW5kYXIsIGZpZWxkcywgb3B0aW9ucykpO1xuICAgICAgICB0aW1lWm9uZSA9IFRvVGVtcG9yYWxUaW1lWm9uZShmaWVsZHMudGltZVpvbmUpO1xuICAgICAgICBvZmZzZXQgPSBmaWVsZHMub2Zmc2V0O1xuICAgICAgICBpZiAob2Zmc2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG9mZnNldEJlaGF2aW91ciA9ICd3YWxsJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9mZnNldCA9IFRvU3RyaW5nKG9mZnNldCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIFRvVGVtcG9yYWxPdmVyZmxvdyhvcHRpb25zKTsgLy8gdmFsaWRhdGUgYW5kIGlnbm9yZVxuICAgICAgICBsZXQgaWFuYU5hbWUsIHo7XG4gICAgICAgICh7IHllYXIsIG1vbnRoLCBkYXksIGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZCwgbWljcm9zZWNvbmQsIG5hbm9zZWNvbmQsIGlhbmFOYW1lLCBvZmZzZXQsIHosIGNhbGVuZGFyIH0gPVxuICAgICAgICAgICAgUGFyc2VUZW1wb3JhbFpvbmVkRGF0ZVRpbWVTdHJpbmcoVG9TdHJpbmcoaXRlbSkpKTtcbiAgICAgICAgaWYgKCFpYW5hTmFtZSlcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCd0aW1lIHpvbmUgSUQgcmVxdWlyZWQgaW4gYnJhY2tldHMnKTtcbiAgICAgICAgaWYgKHopIHtcbiAgICAgICAgICAgIG9mZnNldEJlaGF2aW91ciA9ICdleGFjdCc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIW9mZnNldCkge1xuICAgICAgICAgICAgb2Zmc2V0QmVoYXZpb3VyID0gJ3dhbGwnO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IFRlbXBvcmFsVGltZVpvbmUgPSBHZXRJbnRyaW5zaWMoJyVUZW1wb3JhbC5UaW1lWm9uZSUnKTtcbiAgICAgICAgdGltZVpvbmUgPSBuZXcgVGVtcG9yYWxUaW1lWm9uZShpYW5hTmFtZSk7XG4gICAgICAgIGlmICghY2FsZW5kYXIpXG4gICAgICAgICAgICBjYWxlbmRhciA9IEdldElTTzg2MDFDYWxlbmRhcigpO1xuICAgICAgICBjYWxlbmRhciA9IFRvVGVtcG9yYWxDYWxlbmRhcihjYWxlbmRhcik7XG4gICAgICAgIG1hdGNoTWludXRlID0gdHJ1ZTsgLy8gSVNPIHN0cmluZ3MgbWF5IHNwZWNpZnkgb2Zmc2V0IHdpdGggbGVzcyBwcmVjaXNpb25cbiAgICB9XG4gICAgbGV0IG9mZnNldE5zID0gMDtcbiAgICAvLyBUaGUgY29kZSBhYm92ZSBndWFyYW50ZWVzIHRoYXQgaWYgb2Zmc2V0QmVoYXZpb3VyID09PSAnb3B0aW9uJywgdGhlblxuICAgIC8vIGBvZmZzZXRgIGlzIG5vdCB1bmRlZmluZWQuXG4gICAgaWYgKG9mZnNldEJlaGF2aW91ciA9PT0gJ29wdGlvbicpXG4gICAgICAgIG9mZnNldE5zID0gUGFyc2VUaW1lWm9uZU9mZnNldFN0cmluZyhvZmZzZXQpO1xuICAgIGNvbnN0IGRpc2FtYmlndWF0aW9uID0gVG9UZW1wb3JhbERpc2FtYmlndWF0aW9uKG9wdGlvbnMpO1xuICAgIGNvbnN0IG9mZnNldE9wdCA9IFRvVGVtcG9yYWxPZmZzZXQob3B0aW9ucywgJ3JlamVjdCcpO1xuICAgIGNvbnN0IGVwb2NoTmFub3NlY29uZHMgPSBJbnRlcnByZXRJU09EYXRlVGltZU9mZnNldCh5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQsIG1pY3Jvc2Vjb25kLCBuYW5vc2Vjb25kLCBvZmZzZXRCZWhhdmlvdXIsIG9mZnNldE5zLCB0aW1lWm9uZSwgZGlzYW1iaWd1YXRpb24sIG9mZnNldE9wdCwgbWF0Y2hNaW51dGUpO1xuICAgIHJldHVybiBDcmVhdGVUZW1wb3JhbFpvbmVkRGF0ZVRpbWUoZXBvY2hOYW5vc2Vjb25kcywgdGltZVpvbmUsIGNhbGVuZGFyKTtcbn1cbmZ1bmN0aW9uIENyZWF0ZVRlbXBvcmFsRGF0ZVNsb3RzKHJlc3VsdCwgaXNvWWVhciwgaXNvTW9udGgsIGlzb0RheSwgY2FsZW5kYXIpIHtcbiAgICBSZWplY3RJU09EYXRlKGlzb1llYXIsIGlzb01vbnRoLCBpc29EYXkpO1xuICAgIFJlamVjdERhdGVSYW5nZShpc29ZZWFyLCBpc29Nb250aCwgaXNvRGF5KTtcbiAgICBDcmVhdGVTbG90cyhyZXN1bHQpO1xuICAgIFNldFNsb3QocmVzdWx0LCBJU09fWUVBUiwgaXNvWWVhcik7XG4gICAgU2V0U2xvdChyZXN1bHQsIElTT19NT05USCwgaXNvTW9udGgpO1xuICAgIFNldFNsb3QocmVzdWx0LCBJU09fREFZLCBpc29EYXkpO1xuICAgIFNldFNsb3QocmVzdWx0LCBDQUxFTkRBUiwgY2FsZW5kYXIpO1xuICAgIFNldFNsb3QocmVzdWx0LCBEQVRFX0JSQU5ELCB0cnVlKTtcbiAgICB7XG4gICAgICAgIE9iamVjdERlZmluZVByb3BlcnR5KHJlc3VsdCwgJ19yZXByXycsIHtcbiAgICAgICAgICAgIHZhbHVlOiBgJHtyZXN1bHRbU3ltYm9sLnRvU3RyaW5nVGFnXX0gPCR7VGVtcG9yYWxEYXRlVG9TdHJpbmcocmVzdWx0KX0+YCxcbiAgICAgICAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICB9XG59XG5mdW5jdGlvbiBDcmVhdGVUZW1wb3JhbERhdGUoaXNvWWVhciwgaXNvTW9udGgsIGlzb0RheSwgY2FsZW5kYXIgPSBHZXRJU084NjAxQ2FsZW5kYXIoKSkge1xuICAgIGNvbnN0IFRlbXBvcmFsUGxhaW5EYXRlID0gR2V0SW50cmluc2ljKCclVGVtcG9yYWwuUGxhaW5EYXRlJScpO1xuICAgIGNvbnN0IHJlc3VsdCA9IE9iamVjdENyZWF0ZSQyKFRlbXBvcmFsUGxhaW5EYXRlLnByb3RvdHlwZSk7XG4gICAgQ3JlYXRlVGVtcG9yYWxEYXRlU2xvdHMocmVzdWx0LCBpc29ZZWFyLCBpc29Nb250aCwgaXNvRGF5LCBjYWxlbmRhcik7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIENyZWF0ZVRlbXBvcmFsRGF0ZVRpbWVTbG90cyhyZXN1bHQsIGlzb1llYXIsIGlzb01vbnRoLCBpc29EYXksIGgsIG1pbiwgcywgbXMsIMK1cywgbnMsIGNhbGVuZGFyKSB7XG4gICAgUmVqZWN0RGF0ZVRpbWUoaXNvWWVhciwgaXNvTW9udGgsIGlzb0RheSwgaCwgbWluLCBzLCBtcywgwrVzLCBucyk7XG4gICAgUmVqZWN0RGF0ZVRpbWVSYW5nZShpc29ZZWFyLCBpc29Nb250aCwgaXNvRGF5LCBoLCBtaW4sIHMsIG1zLCDCtXMsIG5zKTtcbiAgICBDcmVhdGVTbG90cyhyZXN1bHQpO1xuICAgIFNldFNsb3QocmVzdWx0LCBJU09fWUVBUiwgaXNvWWVhcik7XG4gICAgU2V0U2xvdChyZXN1bHQsIElTT19NT05USCwgaXNvTW9udGgpO1xuICAgIFNldFNsb3QocmVzdWx0LCBJU09fREFZLCBpc29EYXkpO1xuICAgIFNldFNsb3QocmVzdWx0LCBJU09fSE9VUiwgaCk7XG4gICAgU2V0U2xvdChyZXN1bHQsIElTT19NSU5VVEUsIG1pbik7XG4gICAgU2V0U2xvdChyZXN1bHQsIElTT19TRUNPTkQsIHMpO1xuICAgIFNldFNsb3QocmVzdWx0LCBJU09fTUlMTElTRUNPTkQsIG1zKTtcbiAgICBTZXRTbG90KHJlc3VsdCwgSVNPX01JQ1JPU0VDT05ELCDCtXMpO1xuICAgIFNldFNsb3QocmVzdWx0LCBJU09fTkFOT1NFQ09ORCwgbnMpO1xuICAgIFNldFNsb3QocmVzdWx0LCBDQUxFTkRBUiwgY2FsZW5kYXIpO1xuICAgIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlc3VsdCwgJ19yZXByXycsIHtcbiAgICAgICAgICAgIHZhbHVlOiBgJHtyZXN1bHRbU3ltYm9sLnRvU3RyaW5nVGFnXX0gPCR7VGVtcG9yYWxEYXRlVGltZVRvU3RyaW5nKHJlc3VsdCwgJ2F1dG8nKX0+YCxcbiAgICAgICAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICB9XG59XG5mdW5jdGlvbiBDcmVhdGVUZW1wb3JhbERhdGVUaW1lKGlzb1llYXIsIGlzb01vbnRoLCBpc29EYXksIGgsIG1pbiwgcywgbXMsIMK1cywgbnMsIGNhbGVuZGFyID0gR2V0SVNPODYwMUNhbGVuZGFyKCkpIHtcbiAgICBjb25zdCBUZW1wb3JhbFBsYWluRGF0ZVRpbWUgPSBHZXRJbnRyaW5zaWMoJyVUZW1wb3JhbC5QbGFpbkRhdGVUaW1lJScpO1xuICAgIGNvbnN0IHJlc3VsdCA9IE9iamVjdENyZWF0ZSQyKFRlbXBvcmFsUGxhaW5EYXRlVGltZS5wcm90b3R5cGUpO1xuICAgIENyZWF0ZVRlbXBvcmFsRGF0ZVRpbWVTbG90cyhyZXN1bHQsIGlzb1llYXIsIGlzb01vbnRoLCBpc29EYXksIGgsIG1pbiwgcywgbXMsIMK1cywgbnMsIGNhbGVuZGFyKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gQ3JlYXRlVGVtcG9yYWxNb250aERheVNsb3RzKHJlc3VsdCwgaXNvTW9udGgsIGlzb0RheSwgY2FsZW5kYXIsIHJlZmVyZW5jZUlTT1llYXIpIHtcbiAgICBSZWplY3RJU09EYXRlKHJlZmVyZW5jZUlTT1llYXIsIGlzb01vbnRoLCBpc29EYXkpO1xuICAgIFJlamVjdERhdGVSYW5nZShyZWZlcmVuY2VJU09ZZWFyLCBpc29Nb250aCwgaXNvRGF5KTtcbiAgICBDcmVhdGVTbG90cyhyZXN1bHQpO1xuICAgIFNldFNsb3QocmVzdWx0LCBJU09fTU9OVEgsIGlzb01vbnRoKTtcbiAgICBTZXRTbG90KHJlc3VsdCwgSVNPX0RBWSwgaXNvRGF5KTtcbiAgICBTZXRTbG90KHJlc3VsdCwgSVNPX1lFQVIsIHJlZmVyZW5jZUlTT1llYXIpO1xuICAgIFNldFNsb3QocmVzdWx0LCBDQUxFTkRBUiwgY2FsZW5kYXIpO1xuICAgIFNldFNsb3QocmVzdWx0LCBNT05USF9EQVlfQlJBTkQsIHRydWUpO1xuICAgIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlc3VsdCwgJ19yZXByXycsIHtcbiAgICAgICAgICAgIHZhbHVlOiBgJHtyZXN1bHRbU3ltYm9sLnRvU3RyaW5nVGFnXX0gPCR7VGVtcG9yYWxNb250aERheVRvU3RyaW5nKHJlc3VsdCl9PmAsXG4gICAgICAgICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZnVuY3Rpb24gQ3JlYXRlVGVtcG9yYWxNb250aERheShpc29Nb250aCwgaXNvRGF5LCBjYWxlbmRhciA9IEdldElTTzg2MDFDYWxlbmRhcigpLCByZWZlcmVuY2VJU09ZZWFyID0gMTk3Mikge1xuICAgIGNvbnN0IFRlbXBvcmFsUGxhaW5Nb250aERheSA9IEdldEludHJpbnNpYygnJVRlbXBvcmFsLlBsYWluTW9udGhEYXklJyk7XG4gICAgY29uc3QgcmVzdWx0ID0gT2JqZWN0Q3JlYXRlJDIoVGVtcG9yYWxQbGFpbk1vbnRoRGF5LnByb3RvdHlwZSk7XG4gICAgQ3JlYXRlVGVtcG9yYWxNb250aERheVNsb3RzKHJlc3VsdCwgaXNvTW9udGgsIGlzb0RheSwgY2FsZW5kYXIsIHJlZmVyZW5jZUlTT1llYXIpO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBDcmVhdGVUZW1wb3JhbFllYXJNb250aFNsb3RzKHJlc3VsdCwgaXNvWWVhciwgaXNvTW9udGgsIGNhbGVuZGFyLCByZWZlcmVuY2VJU09EYXkpIHtcbiAgICBSZWplY3RJU09EYXRlKGlzb1llYXIsIGlzb01vbnRoLCByZWZlcmVuY2VJU09EYXkpO1xuICAgIFJlamVjdFllYXJNb250aFJhbmdlKGlzb1llYXIsIGlzb01vbnRoKTtcbiAgICBDcmVhdGVTbG90cyhyZXN1bHQpO1xuICAgIFNldFNsb3QocmVzdWx0LCBJU09fWUVBUiwgaXNvWWVhcik7XG4gICAgU2V0U2xvdChyZXN1bHQsIElTT19NT05USCwgaXNvTW9udGgpO1xuICAgIFNldFNsb3QocmVzdWx0LCBJU09fREFZLCByZWZlcmVuY2VJU09EYXkpO1xuICAgIFNldFNsb3QocmVzdWx0LCBDQUxFTkRBUiwgY2FsZW5kYXIpO1xuICAgIFNldFNsb3QocmVzdWx0LCBZRUFSX01PTlRIX0JSQU5ELCB0cnVlKTtcbiAgICB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZXN1bHQsICdfcmVwcl8nLCB7XG4gICAgICAgICAgICB2YWx1ZTogYCR7cmVzdWx0W1N5bWJvbC50b1N0cmluZ1RhZ119IDwke1RlbXBvcmFsWWVhck1vbnRoVG9TdHJpbmcocmVzdWx0KX0+YCxcbiAgICAgICAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICB9XG59XG5mdW5jdGlvbiBDcmVhdGVUZW1wb3JhbFllYXJNb250aChpc29ZZWFyLCBpc29Nb250aCwgY2FsZW5kYXIgPSBHZXRJU084NjAxQ2FsZW5kYXIoKSwgcmVmZXJlbmNlSVNPRGF5ID0gMSkge1xuICAgIGNvbnN0IFRlbXBvcmFsUGxhaW5ZZWFyTW9udGggPSBHZXRJbnRyaW5zaWMoJyVUZW1wb3JhbC5QbGFpblllYXJNb250aCUnKTtcbiAgICBjb25zdCByZXN1bHQgPSBPYmplY3RDcmVhdGUkMihUZW1wb3JhbFBsYWluWWVhck1vbnRoLnByb3RvdHlwZSk7XG4gICAgQ3JlYXRlVGVtcG9yYWxZZWFyTW9udGhTbG90cyhyZXN1bHQsIGlzb1llYXIsIGlzb01vbnRoLCBjYWxlbmRhciwgcmVmZXJlbmNlSVNPRGF5KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gQ3JlYXRlVGVtcG9yYWxab25lZERhdGVUaW1lU2xvdHMocmVzdWx0LCBlcG9jaE5hbm9zZWNvbmRzLCB0aW1lWm9uZSwgY2FsZW5kYXIpIHtcbiAgICBWYWxpZGF0ZUVwb2NoTmFub3NlY29uZHMoZXBvY2hOYW5vc2Vjb25kcyk7XG4gICAgQ3JlYXRlU2xvdHMocmVzdWx0KTtcbiAgICBTZXRTbG90KHJlc3VsdCwgRVBPQ0hOQU5PU0VDT05EUywgZXBvY2hOYW5vc2Vjb25kcyk7XG4gICAgU2V0U2xvdChyZXN1bHQsIFRJTUVfWk9ORSwgdGltZVpvbmUpO1xuICAgIFNldFNsb3QocmVzdWx0LCBDQUxFTkRBUiwgY2FsZW5kYXIpO1xuICAgIGNvbnN0IFRlbXBvcmFsSW5zdGFudCA9IEdldEludHJpbnNpYygnJVRlbXBvcmFsLkluc3RhbnQlJyk7XG4gICAgY29uc3QgaW5zdGFudCA9IG5ldyBUZW1wb3JhbEluc3RhbnQoR2V0U2xvdChyZXN1bHQsIEVQT0NITkFOT1NFQ09ORFMpKTtcbiAgICBTZXRTbG90KHJlc3VsdCwgSU5TVEFOVCwgaW5zdGFudCk7XG4gICAge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVzdWx0LCAnX3JlcHJfJywge1xuICAgICAgICAgICAgdmFsdWU6IGAke3Jlc3VsdFtTeW1ib2wudG9TdHJpbmdUYWddfSA8JHtUZW1wb3JhbFpvbmVkRGF0ZVRpbWVUb1N0cmluZyhyZXN1bHQsICdhdXRvJyl9PmAsXG4gICAgICAgICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZnVuY3Rpb24gQ3JlYXRlVGVtcG9yYWxab25lZERhdGVUaW1lKGVwb2NoTmFub3NlY29uZHMsIHRpbWVab25lLCBjYWxlbmRhciA9IEdldElTTzg2MDFDYWxlbmRhcigpKSB7XG4gICAgY29uc3QgVGVtcG9yYWxab25lZERhdGVUaW1lID0gR2V0SW50cmluc2ljKCclVGVtcG9yYWwuWm9uZWREYXRlVGltZSUnKTtcbiAgICBjb25zdCByZXN1bHQgPSBPYmplY3RDcmVhdGUkMihUZW1wb3JhbFpvbmVkRGF0ZVRpbWUucHJvdG90eXBlKTtcbiAgICBDcmVhdGVUZW1wb3JhbFpvbmVkRGF0ZVRpbWVTbG90cyhyZXN1bHQsIGVwb2NoTmFub3NlY29uZHMsIHRpbWVab25lLCBjYWxlbmRhcik7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIEdldElTTzg2MDFDYWxlbmRhcigpIHtcbiAgICBjb25zdCBUZW1wb3JhbENhbGVuZGFyID0gR2V0SW50cmluc2ljKCclVGVtcG9yYWwuQ2FsZW5kYXIlJyk7XG4gICAgcmV0dXJuIG5ldyBUZW1wb3JhbENhbGVuZGFyKCdpc284NjAxJyk7XG59XG4vLyBUT0RPOiBzaG91bGQgKGNhbj8pIHdlIG1ha2UgdGhpcyBnZW5lcmljIHNvIHRoZSBmaWVsZCBuYW1lcyBhcmUgY2hlY2tlZFxuLy8gYWdhaW5zdCB0aGUgdHlwZSB0aGF0IHRoZSBjYWxlbmRhciBpcyBhIHByb3BlcnR5IG9mP1xuZnVuY3Rpb24gQ2FsZW5kYXJGaWVsZHMoY2FsZW5kYXIsIGZpZWxkTmFtZXNQYXJhbSkge1xuICAgIGxldCBmaWVsZE5hbWVzID0gZmllbGROYW1lc1BhcmFtO1xuICAgIGlmIChjYWxlbmRhci5maWVsZHMpIHtcbiAgICAgICAgZmllbGROYW1lcyA9IGNhbGVuZGFyLmZpZWxkcyhmaWVsZE5hbWVzKTtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgZm9yIChjb25zdCBuYW1lIG9mIGZpZWxkTmFtZXMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lICE9PSAnc3RyaW5nJylcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2JhZCByZXR1cm4gZnJvbSBjYWxlbmRhci5maWVsZHMoKScpO1xuICAgICAgICBBcnJheVByb3RvdHlwZVB1c2gkMS5jYWxsKHJlc3VsdCwgbmFtZSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBDYWxlbmRhck1lcmdlRmllbGRzKGNhbGVuZGFyLCBmaWVsZHMsIGFkZGl0aW9uYWxGaWVsZHMpIHtcbiAgICBjb25zdCBjYWxNZXJnZUZpZWxkcyA9IGNhbGVuZGFyLm1lcmdlRmllbGRzO1xuICAgIGlmICghY2FsTWVyZ2VGaWVsZHMpIHtcbiAgICAgICAgcmV0dXJuIHsgLi4uZmllbGRzLCAuLi5hZGRpdGlvbmFsRmllbGRzIH07XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IFJlZmxlY3QuYXBwbHkoY2FsTWVyZ2VGaWVsZHMsIGNhbGVuZGFyLCBbZmllbGRzLCBhZGRpdGlvbmFsRmllbGRzXSk7XG4gICAgaWYgKCFJc09iamVjdChyZXN1bHQpKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdiYWQgcmV0dXJuIGZyb20gY2FsZW5kYXIubWVyZ2VGaWVsZHMoKScpO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBDYWxlbmRhckRhdGVBZGQoY2FsZW5kYXIsIGRhdGUsIGR1cmF0aW9uLCBvcHRpb25zLCBkYXRlQWRkUGFyYW0pIHtcbiAgICBsZXQgZGF0ZUFkZCA9IGRhdGVBZGRQYXJhbTtcbiAgICBpZiAoZGF0ZUFkZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGRhdGVBZGQgPSBjYWxlbmRhci5kYXRlQWRkO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSBSZWZsZWN0QXBwbHkkMShkYXRlQWRkLCBjYWxlbmRhciwgW2RhdGUsIGR1cmF0aW9uLCBvcHRpb25zXSk7XG4gICAgaWYgKCFJc1RlbXBvcmFsRGF0ZShyZXN1bHQpKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlc3VsdCcpO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBDYWxlbmRhckRhdGVVbnRpbChjYWxlbmRhciwgZGF0ZSwgb3RoZXJEYXRlLCBvcHRpb25zLCBkYXRlVW50aWxQYXJhbSkge1xuICAgIGxldCBkYXRlVW50aWwgPSBkYXRlVW50aWxQYXJhbTtcbiAgICBpZiAoZGF0ZVVudGlsID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZGF0ZVVudGlsID0gY2FsZW5kYXIuZGF0ZVVudGlsO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSBSZWZsZWN0QXBwbHkkMShkYXRlVW50aWwsIGNhbGVuZGFyLCBbZGF0ZSwgb3RoZXJEYXRlLCBvcHRpb25zXSk7XG4gICAgaWYgKCFJc1RlbXBvcmFsRHVyYXRpb24ocmVzdWx0KSlcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZXN1bHQnKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gQ2FsZW5kYXJZZWFyKGNhbGVuZGFyLCBkYXRlTGlrZSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IGNhbGVuZGFyLnllYXIoZGF0ZUxpa2UpO1xuICAgIGlmIChyZXN1bHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignY2FsZW5kYXIgeWVhciByZXN1bHQgbXVzdCBiZSBhbiBpbnRlZ2VyJyk7XG4gICAgfVxuICAgIHJldHVybiBUb0ludGVnZXJUaHJvd09uSW5maW5pdHkocmVzdWx0KTtcbn1cbmZ1bmN0aW9uIENhbGVuZGFyTW9udGgoY2FsZW5kYXIsIGRhdGVMaWtlKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gY2FsZW5kYXIubW9udGgoZGF0ZUxpa2UpO1xuICAgIGlmIChyZXN1bHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignY2FsZW5kYXIgbW9udGggcmVzdWx0IG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyJyk7XG4gICAgfVxuICAgIHJldHVybiBUb1Bvc2l0aXZlSW50ZWdlcihyZXN1bHQpO1xufVxuZnVuY3Rpb24gQ2FsZW5kYXJNb250aENvZGUoY2FsZW5kYXIsIGRhdGVMaWtlKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gY2FsZW5kYXIubW9udGhDb2RlKGRhdGVMaWtlKTtcbiAgICBpZiAocmVzdWx0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2NhbGVuZGFyIG1vbnRoQ29kZSByZXN1bHQgbXVzdCBiZSBhIHN0cmluZycpO1xuICAgIH1cbiAgICByZXR1cm4gVG9TdHJpbmcocmVzdWx0KTtcbn1cbmZ1bmN0aW9uIENhbGVuZGFyRGF5KGNhbGVuZGFyLCBkYXRlTGlrZSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IGNhbGVuZGFyLmRheShkYXRlTGlrZSk7XG4gICAgaWYgKHJlc3VsdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdjYWxlbmRhciBkYXkgcmVzdWx0IG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyJyk7XG4gICAgfVxuICAgIHJldHVybiBUb1Bvc2l0aXZlSW50ZWdlcihyZXN1bHQpO1xufVxuZnVuY3Rpb24gQ2FsZW5kYXJFcmEoY2FsZW5kYXIsIGRhdGVMaWtlKSB7XG4gICAgbGV0IHJlc3VsdCA9IGNhbGVuZGFyLmVyYShkYXRlTGlrZSk7XG4gICAgaWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJlc3VsdCA9IFRvU3RyaW5nKHJlc3VsdCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBDYWxlbmRhckVyYVllYXIoY2FsZW5kYXIsIGRhdGVMaWtlKSB7XG4gICAgbGV0IHJlc3VsdCA9IGNhbGVuZGFyLmVyYVllYXIoZGF0ZUxpa2UpO1xuICAgIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXN1bHQgPSBUb0ludGVnZXJUaHJvd09uSW5maW5pdHkocmVzdWx0KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIENhbGVuZGFyRGF5T2ZXZWVrKGNhbGVuZGFyLCBkYXRlTGlrZSkge1xuICAgIHJldHVybiBjYWxlbmRhci5kYXlPZldlZWsoZGF0ZUxpa2UpO1xufVxuZnVuY3Rpb24gQ2FsZW5kYXJEYXlPZlllYXIoY2FsZW5kYXIsIGRhdGVMaWtlKSB7XG4gICAgcmV0dXJuIGNhbGVuZGFyLmRheU9mWWVhcihkYXRlTGlrZSk7XG59XG5mdW5jdGlvbiBDYWxlbmRhcldlZWtPZlllYXIoY2FsZW5kYXIsIGRhdGVMaWtlKSB7XG4gICAgcmV0dXJuIGNhbGVuZGFyLndlZWtPZlllYXIoZGF0ZUxpa2UpO1xufVxuZnVuY3Rpb24gQ2FsZW5kYXJEYXlzSW5XZWVrKGNhbGVuZGFyLCBkYXRlTGlrZSkge1xuICAgIHJldHVybiBjYWxlbmRhci5kYXlzSW5XZWVrKGRhdGVMaWtlKTtcbn1cbmZ1bmN0aW9uIENhbGVuZGFyRGF5c0luTW9udGgoY2FsZW5kYXIsIGRhdGVMaWtlKSB7XG4gICAgcmV0dXJuIGNhbGVuZGFyLmRheXNJbk1vbnRoKGRhdGVMaWtlKTtcbn1cbmZ1bmN0aW9uIENhbGVuZGFyRGF5c0luWWVhcihjYWxlbmRhciwgZGF0ZUxpa2UpIHtcbiAgICByZXR1cm4gY2FsZW5kYXIuZGF5c0luWWVhcihkYXRlTGlrZSk7XG59XG5mdW5jdGlvbiBDYWxlbmRhck1vbnRoc0luWWVhcihjYWxlbmRhciwgZGF0ZUxpa2UpIHtcbiAgICByZXR1cm4gY2FsZW5kYXIubW9udGhzSW5ZZWFyKGRhdGVMaWtlKTtcbn1cbmZ1bmN0aW9uIENhbGVuZGFySW5MZWFwWWVhcihjYWxlbmRhciwgZGF0ZUxpa2UpIHtcbiAgICByZXR1cm4gY2FsZW5kYXIuaW5MZWFwWWVhcihkYXRlTGlrZSk7XG59XG5mdW5jdGlvbiBUb1RlbXBvcmFsQ2FsZW5kYXIoY2FsZW5kYXJMaWtlUGFyYW0pIHtcbiAgICBsZXQgY2FsZW5kYXJMaWtlID0gY2FsZW5kYXJMaWtlUGFyYW07XG4gICAgaWYgKElzT2JqZWN0KGNhbGVuZGFyTGlrZSkpIHtcbiAgICAgICAgaWYgKEhhc1Nsb3QoY2FsZW5kYXJMaWtlLCBDQUxFTkRBUikpXG4gICAgICAgICAgICByZXR1cm4gR2V0U2xvdChjYWxlbmRhckxpa2UsIENBTEVOREFSKTtcbiAgICAgICAgaWYgKCEoJ2NhbGVuZGFyJyBpbiBjYWxlbmRhckxpa2UpKVxuICAgICAgICAgICAgcmV0dXJuIGNhbGVuZGFyTGlrZTtcbiAgICAgICAgY2FsZW5kYXJMaWtlID0gY2FsZW5kYXJMaWtlLmNhbGVuZGFyO1xuICAgICAgICBpZiAoSXNPYmplY3QoY2FsZW5kYXJMaWtlKSAmJiAhKCdjYWxlbmRhcicgaW4gY2FsZW5kYXJMaWtlKSlcbiAgICAgICAgICAgIHJldHVybiBjYWxlbmRhckxpa2U7XG4gICAgfVxuICAgIGNvbnN0IGlkZW50aWZpZXIgPSBUb1N0cmluZyhjYWxlbmRhckxpa2UpO1xuICAgIGNvbnN0IFRlbXBvcmFsQ2FsZW5kYXIgPSBHZXRJbnRyaW5zaWMoJyVUZW1wb3JhbC5DYWxlbmRhciUnKTtcbiAgICBpZiAoSXNCdWlsdGluQ2FsZW5kYXIoaWRlbnRpZmllcikpXG4gICAgICAgIHJldHVybiBuZXcgVGVtcG9yYWxDYWxlbmRhcihpZGVudGlmaWVyKTtcbiAgICBsZXQgY2FsZW5kYXI7XG4gICAgdHJ5IHtcbiAgICAgICAgKHsgY2FsZW5kYXIgfSA9IFBhcnNlSVNPRGF0ZVRpbWUoaWRlbnRpZmllcikpO1xuICAgIH1cbiAgICBjYXRjaCB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBJbnZhbGlkIGNhbGVuZGFyOiAke2lkZW50aWZpZXJ9YCk7XG4gICAgfVxuICAgIGlmICghY2FsZW5kYXIpXG4gICAgICAgIGNhbGVuZGFyID0gJ2lzbzg2MDEnO1xuICAgIHJldHVybiBuZXcgVGVtcG9yYWxDYWxlbmRhcihjYWxlbmRhcik7XG59XG5mdW5jdGlvbiBHZXRUZW1wb3JhbENhbGVuZGFyV2l0aElTT0RlZmF1bHQoaXRlbSkge1xuICAgIGlmIChIYXNTbG90KGl0ZW0sIENBTEVOREFSKSlcbiAgICAgICAgcmV0dXJuIEdldFNsb3QoaXRlbSwgQ0FMRU5EQVIpO1xuICAgIGNvbnN0IHsgY2FsZW5kYXIgfSA9IGl0ZW07XG4gICAgaWYgKGNhbGVuZGFyID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiBHZXRJU084NjAxQ2FsZW5kYXIoKTtcbiAgICByZXR1cm4gVG9UZW1wb3JhbENhbGVuZGFyKGNhbGVuZGFyKTtcbn1cbmZ1bmN0aW9uIENhbGVuZGFyRXF1YWxzKG9uZSwgdHdvKSB7XG4gICAgaWYgKG9uZSA9PT0gdHdvKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBjb25zdCBjYWwxID0gVG9TdHJpbmcob25lKTtcbiAgICBjb25zdCBjYWwyID0gVG9TdHJpbmcodHdvKTtcbiAgICByZXR1cm4gY2FsMSA9PT0gY2FsMjtcbn1cbmZ1bmN0aW9uIENvbnNvbGlkYXRlQ2FsZW5kYXJzKG9uZSwgdHdvKSB7XG4gICAgaWYgKG9uZSA9PT0gdHdvKVxuICAgICAgICByZXR1cm4gdHdvO1xuICAgIGNvbnN0IHNPbmUgPSBUb1N0cmluZyhvbmUpO1xuICAgIGNvbnN0IHNUd28gPSBUb1N0cmluZyh0d28pO1xuICAgIGlmIChzT25lID09PSBzVHdvIHx8IHNPbmUgPT09ICdpc284NjAxJykge1xuICAgICAgICByZXR1cm4gdHdvO1xuICAgIH1cbiAgICBlbHNlIGlmIChzVHdvID09PSAnaXNvODYwMScpIHtcbiAgICAgICAgcmV0dXJuIG9uZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdpcnJlY29uY2lsYWJsZSBjYWxlbmRhcnMnKTtcbiAgICB9XG59XG5mdW5jdGlvbiBEYXRlRnJvbUZpZWxkcyhjYWxlbmRhciwgZmllbGRzLCBvcHRpb25zKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gY2FsZW5kYXIuZGF0ZUZyb21GaWVsZHMoZmllbGRzLCBvcHRpb25zKTtcbiAgICBpZiAoIUlzVGVtcG9yYWxEYXRlKHJlc3VsdCkpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVzdWx0Jyk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIFllYXJNb250aEZyb21GaWVsZHMoY2FsZW5kYXIsIGZpZWxkcywgb3B0aW9ucykge1xuICAgIGNvbnN0IHJlc3VsdCA9IGNhbGVuZGFyLnllYXJNb250aEZyb21GaWVsZHMoZmllbGRzLCBvcHRpb25zKTtcbiAgICBpZiAoIUlzVGVtcG9yYWxZZWFyTW9udGgocmVzdWx0KSlcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZXN1bHQnKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gTW9udGhEYXlGcm9tRmllbGRzKGNhbGVuZGFyLCBmaWVsZHMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCByZXN1bHQgPSBjYWxlbmRhci5tb250aERheUZyb21GaWVsZHMoZmllbGRzLCBvcHRpb25zKTtcbiAgICBpZiAoIUlzVGVtcG9yYWxNb250aERheShyZXN1bHQpKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlc3VsdCcpO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBUb1RlbXBvcmFsVGltZVpvbmUodGVtcG9yYWxUaW1lWm9uZUxpa2VQYXJhbSkge1xuICAgIGxldCB0ZW1wb3JhbFRpbWVab25lTGlrZSA9IHRlbXBvcmFsVGltZVpvbmVMaWtlUGFyYW07XG4gICAgaWYgKElzT2JqZWN0KHRlbXBvcmFsVGltZVpvbmVMaWtlKSkge1xuICAgICAgICBpZiAoSXNUZW1wb3JhbFpvbmVkRGF0ZVRpbWUodGVtcG9yYWxUaW1lWm9uZUxpa2UpKVxuICAgICAgICAgICAgcmV0dXJuIEdldFNsb3QodGVtcG9yYWxUaW1lWm9uZUxpa2UsIFRJTUVfWk9ORSk7XG4gICAgICAgIGlmICghKCd0aW1lWm9uZScgaW4gdGVtcG9yYWxUaW1lWm9uZUxpa2UpKVxuICAgICAgICAgICAgcmV0dXJuIHRlbXBvcmFsVGltZVpvbmVMaWtlO1xuICAgICAgICB0ZW1wb3JhbFRpbWVab25lTGlrZSA9IHRlbXBvcmFsVGltZVpvbmVMaWtlLnRpbWVab25lO1xuICAgICAgICBpZiAoSXNPYmplY3QodGVtcG9yYWxUaW1lWm9uZUxpa2UpICYmICEoJ3RpbWVab25lJyBpbiB0ZW1wb3JhbFRpbWVab25lTGlrZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0ZW1wb3JhbFRpbWVab25lTGlrZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBpZGVudGlmaWVyID0gVG9TdHJpbmcodGVtcG9yYWxUaW1lWm9uZUxpa2UpO1xuICAgIGNvbnN0IHRpbWVab25lID0gUGFyc2VUZW1wb3JhbFRpbWVab25lKGlkZW50aWZpZXIpO1xuICAgIGNvbnN0IFRlbXBvcmFsVGltZVpvbmUgPSBHZXRJbnRyaW5zaWMoJyVUZW1wb3JhbC5UaW1lWm9uZSUnKTtcbiAgICByZXR1cm4gbmV3IFRlbXBvcmFsVGltZVpvbmUodGltZVpvbmUpO1xufVxuZnVuY3Rpb24gVGltZVpvbmVFcXVhbHMob25lLCB0d28pIHtcbiAgICBpZiAob25lID09PSB0d28pXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIGNvbnN0IHR6MSA9IFRvU3RyaW5nKG9uZSk7XG4gICAgY29uc3QgdHoyID0gVG9TdHJpbmcodHdvKTtcbiAgICByZXR1cm4gdHoxID09PSB0ejI7XG59XG5mdW5jdGlvbiBUZW1wb3JhbERhdGVUaW1lVG9EYXRlKGRhdGVUaW1lKSB7XG4gICAgcmV0dXJuIENyZWF0ZVRlbXBvcmFsRGF0ZShHZXRTbG90KGRhdGVUaW1lLCBJU09fWUVBUiksIEdldFNsb3QoZGF0ZVRpbWUsIElTT19NT05USCksIEdldFNsb3QoZGF0ZVRpbWUsIElTT19EQVkpLCBHZXRTbG90KGRhdGVUaW1lLCBDQUxFTkRBUikpO1xufVxuZnVuY3Rpb24gVGVtcG9yYWxEYXRlVGltZVRvVGltZShkYXRlVGltZSkge1xuICAgIGNvbnN0IFRpbWUgPSBHZXRJbnRyaW5zaWMoJyVUZW1wb3JhbC5QbGFpblRpbWUlJyk7XG4gICAgcmV0dXJuIG5ldyBUaW1lKEdldFNsb3QoZGF0ZVRpbWUsIElTT19IT1VSKSwgR2V0U2xvdChkYXRlVGltZSwgSVNPX01JTlVURSksIEdldFNsb3QoZGF0ZVRpbWUsIElTT19TRUNPTkQpLCBHZXRTbG90KGRhdGVUaW1lLCBJU09fTUlMTElTRUNPTkQpLCBHZXRTbG90KGRhdGVUaW1lLCBJU09fTUlDUk9TRUNPTkQpLCBHZXRTbG90KGRhdGVUaW1lLCBJU09fTkFOT1NFQ09ORCkpO1xufVxuZnVuY3Rpb24gR2V0T2Zmc2V0TmFub3NlY29uZHNGb3IodGltZVpvbmUsIGluc3RhbnQpIHtcbiAgICBsZXQgZ2V0T2Zmc2V0TmFub3NlY29uZHNGb3IgPSB0aW1lWm9uZS5nZXRPZmZzZXROYW5vc2Vjb25kc0ZvcjtcbiAgICBpZiAodHlwZW9mIGdldE9mZnNldE5hbm9zZWNvbmRzRm9yICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2dldE9mZnNldE5hbm9zZWNvbmRzRm9yIG5vdCBjYWxsYWJsZScpO1xuICAgIH1cbiAgICBjb25zdCBvZmZzZXROcyA9IFJlZmxlY3QuYXBwbHkoZ2V0T2Zmc2V0TmFub3NlY29uZHNGb3IsIHRpbWVab25lLCBbaW5zdGFudF0pO1xuICAgIGlmICh0eXBlb2Ygb2Zmc2V0TnMgIT09ICdudW1iZXInKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2JhZCByZXR1cm4gZnJvbSBnZXRPZmZzZXROYW5vc2Vjb25kc0ZvcicpO1xuICAgIH1cbiAgICBpZiAoIUlzSW50ZWdlcihvZmZzZXROcykgfHwgTWF0aEFicyhvZmZzZXROcykgPiA4NjQwMGU5KSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdvdXQtb2YtcmFuZ2UgcmV0dXJuIGZyb20gZ2V0T2Zmc2V0TmFub3NlY29uZHNGb3InKTtcbiAgICB9XG4gICAgcmV0dXJuIG9mZnNldE5zO1xufVxuZnVuY3Rpb24gQnVpbHRpblRpbWVab25lR2V0T2Zmc2V0U3RyaW5nRm9yKHRpbWVab25lLCBpbnN0YW50KSB7XG4gICAgY29uc3Qgb2Zmc2V0TnMgPSBHZXRPZmZzZXROYW5vc2Vjb25kc0Zvcih0aW1lWm9uZSwgaW5zdGFudCk7XG4gICAgcmV0dXJuIEZvcm1hdFRpbWVab25lT2Zmc2V0U3RyaW5nKG9mZnNldE5zKTtcbn1cbmZ1bmN0aW9uIEJ1aWx0aW5UaW1lWm9uZUdldFBsYWluRGF0ZVRpbWVGb3IodGltZVpvbmUsIGluc3RhbnQsIGNhbGVuZGFyKSB7XG4gICAgY29uc3QgbnMgPSBHZXRTbG90KGluc3RhbnQsIEVQT0NITkFOT1NFQ09ORFMpO1xuICAgIGNvbnN0IG9mZnNldE5zID0gR2V0T2Zmc2V0TmFub3NlY29uZHNGb3IodGltZVpvbmUsIGluc3RhbnQpO1xuICAgIGxldCB7IHllYXIsIG1vbnRoLCBkYXksIGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZCwgbWljcm9zZWNvbmQsIG5hbm9zZWNvbmQgfSA9IEdldElTT1BhcnRzRnJvbUVwb2NoKG5zKTtcbiAgICAoeyB5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQsIG1pY3Jvc2Vjb25kLCBuYW5vc2Vjb25kIH0gPSBCYWxhbmNlSVNPRGF0ZVRpbWUoeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kLCBtaWNyb3NlY29uZCwgbmFub3NlY29uZCArIG9mZnNldE5zKSk7XG4gICAgcmV0dXJuIENyZWF0ZVRlbXBvcmFsRGF0ZVRpbWUoeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kLCBtaWNyb3NlY29uZCwgbmFub3NlY29uZCwgY2FsZW5kYXIpO1xufVxuZnVuY3Rpb24gQnVpbHRpblRpbWVab25lR2V0SW5zdGFudEZvcih0aW1lWm9uZSwgZGF0ZVRpbWUsIGRpc2FtYmlndWF0aW9uKSB7XG4gICAgY29uc3QgcG9zc2libGVJbnN0YW50cyA9IEdldFBvc3NpYmxlSW5zdGFudHNGb3IodGltZVpvbmUsIGRhdGVUaW1lKTtcbiAgICByZXR1cm4gRGlzYW1iaWd1YXRlUG9zc2libGVJbnN0YW50cyhwb3NzaWJsZUluc3RhbnRzLCB0aW1lWm9uZSwgZGF0ZVRpbWUsIGRpc2FtYmlndWF0aW9uKTtcbn1cbmZ1bmN0aW9uIERpc2FtYmlndWF0ZVBvc3NpYmxlSW5zdGFudHMocG9zc2libGVJbnN0YW50cywgdGltZVpvbmUsIGRhdGVUaW1lLCBkaXNhbWJpZ3VhdGlvbikge1xuICAgIGNvbnN0IEluc3RhbnQgPSBHZXRJbnRyaW5zaWMoJyVUZW1wb3JhbC5JbnN0YW50JScpO1xuICAgIGNvbnN0IG51bUluc3RhbnRzID0gcG9zc2libGVJbnN0YW50cy5sZW5ndGg7XG4gICAgaWYgKG51bUluc3RhbnRzID09PSAxKVxuICAgICAgICByZXR1cm4gcG9zc2libGVJbnN0YW50c1swXTtcbiAgICBpZiAobnVtSW5zdGFudHMpIHtcbiAgICAgICAgc3dpdGNoIChkaXNhbWJpZ3VhdGlvbikge1xuICAgICAgICAgICAgY2FzZSAnY29tcGF0aWJsZSc6XG4gICAgICAgICAgICAvLyBmYWxsIHRocm91Z2ggYmVjYXVzZSAnY29tcGF0aWJsZScgbWVhbnMgJ2VhcmxpZXInIGZvciBcImZhbGwgYmFja1wiIHRyYW5zaXRpb25zXG4gICAgICAgICAgICBjYXNlICdlYXJsaWVyJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gcG9zc2libGVJbnN0YW50c1swXTtcbiAgICAgICAgICAgIGNhc2UgJ2xhdGVyJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gcG9zc2libGVJbnN0YW50c1tudW1JbnN0YW50cyAtIDFdO1xuICAgICAgICAgICAgY2FzZSAncmVqZWN0Jzoge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdtdWx0aXBsZSBpbnN0YW50cyBmb3VuZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHllYXIgPSBHZXRTbG90KGRhdGVUaW1lLCBJU09fWUVBUik7XG4gICAgY29uc3QgbW9udGggPSBHZXRTbG90KGRhdGVUaW1lLCBJU09fTU9OVEgpO1xuICAgIGNvbnN0IGRheSA9IEdldFNsb3QoZGF0ZVRpbWUsIElTT19EQVkpO1xuICAgIGNvbnN0IGhvdXIgPSBHZXRTbG90KGRhdGVUaW1lLCBJU09fSE9VUik7XG4gICAgY29uc3QgbWludXRlID0gR2V0U2xvdChkYXRlVGltZSwgSVNPX01JTlVURSk7XG4gICAgY29uc3Qgc2Vjb25kID0gR2V0U2xvdChkYXRlVGltZSwgSVNPX1NFQ09ORCk7XG4gICAgY29uc3QgbWlsbGlzZWNvbmQgPSBHZXRTbG90KGRhdGVUaW1lLCBJU09fTUlMTElTRUNPTkQpO1xuICAgIGNvbnN0IG1pY3Jvc2Vjb25kID0gR2V0U2xvdChkYXRlVGltZSwgSVNPX01JQ1JPU0VDT05EKTtcbiAgICBjb25zdCBuYW5vc2Vjb25kID0gR2V0U2xvdChkYXRlVGltZSwgSVNPX05BTk9TRUNPTkQpO1xuICAgIGNvbnN0IHV0Y25zID0gR2V0RXBvY2hGcm9tSVNPUGFydHMoeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kLCBtaWNyb3NlY29uZCwgbmFub3NlY29uZCk7XG4gICAgaWYgKHV0Y25zID09PSBudWxsKVxuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignRGF0ZVRpbWUgb3V0c2lkZSBvZiBzdXBwb3J0ZWQgcmFuZ2UnKTtcbiAgICBjb25zdCBkYXlCZWZvcmUgPSBuZXcgSW5zdGFudChKU0JJLnN1YnRyYWN0KHV0Y25zLCBEQVlfTkFOT1MpKTtcbiAgICBjb25zdCBkYXlBZnRlciA9IG5ldyBJbnN0YW50KEpTQkkuYWRkKHV0Y25zLCBEQVlfTkFOT1MpKTtcbiAgICBjb25zdCBvZmZzZXRCZWZvcmUgPSBHZXRPZmZzZXROYW5vc2Vjb25kc0Zvcih0aW1lWm9uZSwgZGF5QmVmb3JlKTtcbiAgICBjb25zdCBvZmZzZXRBZnRlciA9IEdldE9mZnNldE5hbm9zZWNvbmRzRm9yKHRpbWVab25lLCBkYXlBZnRlcik7XG4gICAgY29uc3QgbmFub3NlY29uZHMgPSBvZmZzZXRBZnRlciAtIG9mZnNldEJlZm9yZTtcbiAgICBzd2l0Y2ggKGRpc2FtYmlndWF0aW9uKSB7XG4gICAgICAgIGNhc2UgJ2VhcmxpZXInOiB7XG4gICAgICAgICAgICBjb25zdCBjYWxlbmRhciA9IEdldFNsb3QoZGF0ZVRpbWUsIENBTEVOREFSKTtcbiAgICAgICAgICAgIGNvbnN0IFBsYWluRGF0ZVRpbWUgPSBHZXRJbnRyaW5zaWMoJyVUZW1wb3JhbC5QbGFpbkRhdGVUaW1lJScpO1xuICAgICAgICAgICAgY29uc3QgZWFybGllciA9IEFkZERhdGVUaW1lKHllYXIsIG1vbnRoLCBkYXksIGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZCwgbWljcm9zZWNvbmQsIG5hbm9zZWNvbmQsIGNhbGVuZGFyLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAtbmFub3NlY29uZHMsIHVuZGVmaW5lZCk7XG4gICAgICAgICAgICBjb25zdCBlYXJsaWVyUGxhaW5EYXRlVGltZSA9IG5ldyBQbGFpbkRhdGVUaW1lKGVhcmxpZXIueWVhciwgZWFybGllci5tb250aCwgZWFybGllci5kYXksIGVhcmxpZXIuaG91ciwgZWFybGllci5taW51dGUsIGVhcmxpZXIuc2Vjb25kLCBlYXJsaWVyLm1pbGxpc2Vjb25kLCBlYXJsaWVyLm1pY3Jvc2Vjb25kLCBlYXJsaWVyLm5hbm9zZWNvbmQsIGNhbGVuZGFyKTtcbiAgICAgICAgICAgIHJldHVybiBHZXRQb3NzaWJsZUluc3RhbnRzRm9yKHRpbWVab25lLCBlYXJsaWVyUGxhaW5EYXRlVGltZSlbMF07XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnY29tcGF0aWJsZSc6XG4gICAgICAgIC8vIGZhbGwgdGhyb3VnaCBiZWNhdXNlICdjb21wYXRpYmxlJyBtZWFucyAnbGF0ZXInIGZvciBcInNwcmluZyBmb3J3YXJkXCIgdHJhbnNpdGlvbnNcbiAgICAgICAgY2FzZSAnbGF0ZXInOiB7XG4gICAgICAgICAgICBjb25zdCBjYWxlbmRhciA9IEdldFNsb3QoZGF0ZVRpbWUsIENBTEVOREFSKTtcbiAgICAgICAgICAgIGNvbnN0IFBsYWluRGF0ZVRpbWUgPSBHZXRJbnRyaW5zaWMoJyVUZW1wb3JhbC5QbGFpbkRhdGVUaW1lJScpO1xuICAgICAgICAgICAgY29uc3QgbGF0ZXIgPSBBZGREYXRlVGltZSh5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQsIG1pY3Jvc2Vjb25kLCBuYW5vc2Vjb25kLCBjYWxlbmRhciwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgbmFub3NlY29uZHMsIHVuZGVmaW5lZCk7XG4gICAgICAgICAgICBjb25zdCBsYXRlclBsYWluRGF0ZVRpbWUgPSBuZXcgUGxhaW5EYXRlVGltZShsYXRlci55ZWFyLCBsYXRlci5tb250aCwgbGF0ZXIuZGF5LCBsYXRlci5ob3VyLCBsYXRlci5taW51dGUsIGxhdGVyLnNlY29uZCwgbGF0ZXIubWlsbGlzZWNvbmQsIGxhdGVyLm1pY3Jvc2Vjb25kLCBsYXRlci5uYW5vc2Vjb25kLCBjYWxlbmRhcik7XG4gICAgICAgICAgICBjb25zdCBwb3NzaWJsZSA9IEdldFBvc3NpYmxlSW5zdGFudHNGb3IodGltZVpvbmUsIGxhdGVyUGxhaW5EYXRlVGltZSk7XG4gICAgICAgICAgICByZXR1cm4gcG9zc2libGVbcG9zc2libGUubGVuZ3RoIC0gMV07XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAncmVqZWN0Jzoge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ25vIHN1Y2ggaW5zdGFudCBmb3VuZCcpO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gR2V0UG9zc2libGVJbnN0YW50c0Zvcih0aW1lWm9uZSwgZGF0ZVRpbWUpIHtcbiAgICBjb25zdCBwb3NzaWJsZUluc3RhbnRzID0gdGltZVpvbmUuZ2V0UG9zc2libGVJbnN0YW50c0ZvcihkYXRlVGltZSk7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgZm9yIChjb25zdCBpbnN0YW50IG9mIHBvc3NpYmxlSW5zdGFudHMpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsSW5zdGFudChpbnN0YW50KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYmFkIHJldHVybiBmcm9tIGdldFBvc3NpYmxlSW5zdGFudHNGb3InKTtcbiAgICAgICAgfVxuICAgICAgICBBcnJheVByb3RvdHlwZVB1c2gkMS5jYWxsKHJlc3VsdCwgaW5zdGFudCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBJU09ZZWFyU3RyaW5nKHllYXIpIHtcbiAgICBsZXQgeWVhclN0cmluZztcbiAgICBpZiAoeWVhciA8IDEwMDAgfHwgeWVhciA+IDk5OTkpIHtcbiAgICAgICAgY29uc3Qgc2lnbiA9IHllYXIgPCAwID8gJy0nIDogJysnO1xuICAgICAgICBjb25zdCB5ZWFyTnVtYmVyID0gTWF0aEFicyh5ZWFyKTtcbiAgICAgICAgeWVhclN0cmluZyA9IHNpZ24gKyBgMDAwMDAwJHt5ZWFyTnVtYmVyfWAuc2xpY2UoLTYpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgeWVhclN0cmluZyA9IGAke3llYXJ9YDtcbiAgICB9XG4gICAgcmV0dXJuIHllYXJTdHJpbmc7XG59XG5mdW5jdGlvbiBJU09EYXRlVGltZVBhcnRTdHJpbmcocGFydCkge1xuICAgIHJldHVybiBgMDAke3BhcnR9YC5zbGljZSgtMik7XG59XG5mdW5jdGlvbiBGb3JtYXRTZWNvbmRzU3RyaW5nUGFydChzZWNvbmQsIG1pbGxpc2Vjb25kLCBtaWNyb3NlY29uZCwgbmFub3NlY29uZCwgcHJlY2lzaW9uKSB7XG4gICAgaWYgKHByZWNpc2lvbiA9PT0gJ21pbnV0ZScpXG4gICAgICAgIHJldHVybiAnJztcbiAgICBjb25zdCBzZWNzID0gYDoke0lTT0RhdGVUaW1lUGFydFN0cmluZyhzZWNvbmQpfWA7XG4gICAgbGV0IGZyYWN0aW9uTnVtYmVyID0gbWlsbGlzZWNvbmQgKiAxZTYgKyBtaWNyb3NlY29uZCAqIDFlMyArIG5hbm9zZWNvbmQ7XG4gICAgbGV0IGZyYWN0aW9uO1xuICAgIGlmIChwcmVjaXNpb24gPT09ICdhdXRvJykge1xuICAgICAgICBpZiAoZnJhY3Rpb25OdW1iZXIgPT09IDApXG4gICAgICAgICAgICByZXR1cm4gc2VjcztcbiAgICAgICAgZnJhY3Rpb24gPSBgJHtmcmFjdGlvbk51bWJlcn1gLnBhZFN0YXJ0KDksICcwJyk7XG4gICAgICAgIHdoaWxlIChmcmFjdGlvbltmcmFjdGlvbi5sZW5ndGggLSAxXSA9PT0gJzAnKVxuICAgICAgICAgICAgZnJhY3Rpb24gPSBmcmFjdGlvbi5zbGljZSgwLCAtMSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAocHJlY2lzaW9uID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuIHNlY3M7XG4gICAgICAgIGZyYWN0aW9uID0gYCR7ZnJhY3Rpb25OdW1iZXJ9YC5wYWRTdGFydCg5LCAnMCcpLnNsaWNlKDAsIHByZWNpc2lvbik7XG4gICAgfVxuICAgIHJldHVybiBgJHtzZWNzfS4ke2ZyYWN0aW9ufWA7XG59XG5mdW5jdGlvbiBUZW1wb3JhbEluc3RhbnRUb1N0cmluZyhpbnN0YW50LCB0aW1lWm9uZSwgcHJlY2lzaW9uKSB7XG4gICAgbGV0IG91dHB1dFRpbWVab25lID0gdGltZVpvbmU7XG4gICAgaWYgKG91dHB1dFRpbWVab25lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3QgVGVtcG9yYWxUaW1lWm9uZSA9IEdldEludHJpbnNpYygnJVRlbXBvcmFsLlRpbWVab25lJScpO1xuICAgICAgICBvdXRwdXRUaW1lWm9uZSA9IG5ldyBUZW1wb3JhbFRpbWVab25lKCdVVEMnKTtcbiAgICB9XG4gICAgY29uc3QgaXNvID0gR2V0SVNPODYwMUNhbGVuZGFyKCk7XG4gICAgY29uc3QgZGF0ZVRpbWUgPSBCdWlsdGluVGltZVpvbmVHZXRQbGFpbkRhdGVUaW1lRm9yKG91dHB1dFRpbWVab25lLCBpbnN0YW50LCBpc28pO1xuICAgIGNvbnN0IHllYXIgPSBJU09ZZWFyU3RyaW5nKEdldFNsb3QoZGF0ZVRpbWUsIElTT19ZRUFSKSk7XG4gICAgY29uc3QgbW9udGggPSBJU09EYXRlVGltZVBhcnRTdHJpbmcoR2V0U2xvdChkYXRlVGltZSwgSVNPX01PTlRIKSk7XG4gICAgY29uc3QgZGF5ID0gSVNPRGF0ZVRpbWVQYXJ0U3RyaW5nKEdldFNsb3QoZGF0ZVRpbWUsIElTT19EQVkpKTtcbiAgICBjb25zdCBob3VyID0gSVNPRGF0ZVRpbWVQYXJ0U3RyaW5nKEdldFNsb3QoZGF0ZVRpbWUsIElTT19IT1VSKSk7XG4gICAgY29uc3QgbWludXRlID0gSVNPRGF0ZVRpbWVQYXJ0U3RyaW5nKEdldFNsb3QoZGF0ZVRpbWUsIElTT19NSU5VVEUpKTtcbiAgICBjb25zdCBzZWNvbmRzID0gRm9ybWF0U2Vjb25kc1N0cmluZ1BhcnQoR2V0U2xvdChkYXRlVGltZSwgSVNPX1NFQ09ORCksIEdldFNsb3QoZGF0ZVRpbWUsIElTT19NSUxMSVNFQ09ORCksIEdldFNsb3QoZGF0ZVRpbWUsIElTT19NSUNST1NFQ09ORCksIEdldFNsb3QoZGF0ZVRpbWUsIElTT19OQU5PU0VDT05EKSwgcHJlY2lzaW9uKTtcbiAgICBsZXQgdGltZVpvbmVTdHJpbmcgPSAnWic7XG4gICAgaWYgKHRpbWVab25lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3Qgb2Zmc2V0TnMgPSBHZXRPZmZzZXROYW5vc2Vjb25kc0ZvcihvdXRwdXRUaW1lWm9uZSwgaW5zdGFudCk7XG4gICAgICAgIHRpbWVab25lU3RyaW5nID0gRm9ybWF0SVNPVGltZVpvbmVPZmZzZXRTdHJpbmcob2Zmc2V0TnMpO1xuICAgIH1cbiAgICByZXR1cm4gYCR7eWVhcn0tJHttb250aH0tJHtkYXl9VCR7aG91cn06JHttaW51dGV9JHtzZWNvbmRzfSR7dGltZVpvbmVTdHJpbmd9YDtcbn1cbmZ1bmN0aW9uIFRlbXBvcmFsRHVyYXRpb25Ub1N0cmluZyhkdXJhdGlvbiwgcHJlY2lzaW9uID0gJ2F1dG8nLCBvcHRpb25zID0gdW5kZWZpbmVkKSB7XG4gICAgZnVuY3Rpb24gZm9ybWF0TnVtYmVyKG51bSkge1xuICAgICAgICBpZiAobnVtIDw9IE51bWJlck1heFNhZmVJbnRlZ2VyKVxuICAgICAgICAgICAgcmV0dXJuIG51bS50b1N0cmluZygxMCk7XG4gICAgICAgIHJldHVybiBKU0JJLkJpZ0ludChudW0pLnRvU3RyaW5nKDEwKTtcbiAgICB9XG4gICAgY29uc3QgeWVhcnMgPSBHZXRTbG90KGR1cmF0aW9uLCBZRUFSUyk7XG4gICAgY29uc3QgbW9udGhzID0gR2V0U2xvdChkdXJhdGlvbiwgTU9OVEhTKTtcbiAgICBjb25zdCB3ZWVrcyA9IEdldFNsb3QoZHVyYXRpb24sIFdFRUtTKTtcbiAgICBjb25zdCBkYXlzID0gR2V0U2xvdChkdXJhdGlvbiwgREFZUyk7XG4gICAgY29uc3QgaG91cnMgPSBHZXRTbG90KGR1cmF0aW9uLCBIT1VSUyk7XG4gICAgY29uc3QgbWludXRlcyA9IEdldFNsb3QoZHVyYXRpb24sIE1JTlVURVMpO1xuICAgIGxldCBzZWNvbmRzID0gR2V0U2xvdChkdXJhdGlvbiwgU0VDT05EUyk7XG4gICAgbGV0IG1zID0gR2V0U2xvdChkdXJhdGlvbiwgTUlMTElTRUNPTkRTKTtcbiAgICBsZXQgwrVzID0gR2V0U2xvdChkdXJhdGlvbiwgTUlDUk9TRUNPTkRTKTtcbiAgICBsZXQgbnMgPSBHZXRTbG90KGR1cmF0aW9uLCBOQU5PU0VDT05EUyk7XG4gICAgY29uc3Qgc2lnbiA9IER1cmF0aW9uU2lnbih5ZWFycywgbW9udGhzLCB3ZWVrcywgZGF5cywgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIG1zLCDCtXMsIG5zKTtcbiAgICBpZiAob3B0aW9ucykge1xuICAgICAgICBjb25zdCB7IHVuaXQsIGluY3JlbWVudCwgcm91bmRpbmdNb2RlIH0gPSBvcHRpb25zO1xuICAgICAgICAoe1xuICAgICAgICAgICAgc2Vjb25kcyxcbiAgICAgICAgICAgIG1pbGxpc2Vjb25kczogbXMsXG4gICAgICAgICAgICBtaWNyb3NlY29uZHM6IMK1cyxcbiAgICAgICAgICAgIG5hbm9zZWNvbmRzOiBuc1xuICAgICAgICB9ID0gUm91bmREdXJhdGlvbigwLCAwLCAwLCAwLCAwLCAwLCBzZWNvbmRzLCBtcywgwrVzLCBucywgaW5jcmVtZW50LCB1bml0LCByb3VuZGluZ01vZGUpKTtcbiAgICB9XG4gICAgY29uc3QgZGF0ZVBhcnRzID0gW107XG4gICAgaWYgKHllYXJzKVxuICAgICAgICBkYXRlUGFydHMucHVzaChgJHtmb3JtYXROdW1iZXIoTWF0aEFicyh5ZWFycykpfVlgKTtcbiAgICBpZiAobW9udGhzKVxuICAgICAgICBkYXRlUGFydHMucHVzaChgJHtmb3JtYXROdW1iZXIoTWF0aEFicyhtb250aHMpKX1NYCk7XG4gICAgaWYgKHdlZWtzKVxuICAgICAgICBkYXRlUGFydHMucHVzaChgJHtmb3JtYXROdW1iZXIoTWF0aEFicyh3ZWVrcykpfVdgKTtcbiAgICBpZiAoZGF5cylcbiAgICAgICAgZGF0ZVBhcnRzLnB1c2goYCR7Zm9ybWF0TnVtYmVyKE1hdGhBYnMoZGF5cykpfURgKTtcbiAgICBjb25zdCB0aW1lUGFydHMgPSBbXTtcbiAgICBpZiAoaG91cnMpXG4gICAgICAgIHRpbWVQYXJ0cy5wdXNoKGAke2Zvcm1hdE51bWJlcihNYXRoQWJzKGhvdXJzKSl9SGApO1xuICAgIGlmIChtaW51dGVzKVxuICAgICAgICB0aW1lUGFydHMucHVzaChgJHtmb3JtYXROdW1iZXIoTWF0aEFicyhtaW51dGVzKSl9TWApO1xuICAgIGNvbnN0IHNlY29uZFBhcnRzID0gW107XG4gICAgbGV0IHRvdGFsID0gVG90YWxEdXJhdGlvbk5hbm9zZWNvbmRzKDAsIDAsIDAsIHNlY29uZHMsIG1zLCDCtXMsIG5zLCAwKTtcbiAgICBsZXQgbnNCaWdJbnQsIMK1c0JpZ0ludCwgbXNCaWdJbnQsIHNlY29uZHNCaWdJbnQ7XG4gICAgKHsgcXVvdGllbnQ6IHRvdGFsLCByZW1haW5kZXI6IG5zQmlnSW50IH0gPSBkaXZtb2QodG90YWwsIFRIT1VTQU5EKSk7XG4gICAgKHsgcXVvdGllbnQ6IHRvdGFsLCByZW1haW5kZXI6IMK1c0JpZ0ludCB9ID0gZGl2bW9kKHRvdGFsLCBUSE9VU0FORCkpO1xuICAgICh7IHF1b3RpZW50OiBzZWNvbmRzQmlnSW50LCByZW1haW5kZXI6IG1zQmlnSW50IH0gPSBkaXZtb2QodG90YWwsIFRIT1VTQU5EKSk7XG4gICAgY29uc3QgZnJhY3Rpb24gPSBNYXRoQWJzKEpTQkkudG9OdW1iZXIobXNCaWdJbnQpKSAqIDFlNiArIE1hdGhBYnMoSlNCSS50b051bWJlcijCtXNCaWdJbnQpKSAqIDFlMyArIE1hdGhBYnMoSlNCSS50b051bWJlcihuc0JpZ0ludCkpO1xuICAgIGxldCBkZWNpbWFsUGFydDtcbiAgICBpZiAocHJlY2lzaW9uID09PSAnYXV0bycpIHtcbiAgICAgICAgaWYgKGZyYWN0aW9uICE9PSAwKSB7XG4gICAgICAgICAgICBkZWNpbWFsUGFydCA9IGAke2ZyYWN0aW9ufWAucGFkU3RhcnQoOSwgJzAnKTtcbiAgICAgICAgICAgIHdoaWxlIChkZWNpbWFsUGFydFtkZWNpbWFsUGFydC5sZW5ndGggLSAxXSA9PT0gJzAnKSB7XG4gICAgICAgICAgICAgICAgZGVjaW1hbFBhcnQgPSBkZWNpbWFsUGFydC5zbGljZSgwLCAtMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAocHJlY2lzaW9uICE9PSAwKSB7XG4gICAgICAgIGRlY2ltYWxQYXJ0ID0gYCR7ZnJhY3Rpb259YC5wYWRTdGFydCg5LCAnMCcpLnNsaWNlKDAsIHByZWNpc2lvbik7XG4gICAgfVxuICAgIGlmIChkZWNpbWFsUGFydClcbiAgICAgICAgc2Vjb25kUGFydHMudW5zaGlmdCgnLicsIGRlY2ltYWxQYXJ0KTtcbiAgICBpZiAoIUpTQkkuZXF1YWwoc2Vjb25kc0JpZ0ludCwgWkVSTykgfHwgc2Vjb25kUGFydHMubGVuZ3RoIHx8IHByZWNpc2lvbiAhPT0gJ2F1dG8nKSB7XG4gICAgICAgIHNlY29uZFBhcnRzLnVuc2hpZnQoYWJzKHNlY29uZHNCaWdJbnQpLnRvU3RyaW5nKCkpO1xuICAgIH1cbiAgICBpZiAoc2Vjb25kUGFydHMubGVuZ3RoKVxuICAgICAgICB0aW1lUGFydHMucHVzaChgJHtzZWNvbmRQYXJ0cy5qb2luKCcnKX1TYCk7XG4gICAgaWYgKHRpbWVQYXJ0cy5sZW5ndGgpXG4gICAgICAgIHRpbWVQYXJ0cy51bnNoaWZ0KCdUJyk7XG4gICAgaWYgKCFkYXRlUGFydHMubGVuZ3RoICYmICF0aW1lUGFydHMubGVuZ3RoKVxuICAgICAgICByZXR1cm4gJ1BUMFMnO1xuICAgIHJldHVybiBgJHtzaWduIDwgMCA/ICctJyA6ICcnfVAke2RhdGVQYXJ0cy5qb2luKCcnKX0ke3RpbWVQYXJ0cy5qb2luKCcnKX1gO1xufVxuZnVuY3Rpb24gVGVtcG9yYWxEYXRlVG9TdHJpbmcoZGF0ZSwgc2hvd0NhbGVuZGFyID0gJ2F1dG8nKSB7XG4gICAgY29uc3QgeWVhciA9IElTT1llYXJTdHJpbmcoR2V0U2xvdChkYXRlLCBJU09fWUVBUikpO1xuICAgIGNvbnN0IG1vbnRoID0gSVNPRGF0ZVRpbWVQYXJ0U3RyaW5nKEdldFNsb3QoZGF0ZSwgSVNPX01PTlRIKSk7XG4gICAgY29uc3QgZGF5ID0gSVNPRGF0ZVRpbWVQYXJ0U3RyaW5nKEdldFNsb3QoZGF0ZSwgSVNPX0RBWSkpO1xuICAgIGNvbnN0IGNhbGVuZGFySUQgPSBUb1N0cmluZyhHZXRTbG90KGRhdGUsIENBTEVOREFSKSk7XG4gICAgY29uc3QgY2FsZW5kYXIgPSBGb3JtYXRDYWxlbmRhckFubm90YXRpb24oY2FsZW5kYXJJRCwgc2hvd0NhbGVuZGFyKTtcbiAgICByZXR1cm4gYCR7eWVhcn0tJHttb250aH0tJHtkYXl9JHtjYWxlbmRhcn1gO1xufVxuZnVuY3Rpb24gVGVtcG9yYWxEYXRlVGltZVRvU3RyaW5nKGRhdGVUaW1lLCBwcmVjaXNpb24sIHNob3dDYWxlbmRhciA9ICdhdXRvJywgb3B0aW9ucyA9IHVuZGVmaW5lZCkge1xuICAgIGxldCB5ZWFyID0gR2V0U2xvdChkYXRlVGltZSwgSVNPX1lFQVIpO1xuICAgIGxldCBtb250aCA9IEdldFNsb3QoZGF0ZVRpbWUsIElTT19NT05USCk7XG4gICAgbGV0IGRheSA9IEdldFNsb3QoZGF0ZVRpbWUsIElTT19EQVkpO1xuICAgIGxldCBob3VyID0gR2V0U2xvdChkYXRlVGltZSwgSVNPX0hPVVIpO1xuICAgIGxldCBtaW51dGUgPSBHZXRTbG90KGRhdGVUaW1lLCBJU09fTUlOVVRFKTtcbiAgICBsZXQgc2Vjb25kID0gR2V0U2xvdChkYXRlVGltZSwgSVNPX1NFQ09ORCk7XG4gICAgbGV0IG1pbGxpc2Vjb25kID0gR2V0U2xvdChkYXRlVGltZSwgSVNPX01JTExJU0VDT05EKTtcbiAgICBsZXQgbWljcm9zZWNvbmQgPSBHZXRTbG90KGRhdGVUaW1lLCBJU09fTUlDUk9TRUNPTkQpO1xuICAgIGxldCBuYW5vc2Vjb25kID0gR2V0U2xvdChkYXRlVGltZSwgSVNPX05BTk9TRUNPTkQpO1xuICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHsgdW5pdCwgaW5jcmVtZW50LCByb3VuZGluZ01vZGUgfSA9IG9wdGlvbnM7XG4gICAgICAgICh7IHllYXIsIG1vbnRoLCBkYXksIGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZCwgbWljcm9zZWNvbmQsIG5hbm9zZWNvbmQgfSA9IFJvdW5kSVNPRGF0ZVRpbWUoeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kLCBtaWNyb3NlY29uZCwgbmFub3NlY29uZCwgaW5jcmVtZW50LCB1bml0LCByb3VuZGluZ01vZGUpKTtcbiAgICB9XG4gICAgY29uc3QgeWVhclN0cmluZyA9IElTT1llYXJTdHJpbmcoeWVhcik7XG4gICAgY29uc3QgbW9udGhTdHJpbmcgPSBJU09EYXRlVGltZVBhcnRTdHJpbmcobW9udGgpO1xuICAgIGNvbnN0IGRheVN0cmluZyA9IElTT0RhdGVUaW1lUGFydFN0cmluZyhkYXkpO1xuICAgIGNvbnN0IGhvdXJTdHJpbmcgPSBJU09EYXRlVGltZVBhcnRTdHJpbmcoaG91cik7XG4gICAgY29uc3QgbWludXRlU3RyaW5nID0gSVNPRGF0ZVRpbWVQYXJ0U3RyaW5nKG1pbnV0ZSk7XG4gICAgY29uc3Qgc2Vjb25kc1N0cmluZyA9IEZvcm1hdFNlY29uZHNTdHJpbmdQYXJ0KHNlY29uZCwgbWlsbGlzZWNvbmQsIG1pY3Jvc2Vjb25kLCBuYW5vc2Vjb25kLCBwcmVjaXNpb24pO1xuICAgIGNvbnN0IGNhbGVuZGFySUQgPSBUb1N0cmluZyhHZXRTbG90KGRhdGVUaW1lLCBDQUxFTkRBUikpO1xuICAgIGNvbnN0IGNhbGVuZGFyID0gRm9ybWF0Q2FsZW5kYXJBbm5vdGF0aW9uKGNhbGVuZGFySUQsIHNob3dDYWxlbmRhcik7XG4gICAgcmV0dXJuIGAke3llYXJTdHJpbmd9LSR7bW9udGhTdHJpbmd9LSR7ZGF5U3RyaW5nfVQke2hvdXJTdHJpbmd9OiR7bWludXRlU3RyaW5nfSR7c2Vjb25kc1N0cmluZ30ke2NhbGVuZGFyfWA7XG59XG5mdW5jdGlvbiBUZW1wb3JhbE1vbnRoRGF5VG9TdHJpbmcobW9udGhEYXksIHNob3dDYWxlbmRhciA9ICdhdXRvJykge1xuICAgIGNvbnN0IG1vbnRoID0gSVNPRGF0ZVRpbWVQYXJ0U3RyaW5nKEdldFNsb3QobW9udGhEYXksIElTT19NT05USCkpO1xuICAgIGNvbnN0IGRheSA9IElTT0RhdGVUaW1lUGFydFN0cmluZyhHZXRTbG90KG1vbnRoRGF5LCBJU09fREFZKSk7XG4gICAgbGV0IHJlc3VsdFN0cmluZyA9IGAke21vbnRofS0ke2RheX1gO1xuICAgIGNvbnN0IGNhbGVuZGFyID0gR2V0U2xvdChtb250aERheSwgQ0FMRU5EQVIpO1xuICAgIGNvbnN0IGNhbGVuZGFySUQgPSBUb1N0cmluZyhjYWxlbmRhcik7XG4gICAgaWYgKGNhbGVuZGFySUQgIT09ICdpc284NjAxJykge1xuICAgICAgICBjb25zdCB5ZWFyID0gSVNPWWVhclN0cmluZyhHZXRTbG90KG1vbnRoRGF5LCBJU09fWUVBUikpO1xuICAgICAgICByZXN1bHRTdHJpbmcgPSBgJHt5ZWFyfS0ke3Jlc3VsdFN0cmluZ31gO1xuICAgIH1cbiAgICBjb25zdCBjYWxlbmRhclN0cmluZyA9IEZvcm1hdENhbGVuZGFyQW5ub3RhdGlvbihjYWxlbmRhcklELCBzaG93Q2FsZW5kYXIpO1xuICAgIGlmIChjYWxlbmRhclN0cmluZylcbiAgICAgICAgcmVzdWx0U3RyaW5nICs9IGNhbGVuZGFyU3RyaW5nO1xuICAgIHJldHVybiByZXN1bHRTdHJpbmc7XG59XG5mdW5jdGlvbiBUZW1wb3JhbFllYXJNb250aFRvU3RyaW5nKHllYXJNb250aCwgc2hvd0NhbGVuZGFyID0gJ2F1dG8nKSB7XG4gICAgY29uc3QgeWVhciA9IElTT1llYXJTdHJpbmcoR2V0U2xvdCh5ZWFyTW9udGgsIElTT19ZRUFSKSk7XG4gICAgY29uc3QgbW9udGggPSBJU09EYXRlVGltZVBhcnRTdHJpbmcoR2V0U2xvdCh5ZWFyTW9udGgsIElTT19NT05USCkpO1xuICAgIGxldCByZXN1bHRTdHJpbmcgPSBgJHt5ZWFyfS0ke21vbnRofWA7XG4gICAgY29uc3QgY2FsZW5kYXIgPSBHZXRTbG90KHllYXJNb250aCwgQ0FMRU5EQVIpO1xuICAgIGNvbnN0IGNhbGVuZGFySUQgPSBUb1N0cmluZyhjYWxlbmRhcik7XG4gICAgaWYgKGNhbGVuZGFySUQgIT09ICdpc284NjAxJykge1xuICAgICAgICBjb25zdCBkYXkgPSBJU09EYXRlVGltZVBhcnRTdHJpbmcoR2V0U2xvdCh5ZWFyTW9udGgsIElTT19EQVkpKTtcbiAgICAgICAgcmVzdWx0U3RyaW5nICs9IGAtJHtkYXl9YDtcbiAgICB9XG4gICAgY29uc3QgY2FsZW5kYXJTdHJpbmcgPSBGb3JtYXRDYWxlbmRhckFubm90YXRpb24oY2FsZW5kYXJJRCwgc2hvd0NhbGVuZGFyKTtcbiAgICBpZiAoY2FsZW5kYXJTdHJpbmcpXG4gICAgICAgIHJlc3VsdFN0cmluZyArPSBjYWxlbmRhclN0cmluZztcbiAgICByZXR1cm4gcmVzdWx0U3RyaW5nO1xufVxuZnVuY3Rpb24gVGVtcG9yYWxab25lZERhdGVUaW1lVG9TdHJpbmcoemR0LCBwcmVjaXNpb24sIHNob3dDYWxlbmRhciA9ICdhdXRvJywgc2hvd1RpbWVab25lID0gJ2F1dG8nLCBzaG93T2Zmc2V0ID0gJ2F1dG8nLCBvcHRpb25zID0gdW5kZWZpbmVkKSB7XG4gICAgbGV0IGluc3RhbnQgPSBHZXRTbG90KHpkdCwgSU5TVEFOVCk7XG4gICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgeyB1bml0LCBpbmNyZW1lbnQsIHJvdW5kaW5nTW9kZSB9ID0gb3B0aW9ucztcbiAgICAgICAgY29uc3QgbnMgPSBSb3VuZEluc3RhbnQoR2V0U2xvdCh6ZHQsIEVQT0NITkFOT1NFQ09ORFMpLCBpbmNyZW1lbnQsIHVuaXQsIHJvdW5kaW5nTW9kZSk7XG4gICAgICAgIGNvbnN0IFRlbXBvcmFsSW5zdGFudCA9IEdldEludHJpbnNpYygnJVRlbXBvcmFsLkluc3RhbnQlJyk7XG4gICAgICAgIGluc3RhbnQgPSBuZXcgVGVtcG9yYWxJbnN0YW50KG5zKTtcbiAgICB9XG4gICAgY29uc3QgdHogPSBHZXRTbG90KHpkdCwgVElNRV9aT05FKTtcbiAgICBjb25zdCBpc28gPSBHZXRJU084NjAxQ2FsZW5kYXIoKTtcbiAgICBjb25zdCBkYXRlVGltZSA9IEJ1aWx0aW5UaW1lWm9uZUdldFBsYWluRGF0ZVRpbWVGb3IodHosIGluc3RhbnQsIGlzbyk7XG4gICAgY29uc3QgeWVhciA9IElTT1llYXJTdHJpbmcoR2V0U2xvdChkYXRlVGltZSwgSVNPX1lFQVIpKTtcbiAgICBjb25zdCBtb250aCA9IElTT0RhdGVUaW1lUGFydFN0cmluZyhHZXRTbG90KGRhdGVUaW1lLCBJU09fTU9OVEgpKTtcbiAgICBjb25zdCBkYXkgPSBJU09EYXRlVGltZVBhcnRTdHJpbmcoR2V0U2xvdChkYXRlVGltZSwgSVNPX0RBWSkpO1xuICAgIGNvbnN0IGhvdXIgPSBJU09EYXRlVGltZVBhcnRTdHJpbmcoR2V0U2xvdChkYXRlVGltZSwgSVNPX0hPVVIpKTtcbiAgICBjb25zdCBtaW51dGUgPSBJU09EYXRlVGltZVBhcnRTdHJpbmcoR2V0U2xvdChkYXRlVGltZSwgSVNPX01JTlVURSkpO1xuICAgIGNvbnN0IHNlY29uZHMgPSBGb3JtYXRTZWNvbmRzU3RyaW5nUGFydChHZXRTbG90KGRhdGVUaW1lLCBJU09fU0VDT05EKSwgR2V0U2xvdChkYXRlVGltZSwgSVNPX01JTExJU0VDT05EKSwgR2V0U2xvdChkYXRlVGltZSwgSVNPX01JQ1JPU0VDT05EKSwgR2V0U2xvdChkYXRlVGltZSwgSVNPX05BTk9TRUNPTkQpLCBwcmVjaXNpb24pO1xuICAgIGxldCByZXN1bHQgPSBgJHt5ZWFyfS0ke21vbnRofS0ke2RheX1UJHtob3VyfToke21pbnV0ZX0ke3NlY29uZHN9YDtcbiAgICBpZiAoc2hvd09mZnNldCAhPT0gJ25ldmVyJykge1xuICAgICAgICBjb25zdCBvZmZzZXROcyA9IEdldE9mZnNldE5hbm9zZWNvbmRzRm9yKHR6LCBpbnN0YW50KTtcbiAgICAgICAgcmVzdWx0ICs9IEZvcm1hdElTT1RpbWVab25lT2Zmc2V0U3RyaW5nKG9mZnNldE5zKTtcbiAgICB9XG4gICAgaWYgKHNob3dUaW1lWm9uZSAhPT0gJ25ldmVyJylcbiAgICAgICAgcmVzdWx0ICs9IGBbJHt0en1dYDtcbiAgICBjb25zdCBjYWxlbmRhcklEID0gVG9TdHJpbmcoR2V0U2xvdCh6ZHQsIENBTEVOREFSKSk7XG4gICAgcmVzdWx0ICs9IEZvcm1hdENhbGVuZGFyQW5ub3RhdGlvbihjYWxlbmRhcklELCBzaG93Q2FsZW5kYXIpO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBUZXN0VGltZVpvbmVPZmZzZXRTdHJpbmcoc3RyaW5nKSB7XG4gICAgcmV0dXJuIE9GRlNFVC50ZXN0KFN0cmluZ0N0b3Ioc3RyaW5nKSk7XG59XG5mdW5jdGlvbiBQYXJzZVRpbWVab25lT2Zmc2V0U3RyaW5nKHN0cmluZykge1xuICAgIGNvbnN0IG1hdGNoID0gT0ZGU0VULmV4ZWMoU3RyaW5nQ3RvcihzdHJpbmcpKTtcbiAgICBpZiAoIW1hdGNoKSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBpbnZhbGlkIHRpbWUgem9uZSBvZmZzZXQ6ICR7c3RyaW5nfWApO1xuICAgIH1cbiAgICBjb25zdCBzaWduID0gbWF0Y2hbMV0gPT09ICctJyB8fCBtYXRjaFsxXSA9PT0gJ1xcdTIyMTInID8gLTEgOiArMTtcbiAgICBjb25zdCBob3VycyA9ICttYXRjaFsyXTtcbiAgICBjb25zdCBtaW51dGVzID0gKyhtYXRjaFszXSB8fCAwKTtcbiAgICBjb25zdCBzZWNvbmRzID0gKyhtYXRjaFs0XSB8fCAwKTtcbiAgICBjb25zdCBuYW5vc2Vjb25kcyA9ICsoKG1hdGNoWzVdIHx8IDApICsgJzAwMDAwMDAwMCcpLnNsaWNlKDAsIDkpO1xuICAgIHJldHVybiBzaWduICogKCgoaG91cnMgKiA2MCArIG1pbnV0ZXMpICogNjAgKyBzZWNvbmRzKSAqIDFlOSArIG5hbm9zZWNvbmRzKTtcbn1cbmZ1bmN0aW9uIEdldENhbm9uaWNhbFRpbWVab25lSWRlbnRpZmllcih0aW1lWm9uZUlkZW50aWZpZXIpIHtcbiAgICBpZiAoVGVzdFRpbWVab25lT2Zmc2V0U3RyaW5nKHRpbWVab25lSWRlbnRpZmllcikpIHtcbiAgICAgICAgY29uc3Qgb2Zmc2V0TnMgPSBQYXJzZVRpbWVab25lT2Zmc2V0U3RyaW5nKHRpbWVab25lSWRlbnRpZmllcik7XG4gICAgICAgIHJldHVybiBGb3JtYXRUaW1lWm9uZU9mZnNldFN0cmluZyhvZmZzZXROcyk7XG4gICAgfVxuICAgIGNvbnN0IGZvcm1hdHRlciA9IGdldEludGxEYXRlVGltZUZvcm1hdEVuVXNGb3JUaW1lWm9uZShTdHJpbmdDdG9yKHRpbWVab25lSWRlbnRpZmllcikpO1xuICAgIHJldHVybiBmb3JtYXR0ZXIucmVzb2x2ZWRPcHRpb25zKCkudGltZVpvbmU7XG59XG5mdW5jdGlvbiBHZXRJQU5BVGltZVpvbmVPZmZzZXROYW5vc2Vjb25kcyhlcG9jaE5hbm9zZWNvbmRzLCBpZCkge1xuICAgIGNvbnN0IHsgeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kLCBtaWNyb3NlY29uZCwgbmFub3NlY29uZCB9ID0gR2V0SUFOQVRpbWVab25lRGF0ZVRpbWVQYXJ0cyhlcG9jaE5hbm9zZWNvbmRzLCBpZCk7XG4gICAgY29uc3QgdXRjID0gR2V0RXBvY2hGcm9tSVNPUGFydHMoeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kLCBtaWNyb3NlY29uZCwgbmFub3NlY29uZCk7XG4gICAgaWYgKHV0YyA9PT0gbnVsbClcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0RhdGUgb3V0c2lkZSBvZiBzdXBwb3J0ZWQgcmFuZ2UnKTtcbiAgICByZXR1cm4gSlNCSS50b051bWJlcihKU0JJLnN1YnRyYWN0KHV0YywgZXBvY2hOYW5vc2Vjb25kcykpO1xufVxuZnVuY3Rpb24gRm9ybWF0VGltZVpvbmVPZmZzZXRTdHJpbmcob2Zmc2V0TmFub3NlY29uZHNQYXJhbSkge1xuICAgIGNvbnN0IHNpZ24gPSBvZmZzZXROYW5vc2Vjb25kc1BhcmFtIDwgMCA/ICctJyA6ICcrJztcbiAgICBjb25zdCBvZmZzZXROYW5vc2Vjb25kcyA9IE1hdGhBYnMob2Zmc2V0TmFub3NlY29uZHNQYXJhbSk7XG4gICAgY29uc3QgbmFub3NlY29uZHMgPSBvZmZzZXROYW5vc2Vjb25kcyAlIDFlOTtcbiAgICBjb25zdCBzZWNvbmRzID0gTWF0aEZsb29yKG9mZnNldE5hbm9zZWNvbmRzIC8gMWU5KSAlIDYwO1xuICAgIGNvbnN0IG1pbnV0ZXMgPSBNYXRoRmxvb3Iob2Zmc2V0TmFub3NlY29uZHMgLyA2MGU5KSAlIDYwO1xuICAgIGNvbnN0IGhvdXJzID0gTWF0aEZsb29yKG9mZnNldE5hbm9zZWNvbmRzIC8gMzYwMGU5KTtcbiAgICBjb25zdCBob3VyU3RyaW5nID0gSVNPRGF0ZVRpbWVQYXJ0U3RyaW5nKGhvdXJzKTtcbiAgICBjb25zdCBtaW51dGVTdHJpbmcgPSBJU09EYXRlVGltZVBhcnRTdHJpbmcobWludXRlcyk7XG4gICAgY29uc3Qgc2Vjb25kU3RyaW5nID0gSVNPRGF0ZVRpbWVQYXJ0U3RyaW5nKHNlY29uZHMpO1xuICAgIGxldCBwb3N0ID0gJyc7XG4gICAgaWYgKG5hbm9zZWNvbmRzKSB7XG4gICAgICAgIGxldCBmcmFjdGlvbiA9IGAke25hbm9zZWNvbmRzfWAucGFkU3RhcnQoOSwgJzAnKTtcbiAgICAgICAgd2hpbGUgKGZyYWN0aW9uW2ZyYWN0aW9uLmxlbmd0aCAtIDFdID09PSAnMCcpXG4gICAgICAgICAgICBmcmFjdGlvbiA9IGZyYWN0aW9uLnNsaWNlKDAsIC0xKTtcbiAgICAgICAgcG9zdCA9IGA6JHtzZWNvbmRTdHJpbmd9LiR7ZnJhY3Rpb259YDtcbiAgICB9XG4gICAgZWxzZSBpZiAoc2Vjb25kcykge1xuICAgICAgICBwb3N0ID0gYDoke3NlY29uZFN0cmluZ31gO1xuICAgIH1cbiAgICByZXR1cm4gYCR7c2lnbn0ke2hvdXJTdHJpbmd9OiR7bWludXRlU3RyaW5nfSR7cG9zdH1gO1xufVxuZnVuY3Rpb24gRm9ybWF0SVNPVGltZVpvbmVPZmZzZXRTdHJpbmcob2Zmc2V0TmFub3NlY29uZHNQYXJhbSkge1xuICAgIGxldCBvZmZzZXROYW5vc2Vjb25kcyA9IEpTQkkudG9OdW1iZXIoUm91bmROdW1iZXJUb0luY3JlbWVudChKU0JJLkJpZ0ludChvZmZzZXROYW5vc2Vjb25kc1BhcmFtKSwgNjBlOSwgJ2hhbGZFeHBhbmQnKSk7XG4gICAgY29uc3Qgc2lnbiA9IG9mZnNldE5hbm9zZWNvbmRzIDwgMCA/ICctJyA6ICcrJztcbiAgICBvZmZzZXROYW5vc2Vjb25kcyA9IE1hdGhBYnMob2Zmc2V0TmFub3NlY29uZHMpO1xuICAgIGNvbnN0IG1pbnV0ZXMgPSAob2Zmc2V0TmFub3NlY29uZHMgLyA2MGU5KSAlIDYwO1xuICAgIGNvbnN0IGhvdXJzID0gTWF0aEZsb29yKG9mZnNldE5hbm9zZWNvbmRzIC8gMzYwMGU5KTtcbiAgICBjb25zdCBob3VyU3RyaW5nID0gSVNPRGF0ZVRpbWVQYXJ0U3RyaW5nKGhvdXJzKTtcbiAgICBjb25zdCBtaW51dGVTdHJpbmcgPSBJU09EYXRlVGltZVBhcnRTdHJpbmcobWludXRlcyk7XG4gICAgcmV0dXJuIGAke3NpZ259JHtob3VyU3RyaW5nfToke21pbnV0ZVN0cmluZ31gO1xufVxuZnVuY3Rpb24gR2V0RXBvY2hGcm9tSVNPUGFydHMoeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kLCBtaWNyb3NlY29uZCwgbmFub3NlY29uZCkge1xuICAgIC8vIE5vdGU6IERhdGUuVVRDKCkgaW50ZXJwcmV0cyBvbmUgYW5kIHR3by1kaWdpdCB5ZWFycyBhcyBiZWluZyBpbiB0aGVcbiAgICAvLyAyMHRoIGNlbnR1cnksIHNvIGRvbid0IHVzZSBpdFxuICAgIGNvbnN0IGxlZ2FjeURhdGUgPSBuZXcgRGF0ZSgpO1xuICAgIGxlZ2FjeURhdGUuc2V0VVRDSG91cnMoaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kKTtcbiAgICBsZWdhY3lEYXRlLnNldFVUQ0Z1bGxZZWFyKHllYXIsIG1vbnRoIC0gMSwgZGF5KTtcbiAgICBjb25zdCBtcyA9IGxlZ2FjeURhdGUuZ2V0VGltZSgpO1xuICAgIGlmIChOdW1iZXJJc05hTihtcykpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGxldCBucyA9IEpTQkkubXVsdGlwbHkoSlNCSS5CaWdJbnQobXMpLCBNSUxMSU9OKTtcbiAgICBucyA9IEpTQkkuYWRkKG5zLCBKU0JJLm11bHRpcGx5KEpTQkkuQmlnSW50KG1pY3Jvc2Vjb25kKSwgVEhPVVNBTkQpKTtcbiAgICBucyA9IEpTQkkuYWRkKG5zLCBKU0JJLkJpZ0ludChuYW5vc2Vjb25kKSk7XG4gICAgaWYgKEpTQkkubGVzc1RoYW4obnMsIE5TX01JTikgfHwgSlNCSS5ncmVhdGVyVGhhbihucywgTlNfTUFYKSlcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIG5zO1xufVxuZnVuY3Rpb24gR2V0SVNPUGFydHNGcm9tRXBvY2goZXBvY2hOYW5vc2Vjb25kcykge1xuICAgIGNvbnN0IHsgcXVvdGllbnQsIHJlbWFpbmRlciB9ID0gZGl2bW9kKGVwb2NoTmFub3NlY29uZHMsIE1JTExJT04pO1xuICAgIGxldCBlcG9jaE1pbGxpc2Vjb25kcyA9IEpTQkkudG9OdW1iZXIocXVvdGllbnQpO1xuICAgIGxldCBuYW5vcyA9IEpTQkkudG9OdW1iZXIocmVtYWluZGVyKTtcbiAgICBpZiAobmFub3MgPCAwKSB7XG4gICAgICAgIG5hbm9zICs9IDFlNjtcbiAgICAgICAgZXBvY2hNaWxsaXNlY29uZHMgLT0gMTtcbiAgICB9XG4gICAgY29uc3QgbWljcm9zZWNvbmQgPSBNYXRoRmxvb3IobmFub3MgLyAxZTMpICUgMWUzO1xuICAgIGNvbnN0IG5hbm9zZWNvbmQgPSBuYW5vcyAlIDFlMztcbiAgICBjb25zdCBpdGVtID0gbmV3IERhdGUoZXBvY2hNaWxsaXNlY29uZHMpO1xuICAgIGNvbnN0IHllYXIgPSBpdGVtLmdldFVUQ0Z1bGxZZWFyKCk7XG4gICAgY29uc3QgbW9udGggPSBpdGVtLmdldFVUQ01vbnRoKCkgKyAxO1xuICAgIGNvbnN0IGRheSA9IGl0ZW0uZ2V0VVRDRGF0ZSgpO1xuICAgIGNvbnN0IGhvdXIgPSBpdGVtLmdldFVUQ0hvdXJzKCk7XG4gICAgY29uc3QgbWludXRlID0gaXRlbS5nZXRVVENNaW51dGVzKCk7XG4gICAgY29uc3Qgc2Vjb25kID0gaXRlbS5nZXRVVENTZWNvbmRzKCk7XG4gICAgY29uc3QgbWlsbGlzZWNvbmQgPSBpdGVtLmdldFVUQ01pbGxpc2Vjb25kcygpO1xuICAgIHJldHVybiB7IGVwb2NoTWlsbGlzZWNvbmRzLCB5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQsIG1pY3Jvc2Vjb25kLCBuYW5vc2Vjb25kIH07XG59XG4vLyB0cy1wcnVuZS1pZ25vcmUtbmV4dCBUT0RPOiByZW1vdmUgdGhpcyBhZnRlciB0ZXN0cyBhcmUgY29udmVydGVkIHRvIFRTXG5mdW5jdGlvbiBHZXRJQU5BVGltZVpvbmVEYXRlVGltZVBhcnRzKGVwb2NoTmFub3NlY29uZHMsIGlkKSB7XG4gICAgY29uc3QgeyBlcG9jaE1pbGxpc2Vjb25kcywgbWlsbGlzZWNvbmQsIG1pY3Jvc2Vjb25kLCBuYW5vc2Vjb25kIH0gPSBHZXRJU09QYXJ0c0Zyb21FcG9jaChlcG9jaE5hbm9zZWNvbmRzKTtcbiAgICBjb25zdCB7IHllYXIsIG1vbnRoLCBkYXksIGhvdXIsIG1pbnV0ZSwgc2Vjb25kIH0gPSBHZXRGb3JtYXR0ZXJQYXJ0cyhpZCwgZXBvY2hNaWxsaXNlY29uZHMpO1xuICAgIHJldHVybiBCYWxhbmNlSVNPRGF0ZVRpbWUoeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kLCBtaWNyb3NlY29uZCwgbmFub3NlY29uZCk7XG59XG5mdW5jdGlvbiBtYXhKU0JJKG9uZSwgdHdvKSB7XG4gICAgcmV0dXJuIEpTQkkubGVzc1RoYW4ob25lLCB0d28pID8gdHdvIDogb25lO1xufVxuLyoqXG4gKiBPdXIgYmVzdCBndWVzcyBhdCBob3cgZmFyIGluIGFkdmFuY2UgbmV3IHJ1bGVzIHdpbGwgYmUgcHV0IGludG8gdGhlIFRaREIgZm9yXG4gKiBmdXR1cmUgb2Zmc2V0IHRyYW5zaXRpb25zLiBXZSdsbCBwaWNrIDEwIHllYXJzIGJ1dCBjYW4gYWx3YXlzIHJldmlzZSBpdCBpZlxuICogd2UgZmluZCB0aGF0IGNvdW50cmllcyBhcmUgYmVpbmcgdW51c3VhbGx5IHByb2FjdGl2ZSBpbiB0aGVpciBhbm5vdW5jaW5nXG4gKiBvZiBvZmZzZXQgY2hhbmdlcy5cbiAqL1xuZnVuY3Rpb24gYWZ0ZXJMYXRlc3RQb3NzaWJsZVR6ZGJSdWxlQ2hhbmdlKCkge1xuICAgIHJldHVybiBKU0JJLmFkZChTeXN0ZW1VVENFcG9jaE5hbm9TZWNvbmRzKCksIEFCT1VUX1RFTl9ZRUFSU19OQU5PUyk7XG59XG5mdW5jdGlvbiBHZXRJQU5BVGltZVpvbmVOZXh0VHJhbnNpdGlvbihlcG9jaE5hbm9zZWNvbmRzLCBpZCkge1xuICAgIC8vIERlY2lkZSBob3cgZmFyIGluIHRoZSBmdXR1cmUgYWZ0ZXIgYGVwb2NoTmFub3NlY29uZHNgIHdlJ2xsIGxvb2sgZm9yIGFuXG4gICAgLy8gb2Zmc2V0IGNoYW5nZS4gVGhlcmUgYXJlIHR3byBjYXNlczpcbiAgICAvLyAxLiBJZiBpdCdzIGEgcGFzdCBkYXRlIChvciBhIGRhdGUgaW4gdGhlIG5lYXIgZnV0dXJlKSB0aGVuIGl0J3MgcG9zc2libGVcbiAgICAvLyAgICB0aGF0IHRoZSB0aW1lIHpvbmUgbWF5IGhhdmUgbmV3bHkgYWRkZWQgRFNUIGluIHRoZSBuZXh0IGZldyB5ZWFycy4gU29cbiAgICAvLyAgICB3ZSdsbCBoYXZlIHRvIGxvb2sgZnJvbSB0aGUgcHJvdmlkZWQgdGltZSB1bnRpbCBhIGZldyB5ZWFycyBhZnRlciB0aGVcbiAgICAvLyAgICBjdXJyZW50IHN5c3RlbSB0aW1lLiAoQ2hhbmdlcyB0byBEU1QgcG9saWN5IGFyZSB1c3VhbGx5IGFubm91bmNlZCBhIGZld1xuICAgIC8vICAgIHllYXJzIGluIHRoZSBmdXR1cmUuKSBOb3RlIHRoYXQgdGhlIGZpcnN0IERTVCBhbnl3aGVyZSBzdGFydGVkIGluIDE4NDcsXG4gICAgLy8gICAgc28gd2UnbGwgc3RhcnQgY2hlY2tzIGluIDE4NDcgaW5zdGVhZCBvZiB3YXN0aW5nIGN5Y2xlcyBvbiB5ZWFycyB3aGVyZVxuICAgIC8vICAgIHRoZXJlIHdpbGwgbmV2ZXIgYmUgdHJhbnNpdGlvbnMuXG4gICAgLy8gMi4gSWYgaXQncyBhIGZ1dHVyZSBkYXRlIGJleW9uZCB0aGUgbmV4dCBmZXcgeWVhcnMsIHRoZW4gd2UnbGwganVzdCBhc3N1bWVcbiAgICAvLyAgICB0aGF0IHRoZSBsYXRlc3QgRFNUIHBvbGljeSBpbiBUWkRCIHdpbGwgc3RpbGwgYmUgaW4gZWZmZWN0LiAgSW4gdGhpc1xuICAgIC8vICAgIGNhc2UsIHdlIG9ubHkgbmVlZCB0byBsb29rIG9uZSB5ZWFyIGluIHRoZSBmdXR1cmUgdG8gc2VlIGlmIHRoZXJlIGFyZVxuICAgIC8vICAgIGFueSBEU1QgdHJhbnNpdGlvbnMuICBXZSBhY3R1YWxseSBvbmx5IG5lZWQgdG8gbG9vayA5LTEwIG1vbnRocyBiZWNhdXNlXG4gICAgLy8gICAgRFNUIGhhcyB0d28gdHJhbnNpdGlvbnMgcGVyIHllYXIsIGJ1dCB3ZSdsbCB1c2UgYSB5ZWFyIGp1c3QgdG8gYmUgc2FmZS5cbiAgICBjb25zdCBvbmVZZWFyTGF0ZXIgPSBKU0JJLmFkZChlcG9jaE5hbm9zZWNvbmRzLCBBQk9VVF9PTkVfWUVBUl9OQU5PUyk7XG4gICAgY29uc3QgdXBwZXJjYXAgPSBtYXhKU0JJKGFmdGVyTGF0ZXN0UG9zc2libGVUemRiUnVsZUNoYW5nZSgpLCBvbmVZZWFyTGF0ZXIpO1xuICAgIC8vIFRoZSBmaXJzdCB0cmFuc2l0aW9uIChpbiBhbnkgdGltZXpvbmUpIHJlY29yZGVkIGluIHRoZSBUWkRCIHdhcyBpbiAxODQ3LCBzb1xuICAgIC8vIHN0YXJ0IHRoZXJlIGlmIGFuIGVhcmxpZXIgZGF0ZSBpcyBzdXBwbGllZC5cbiAgICBsZXQgbGVmdE5hbm9zID0gbWF4SlNCSShCRUZPUkVfRklSU1RfT0ZGU0VUX1RSQU5TSVRJT04sIGVwb2NoTmFub3NlY29uZHMpO1xuICAgIGNvbnN0IGxlZnRPZmZzZXROcyA9IEdldElBTkFUaW1lWm9uZU9mZnNldE5hbm9zZWNvbmRzKGxlZnROYW5vcywgaWQpO1xuICAgIGxldCByaWdodE5hbm9zID0gbGVmdE5hbm9zO1xuICAgIGxldCByaWdodE9mZnNldE5zID0gbGVmdE9mZnNldE5zO1xuICAgIHdoaWxlIChsZWZ0T2Zmc2V0TnMgPT09IHJpZ2h0T2Zmc2V0TnMgJiYgSlNCSS5sZXNzVGhhbihKU0JJLkJpZ0ludChsZWZ0TmFub3MpLCB1cHBlcmNhcCkpIHtcbiAgICAgICAgcmlnaHROYW5vcyA9IEpTQkkuYWRkKGxlZnROYW5vcywgVFdPX1dFRUtTX05BTk9TKTtcbiAgICAgICAgcmlnaHRPZmZzZXROcyA9IEdldElBTkFUaW1lWm9uZU9mZnNldE5hbm9zZWNvbmRzKHJpZ2h0TmFub3MsIGlkKTtcbiAgICAgICAgaWYgKGxlZnRPZmZzZXROcyA9PT0gcmlnaHRPZmZzZXROcykge1xuICAgICAgICAgICAgbGVmdE5hbm9zID0gcmlnaHROYW5vcztcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAobGVmdE9mZnNldE5zID09PSByaWdodE9mZnNldE5zKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBjb25zdCByZXN1bHQgPSBiaXNlY3QoKGVwb2NoTnMpID0+IEdldElBTkFUaW1lWm9uZU9mZnNldE5hbm9zZWNvbmRzKGVwb2NoTnMsIGlkKSwgbGVmdE5hbm9zLCByaWdodE5hbm9zLCBsZWZ0T2Zmc2V0TnMsIHJpZ2h0T2Zmc2V0TnMpO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBHZXRJQU5BVGltZVpvbmVQcmV2aW91c1RyYW5zaXRpb24oZXBvY2hOYW5vc2Vjb25kcywgaWQpIHtcbiAgICAvLyBJZiBhIHRpbWUgem9uZSB1c2VzIERTVCAoYXQgdGhlIHRpbWUgb2YgYGVwb2NoTmFub3NlY29uZHNgKSwgdGhlbiB3ZSBvbmx5XG4gICAgLy8gaGF2ZSB0byBsb29rIGJhY2sgb25lIHllYXIgdG8gZmluZCBhIHRyYW5zaXRpb24uIEJ1dCBpZiBpdCBkb2Vzbid0IHVzZSBEU1QsXG4gICAgLy8gdGhlbiB3ZSBuZWVkIHRvIGxvb2sgYWxsIHRoZSB3YXkgYmFjayB0byAxODQ3ICh0aGUgZWFybGllc3QgcnVsZSBpbiB0aGVcbiAgICAvLyBUWkRCKSB0byBzZWUgaWYgaXQgaGFkIG90aGVyIG9mZnNldCB0cmFuc2l0aW9ucyBpbiB0aGUgcGFzdC4gTG9vcGluZyBiYWNrXG4gICAgLy8gZnJvbSBhIGZhci1mdXR1cmUgZGF0ZSB0byAxODQ3IGlzIHZlcnkgc2xvdyAobWludXRlcyBvZiAxMDAlIENQVSEpLCBhbmQgaXNcbiAgICAvLyBhbHNvIHVubmVjZXNzYXJ5IGJlY2F1c2UgRFNUIHJ1bGVzIGFyZW4ndCBwdXQgaW50byB0aGUgVFpEQiBtb3JlIHRoYW4gYSBmZXdcbiAgICAvLyB5ZWFycyBpbiB0aGUgZnV0dXJlIGJlY2F1c2UgdGhlIHBvbGl0aWNhbCBjaGFuZ2VzIGluIHRpbWUgem9uZXMgaGFwcGVuIHdpdGhcbiAgICAvLyBvbmx5IGEgZmV3IHllYXJzJyB3YXJuaW5nLiBUaGVyZWZvcmUsIGlmIGEgZmFyLWZ1dHVyZSBkYXRlIGlzIHByb3ZpZGVkLFxuICAgIC8vIHRoZW4gd2UnbGwgcnVuIHRoZSBjaGVjayBpbiB0d28gcGFydHM6XG4gICAgLy8gMS4gRmlyc3QsIHdlJ2xsIGxvb2sgYmFjayBmb3IgdXAgdG8gb25lIHllYXIgdG8gc2VlIGlmIHRoZSBsYXRlc3QgVFpEQlxuICAgIC8vICAgIHJ1bGVzIGhhdmUgRFNULlxuICAgIC8vIDIuIElmIG5vdCwgdGhlbiB3ZSdsbCBcImZhc3QtcmV2ZXJzZVwiIGJhY2sgdG8gYSBmZXcgeWVhcnMgbGF0ZXIgdGhhbiB0aGVcbiAgICAvLyAgICBjdXJyZW50IHN5c3RlbSB0aW1lLCBhbmQgdGhlbiBsb29rIGJhY2sgdG8gMTg0Ny4gVGhpcyByZWR1Y2VzIHRoZVxuICAgIC8vICAgIHdvcnN0LWNhc2UgbG9vcCBmcm9tIDI3M0sgeWVhcnMgdG8gMTc1IHllYXJzLCBmb3IgYSB+MTUwMHggaW1wcm92ZW1lbnRcbiAgICAvLyAgICBpbiB3b3JzdC1jYXNlIHBlcmYuXG4gICAgY29uc3QgYWZ0ZXJMYXRlc3RSdWxlID0gYWZ0ZXJMYXRlc3RQb3NzaWJsZVR6ZGJSdWxlQ2hhbmdlKCk7XG4gICAgY29uc3QgaXNGYXJGdXR1cmUgPSBKU0JJLmdyZWF0ZXJUaGFuKGVwb2NoTmFub3NlY29uZHMsIGFmdGVyTGF0ZXN0UnVsZSk7XG4gICAgY29uc3QgbG93ZXJjYXAgPSBpc0ZhckZ1dHVyZSA/IEpTQkkuc3VidHJhY3QoZXBvY2hOYW5vc2Vjb25kcywgQUJPVVRfT05FX1lFQVJfTkFOT1MpIDogQkVGT1JFX0ZJUlNUX09GRlNFVF9UUkFOU0lUSU9OO1xuICAgIGxldCByaWdodE5hbm9zID0gSlNCSS5zdWJ0cmFjdChlcG9jaE5hbm9zZWNvbmRzLCBPTkUpO1xuICAgIGNvbnN0IHJpZ2h0T2Zmc2V0TnMgPSBHZXRJQU5BVGltZVpvbmVPZmZzZXROYW5vc2Vjb25kcyhyaWdodE5hbm9zLCBpZCk7XG4gICAgbGV0IGxlZnROYW5vcyA9IHJpZ2h0TmFub3M7XG4gICAgbGV0IGxlZnRPZmZzZXROcyA9IHJpZ2h0T2Zmc2V0TnM7XG4gICAgd2hpbGUgKHJpZ2h0T2Zmc2V0TnMgPT09IGxlZnRPZmZzZXROcyAmJiBKU0JJLmdyZWF0ZXJUaGFuKHJpZ2h0TmFub3MsIGxvd2VyY2FwKSkge1xuICAgICAgICBsZWZ0TmFub3MgPSBKU0JJLnN1YnRyYWN0KHJpZ2h0TmFub3MsIFRXT19XRUVLU19OQU5PUyk7XG4gICAgICAgIGxlZnRPZmZzZXROcyA9IEdldElBTkFUaW1lWm9uZU9mZnNldE5hbm9zZWNvbmRzKGxlZnROYW5vcywgaWQpO1xuICAgICAgICBpZiAocmlnaHRPZmZzZXROcyA9PT0gbGVmdE9mZnNldE5zKSB7XG4gICAgICAgICAgICByaWdodE5hbm9zID0gbGVmdE5hbm9zO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChyaWdodE9mZnNldE5zID09PSBsZWZ0T2Zmc2V0TnMpIHtcbiAgICAgICAgaWYgKGlzRmFyRnV0dXJlKSB7XG4gICAgICAgICAgICAvLyBUaGVyZSB3YXMgbm8gRFNUIGFmdGVyIGxvb2tpbmcgYmFjayBvbmUgeWVhciwgd2hpY2ggbWVhbnMgdGhhdCB0aGUgbW9zdFxuICAgICAgICAgICAgLy8gcmVjZW50IFRaREIgcnVsZXMgZG9uJ3QgaGF2ZSBhbnkgcmVjdXJyaW5nIHRyYW5zaXRpb25zLiBUbyBjaGVjayBmb3JcbiAgICAgICAgICAgIC8vIHRyYW5zaXRpb25zIGluIG9sZGVyIHJ1bGVzLCBiYWNrIHVwIHRvIGEgZmV3IHllYXJzIGFmdGVyIHRoZSBjdXJyZW50XG4gICAgICAgICAgICAvLyBkYXRlIGFuZCB0aGVuIGxvb2sgYWxsIHRoZSB3YXkgYmFjayB0byAxODQ3LiBOb3RlIHRoYXQgd2UgbW92ZSBiYWNrIG9uZVxuICAgICAgICAgICAgLy8gZGF5IGZyb20gdGhlIGxhdGVzdCBwb3NzaWJsZSBydWxlIHNvIHRoYXQgd2hlbiB0aGUgcmVjdXJzaW9uIHJ1bnMgaXRcbiAgICAgICAgICAgIC8vIHdvbid0IGNvbnNpZGVyIHRoZSBuZXcgdGltZSB0byBiZSBcImZhciBmdXR1cmVcIiBiZWNhdXNlIHRoZSBzeXN0ZW0gY2xvY2tcbiAgICAgICAgICAgIC8vIGhhcyBhZHZhbmNlZCBpbiB0aGUgbWVhbnRpbWUuXG4gICAgICAgICAgICBjb25zdCBuZXdUaW1lVG9DaGVjayA9IEpTQkkuc3VidHJhY3QoYWZ0ZXJMYXRlc3RSdWxlLCBEQVlfTkFOT1MpO1xuICAgICAgICAgICAgcmV0dXJuIEdldElBTkFUaW1lWm9uZVByZXZpb3VzVHJhbnNpdGlvbihuZXdUaW1lVG9DaGVjaywgaWQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSBiaXNlY3QoKGVwb2NoTnMpID0+IEdldElBTkFUaW1lWm9uZU9mZnNldE5hbm9zZWNvbmRzKGVwb2NoTnMsIGlkKSwgbGVmdE5hbm9zLCByaWdodE5hbm9zLCBsZWZ0T2Zmc2V0TnMsIHJpZ2h0T2Zmc2V0TnMpO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG4vLyB0cy1wcnVuZS1pZ25vcmUtbmV4dCBUT0RPOiByZW1vdmUgdGhpcyBhZnRlciB0ZXN0cyBhcmUgY29udmVydGVkIHRvIFRTXG5mdW5jdGlvbiBwYXJzZUZyb21FblVzRm9ybWF0KGRhdGV0aW1lKSB7XG4gICAgY29uc3QgcGFydHMgPSBkYXRldGltZS5zcGxpdCgvW15cXHddKy8pO1xuICAgIGlmIChwYXJ0cy5sZW5ndGggIT09IDcpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYGV4cGVjdGVkIDcgcGFydHMgaW4gXCIke2RhdGV0aW1lfWApO1xuICAgIH1cbiAgICBjb25zdCBtb250aCA9ICtwYXJ0c1swXTtcbiAgICBjb25zdCBkYXkgPSArcGFydHNbMV07XG4gICAgbGV0IHllYXIgPSArcGFydHNbMl07XG4gICAgY29uc3QgZXJhID0gcGFydHNbM10udG9VcHBlckNhc2UoKTtcbiAgICBpZiAoZXJhID09PSAnQicgfHwgZXJhID09PSAnQkMnKSB7XG4gICAgICAgIHllYXIgPSAteWVhciArIDE7XG4gICAgfVxuICAgIGVsc2UgaWYgKGVyYSAhPT0gJ0EnICYmIGVyYSAhPT0gJ0FEJykge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgVW5rbm93biBlcmEgJHtlcmF9IGluIFwiJHtkYXRldGltZX1gKTtcbiAgICB9XG4gICAgbGV0IGhvdXIgPSArcGFydHNbNF07XG4gICAgaWYgKGhvdXIgPT09IDI0KSB7XG4gICAgICAgIC8vIGJ1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0xMDQ1NzkxXG4gICAgICAgIGhvdXIgPSAwO1xuICAgIH1cbiAgICBjb25zdCBtaW51dGUgPSArcGFydHNbNV07XG4gICAgY29uc3Qgc2Vjb25kID0gK3BhcnRzWzZdO1xuICAgIGlmICghTnVtYmVySXNGaW5pdGUoeWVhcikgfHxcbiAgICAgICAgIU51bWJlcklzRmluaXRlKG1vbnRoKSB8fFxuICAgICAgICAhTnVtYmVySXNGaW5pdGUoZGF5KSB8fFxuICAgICAgICAhTnVtYmVySXNGaW5pdGUoaG91cikgfHxcbiAgICAgICAgIU51bWJlcklzRmluaXRlKG1pbnV0ZSkgfHxcbiAgICAgICAgIU51bWJlcklzRmluaXRlKHNlY29uZCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYEludmFsaWQgbnVtYmVyIGluIFwiJHtkYXRldGltZX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQgfTtcbn1cbi8vIHRzLXBydW5lLWlnbm9yZS1uZXh0IFRPRE86IHJlbW92ZSB0aGlzIGFmdGVyIHRlc3RzIGFyZSBjb252ZXJ0ZWQgdG8gVFNcbmZ1bmN0aW9uIEdldEZvcm1hdHRlclBhcnRzKHRpbWVab25lLCBlcG9jaE1pbGxpc2Vjb25kcykge1xuICAgIGNvbnN0IGZvcm1hdHRlciA9IGdldEludGxEYXRlVGltZUZvcm1hdEVuVXNGb3JUaW1lWm9uZSh0aW1lWm9uZSk7XG4gICAgLy8gVXNpbmcgYGZvcm1hdGAgaW5zdGVhZCBvZiBgZm9ybWF0VG9QYXJ0c2AgZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBvbGRlciBjbGllbnRzXG4gICAgY29uc3QgZGF0ZXRpbWUgPSBmb3JtYXR0ZXIuZm9ybWF0KG5ldyBEYXRlKGVwb2NoTWlsbGlzZWNvbmRzKSk7XG4gICAgcmV0dXJuIHBhcnNlRnJvbUVuVXNGb3JtYXQoZGF0ZXRpbWUpO1xufVxuZnVuY3Rpb24gR2V0SUFOQVRpbWVab25lRXBvY2hWYWx1ZShpZCwgeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kLCBtaWNyb3NlY29uZCwgbmFub3NlY29uZCkge1xuICAgIGNvbnN0IG5zID0gR2V0RXBvY2hGcm9tSVNPUGFydHMoeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kLCBtaWNyb3NlY29uZCwgbmFub3NlY29uZCk7XG4gICAgaWYgKG5zID09PSBudWxsKVxuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignRGF0ZVRpbWUgb3V0c2lkZSBvZiBzdXBwb3J0ZWQgcmFuZ2UnKTtcbiAgICBsZXQgbnNFYXJsaWVyID0gSlNCSS5zdWJ0cmFjdChucywgREFZX05BTk9TKTtcbiAgICBpZiAoSlNCSS5sZXNzVGhhbihuc0VhcmxpZXIsIE5TX01JTikpXG4gICAgICAgIG5zRWFybGllciA9IG5zO1xuICAgIGxldCBuc0xhdGVyID0gSlNCSS5hZGQobnMsIERBWV9OQU5PUyk7XG4gICAgaWYgKEpTQkkuZ3JlYXRlclRoYW4obnNMYXRlciwgTlNfTUFYKSlcbiAgICAgICAgbnNMYXRlciA9IG5zO1xuICAgIGNvbnN0IGVhcmxpZXN0ID0gR2V0SUFOQVRpbWVab25lT2Zmc2V0TmFub3NlY29uZHMobnNFYXJsaWVyLCBpZCk7XG4gICAgY29uc3QgbGF0ZXN0ID0gR2V0SUFOQVRpbWVab25lT2Zmc2V0TmFub3NlY29uZHMobnNMYXRlciwgaWQpO1xuICAgIGNvbnN0IGZvdW5kID0gZWFybGllc3QgPT09IGxhdGVzdCA/IFtlYXJsaWVzdF0gOiBbZWFybGllc3QsIGxhdGVzdF07XG4gICAgcmV0dXJuIGZvdW5kXG4gICAgICAgIC5tYXAoKG9mZnNldE5hbm9zZWNvbmRzKSA9PiB7XG4gICAgICAgIGNvbnN0IGVwb2NoTmFub3NlY29uZHMgPSBKU0JJLnN1YnRyYWN0KG5zLCBKU0JJLkJpZ0ludChvZmZzZXROYW5vc2Vjb25kcykpO1xuICAgICAgICBjb25zdCBwYXJ0cyA9IEdldElBTkFUaW1lWm9uZURhdGVUaW1lUGFydHMoZXBvY2hOYW5vc2Vjb25kcywgaWQpO1xuICAgICAgICBpZiAoeWVhciAhPT0gcGFydHMueWVhciB8fFxuICAgICAgICAgICAgbW9udGggIT09IHBhcnRzLm1vbnRoIHx8XG4gICAgICAgICAgICBkYXkgIT09IHBhcnRzLmRheSB8fFxuICAgICAgICAgICAgaG91ciAhPT0gcGFydHMuaG91ciB8fFxuICAgICAgICAgICAgbWludXRlICE9PSBwYXJ0cy5taW51dGUgfHxcbiAgICAgICAgICAgIHNlY29uZCAhPT0gcGFydHMuc2Vjb25kIHx8XG4gICAgICAgICAgICBtaWxsaXNlY29uZCAhPT0gcGFydHMubWlsbGlzZWNvbmQgfHxcbiAgICAgICAgICAgIG1pY3Jvc2Vjb25kICE9PSBwYXJ0cy5taWNyb3NlY29uZCB8fFxuICAgICAgICAgICAgbmFub3NlY29uZCAhPT0gcGFydHMubmFub3NlY29uZCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXBvY2hOYW5vc2Vjb25kcztcbiAgICB9KVxuICAgICAgICAuZmlsdGVyKCh4KSA9PiB4ICE9PSB1bmRlZmluZWQpO1xufVxuZnVuY3Rpb24gTGVhcFllYXIoeWVhcikge1xuICAgIGlmICh1bmRlZmluZWQgPT09IHllYXIpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBjb25zdCBpc0RpdjQgPSB5ZWFyICUgNCA9PT0gMDtcbiAgICBjb25zdCBpc0RpdjEwMCA9IHllYXIgJSAxMDAgPT09IDA7XG4gICAgY29uc3QgaXNEaXY0MDAgPSB5ZWFyICUgNDAwID09PSAwO1xuICAgIHJldHVybiBpc0RpdjQgJiYgKCFpc0RpdjEwMCB8fCBpc0RpdjQwMCk7XG59XG5mdW5jdGlvbiBJU09EYXlzSW5Nb250aCh5ZWFyLCBtb250aCkge1xuICAgIGNvbnN0IERvTSA9IHtcbiAgICAgICAgc3RhbmRhcmQ6IFszMSwgMjgsIDMxLCAzMCwgMzEsIDMwLCAzMSwgMzEsIDMwLCAzMSwgMzAsIDMxXSxcbiAgICAgICAgbGVhcHllYXI6IFszMSwgMjksIDMxLCAzMCwgMzEsIDMwLCAzMSwgMzEsIDMwLCAzMSwgMzAsIDMxXVxuICAgIH07XG4gICAgcmV0dXJuIERvTVtMZWFwWWVhcih5ZWFyKSA/ICdsZWFweWVhcicgOiAnc3RhbmRhcmQnXVttb250aCAtIDFdO1xufVxuZnVuY3Rpb24gRGF5T2ZXZWVrKHllYXIsIG1vbnRoLCBkYXkpIHtcbiAgICBjb25zdCBtID0gbW9udGggKyAobW9udGggPCAzID8gMTAgOiAtMik7XG4gICAgY29uc3QgWSA9IHllYXIgLSAobW9udGggPCAzID8gMSA6IDApO1xuICAgIGNvbnN0IGMgPSBNYXRoRmxvb3IoWSAvIDEwMCk7XG4gICAgY29uc3QgeSA9IFkgLSBjICogMTAwO1xuICAgIGNvbnN0IGQgPSBkYXk7XG4gICAgY29uc3QgcEQgPSBkO1xuICAgIGNvbnN0IHBNID0gTWF0aEZsb29yKDIuNiAqIG0gLSAwLjIpO1xuICAgIGNvbnN0IHBZID0geSArIE1hdGhGbG9vcih5IC8gNCk7XG4gICAgY29uc3QgcEMgPSBNYXRoRmxvb3IoYyAvIDQpIC0gMiAqIGM7XG4gICAgY29uc3QgZG93ID0gKHBEICsgcE0gKyBwWSArIHBDKSAlIDc7XG4gICAgcmV0dXJuIGRvdyArIChkb3cgPD0gMCA/IDcgOiAwKTtcbn1cbmZ1bmN0aW9uIERheU9mWWVhcih5ZWFyLCBtb250aCwgZGF5KSB7XG4gICAgbGV0IGRheXMgPSBkYXk7XG4gICAgZm9yIChsZXQgbSA9IG1vbnRoIC0gMTsgbSA+IDA7IG0tLSkge1xuICAgICAgICBkYXlzICs9IElTT0RheXNJbk1vbnRoKHllYXIsIG0pO1xuICAgIH1cbiAgICByZXR1cm4gZGF5cztcbn1cbmZ1bmN0aW9uIFdlZWtPZlllYXIoeWVhciwgbW9udGgsIGRheSkge1xuICAgIGNvbnN0IGRveSA9IERheU9mWWVhcih5ZWFyLCBtb250aCwgZGF5KTtcbiAgICBjb25zdCBkb3cgPSBEYXlPZldlZWsoeWVhciwgbW9udGgsIGRheSkgfHwgNztcbiAgICBjb25zdCBkb2ogPSBEYXlPZldlZWsoeWVhciwgMSwgMSk7XG4gICAgY29uc3Qgd2VlayA9IE1hdGhGbG9vcigoZG95IC0gZG93ICsgMTApIC8gNyk7XG4gICAgaWYgKHdlZWsgPCAxKSB7XG4gICAgICAgIGlmIChkb2ogPT09IDUgfHwgKGRvaiA9PT0gNiAmJiBMZWFwWWVhcih5ZWFyIC0gMSkpKSB7XG4gICAgICAgICAgICByZXR1cm4gNTM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gNTI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHdlZWsgPT09IDUzKSB7XG4gICAgICAgIGlmICgoTGVhcFllYXIoeWVhcikgPyAzNjYgOiAzNjUpIC0gZG95IDwgNCAtIGRvdykge1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHdlZWs7XG59XG5mdW5jdGlvbiBEdXJhdGlvblNpZ24oeSwgbW9uLCB3LCBkLCBoLCBtaW4sIHMsIG1zLCDCtXMsIG5zKSB7XG4gICAgZm9yIChjb25zdCBwcm9wIG9mIFt5LCBtb24sIHcsIGQsIGgsIG1pbiwgcywgbXMsIMK1cywgbnNdKSB7XG4gICAgICAgIGlmIChwcm9wICE9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIHByb3AgPCAwID8gLTEgOiAxO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbn1cbmZ1bmN0aW9uIEJhbGFuY2VJU09ZZWFyTW9udGgoeWVhclBhcmFtLCBtb250aFBhcmFtKSB7XG4gICAgbGV0IHllYXIgPSB5ZWFyUGFyYW07XG4gICAgbGV0IG1vbnRoID0gbW9udGhQYXJhbTtcbiAgICBpZiAoIU51bWJlcklzRmluaXRlKHllYXIpIHx8ICFOdW1iZXJJc0Zpbml0ZShtb250aCkpXG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdpbmZpbml0eSBpcyBvdXQgb2YgcmFuZ2UnKTtcbiAgICBtb250aCAtPSAxO1xuICAgIHllYXIgKz0gTWF0aEZsb29yKG1vbnRoIC8gMTIpO1xuICAgIG1vbnRoICU9IDEyO1xuICAgIGlmIChtb250aCA8IDApXG4gICAgICAgIG1vbnRoICs9IDEyO1xuICAgIG1vbnRoICs9IDE7XG4gICAgcmV0dXJuIHsgeWVhciwgbW9udGggfTtcbn1cbmZ1bmN0aW9uIEJhbGFuY2VJU09EYXRlKHllYXJQYXJhbSwgbW9udGhQYXJhbSwgZGF5UGFyYW0pIHtcbiAgICBsZXQgeWVhciA9IHllYXJQYXJhbTtcbiAgICBsZXQgbW9udGggPSBtb250aFBhcmFtO1xuICAgIGxldCBkYXkgPSBkYXlQYXJhbTtcbiAgICBpZiAoIU51bWJlcklzRmluaXRlKGRheSkpXG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdpbmZpbml0eSBpcyBvdXQgb2YgcmFuZ2UnKTtcbiAgICAoeyB5ZWFyLCBtb250aCB9ID0gQmFsYW5jZUlTT1llYXJNb250aCh5ZWFyLCBtb250aCkpO1xuICAgIGxldCBkYXlzSW5ZZWFyID0gMDtcbiAgICBsZXQgdGVzdFllYXIgPSBtb250aCA+IDIgPyB5ZWFyIDogeWVhciAtIDE7XG4gICAgd2hpbGUgKCgoZGF5c0luWWVhciA9IExlYXBZZWFyKHRlc3RZZWFyKSA/IDM2NiA6IDM2NSksIGRheSA8IC1kYXlzSW5ZZWFyKSkge1xuICAgICAgICB5ZWFyIC09IDE7XG4gICAgICAgIHRlc3RZZWFyIC09IDE7XG4gICAgICAgIGRheSArPSBkYXlzSW5ZZWFyO1xuICAgIH1cbiAgICB0ZXN0WWVhciArPSAxO1xuICAgIHdoaWxlICgoKGRheXNJblllYXIgPSBMZWFwWWVhcih0ZXN0WWVhcikgPyAzNjYgOiAzNjUpLCBkYXkgPiBkYXlzSW5ZZWFyKSkge1xuICAgICAgICB5ZWFyICs9IDE7XG4gICAgICAgIHRlc3RZZWFyICs9IDE7XG4gICAgICAgIGRheSAtPSBkYXlzSW5ZZWFyO1xuICAgIH1cbiAgICB3aGlsZSAoZGF5IDwgMSkge1xuICAgICAgICAoeyB5ZWFyLCBtb250aCB9ID0gQmFsYW5jZUlTT1llYXJNb250aCh5ZWFyLCBtb250aCAtIDEpKTtcbiAgICAgICAgZGF5ICs9IElTT0RheXNJbk1vbnRoKHllYXIsIG1vbnRoKTtcbiAgICB9XG4gICAgd2hpbGUgKGRheSA+IElTT0RheXNJbk1vbnRoKHllYXIsIG1vbnRoKSkge1xuICAgICAgICBkYXkgLT0gSVNPRGF5c0luTW9udGgoeWVhciwgbW9udGgpO1xuICAgICAgICAoeyB5ZWFyLCBtb250aCB9ID0gQmFsYW5jZUlTT1llYXJNb250aCh5ZWFyLCBtb250aCArIDEpKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgeWVhciwgbW9udGgsIGRheSB9O1xufVxuZnVuY3Rpb24gQmFsYW5jZUlTT0RhdGVUaW1lKHllYXJQYXJhbSwgbW9udGhQYXJhbSwgZGF5UGFyYW0sIGhvdXJQYXJhbSwgbWludXRlUGFyYW0sIHNlY29uZFBhcmFtLCBtaWxsaXNlY29uZFBhcmFtLCBtaWNyb3NlY29uZFBhcmFtLCBuYW5vc2Vjb25kUGFyYW0pIHtcbiAgICBjb25zdCB7IGRlbHRhRGF5cywgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kLCBtaWNyb3NlY29uZCwgbmFub3NlY29uZCB9ID0gQmFsYW5jZVRpbWUoaG91clBhcmFtLCBtaW51dGVQYXJhbSwgc2Vjb25kUGFyYW0sIG1pbGxpc2Vjb25kUGFyYW0sIG1pY3Jvc2Vjb25kUGFyYW0sIG5hbm9zZWNvbmRQYXJhbSk7XG4gICAgY29uc3QgeyB5ZWFyLCBtb250aCwgZGF5IH0gPSBCYWxhbmNlSVNPRGF0ZSh5ZWFyUGFyYW0sIG1vbnRoUGFyYW0sIGRheVBhcmFtICsgZGVsdGFEYXlzKTtcbiAgICByZXR1cm4geyB5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQsIG1pY3Jvc2Vjb25kLCBuYW5vc2Vjb25kIH07XG59XG5mdW5jdGlvbiBCYWxhbmNlVGltZShob3VyUGFyYW0sIG1pbnV0ZVBhcmFtLCBzZWNvbmRQYXJhbSwgbWlsbGlzZWNvbmRQYXJhbSwgbWljcm9zZWNvbmRQYXJhbSwgbmFub3NlY29uZFBhcmFtKSB7XG4gICAgbGV0IGhvdXIgPSBob3VyUGFyYW07XG4gICAgbGV0IG1pbnV0ZSA9IG1pbnV0ZVBhcmFtO1xuICAgIGxldCBzZWNvbmQgPSBzZWNvbmRQYXJhbTtcbiAgICBsZXQgbWlsbGlzZWNvbmQgPSBtaWxsaXNlY29uZFBhcmFtO1xuICAgIGxldCBtaWNyb3NlY29uZCA9IG1pY3Jvc2Vjb25kUGFyYW07XG4gICAgbGV0IG5hbm9zZWNvbmQgPSBuYW5vc2Vjb25kUGFyYW07XG4gICAgaWYgKCFOdW1iZXJJc0Zpbml0ZShob3VyKSB8fFxuICAgICAgICAhTnVtYmVySXNGaW5pdGUobWludXRlKSB8fFxuICAgICAgICAhTnVtYmVySXNGaW5pdGUoc2Vjb25kKSB8fFxuICAgICAgICAhTnVtYmVySXNGaW5pdGUobWlsbGlzZWNvbmQpIHx8XG4gICAgICAgICFOdW1iZXJJc0Zpbml0ZShtaWNyb3NlY29uZCkgfHxcbiAgICAgICAgIU51bWJlcklzRmluaXRlKG5hbm9zZWNvbmQpKSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdpbmZpbml0eSBpcyBvdXQgb2YgcmFuZ2UnKTtcbiAgICB9XG4gICAgbWljcm9zZWNvbmQgKz0gTWF0aEZsb29yKG5hbm9zZWNvbmQgLyAxMDAwKTtcbiAgICBuYW5vc2Vjb25kID0gTm9uTmVnYXRpdmVNb2R1bG8obmFub3NlY29uZCwgMTAwMCk7XG4gICAgbWlsbGlzZWNvbmQgKz0gTWF0aEZsb29yKG1pY3Jvc2Vjb25kIC8gMTAwMCk7XG4gICAgbWljcm9zZWNvbmQgPSBOb25OZWdhdGl2ZU1vZHVsbyhtaWNyb3NlY29uZCwgMTAwMCk7XG4gICAgc2Vjb25kICs9IE1hdGhGbG9vcihtaWxsaXNlY29uZCAvIDEwMDApO1xuICAgIG1pbGxpc2Vjb25kID0gTm9uTmVnYXRpdmVNb2R1bG8obWlsbGlzZWNvbmQsIDEwMDApO1xuICAgIG1pbnV0ZSArPSBNYXRoRmxvb3Ioc2Vjb25kIC8gNjApO1xuICAgIHNlY29uZCA9IE5vbk5lZ2F0aXZlTW9kdWxvKHNlY29uZCwgNjApO1xuICAgIGhvdXIgKz0gTWF0aEZsb29yKG1pbnV0ZSAvIDYwKTtcbiAgICBtaW51dGUgPSBOb25OZWdhdGl2ZU1vZHVsbyhtaW51dGUsIDYwKTtcbiAgICBjb25zdCBkZWx0YURheXMgPSBNYXRoRmxvb3IoaG91ciAvIDI0KTtcbiAgICBob3VyID0gTm9uTmVnYXRpdmVNb2R1bG8oaG91ciwgMjQpO1xuICAgIHJldHVybiB7IGRlbHRhRGF5cywgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kLCBtaWNyb3NlY29uZCwgbmFub3NlY29uZCB9O1xufVxuZnVuY3Rpb24gVG90YWxEdXJhdGlvbk5hbm9zZWNvbmRzKGRheXNQYXJhbSwgaG91cnNQYXJhbSwgbWludXRlc1BhcmFtLCBzZWNvbmRzUGFyYW0sIG1pbGxpc2Vjb25kc1BhcmFtLCBtaWNyb3NlY29uZHNQYXJhbSwgbmFub3NlY29uZHNQYXJhbSwgb2Zmc2V0U2hpZnQpIHtcbiAgICBjb25zdCBkYXlzID0gSlNCSS5CaWdJbnQoZGF5c1BhcmFtKTtcbiAgICBsZXQgbmFub3NlY29uZHMgPSBKU0JJLkJpZ0ludChuYW5vc2Vjb25kc1BhcmFtKTtcbiAgICBpZiAoZGF5c1BhcmFtICE9PSAwKVxuICAgICAgICBuYW5vc2Vjb25kcyA9IEpTQkkuc3VidHJhY3QoSlNCSS5CaWdJbnQobmFub3NlY29uZHNQYXJhbSksIEpTQkkuQmlnSW50KG9mZnNldFNoaWZ0KSk7XG4gICAgY29uc3QgaG91cnMgPSBKU0JJLmFkZChKU0JJLkJpZ0ludChob3Vyc1BhcmFtKSwgSlNCSS5tdWx0aXBseShkYXlzLCBKU0JJLkJpZ0ludCgyNCkpKTtcbiAgICBjb25zdCBtaW51dGVzID0gSlNCSS5hZGQoSlNCSS5CaWdJbnQobWludXRlc1BhcmFtKSwgSlNCSS5tdWx0aXBseShob3VycywgU0lYVFkpKTtcbiAgICBjb25zdCBzZWNvbmRzID0gSlNCSS5hZGQoSlNCSS5CaWdJbnQoc2Vjb25kc1BhcmFtKSwgSlNCSS5tdWx0aXBseShtaW51dGVzLCBTSVhUWSkpO1xuICAgIGNvbnN0IG1pbGxpc2Vjb25kcyA9IEpTQkkuYWRkKEpTQkkuQmlnSW50KG1pbGxpc2Vjb25kc1BhcmFtKSwgSlNCSS5tdWx0aXBseShzZWNvbmRzLCBUSE9VU0FORCkpO1xuICAgIGNvbnN0IG1pY3Jvc2Vjb25kcyA9IEpTQkkuYWRkKEpTQkkuQmlnSW50KG1pY3Jvc2Vjb25kc1BhcmFtKSwgSlNCSS5tdWx0aXBseShtaWxsaXNlY29uZHMsIFRIT1VTQU5EKSk7XG4gICAgcmV0dXJuIEpTQkkuYWRkKEpTQkkuQmlnSW50KG5hbm9zZWNvbmRzKSwgSlNCSS5tdWx0aXBseShtaWNyb3NlY29uZHMsIFRIT1VTQU5EKSk7XG59XG5mdW5jdGlvbiBOYW5vc2Vjb25kc1RvRGF5cyhuYW5vc2Vjb25kc1BhcmFtLCByZWxhdGl2ZVRvKSB7XG4gICAgY29uc3QgVGVtcG9yYWxJbnN0YW50ID0gR2V0SW50cmluc2ljKCclVGVtcG9yYWwuSW5zdGFudCUnKTtcbiAgICBjb25zdCBzaWduID0gTWF0aFNpZ24oSlNCSS50b051bWJlcihuYW5vc2Vjb25kc1BhcmFtKSk7XG4gICAgbGV0IG5hbm9zZWNvbmRzID0gSlNCSS5CaWdJbnQobmFub3NlY29uZHNQYXJhbSk7XG4gICAgbGV0IGRheUxlbmd0aE5zID0gODY0MDBlOTtcbiAgICBpZiAoc2lnbiA9PT0gMClcbiAgICAgICAgcmV0dXJuIHsgZGF5czogMCwgbmFub3NlY29uZHM6IFpFUk8sIGRheUxlbmd0aE5zIH07XG4gICAgaWYgKCFJc1RlbXBvcmFsWm9uZWREYXRlVGltZShyZWxhdGl2ZVRvKSkge1xuICAgICAgICBsZXQgZGF5cztcbiAgICAgICAgKHsgcXVvdGllbnQ6IGRheXMsIHJlbWFpbmRlcjogbmFub3NlY29uZHMgfSA9IGRpdm1vZChuYW5vc2Vjb25kcywgSlNCSS5CaWdJbnQoZGF5TGVuZ3RoTnMpKSk7XG4gICAgICAgIHJldHVybiB7IGRheXM6IEpTQkkudG9OdW1iZXIoZGF5cyksIG5hbm9zZWNvbmRzLCBkYXlMZW5ndGhOcyB9O1xuICAgIH1cbiAgICBjb25zdCBzdGFydE5zID0gR2V0U2xvdChyZWxhdGl2ZVRvLCBFUE9DSE5BTk9TRUNPTkRTKTtcbiAgICBjb25zdCBzdGFydCA9IEdldFNsb3QocmVsYXRpdmVUbywgSU5TVEFOVCk7XG4gICAgY29uc3QgZW5kTnMgPSBKU0JJLmFkZChzdGFydE5zLCBuYW5vc2Vjb25kcyk7XG4gICAgY29uc3QgZW5kID0gbmV3IFRlbXBvcmFsSW5zdGFudChlbmROcyk7XG4gICAgY29uc3QgdGltZVpvbmUgPSBHZXRTbG90KHJlbGF0aXZlVG8sIFRJTUVfWk9ORSk7XG4gICAgY29uc3QgY2FsZW5kYXIgPSBHZXRTbG90KHJlbGF0aXZlVG8sIENBTEVOREFSKTtcbiAgICAvLyBGaW5kIHRoZSBkaWZmZXJlbmNlIGluIGRheXMgb25seS5cbiAgICBjb25zdCBkdFN0YXJ0ID0gQnVpbHRpblRpbWVab25lR2V0UGxhaW5EYXRlVGltZUZvcih0aW1lWm9uZSwgc3RhcnQsIGNhbGVuZGFyKTtcbiAgICBjb25zdCBkdEVuZCA9IEJ1aWx0aW5UaW1lWm9uZUdldFBsYWluRGF0ZVRpbWVGb3IodGltZVpvbmUsIGVuZCwgY2FsZW5kYXIpO1xuICAgIGxldCB7IGRheXMgfSA9IERpZmZlcmVuY2VJU09EYXRlVGltZShHZXRTbG90KGR0U3RhcnQsIElTT19ZRUFSKSwgR2V0U2xvdChkdFN0YXJ0LCBJU09fTU9OVEgpLCBHZXRTbG90KGR0U3RhcnQsIElTT19EQVkpLCBHZXRTbG90KGR0U3RhcnQsIElTT19IT1VSKSwgR2V0U2xvdChkdFN0YXJ0LCBJU09fTUlOVVRFKSwgR2V0U2xvdChkdFN0YXJ0LCBJU09fU0VDT05EKSwgR2V0U2xvdChkdFN0YXJ0LCBJU09fTUlMTElTRUNPTkQpLCBHZXRTbG90KGR0U3RhcnQsIElTT19NSUNST1NFQ09ORCksIEdldFNsb3QoZHRTdGFydCwgSVNPX05BTk9TRUNPTkQpLCBHZXRTbG90KGR0RW5kLCBJU09fWUVBUiksIEdldFNsb3QoZHRFbmQsIElTT19NT05USCksIEdldFNsb3QoZHRFbmQsIElTT19EQVkpLCBHZXRTbG90KGR0RW5kLCBJU09fSE9VUiksIEdldFNsb3QoZHRFbmQsIElTT19NSU5VVEUpLCBHZXRTbG90KGR0RW5kLCBJU09fU0VDT05EKSwgR2V0U2xvdChkdEVuZCwgSVNPX01JTExJU0VDT05EKSwgR2V0U2xvdChkdEVuZCwgSVNPX01JQ1JPU0VDT05EKSwgR2V0U2xvdChkdEVuZCwgSVNPX05BTk9TRUNPTkQpLCBjYWxlbmRhciwgJ2RheScpO1xuICAgIGxldCBpbnRlcm1lZGlhdGVOcyA9IEFkZFpvbmVkRGF0ZVRpbWUoc3RhcnQsIHRpbWVab25lLCBjYWxlbmRhciwgMCwgMCwgMCwgZGF5cywgMCwgMCwgMCwgMCwgMCwgMCk7XG4gICAgLy8gbWF5IGRpc2FtYmlndWF0ZVxuICAgIC8vIElmIGNsb2NrIHRpbWUgYWZ0ZXIgYWRkaXRpb24gd2FzIGluIHRoZSBtaWRkbGUgb2YgYSBza2lwcGVkIHBlcmlvZCwgdGhlXG4gICAgLy8gZW5kcG9pbnQgd2FzIGRpc2FtYmlndWF0ZWQgdG8gYSBsYXRlciBjbG9jayB0aW1lLiBTbyBpdCdzIHBvc3NpYmxlIHRoYXRcbiAgICAvLyB0aGUgcmVzdWx0aW5nIGRpc2FtYmlndWF0ZWQgcmVzdWx0IGlzIGxhdGVyIHRoYW4gZW5kTnMuIElmIHNvLCB0aGVuIGJhY2tcbiAgICAvLyB1cCBvbmUgZGF5IGFuZCB0cnkgYWdhaW4uIFJlcGVhdCBpZiBuZWNlc3NhcnkgKHNvbWUgdHJhbnNpdGlvbnMgYXJlXG4gICAgLy8gPiAyNCBob3VycykgdW50aWwgZWl0aGVyIHRoZXJlJ3MgemVybyBkYXlzIGxlZnQgb3IgdGhlIGRhdGUgZHVyYXRpb24gaXNcbiAgICAvLyBiYWNrIGluc2lkZSB0aGUgcGVyaW9kIHdoZXJlIGl0IGJlbG9uZ3MuIE5vdGUgdGhhdCB0aGlzIGNhc2Ugb25seSBjYW5cbiAgICAvLyBoYXBwZW4gZm9yIHBvc2l0aXZlIGR1cmF0aW9ucyBiZWNhdXNlIHRoZSBvbmx5IGRpcmVjdGlvbiB0aGF0XG4gICAgLy8gYGRpc2FtYmlndWF0aW9uOiAnY29tcGF0aWJsZSdgIGNhbiBjaGFuZ2UgY2xvY2sgdGltZSBpcyBmb3J3YXJkcy5cbiAgICBpZiAoc2lnbiA9PT0gMSkge1xuICAgICAgICB3aGlsZSAoZGF5cyA+IDAgJiYgSlNCSS5ncmVhdGVyVGhhbihpbnRlcm1lZGlhdGVOcywgZW5kTnMpKSB7XG4gICAgICAgICAgICAtLWRheXM7XG4gICAgICAgICAgICBpbnRlcm1lZGlhdGVOcyA9IEFkZFpvbmVkRGF0ZVRpbWUoc3RhcnQsIHRpbWVab25lLCBjYWxlbmRhciwgMCwgMCwgMCwgZGF5cywgMCwgMCwgMCwgMCwgMCwgMCk7XG4gICAgICAgICAgICAvLyBtYXkgZG8gZGlzYW1iaWd1YXRpb25cbiAgICAgICAgfVxuICAgIH1cbiAgICBuYW5vc2Vjb25kcyA9IEpTQkkuc3VidHJhY3QoZW5kTnMsIGludGVybWVkaWF0ZU5zKTtcbiAgICBsZXQgaXNPdmVyZmxvdyA9IGZhbHNlO1xuICAgIGxldCByZWxhdGl2ZUluc3RhbnQgPSBuZXcgVGVtcG9yYWxJbnN0YW50KGludGVybWVkaWF0ZU5zKTtcbiAgICBkbyB7XG4gICAgICAgIC8vIGNhbGN1bGF0ZSBsZW5ndGggb2YgdGhlIG5leHQgZGF5IChkYXkgdGhhdCBjb250YWlucyB0aGUgdGltZSByZW1haW5kZXIpXG4gICAgICAgIGNvbnN0IG9uZURheUZhcnRoZXJOcyA9IEFkZFpvbmVkRGF0ZVRpbWUocmVsYXRpdmVJbnN0YW50LCB0aW1lWm9uZSwgY2FsZW5kYXIsIDAsIDAsIDAsIHNpZ24sIDAsIDAsIDAsIDAsIDAsIDApO1xuICAgICAgICBjb25zdCByZWxhdGl2ZU5zID0gR2V0U2xvdChyZWxhdGl2ZUluc3RhbnQsIEVQT0NITkFOT1NFQ09ORFMpO1xuICAgICAgICBkYXlMZW5ndGhOcyA9IEpTQkkudG9OdW1iZXIoSlNCSS5zdWJ0cmFjdChvbmVEYXlGYXJ0aGVyTnMsIHJlbGF0aXZlTnMpKTtcbiAgICAgICAgaXNPdmVyZmxvdyA9IEpTQkkuZ3JlYXRlclRoYW4oSlNCSS5tdWx0aXBseShKU0JJLnN1YnRyYWN0KG5hbm9zZWNvbmRzLCBKU0JJLkJpZ0ludChkYXlMZW5ndGhOcykpLCBKU0JJLkJpZ0ludChzaWduKSksIFpFUk8pO1xuICAgICAgICBpZiAoaXNPdmVyZmxvdykge1xuICAgICAgICAgICAgbmFub3NlY29uZHMgPSBKU0JJLnN1YnRyYWN0KG5hbm9zZWNvbmRzLCBKU0JJLkJpZ0ludChkYXlMZW5ndGhOcykpO1xuICAgICAgICAgICAgcmVsYXRpdmVJbnN0YW50ID0gbmV3IFRlbXBvcmFsSW5zdGFudChvbmVEYXlGYXJ0aGVyTnMpO1xuICAgICAgICAgICAgZGF5cyArPSBzaWduO1xuICAgICAgICB9XG4gICAgfSB3aGlsZSAoaXNPdmVyZmxvdyk7XG4gICAgcmV0dXJuIHsgZGF5cywgbmFub3NlY29uZHMsIGRheUxlbmd0aE5zOiBNYXRoQWJzKGRheUxlbmd0aE5zKSB9O1xufVxuZnVuY3Rpb24gQmFsYW5jZUR1cmF0aW9uKGRheXNQYXJhbSwgaG91cnNQYXJhbSwgbWludXRlc1BhcmFtLCBzZWNvbmRzUGFyYW0sIG1pbGxpc2Vjb25kc1BhcmFtLCBtaWNyb3NlY29uZHNQYXJhbSwgbmFub3NlY29uZHNQYXJhbSwgbGFyZ2VzdFVuaXQsIHJlbGF0aXZlVG8gPSB1bmRlZmluZWQpIHtcbiAgICBsZXQgZGF5cyA9IGRheXNQYXJhbTtcbiAgICBsZXQgbmFub3NlY29uZHNCaWdJbnQsIG1pY3Jvc2Vjb25kc0JpZ0ludCwgbWlsbGlzZWNvbmRzQmlnSW50LCBzZWNvbmRzQmlnSW50LCBtaW51dGVzQmlnSW50LCBob3Vyc0JpZ0ludDtcbiAgICBpZiAoSXNUZW1wb3JhbFpvbmVkRGF0ZVRpbWUocmVsYXRpdmVUbykpIHtcbiAgICAgICAgY29uc3QgZW5kTnMgPSBBZGRab25lZERhdGVUaW1lKEdldFNsb3QocmVsYXRpdmVUbywgSU5TVEFOVCksIEdldFNsb3QocmVsYXRpdmVUbywgVElNRV9aT05FKSwgR2V0U2xvdChyZWxhdGl2ZVRvLCBDQUxFTkRBUiksIDAsIDAsIDAsIGRheXMsIGhvdXJzUGFyYW0sIG1pbnV0ZXNQYXJhbSwgc2Vjb25kc1BhcmFtLCBtaWxsaXNlY29uZHNQYXJhbSwgbWljcm9zZWNvbmRzUGFyYW0sIG5hbm9zZWNvbmRzUGFyYW0pO1xuICAgICAgICBjb25zdCBzdGFydE5zID0gR2V0U2xvdChyZWxhdGl2ZVRvLCBFUE9DSE5BTk9TRUNPTkRTKTtcbiAgICAgICAgbmFub3NlY29uZHNCaWdJbnQgPSBKU0JJLnN1YnRyYWN0KGVuZE5zLCBzdGFydE5zKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIG5hbm9zZWNvbmRzQmlnSW50ID0gVG90YWxEdXJhdGlvbk5hbm9zZWNvbmRzKGRheXMsIGhvdXJzUGFyYW0sIG1pbnV0ZXNQYXJhbSwgc2Vjb25kc1BhcmFtLCBtaWxsaXNlY29uZHNQYXJhbSwgbWljcm9zZWNvbmRzUGFyYW0sIG5hbm9zZWNvbmRzUGFyYW0sIDApO1xuICAgIH1cbiAgICBpZiAobGFyZ2VzdFVuaXQgPT09ICd5ZWFyJyB8fCBsYXJnZXN0VW5pdCA9PT0gJ21vbnRoJyB8fCBsYXJnZXN0VW5pdCA9PT0gJ3dlZWsnIHx8IGxhcmdlc3RVbml0ID09PSAnZGF5Jykge1xuICAgICAgICAoeyBkYXlzLCBuYW5vc2Vjb25kczogbmFub3NlY29uZHNCaWdJbnQgfSA9IE5hbm9zZWNvbmRzVG9EYXlzKG5hbm9zZWNvbmRzQmlnSW50LCByZWxhdGl2ZVRvKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBkYXlzID0gMDtcbiAgICB9XG4gICAgY29uc3Qgc2lnbiA9IEpTQkkubGVzc1RoYW4obmFub3NlY29uZHNCaWdJbnQsIFpFUk8pID8gLTEgOiAxO1xuICAgIG5hbm9zZWNvbmRzQmlnSW50ID0gYWJzKG5hbm9zZWNvbmRzQmlnSW50KTtcbiAgICBtaWNyb3NlY29uZHNCaWdJbnQgPSBtaWxsaXNlY29uZHNCaWdJbnQgPSBzZWNvbmRzQmlnSW50ID0gbWludXRlc0JpZ0ludCA9IGhvdXJzQmlnSW50ID0gWkVSTztcbiAgICBzd2l0Y2ggKGxhcmdlc3RVbml0KSB7XG4gICAgICAgIGNhc2UgJ3llYXInOlxuICAgICAgICBjYXNlICdtb250aCc6XG4gICAgICAgIGNhc2UgJ3dlZWsnOlxuICAgICAgICBjYXNlICdkYXknOlxuICAgICAgICBjYXNlICdob3VyJzpcbiAgICAgICAgICAgICh7IHF1b3RpZW50OiBtaWNyb3NlY29uZHNCaWdJbnQsIHJlbWFpbmRlcjogbmFub3NlY29uZHNCaWdJbnQgfSA9IGRpdm1vZChuYW5vc2Vjb25kc0JpZ0ludCwgVEhPVVNBTkQpKTtcbiAgICAgICAgICAgICh7IHF1b3RpZW50OiBtaWxsaXNlY29uZHNCaWdJbnQsIHJlbWFpbmRlcjogbWljcm9zZWNvbmRzQmlnSW50IH0gPSBkaXZtb2QobWljcm9zZWNvbmRzQmlnSW50LCBUSE9VU0FORCkpO1xuICAgICAgICAgICAgKHsgcXVvdGllbnQ6IHNlY29uZHNCaWdJbnQsIHJlbWFpbmRlcjogbWlsbGlzZWNvbmRzQmlnSW50IH0gPSBkaXZtb2QobWlsbGlzZWNvbmRzQmlnSW50LCBUSE9VU0FORCkpO1xuICAgICAgICAgICAgKHsgcXVvdGllbnQ6IG1pbnV0ZXNCaWdJbnQsIHJlbWFpbmRlcjogc2Vjb25kc0JpZ0ludCB9ID0gZGl2bW9kKHNlY29uZHNCaWdJbnQsIFNJWFRZKSk7XG4gICAgICAgICAgICAoeyBxdW90aWVudDogaG91cnNCaWdJbnQsIHJlbWFpbmRlcjogbWludXRlc0JpZ0ludCB9ID0gZGl2bW9kKG1pbnV0ZXNCaWdJbnQsIFNJWFRZKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnbWludXRlJzpcbiAgICAgICAgICAgICh7IHF1b3RpZW50OiBtaWNyb3NlY29uZHNCaWdJbnQsIHJlbWFpbmRlcjogbmFub3NlY29uZHNCaWdJbnQgfSA9IGRpdm1vZChuYW5vc2Vjb25kc0JpZ0ludCwgVEhPVVNBTkQpKTtcbiAgICAgICAgICAgICh7IHF1b3RpZW50OiBtaWxsaXNlY29uZHNCaWdJbnQsIHJlbWFpbmRlcjogbWljcm9zZWNvbmRzQmlnSW50IH0gPSBkaXZtb2QobWljcm9zZWNvbmRzQmlnSW50LCBUSE9VU0FORCkpO1xuICAgICAgICAgICAgKHsgcXVvdGllbnQ6IHNlY29uZHNCaWdJbnQsIHJlbWFpbmRlcjogbWlsbGlzZWNvbmRzQmlnSW50IH0gPSBkaXZtb2QobWlsbGlzZWNvbmRzQmlnSW50LCBUSE9VU0FORCkpO1xuICAgICAgICAgICAgKHsgcXVvdGllbnQ6IG1pbnV0ZXNCaWdJbnQsIHJlbWFpbmRlcjogc2Vjb25kc0JpZ0ludCB9ID0gZGl2bW9kKHNlY29uZHNCaWdJbnQsIFNJWFRZKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnc2Vjb25kJzpcbiAgICAgICAgICAgICh7IHF1b3RpZW50OiBtaWNyb3NlY29uZHNCaWdJbnQsIHJlbWFpbmRlcjogbmFub3NlY29uZHNCaWdJbnQgfSA9IGRpdm1vZChuYW5vc2Vjb25kc0JpZ0ludCwgVEhPVVNBTkQpKTtcbiAgICAgICAgICAgICh7IHF1b3RpZW50OiBtaWxsaXNlY29uZHNCaWdJbnQsIHJlbWFpbmRlcjogbWljcm9zZWNvbmRzQmlnSW50IH0gPSBkaXZtb2QobWljcm9zZWNvbmRzQmlnSW50LCBUSE9VU0FORCkpO1xuICAgICAgICAgICAgKHsgcXVvdGllbnQ6IHNlY29uZHNCaWdJbnQsIHJlbWFpbmRlcjogbWlsbGlzZWNvbmRzQmlnSW50IH0gPSBkaXZtb2QobWlsbGlzZWNvbmRzQmlnSW50LCBUSE9VU0FORCkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ21pbGxpc2Vjb25kJzpcbiAgICAgICAgICAgICh7IHF1b3RpZW50OiBtaWNyb3NlY29uZHNCaWdJbnQsIHJlbWFpbmRlcjogbmFub3NlY29uZHNCaWdJbnQgfSA9IGRpdm1vZChuYW5vc2Vjb25kc0JpZ0ludCwgVEhPVVNBTkQpKTtcbiAgICAgICAgICAgICh7IHF1b3RpZW50OiBtaWxsaXNlY29uZHNCaWdJbnQsIHJlbWFpbmRlcjogbWljcm9zZWNvbmRzQmlnSW50IH0gPSBkaXZtb2QobWljcm9zZWNvbmRzQmlnSW50LCBUSE9VU0FORCkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ21pY3Jvc2Vjb25kJzpcbiAgICAgICAgICAgICh7IHF1b3RpZW50OiBtaWNyb3NlY29uZHNCaWdJbnQsIHJlbWFpbmRlcjogbmFub3NlY29uZHNCaWdJbnQgfSA9IGRpdm1vZChuYW5vc2Vjb25kc0JpZ0ludCwgVEhPVVNBTkQpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICduYW5vc2Vjb25kJzpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhc3NlcnQgbm90IHJlYWNoZWQnKTtcbiAgICB9XG4gICAgY29uc3QgaG91cnMgPSBKU0JJLnRvTnVtYmVyKGhvdXJzQmlnSW50KSAqIHNpZ247XG4gICAgY29uc3QgbWludXRlcyA9IEpTQkkudG9OdW1iZXIobWludXRlc0JpZ0ludCkgKiBzaWduO1xuICAgIGNvbnN0IHNlY29uZHMgPSBKU0JJLnRvTnVtYmVyKHNlY29uZHNCaWdJbnQpICogc2lnbjtcbiAgICBjb25zdCBtaWxsaXNlY29uZHMgPSBKU0JJLnRvTnVtYmVyKG1pbGxpc2Vjb25kc0JpZ0ludCkgKiBzaWduO1xuICAgIGNvbnN0IG1pY3Jvc2Vjb25kcyA9IEpTQkkudG9OdW1iZXIobWljcm9zZWNvbmRzQmlnSW50KSAqIHNpZ247XG4gICAgY29uc3QgbmFub3NlY29uZHMgPSBKU0JJLnRvTnVtYmVyKG5hbm9zZWNvbmRzQmlnSW50KSAqIHNpZ247XG4gICAgcmV0dXJuIHsgZGF5cywgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc2Vjb25kcywgbWljcm9zZWNvbmRzLCBuYW5vc2Vjb25kcyB9O1xufVxuZnVuY3Rpb24gVW5iYWxhbmNlRHVyYXRpb25SZWxhdGl2ZSh5ZWFyc1BhcmFtLCBtb250aHNQYXJhbSwgd2Vla3NQYXJhbSwgZGF5c1BhcmFtLCBsYXJnZXN0VW5pdCwgcmVsYXRpdmVUb1BhcmFtKSB7XG4gICAgbGV0IHllYXJzID0geWVhcnNQYXJhbTtcbiAgICBsZXQgbW9udGhzID0gbW9udGhzUGFyYW07XG4gICAgbGV0IHdlZWtzID0gd2Vla3NQYXJhbTtcbiAgICBsZXQgZGF5cyA9IGRheXNQYXJhbTtcbiAgICBjb25zdCBUZW1wb3JhbER1cmF0aW9uID0gR2V0SW50cmluc2ljKCclVGVtcG9yYWwuRHVyYXRpb24lJyk7XG4gICAgY29uc3Qgc2lnbiA9IER1cmF0aW9uU2lnbih5ZWFycywgbW9udGhzLCB3ZWVrcywgZGF5cywgMCwgMCwgMCwgMCwgMCwgMCk7XG4gICAgbGV0IGNhbGVuZGFyO1xuICAgIGxldCByZWxhdGl2ZVRvO1xuICAgIGlmIChyZWxhdGl2ZVRvUGFyYW0pIHtcbiAgICAgICAgcmVsYXRpdmVUbyA9IFRvVGVtcG9yYWxEYXRlKHJlbGF0aXZlVG9QYXJhbSk7XG4gICAgICAgIGNhbGVuZGFyID0gR2V0U2xvdChyZWxhdGl2ZVRvLCBDQUxFTkRBUik7XG4gICAgfVxuICAgIGNvbnN0IG9uZVllYXIgPSBuZXcgVGVtcG9yYWxEdXJhdGlvbihzaWduKTtcbiAgICBjb25zdCBvbmVNb250aCA9IG5ldyBUZW1wb3JhbER1cmF0aW9uKDAsIHNpZ24pO1xuICAgIGNvbnN0IG9uZVdlZWsgPSBuZXcgVGVtcG9yYWxEdXJhdGlvbigwLCAwLCBzaWduKTtcbiAgICBzd2l0Y2ggKGxhcmdlc3RVbml0KSB7XG4gICAgICAgIGNhc2UgJ3llYXInOlxuICAgICAgICAgICAgLy8gbm8tb3BcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdtb250aCc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaWYgKCFjYWxlbmRhcilcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2Egc3RhcnRpbmcgcG9pbnQgaXMgcmVxdWlyZWQgZm9yIG1vbnRocyBiYWxhbmNpbmcnKTtcbiAgICAgICAgICAgICAgICAvLyBiYWxhbmNlIHllYXJzIGRvd24gdG8gbW9udGhzXG4gICAgICAgICAgICAgICAgY29uc3QgZGF0ZUFkZCA9IGNhbGVuZGFyLmRhdGVBZGQ7XG4gICAgICAgICAgICAgICAgY29uc3QgZGF0ZVVudGlsID0gY2FsZW5kYXIuZGF0ZVVudGlsO1xuICAgICAgICAgICAgICAgIGxldCByZWxhdGl2ZVRvRGF0ZU9ubHkgPSByZWxhdGl2ZVRvO1xuICAgICAgICAgICAgICAgIHdoaWxlIChNYXRoQWJzKHllYXJzKSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYWRkT3B0aW9ucyA9IE9iamVjdENyZWF0ZSQyKG51bGwpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXdSZWxhdGl2ZVRvID0gQ2FsZW5kYXJEYXRlQWRkKGNhbGVuZGFyLCByZWxhdGl2ZVRvRGF0ZU9ubHksIG9uZVllYXIsIGFkZE9wdGlvbnMsIGRhdGVBZGQpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB1bnRpbE9wdGlvbnMgPSBPYmplY3RDcmVhdGUkMihudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgdW50aWxPcHRpb25zLmxhcmdlc3RVbml0ID0gJ21vbnRoJztcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdW50aWxSZXN1bHQgPSBDYWxlbmRhckRhdGVVbnRpbChjYWxlbmRhciwgcmVsYXRpdmVUb0RhdGVPbmx5LCBuZXdSZWxhdGl2ZVRvLCB1bnRpbE9wdGlvbnMsIGRhdGVVbnRpbCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG9uZVllYXJNb250aHMgPSBHZXRTbG90KHVudGlsUmVzdWx0LCBNT05USFMpO1xuICAgICAgICAgICAgICAgICAgICByZWxhdGl2ZVRvRGF0ZU9ubHkgPSBuZXdSZWxhdGl2ZVRvO1xuICAgICAgICAgICAgICAgICAgICBtb250aHMgKz0gb25lWWVhck1vbnRocztcbiAgICAgICAgICAgICAgICAgICAgeWVhcnMgLT0gc2lnbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnd2Vlayc6XG4gICAgICAgICAgICBpZiAoIWNhbGVuZGFyKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdhIHN0YXJ0aW5nIHBvaW50IGlzIHJlcXVpcmVkIGZvciB3ZWVrcyBiYWxhbmNpbmcnKTtcbiAgICAgICAgICAgIC8vIGJhbGFuY2UgeWVhcnMgZG93biB0byBkYXlzXG4gICAgICAgICAgICB3aGlsZSAoTWF0aEFicyh5ZWFycykgPiAwKSB7XG4gICAgICAgICAgICAgICAgbGV0IG9uZVllYXJEYXlzO1xuICAgICAgICAgICAgICAgICh7IHJlbGF0aXZlVG8sIGRheXM6IG9uZVllYXJEYXlzIH0gPSBNb3ZlUmVsYXRpdmVEYXRlKGNhbGVuZGFyLCByZWxhdGl2ZVRvLCBvbmVZZWFyKSk7XG4gICAgICAgICAgICAgICAgZGF5cyArPSBvbmVZZWFyRGF5cztcbiAgICAgICAgICAgICAgICB5ZWFycyAtPSBzaWduO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gYmFsYW5jZSBtb250aHMgZG93biB0byBkYXlzXG4gICAgICAgICAgICB3aGlsZSAoTWF0aEFicyhtb250aHMpID4gMCkge1xuICAgICAgICAgICAgICAgIGxldCBvbmVNb250aERheXM7XG4gICAgICAgICAgICAgICAgKHsgcmVsYXRpdmVUbywgZGF5czogb25lTW9udGhEYXlzIH0gPSBNb3ZlUmVsYXRpdmVEYXRlKGNhbGVuZGFyLCByZWxhdGl2ZVRvLCBvbmVNb250aCkpO1xuICAgICAgICAgICAgICAgIGRheXMgKz0gb25lTW9udGhEYXlzO1xuICAgICAgICAgICAgICAgIG1vbnRocyAtPSBzaWduO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAvLyBiYWxhbmNlIHllYXJzIGRvd24gdG8gZGF5c1xuICAgICAgICAgICAgd2hpbGUgKE1hdGhBYnMoeWVhcnMpID4gMCkge1xuICAgICAgICAgICAgICAgIGlmICghY2FsZW5kYXIpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdhIHN0YXJ0aW5nIHBvaW50IGlzIHJlcXVpcmVkIGZvciBiYWxhbmNpbmcgY2FsZW5kYXIgdW5pdHMnKTtcbiAgICAgICAgICAgICAgICBsZXQgb25lWWVhckRheXM7XG4gICAgICAgICAgICAgICAgKHsgcmVsYXRpdmVUbywgZGF5czogb25lWWVhckRheXMgfSA9IE1vdmVSZWxhdGl2ZURhdGUoY2FsZW5kYXIsIHJlbGF0aXZlVG8sIG9uZVllYXIpKTtcbiAgICAgICAgICAgICAgICBkYXlzICs9IG9uZVllYXJEYXlzO1xuICAgICAgICAgICAgICAgIHllYXJzIC09IHNpZ247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBiYWxhbmNlIG1vbnRocyBkb3duIHRvIGRheXNcbiAgICAgICAgICAgIHdoaWxlIChNYXRoQWJzKG1vbnRocykgPiAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFjYWxlbmRhcilcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2Egc3RhcnRpbmcgcG9pbnQgaXMgcmVxdWlyZWQgZm9yIGJhbGFuY2luZyBjYWxlbmRhciB1bml0cycpO1xuICAgICAgICAgICAgICAgIGxldCBvbmVNb250aERheXM7XG4gICAgICAgICAgICAgICAgKHsgcmVsYXRpdmVUbywgZGF5czogb25lTW9udGhEYXlzIH0gPSBNb3ZlUmVsYXRpdmVEYXRlKGNhbGVuZGFyLCByZWxhdGl2ZVRvLCBvbmVNb250aCkpO1xuICAgICAgICAgICAgICAgIGRheXMgKz0gb25lTW9udGhEYXlzO1xuICAgICAgICAgICAgICAgIG1vbnRocyAtPSBzaWduO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gYmFsYW5jZSB3ZWVrcyBkb3duIHRvIGRheXNcbiAgICAgICAgICAgIHdoaWxlIChNYXRoQWJzKHdlZWtzKSA+IDApIHtcbiAgICAgICAgICAgICAgICBpZiAoIWNhbGVuZGFyKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignYSBzdGFydGluZyBwb2ludCBpcyByZXF1aXJlZCBmb3IgYmFsYW5jaW5nIGNhbGVuZGFyIHVuaXRzJyk7XG4gICAgICAgICAgICAgICAgbGV0IG9uZVdlZWtEYXlzO1xuICAgICAgICAgICAgICAgICh7IHJlbGF0aXZlVG8sIGRheXM6IG9uZVdlZWtEYXlzIH0gPSBNb3ZlUmVsYXRpdmVEYXRlKGNhbGVuZGFyLCByZWxhdGl2ZVRvLCBvbmVXZWVrKSk7XG4gICAgICAgICAgICAgICAgZGF5cyArPSBvbmVXZWVrRGF5cztcbiAgICAgICAgICAgICAgICB3ZWVrcyAtPSBzaWduO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiB7IHllYXJzLCBtb250aHMsIHdlZWtzLCBkYXlzIH07XG59XG5mdW5jdGlvbiBCYWxhbmNlRHVyYXRpb25SZWxhdGl2ZSh5ZWFyc1BhcmFtLCBtb250aHNQYXJhbSwgd2Vla3NQYXJhbSwgZGF5c1BhcmFtLCBsYXJnZXN0VW5pdCwgcmVsYXRpdmVUb1BhcmFtKSB7XG4gICAgbGV0IHllYXJzID0geWVhcnNQYXJhbTtcbiAgICBsZXQgbW9udGhzID0gbW9udGhzUGFyYW07XG4gICAgbGV0IHdlZWtzID0gd2Vla3NQYXJhbTtcbiAgICBsZXQgZGF5cyA9IGRheXNQYXJhbTtcbiAgICBjb25zdCBUZW1wb3JhbER1cmF0aW9uID0gR2V0SW50cmluc2ljKCclVGVtcG9yYWwuRHVyYXRpb24lJyk7XG4gICAgY29uc3Qgc2lnbiA9IER1cmF0aW9uU2lnbih5ZWFycywgbW9udGhzLCB3ZWVrcywgZGF5cywgMCwgMCwgMCwgMCwgMCwgMCk7XG4gICAgaWYgKHNpZ24gPT09IDApXG4gICAgICAgIHJldHVybiB7IHllYXJzLCBtb250aHMsIHdlZWtzLCBkYXlzIH07XG4gICAgbGV0IGNhbGVuZGFyO1xuICAgIGxldCByZWxhdGl2ZVRvO1xuICAgIGlmIChyZWxhdGl2ZVRvUGFyYW0pIHtcbiAgICAgICAgcmVsYXRpdmVUbyA9IFRvVGVtcG9yYWxEYXRlKHJlbGF0aXZlVG9QYXJhbSk7XG4gICAgICAgIGNhbGVuZGFyID0gR2V0U2xvdChyZWxhdGl2ZVRvLCBDQUxFTkRBUik7XG4gICAgfVxuICAgIGNvbnN0IG9uZVllYXIgPSBuZXcgVGVtcG9yYWxEdXJhdGlvbihzaWduKTtcbiAgICBjb25zdCBvbmVNb250aCA9IG5ldyBUZW1wb3JhbER1cmF0aW9uKDAsIHNpZ24pO1xuICAgIGNvbnN0IG9uZVdlZWsgPSBuZXcgVGVtcG9yYWxEdXJhdGlvbigwLCAwLCBzaWduKTtcbiAgICBzd2l0Y2ggKGxhcmdlc3RVbml0KSB7XG4gICAgICAgIGNhc2UgJ3llYXInOiB7XG4gICAgICAgICAgICBpZiAoIWNhbGVuZGFyKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdhIHN0YXJ0aW5nIHBvaW50IGlzIHJlcXVpcmVkIGZvciB5ZWFycyBiYWxhbmNpbmcnKTtcbiAgICAgICAgICAgIC8vIGJhbGFuY2UgZGF5cyB1cCB0byB5ZWFyc1xuICAgICAgICAgICAgbGV0IG5ld1JlbGF0aXZlVG8sIG9uZVllYXJEYXlzO1xuICAgICAgICAgICAgKHsgcmVsYXRpdmVUbzogbmV3UmVsYXRpdmVUbywgZGF5czogb25lWWVhckRheXMgfSA9IE1vdmVSZWxhdGl2ZURhdGUoY2FsZW5kYXIsIHJlbGF0aXZlVG8sIG9uZVllYXIpKTtcbiAgICAgICAgICAgIHdoaWxlIChNYXRoQWJzKGRheXMpID49IE1hdGhBYnMob25lWWVhckRheXMpKSB7XG4gICAgICAgICAgICAgICAgZGF5cyAtPSBvbmVZZWFyRGF5cztcbiAgICAgICAgICAgICAgICB5ZWFycyArPSBzaWduO1xuICAgICAgICAgICAgICAgIHJlbGF0aXZlVG8gPSBuZXdSZWxhdGl2ZVRvO1xuICAgICAgICAgICAgICAgICh7IHJlbGF0aXZlVG86IG5ld1JlbGF0aXZlVG8sIGRheXM6IG9uZVllYXJEYXlzIH0gPSBNb3ZlUmVsYXRpdmVEYXRlKGNhbGVuZGFyLCByZWxhdGl2ZVRvLCBvbmVZZWFyKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBiYWxhbmNlIGRheXMgdXAgdG8gbW9udGhzXG4gICAgICAgICAgICBsZXQgb25lTW9udGhEYXlzO1xuICAgICAgICAgICAgKHsgcmVsYXRpdmVUbzogbmV3UmVsYXRpdmVUbywgZGF5czogb25lTW9udGhEYXlzIH0gPSBNb3ZlUmVsYXRpdmVEYXRlKGNhbGVuZGFyLCByZWxhdGl2ZVRvLCBvbmVNb250aCkpO1xuICAgICAgICAgICAgd2hpbGUgKE1hdGhBYnMoZGF5cykgPj0gTWF0aEFicyhvbmVNb250aERheXMpKSB7XG4gICAgICAgICAgICAgICAgZGF5cyAtPSBvbmVNb250aERheXM7XG4gICAgICAgICAgICAgICAgbW9udGhzICs9IHNpZ247XG4gICAgICAgICAgICAgICAgcmVsYXRpdmVUbyA9IG5ld1JlbGF0aXZlVG87XG4gICAgICAgICAgICAgICAgKHsgcmVsYXRpdmVUbzogbmV3UmVsYXRpdmVUbywgZGF5czogb25lTW9udGhEYXlzIH0gPSBNb3ZlUmVsYXRpdmVEYXRlKGNhbGVuZGFyLCByZWxhdGl2ZVRvLCBvbmVNb250aCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gYmFsYW5jZSBtb250aHMgdXAgdG8geWVhcnNcbiAgICAgICAgICAgIGNvbnN0IGRhdGVBZGQgPSBjYWxlbmRhci5kYXRlQWRkO1xuICAgICAgICAgICAgY29uc3QgYWRkT3B0aW9ucyA9IE9iamVjdENyZWF0ZSQyKG51bGwpO1xuICAgICAgICAgICAgbmV3UmVsYXRpdmVUbyA9IENhbGVuZGFyRGF0ZUFkZChjYWxlbmRhciwgcmVsYXRpdmVUbywgb25lWWVhciwgYWRkT3B0aW9ucywgZGF0ZUFkZCk7XG4gICAgICAgICAgICBjb25zdCBkYXRlVW50aWwgPSBjYWxlbmRhci5kYXRlVW50aWw7XG4gICAgICAgICAgICBjb25zdCB1bnRpbE9wdGlvbnMgPSBPYmplY3RDcmVhdGUkMihudWxsKTtcbiAgICAgICAgICAgIHVudGlsT3B0aW9ucy5sYXJnZXN0VW5pdCA9ICdtb250aCc7XG4gICAgICAgICAgICBsZXQgdW50aWxSZXN1bHQgPSBDYWxlbmRhckRhdGVVbnRpbChjYWxlbmRhciwgcmVsYXRpdmVUbywgbmV3UmVsYXRpdmVUbywgdW50aWxPcHRpb25zLCBkYXRlVW50aWwpO1xuICAgICAgICAgICAgbGV0IG9uZVllYXJNb250aHMgPSBHZXRTbG90KHVudGlsUmVzdWx0LCBNT05USFMpO1xuICAgICAgICAgICAgd2hpbGUgKE1hdGhBYnMobW9udGhzKSA+PSBNYXRoQWJzKG9uZVllYXJNb250aHMpKSB7XG4gICAgICAgICAgICAgICAgbW9udGhzIC09IG9uZVllYXJNb250aHM7XG4gICAgICAgICAgICAgICAgeWVhcnMgKz0gc2lnbjtcbiAgICAgICAgICAgICAgICByZWxhdGl2ZVRvID0gbmV3UmVsYXRpdmVUbztcbiAgICAgICAgICAgICAgICBjb25zdCBhZGRPcHRpb25zID0gT2JqZWN0Q3JlYXRlJDIobnVsbCk7XG4gICAgICAgICAgICAgICAgbmV3UmVsYXRpdmVUbyA9IENhbGVuZGFyRGF0ZUFkZChjYWxlbmRhciwgcmVsYXRpdmVUbywgb25lWWVhciwgYWRkT3B0aW9ucywgZGF0ZUFkZCk7XG4gICAgICAgICAgICAgICAgY29uc3QgdW50aWxPcHRpb25zID0gT2JqZWN0Q3JlYXRlJDIobnVsbCk7XG4gICAgICAgICAgICAgICAgdW50aWxPcHRpb25zLmxhcmdlc3RVbml0ID0gJ21vbnRoJztcbiAgICAgICAgICAgICAgICB1bnRpbFJlc3VsdCA9IENhbGVuZGFyRGF0ZVVudGlsKGNhbGVuZGFyLCByZWxhdGl2ZVRvLCBuZXdSZWxhdGl2ZVRvLCB1bnRpbE9wdGlvbnMsIGRhdGVVbnRpbCk7XG4gICAgICAgICAgICAgICAgb25lWWVhck1vbnRocyA9IEdldFNsb3QodW50aWxSZXN1bHQsIE1PTlRIUyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdtb250aCc6IHtcbiAgICAgICAgICAgIGlmICghY2FsZW5kYXIpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2Egc3RhcnRpbmcgcG9pbnQgaXMgcmVxdWlyZWQgZm9yIG1vbnRocyBiYWxhbmNpbmcnKTtcbiAgICAgICAgICAgIC8vIGJhbGFuY2UgZGF5cyB1cCB0byBtb250aHNcbiAgICAgICAgICAgIGxldCBuZXdSZWxhdGl2ZVRvLCBvbmVNb250aERheXM7XG4gICAgICAgICAgICAoeyByZWxhdGl2ZVRvOiBuZXdSZWxhdGl2ZVRvLCBkYXlzOiBvbmVNb250aERheXMgfSA9IE1vdmVSZWxhdGl2ZURhdGUoY2FsZW5kYXIsIHJlbGF0aXZlVG8sIG9uZU1vbnRoKSk7XG4gICAgICAgICAgICB3aGlsZSAoTWF0aEFicyhkYXlzKSA+PSBNYXRoQWJzKG9uZU1vbnRoRGF5cykpIHtcbiAgICAgICAgICAgICAgICBkYXlzIC09IG9uZU1vbnRoRGF5cztcbiAgICAgICAgICAgICAgICBtb250aHMgKz0gc2lnbjtcbiAgICAgICAgICAgICAgICByZWxhdGl2ZVRvID0gbmV3UmVsYXRpdmVUbztcbiAgICAgICAgICAgICAgICAoeyByZWxhdGl2ZVRvOiBuZXdSZWxhdGl2ZVRvLCBkYXlzOiBvbmVNb250aERheXMgfSA9IE1vdmVSZWxhdGl2ZURhdGUoY2FsZW5kYXIsIHJlbGF0aXZlVG8sIG9uZU1vbnRoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlICd3ZWVrJzoge1xuICAgICAgICAgICAgaWYgKCFjYWxlbmRhcilcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignYSBzdGFydGluZyBwb2ludCBpcyByZXF1aXJlZCBmb3Igd2Vla3MgYmFsYW5jaW5nJyk7XG4gICAgICAgICAgICAvLyBiYWxhbmNlIGRheXMgdXAgdG8gd2Vla3NcbiAgICAgICAgICAgIGxldCBuZXdSZWxhdGl2ZVRvLCBvbmVXZWVrRGF5cztcbiAgICAgICAgICAgICh7IHJlbGF0aXZlVG86IG5ld1JlbGF0aXZlVG8sIGRheXM6IG9uZVdlZWtEYXlzIH0gPSBNb3ZlUmVsYXRpdmVEYXRlKGNhbGVuZGFyLCByZWxhdGl2ZVRvLCBvbmVXZWVrKSk7XG4gICAgICAgICAgICB3aGlsZSAoTWF0aEFicyhkYXlzKSA+PSBNYXRoQWJzKG9uZVdlZWtEYXlzKSkge1xuICAgICAgICAgICAgICAgIGRheXMgLT0gb25lV2Vla0RheXM7XG4gICAgICAgICAgICAgICAgd2Vla3MgKz0gc2lnbjtcbiAgICAgICAgICAgICAgICByZWxhdGl2ZVRvID0gbmV3UmVsYXRpdmVUbztcbiAgICAgICAgICAgICAgICAoeyByZWxhdGl2ZVRvOiBuZXdSZWxhdGl2ZVRvLCBkYXlzOiBvbmVXZWVrRGF5cyB9ID0gTW92ZVJlbGF0aXZlRGF0ZShjYWxlbmRhciwgcmVsYXRpdmVUbywgb25lV2VlaykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgeWVhcnMsIG1vbnRocywgd2Vla3MsIGRheXMgfTtcbn1cbmZ1bmN0aW9uIENhbGN1bGF0ZU9mZnNldFNoaWZ0KHJlbGF0aXZlVG8sIHksIG1vbiwgdywgZCwgaCwgbWluLCBzLCBtcywgwrVzLCBucykge1xuICAgIGlmIChJc1RlbXBvcmFsWm9uZWREYXRlVGltZShyZWxhdGl2ZVRvKSkge1xuICAgICAgICBjb25zdCBpbnN0YW50ID0gR2V0U2xvdChyZWxhdGl2ZVRvLCBJTlNUQU5UKTtcbiAgICAgICAgY29uc3QgdGltZVpvbmUgPSBHZXRTbG90KHJlbGF0aXZlVG8sIFRJTUVfWk9ORSk7XG4gICAgICAgIGNvbnN0IGNhbGVuZGFyID0gR2V0U2xvdChyZWxhdGl2ZVRvLCBDQUxFTkRBUik7XG4gICAgICAgIGNvbnN0IG9mZnNldEJlZm9yZSA9IEdldE9mZnNldE5hbm9zZWNvbmRzRm9yKHRpbWVab25lLCBpbnN0YW50KTtcbiAgICAgICAgY29uc3QgYWZ0ZXIgPSBBZGRab25lZERhdGVUaW1lKGluc3RhbnQsIHRpbWVab25lLCBjYWxlbmRhciwgeSwgbW9uLCB3LCBkLCBoLCBtaW4sIHMsIG1zLCDCtXMsIG5zKTtcbiAgICAgICAgY29uc3QgVGVtcG9yYWxJbnN0YW50ID0gR2V0SW50cmluc2ljKCclVGVtcG9yYWwuSW5zdGFudCUnKTtcbiAgICAgICAgY29uc3QgaW5zdGFudEFmdGVyID0gbmV3IFRlbXBvcmFsSW5zdGFudChhZnRlcik7XG4gICAgICAgIGNvbnN0IG9mZnNldEFmdGVyID0gR2V0T2Zmc2V0TmFub3NlY29uZHNGb3IodGltZVpvbmUsIGluc3RhbnRBZnRlcik7XG4gICAgICAgIHJldHVybiBvZmZzZXRBZnRlciAtIG9mZnNldEJlZm9yZTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG59XG5mdW5jdGlvbiBDcmVhdGVOZWdhdGVkVGVtcG9yYWxEdXJhdGlvbihkdXJhdGlvbikge1xuICAgIGNvbnN0IFRlbXBvcmFsRHVyYXRpb24gPSBHZXRJbnRyaW5zaWMoJyVUZW1wb3JhbC5EdXJhdGlvbiUnKTtcbiAgICByZXR1cm4gbmV3IFRlbXBvcmFsRHVyYXRpb24oLUdldFNsb3QoZHVyYXRpb24sIFlFQVJTKSwgLUdldFNsb3QoZHVyYXRpb24sIE1PTlRIUyksIC1HZXRTbG90KGR1cmF0aW9uLCBXRUVLUyksIC1HZXRTbG90KGR1cmF0aW9uLCBEQVlTKSwgLUdldFNsb3QoZHVyYXRpb24sIEhPVVJTKSwgLUdldFNsb3QoZHVyYXRpb24sIE1JTlVURVMpLCAtR2V0U2xvdChkdXJhdGlvbiwgU0VDT05EUyksIC1HZXRTbG90KGR1cmF0aW9uLCBNSUxMSVNFQ09ORFMpLCAtR2V0U2xvdChkdXJhdGlvbiwgTUlDUk9TRUNPTkRTKSwgLUdldFNsb3QoZHVyYXRpb24sIE5BTk9TRUNPTkRTKSk7XG59XG5mdW5jdGlvbiBDb25zdHJhaW5Ub1JhbmdlKHZhbHVlLCBtaW4sIG1heCkge1xuICAgIC8vIE1hdGguTWF4IGFjY2VwdHMgdW5kZWZpbmVkIHZhbHVlcyBhbmQgcmV0dXJucyBOYU4uIFVuZGVmaW5lZCB2YWx1ZXMgYXJlXG4gICAgLy8gdXNlZCBmb3Igb3B0aW9uYWwgcGFyYW1zIGluIHRoZSBtZXRob2QgYmVsb3cuXG4gICAgcmV0dXJuIE1hdGhNaW4obWF4LCBNYXRoTWF4KG1pbiwgdmFsdWUpKTtcbn1cbmZ1bmN0aW9uIENvbnN0cmFpbklTT0RhdGUoeWVhciwgbW9udGhQYXJhbSwgZGF5UGFyYW0pIHtcbiAgICBjb25zdCBtb250aCA9IENvbnN0cmFpblRvUmFuZ2UobW9udGhQYXJhbSwgMSwgMTIpO1xuICAgIGNvbnN0IGRheSA9IENvbnN0cmFpblRvUmFuZ2UoZGF5UGFyYW0sIDEsIElTT0RheXNJbk1vbnRoKHllYXIsIG1vbnRoKSk7XG4gICAgcmV0dXJuIHsgeWVhciwgbW9udGgsIGRheSB9O1xufVxuZnVuY3Rpb24gQ29uc3RyYWluVGltZShob3VyUGFyYW0sIG1pbnV0ZVBhcmFtLCBzZWNvbmRQYXJhbSwgbWlsbGlzZWNvbmRQYXJhbSwgbWljcm9zZWNvbmRQYXJhbSwgbmFub3NlY29uZFBhcmFtKSB7XG4gICAgY29uc3QgaG91ciA9IENvbnN0cmFpblRvUmFuZ2UoaG91clBhcmFtLCAwLCAyMyk7XG4gICAgY29uc3QgbWludXRlID0gQ29uc3RyYWluVG9SYW5nZShtaW51dGVQYXJhbSwgMCwgNTkpO1xuICAgIGNvbnN0IHNlY29uZCA9IENvbnN0cmFpblRvUmFuZ2Uoc2Vjb25kUGFyYW0sIDAsIDU5KTtcbiAgICBjb25zdCBtaWxsaXNlY29uZCA9IENvbnN0cmFpblRvUmFuZ2UobWlsbGlzZWNvbmRQYXJhbSwgMCwgOTk5KTtcbiAgICBjb25zdCBtaWNyb3NlY29uZCA9IENvbnN0cmFpblRvUmFuZ2UobWljcm9zZWNvbmRQYXJhbSwgMCwgOTk5KTtcbiAgICBjb25zdCBuYW5vc2Vjb25kID0gQ29uc3RyYWluVG9SYW5nZShuYW5vc2Vjb25kUGFyYW0sIDAsIDk5OSk7XG4gICAgcmV0dXJuIHsgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kLCBtaWNyb3NlY29uZCwgbmFub3NlY29uZCB9O1xufVxuZnVuY3Rpb24gUmVqZWN0VG9SYW5nZSh2YWx1ZSwgbWluLCBtYXgpIHtcbiAgICBpZiAodmFsdWUgPCBtaW4gfHwgdmFsdWUgPiBtYXgpXG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGB2YWx1ZSBvdXQgb2YgcmFuZ2U6ICR7bWlufSA8PSAke3ZhbHVlfSA8PSAke21heH1gKTtcbn1cbmZ1bmN0aW9uIFJlamVjdElTT0RhdGUoeWVhciwgbW9udGgsIGRheSkge1xuICAgIFJlamVjdFRvUmFuZ2UobW9udGgsIDEsIDEyKTtcbiAgICBSZWplY3RUb1JhbmdlKGRheSwgMSwgSVNPRGF5c0luTW9udGgoeWVhciwgbW9udGgpKTtcbn1cbmZ1bmN0aW9uIFJlamVjdERhdGVSYW5nZSh5ZWFyLCBtb250aCwgZGF5KSB7XG4gICAgLy8gTm9vbiBhdm9pZHMgdHJvdWJsZSBhdCBlZGdlcyBvZiBEYXRlVGltZSByYW5nZSAoZXhjbHVkZXMgbWlkbmlnaHQpXG4gICAgUmVqZWN0RGF0ZVRpbWVSYW5nZSh5ZWFyLCBtb250aCwgZGF5LCAxMiwgMCwgMCwgMCwgMCwgMCk7XG59XG5mdW5jdGlvbiBSZWplY3RUaW1lKGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZCwgbWljcm9zZWNvbmQsIG5hbm9zZWNvbmQpIHtcbiAgICBSZWplY3RUb1JhbmdlKGhvdXIsIDAsIDIzKTtcbiAgICBSZWplY3RUb1JhbmdlKG1pbnV0ZSwgMCwgNTkpO1xuICAgIFJlamVjdFRvUmFuZ2Uoc2Vjb25kLCAwLCA1OSk7XG4gICAgUmVqZWN0VG9SYW5nZShtaWxsaXNlY29uZCwgMCwgOTk5KTtcbiAgICBSZWplY3RUb1JhbmdlKG1pY3Jvc2Vjb25kLCAwLCA5OTkpO1xuICAgIFJlamVjdFRvUmFuZ2UobmFub3NlY29uZCwgMCwgOTk5KTtcbn1cbmZ1bmN0aW9uIFJlamVjdERhdGVUaW1lKHllYXIsIG1vbnRoLCBkYXksIGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZCwgbWljcm9zZWNvbmQsIG5hbm9zZWNvbmQpIHtcbiAgICBSZWplY3RJU09EYXRlKHllYXIsIG1vbnRoLCBkYXkpO1xuICAgIFJlamVjdFRpbWUoaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kLCBtaWNyb3NlY29uZCwgbmFub3NlY29uZCk7XG59XG5mdW5jdGlvbiBSZWplY3REYXRlVGltZVJhbmdlKHllYXIsIG1vbnRoLCBkYXksIGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZCwgbWljcm9zZWNvbmQsIG5hbm9zZWNvbmQpIHtcbiAgICBSZWplY3RUb1JhbmdlKHllYXIsIFlFQVJfTUlOLCBZRUFSX01BWCk7XG4gICAgLy8gUmVqZWN0IGFueSBEYXRlVGltZSAyNCBob3VycyBvciBtb3JlIG91dHNpZGUgdGhlIEluc3RhbnQgcmFuZ2VcbiAgICBpZiAoKHllYXIgPT09IFlFQVJfTUlOICYmXG4gICAgICAgIG51bGwgPT1cbiAgICAgICAgICAgIEdldEVwb2NoRnJvbUlTT1BhcnRzKHllYXIsIG1vbnRoLCBkYXkgKyAxLCBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQsIG1pY3Jvc2Vjb25kLCBuYW5vc2Vjb25kIC0gMSkpIHx8XG4gICAgICAgICh5ZWFyID09PSBZRUFSX01BWCAmJlxuICAgICAgICAgICAgbnVsbCA9PVxuICAgICAgICAgICAgICAgIEdldEVwb2NoRnJvbUlTT1BhcnRzKHllYXIsIG1vbnRoLCBkYXkgLSAxLCBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQsIG1pY3Jvc2Vjb25kLCBuYW5vc2Vjb25kICsgMSkpKSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdEYXRlVGltZSBvdXRzaWRlIG9mIHN1cHBvcnRlZCByYW5nZScpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIFZhbGlkYXRlRXBvY2hOYW5vc2Vjb25kcyhlcG9jaE5hbm9zZWNvbmRzKSB7XG4gICAgaWYgKEpTQkkubGVzc1RoYW4oZXBvY2hOYW5vc2Vjb25kcywgTlNfTUlOKSB8fCBKU0JJLmdyZWF0ZXJUaGFuKGVwb2NoTmFub3NlY29uZHMsIE5TX01BWCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luc3RhbnQgb3V0c2lkZSBvZiBzdXBwb3J0ZWQgcmFuZ2UnKTtcbiAgICB9XG59XG5mdW5jdGlvbiBSZWplY3RZZWFyTW9udGhSYW5nZSh5ZWFyLCBtb250aCkge1xuICAgIFJlamVjdFRvUmFuZ2UoeWVhciwgWUVBUl9NSU4sIFlFQVJfTUFYKTtcbiAgICBpZiAoeWVhciA9PT0gWUVBUl9NSU4pIHtcbiAgICAgICAgUmVqZWN0VG9SYW5nZShtb250aCwgNCwgMTIpO1xuICAgIH1cbiAgICBlbHNlIGlmICh5ZWFyID09PSBZRUFSX01BWCkge1xuICAgICAgICBSZWplY3RUb1JhbmdlKG1vbnRoLCAxLCA5KTtcbiAgICB9XG59XG5mdW5jdGlvbiBSZWplY3REdXJhdGlvbih5LCBtb24sIHcsIGQsIGgsIG1pbiwgcywgbXMsIMK1cywgbnMpIHtcbiAgICBjb25zdCBzaWduID0gRHVyYXRpb25TaWduKHksIG1vbiwgdywgZCwgaCwgbWluLCBzLCBtcywgwrVzLCBucyk7XG4gICAgZm9yIChjb25zdCBwcm9wIG9mIFt5LCBtb24sIHcsIGQsIGgsIG1pbiwgcywgbXMsIMK1cywgbnNdKSB7XG4gICAgICAgIGlmICghTnVtYmVySXNGaW5pdGUocHJvcCkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignaW5maW5pdGUgdmFsdWVzIG5vdCBhbGxvd2VkIGFzIGR1cmF0aW9uIGZpZWxkcycpO1xuICAgICAgICBjb25zdCBwcm9wU2lnbiA9IE1hdGhTaWduKHByb3ApO1xuICAgICAgICBpZiAocHJvcFNpZ24gIT09IDAgJiYgcHJvcFNpZ24gIT09IHNpZ24pXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignbWl4ZWQtc2lnbiB2YWx1ZXMgbm90IGFsbG93ZWQgYXMgZHVyYXRpb24gZmllbGRzJyk7XG4gICAgfVxufVxuZnVuY3Rpb24gRGlmZmVyZW5jZUlTT0RhdGUoeTEsIG0xLCBkMSwgeTIsIG0yLCBkMiwgbGFyZ2VzdFVuaXQpIHtcbiAgICBzd2l0Y2ggKGxhcmdlc3RVbml0KSB7XG4gICAgICAgIGNhc2UgJ3llYXInOlxuICAgICAgICBjYXNlICdtb250aCc6IHtcbiAgICAgICAgICAgIGNvbnN0IHNpZ24gPSAtQ29tcGFyZUlTT0RhdGUoeTEsIG0xLCBkMSwgeTIsIG0yLCBkMik7XG4gICAgICAgICAgICBpZiAoc2lnbiA9PT0gMClcbiAgICAgICAgICAgICAgICByZXR1cm4geyB5ZWFyczogMCwgbW9udGhzOiAwLCB3ZWVrczogMCwgZGF5czogMCB9O1xuICAgICAgICAgICAgY29uc3Qgc3RhcnQgPSB7IHllYXI6IHkxLCBtb250aDogbTEsIGRheTogZDEgfTtcbiAgICAgICAgICAgIGNvbnN0IGVuZCA9IHsgeWVhcjogeTIsIG1vbnRoOiBtMiwgZGF5OiBkMiB9O1xuICAgICAgICAgICAgbGV0IHllYXJzID0gZW5kLnllYXIgLSBzdGFydC55ZWFyO1xuICAgICAgICAgICAgbGV0IG1pZCA9IEFkZElTT0RhdGUoeTEsIG0xLCBkMSwgeWVhcnMsIDAsIDAsIDAsICdjb25zdHJhaW4nKTtcbiAgICAgICAgICAgIGxldCBtaWRTaWduID0gLUNvbXBhcmVJU09EYXRlKG1pZC55ZWFyLCBtaWQubW9udGgsIG1pZC5kYXksIHkyLCBtMiwgZDIpO1xuICAgICAgICAgICAgaWYgKG1pZFNpZ24gPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbGFyZ2VzdFVuaXQgPT09ICd5ZWFyJ1xuICAgICAgICAgICAgICAgICAgICA/IHsgeWVhcnMsIG1vbnRoczogMCwgd2Vla3M6IDAsIGRheXM6IDAgfVxuICAgICAgICAgICAgICAgICAgICA6IHsgeWVhcnM6IDAsIG1vbnRoczogeWVhcnMgKiAxMiwgd2Vla3M6IDAsIGRheXM6IDAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBtb250aHMgPSBlbmQubW9udGggLSBzdGFydC5tb250aDtcbiAgICAgICAgICAgIGlmIChtaWRTaWduICE9PSBzaWduKSB7XG4gICAgICAgICAgICAgICAgeWVhcnMgLT0gc2lnbjtcbiAgICAgICAgICAgICAgICBtb250aHMgKz0gc2lnbiAqIDEyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWlkID0gQWRkSVNPRGF0ZSh5MSwgbTEsIGQxLCB5ZWFycywgbW9udGhzLCAwLCAwLCAnY29uc3RyYWluJyk7XG4gICAgICAgICAgICBtaWRTaWduID0gLUNvbXBhcmVJU09EYXRlKG1pZC55ZWFyLCBtaWQubW9udGgsIG1pZC5kYXksIHkyLCBtMiwgZDIpO1xuICAgICAgICAgICAgaWYgKG1pZFNpZ24gPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbGFyZ2VzdFVuaXQgPT09ICd5ZWFyJ1xuICAgICAgICAgICAgICAgICAgICA/IHsgeWVhcnMsIG1vbnRocywgd2Vla3M6IDAsIGRheXM6IDAgfVxuICAgICAgICAgICAgICAgICAgICA6IHsgeWVhcnM6IDAsIG1vbnRoczogbW9udGhzICsgeWVhcnMgKiAxMiwgd2Vla3M6IDAsIGRheXM6IDAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtaWRTaWduICE9PSBzaWduKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIGVuZCBkYXRlIGlzIGxhdGVyIGluIHRoZSBtb250aCB0aGFuIG1pZCBkYXRlIChvciBlYXJsaWVyIGZvclxuICAgICAgICAgICAgICAgIC8vIG5lZ2F0aXZlIGR1cmF0aW9ucykuIEJhY2sgdXAgb25lIG1vbnRoLlxuICAgICAgICAgICAgICAgIG1vbnRocyAtPSBzaWduO1xuICAgICAgICAgICAgICAgIGlmIChtb250aHMgPT09IC1zaWduKSB7XG4gICAgICAgICAgICAgICAgICAgIHllYXJzIC09IHNpZ247XG4gICAgICAgICAgICAgICAgICAgIG1vbnRocyA9IDExICogc2lnbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbWlkID0gQWRkSVNPRGF0ZSh5MSwgbTEsIGQxLCB5ZWFycywgbW9udGhzLCAwLCAwLCAnY29uc3RyYWluJyk7XG4gICAgICAgICAgICAgICAgbWlkU2lnbiA9IC1Db21wYXJlSVNPRGF0ZSh5MSwgbTEsIGQxLCBtaWQueWVhciwgbWlkLm1vbnRoLCBtaWQuZGF5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBkYXlzID0gMDtcbiAgICAgICAgICAgIC8vIElmIHdlIGdldCBoZXJlLCBtb250aHMgYW5kIHllYXJzIGFyZSBjb3JyZWN0IChubyBvdmVyZmxvdyksIGFuZCBgbWlkYFxuICAgICAgICAgICAgLy8gaXMgd2l0aGluIHRoZSByYW5nZSBmcm9tIGBzdGFydGAgdG8gYGVuZGAuIFRvIGNvdW50IHRoZSBkYXlzIGJldHdlZW5cbiAgICAgICAgICAgIC8vIGBtaWRgIGFuZCBgZW5kYCwgdGhlcmUgYXJlIDMgY2FzZXM6XG4gICAgICAgICAgICAvLyAxKSBzYW1lIG1vbnRoOiB1c2Ugc2ltcGxlIHN1YnRyYWN0aW9uXG4gICAgICAgICAgICAvLyAyKSBlbmQgaXMgcHJldmlvdXMgbW9udGggZnJvbSBpbnRlcm1lZGlhdGUgKG5lZ2F0aXZlIGR1cmF0aW9uKVxuICAgICAgICAgICAgLy8gMykgZW5kIGlzIG5leHQgbW9udGggZnJvbSBpbnRlcm1lZGlhdGUgKHBvc2l0aXZlIGR1cmF0aW9uKVxuICAgICAgICAgICAgaWYgKG1pZC5tb250aCA9PT0gZW5kLm1vbnRoKSB7XG4gICAgICAgICAgICAgICAgLy8gMSkgc2FtZSBtb250aDogdXNlIHNpbXBsZSBzdWJ0cmFjdGlvblxuICAgICAgICAgICAgICAgIGRheXMgPSBlbmQuZGF5IC0gbWlkLmRheTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHNpZ24gPCAwKSB7XG4gICAgICAgICAgICAgICAgLy8gMikgZW5kIGlzIHByZXZpb3VzIG1vbnRoIGZyb20gaW50ZXJtZWRpYXRlIChuZWdhdGl2ZSBkdXJhdGlvbilcbiAgICAgICAgICAgICAgICAvLyBFeGFtcGxlOiBpbnRlcm1lZGlhdGU6IEZlYiAxLCBlbmQ6IEphbiAzMCwgRGF5c0luTW9udGggPSAzMSwgZGF5cyA9IC0yXG4gICAgICAgICAgICAgICAgZGF5cyA9IC1taWQuZGF5IC0gKElTT0RheXNJbk1vbnRoKGVuZC55ZWFyLCBlbmQubW9udGgpIC0gZW5kLmRheSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyAzKSBlbmQgaXMgbmV4dCBtb250aCBmcm9tIGludGVybWVkaWF0ZSAocG9zaXRpdmUgZHVyYXRpb24pXG4gICAgICAgICAgICAgICAgLy8gRXhhbXBsZTogaW50ZXJtZWRpYXRlOiBKYW4gMjksIGVuZDogRmViIDEsIERheXNJbk1vbnRoID0gMzEsIGRheXMgPSAzXG4gICAgICAgICAgICAgICAgZGF5cyA9IGVuZC5kYXkgKyAoSVNPRGF5c0luTW9udGgobWlkLnllYXIsIG1pZC5tb250aCkgLSBtaWQuZGF5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsYXJnZXN0VW5pdCA9PT0gJ21vbnRoJykge1xuICAgICAgICAgICAgICAgIG1vbnRocyArPSB5ZWFycyAqIDEyO1xuICAgICAgICAgICAgICAgIHllYXJzID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7IHllYXJzLCBtb250aHMsIHdlZWtzOiAwLCBkYXlzIH07XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnd2Vlayc6XG4gICAgICAgIGNhc2UgJ2RheSc6IHtcbiAgICAgICAgICAgIGxldCBsYXJnZXIsIHNtYWxsZXIsIHNpZ247XG4gICAgICAgICAgICBpZiAoQ29tcGFyZUlTT0RhdGUoeTEsIG0xLCBkMSwgeTIsIG0yLCBkMikgPCAwKSB7XG4gICAgICAgICAgICAgICAgc21hbGxlciA9IHsgeWVhcjogeTEsIG1vbnRoOiBtMSwgZGF5OiBkMSB9O1xuICAgICAgICAgICAgICAgIGxhcmdlciA9IHsgeWVhcjogeTIsIG1vbnRoOiBtMiwgZGF5OiBkMiB9O1xuICAgICAgICAgICAgICAgIHNpZ24gPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc21hbGxlciA9IHsgeWVhcjogeTIsIG1vbnRoOiBtMiwgZGF5OiBkMiB9O1xuICAgICAgICAgICAgICAgIGxhcmdlciA9IHsgeWVhcjogeTEsIG1vbnRoOiBtMSwgZGF5OiBkMSB9O1xuICAgICAgICAgICAgICAgIHNpZ24gPSAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBkYXlzID0gRGF5T2ZZZWFyKGxhcmdlci55ZWFyLCBsYXJnZXIubW9udGgsIGxhcmdlci5kYXkpIC0gRGF5T2ZZZWFyKHNtYWxsZXIueWVhciwgc21hbGxlci5tb250aCwgc21hbGxlci5kYXkpO1xuICAgICAgICAgICAgZm9yIChsZXQgeWVhciA9IHNtYWxsZXIueWVhcjsgeWVhciA8IGxhcmdlci55ZWFyOyArK3llYXIpIHtcbiAgICAgICAgICAgICAgICBkYXlzICs9IExlYXBZZWFyKHllYXIpID8gMzY2IDogMzY1O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHdlZWtzID0gMDtcbiAgICAgICAgICAgIGlmIChsYXJnZXN0VW5pdCA9PT0gJ3dlZWsnKSB7XG4gICAgICAgICAgICAgICAgd2Vla3MgPSBNYXRoRmxvb3IoZGF5cyAvIDcpO1xuICAgICAgICAgICAgICAgIGRheXMgJT0gNztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdlZWtzICo9IHNpZ247XG4gICAgICAgICAgICBkYXlzICo9IHNpZ247XG4gICAgICAgICAgICByZXR1cm4geyB5ZWFyczogMCwgbW9udGhzOiAwLCB3ZWVrcywgZGF5cyB9O1xuICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Fzc2VydCBub3QgcmVhY2hlZCcpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIERpZmZlcmVuY2VUaW1lKGgxLCBtaW4xLCBzMSwgbXMxLCDCtXMxLCBuczEsIGgyLCBtaW4yLCBzMiwgbXMyLCDCtXMyLCBuczIpIHtcbiAgICBsZXQgaG91cnMgPSBoMiAtIGgxO1xuICAgIGxldCBtaW51dGVzID0gbWluMiAtIG1pbjE7XG4gICAgbGV0IHNlY29uZHMgPSBzMiAtIHMxO1xuICAgIGxldCBtaWxsaXNlY29uZHMgPSBtczIgLSBtczE7XG4gICAgbGV0IG1pY3Jvc2Vjb25kcyA9IMK1czIgLSDCtXMxO1xuICAgIGxldCBuYW5vc2Vjb25kcyA9IG5zMiAtIG5zMTtcbiAgICBjb25zdCBzaWduID0gRHVyYXRpb25TaWduKDAsIDAsIDAsIDAsIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBtaWxsaXNlY29uZHMsIG1pY3Jvc2Vjb25kcywgbmFub3NlY29uZHMpO1xuICAgIGhvdXJzICo9IHNpZ247XG4gICAgbWludXRlcyAqPSBzaWduO1xuICAgIHNlY29uZHMgKj0gc2lnbjtcbiAgICBtaWxsaXNlY29uZHMgKj0gc2lnbjtcbiAgICBtaWNyb3NlY29uZHMgKj0gc2lnbjtcbiAgICBuYW5vc2Vjb25kcyAqPSBzaWduO1xuICAgIGxldCBkZWx0YURheXMgPSAwO1xuICAgICh7XG4gICAgICAgIGRlbHRhRGF5cyxcbiAgICAgICAgaG91cjogaG91cnMsXG4gICAgICAgIG1pbnV0ZTogbWludXRlcyxcbiAgICAgICAgc2Vjb25kOiBzZWNvbmRzLFxuICAgICAgICBtaWxsaXNlY29uZDogbWlsbGlzZWNvbmRzLFxuICAgICAgICBtaWNyb3NlY29uZDogbWljcm9zZWNvbmRzLFxuICAgICAgICBuYW5vc2Vjb25kOiBuYW5vc2Vjb25kc1xuICAgIH0gPSBCYWxhbmNlVGltZShob3VycywgbWludXRlcywgc2Vjb25kcywgbWlsbGlzZWNvbmRzLCBtaWNyb3NlY29uZHMsIG5hbm9zZWNvbmRzKSk7XG4gICAgZGVsdGFEYXlzICo9IHNpZ247XG4gICAgaG91cnMgKj0gc2lnbjtcbiAgICBtaW51dGVzICo9IHNpZ247XG4gICAgc2Vjb25kcyAqPSBzaWduO1xuICAgIG1pbGxpc2Vjb25kcyAqPSBzaWduO1xuICAgIG1pY3Jvc2Vjb25kcyAqPSBzaWduO1xuICAgIG5hbm9zZWNvbmRzICo9IHNpZ247XG4gICAgcmV0dXJuIHsgZGVsdGFEYXlzLCBob3VycywgbWludXRlcywgc2Vjb25kcywgbWlsbGlzZWNvbmRzLCBtaWNyb3NlY29uZHMsIG5hbm9zZWNvbmRzIH07XG59XG5mdW5jdGlvbiBEaWZmZXJlbmNlSW5zdGFudChuczEsIG5zMiwgaW5jcmVtZW50LCB1bml0LCByb3VuZGluZ01vZGUpIHtcbiAgICBjb25zdCBkaWZmID0gSlNCSS5zdWJ0cmFjdChuczIsIG5zMSk7XG4gICAgY29uc3QgcmVtYWluZGVyID0gSlNCSS5yZW1haW5kZXIoZGlmZiwgSlNCSS5CaWdJbnQoODY0MDBlOSkpO1xuICAgIGNvbnN0IHdob2xlRGF5cyA9IEpTQkkuc3VidHJhY3QoZGlmZiwgcmVtYWluZGVyKTtcbiAgICBjb25zdCByb3VuZGVkUmVtYWluZGVyID0gUm91bmROdW1iZXJUb0luY3JlbWVudChyZW1haW5kZXIsIG5zUGVyVGltZVVuaXRbdW5pdF0gKiBpbmNyZW1lbnQsIHJvdW5kaW5nTW9kZSk7XG4gICAgY29uc3Qgcm91bmRlZERpZmYgPSBKU0JJLmFkZCh3aG9sZURheXMsIHJvdW5kZWRSZW1haW5kZXIpO1xuICAgIGNvbnN0IG5hbm9zZWNvbmRzID0gSlNCSS50b051bWJlcihKU0JJLnJlbWFpbmRlcihyb3VuZGVkRGlmZiwgVEhPVVNBTkQpKTtcbiAgICBjb25zdCBtaWNyb3NlY29uZHMgPSBKU0JJLnRvTnVtYmVyKEpTQkkucmVtYWluZGVyKEpTQkkuZGl2aWRlKHJvdW5kZWREaWZmLCBUSE9VU0FORCksIFRIT1VTQU5EKSk7XG4gICAgY29uc3QgbWlsbGlzZWNvbmRzID0gSlNCSS50b051bWJlcihKU0JJLnJlbWFpbmRlcihKU0JJLmRpdmlkZShyb3VuZGVkRGlmZiwgTUlMTElPTiksIFRIT1VTQU5EKSk7XG4gICAgY29uc3Qgc2Vjb25kcyA9IEpTQkkudG9OdW1iZXIoSlNCSS5kaXZpZGUocm91bmRlZERpZmYsIEJJTExJT04pKTtcbiAgICByZXR1cm4geyBzZWNvbmRzLCBtaWxsaXNlY29uZHMsIG1pY3Jvc2Vjb25kcywgbmFub3NlY29uZHMgfTtcbn1cbmZ1bmN0aW9uIERpZmZlcmVuY2VJU09EYXRlVGltZSh5MVBhcmFtLCBtb24xUGFyYW0sIGQxUGFyYW0sIGgxLCBtaW4xLCBzMSwgbXMxLCDCtXMxLCBuczEsIHkyLCBtb24yLCBkMiwgaDIsIG1pbjIsIHMyLCBtczIsIMK1czIsIG5zMiwgY2FsZW5kYXIsIGxhcmdlc3RVbml0LCBvcHRpb25zID0gT2JqZWN0Q3JlYXRlJDIobnVsbCkpIHtcbiAgICBsZXQgeTEgPSB5MVBhcmFtO1xuICAgIGxldCBtb24xID0gbW9uMVBhcmFtO1xuICAgIGxldCBkMSA9IGQxUGFyYW07XG4gICAgbGV0IHsgZGVsdGFEYXlzLCBob3VycywgbWludXRlcywgc2Vjb25kcywgbWlsbGlzZWNvbmRzLCBtaWNyb3NlY29uZHMsIG5hbm9zZWNvbmRzIH0gPSBEaWZmZXJlbmNlVGltZShoMSwgbWluMSwgczEsIG1zMSwgwrVzMSwgbnMxLCBoMiwgbWluMiwgczIsIG1zMiwgwrVzMiwgbnMyKTtcbiAgICBjb25zdCB0aW1lU2lnbiA9IER1cmF0aW9uU2lnbigwLCAwLCAwLCBkZWx0YURheXMsIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBtaWxsaXNlY29uZHMsIG1pY3Jvc2Vjb25kcywgbmFub3NlY29uZHMpO1xuICAgICh7IHllYXI6IHkxLCBtb250aDogbW9uMSwgZGF5OiBkMSB9ID0gQmFsYW5jZUlTT0RhdGUoeTEsIG1vbjEsIGQxICsgZGVsdGFEYXlzKSk7XG4gICAgY29uc3QgZGF0ZVNpZ24gPSBDb21wYXJlSVNPRGF0ZSh5MiwgbW9uMiwgZDIsIHkxLCBtb24xLCBkMSk7XG4gICAgaWYgKGRhdGVTaWduID09PSAtdGltZVNpZ24pIHtcbiAgICAgICAgKHsgeWVhcjogeTEsIG1vbnRoOiBtb24xLCBkYXk6IGQxIH0gPSBCYWxhbmNlSVNPRGF0ZSh5MSwgbW9uMSwgZDEgLSB0aW1lU2lnbikpO1xuICAgICAgICAoeyBob3VycywgbWludXRlcywgc2Vjb25kcywgbWlsbGlzZWNvbmRzLCBtaWNyb3NlY29uZHMsIG5hbm9zZWNvbmRzIH0gPSBCYWxhbmNlRHVyYXRpb24oLXRpbWVTaWduLCBob3VycywgbWludXRlcywgc2Vjb25kcywgbWlsbGlzZWNvbmRzLCBtaWNyb3NlY29uZHMsIG5hbm9zZWNvbmRzLCBsYXJnZXN0VW5pdCkpO1xuICAgIH1cbiAgICBjb25zdCBkYXRlMSA9IENyZWF0ZVRlbXBvcmFsRGF0ZSh5MSwgbW9uMSwgZDEsIGNhbGVuZGFyKTtcbiAgICBjb25zdCBkYXRlMiA9IENyZWF0ZVRlbXBvcmFsRGF0ZSh5MiwgbW9uMiwgZDIsIGNhbGVuZGFyKTtcbiAgICBjb25zdCBkYXRlTGFyZ2VzdFVuaXQgPSBMYXJnZXJPZlR3b1RlbXBvcmFsVW5pdHMoJ2RheScsIGxhcmdlc3RVbml0KTtcbiAgICBjb25zdCB1bnRpbE9wdGlvbnMgPSB7IC4uLm9wdGlvbnMsIGxhcmdlc3RVbml0OiBkYXRlTGFyZ2VzdFVuaXQgfTtcbiAgICBsZXQgeyB5ZWFycywgbW9udGhzLCB3ZWVrcywgZGF5cyB9ID0gQ2FsZW5kYXJEYXRlVW50aWwoY2FsZW5kYXIsIGRhdGUxLCBkYXRlMiwgdW50aWxPcHRpb25zKTtcbiAgICAvLyBTaWducyBvZiBkYXRlIHBhcnQgYW5kIHRpbWUgcGFydCBtYXkgbm90IGFncmVlOyBiYWxhbmNlIHRoZW0gdG9nZXRoZXJcbiAgICAoeyBkYXlzLCBob3VycywgbWludXRlcywgc2Vjb25kcywgbWlsbGlzZWNvbmRzLCBtaWNyb3NlY29uZHMsIG5hbm9zZWNvbmRzIH0gPSBCYWxhbmNlRHVyYXRpb24oZGF5cywgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc2Vjb25kcywgbWljcm9zZWNvbmRzLCBuYW5vc2Vjb25kcywgbGFyZ2VzdFVuaXQpKTtcbiAgICByZXR1cm4geyB5ZWFycywgbW9udGhzLCB3ZWVrcywgZGF5cywgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc2Vjb25kcywgbWljcm9zZWNvbmRzLCBuYW5vc2Vjb25kcyB9O1xufVxuZnVuY3Rpb24gRGlmZmVyZW5jZVpvbmVkRGF0ZVRpbWUobnMxLCBuczIsIHRpbWVab25lLCBjYWxlbmRhciwgbGFyZ2VzdFVuaXQsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBuc0RpZmYgPSBKU0JJLnN1YnRyYWN0KG5zMiwgbnMxKTtcbiAgICBpZiAoSlNCSS5lcXVhbChuc0RpZmYsIFpFUk8pKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB5ZWFyczogMCxcbiAgICAgICAgICAgIG1vbnRoczogMCxcbiAgICAgICAgICAgIHdlZWtzOiAwLFxuICAgICAgICAgICAgZGF5czogMCxcbiAgICAgICAgICAgIGhvdXJzOiAwLFxuICAgICAgICAgICAgbWludXRlczogMCxcbiAgICAgICAgICAgIHNlY29uZHM6IDAsXG4gICAgICAgICAgICBtaWxsaXNlY29uZHM6IDAsXG4gICAgICAgICAgICBtaWNyb3NlY29uZHM6IDAsXG4gICAgICAgICAgICBuYW5vc2Vjb25kczogMFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBGaW5kIHRoZSBkaWZmZXJlbmNlIGluIGRhdGVzIG9ubHkuXG4gICAgY29uc3QgVGVtcG9yYWxJbnN0YW50ID0gR2V0SW50cmluc2ljKCclVGVtcG9yYWwuSW5zdGFudCUnKTtcbiAgICBjb25zdCBzdGFydCA9IG5ldyBUZW1wb3JhbEluc3RhbnQobnMxKTtcbiAgICBjb25zdCBlbmQgPSBuZXcgVGVtcG9yYWxJbnN0YW50KG5zMik7XG4gICAgY29uc3QgZHRTdGFydCA9IEJ1aWx0aW5UaW1lWm9uZUdldFBsYWluRGF0ZVRpbWVGb3IodGltZVpvbmUsIHN0YXJ0LCBjYWxlbmRhcik7XG4gICAgY29uc3QgZHRFbmQgPSBCdWlsdGluVGltZVpvbmVHZXRQbGFpbkRhdGVUaW1lRm9yKHRpbWVab25lLCBlbmQsIGNhbGVuZGFyKTtcbiAgICBsZXQgeyB5ZWFycywgbW9udGhzLCB3ZWVrcywgZGF5cyB9ID0gRGlmZmVyZW5jZUlTT0RhdGVUaW1lKEdldFNsb3QoZHRTdGFydCwgSVNPX1lFQVIpLCBHZXRTbG90KGR0U3RhcnQsIElTT19NT05USCksIEdldFNsb3QoZHRTdGFydCwgSVNPX0RBWSksIEdldFNsb3QoZHRTdGFydCwgSVNPX0hPVVIpLCBHZXRTbG90KGR0U3RhcnQsIElTT19NSU5VVEUpLCBHZXRTbG90KGR0U3RhcnQsIElTT19TRUNPTkQpLCBHZXRTbG90KGR0U3RhcnQsIElTT19NSUxMSVNFQ09ORCksIEdldFNsb3QoZHRTdGFydCwgSVNPX01JQ1JPU0VDT05EKSwgR2V0U2xvdChkdFN0YXJ0LCBJU09fTkFOT1NFQ09ORCksIEdldFNsb3QoZHRFbmQsIElTT19ZRUFSKSwgR2V0U2xvdChkdEVuZCwgSVNPX01PTlRIKSwgR2V0U2xvdChkdEVuZCwgSVNPX0RBWSksIEdldFNsb3QoZHRFbmQsIElTT19IT1VSKSwgR2V0U2xvdChkdEVuZCwgSVNPX01JTlVURSksIEdldFNsb3QoZHRFbmQsIElTT19TRUNPTkQpLCBHZXRTbG90KGR0RW5kLCBJU09fTUlMTElTRUNPTkQpLCBHZXRTbG90KGR0RW5kLCBJU09fTUlDUk9TRUNPTkQpLCBHZXRTbG90KGR0RW5kLCBJU09fTkFOT1NFQ09ORCksIGNhbGVuZGFyLCBsYXJnZXN0VW5pdCwgb3B0aW9ucyk7XG4gICAgY29uc3QgaW50ZXJtZWRpYXRlTnMgPSBBZGRab25lZERhdGVUaW1lKHN0YXJ0LCB0aW1lWm9uZSwgY2FsZW5kYXIsIHllYXJzLCBtb250aHMsIHdlZWtzLCAwLCAwLCAwLCAwLCAwLCAwLCAwKTtcbiAgICAvLyBtYXkgZGlzYW1iaWd1YXRlXG4gICAgbGV0IHRpbWVSZW1haW5kZXJOcyA9IEpTQkkuc3VidHJhY3QobnMyLCBpbnRlcm1lZGlhdGVOcyk7XG4gICAgY29uc3QgaW50ZXJtZWRpYXRlID0gQ3JlYXRlVGVtcG9yYWxab25lZERhdGVUaW1lKGludGVybWVkaWF0ZU5zLCB0aW1lWm9uZSwgY2FsZW5kYXIpO1xuICAgICh7IG5hbm9zZWNvbmRzOiB0aW1lUmVtYWluZGVyTnMsIGRheXMgfSA9IE5hbm9zZWNvbmRzVG9EYXlzKHRpbWVSZW1haW5kZXJOcywgaW50ZXJtZWRpYXRlKSk7XG4gICAgLy8gRmluYWxseSwgbWVyZ2UgdGhlIGRhdGUgYW5kIHRpbWUgZHVyYXRpb25zIGFuZCByZXR1cm4gdGhlIG1lcmdlZCByZXN1bHQuXG4gICAgY29uc3QgeyBob3VycywgbWludXRlcywgc2Vjb25kcywgbWlsbGlzZWNvbmRzLCBtaWNyb3NlY29uZHMsIG5hbm9zZWNvbmRzIH0gPSBCYWxhbmNlRHVyYXRpb24oMCwgMCwgMCwgMCwgMCwgMCwgSlNCSS50b051bWJlcih0aW1lUmVtYWluZGVyTnMpLCAnaG91cicpO1xuICAgIHJldHVybiB7IHllYXJzLCBtb250aHMsIHdlZWtzLCBkYXlzLCBob3VycywgbWludXRlcywgc2Vjb25kcywgbWlsbGlzZWNvbmRzLCBtaWNyb3NlY29uZHMsIG5hbm9zZWNvbmRzIH07XG59XG5mdW5jdGlvbiBBZGRJU09EYXRlKHllYXJQYXJhbSwgbW9udGhQYXJhbSwgZGF5UGFyYW0sIHllYXJzUGFyYW0sIG1vbnRoc1BhcmFtLCB3ZWVrc1BhcmFtLCBkYXlzUGFyYW0sIG92ZXJmbG93KSB7XG4gICAgbGV0IHllYXIgPSB5ZWFyUGFyYW07XG4gICAgbGV0IG1vbnRoID0gbW9udGhQYXJhbTtcbiAgICBsZXQgZGF5ID0gZGF5UGFyYW07XG4gICAgbGV0IHllYXJzID0geWVhcnNQYXJhbTtcbiAgICBsZXQgbW9udGhzID0gbW9udGhzUGFyYW07XG4gICAgbGV0IHdlZWtzID0gd2Vla3NQYXJhbTtcbiAgICBsZXQgZGF5cyA9IGRheXNQYXJhbTtcbiAgICB5ZWFyICs9IHllYXJzO1xuICAgIG1vbnRoICs9IG1vbnRocztcbiAgICAoeyB5ZWFyLCBtb250aCB9ID0gQmFsYW5jZUlTT1llYXJNb250aCh5ZWFyLCBtb250aCkpO1xuICAgICh7IHllYXIsIG1vbnRoLCBkYXkgfSA9IFJlZ3VsYXRlSVNPRGF0ZSh5ZWFyLCBtb250aCwgZGF5LCBvdmVyZmxvdykpO1xuICAgIGRheXMgKz0gNyAqIHdlZWtzO1xuICAgIGRheSArPSBkYXlzO1xuICAgICh7IHllYXIsIG1vbnRoLCBkYXkgfSA9IEJhbGFuY2VJU09EYXRlKHllYXIsIG1vbnRoLCBkYXkpKTtcbiAgICByZXR1cm4geyB5ZWFyLCBtb250aCwgZGF5IH07XG59XG5mdW5jdGlvbiBBZGRUaW1lKGhvdXJQYXJhbSwgbWludXRlUGFyYW0sIHNlY29uZFBhcmFtLCBtaWxsaXNlY29uZFBhcmFtLCBtaWNyb3NlY29uZFBhcmFtLCBuYW5vc2Vjb25kUGFyYW0sIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBtaWxsaXNlY29uZHMsIG1pY3Jvc2Vjb25kcywgbmFub3NlY29uZHMpIHtcbiAgICBsZXQgaG91ciA9IGhvdXJQYXJhbTtcbiAgICBsZXQgbWludXRlID0gbWludXRlUGFyYW07XG4gICAgbGV0IHNlY29uZCA9IHNlY29uZFBhcmFtO1xuICAgIGxldCBtaWxsaXNlY29uZCA9IG1pbGxpc2Vjb25kUGFyYW07XG4gICAgbGV0IG1pY3Jvc2Vjb25kID0gbWljcm9zZWNvbmRQYXJhbTtcbiAgICBsZXQgbmFub3NlY29uZCA9IG5hbm9zZWNvbmRQYXJhbTtcbiAgICBob3VyICs9IGhvdXJzO1xuICAgIG1pbnV0ZSArPSBtaW51dGVzO1xuICAgIHNlY29uZCArPSBzZWNvbmRzO1xuICAgIG1pbGxpc2Vjb25kICs9IG1pbGxpc2Vjb25kcztcbiAgICBtaWNyb3NlY29uZCArPSBtaWNyb3NlY29uZHM7XG4gICAgbmFub3NlY29uZCArPSBuYW5vc2Vjb25kcztcbiAgICBsZXQgZGVsdGFEYXlzID0gMDtcbiAgICAoeyBkZWx0YURheXMsIGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZCwgbWljcm9zZWNvbmQsIG5hbm9zZWNvbmQgfSA9IEJhbGFuY2VUaW1lKGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZCwgbWljcm9zZWNvbmQsIG5hbm9zZWNvbmQpKTtcbiAgICByZXR1cm4geyBkZWx0YURheXMsIGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZCwgbWljcm9zZWNvbmQsIG5hbm9zZWNvbmQgfTtcbn1cbmZ1bmN0aW9uIEFkZER1cmF0aW9uKHkxLCBtb24xLCB3MSwgZDEsIGgxLCBtaW4xLCBzMSwgbXMxLCDCtXMxLCBuczEsIHkyLCBtb24yLCB3MiwgZDIsIGgyLCBtaW4yLCBzMiwgbXMyLCDCtXMyLCBuczIsIHJlbGF0aXZlVG8pIHtcbiAgICBjb25zdCBsYXJnZXN0VW5pdDEgPSBEZWZhdWx0VGVtcG9yYWxMYXJnZXN0VW5pdCh5MSwgbW9uMSwgdzEsIGQxLCBoMSwgbWluMSwgczEsIG1zMSwgwrVzMSwgbnMxKTtcbiAgICBjb25zdCBsYXJnZXN0VW5pdDIgPSBEZWZhdWx0VGVtcG9yYWxMYXJnZXN0VW5pdCh5MiwgbW9uMiwgdzIsIGQyLCBoMiwgbWluMiwgczIsIG1zMiwgwrVzMiwgbnMyKTtcbiAgICBjb25zdCBsYXJnZXN0VW5pdCA9IExhcmdlck9mVHdvVGVtcG9yYWxVbml0cyhsYXJnZXN0VW5pdDEsIGxhcmdlc3RVbml0Mik7XG4gICAgbGV0IHllYXJzLCBtb250aHMsIHdlZWtzLCBkYXlzLCBob3VycywgbWludXRlcywgc2Vjb25kcywgbWlsbGlzZWNvbmRzLCBtaWNyb3NlY29uZHMsIG5hbm9zZWNvbmRzO1xuICAgIGlmICghcmVsYXRpdmVUbykge1xuICAgICAgICBpZiAobGFyZ2VzdFVuaXQgPT09ICd5ZWFyJyB8fCBsYXJnZXN0VW5pdCA9PT0gJ21vbnRoJyB8fCBsYXJnZXN0VW5pdCA9PT0gJ3dlZWsnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigncmVsYXRpdmVUbyBpcyByZXF1aXJlZCBmb3IgeWVhcnMsIG1vbnRocywgb3Igd2Vla3MgYXJpdGhtZXRpYycpO1xuICAgICAgICB9XG4gICAgICAgIHllYXJzID0gbW9udGhzID0gd2Vla3MgPSAwO1xuICAgICAgICAoeyBkYXlzLCBob3VycywgbWludXRlcywgc2Vjb25kcywgbWlsbGlzZWNvbmRzLCBtaWNyb3NlY29uZHMsIG5hbm9zZWNvbmRzIH0gPSBCYWxhbmNlRHVyYXRpb24oZDEgKyBkMiwgaDEgKyBoMiwgbWluMSArIG1pbjIsIHMxICsgczIsIG1zMSArIG1zMiwgwrVzMSArIMK1czIsIG5zMSArIG5zMiwgbGFyZ2VzdFVuaXQpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoSXNUZW1wb3JhbERhdGUocmVsYXRpdmVUbykpIHtcbiAgICAgICAgY29uc3QgVGVtcG9yYWxEdXJhdGlvbiA9IEdldEludHJpbnNpYygnJVRlbXBvcmFsLkR1cmF0aW9uJScpO1xuICAgICAgICBjb25zdCBjYWxlbmRhciA9IEdldFNsb3QocmVsYXRpdmVUbywgQ0FMRU5EQVIpO1xuICAgICAgICBjb25zdCBkYXRlRHVyYXRpb24xID0gbmV3IFRlbXBvcmFsRHVyYXRpb24oeTEsIG1vbjEsIHcxLCBkMSwgMCwgMCwgMCwgMCwgMCwgMCk7XG4gICAgICAgIGNvbnN0IGRhdGVEdXJhdGlvbjIgPSBuZXcgVGVtcG9yYWxEdXJhdGlvbih5MiwgbW9uMiwgdzIsIGQyLCAwLCAwLCAwLCAwLCAwLCAwKTtcbiAgICAgICAgY29uc3QgZGF0ZUFkZCA9IGNhbGVuZGFyLmRhdGVBZGQ7XG4gICAgICAgIGNvbnN0IGZpcnN0QWRkT3B0aW9ucyA9IE9iamVjdENyZWF0ZSQyKG51bGwpO1xuICAgICAgICBjb25zdCBpbnRlcm1lZGlhdGUgPSBDYWxlbmRhckRhdGVBZGQoY2FsZW5kYXIsIHJlbGF0aXZlVG8sIGRhdGVEdXJhdGlvbjEsIGZpcnN0QWRkT3B0aW9ucywgZGF0ZUFkZCk7XG4gICAgICAgIGNvbnN0IHNlY29uZEFkZE9wdGlvbnMgPSBPYmplY3RDcmVhdGUkMihudWxsKTtcbiAgICAgICAgY29uc3QgZW5kID0gQ2FsZW5kYXJEYXRlQWRkKGNhbGVuZGFyLCBpbnRlcm1lZGlhdGUsIGRhdGVEdXJhdGlvbjIsIHNlY29uZEFkZE9wdGlvbnMsIGRhdGVBZGQpO1xuICAgICAgICBjb25zdCBkYXRlTGFyZ2VzdFVuaXQgPSBMYXJnZXJPZlR3b1RlbXBvcmFsVW5pdHMoJ2RheScsIGxhcmdlc3RVbml0KTtcbiAgICAgICAgY29uc3QgZGlmZmVyZW5jZU9wdGlvbnMgPSBPYmplY3RDcmVhdGUkMihudWxsKTtcbiAgICAgICAgZGlmZmVyZW5jZU9wdGlvbnMubGFyZ2VzdFVuaXQgPSBkYXRlTGFyZ2VzdFVuaXQ7XG4gICAgICAgICh7IHllYXJzLCBtb250aHMsIHdlZWtzLCBkYXlzIH0gPSBDYWxlbmRhckRhdGVVbnRpbChjYWxlbmRhciwgcmVsYXRpdmVUbywgZW5kLCBkaWZmZXJlbmNlT3B0aW9ucykpO1xuICAgICAgICAvLyBTaWducyBvZiBkYXRlIHBhcnQgYW5kIHRpbWUgcGFydCBtYXkgbm90IGFncmVlOyBiYWxhbmNlIHRoZW0gdG9nZXRoZXJcbiAgICAgICAgKHsgZGF5cywgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc2Vjb25kcywgbWljcm9zZWNvbmRzLCBuYW5vc2Vjb25kcyB9ID0gQmFsYW5jZUR1cmF0aW9uKGRheXMsIGgxICsgaDIsIG1pbjEgKyBtaW4yLCBzMSArIHMyLCBtczEgKyBtczIsIMK1czEgKyDCtXMyLCBuczEgKyBuczIsIGxhcmdlc3RVbml0KSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyByZWxhdGl2ZVRvIGlzIGEgWm9uZWREYXRlVGltZVxuICAgICAgICBjb25zdCBUZW1wb3JhbEluc3RhbnQgPSBHZXRJbnRyaW5zaWMoJyVUZW1wb3JhbC5JbnN0YW50JScpO1xuICAgICAgICBjb25zdCB0aW1lWm9uZSA9IEdldFNsb3QocmVsYXRpdmVUbywgVElNRV9aT05FKTtcbiAgICAgICAgY29uc3QgY2FsZW5kYXIgPSBHZXRTbG90KHJlbGF0aXZlVG8sIENBTEVOREFSKTtcbiAgICAgICAgY29uc3QgaW50ZXJtZWRpYXRlTnMgPSBBZGRab25lZERhdGVUaW1lKEdldFNsb3QocmVsYXRpdmVUbywgSU5TVEFOVCksIHRpbWVab25lLCBjYWxlbmRhciwgeTEsIG1vbjEsIHcxLCBkMSwgaDEsIG1pbjEsIHMxLCBtczEsIMK1czEsIG5zMSk7XG4gICAgICAgIGNvbnN0IGVuZE5zID0gQWRkWm9uZWREYXRlVGltZShuZXcgVGVtcG9yYWxJbnN0YW50KGludGVybWVkaWF0ZU5zKSwgdGltZVpvbmUsIGNhbGVuZGFyLCB5MiwgbW9uMiwgdzIsIGQyLCBoMiwgbWluMiwgczIsIG1zMiwgwrVzMiwgbnMyKTtcbiAgICAgICAgaWYgKGxhcmdlc3RVbml0ICE9PSAneWVhcicgJiYgbGFyZ2VzdFVuaXQgIT09ICdtb250aCcgJiYgbGFyZ2VzdFVuaXQgIT09ICd3ZWVrJyAmJiBsYXJnZXN0VW5pdCAhPT0gJ2RheScpIHtcbiAgICAgICAgICAgIC8vIFRoZSB1c2VyIGlzIG9ubHkgYXNraW5nIGZvciBhIHRpbWUgZGlmZmVyZW5jZSwgc28gcmV0dXJuIGRpZmZlcmVuY2Ugb2YgaW5zdGFudHMuXG4gICAgICAgICAgICB5ZWFycyA9IDA7XG4gICAgICAgICAgICBtb250aHMgPSAwO1xuICAgICAgICAgICAgd2Vla3MgPSAwO1xuICAgICAgICAgICAgZGF5cyA9IDA7XG4gICAgICAgICAgICAoeyBzZWNvbmRzLCBtaWxsaXNlY29uZHMsIG1pY3Jvc2Vjb25kcywgbmFub3NlY29uZHMgfSA9IERpZmZlcmVuY2VJbnN0YW50KEdldFNsb3QocmVsYXRpdmVUbywgRVBPQ0hOQU5PU0VDT05EUyksIGVuZE5zLCAxLCAnbmFub3NlY29uZCcsICdoYWxmRXhwYW5kJykpO1xuICAgICAgICAgICAgKHsgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc2Vjb25kcywgbWljcm9zZWNvbmRzLCBuYW5vc2Vjb25kcyB9ID0gQmFsYW5jZUR1cmF0aW9uKDAsIDAsIDAsIHNlY29uZHMsIG1pbGxpc2Vjb25kcywgbWljcm9zZWNvbmRzLCBuYW5vc2Vjb25kcywgbGFyZ2VzdFVuaXQpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICh7IHllYXJzLCBtb250aHMsIHdlZWtzLCBkYXlzLCBob3VycywgbWludXRlcywgc2Vjb25kcywgbWlsbGlzZWNvbmRzLCBtaWNyb3NlY29uZHMsIG5hbm9zZWNvbmRzIH0gPVxuICAgICAgICAgICAgICAgIERpZmZlcmVuY2Vab25lZERhdGVUaW1lKEdldFNsb3QocmVsYXRpdmVUbywgRVBPQ0hOQU5PU0VDT05EUyksIGVuZE5zLCB0aW1lWm9uZSwgY2FsZW5kYXIsIGxhcmdlc3RVbml0KSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgUmVqZWN0RHVyYXRpb24oeWVhcnMsIG1vbnRocywgd2Vla3MsIGRheXMsIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBtaWxsaXNlY29uZHMsIG1pY3Jvc2Vjb25kcywgbmFub3NlY29uZHMpO1xuICAgIHJldHVybiB7IHllYXJzLCBtb250aHMsIHdlZWtzLCBkYXlzLCBob3VycywgbWludXRlcywgc2Vjb25kcywgbWlsbGlzZWNvbmRzLCBtaWNyb3NlY29uZHMsIG5hbm9zZWNvbmRzIH07XG59XG5mdW5jdGlvbiBBZGRJbnN0YW50KGVwb2NoTmFub3NlY29uZHMsIGgsIG1pbiwgcywgbXMsIMK1cywgbnMpIHtcbiAgICBsZXQgc3VtID0gWkVSTztcbiAgICBzdW0gPSBKU0JJLmFkZChzdW0sIEpTQkkuQmlnSW50KG5zKSk7XG4gICAgc3VtID0gSlNCSS5hZGQoc3VtLCBKU0JJLm11bHRpcGx5KEpTQkkuQmlnSW50KMK1cyksIFRIT1VTQU5EKSk7XG4gICAgc3VtID0gSlNCSS5hZGQoc3VtLCBKU0JJLm11bHRpcGx5KEpTQkkuQmlnSW50KG1zKSwgTUlMTElPTikpO1xuICAgIHN1bSA9IEpTQkkuYWRkKHN1bSwgSlNCSS5tdWx0aXBseShKU0JJLkJpZ0ludChzKSwgQklMTElPTikpO1xuICAgIHN1bSA9IEpTQkkuYWRkKHN1bSwgSlNCSS5tdWx0aXBseShKU0JJLkJpZ0ludChtaW4pLCBKU0JJLkJpZ0ludCg2MCAqIDFlOSkpKTtcbiAgICBzdW0gPSBKU0JJLmFkZChzdW0sIEpTQkkubXVsdGlwbHkoSlNCSS5CaWdJbnQoaCksIEpTQkkuQmlnSW50KDYwICogNjAgKiAxZTkpKSk7XG4gICAgY29uc3QgcmVzdWx0ID0gSlNCSS5hZGQoZXBvY2hOYW5vc2Vjb25kcywgc3VtKTtcbiAgICBWYWxpZGF0ZUVwb2NoTmFub3NlY29uZHMocmVzdWx0KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gQWRkRGF0ZVRpbWUoeWVhciwgbW9udGgsIGRheSwgaG91clBhcmFtLCBtaW51dGVQYXJhbSwgc2Vjb25kUGFyYW0sIG1pbGxpc2Vjb25kUGFyYW0sIG1pY3Jvc2Vjb25kUGFyYW0sIG5hbm9zZWNvbmRQYXJhbSwgY2FsZW5kYXIsIHllYXJzLCBtb250aHMsIHdlZWtzLCBkYXlzUGFyYW0sIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBtaWxsaXNlY29uZHMsIG1pY3Jvc2Vjb25kcywgbmFub3NlY29uZHMsIG9wdGlvbnMpIHtcbiAgICBsZXQgZGF5cyA9IGRheXNQYXJhbTtcbiAgICAvLyBBZGQgdGhlIHRpbWUgcGFydFxuICAgIGxldCB7IGRlbHRhRGF5cywgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kLCBtaWNyb3NlY29uZCwgbmFub3NlY29uZCB9ID0gQWRkVGltZShob3VyUGFyYW0sIG1pbnV0ZVBhcmFtLCBzZWNvbmRQYXJhbSwgbWlsbGlzZWNvbmRQYXJhbSwgbWljcm9zZWNvbmRQYXJhbSwgbmFub3NlY29uZFBhcmFtLCBob3VycywgbWludXRlcywgc2Vjb25kcywgbWlsbGlzZWNvbmRzLCBtaWNyb3NlY29uZHMsIG5hbm9zZWNvbmRzKTtcbiAgICBkYXlzICs9IGRlbHRhRGF5cztcbiAgICAvLyBEZWxlZ2F0ZSB0aGUgZGF0ZSBwYXJ0IGFkZGl0aW9uIHRvIHRoZSBjYWxlbmRhclxuICAgIGNvbnN0IFRlbXBvcmFsRHVyYXRpb24gPSBHZXRJbnRyaW5zaWMoJyVUZW1wb3JhbC5EdXJhdGlvbiUnKTtcbiAgICBjb25zdCBkYXRlUGFydCA9IENyZWF0ZVRlbXBvcmFsRGF0ZSh5ZWFyLCBtb250aCwgZGF5LCBjYWxlbmRhcik7XG4gICAgY29uc3QgZGF0ZUR1cmF0aW9uID0gbmV3IFRlbXBvcmFsRHVyYXRpb24oeWVhcnMsIG1vbnRocywgd2Vla3MsIGRheXMsIDAsIDAsIDAsIDAsIDAsIDApO1xuICAgIGNvbnN0IGFkZGVkRGF0ZSA9IENhbGVuZGFyRGF0ZUFkZChjYWxlbmRhciwgZGF0ZVBhcnQsIGRhdGVEdXJhdGlvbiwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgeWVhcjogR2V0U2xvdChhZGRlZERhdGUsIElTT19ZRUFSKSxcbiAgICAgICAgbW9udGg6IEdldFNsb3QoYWRkZWREYXRlLCBJU09fTU9OVEgpLFxuICAgICAgICBkYXk6IEdldFNsb3QoYWRkZWREYXRlLCBJU09fREFZKSxcbiAgICAgICAgaG91cixcbiAgICAgICAgbWludXRlLFxuICAgICAgICBzZWNvbmQsXG4gICAgICAgIG1pbGxpc2Vjb25kLFxuICAgICAgICBtaWNyb3NlY29uZCxcbiAgICAgICAgbmFub3NlY29uZFxuICAgIH07XG59XG5mdW5jdGlvbiBBZGRab25lZERhdGVUaW1lKGluc3RhbnQsIHRpbWVab25lLCBjYWxlbmRhciwgeWVhcnMsIG1vbnRocywgd2Vla3MsIGRheXMsIGgsIG1pbiwgcywgbXMsIMK1cywgbnMsIG9wdGlvbnMpIHtcbiAgICAvLyBJZiBvbmx5IHRpbWUgaXMgdG8gYmUgYWRkZWQsIHRoZW4gdXNlIEluc3RhbnQgbWF0aC4gSXQncyBub3QgT0sgdG8gZmFsbFxuICAgIC8vIHRocm91Z2ggdG8gdGhlIGRhdGUvdGltZSBjb2RlIGJlbG93IGJlY2F1c2UgY29tcGF0aWJsZSBkaXNhbWJpZ3VhdGlvbiBpblxuICAgIC8vIHRoZSBQbGFpbkRhdGVUaW1lPT5JbnN0YW50IGNvbnZlcnNpb24gd2lsbCBjaGFuZ2UgdGhlIG9mZnNldCBvZiBhbnlcbiAgICAvLyBab25lZERhdGVUaW1lIGluIHRoZSByZXBlYXRlZCBjbG9jayB0aW1lIGFmdGVyIGEgYmFja3dhcmRzIHRyYW5zaXRpb24uXG4gICAgLy8gV2hlbiBhZGRpbmcvc3VidHJhY3RpbmcgdGltZSB1bml0cyBhbmQgbm90IGRhdGVzLCB0aGlzIGRpc2FtYmlndWF0aW9uIGlzXG4gICAgLy8gbm90IGV4cGVjdGVkIGFuZCBzbyBpcyBhdm9pZGVkIGJlbG93IHZpYSBhIGZhc3QgcGF0aCBmb3IgdGltZS1vbmx5XG4gICAgLy8gYXJpdGhtZXRpYy5cbiAgICAvLyBCVFcsIHRoaXMgYmVoYXZpb3IgaXMgc2ltaWxhciBpbiBzcGlyaXQgdG8gb2Zmc2V0OiAncHJlZmVyJyBpbiBgd2l0aGAuXG4gICAgY29uc3QgVGVtcG9yYWxEdXJhdGlvbiA9IEdldEludHJpbnNpYygnJVRlbXBvcmFsLkR1cmF0aW9uJScpO1xuICAgIGlmIChEdXJhdGlvblNpZ24oeWVhcnMsIG1vbnRocywgd2Vla3MsIGRheXMsIDAsIDAsIDAsIDAsIDAsIDApID09PSAwKSB7XG4gICAgICAgIHJldHVybiBBZGRJbnN0YW50KEdldFNsb3QoaW5zdGFudCwgRVBPQ0hOQU5PU0VDT05EUyksIGgsIG1pbiwgcywgbXMsIMK1cywgbnMpO1xuICAgIH1cbiAgICAvLyBSRkMgNTU0NSByZXF1aXJlcyB0aGUgZGF0ZSBwb3J0aW9uIHRvIGJlIGFkZGVkIGluIGNhbGVuZGFyIGRheXMgYW5kIHRoZVxuICAgIC8vIHRpbWUgcG9ydGlvbiB0byBiZSBhZGRlZCBpbiBleGFjdCB0aW1lLlxuICAgIGNvbnN0IGR0ID0gQnVpbHRpblRpbWVab25lR2V0UGxhaW5EYXRlVGltZUZvcih0aW1lWm9uZSwgaW5zdGFudCwgY2FsZW5kYXIpO1xuICAgIGNvbnN0IGRhdGVQYXJ0ID0gQ3JlYXRlVGVtcG9yYWxEYXRlKEdldFNsb3QoZHQsIElTT19ZRUFSKSwgR2V0U2xvdChkdCwgSVNPX01PTlRIKSwgR2V0U2xvdChkdCwgSVNPX0RBWSksIGNhbGVuZGFyKTtcbiAgICBjb25zdCBkYXRlRHVyYXRpb24gPSBuZXcgVGVtcG9yYWxEdXJhdGlvbih5ZWFycywgbW9udGhzLCB3ZWVrcywgZGF5cywgMCwgMCwgMCwgMCwgMCwgMCk7XG4gICAgY29uc3QgYWRkZWREYXRlID0gQ2FsZW5kYXJEYXRlQWRkKGNhbGVuZGFyLCBkYXRlUGFydCwgZGF0ZUR1cmF0aW9uLCBvcHRpb25zKTtcbiAgICBjb25zdCBkdEludGVybWVkaWF0ZSA9IENyZWF0ZVRlbXBvcmFsRGF0ZVRpbWUoR2V0U2xvdChhZGRlZERhdGUsIElTT19ZRUFSKSwgR2V0U2xvdChhZGRlZERhdGUsIElTT19NT05USCksIEdldFNsb3QoYWRkZWREYXRlLCBJU09fREFZKSwgR2V0U2xvdChkdCwgSVNPX0hPVVIpLCBHZXRTbG90KGR0LCBJU09fTUlOVVRFKSwgR2V0U2xvdChkdCwgSVNPX1NFQ09ORCksIEdldFNsb3QoZHQsIElTT19NSUxMSVNFQ09ORCksIEdldFNsb3QoZHQsIElTT19NSUNST1NFQ09ORCksIEdldFNsb3QoZHQsIElTT19OQU5PU0VDT05EKSwgY2FsZW5kYXIpO1xuICAgIC8vIE5vdGUgdGhhdCAnY29tcGF0aWJsZScgaXMgdXNlZCBiZWxvdyBiZWNhdXNlIHRoaXMgZGlzYW1iaWd1YXRpb24gYmVoYXZpb3JcbiAgICAvLyBpcyByZXF1aXJlZCBieSBSRkMgNTU0NS5cbiAgICBjb25zdCBpbnN0YW50SW50ZXJtZWRpYXRlID0gQnVpbHRpblRpbWVab25lR2V0SW5zdGFudEZvcih0aW1lWm9uZSwgZHRJbnRlcm1lZGlhdGUsICdjb21wYXRpYmxlJyk7XG4gICAgcmV0dXJuIEFkZEluc3RhbnQoR2V0U2xvdChpbnN0YW50SW50ZXJtZWRpYXRlLCBFUE9DSE5BTk9TRUNPTkRTKSwgaCwgbWluLCBzLCBtcywgwrVzLCBucyk7XG59XG5mdW5jdGlvbiBSb3VuZE51bWJlclRvSW5jcmVtZW50KHF1YW50aXR5LCBpbmNyZW1lbnQsIG1vZGUpIHtcbiAgICBpZiAoaW5jcmVtZW50ID09PSAxKVxuICAgICAgICByZXR1cm4gcXVhbnRpdHk7XG4gICAgbGV0IHsgcXVvdGllbnQsIHJlbWFpbmRlciB9ID0gZGl2bW9kKHF1YW50aXR5LCBKU0JJLkJpZ0ludChpbmNyZW1lbnQpKTtcbiAgICBpZiAoSlNCSS5lcXVhbChyZW1haW5kZXIsIFpFUk8pKVxuICAgICAgICByZXR1cm4gcXVhbnRpdHk7XG4gICAgY29uc3Qgc2lnbiA9IEpTQkkubGVzc1RoYW4ocmVtYWluZGVyLCBaRVJPKSA/IC0xIDogMTtcbiAgICBzd2l0Y2ggKG1vZGUpIHtcbiAgICAgICAgY2FzZSAnY2VpbCc6XG4gICAgICAgICAgICBpZiAoc2lnbiA+IDApXG4gICAgICAgICAgICAgICAgcXVvdGllbnQgPSBKU0JJLmFkZChxdW90aWVudCwgSlNCSS5CaWdJbnQoc2lnbikpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2Zsb29yJzpcbiAgICAgICAgICAgIGlmIChzaWduIDwgMClcbiAgICAgICAgICAgICAgICBxdW90aWVudCA9IEpTQkkuYWRkKHF1b3RpZW50LCBKU0JJLkJpZ0ludChzaWduKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAndHJ1bmMnOlxuICAgICAgICAgICAgLy8gbm8gY2hhbmdlIG5lZWRlZCwgYmVjYXVzZSBkaXZtb2QgaXMgYSB0cnVuY2F0aW9uXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnaGFsZkV4cGFuZCc6XG4gICAgICAgICAgICAvLyBcImhhbGYgdXAgYXdheSBmcm9tIHplcm9cIlxuICAgICAgICAgICAgaWYgKEpTQkkudG9OdW1iZXIoYWJzKEpTQkkubXVsdGlwbHkocmVtYWluZGVyLCBKU0JJLkJpZ0ludCgyKSkpKSA+PSBpbmNyZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBxdW90aWVudCA9IEpTQkkuYWRkKHF1b3RpZW50LCBKU0JJLkJpZ0ludChzaWduKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIEpTQkkubXVsdGlwbHkocXVvdGllbnQsIEpTQkkuQmlnSW50KGluY3JlbWVudCkpO1xufVxuZnVuY3Rpb24gUm91bmRJbnN0YW50KGVwb2NoTnMsIGluY3JlbWVudCwgdW5pdCwgcm91bmRpbmdNb2RlKSB7XG4gICAgLy8gTm90ZTogTm9uTmVnYXRpdmVNb2R1bG8sIGJ1dCB3aXRoIEJpZ0ludFxuICAgIGxldCByZW1haW5kZXIgPSBKU0JJLnJlbWFpbmRlcihlcG9jaE5zLCBKU0JJLkJpZ0ludCg4NjQwMGU5KSk7XG4gICAgaWYgKEpTQkkubGVzc1RoYW4ocmVtYWluZGVyLCBaRVJPKSlcbiAgICAgICAgcmVtYWluZGVyID0gSlNCSS5hZGQocmVtYWluZGVyLCBKU0JJLkJpZ0ludCg4NjQwMGU5KSk7XG4gICAgY29uc3Qgd2hvbGVEYXlzID0gSlNCSS5zdWJ0cmFjdChlcG9jaE5zLCByZW1haW5kZXIpO1xuICAgIGNvbnN0IHJvdW5kZWRSZW1haW5kZXIgPSBSb3VuZE51bWJlclRvSW5jcmVtZW50KHJlbWFpbmRlciwgbnNQZXJUaW1lVW5pdFt1bml0XSAqIGluY3JlbWVudCwgcm91bmRpbmdNb2RlKTtcbiAgICByZXR1cm4gSlNCSS5hZGQod2hvbGVEYXlzLCByb3VuZGVkUmVtYWluZGVyKTtcbn1cbmZ1bmN0aW9uIFJvdW5kSVNPRGF0ZVRpbWUoeWVhclBhcmFtLCBtb250aFBhcmFtLCBkYXlQYXJhbSwgaG91clBhcmFtLCBtaW51dGVQYXJhbSwgc2Vjb25kUGFyYW0sIG1pbGxpc2Vjb25kUGFyYW0sIG1pY3Jvc2Vjb25kUGFyYW0sIG5hbm9zZWNvbmRQYXJhbSwgaW5jcmVtZW50LCB1bml0LCByb3VuZGluZ01vZGUsIGRheUxlbmd0aE5zID0gODY0MDBlOSkge1xuICAgIGNvbnN0IHsgZGVsdGFEYXlzLCBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQsIG1pY3Jvc2Vjb25kLCBuYW5vc2Vjb25kIH0gPSBSb3VuZFRpbWUoaG91clBhcmFtLCBtaW51dGVQYXJhbSwgc2Vjb25kUGFyYW0sIG1pbGxpc2Vjb25kUGFyYW0sIG1pY3Jvc2Vjb25kUGFyYW0sIG5hbm9zZWNvbmRQYXJhbSwgaW5jcmVtZW50LCB1bml0LCByb3VuZGluZ01vZGUsIGRheUxlbmd0aE5zKTtcbiAgICBjb25zdCB7IHllYXIsIG1vbnRoLCBkYXkgfSA9IEJhbGFuY2VJU09EYXRlKHllYXJQYXJhbSwgbW9udGhQYXJhbSwgZGF5UGFyYW0gKyBkZWx0YURheXMpO1xuICAgIHJldHVybiB7IHllYXIsIG1vbnRoLCBkYXksIGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZCwgbWljcm9zZWNvbmQsIG5hbm9zZWNvbmQgfTtcbn1cbmZ1bmN0aW9uIFJvdW5kVGltZShob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQsIG1pY3Jvc2Vjb25kLCBuYW5vc2Vjb25kLCBpbmNyZW1lbnQsIHVuaXQsIHJvdW5kaW5nTW9kZSwgZGF5TGVuZ3RoTnMgPSA4NjQwMGU5KSB7XG4gICAgbGV0IHF1YW50aXR5ID0gWkVSTztcbiAgICBzd2l0Y2ggKHVuaXQpIHtcbiAgICAgICAgY2FzZSAnZGF5JzpcbiAgICAgICAgY2FzZSAnaG91cic6XG4gICAgICAgICAgICBxdWFudGl0eSA9IEpTQkkuQmlnSW50KGhvdXIpO1xuICAgICAgICAvLyBmYWxsIHRocm91Z2hcbiAgICAgICAgY2FzZSAnbWludXRlJzpcbiAgICAgICAgICAgIHF1YW50aXR5ID0gSlNCSS5hZGQoSlNCSS5tdWx0aXBseShxdWFudGl0eSwgU0lYVFkpLCBKU0JJLkJpZ0ludChtaW51dGUpKTtcbiAgICAgICAgLy8gZmFsbCB0aHJvdWdoXG4gICAgICAgIGNhc2UgJ3NlY29uZCc6XG4gICAgICAgICAgICBxdWFudGl0eSA9IEpTQkkuYWRkKEpTQkkubXVsdGlwbHkocXVhbnRpdHksIFNJWFRZKSwgSlNCSS5CaWdJbnQoc2Vjb25kKSk7XG4gICAgICAgIC8vIGZhbGwgdGhyb3VnaFxuICAgICAgICBjYXNlICdtaWxsaXNlY29uZCc6XG4gICAgICAgICAgICBxdWFudGl0eSA9IEpTQkkuYWRkKEpTQkkubXVsdGlwbHkocXVhbnRpdHksIFRIT1VTQU5EKSwgSlNCSS5CaWdJbnQobWlsbGlzZWNvbmQpKTtcbiAgICAgICAgLy8gZmFsbCB0aHJvdWdoXG4gICAgICAgIGNhc2UgJ21pY3Jvc2Vjb25kJzpcbiAgICAgICAgICAgIHF1YW50aXR5ID0gSlNCSS5hZGQoSlNCSS5tdWx0aXBseShxdWFudGl0eSwgVEhPVVNBTkQpLCBKU0JJLkJpZ0ludChtaWNyb3NlY29uZCkpO1xuICAgICAgICAvLyBmYWxsIHRocm91Z2hcbiAgICAgICAgY2FzZSAnbmFub3NlY29uZCc6XG4gICAgICAgICAgICBxdWFudGl0eSA9IEpTQkkuYWRkKEpTQkkubXVsdGlwbHkocXVhbnRpdHksIFRIT1VTQU5EKSwgSlNCSS5CaWdJbnQobmFub3NlY29uZCkpO1xuICAgIH1cbiAgICBjb25zdCBuc1BlclVuaXQgPSB1bml0ID09PSAnZGF5JyA/IGRheUxlbmd0aE5zIDogbnNQZXJUaW1lVW5pdFt1bml0XTtcbiAgICBjb25zdCByb3VuZGVkID0gUm91bmROdW1iZXJUb0luY3JlbWVudChxdWFudGl0eSwgbnNQZXJVbml0ICogaW5jcmVtZW50LCByb3VuZGluZ01vZGUpO1xuICAgIGNvbnN0IHJlc3VsdCA9IEpTQkkudG9OdW1iZXIoSlNCSS5kaXZpZGUocm91bmRlZCwgSlNCSS5CaWdJbnQobnNQZXJVbml0KSkpO1xuICAgIHN3aXRjaCAodW5pdCkge1xuICAgICAgICBjYXNlICdkYXknOlxuICAgICAgICAgICAgcmV0dXJuIHsgZGVsdGFEYXlzOiByZXN1bHQsIGhvdXI6IDAsIG1pbnV0ZTogMCwgc2Vjb25kOiAwLCBtaWxsaXNlY29uZDogMCwgbWljcm9zZWNvbmQ6IDAsIG5hbm9zZWNvbmQ6IDAgfTtcbiAgICAgICAgY2FzZSAnaG91cic6XG4gICAgICAgICAgICByZXR1cm4gQmFsYW5jZVRpbWUocmVzdWx0LCAwLCAwLCAwLCAwLCAwKTtcbiAgICAgICAgY2FzZSAnbWludXRlJzpcbiAgICAgICAgICAgIHJldHVybiBCYWxhbmNlVGltZShob3VyLCByZXN1bHQsIDAsIDAsIDAsIDApO1xuICAgICAgICBjYXNlICdzZWNvbmQnOlxuICAgICAgICAgICAgcmV0dXJuIEJhbGFuY2VUaW1lKGhvdXIsIG1pbnV0ZSwgcmVzdWx0LCAwLCAwLCAwKTtcbiAgICAgICAgY2FzZSAnbWlsbGlzZWNvbmQnOlxuICAgICAgICAgICAgcmV0dXJuIEJhbGFuY2VUaW1lKGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCByZXN1bHQsIDAsIDApO1xuICAgICAgICBjYXNlICdtaWNyb3NlY29uZCc6XG4gICAgICAgICAgICByZXR1cm4gQmFsYW5jZVRpbWUoaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kLCByZXN1bHQsIDApO1xuICAgICAgICBjYXNlICduYW5vc2Vjb25kJzpcbiAgICAgICAgICAgIHJldHVybiBCYWxhbmNlVGltZShob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQsIG1pY3Jvc2Vjb25kLCByZXN1bHQpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHVuaXQgJHt1bml0fWApO1xuICAgIH1cbn1cbmZ1bmN0aW9uIERheXNVbnRpbChlYXJsaWVyLCBsYXRlcikge1xuICAgIHJldHVybiBEaWZmZXJlbmNlSVNPRGF0ZShHZXRTbG90KGVhcmxpZXIsIElTT19ZRUFSKSwgR2V0U2xvdChlYXJsaWVyLCBJU09fTU9OVEgpLCBHZXRTbG90KGVhcmxpZXIsIElTT19EQVkpLCBHZXRTbG90KGxhdGVyLCBJU09fWUVBUiksIEdldFNsb3QobGF0ZXIsIElTT19NT05USCksIEdldFNsb3QobGF0ZXIsIElTT19EQVkpLCAnZGF5JykuZGF5cztcbn1cbmZ1bmN0aW9uIE1vdmVSZWxhdGl2ZURhdGUoY2FsZW5kYXIsIHJlbGF0aXZlVG9QYXJhbSwgZHVyYXRpb24pIHtcbiAgICBjb25zdCBvcHRpb25zID0gT2JqZWN0Q3JlYXRlJDIobnVsbCk7XG4gICAgY29uc3QgbGF0ZXIgPSBDYWxlbmRhckRhdGVBZGQoY2FsZW5kYXIsIHJlbGF0aXZlVG9QYXJhbSwgZHVyYXRpb24sIG9wdGlvbnMpO1xuICAgIGNvbnN0IGRheXMgPSBEYXlzVW50aWwocmVsYXRpdmVUb1BhcmFtLCBsYXRlcik7XG4gICAgcmV0dXJuIHsgcmVsYXRpdmVUbzogbGF0ZXIsIGRheXMgfTtcbn1cbmZ1bmN0aW9uIE1vdmVSZWxhdGl2ZVpvbmVkRGF0ZVRpbWUocmVsYXRpdmVUbywgeWVhcnMsIG1vbnRocywgd2Vla3MsIGRheXMpIHtcbiAgICBjb25zdCB0aW1lWm9uZSA9IEdldFNsb3QocmVsYXRpdmVUbywgVElNRV9aT05FKTtcbiAgICBjb25zdCBjYWxlbmRhciA9IEdldFNsb3QocmVsYXRpdmVUbywgQ0FMRU5EQVIpO1xuICAgIGNvbnN0IGludGVybWVkaWF0ZU5zID0gQWRkWm9uZWREYXRlVGltZShHZXRTbG90KHJlbGF0aXZlVG8sIElOU1RBTlQpLCB0aW1lWm9uZSwgY2FsZW5kYXIsIHllYXJzLCBtb250aHMsIHdlZWtzLCBkYXlzLCAwLCAwLCAwLCAwLCAwLCAwKTtcbiAgICByZXR1cm4gQ3JlYXRlVGVtcG9yYWxab25lZERhdGVUaW1lKGludGVybWVkaWF0ZU5zLCB0aW1lWm9uZSwgY2FsZW5kYXIpO1xufVxuZnVuY3Rpb24gQWRqdXN0Um91bmRlZER1cmF0aW9uRGF5cyh5ZWFyc1BhcmFtLCBtb250aHNQYXJhbSwgd2Vla3NQYXJhbSwgZGF5c1BhcmFtLCBob3Vyc1BhcmFtLCBtaW51dGVzUGFyYW0sIHNlY29uZHNQYXJhbSwgbWlsbGlzZWNvbmRzUGFyYW0sIG1pY3Jvc2Vjb25kc1BhcmFtLCBuYW5vc2Vjb25kc1BhcmFtLCBpbmNyZW1lbnQsIHVuaXQsIHJvdW5kaW5nTW9kZSwgcmVsYXRpdmVUbykge1xuICAgIGxldCB5ZWFycyA9IHllYXJzUGFyYW07XG4gICAgbGV0IG1vbnRocyA9IG1vbnRoc1BhcmFtO1xuICAgIGxldCB3ZWVrcyA9IHdlZWtzUGFyYW07XG4gICAgbGV0IGRheXMgPSBkYXlzUGFyYW07XG4gICAgbGV0IGhvdXJzID0gaG91cnNQYXJhbTtcbiAgICBsZXQgbWludXRlcyA9IG1pbnV0ZXNQYXJhbTtcbiAgICBsZXQgc2Vjb25kcyA9IHNlY29uZHNQYXJhbTtcbiAgICBsZXQgbWlsbGlzZWNvbmRzID0gbWlsbGlzZWNvbmRzUGFyYW07XG4gICAgbGV0IG1pY3Jvc2Vjb25kcyA9IG1pY3Jvc2Vjb25kc1BhcmFtO1xuICAgIGxldCBuYW5vc2Vjb25kcyA9IG5hbm9zZWNvbmRzUGFyYW07XG4gICAgaWYgKCFJc1RlbXBvcmFsWm9uZWREYXRlVGltZShyZWxhdGl2ZVRvKSB8fFxuICAgICAgICB1bml0ID09PSAneWVhcicgfHxcbiAgICAgICAgdW5pdCA9PT0gJ21vbnRoJyB8fFxuICAgICAgICB1bml0ID09PSAnd2VlaycgfHxcbiAgICAgICAgdW5pdCA9PT0gJ2RheScgfHxcbiAgICAgICAgKHVuaXQgPT09ICduYW5vc2Vjb25kJyAmJiBpbmNyZW1lbnQgPT09IDEpKSB7XG4gICAgICAgIHJldHVybiB7IHllYXJzLCBtb250aHMsIHdlZWtzLCBkYXlzLCBob3VycywgbWludXRlcywgc2Vjb25kcywgbWlsbGlzZWNvbmRzLCBtaWNyb3NlY29uZHMsIG5hbm9zZWNvbmRzIH07XG4gICAgfVxuICAgIC8vIFRoZXJlJ3Mgb25lIG1vcmUgcm91bmQgb2Ygcm91bmRpbmcgcG9zc2libGU6IGlmIHJlbGF0aXZlVG8gaXMgYVxuICAgIC8vIFpvbmVkRGF0ZVRpbWUsIHRoZSB0aW1lIHVuaXRzIGNvdWxkIGhhdmUgcm91bmRlZCB1cCBpbnRvIGVub3VnaCBob3Vyc1xuICAgIC8vIHRvIGV4Y2VlZCB0aGUgZGF5IGxlbmd0aC4gSWYgdGhpcyBoYXBwZW5zLCBncm93IHRoZSBkYXRlIHBhcnQgYnkgYVxuICAgIC8vIHNpbmdsZSBkYXkgYW5kIHJlLXJ1biBleGFjdCB0aW1lIHJvdW5kaW5nIG9uIHRoZSBzbWFsbGVyIHJlbWFpbmRlci4gRE9cbiAgICAvLyBOT1QgUkVDVVJTRSwgYmVjYXVzZSBvbmNlIHRoZSBleHRyYSBob3VycyBhcmUgc3Vja2VkIHVwIGludG8gdGhlIGRhdGVcbiAgICAvLyBkdXJhdGlvbiwgdGhlcmUncyBubyB3YXkgZm9yIGFub3RoZXIgZnVsbCBkYXkgdG8gY29tZSBmcm9tIHRoZSBuZXh0XG4gICAgLy8gcm91bmQgb2Ygcm91bmRpbmcuIEFuZCBpZiBpdCB3ZXJlIHBvc3NpYmxlIChlLmcuIGNvbnRyaXZlZCBjYWxlbmRhclxuICAgIC8vIHdpdGggMzAtbWludXRlLWxvbmcgXCJkYXlzXCIpIHRoZW4gaXQnZCByaXNrIGFuIGluZmluaXRlIGxvb3AuXG4gICAgbGV0IHRpbWVSZW1haW5kZXJOcyA9IFRvdGFsRHVyYXRpb25OYW5vc2Vjb25kcygwLCBob3VycywgbWludXRlcywgc2Vjb25kcywgbWlsbGlzZWNvbmRzLCBtaWNyb3NlY29uZHMsIG5hbm9zZWNvbmRzLCAwKTtcbiAgICBjb25zdCBkaXJlY3Rpb24gPSBNYXRoU2lnbihKU0JJLnRvTnVtYmVyKHRpbWVSZW1haW5kZXJOcykpO1xuICAgIGNvbnN0IHRpbWVab25lID0gR2V0U2xvdChyZWxhdGl2ZVRvLCBUSU1FX1pPTkUpO1xuICAgIGNvbnN0IGNhbGVuZGFyID0gR2V0U2xvdChyZWxhdGl2ZVRvLCBDQUxFTkRBUik7XG4gICAgY29uc3QgZGF5U3RhcnQgPSBBZGRab25lZERhdGVUaW1lKEdldFNsb3QocmVsYXRpdmVUbywgSU5TVEFOVCksIHRpbWVab25lLCBjYWxlbmRhciwgeWVhcnMsIG1vbnRocywgd2Vla3MsIGRheXMsIDAsIDAsIDAsIDAsIDAsIDApO1xuICAgIGNvbnN0IFRlbXBvcmFsSW5zdGFudCA9IEdldEludHJpbnNpYygnJVRlbXBvcmFsLkluc3RhbnQlJyk7XG4gICAgY29uc3QgZGF5RW5kID0gQWRkWm9uZWREYXRlVGltZShuZXcgVGVtcG9yYWxJbnN0YW50KGRheVN0YXJ0KSwgdGltZVpvbmUsIGNhbGVuZGFyLCAwLCAwLCAwLCBkaXJlY3Rpb24sIDAsIDAsIDAsIDAsIDAsIDApO1xuICAgIGNvbnN0IGRheUxlbmd0aE5zID0gSlNCSS5zdWJ0cmFjdChkYXlFbmQsIGRheVN0YXJ0KTtcbiAgICBpZiAoSlNCSS5ncmVhdGVyVGhhbk9yRXF1YWwoSlNCSS5tdWx0aXBseShKU0JJLnN1YnRyYWN0KHRpbWVSZW1haW5kZXJOcywgZGF5TGVuZ3RoTnMpLCBKU0JJLkJpZ0ludChkaXJlY3Rpb24pKSwgWkVSTykpIHtcbiAgICAgICAgKHsgeWVhcnMsIG1vbnRocywgd2Vla3MsIGRheXMgfSA9IEFkZER1cmF0aW9uKHllYXJzLCBtb250aHMsIHdlZWtzLCBkYXlzLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCBkaXJlY3Rpb24sIDAsIDAsIDAsIDAsIDAsIDAsIHJlbGF0aXZlVG8pKTtcbiAgICAgICAgdGltZVJlbWFpbmRlck5zID0gUm91bmRJbnN0YW50KEpTQkkuc3VidHJhY3QodGltZVJlbWFpbmRlck5zLCBkYXlMZW5ndGhOcyksIGluY3JlbWVudCwgdW5pdCwgcm91bmRpbmdNb2RlKTtcbiAgICAgICAgKHsgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc2Vjb25kcywgbWljcm9zZWNvbmRzLCBuYW5vc2Vjb25kcyB9ID0gQmFsYW5jZUR1cmF0aW9uKDAsIDAsIDAsIDAsIDAsIDAsIEpTQkkudG9OdW1iZXIodGltZVJlbWFpbmRlck5zKSwgJ2hvdXInKSk7XG4gICAgfVxuICAgIHJldHVybiB7IHllYXJzLCBtb250aHMsIHdlZWtzLCBkYXlzLCBob3VycywgbWludXRlcywgc2Vjb25kcywgbWlsbGlzZWNvbmRzLCBtaWNyb3NlY29uZHMsIG5hbm9zZWNvbmRzIH07XG59XG5mdW5jdGlvbiBSb3VuZER1cmF0aW9uKHllYXJzUGFyYW0sIG1vbnRoc1BhcmFtLCB3ZWVrc1BhcmFtLCBkYXlzUGFyYW0sIGhvdXJzUGFyYW0sIG1pbnV0ZXNQYXJhbSwgc2Vjb25kc1BhcmFtLCBtaWxsaXNlY29uZHNQYXJhbSwgbWljcm9zZWNvbmRzUGFyYW0sIG5hbm9zZWNvbmRzUGFyYW0sIGluY3JlbWVudCwgdW5pdCwgcm91bmRpbmdNb2RlLCByZWxhdGl2ZVRvUGFyYW0gPSB1bmRlZmluZWQpIHtcbiAgICBsZXQgeWVhcnMgPSB5ZWFyc1BhcmFtO1xuICAgIGxldCBtb250aHMgPSBtb250aHNQYXJhbTtcbiAgICBsZXQgd2Vla3MgPSB3ZWVrc1BhcmFtO1xuICAgIGxldCBkYXlzID0gZGF5c1BhcmFtO1xuICAgIGxldCBob3VycyA9IGhvdXJzUGFyYW07XG4gICAgbGV0IG1pbnV0ZXMgPSBtaW51dGVzUGFyYW07XG4gICAgbGV0IHNlY29uZHMgPSBzZWNvbmRzUGFyYW07XG4gICAgbGV0IG1pbGxpc2Vjb25kcyA9IG1pbGxpc2Vjb25kc1BhcmFtO1xuICAgIGxldCBtaWNyb3NlY29uZHMgPSBtaWNyb3NlY29uZHNQYXJhbTtcbiAgICBsZXQgbmFub3NlY29uZHMgPSBKU0JJLkJpZ0ludChuYW5vc2Vjb25kc1BhcmFtKTtcbiAgICBjb25zdCBUZW1wb3JhbER1cmF0aW9uID0gR2V0SW50cmluc2ljKCclVGVtcG9yYWwuRHVyYXRpb24lJyk7XG4gICAgbGV0IGNhbGVuZGFyLCB6ZHRSZWxhdGl2ZTtcbiAgICAvLyBBIGNhc3QgaXMgdXNlZCBiZWxvdyBiZWNhdXNlIHJlbGF0aXZlVG8gd2lsbCBiZSBlaXRoZXIgUGxhaW5EYXRlIG9yXG4gICAgLy8gdW5kZWZpbmVkIGZvciB0aGUgcmVzdCBvZiB0aGlzIGxvbmcgbWV0aG9kIChhZnRlciBhbnkgWkRUPT5QbGFpbkRhdGVcbiAgICAvLyBjb252ZXJzaW9uIGJlbG93KSwgYW5kIFRTIGlzbid0IHNtYXJ0IGVub3VnaCB0byBrbm93IHRoYXQgdGhlIHR5cGUgaGFzXG4gICAgLy8gY2hhbmdlZC4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9taWNyb3NvZnQvVHlwZVNjcmlwdC9pc3N1ZXMvMjc3MDYuXG4gICAgbGV0IHJlbGF0aXZlVG8gPSByZWxhdGl2ZVRvUGFyYW07XG4gICAgaWYgKHJlbGF0aXZlVG8pIHtcbiAgICAgICAgaWYgKElzVGVtcG9yYWxab25lZERhdGVUaW1lKHJlbGF0aXZlVG8pKSB7XG4gICAgICAgICAgICB6ZHRSZWxhdGl2ZSA9IHJlbGF0aXZlVG87XG4gICAgICAgICAgICByZWxhdGl2ZVRvID0gVG9UZW1wb3JhbERhdGUocmVsYXRpdmVUbyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIUlzVGVtcG9yYWxEYXRlKHJlbGF0aXZlVG8pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdzdGFydGluZyBwb2ludCBtdXN0IGJlIFBsYWluRGF0ZSBvciBab25lZERhdGVUaW1lJyk7XG4gICAgICAgIH1cbiAgICAgICAgY2FsZW5kYXIgPSBHZXRTbG90KHJlbGF0aXZlVG8sIENBTEVOREFSKTtcbiAgICB9XG4gICAgLy8gRmlyc3QgY29udmVydCB0aW1lIHVuaXRzIHVwIHRvIGRheXMsIGlmIHJvdW5kaW5nIHRvIGRheXMgb3IgaGlnaGVyIHVuaXRzLlxuICAgIC8vIElmIHJvdW5kaW5nIHJlbGF0aXZlIHRvIGEgWm9uZWREYXRlVGltZSwgdGhlbiBzb21lIGRheXMgbWF5IG5vdCBiZSAyNGguXG4gICAgLy8gVFMgZG9lc24ndCBrbm93IHRoYXQgYGRheUxlbmd0aE5zYCBpcyBvbmx5IHVzZWQgaWYgdGhlIHVuaXQgaXMgZGF5IG9yXG4gICAgLy8gbGFyZ2VyLiBXZSdsbCBjYXN0IGF3YXkgYHVuZGVmaW5lZGAgd2hlbiBpdCdzIHVzZWQgbG93ZXIgZG93biBiZWxvdy5cbiAgICBsZXQgZGF5TGVuZ3RoTnM7XG4gICAgaWYgKHVuaXQgPT09ICd5ZWFyJyB8fCB1bml0ID09PSAnbW9udGgnIHx8IHVuaXQgPT09ICd3ZWVrJyB8fCB1bml0ID09PSAnZGF5Jykge1xuICAgICAgICBuYW5vc2Vjb25kcyA9IFRvdGFsRHVyYXRpb25OYW5vc2Vjb25kcygwLCBob3VycywgbWludXRlcywgc2Vjb25kcywgbWlsbGlzZWNvbmRzLCBtaWNyb3NlY29uZHMsIG5hbm9zZWNvbmRzUGFyYW0sIDApO1xuICAgICAgICBsZXQgaW50ZXJtZWRpYXRlO1xuICAgICAgICBpZiAoemR0UmVsYXRpdmUpIHtcbiAgICAgICAgICAgIGludGVybWVkaWF0ZSA9IE1vdmVSZWxhdGl2ZVpvbmVkRGF0ZVRpbWUoemR0UmVsYXRpdmUsIHllYXJzLCBtb250aHMsIHdlZWtzLCBkYXlzKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZGVsdGFEYXlzO1xuICAgICAgICBsZXQgZGF5TGVuZ3RoO1xuICAgICAgICAoeyBkYXlzOiBkZWx0YURheXMsIG5hbm9zZWNvbmRzLCBkYXlMZW5ndGhOczogZGF5TGVuZ3RoIH0gPSBOYW5vc2Vjb25kc1RvRGF5cyhuYW5vc2Vjb25kcywgaW50ZXJtZWRpYXRlKSk7XG4gICAgICAgIGRheUxlbmd0aE5zID0gSlNCSS5CaWdJbnQoZGF5TGVuZ3RoKTtcbiAgICAgICAgZGF5cyArPSBkZWx0YURheXM7XG4gICAgICAgIGhvdXJzID0gbWludXRlcyA9IHNlY29uZHMgPSBtaWxsaXNlY29uZHMgPSBtaWNyb3NlY29uZHMgPSAwO1xuICAgIH1cbiAgICBsZXQgdG90YWw7XG4gICAgc3dpdGNoICh1bml0KSB7XG4gICAgICAgIGNhc2UgJ3llYXInOiB7XG4gICAgICAgICAgICBpZiAoIWNhbGVuZGFyKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBIHN0YXJ0aW5nIHBvaW50IGlzIHJlcXVpcmVkIGZvciB5ZWFycyByb3VuZGluZycpO1xuICAgICAgICAgICAgLy8gY29udmVydCBtb250aHMgYW5kIHdlZWtzIHRvIGRheXMgYnkgY2FsY3VsYXRpbmcgZGlmZmVyZW5jZShcbiAgICAgICAgICAgIC8vIHJlbGF0aXZlVG8gKyB5ZWFycywgcmVsYXRpdmVUbyArIHsgeWVhcnMsIG1vbnRocywgd2Vla3MgfSlcbiAgICAgICAgICAgIGNvbnN0IHllYXJzRHVyYXRpb24gPSBuZXcgVGVtcG9yYWxEdXJhdGlvbih5ZWFycyk7XG4gICAgICAgICAgICBjb25zdCBkYXRlQWRkID0gY2FsZW5kYXIuZGF0ZUFkZDtcbiAgICAgICAgICAgIGNvbnN0IGZpcnN0QWRkT3B0aW9ucyA9IE9iamVjdENyZWF0ZSQyKG51bGwpO1xuICAgICAgICAgICAgY29uc3QgeWVhcnNMYXRlciA9IENhbGVuZGFyRGF0ZUFkZChjYWxlbmRhciwgcmVsYXRpdmVUbywgeWVhcnNEdXJhdGlvbiwgZmlyc3RBZGRPcHRpb25zLCBkYXRlQWRkKTtcbiAgICAgICAgICAgIGNvbnN0IHllYXJzTW9udGhzV2Vla3MgPSBuZXcgVGVtcG9yYWxEdXJhdGlvbih5ZWFycywgbW9udGhzLCB3ZWVrcyk7XG4gICAgICAgICAgICBjb25zdCBzZWNvbmRBZGRPcHRpb25zID0gT2JqZWN0Q3JlYXRlJDIobnVsbCk7XG4gICAgICAgICAgICBjb25zdCB5ZWFyc01vbnRoc1dlZWtzTGF0ZXIgPSBDYWxlbmRhckRhdGVBZGQoY2FsZW5kYXIsIHJlbGF0aXZlVG8sIHllYXJzTW9udGhzV2Vla3MsIHNlY29uZEFkZE9wdGlvbnMsIGRhdGVBZGQpO1xuICAgICAgICAgICAgY29uc3QgbW9udGhzV2Vla3NJbkRheXMgPSBEYXlzVW50aWwoeWVhcnNMYXRlciwgeWVhcnNNb250aHNXZWVrc0xhdGVyKTtcbiAgICAgICAgICAgIHJlbGF0aXZlVG8gPSB5ZWFyc0xhdGVyO1xuICAgICAgICAgICAgZGF5cyArPSBtb250aHNXZWVrc0luRGF5cztcbiAgICAgICAgICAgIGNvbnN0IHRoaXJkQWRkT3B0aW9ucyA9IE9iamVjdENyZWF0ZSQyKG51bGwpO1xuICAgICAgICAgICAgY29uc3QgZGF5c0xhdGVyID0gQ2FsZW5kYXJEYXRlQWRkKGNhbGVuZGFyLCByZWxhdGl2ZVRvLCB7IGRheXMgfSwgdGhpcmRBZGRPcHRpb25zLCBkYXRlQWRkKTtcbiAgICAgICAgICAgIGNvbnN0IHVudGlsT3B0aW9ucyA9IE9iamVjdENyZWF0ZSQyKG51bGwpO1xuICAgICAgICAgICAgdW50aWxPcHRpb25zLmxhcmdlc3RVbml0ID0gJ3llYXInO1xuICAgICAgICAgICAgY29uc3QgeWVhcnNQYXNzZWQgPSBDYWxlbmRhckRhdGVVbnRpbChjYWxlbmRhciwgcmVsYXRpdmVUbywgZGF5c0xhdGVyLCB1bnRpbE9wdGlvbnMpLnllYXJzO1xuICAgICAgICAgICAgeWVhcnMgKz0geWVhcnNQYXNzZWQ7XG4gICAgICAgICAgICBjb25zdCBvbGRSZWxhdGl2ZVRvID0gcmVsYXRpdmVUbztcbiAgICAgICAgICAgIGNvbnN0IGZvdXJ0aEFkZE9wdGlvbnMgPSBPYmplY3RDcmVhdGUkMihudWxsKTtcbiAgICAgICAgICAgIHJlbGF0aXZlVG8gPSBDYWxlbmRhckRhdGVBZGQoY2FsZW5kYXIsIHJlbGF0aXZlVG8sIHsgeWVhcnM6IHllYXJzUGFzc2VkIH0sIGZvdXJ0aEFkZE9wdGlvbnMsIGRhdGVBZGQpO1xuICAgICAgICAgICAgY29uc3QgZGF5c1Bhc3NlZCA9IERheXNVbnRpbChvbGRSZWxhdGl2ZVRvLCByZWxhdGl2ZVRvKTtcbiAgICAgICAgICAgIGRheXMgLT0gZGF5c1Bhc3NlZDtcbiAgICAgICAgICAgIGNvbnN0IG9uZVllYXIgPSBuZXcgVGVtcG9yYWxEdXJhdGlvbihkYXlzIDwgMCA/IC0xIDogMSk7XG4gICAgICAgICAgICBsZXQgeyBkYXlzOiBvbmVZZWFyRGF5cyB9ID0gTW92ZVJlbGF0aXZlRGF0ZShjYWxlbmRhciwgcmVsYXRpdmVUbywgb25lWWVhcik7XG4gICAgICAgICAgICAvLyBOb3RlIHRoYXQgYG5hbm9zZWNvbmRzYCBiZWxvdyAoaGVyZSBhbmQgaW4gc2ltaWxhciBjb2RlIGZvciBtb250aHMsXG4gICAgICAgICAgICAvLyB3ZWVrcywgYW5kIGRheXMgZnVydGhlciBiZWxvdykgaXNuJ3QgYWN0dWFsbHkgbmFub3NlY29uZHMgZm9yIHRoZVxuICAgICAgICAgICAgLy8gZnVsbCBkYXRlIHJhbmdlLiAgSW5zdGVhZCwgaXQncyBhIEJpZ0ludCByZXByZXNlbnRhdGlvbiBvZiB0b3RhbFxuICAgICAgICAgICAgLy8gZGF5cyBtdWx0aXBsaWVkIGJ5IHRoZSBudW1iZXIgb2YgbmFub3NlY29uZHMgaW4gdGhlIGxhc3QgZGF5IG9mXG4gICAgICAgICAgICAvLyB0aGUgZHVyYXRpb24uIFRoaXMgbGV0cyB1cyBkbyBkYXlzLW9yLWxhcmdlciByb3VuZGluZyB1c2luZyBCaWdJbnRcbiAgICAgICAgICAgIC8vIG1hdGggd2hpY2ggcmVkdWNlcyBwcmVjaXNpb24gbG9zcy5cbiAgICAgICAgICAgIG9uZVllYXJEYXlzID0gTWF0aEFicyhvbmVZZWFyRGF5cyk7XG4gICAgICAgICAgICAvLyBkYXlMZW5ndGhOcyBpcyBuZXZlciB1bmRlZmluZWQgaWYgdW5pdCBpcyBgZGF5YCBvciBsYXJnZXIuXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgICAgICAgY29uc3QgZGl2aXNvciA9IEpTQkkubXVsdGlwbHkoSlNCSS5CaWdJbnQob25lWWVhckRheXMpLCBkYXlMZW5ndGhOcyk7XG4gICAgICAgICAgICBuYW5vc2Vjb25kcyA9IEpTQkkuYWRkKFxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICAgICAgICAgIEpTQkkuYWRkKEpTQkkubXVsdGlwbHkoZGl2aXNvciwgSlNCSS5CaWdJbnQoeWVhcnMpKSwgSlNCSS5tdWx0aXBseShKU0JJLkJpZ0ludChkYXlzKSwgZGF5TGVuZ3RoTnMpKSwgbmFub3NlY29uZHMpO1xuICAgICAgICAgICAgY29uc3Qgcm91bmRlZCA9IFJvdW5kTnVtYmVyVG9JbmNyZW1lbnQobmFub3NlY29uZHMsIEpTQkkudG9OdW1iZXIoSlNCSS5tdWx0aXBseShkaXZpc29yLCBKU0JJLkJpZ0ludChpbmNyZW1lbnQpKSksIHJvdW5kaW5nTW9kZSk7XG4gICAgICAgICAgICB0b3RhbCA9IEpTQkkudG9OdW1iZXIobmFub3NlY29uZHMpIC8gSlNCSS50b051bWJlcihkaXZpc29yKTtcbiAgICAgICAgICAgIHllYXJzID0gSlNCSS50b051bWJlcihKU0JJLmRpdmlkZShyb3VuZGVkLCBkaXZpc29yKSk7XG4gICAgICAgICAgICBuYW5vc2Vjb25kcyA9IFpFUk87XG4gICAgICAgICAgICBtb250aHMgPSB3ZWVrcyA9IGRheXMgPSAwO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnbW9udGgnOiB7XG4gICAgICAgICAgICBpZiAoIWNhbGVuZGFyKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBIHN0YXJ0aW5nIHBvaW50IGlzIHJlcXVpcmVkIGZvciBtb250aHMgcm91bmRpbmcnKTtcbiAgICAgICAgICAgIC8vIGNvbnZlcnQgd2Vla3MgdG8gZGF5cyBieSBjYWxjdWxhdGluZyBkaWZmZXJlbmNlKHJlbGF0aXZlVG8gK1xuICAgICAgICAgICAgLy8gICB7IHllYXJzLCBtb250aHMgfSwgcmVsYXRpdmVUbyArIHsgeWVhcnMsIG1vbnRocywgd2Vla3MgfSlcbiAgICAgICAgICAgIGNvbnN0IHllYXJzTW9udGhzID0gbmV3IFRlbXBvcmFsRHVyYXRpb24oeWVhcnMsIG1vbnRocyk7XG4gICAgICAgICAgICBjb25zdCBkYXRlQWRkID0gY2FsZW5kYXIuZGF0ZUFkZDtcbiAgICAgICAgICAgIGNvbnN0IGZpcnN0QWRkT3B0aW9ucyA9IE9iamVjdENyZWF0ZSQyKG51bGwpO1xuICAgICAgICAgICAgY29uc3QgeWVhcnNNb250aHNMYXRlciA9IENhbGVuZGFyRGF0ZUFkZChjYWxlbmRhciwgcmVsYXRpdmVUbywgeWVhcnNNb250aHMsIGZpcnN0QWRkT3B0aW9ucywgZGF0ZUFkZCk7XG4gICAgICAgICAgICBjb25zdCB5ZWFyc01vbnRoc1dlZWtzID0gbmV3IFRlbXBvcmFsRHVyYXRpb24oeWVhcnMsIG1vbnRocywgd2Vla3MpO1xuICAgICAgICAgICAgY29uc3Qgc2Vjb25kQWRkT3B0aW9ucyA9IE9iamVjdENyZWF0ZSQyKG51bGwpO1xuICAgICAgICAgICAgY29uc3QgeWVhcnNNb250aHNXZWVrc0xhdGVyID0gQ2FsZW5kYXJEYXRlQWRkKGNhbGVuZGFyLCByZWxhdGl2ZVRvLCB5ZWFyc01vbnRoc1dlZWtzLCBzZWNvbmRBZGRPcHRpb25zLCBkYXRlQWRkKTtcbiAgICAgICAgICAgIGNvbnN0IHdlZWtzSW5EYXlzID0gRGF5c1VudGlsKHllYXJzTW9udGhzTGF0ZXIsIHllYXJzTW9udGhzV2Vla3NMYXRlcik7XG4gICAgICAgICAgICByZWxhdGl2ZVRvID0geWVhcnNNb250aHNMYXRlcjtcbiAgICAgICAgICAgIGRheXMgKz0gd2Vla3NJbkRheXM7XG4gICAgICAgICAgICAvLyBNb250aHMgbWF5IGJlIGRpZmZlcmVudCBsZW5ndGhzIG9mIGRheXMgZGVwZW5kaW5nIG9uIHRoZSBjYWxlbmRhcixcbiAgICAgICAgICAgIC8vIGNvbnZlcnQgZGF5cyB0byBtb250aHMgaW4gYSBsb29wIGFzIGRlc2NyaWJlZCBhYm92ZSB1bmRlciAneWVhcnMnLlxuICAgICAgICAgICAgY29uc3Qgc2lnbiA9IE1hdGhTaWduKGRheXMpO1xuICAgICAgICAgICAgY29uc3Qgb25lTW9udGggPSBuZXcgVGVtcG9yYWxEdXJhdGlvbigwLCBkYXlzIDwgMCA/IC0xIDogMSk7XG4gICAgICAgICAgICBsZXQgb25lTW9udGhEYXlzO1xuICAgICAgICAgICAgKHsgcmVsYXRpdmVUbywgZGF5czogb25lTW9udGhEYXlzIH0gPSBNb3ZlUmVsYXRpdmVEYXRlKGNhbGVuZGFyLCByZWxhdGl2ZVRvLCBvbmVNb250aCkpO1xuICAgICAgICAgICAgd2hpbGUgKE1hdGhBYnMoZGF5cykgPj0gTWF0aEFicyhvbmVNb250aERheXMpKSB7XG4gICAgICAgICAgICAgICAgbW9udGhzICs9IHNpZ247XG4gICAgICAgICAgICAgICAgZGF5cyAtPSBvbmVNb250aERheXM7XG4gICAgICAgICAgICAgICAgKHsgcmVsYXRpdmVUbywgZGF5czogb25lTW9udGhEYXlzIH0gPSBNb3ZlUmVsYXRpdmVEYXRlKGNhbGVuZGFyLCByZWxhdGl2ZVRvLCBvbmVNb250aCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb25lTW9udGhEYXlzID0gTWF0aEFicyhvbmVNb250aERheXMpO1xuICAgICAgICAgICAgLy8gZGF5TGVuZ3RoTnMgaXMgbmV2ZXIgdW5kZWZpbmVkIGlmIHVuaXQgaXMgYGRheWAgb3IgbGFyZ2VyLlxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICAgICAgICAgIGNvbnN0IGRpdmlzb3IgPSBKU0JJLm11bHRpcGx5KEpTQkkuQmlnSW50KG9uZU1vbnRoRGF5cyksIGRheUxlbmd0aE5zKTtcbiAgICAgICAgICAgIG5hbm9zZWNvbmRzID0gSlNCSS5hZGQoXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgICAgICAgSlNCSS5hZGQoSlNCSS5tdWx0aXBseShkaXZpc29yLCBKU0JJLkJpZ0ludChtb250aHMpKSwgSlNCSS5tdWx0aXBseShKU0JJLkJpZ0ludChkYXlzKSwgZGF5TGVuZ3RoTnMpKSwgbmFub3NlY29uZHMpO1xuICAgICAgICAgICAgY29uc3Qgcm91bmRlZCA9IFJvdW5kTnVtYmVyVG9JbmNyZW1lbnQobmFub3NlY29uZHMsIEpTQkkudG9OdW1iZXIoSlNCSS5tdWx0aXBseShkaXZpc29yLCBKU0JJLkJpZ0ludChpbmNyZW1lbnQpKSksIHJvdW5kaW5nTW9kZSk7XG4gICAgICAgICAgICB0b3RhbCA9IEpTQkkudG9OdW1iZXIobmFub3NlY29uZHMpIC8gSlNCSS50b051bWJlcihkaXZpc29yKTtcbiAgICAgICAgICAgIG1vbnRocyA9IEpTQkkudG9OdW1iZXIoSlNCSS5kaXZpZGUocm91bmRlZCwgZGl2aXNvcikpO1xuICAgICAgICAgICAgbmFub3NlY29uZHMgPSBaRVJPO1xuICAgICAgICAgICAgd2Vla3MgPSBkYXlzID0gMDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ3dlZWsnOiB7XG4gICAgICAgICAgICBpZiAoIWNhbGVuZGFyKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBIHN0YXJ0aW5nIHBvaW50IGlzIHJlcXVpcmVkIGZvciB3ZWVrcyByb3VuZGluZycpO1xuICAgICAgICAgICAgLy8gV2Vla3MgbWF5IGJlIGRpZmZlcmVudCBsZW5ndGhzIG9mIGRheXMgZGVwZW5kaW5nIG9uIHRoZSBjYWxlbmRhcixcbiAgICAgICAgICAgIC8vIGNvbnZlcnQgZGF5cyB0byB3ZWVrcyBpbiBhIGxvb3AgYXMgZGVzY3JpYmVkIGFib3ZlIHVuZGVyICd5ZWFycycuXG4gICAgICAgICAgICBjb25zdCBzaWduID0gTWF0aFNpZ24oZGF5cyk7XG4gICAgICAgICAgICBjb25zdCBvbmVXZWVrID0gbmV3IFRlbXBvcmFsRHVyYXRpb24oMCwgMCwgZGF5cyA8IDAgPyAtMSA6IDEpO1xuICAgICAgICAgICAgbGV0IG9uZVdlZWtEYXlzO1xuICAgICAgICAgICAgKHsgcmVsYXRpdmVUbywgZGF5czogb25lV2Vla0RheXMgfSA9IE1vdmVSZWxhdGl2ZURhdGUoY2FsZW5kYXIsIHJlbGF0aXZlVG8sIG9uZVdlZWspKTtcbiAgICAgICAgICAgIHdoaWxlIChNYXRoQWJzKGRheXMpID49IE1hdGhBYnMob25lV2Vla0RheXMpKSB7XG4gICAgICAgICAgICAgICAgd2Vla3MgKz0gc2lnbjtcbiAgICAgICAgICAgICAgICBkYXlzIC09IG9uZVdlZWtEYXlzO1xuICAgICAgICAgICAgICAgICh7IHJlbGF0aXZlVG8sIGRheXM6IG9uZVdlZWtEYXlzIH0gPSBNb3ZlUmVsYXRpdmVEYXRlKGNhbGVuZGFyLCByZWxhdGl2ZVRvLCBvbmVXZWVrKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvbmVXZWVrRGF5cyA9IE1hdGhBYnMob25lV2Vla0RheXMpO1xuICAgICAgICAgICAgLy8gZGF5TGVuZ3RoTnMgaXMgbmV2ZXIgdW5kZWZpbmVkIGlmIHVuaXQgaXMgYGRheWAgb3IgbGFyZ2VyLlxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICAgICAgICAgIGNvbnN0IGRpdmlzb3IgPSBKU0JJLm11bHRpcGx5KEpTQkkuQmlnSW50KG9uZVdlZWtEYXlzKSwgZGF5TGVuZ3RoTnMpO1xuICAgICAgICAgICAgbmFub3NlY29uZHMgPSBKU0JJLmFkZChcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICAgICAgICBKU0JJLmFkZChKU0JJLm11bHRpcGx5KGRpdmlzb3IsIEpTQkkuQmlnSW50KHdlZWtzKSksIEpTQkkubXVsdGlwbHkoSlNCSS5CaWdJbnQoZGF5cyksIGRheUxlbmd0aE5zKSksIG5hbm9zZWNvbmRzKTtcbiAgICAgICAgICAgIGNvbnN0IHJvdW5kZWQgPSBSb3VuZE51bWJlclRvSW5jcmVtZW50KG5hbm9zZWNvbmRzLCBKU0JJLnRvTnVtYmVyKEpTQkkubXVsdGlwbHkoZGl2aXNvciwgSlNCSS5CaWdJbnQoaW5jcmVtZW50KSkpLCByb3VuZGluZ01vZGUpO1xuICAgICAgICAgICAgdG90YWwgPSBKU0JJLnRvTnVtYmVyKG5hbm9zZWNvbmRzKSAvIEpTQkkudG9OdW1iZXIoZGl2aXNvcik7XG4gICAgICAgICAgICB3ZWVrcyA9IEpTQkkudG9OdW1iZXIoSlNCSS5kaXZpZGUocm91bmRlZCwgZGl2aXNvcikpO1xuICAgICAgICAgICAgbmFub3NlY29uZHMgPSBaRVJPO1xuICAgICAgICAgICAgZGF5cyA9IDA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdkYXknOiB7XG4gICAgICAgICAgICAvLyBkYXlMZW5ndGhOcyBpcyBuZXZlciB1bmRlZmluZWQgaWYgdW5pdCBpcyBgZGF5YCBvciBsYXJnZXIuXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgICAgICAgY29uc3QgZGl2aXNvciA9IGRheUxlbmd0aE5zO1xuICAgICAgICAgICAgbmFub3NlY29uZHMgPSBKU0JJLmFkZChKU0JJLm11bHRpcGx5KGRpdmlzb3IsIEpTQkkuQmlnSW50KGRheXMpKSwgbmFub3NlY29uZHMpO1xuICAgICAgICAgICAgY29uc3Qgcm91bmRlZCA9IFJvdW5kTnVtYmVyVG9JbmNyZW1lbnQobmFub3NlY29uZHMsIEpTQkkudG9OdW1iZXIoSlNCSS5tdWx0aXBseShkaXZpc29yLCBKU0JJLkJpZ0ludChpbmNyZW1lbnQpKSksIHJvdW5kaW5nTW9kZSk7XG4gICAgICAgICAgICB0b3RhbCA9IEpTQkkudG9OdW1iZXIobmFub3NlY29uZHMpIC8gSlNCSS50b051bWJlcihkaXZpc29yKTtcbiAgICAgICAgICAgIGRheXMgPSBKU0JJLnRvTnVtYmVyKEpTQkkuZGl2aWRlKHJvdW5kZWQsIGRpdmlzb3IpKTtcbiAgICAgICAgICAgIG5hbm9zZWNvbmRzID0gWkVSTztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ2hvdXInOiB7XG4gICAgICAgICAgICBjb25zdCBkaXZpc29yID0gMzYwMGU5O1xuICAgICAgICAgICAgbGV0IGFsbE5hbm9zZWNvbmRzID0gSlNCSS5tdWx0aXBseShKU0JJLkJpZ0ludChob3VycyksIEpTQkkuQmlnSW50KDM2MDBlOSkpO1xuICAgICAgICAgICAgYWxsTmFub3NlY29uZHMgPSBKU0JJLmFkZChhbGxOYW5vc2Vjb25kcywgSlNCSS5tdWx0aXBseShKU0JJLkJpZ0ludChtaW51dGVzKSwgSlNCSS5CaWdJbnQoNjBlOSkpKTtcbiAgICAgICAgICAgIGFsbE5hbm9zZWNvbmRzID0gSlNCSS5hZGQoYWxsTmFub3NlY29uZHMsIEpTQkkubXVsdGlwbHkoSlNCSS5CaWdJbnQoc2Vjb25kcyksIEJJTExJT04pKTtcbiAgICAgICAgICAgIGFsbE5hbm9zZWNvbmRzID0gSlNCSS5hZGQoYWxsTmFub3NlY29uZHMsIEpTQkkubXVsdGlwbHkoSlNCSS5CaWdJbnQobWlsbGlzZWNvbmRzKSwgTUlMTElPTikpO1xuICAgICAgICAgICAgYWxsTmFub3NlY29uZHMgPSBKU0JJLmFkZChhbGxOYW5vc2Vjb25kcywgSlNCSS5tdWx0aXBseShKU0JJLkJpZ0ludChtaWNyb3NlY29uZHMpLCBUSE9VU0FORCkpO1xuICAgICAgICAgICAgYWxsTmFub3NlY29uZHMgPSBKU0JJLmFkZChhbGxOYW5vc2Vjb25kcywgbmFub3NlY29uZHMpO1xuICAgICAgICAgICAgdG90YWwgPSBKU0JJLnRvTnVtYmVyKGFsbE5hbm9zZWNvbmRzKSAvIGRpdmlzb3I7XG4gICAgICAgICAgICBjb25zdCByb3VuZGVkID0gUm91bmROdW1iZXJUb0luY3JlbWVudChhbGxOYW5vc2Vjb25kcywgZGl2aXNvciAqIGluY3JlbWVudCwgcm91bmRpbmdNb2RlKTtcbiAgICAgICAgICAgIGhvdXJzID0gSlNCSS50b051bWJlcihKU0JJLmRpdmlkZShyb3VuZGVkLCBKU0JJLkJpZ0ludChkaXZpc29yKSkpO1xuICAgICAgICAgICAgbmFub3NlY29uZHMgPSBaRVJPO1xuICAgICAgICAgICAgbWludXRlcyA9IHNlY29uZHMgPSBtaWxsaXNlY29uZHMgPSBtaWNyb3NlY29uZHMgPSAwO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnbWludXRlJzoge1xuICAgICAgICAgICAgY29uc3QgZGl2aXNvciA9IDYwZTk7XG4gICAgICAgICAgICBsZXQgYWxsTmFub3NlY29uZHMgPSBKU0JJLm11bHRpcGx5KEpTQkkuQmlnSW50KG1pbnV0ZXMpLCBKU0JJLkJpZ0ludCg2MGU5KSk7XG4gICAgICAgICAgICBhbGxOYW5vc2Vjb25kcyA9IEpTQkkuYWRkKGFsbE5hbm9zZWNvbmRzLCBKU0JJLm11bHRpcGx5KEpTQkkuQmlnSW50KHNlY29uZHMpLCBCSUxMSU9OKSk7XG4gICAgICAgICAgICBhbGxOYW5vc2Vjb25kcyA9IEpTQkkuYWRkKGFsbE5hbm9zZWNvbmRzLCBKU0JJLm11bHRpcGx5KEpTQkkuQmlnSW50KG1pbGxpc2Vjb25kcyksIE1JTExJT04pKTtcbiAgICAgICAgICAgIGFsbE5hbm9zZWNvbmRzID0gSlNCSS5hZGQoYWxsTmFub3NlY29uZHMsIEpTQkkubXVsdGlwbHkoSlNCSS5CaWdJbnQobWljcm9zZWNvbmRzKSwgVEhPVVNBTkQpKTtcbiAgICAgICAgICAgIGFsbE5hbm9zZWNvbmRzID0gSlNCSS5hZGQoYWxsTmFub3NlY29uZHMsIG5hbm9zZWNvbmRzKTtcbiAgICAgICAgICAgIHRvdGFsID0gSlNCSS50b051bWJlcihhbGxOYW5vc2Vjb25kcykgLyBkaXZpc29yO1xuICAgICAgICAgICAgY29uc3Qgcm91bmRlZCA9IFJvdW5kTnVtYmVyVG9JbmNyZW1lbnQoYWxsTmFub3NlY29uZHMsIGRpdmlzb3IgKiBpbmNyZW1lbnQsIHJvdW5kaW5nTW9kZSk7XG4gICAgICAgICAgICBtaW51dGVzID0gSlNCSS50b051bWJlcihKU0JJLmRpdmlkZShyb3VuZGVkLCBKU0JJLkJpZ0ludChkaXZpc29yKSkpO1xuICAgICAgICAgICAgbmFub3NlY29uZHMgPSBaRVJPO1xuICAgICAgICAgICAgc2Vjb25kcyA9IG1pbGxpc2Vjb25kcyA9IG1pY3Jvc2Vjb25kcyA9IDA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdzZWNvbmQnOiB7XG4gICAgICAgICAgICBjb25zdCBkaXZpc29yID0gMWU5O1xuICAgICAgICAgICAgbGV0IGFsbE5hbm9zZWNvbmRzID0gSlNCSS5tdWx0aXBseShKU0JJLkJpZ0ludChzZWNvbmRzKSwgQklMTElPTik7XG4gICAgICAgICAgICBhbGxOYW5vc2Vjb25kcyA9IEpTQkkuYWRkKGFsbE5hbm9zZWNvbmRzLCBKU0JJLm11bHRpcGx5KEpTQkkuQmlnSW50KG1pbGxpc2Vjb25kcyksIE1JTExJT04pKTtcbiAgICAgICAgICAgIGFsbE5hbm9zZWNvbmRzID0gSlNCSS5hZGQoYWxsTmFub3NlY29uZHMsIEpTQkkubXVsdGlwbHkoSlNCSS5CaWdJbnQobWljcm9zZWNvbmRzKSwgVEhPVVNBTkQpKTtcbiAgICAgICAgICAgIGFsbE5hbm9zZWNvbmRzID0gSlNCSS5hZGQoYWxsTmFub3NlY29uZHMsIG5hbm9zZWNvbmRzKTtcbiAgICAgICAgICAgIHRvdGFsID0gSlNCSS50b051bWJlcihhbGxOYW5vc2Vjb25kcykgLyBkaXZpc29yO1xuICAgICAgICAgICAgY29uc3Qgcm91bmRlZCA9IFJvdW5kTnVtYmVyVG9JbmNyZW1lbnQoYWxsTmFub3NlY29uZHMsIGRpdmlzb3IgKiBpbmNyZW1lbnQsIHJvdW5kaW5nTW9kZSk7XG4gICAgICAgICAgICBzZWNvbmRzID0gSlNCSS50b051bWJlcihKU0JJLmRpdmlkZShyb3VuZGVkLCBKU0JJLkJpZ0ludChkaXZpc29yKSkpO1xuICAgICAgICAgICAgbmFub3NlY29uZHMgPSBaRVJPO1xuICAgICAgICAgICAgbWlsbGlzZWNvbmRzID0gbWljcm9zZWNvbmRzID0gMDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ21pbGxpc2Vjb25kJzoge1xuICAgICAgICAgICAgY29uc3QgZGl2aXNvciA9IDFlNjtcbiAgICAgICAgICAgIGxldCBhbGxOYW5vc2Vjb25kcyA9IEpTQkkubXVsdGlwbHkoSlNCSS5CaWdJbnQobWlsbGlzZWNvbmRzKSwgTUlMTElPTik7XG4gICAgICAgICAgICBhbGxOYW5vc2Vjb25kcyA9IEpTQkkuYWRkKGFsbE5hbm9zZWNvbmRzLCBKU0JJLm11bHRpcGx5KEpTQkkuQmlnSW50KG1pY3Jvc2Vjb25kcyksIFRIT1VTQU5EKSk7XG4gICAgICAgICAgICBhbGxOYW5vc2Vjb25kcyA9IEpTQkkuYWRkKGFsbE5hbm9zZWNvbmRzLCBuYW5vc2Vjb25kcyk7XG4gICAgICAgICAgICB0b3RhbCA9IEpTQkkudG9OdW1iZXIoYWxsTmFub3NlY29uZHMpIC8gZGl2aXNvcjtcbiAgICAgICAgICAgIGNvbnN0IHJvdW5kZWQgPSBSb3VuZE51bWJlclRvSW5jcmVtZW50KGFsbE5hbm9zZWNvbmRzLCBkaXZpc29yICogaW5jcmVtZW50LCByb3VuZGluZ01vZGUpO1xuICAgICAgICAgICAgbWlsbGlzZWNvbmRzID0gSlNCSS50b051bWJlcihKU0JJLmRpdmlkZShyb3VuZGVkLCBKU0JJLkJpZ0ludChkaXZpc29yKSkpO1xuICAgICAgICAgICAgbmFub3NlY29uZHMgPSBaRVJPO1xuICAgICAgICAgICAgbWljcm9zZWNvbmRzID0gMDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ21pY3Jvc2Vjb25kJzoge1xuICAgICAgICAgICAgY29uc3QgZGl2aXNvciA9IDFlMztcbiAgICAgICAgICAgIGxldCBhbGxOYW5vc2Vjb25kcyA9IEpTQkkubXVsdGlwbHkoSlNCSS5CaWdJbnQobWljcm9zZWNvbmRzKSwgVEhPVVNBTkQpO1xuICAgICAgICAgICAgYWxsTmFub3NlY29uZHMgPSBKU0JJLmFkZChhbGxOYW5vc2Vjb25kcywgbmFub3NlY29uZHMpO1xuICAgICAgICAgICAgdG90YWwgPSBKU0JJLnRvTnVtYmVyKGFsbE5hbm9zZWNvbmRzKSAvIGRpdmlzb3I7XG4gICAgICAgICAgICBjb25zdCByb3VuZGVkID0gUm91bmROdW1iZXJUb0luY3JlbWVudChhbGxOYW5vc2Vjb25kcywgZGl2aXNvciAqIGluY3JlbWVudCwgcm91bmRpbmdNb2RlKTtcbiAgICAgICAgICAgIG1pY3Jvc2Vjb25kcyA9IEpTQkkudG9OdW1iZXIoSlNCSS5kaXZpZGUocm91bmRlZCwgSlNCSS5CaWdJbnQoZGl2aXNvcikpKTtcbiAgICAgICAgICAgIG5hbm9zZWNvbmRzID0gWkVSTztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ25hbm9zZWNvbmQnOiB7XG4gICAgICAgICAgICB0b3RhbCA9IEpTQkkudG9OdW1iZXIobmFub3NlY29uZHMpO1xuICAgICAgICAgICAgbmFub3NlY29uZHMgPSBSb3VuZE51bWJlclRvSW5jcmVtZW50KG5hbm9zZWNvbmRzLCBpbmNyZW1lbnQsIHJvdW5kaW5nTW9kZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICB5ZWFycyxcbiAgICAgICAgbW9udGhzLFxuICAgICAgICB3ZWVrcyxcbiAgICAgICAgZGF5cyxcbiAgICAgICAgaG91cnMsXG4gICAgICAgIG1pbnV0ZXMsXG4gICAgICAgIHNlY29uZHMsXG4gICAgICAgIG1pbGxpc2Vjb25kcyxcbiAgICAgICAgbWljcm9zZWNvbmRzLFxuICAgICAgICBuYW5vc2Vjb25kczogSlNCSS50b051bWJlcihuYW5vc2Vjb25kcyksXG4gICAgICAgIHRvdGFsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIENvbXBhcmVJU09EYXRlKHkxLCBtMSwgZDEsIHkyLCBtMiwgZDIpIHtcbiAgICBmb3IgKGNvbnN0IFt4LCB5XSBvZiBbXG4gICAgICAgIFt5MSwgeTJdLFxuICAgICAgICBbbTEsIG0yXSxcbiAgICAgICAgW2QxLCBkMl1cbiAgICBdKSB7XG4gICAgICAgIGlmICh4ICE9PSB5KVxuICAgICAgICAgICAgcmV0dXJuIENvbXBhcmlzb25SZXN1bHQoeCAtIHkpO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbn1cbmZ1bmN0aW9uIE5vbk5lZ2F0aXZlTW9kdWxvKHgsIHkpIHtcbiAgICBsZXQgcmVzdWx0ID0geCAlIHk7XG4gICAgaWYgKE9iamVjdElzKHJlc3VsdCwgLTApKVxuICAgICAgICByZXR1cm4gMDtcbiAgICBpZiAocmVzdWx0IDwgMClcbiAgICAgICAgcmVzdWx0ICs9IHk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIFRvQmlnSW50RXh0ZXJuYWwoYXJnKSB7XG4gICAgY29uc3QganNiaUJJID0gVG9CaWdJbnQoYXJnKTtcbiAgICBpZiAodHlwZW9mIGdsb2JhbFRoaXMuQmlnSW50ICE9PSAndW5kZWZpbmVkJylcbiAgICAgICAgcmV0dXJuIGdsb2JhbFRoaXMuQmlnSW50KGpzYmlCSS50b1N0cmluZygxMCkpO1xuICAgIHJldHVybiBqc2JpQkk7XG59XG5mdW5jdGlvbiBUb0JpZ0ludChhcmcpIHtcbiAgICBpZiAoYXJnIGluc3RhbmNlb2YgSlNCSSkge1xuICAgICAgICByZXR1cm4gYXJnO1xuICAgIH1cbiAgICBsZXQgcHJpbSA9IGFyZztcbiAgICBpZiAodHlwZW9mIGFyZyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgY29uc3QgdG9QcmltRm4gPSBhcmdbU3ltYm9sLnRvUHJpbWl0aXZlXTtcbiAgICAgICAgaWYgKHRvUHJpbUZuICYmIHR5cGVvZiB0b1ByaW1GbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcHJpbSA9IFJlZmxlY3RBcHBseSQxKHRvUHJpbUZuLCBhcmcsIFsnbnVtYmVyJ10pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN3aXRjaCAodHlwZW9mIHByaW0pIHtcbiAgICAgICAgY2FzZSAndW5kZWZpbmVkJzpcbiAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgY2FzZSAnc3ltYm9sJzpcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYGNhbm5vdCBjb252ZXJ0ICR7dHlwZW9mIGFyZ30gdG8gYmlnaW50YCk7XG4gICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICBpZiAoIXByaW0ubWF0Y2goL15cXHMqKD86WystXT9cXGQrXFxzKik/JC8pKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdpbnZhbGlkIEJpZ0ludCBzeW50YXgnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgLy8gZXNsaW50OiBuby1mYWxsdGhyb3VnaDogZmFsc2VcbiAgICAgICAgY2FzZSAnYmlnaW50JzpcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEpTQkkuQmlnSW50KHByaW0udG9TdHJpbmcoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgRXJyb3IgJiYgZS5tZXNzYWdlLnN0YXJ0c1dpdGgoJ0ludmFsaWQgaW50ZWdlcicpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoZS5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgfVxuICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgIGlmIChwcmltKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE9ORTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBaRVJPO1xuICAgICAgICAgICAgfVxuICAgIH1cbn1cbi8vIE5vdGU6IFRoaXMgbWV0aG9kIHJldHVybnMgdmFsdWVzIHdpdGggYm9ndXMgbmFub3NlY29uZHMgYmFzZWQgb24gdGhlIHByZXZpb3VzIGl0ZXJhdGlvbidzXG4vLyBtaWxsaXNlY29uZHMuIFRoYXQgd2F5IHRoZXJlIGlzIGEgZ3VhcmFudGVlIHRoYXQgdGhlIGZ1bGwgbmFub3NlY29uZHMgYXJlIGFsd2F5cyBnb2luZyB0byBiZVxuLy8gaW5jcmVhc2luZyBhdCBsZWFzdCBhbmQgdGhhdCB0aGUgbWljcm9zZWNvbmQgYW5kIG5hbm9zZWNvbmQgZmllbGRzIGFyZSBsaWtlbHkgdG8gYmUgbm9uLXplcm8uXG5jb25zdCBTeXN0ZW1VVENFcG9jaE5hbm9TZWNvbmRzID0gKCgpID0+IHtcbiAgICBsZXQgbnMgPSBKU0JJLkJpZ0ludChEYXRlLm5vdygpICUgMWU2KTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBjb25zdCBtcyA9IEpTQkkuQmlnSW50KERhdGUubm93KCkpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBKU0JJLmFkZChKU0JJLm11bHRpcGx5KG1zLCBNSUxMSU9OKSwgbnMpO1xuICAgICAgICBucyA9IEpTQkkuZGl2aWRlKG1zLCBNSUxMSU9OKTtcbiAgICAgICAgaWYgKEpTQkkuZ3JlYXRlclRoYW4ocmVzdWx0LCBOU19NQVgpKVxuICAgICAgICAgICAgcmV0dXJuIE5TX01BWDtcbiAgICAgICAgaWYgKEpTQkkubGVzc1RoYW4ocmVzdWx0LCBOU19NSU4pKVxuICAgICAgICAgICAgcmV0dXJuIE5TX01JTjtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xufSkoKTtcbmZ1bmN0aW9uIFN5c3RlbVRpbWVab25lKCkge1xuICAgIGNvbnN0IGZtdCA9IG5ldyBJbnRsRGF0ZVRpbWVGb3JtYXQkMSgnZW4tdXMnKTtcbiAgICBjb25zdCBUZW1wb3JhbFRpbWVab25lID0gR2V0SW50cmluc2ljKCclVGVtcG9yYWwuVGltZVpvbmUlJyk7XG4gICAgcmV0dXJuIG5ldyBUZW1wb3JhbFRpbWVab25lKFBhcnNlVGVtcG9yYWxUaW1lWm9uZShmbXQucmVzb2x2ZWRPcHRpb25zKCkudGltZVpvbmUpKTtcbn1cbmZ1bmN0aW9uIENvbXBhcmlzb25SZXN1bHQodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPCAwID8gLTEgOiB2YWx1ZSA+IDAgPyAxIDogdmFsdWU7XG59XG5mdW5jdGlvbiBHZXRPcHRpb25zT2JqZWN0KG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gT2JqZWN0Q3JlYXRlJDIobnVsbCk7XG4gICAgaWYgKElzT2JqZWN0KG9wdGlvbnMpICYmIG9wdGlvbnMgIT09IG51bGwpXG4gICAgICAgIHJldHVybiBvcHRpb25zO1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE9wdGlvbnMgcGFyYW1ldGVyIG11c3QgYmUgYW4gb2JqZWN0LCBub3QgJHtvcHRpb25zID09PSBudWxsID8gJ251bGwnIDogYCR7dHlwZW9mIG9wdGlvbnN9YH1gKTtcbn1cbmZ1bmN0aW9uIENyZWF0ZU9uZVByb3BPYmplY3QocHJvcE5hbWUsIHByb3BWYWx1ZSkge1xuICAgIGNvbnN0IG8gPSBPYmplY3RDcmVhdGUkMihudWxsKTtcbiAgICBvW3Byb3BOYW1lXSA9IHByb3BWYWx1ZTtcbiAgICByZXR1cm4gbztcbn1cbmZ1bmN0aW9uIEdldE9wdGlvbihvcHRpb25zLCBwcm9wZXJ0eSwgYWxsb3dlZFZhbHVlcywgZmFsbGJhY2spIHtcbiAgICBsZXQgdmFsdWUgPSBvcHRpb25zW3Byb3BlcnR5XTtcbiAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YWx1ZSA9IFRvU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgaWYgKCFhbGxvd2VkVmFsdWVzLmluY2x1ZGVzKHZhbHVlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYCR7cHJvcGVydHl9IG11c3QgYmUgb25lIG9mICR7YWxsb3dlZFZhbHVlcy5qb2luKCcsICcpfSwgbm90ICR7dmFsdWV9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsbGJhY2s7XG59XG5mdW5jdGlvbiBHZXROdW1iZXJPcHRpb24ob3B0aW9ucywgcHJvcGVydHksIG1pbmltdW0sIG1heGltdW0sIGZhbGxiYWNrKSB7XG4gICAgbGV0IHZhbHVlUmF3ID0gb3B0aW9uc1twcm9wZXJ0eV07XG4gICAgaWYgKHZhbHVlUmF3ID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiBmYWxsYmFjaztcbiAgICBjb25zdCB2YWx1ZSA9IFRvTnVtYmVyKHZhbHVlUmF3KTtcbiAgICBpZiAoTnVtYmVySXNOYU4odmFsdWUpIHx8IHZhbHVlIDwgbWluaW11bSB8fCB2YWx1ZSA+IG1heGltdW0pIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYCR7cHJvcGVydHl9IG11c3QgYmUgYmV0d2VlbiAke21pbmltdW19IGFuZCAke21heGltdW19LCBub3QgJHt2YWx1ZX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIE1hdGhGbG9vcih2YWx1ZSk7XG59XG5jb25zdCBPRkZTRVQgPSBuZXcgUmVnRXhwKGBeJHtvZmZzZXQuc291cmNlfSRgKTtcbmZ1bmN0aW9uIGJpc2VjdChnZXRTdGF0ZSwgbGVmdFBhcmFtLCByaWdodFBhcmFtLCBsc3RhdGVQYXJhbSA9IGdldFN0YXRlKGxlZnRQYXJhbSksIHJzdGF0ZVBhcmFtID0gZ2V0U3RhdGUocmlnaHRQYXJhbSkpIHtcbiAgICAvLyBUaGlzIGRvZXNuJ3QgbWFrZSBtdWNoIHNlbnNlIC0gd2h5IGRvIHRoZXNlIGdldCBjb252ZXJ0ZWQgdW5uZWNlc3NhcmlseT9cbiAgICBsZXQgbGVmdCA9IEpTQkkuQmlnSW50KGxlZnRQYXJhbSk7XG4gICAgbGV0IHJpZ2h0ID0gSlNCSS5CaWdJbnQocmlnaHRQYXJhbSk7XG4gICAgbGV0IGxzdGF0ZSA9IGxzdGF0ZVBhcmFtO1xuICAgIGxldCByc3RhdGUgPSByc3RhdGVQYXJhbTtcbiAgICB3aGlsZSAoSlNCSS5ncmVhdGVyVGhhbihKU0JJLnN1YnRyYWN0KHJpZ2h0LCBsZWZ0KSwgT05FKSkge1xuICAgICAgICBjb25zdCBtaWRkbGUgPSBKU0JJLmRpdmlkZShKU0JJLmFkZChsZWZ0LCByaWdodCksIEpTQkkuQmlnSW50KDIpKTtcbiAgICAgICAgY29uc3QgbXN0YXRlID0gZ2V0U3RhdGUobWlkZGxlKTtcbiAgICAgICAgaWYgKG1zdGF0ZSA9PT0gbHN0YXRlKSB7XG4gICAgICAgICAgICBsZWZ0ID0gbWlkZGxlO1xuICAgICAgICAgICAgbHN0YXRlID0gbXN0YXRlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG1zdGF0ZSA9PT0gcnN0YXRlKSB7XG4gICAgICAgICAgICByaWdodCA9IG1pZGRsZTtcbiAgICAgICAgICAgIHJzdGF0ZSA9IG1zdGF0ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBzdGF0ZSBpbiBiaXNlY3Rpb24gJHtsc3RhdGV9IC0gJHttc3RhdGV9IC0gJHtyc3RhdGV9YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJpZ2h0O1xufVxuY29uc3QgbnNQZXJUaW1lVW5pdCA9IHtcbiAgICBob3VyOiAzNjAwZTksXG4gICAgbWludXRlOiA2MGU5LFxuICAgIHNlY29uZDogMWU5LFxuICAgIG1pbGxpc2Vjb25kOiAxZTYsXG4gICAgbWljcm9zZWNvbmQ6IDFlMyxcbiAgICBuYW5vc2Vjb25kOiAxXG59O1xuXG5jb25zdCBEQVRFID0gU3ltYm9sKCdkYXRlJyk7XG5jb25zdCBZTSA9IFN5bWJvbCgneW0nKTtcbmNvbnN0IE1EID0gU3ltYm9sKCdtZCcpO1xuY29uc3QgVElNRSA9IFN5bWJvbCgndGltZScpO1xuY29uc3QgREFURVRJTUUgPSBTeW1ib2woJ2RhdGV0aW1lJyk7XG5jb25zdCBaT05FRCA9IFN5bWJvbCgnem9uZWRkYXRldGltZScpO1xuY29uc3QgSU5TVCA9IFN5bWJvbCgnaW5zdGFudCcpO1xuY29uc3QgT1JJR0lOQUwgPSBTeW1ib2woJ29yaWdpbmFsJyk7XG5jb25zdCBUWl9SRVNPTFZFRCA9IFN5bWJvbCgndGltZXpvbmUnKTtcbmNvbnN0IFRaX0dJVkVOID0gU3ltYm9sKCd0aW1lem9uZS1pZC1naXZlbicpO1xuY29uc3QgQ0FMX0lEID0gU3ltYm9sKCdjYWxlbmRhci1pZCcpO1xuY29uc3QgTE9DQUxFID0gU3ltYm9sKCdsb2NhbGUnKTtcbmNvbnN0IE9QVElPTlMgPSBTeW1ib2woJ29wdGlvbnMnKTtcbmNvbnN0IGRlc2NyaXB0b3IgPSAodmFsdWUpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9O1xufTtcbmNvbnN0IEludGxEYXRlVGltZUZvcm1hdCA9IGdsb2JhbFRoaXMuSW50bC5EYXRlVGltZUZvcm1hdDtcbmNvbnN0IE9iamVjdEFzc2lnbiQxID0gT2JqZWN0LmFzc2lnbjtcbmNvbnN0IE9iamVjdEhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbmNvbnN0IFJlZmxlY3RBcHBseSA9IFJlZmxlY3QuYXBwbHk7XG4vLyBDb25zdHJ1Y3Rpb24gb2YgYnVpbHQtaW4gSW50bC5EYXRlVGltZUZvcm1hdCBvYmplY3RzIGlzIHNsb29vb29vdyxcbi8vIHNvIHdlJ2xsIG9ubHkgY3JlYXRlIHRob3NlIGluc3RhbmNlcyB3aGVuIHdlIG5lZWQgdGhlbS5cbi8vIFNlZSBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD02NTI4XG5mdW5jdGlvbiBnZXRQcm9wTGF6eShvYmosIHByb3ApIHtcbiAgICBsZXQgdmFsID0gb2JqW3Byb3BdO1xuICAgIGlmICh0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIElmIHdlIGdldCBoZXJlLCBgdmFsYCBpcyBhbiBcImFtZW5kZXIgZnVuY3Rpb25cIi4gSXQgd2lsbCB0YWtlIHRoZSB1c2VyJ3NcbiAgICAgICAgLy8gb3B0aW9ucyBhbmQgdHJhbnNmb3JtIHRoZW0gaW50byBzdWl0YWJsZSBvcHRpb25zIHRvIGJlIHBhc3NlZCBpbnRvIHRoZVxuICAgICAgICAvLyBidWlsdC1pbiAobm9uLXBvbHlmaWxsKSBJbnRsLkRhdGVUaW1lRm9ybWF0IGNvbnN0cnVjdG9yLiBUaGVzZSBvcHRpb25zXG4gICAgICAgIC8vIHdpbGwgdmFyeSBkZXBlbmRpbmcgb24gdGhlIFRlbXBvcmFsIHR5cGUsIHNvIHRoYXQncyB3aHkgd2Ugc3RvcmUgc2VwYXJhdGVcbiAgICAgICAgLy8gZm9ybWF0dGVycyBpbiBzZXBhcmF0ZSBwcm9wcyBvbiB0aGUgcG9seWZpbGwncyBEYXRlVGltZUZvcm1hdCBpbnN0YW5jZXMuXG4gICAgICAgIC8vIFRoZSBlZmZpY2llbmN5IGhhcHBlbnMgYmVjYXVzZSB3ZSBkb24ndCBjcmVhdGUgYW4gKGV4cGVuc2l2ZSkgZm9ybWF0dGVyXG4gICAgICAgIC8vIHVudGlsIHRoZSB1c2VyIGNhbGxzIHRvTG9jYWxlU3RyaW5nIGZvciB0aGF0IFRlbXBvcmFsIHR5cGUuXG4gICAgICAgIHZhbCA9IG5ldyBJbnRsRGF0ZVRpbWVGb3JtYXQob2JqW0xPQ0FMRV0sIHZhbChvYmpbT1BUSU9OU10pKTtcbiAgICAgICAgLy8gVE9ETzogY2FuIHRoaXMgYmUgdHlwZWQgbW9yZSBjbGVhbmx5P1xuICAgICAgICBvYmpbcHJvcF0gPSB2YWw7XG4gICAgfVxuICAgIHJldHVybiB2YWw7XG59XG4vLyBTaW1pbGFybHksIGxhenktaW5pdCBUaW1lWm9uZSBpbnN0YW5jZXMuXG5mdW5jdGlvbiBnZXRSZXNvbHZlZFRpbWVab25lTGF6eShvYmopIHtcbiAgICBsZXQgdmFsID0gb2JqW1RaX1JFU09MVkVEXTtcbiAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdmFsID0gVG9UZW1wb3JhbFRpbWVab25lKHZhbCk7XG4gICAgICAgIG9ialtUWl9SRVNPTFZFRF0gPSB2YWw7XG4gICAgfVxuICAgIHJldHVybiB2YWw7XG59XG5mdW5jdGlvbiBEYXRlVGltZUZvcm1hdEltcGwobG9jYWxlID0gdW5kZWZpbmVkLCBvcHRpb25zUGFyYW0gPSB7fSkge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBEYXRlVGltZUZvcm1hdEltcGwpKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZVRpbWVGb3JtYXRJbXBsKGxvY2FsZSwgb3B0aW9uc1BhcmFtKTtcbiAgICB9XG4gICAgY29uc3QgaGFzT3B0aW9ucyA9IHR5cGVvZiBvcHRpb25zUGFyYW0gIT09ICd1bmRlZmluZWQnO1xuICAgIGNvbnN0IG9wdGlvbnMgPSBoYXNPcHRpb25zID8gT2JqZWN0QXNzaWduJDEoe30sIG9wdGlvbnNQYXJhbSkgOiB7fTtcbiAgICAvLyBUT0RPOiByZW1vdmUgdHlwZSBhc3NlcnRpb24gYWZ0ZXIgVGVtcG9yYWwgdHlwZXMgbGFuZCBpbiBUUyBsaWIgdHlwZXNcbiAgICBjb25zdCBvcmlnaW5hbCA9IG5ldyBJbnRsRGF0ZVRpbWVGb3JtYXQobG9jYWxlLCBvcHRpb25zKTtcbiAgICBjb25zdCBybyA9IG9yaWdpbmFsLnJlc29sdmVkT3B0aW9ucygpO1xuICAgIC8vIERhdGVUaW1lRm9ybWF0IGluc3RhbmNlcyBhcmUgdmVyeSBleHBlbnNpdmUgdG8gY3JlYXRlLiBUaGVyZWZvcmUsIHRoZXkgd2lsbFxuICAgIC8vIGJlIGxhemlseSBjcmVhdGVkIG9ubHkgd2hlbiBuZWVkZWQsIHVzaW5nIHRoZSBsb2NhbGUgYW5kIG9wdGlvbnMgcHJvdmlkZWQuXG4gICAgLy8gQnV0IGl0J3MgcG9zc2libGUgZm9yIGNhbGxlcnMgdG8gbXV0YXRlIHRob3NlIGlucHV0cyBiZWZvcmUgbGF6eSBjcmVhdGlvblxuICAgIC8vIGhhcHBlbnMuIEZvciB0aGlzIHJlYXNvbiwgd2UgY2xvbmUgdGhlIGlucHV0cyBpbnN0ZWFkIG9mIGNhY2hpbmcgdGhlXG4gICAgLy8gb3JpZ2luYWwgb2JqZWN0cy4gVG8gYXZvaWQgdGhlIGNvbXBsZXhpdHkgb2YgZGVlcCBjbG9uaW5nIGFueSBpbnB1dHMgdGhhdFxuICAgIC8vIGFyZSB0aGVtc2VsdmVzIG9iamVjdHMgKGUuZy4gdGhlIGxvY2FsZXMgYXJyYXksIG9yIG9wdGlvbnMgcHJvcGVydHkgdmFsdWVzXG4gICAgLy8gdGhhdCB3aWxsIGJlIGNvZXJjZWQgdG8gc3RyaW5ncyksIHdlIHJlbHkgb24gYHJlc29sdmVkT3B0aW9ucygpYCB0byBkbyB0aGVcbiAgICAvLyBjb2VyY2lvbiBhbmQgY2xvbmluZyBmb3IgdXMuIFVuZm9ydHVuYXRlbHksIHdlIGNhbid0IGp1c3QgdXNlIHRoZSByZXNvbHZlZFxuICAgIC8vIG9wdGlvbnMgYXMtaXMgYmVjYXVzZSBvdXIgb3B0aW9ucy1hbWVuZGluZyBsb2dpYyBhZGRzIGFkZGl0aW9uYWwgZmllbGRzIGlmXG4gICAgLy8gdGhlIHVzZXIgZG9lc24ndCBzdXBwbHkgYW55IHVuaXQgZmllbGRzIGxpa2UgeWVhciwgbW9udGgsIGRheSwgaG91ciwgZXRjLlxuICAgIC8vIFRoZXJlZm9yZSwgd2UgbGltaXQgdGhlIHByb3BlcnRpZXMgaW4gdGhlIGNsb25lIHRvIHByb3BlcnRpZXMgdGhhdCB3ZXJlXG4gICAgLy8gcHJlc2VudCBpbiB0aGUgb3JpZ2luYWwgaW5wdXQuXG4gICAgaWYgKGhhc09wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgY2xvbmVkUmVzb2x2ZWQgPSBPYmplY3RBc3NpZ24kMSh7fSwgcm8pO1xuICAgICAgICBmb3IgKGNvbnN0IHByb3AgaW4gY2xvbmVkUmVzb2x2ZWQpIHtcbiAgICAgICAgICAgIGlmICghUmVmbGVjdEFwcGx5KE9iamVjdEhhc093blByb3BlcnR5LCBvcHRpb25zLCBbcHJvcF0pKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGNsb25lZFJlc29sdmVkW3Byb3BdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXNbT1BUSU9OU10gPSBjbG9uZWRSZXNvbHZlZDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRoaXNbT1BUSU9OU10gPSBvcHRpb25zO1xuICAgIH1cbiAgICB0aGlzW1RaX0dJVkVOXSA9IG9wdGlvbnMudGltZVpvbmUgPyBvcHRpb25zLnRpbWVab25lIDogbnVsbDtcbiAgICB0aGlzW0xPQ0FMRV0gPSByby5sb2NhbGU7XG4gICAgdGhpc1tPUklHSU5BTF0gPSBvcmlnaW5hbDtcbiAgICB0aGlzW1RaX1JFU09MVkVEXSA9IHJvLnRpbWVab25lO1xuICAgIHRoaXNbQ0FMX0lEXSA9IHJvLmNhbGVuZGFyO1xuICAgIHRoaXNbREFURV0gPSBkYXRlQW1lbmQ7XG4gICAgdGhpc1tZTV0gPSB5ZWFyTW9udGhBbWVuZDtcbiAgICB0aGlzW01EXSA9IG1vbnRoRGF5QW1lbmQ7XG4gICAgdGhpc1tUSU1FXSA9IHRpbWVBbWVuZDtcbiAgICB0aGlzW0RBVEVUSU1FXSA9IGRhdGV0aW1lQW1lbmQ7XG4gICAgdGhpc1taT05FRF0gPSB6b25lZERhdGVUaW1lQW1lbmQ7XG4gICAgdGhpc1tJTlNUXSA9IGluc3RhbnRBbWVuZDtcbiAgICByZXR1cm4gdW5kZWZpbmVkOyAvLyBUT0RPOiBJIGNvdWxkbid0IHNhdGlzZnkgVFMgd2l0aG91dCBhZGRpbmcgdGhpcy4gSXMgdGhlcmUgYW5vdGhlciB3YXk/XG59XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRGF0ZVRpbWVGb3JtYXRJbXBsLCAnbmFtZScsIHtcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogJ0RhdGVUaW1lRm9ybWF0J1xufSk7XG5EYXRlVGltZUZvcm1hdEltcGwuc3VwcG9ydGVkTG9jYWxlc09mID0gZnVuY3Rpb24gKGxvY2FsZXMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gSW50bERhdGVUaW1lRm9ybWF0LnN1cHBvcnRlZExvY2FsZXNPZihsb2NhbGVzLCBvcHRpb25zKTtcbn07XG5jb25zdCBwcm9wZXJ0aWVzID0ge1xuICAgIHJlc29sdmVkT3B0aW9uczogZGVzY3JpcHRvcihyZXNvbHZlZE9wdGlvbnMpLFxuICAgIGZvcm1hdDogZGVzY3JpcHRvcihmb3JtYXQpLFxuICAgIGZvcm1hdFJhbmdlOiBkZXNjcmlwdG9yKGZvcm1hdFJhbmdlKVxufTtcbmlmICgnZm9ybWF0VG9QYXJ0cycgaW4gSW50bERhdGVUaW1lRm9ybWF0LnByb3RvdHlwZSkge1xuICAgIHByb3BlcnRpZXMuZm9ybWF0VG9QYXJ0cyA9IGRlc2NyaXB0b3IoZm9ybWF0VG9QYXJ0cyk7XG59XG5pZiAoJ2Zvcm1hdFJhbmdlVG9QYXJ0cycgaW4gSW50bERhdGVUaW1lRm9ybWF0LnByb3RvdHlwZSkge1xuICAgIHByb3BlcnRpZXMuZm9ybWF0UmFuZ2VUb1BhcnRzID0gZGVzY3JpcHRvcihmb3JtYXRSYW5nZVRvUGFydHMpO1xufVxuRGF0ZVRpbWVGb3JtYXRJbXBsLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoSW50bERhdGVUaW1lRm9ybWF0LnByb3RvdHlwZSwgcHJvcGVydGllcyk7XG4vLyBFbnN1cmUgdGhhdCB0aGUgcHJvdG90eXBlIGlzbid0IHdyaXRlYWJsZS5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShEYXRlVGltZUZvcm1hdEltcGwsICdwcm90b3R5cGUnLCB7XG4gICAgd3JpdGFibGU6IGZhbHNlLFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogZmFsc2Vcbn0pO1xuY29uc3QgRGF0ZVRpbWVGb3JtYXQgPSBEYXRlVGltZUZvcm1hdEltcGw7XG5mdW5jdGlvbiByZXNvbHZlZE9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXNbT1JJR0lOQUxdLnJlc29sdmVkT3B0aW9ucygpO1xufVxuZnVuY3Rpb24gYWRqdXN0Rm9ybWF0dGVyVGltZVpvbmUoZm9ybWF0dGVyLCB0aW1lWm9uZSkge1xuICAgIGlmICghdGltZVpvbmUpXG4gICAgICAgIHJldHVybiBmb3JtYXR0ZXI7XG4gICAgY29uc3Qgb3B0aW9ucyA9IGZvcm1hdHRlci5yZXNvbHZlZE9wdGlvbnMoKTtcbiAgICBpZiAob3B0aW9ucy50aW1lWm9uZSA9PT0gdGltZVpvbmUpXG4gICAgICAgIHJldHVybiBmb3JtYXR0ZXI7XG4gICAgLy8gRXhpc3RpbmcgSW50bCBpc24ndCB0eXBlZCB0byBhY2NlcHQgVGVtcG9yYWwtc3BlY2lmaWMgb3B0aW9ucywgYnV0IHdpbGwgbm90XG4gICAgLy8gYnJlYWsgYXQgcnVudGltZSBpZiB3ZSBwYXNzIHRoZW0uIEFsc28sIHRoZSBsaWIgdHlwZXMgZm9yIHJlc29sdmVkIG9wdGlvbnNcbiAgICAvLyBhcmUgbGVzcyByZXN0cmljdGl2ZSB0aGFuIHRoZSB0eXBlcyBmb3Igb3B0aW9ucy4gRm9yIGV4YW1wbGUsIGB3ZWVrZGF5YCBpc1xuICAgIC8vIGAnbG9uZycgfCAnc2hvcnQnIHwgJ25hcnJvdydgIGluIG9wdGlvbnMgYnV0IGBzdHJpbmdgIGluIHJlc29sdmVkIG9wdGlvbnMuXG4gICAgLy8gVE9ETzogaW52ZXN0aWdhdGUgd2h5LCBhbmQgZmlsZSBhbiBpc3N1ZSBhZ2FpbnN0IFRTIGlmIGl0J3MgYSBidWcuXG4gICAgcmV0dXJuIG5ldyBJbnRsRGF0ZVRpbWVGb3JtYXQob3B0aW9ucy5sb2NhbGUsIHsgLi4ub3B0aW9ucywgdGltZVpvbmUgfSk7XG59XG4vLyBUT0RPOiBpbnZlc3RpZ2F0ZSB3aHkgdGhlcmUncyBhIHJlc3QgcGFyYW1ldGVyIGhlcmUuIERvZXMgdGhpcyBmdW5jdGlvbiByZWFsbHkgbmVlZCB0byBhY2NlcHQgZXh0cmEgcGFyYW1zP1xuLy8gQW5kIGlmIHNvLCB3aHkgZG9lc24ndCBmb3JtYXRSYW5nZSBhbHNvIGFjY2VwdCBleHRyYSBwYXJhbXM/XG5mdW5jdGlvbiBmb3JtYXQoZGF0ZXRpbWUsIC4uLnJlc3QpIHtcbiAgICBsZXQgeyBpbnN0YW50LCBmb3JtYXR0ZXIsIHRpbWVab25lIH0gPSBleHRyYWN0T3ZlcnJpZGVzKGRhdGV0aW1lLCB0aGlzKTtcbiAgICBpZiAoaW5zdGFudCAmJiBmb3JtYXR0ZXIpIHtcbiAgICAgICAgZm9ybWF0dGVyID0gYWRqdXN0Rm9ybWF0dGVyVGltZVpvbmUoZm9ybWF0dGVyLCB0aW1lWm9uZSk7XG4gICAgICAgIHJldHVybiBmb3JtYXR0ZXIuZm9ybWF0KGluc3RhbnQuZXBvY2hNaWxsaXNlY29uZHMpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpc1tPUklHSU5BTF0uZm9ybWF0KGRhdGV0aW1lLCAuLi5yZXN0KTtcbn1cbmZ1bmN0aW9uIGZvcm1hdFRvUGFydHMoZGF0ZXRpbWUsIC4uLnJlc3QpIHtcbiAgICBsZXQgeyBpbnN0YW50LCBmb3JtYXR0ZXIsIHRpbWVab25lIH0gPSBleHRyYWN0T3ZlcnJpZGVzKGRhdGV0aW1lLCB0aGlzKTtcbiAgICBpZiAoaW5zdGFudCAmJiBmb3JtYXR0ZXIpIHtcbiAgICAgICAgZm9ybWF0dGVyID0gYWRqdXN0Rm9ybWF0dGVyVGltZVpvbmUoZm9ybWF0dGVyLCB0aW1lWm9uZSk7XG4gICAgICAgIHJldHVybiBmb3JtYXR0ZXIuZm9ybWF0VG9QYXJ0cyhpbnN0YW50LmVwb2NoTWlsbGlzZWNvbmRzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXNbT1JJR0lOQUxdLmZvcm1hdFRvUGFydHMoZGF0ZXRpbWUsIC4uLnJlc3QpO1xufVxuZnVuY3Rpb24gZm9ybWF0UmFuZ2UoYSwgYikge1xuICAgIGlmIChpc1RlbXBvcmFsT2JqZWN0KGEpIHx8IGlzVGVtcG9yYWxPYmplY3QoYikpIHtcbiAgICAgICAgaWYgKCFzYW1lVGVtcG9yYWxUeXBlKGEsIGIpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnRsLkRhdGVUaW1lRm9ybWF0LmZvcm1hdFJhbmdlIGFjY2VwdHMgdHdvIHZhbHVlcyBvZiB0aGUgc2FtZSB0eXBlJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBpbnN0YW50OiBhYSwgZm9ybWF0dGVyOiBhZm9ybWF0dGVyLCB0aW1lWm9uZTogYXR6IH0gPSBleHRyYWN0T3ZlcnJpZGVzKGEsIHRoaXMpO1xuICAgICAgICBjb25zdCB7IGluc3RhbnQ6IGJiLCBmb3JtYXR0ZXI6IGJmb3JtYXR0ZXIsIHRpbWVab25lOiBidHogfSA9IGV4dHJhY3RPdmVycmlkZXMoYiwgdGhpcyk7XG4gICAgICAgIGlmIChhdHogJiYgYnR6ICYmIGF0eiAhPT0gYnR6KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignY2Fubm90IGZvcm1hdCByYW5nZSBiZXR3ZWVuIGRpZmZlcmVudCB0aW1lIHpvbmVzJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFhICYmIGJiICYmIGFmb3JtYXR0ZXIgJiYgYmZvcm1hdHRlciAmJiBhZm9ybWF0dGVyID09PSBiZm9ybWF0dGVyKSB7XG4gICAgICAgICAgICBjb25zdCBmb3JtYXR0ZXIgPSBhZGp1c3RGb3JtYXR0ZXJUaW1lWm9uZShhZm9ybWF0dGVyLCBhdHopO1xuICAgICAgICAgICAgLy8gVE9ETzogUmVtb3ZlIHR5cGUgYXNzZXJ0aW9uIGFmdGVyIHRoaXMgbWV0aG9kIGxhbmRzIGluIFRTIGxpYiB0eXBlc1xuICAgICAgICAgICAgcmV0dXJuIGZvcm1hdHRlci5mb3JtYXRSYW5nZShhYS5lcG9jaE1pbGxpc2Vjb25kcywgYmIuZXBvY2hNaWxsaXNlY29uZHMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFRPRE86IFJlbW92ZSB0eXBlIGFzc2VydGlvbiBhZnRlciB0aGlzIG1ldGhvZCBsYW5kcyBpbiBUUyBsaWIgdHlwZXNcbiAgICByZXR1cm4gdGhpc1tPUklHSU5BTF0uZm9ybWF0UmFuZ2UoYSwgYik7XG59XG5mdW5jdGlvbiBmb3JtYXRSYW5nZVRvUGFydHMoYSwgYikge1xuICAgIGlmIChpc1RlbXBvcmFsT2JqZWN0KGEpIHx8IGlzVGVtcG9yYWxPYmplY3QoYikpIHtcbiAgICAgICAgaWYgKCFzYW1lVGVtcG9yYWxUeXBlKGEsIGIpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnRsLkRhdGVUaW1lRm9ybWF0LmZvcm1hdFJhbmdlVG9QYXJ0cyBhY2NlcHRzIHR3byB2YWx1ZXMgb2YgdGhlIHNhbWUgdHlwZScpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgaW5zdGFudDogYWEsIGZvcm1hdHRlcjogYWZvcm1hdHRlciwgdGltZVpvbmU6IGF0eiB9ID0gZXh0cmFjdE92ZXJyaWRlcyhhLCB0aGlzKTtcbiAgICAgICAgY29uc3QgeyBpbnN0YW50OiBiYiwgZm9ybWF0dGVyOiBiZm9ybWF0dGVyLCB0aW1lWm9uZTogYnR6IH0gPSBleHRyYWN0T3ZlcnJpZGVzKGIsIHRoaXMpO1xuICAgICAgICBpZiAoYXR6ICYmIGJ0eiAmJiBhdHogIT09IGJ0eikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2Nhbm5vdCBmb3JtYXQgcmFuZ2UgYmV0d2VlbiBkaWZmZXJlbnQgdGltZSB6b25lcycpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhYSAmJiBiYiAmJiBhZm9ybWF0dGVyICYmIGJmb3JtYXR0ZXIgJiYgYWZvcm1hdHRlciA9PT0gYmZvcm1hdHRlcikge1xuICAgICAgICAgICAgY29uc3QgZm9ybWF0dGVyID0gYWRqdXN0Rm9ybWF0dGVyVGltZVpvbmUoYWZvcm1hdHRlciwgYXR6KTtcbiAgICAgICAgICAgIC8vIFRPRE86IFJlbW92ZSB0eXBlIGFzc2VydGlvbiBhZnRlciB0aGlzIG1ldGhvZCBsYW5kcyBpbiBUUyBsaWIgdHlwZXNcbiAgICAgICAgICAgIHJldHVybiBmb3JtYXR0ZXIuZm9ybWF0UmFuZ2VUb1BhcnRzKGFhLmVwb2NoTWlsbGlzZWNvbmRzLCBiYi5lcG9jaE1pbGxpc2Vjb25kcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gVE9ETzogUmVtb3ZlIHR5cGUgYXNzZXJ0aW9uIGFmdGVyIHRoaXMgbWV0aG9kIGxhbmRzIGluIFRTIGxpYiB0eXBlc1xuICAgIHJldHVybiB0aGlzW09SSUdJTkFMXS5mb3JtYXRSYW5nZVRvUGFydHMoYSwgYik7XG59XG5mdW5jdGlvbiBhbWVuZChvcHRpb25zUGFyYW0gPSB7fSwgYW1lbmRlZCA9IHt9KSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IE9iamVjdEFzc2lnbiQxKHt9LCBvcHRpb25zUGFyYW0pO1xuICAgIGZvciAoY29uc3Qgb3B0IG9mIFtcbiAgICAgICAgJ3llYXInLFxuICAgICAgICAnbW9udGgnLFxuICAgICAgICAnZGF5JyxcbiAgICAgICAgJ2hvdXInLFxuICAgICAgICAnbWludXRlJyxcbiAgICAgICAgJ3NlY29uZCcsXG4gICAgICAgICd3ZWVrZGF5JyxcbiAgICAgICAgJ2RheVBlcmlvZCcsXG4gICAgICAgICd0aW1lWm9uZU5hbWUnLFxuICAgICAgICAnZGF0ZVN0eWxlJyxcbiAgICAgICAgJ3RpbWVTdHlsZSdcbiAgICBdKSB7XG4gICAgICAgIG9wdGlvbnNbb3B0XSA9IG9wdCBpbiBhbWVuZGVkID8gYW1lbmRlZFtvcHRdIDogb3B0aW9uc1tvcHRdO1xuICAgICAgICBpZiAob3B0aW9uc1tvcHRdID09PSBmYWxzZSB8fCBvcHRpb25zW29wdF0gPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIGRlbGV0ZSBvcHRpb25zW29wdF07XG4gICAgfVxuICAgIHJldHVybiBvcHRpb25zO1xufVxuZnVuY3Rpb24gdGltZUFtZW5kKG9wdGlvbnNQYXJhbSkge1xuICAgIGxldCBvcHRpb25zID0gYW1lbmQob3B0aW9uc1BhcmFtLCB7XG4gICAgICAgIHllYXI6IGZhbHNlLFxuICAgICAgICBtb250aDogZmFsc2UsXG4gICAgICAgIGRheTogZmFsc2UsXG4gICAgICAgIHdlZWtkYXk6IGZhbHNlLFxuICAgICAgICB0aW1lWm9uZU5hbWU6IGZhbHNlLFxuICAgICAgICBkYXRlU3R5bGU6IGZhbHNlXG4gICAgfSk7XG4gICAgaWYgKCFoYXNUaW1lT3B0aW9ucyhvcHRpb25zKSkge1xuICAgICAgICBvcHRpb25zID0gT2JqZWN0QXNzaWduJDEoe30sIG9wdGlvbnMsIHtcbiAgICAgICAgICAgIGhvdXI6ICdudW1lcmljJyxcbiAgICAgICAgICAgIG1pbnV0ZTogJ251bWVyaWMnLFxuICAgICAgICAgICAgc2Vjb25kOiAnbnVtZXJpYydcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBvcHRpb25zO1xufVxuZnVuY3Rpb24geWVhck1vbnRoQW1lbmQob3B0aW9uc1BhcmFtKSB7XG4gICAgbGV0IG9wdGlvbnMgPSBhbWVuZChvcHRpb25zUGFyYW0sIHtcbiAgICAgICAgZGF5OiBmYWxzZSxcbiAgICAgICAgaG91cjogZmFsc2UsXG4gICAgICAgIG1pbnV0ZTogZmFsc2UsXG4gICAgICAgIHNlY29uZDogZmFsc2UsXG4gICAgICAgIHdlZWtkYXk6IGZhbHNlLFxuICAgICAgICBkYXlQZXJpb2Q6IGZhbHNlLFxuICAgICAgICB0aW1lWm9uZU5hbWU6IGZhbHNlLFxuICAgICAgICBkYXRlU3R5bGU6IGZhbHNlLFxuICAgICAgICB0aW1lU3R5bGU6IGZhbHNlXG4gICAgfSk7XG4gICAgaWYgKCEoJ3llYXInIGluIG9wdGlvbnMgfHwgJ21vbnRoJyBpbiBvcHRpb25zKSkge1xuICAgICAgICBvcHRpb25zID0gT2JqZWN0QXNzaWduJDEob3B0aW9ucywgeyB5ZWFyOiAnbnVtZXJpYycsIG1vbnRoOiAnbnVtZXJpYycgfSk7XG4gICAgfVxuICAgIHJldHVybiBvcHRpb25zO1xufVxuZnVuY3Rpb24gbW9udGhEYXlBbWVuZChvcHRpb25zUGFyYW0pIHtcbiAgICBsZXQgb3B0aW9ucyA9IGFtZW5kKG9wdGlvbnNQYXJhbSwge1xuICAgICAgICB5ZWFyOiBmYWxzZSxcbiAgICAgICAgaG91cjogZmFsc2UsXG4gICAgICAgIG1pbnV0ZTogZmFsc2UsXG4gICAgICAgIHNlY29uZDogZmFsc2UsXG4gICAgICAgIHdlZWtkYXk6IGZhbHNlLFxuICAgICAgICBkYXlQZXJpb2Q6IGZhbHNlLFxuICAgICAgICB0aW1lWm9uZU5hbWU6IGZhbHNlLFxuICAgICAgICBkYXRlU3R5bGU6IGZhbHNlLFxuICAgICAgICB0aW1lU3R5bGU6IGZhbHNlXG4gICAgfSk7XG4gICAgaWYgKCEoJ21vbnRoJyBpbiBvcHRpb25zIHx8ICdkYXknIGluIG9wdGlvbnMpKSB7XG4gICAgICAgIG9wdGlvbnMgPSBPYmplY3RBc3NpZ24kMSh7fSwgb3B0aW9ucywgeyBtb250aDogJ251bWVyaWMnLCBkYXk6ICdudW1lcmljJyB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG9wdGlvbnM7XG59XG5mdW5jdGlvbiBkYXRlQW1lbmQob3B0aW9uc1BhcmFtKSB7XG4gICAgbGV0IG9wdGlvbnMgPSBhbWVuZChvcHRpb25zUGFyYW0sIHtcbiAgICAgICAgaG91cjogZmFsc2UsXG4gICAgICAgIG1pbnV0ZTogZmFsc2UsXG4gICAgICAgIHNlY29uZDogZmFsc2UsXG4gICAgICAgIGRheVBlcmlvZDogZmFsc2UsXG4gICAgICAgIHRpbWVab25lTmFtZTogZmFsc2UsXG4gICAgICAgIHRpbWVTdHlsZTogZmFsc2VcbiAgICB9KTtcbiAgICBpZiAoIWhhc0RhdGVPcHRpb25zKG9wdGlvbnMpKSB7XG4gICAgICAgIG9wdGlvbnMgPSBPYmplY3RBc3NpZ24kMSh7fSwgb3B0aW9ucywge1xuICAgICAgICAgICAgeWVhcjogJ251bWVyaWMnLFxuICAgICAgICAgICAgbW9udGg6ICdudW1lcmljJyxcbiAgICAgICAgICAgIGRheTogJ251bWVyaWMnXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gb3B0aW9ucztcbn1cbmZ1bmN0aW9uIGRhdGV0aW1lQW1lbmQob3B0aW9uc1BhcmFtKSB7XG4gICAgbGV0IG9wdGlvbnMgPSBhbWVuZChvcHRpb25zUGFyYW0sIHsgdGltZVpvbmVOYW1lOiBmYWxzZSB9KTtcbiAgICBpZiAoIWhhc1RpbWVPcHRpb25zKG9wdGlvbnMpICYmICFoYXNEYXRlT3B0aW9ucyhvcHRpb25zKSkge1xuICAgICAgICBvcHRpb25zID0gT2JqZWN0QXNzaWduJDEoe30sIG9wdGlvbnMsIHtcbiAgICAgICAgICAgIHllYXI6ICdudW1lcmljJyxcbiAgICAgICAgICAgIG1vbnRoOiAnbnVtZXJpYycsXG4gICAgICAgICAgICBkYXk6ICdudW1lcmljJyxcbiAgICAgICAgICAgIGhvdXI6ICdudW1lcmljJyxcbiAgICAgICAgICAgIG1pbnV0ZTogJ251bWVyaWMnLFxuICAgICAgICAgICAgc2Vjb25kOiAnbnVtZXJpYydcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBvcHRpb25zO1xufVxuZnVuY3Rpb24gem9uZWREYXRlVGltZUFtZW5kKG9wdGlvbnNQYXJhbSkge1xuICAgIGxldCBvcHRpb25zID0gb3B0aW9uc1BhcmFtO1xuICAgIGlmICghaGFzVGltZU9wdGlvbnMob3B0aW9ucykgJiYgIWhhc0RhdGVPcHRpb25zKG9wdGlvbnMpKSB7XG4gICAgICAgIG9wdGlvbnMgPSBPYmplY3RBc3NpZ24kMSh7fSwgb3B0aW9ucywge1xuICAgICAgICAgICAgeWVhcjogJ251bWVyaWMnLFxuICAgICAgICAgICAgbW9udGg6ICdudW1lcmljJyxcbiAgICAgICAgICAgIGRheTogJ251bWVyaWMnLFxuICAgICAgICAgICAgaG91cjogJ251bWVyaWMnLFxuICAgICAgICAgICAgbWludXRlOiAnbnVtZXJpYycsXG4gICAgICAgICAgICBzZWNvbmQ6ICdudW1lcmljJ1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKG9wdGlvbnMudGltZVpvbmVOYW1lID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICBvcHRpb25zLnRpbWVab25lTmFtZSA9ICdzaG9ydCc7XG4gICAgfVxuICAgIHJldHVybiBvcHRpb25zO1xufVxuZnVuY3Rpb24gaW5zdGFudEFtZW5kKG9wdGlvbnNQYXJhbSkge1xuICAgIGxldCBvcHRpb25zID0gb3B0aW9uc1BhcmFtO1xuICAgIGlmICghaGFzVGltZU9wdGlvbnMob3B0aW9ucykgJiYgIWhhc0RhdGVPcHRpb25zKG9wdGlvbnMpKSB7XG4gICAgICAgIG9wdGlvbnMgPSBPYmplY3RBc3NpZ24kMSh7fSwgb3B0aW9ucywge1xuICAgICAgICAgICAgeWVhcjogJ251bWVyaWMnLFxuICAgICAgICAgICAgbW9udGg6ICdudW1lcmljJyxcbiAgICAgICAgICAgIGRheTogJ251bWVyaWMnLFxuICAgICAgICAgICAgaG91cjogJ251bWVyaWMnLFxuICAgICAgICAgICAgbWludXRlOiAnbnVtZXJpYycsXG4gICAgICAgICAgICBzZWNvbmQ6ICdudW1lcmljJ1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG9wdGlvbnM7XG59XG5mdW5jdGlvbiBoYXNEYXRlT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgcmV0dXJuICd5ZWFyJyBpbiBvcHRpb25zIHx8ICdtb250aCcgaW4gb3B0aW9ucyB8fCAnZGF5JyBpbiBvcHRpb25zIHx8ICd3ZWVrZGF5JyBpbiBvcHRpb25zIHx8ICdkYXRlU3R5bGUnIGluIG9wdGlvbnM7XG59XG5mdW5jdGlvbiBoYXNUaW1lT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgcmV0dXJuICgnaG91cicgaW4gb3B0aW9ucyB8fCAnbWludXRlJyBpbiBvcHRpb25zIHx8ICdzZWNvbmQnIGluIG9wdGlvbnMgfHwgJ3RpbWVTdHlsZScgaW4gb3B0aW9ucyB8fCAnZGF5UGVyaW9kJyBpbiBvcHRpb25zKTtcbn1cbmZ1bmN0aW9uIGlzVGVtcG9yYWxPYmplY3Qob2JqKSB7XG4gICAgcmV0dXJuIChJc1RlbXBvcmFsRGF0ZShvYmopIHx8XG4gICAgICAgIElzVGVtcG9yYWxUaW1lKG9iaikgfHxcbiAgICAgICAgSXNUZW1wb3JhbERhdGVUaW1lKG9iaikgfHxcbiAgICAgICAgSXNUZW1wb3JhbFpvbmVkRGF0ZVRpbWUob2JqKSB8fFxuICAgICAgICBJc1RlbXBvcmFsWWVhck1vbnRoKG9iaikgfHxcbiAgICAgICAgSXNUZW1wb3JhbE1vbnRoRGF5KG9iaikgfHxcbiAgICAgICAgSXNUZW1wb3JhbEluc3RhbnQob2JqKSk7XG59XG5mdW5jdGlvbiBzYW1lVGVtcG9yYWxUeXBlKHgsIHkpIHtcbiAgICBpZiAoIWlzVGVtcG9yYWxPYmplY3QoeCkgfHwgIWlzVGVtcG9yYWxPYmplY3QoeSkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoSXNUZW1wb3JhbFRpbWUoeCkgJiYgIUlzVGVtcG9yYWxUaW1lKHkpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKElzVGVtcG9yYWxEYXRlKHgpICYmICFJc1RlbXBvcmFsRGF0ZSh5KSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChJc1RlbXBvcmFsRGF0ZVRpbWUoeCkgJiYgIUlzVGVtcG9yYWxEYXRlVGltZSh5KSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChJc1RlbXBvcmFsWm9uZWREYXRlVGltZSh4KSAmJiAhSXNUZW1wb3JhbFpvbmVkRGF0ZVRpbWUoeSkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoSXNUZW1wb3JhbFllYXJNb250aCh4KSAmJiAhSXNUZW1wb3JhbFllYXJNb250aCh5KSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChJc1RlbXBvcmFsTW9udGhEYXkoeCkgJiYgIUlzVGVtcG9yYWxNb250aERheSh5KSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChJc1RlbXBvcmFsSW5zdGFudCh4KSAmJiAhSXNUZW1wb3JhbEluc3RhbnQoeSkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGV4dHJhY3RPdmVycmlkZXModGVtcG9yYWxPYmosIG1haW4pIHtcbiAgICBjb25zdCBEYXRlVGltZSA9IEdldEludHJpbnNpYygnJVRlbXBvcmFsLlBsYWluRGF0ZVRpbWUlJyk7XG4gICAgaWYgKElzVGVtcG9yYWxUaW1lKHRlbXBvcmFsT2JqKSkge1xuICAgICAgICBjb25zdCBob3VyID0gR2V0U2xvdCh0ZW1wb3JhbE9iaiwgSVNPX0hPVVIpO1xuICAgICAgICBjb25zdCBtaW51dGUgPSBHZXRTbG90KHRlbXBvcmFsT2JqLCBJU09fTUlOVVRFKTtcbiAgICAgICAgY29uc3Qgc2Vjb25kID0gR2V0U2xvdCh0ZW1wb3JhbE9iaiwgSVNPX1NFQ09ORCk7XG4gICAgICAgIGNvbnN0IG1pbGxpc2Vjb25kID0gR2V0U2xvdCh0ZW1wb3JhbE9iaiwgSVNPX01JTExJU0VDT05EKTtcbiAgICAgICAgY29uc3QgbWljcm9zZWNvbmQgPSBHZXRTbG90KHRlbXBvcmFsT2JqLCBJU09fTUlDUk9TRUNPTkQpO1xuICAgICAgICBjb25zdCBuYW5vc2Vjb25kID0gR2V0U2xvdCh0ZW1wb3JhbE9iaiwgSVNPX05BTk9TRUNPTkQpO1xuICAgICAgICBjb25zdCBkYXRldGltZSA9IG5ldyBEYXRlVGltZSgxOTcwLCAxLCAxLCBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQsIG1pY3Jvc2Vjb25kLCBuYW5vc2Vjb25kLCBtYWluW0NBTF9JRF0pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaW5zdGFudDogQnVpbHRpblRpbWVab25lR2V0SW5zdGFudEZvcihnZXRSZXNvbHZlZFRpbWVab25lTGF6eShtYWluKSwgZGF0ZXRpbWUsICdjb21wYXRpYmxlJyksXG4gICAgICAgICAgICBmb3JtYXR0ZXI6IGdldFByb3BMYXp5KG1haW4sIFRJTUUpXG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmIChJc1RlbXBvcmFsWWVhck1vbnRoKHRlbXBvcmFsT2JqKSkge1xuICAgICAgICBjb25zdCBpc29ZZWFyID0gR2V0U2xvdCh0ZW1wb3JhbE9iaiwgSVNPX1lFQVIpO1xuICAgICAgICBjb25zdCBpc29Nb250aCA9IEdldFNsb3QodGVtcG9yYWxPYmosIElTT19NT05USCk7XG4gICAgICAgIGNvbnN0IHJlZmVyZW5jZUlTT0RheSA9IEdldFNsb3QodGVtcG9yYWxPYmosIElTT19EQVkpO1xuICAgICAgICBjb25zdCBjYWxlbmRhciA9IFRvU3RyaW5nKEdldFNsb3QodGVtcG9yYWxPYmosIENBTEVOREFSKSk7XG4gICAgICAgIGlmIChjYWxlbmRhciAhPT0gbWFpbltDQUxfSURdKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgY2Fubm90IGZvcm1hdCBQbGFpblllYXJNb250aCB3aXRoIGNhbGVuZGFyICR7Y2FsZW5kYXJ9IGluIGxvY2FsZSB3aXRoIGNhbGVuZGFyICR7bWFpbltDQUxfSURdfWApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRhdGV0aW1lID0gbmV3IERhdGVUaW1lKGlzb1llYXIsIGlzb01vbnRoLCByZWZlcmVuY2VJU09EYXksIDEyLCAwLCAwLCAwLCAwLCAwLCBjYWxlbmRhcik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpbnN0YW50OiBCdWlsdGluVGltZVpvbmVHZXRJbnN0YW50Rm9yKGdldFJlc29sdmVkVGltZVpvbmVMYXp5KG1haW4pLCBkYXRldGltZSwgJ2NvbXBhdGlibGUnKSxcbiAgICAgICAgICAgIGZvcm1hdHRlcjogZ2V0UHJvcExhenkobWFpbiwgWU0pXG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmIChJc1RlbXBvcmFsTW9udGhEYXkodGVtcG9yYWxPYmopKSB7XG4gICAgICAgIGNvbnN0IHJlZmVyZW5jZUlTT1llYXIgPSBHZXRTbG90KHRlbXBvcmFsT2JqLCBJU09fWUVBUik7XG4gICAgICAgIGNvbnN0IGlzb01vbnRoID0gR2V0U2xvdCh0ZW1wb3JhbE9iaiwgSVNPX01PTlRIKTtcbiAgICAgICAgY29uc3QgaXNvRGF5ID0gR2V0U2xvdCh0ZW1wb3JhbE9iaiwgSVNPX0RBWSk7XG4gICAgICAgIGNvbnN0IGNhbGVuZGFyID0gVG9TdHJpbmcoR2V0U2xvdCh0ZW1wb3JhbE9iaiwgQ0FMRU5EQVIpKTtcbiAgICAgICAgaWYgKGNhbGVuZGFyICE9PSBtYWluW0NBTF9JRF0pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBjYW5ub3QgZm9ybWF0IFBsYWluTW9udGhEYXkgd2l0aCBjYWxlbmRhciAke2NhbGVuZGFyfSBpbiBsb2NhbGUgd2l0aCBjYWxlbmRhciAke21haW5bQ0FMX0lEXX1gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkYXRldGltZSA9IG5ldyBEYXRlVGltZShyZWZlcmVuY2VJU09ZZWFyLCBpc29Nb250aCwgaXNvRGF5LCAxMiwgMCwgMCwgMCwgMCwgMCwgY2FsZW5kYXIpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaW5zdGFudDogQnVpbHRpblRpbWVab25lR2V0SW5zdGFudEZvcihnZXRSZXNvbHZlZFRpbWVab25lTGF6eShtYWluKSwgZGF0ZXRpbWUsICdjb21wYXRpYmxlJyksXG4gICAgICAgICAgICBmb3JtYXR0ZXI6IGdldFByb3BMYXp5KG1haW4sIE1EKVxuICAgICAgICB9O1xuICAgIH1cbiAgICBpZiAoSXNUZW1wb3JhbERhdGUodGVtcG9yYWxPYmopKSB7XG4gICAgICAgIGNvbnN0IGlzb1llYXIgPSBHZXRTbG90KHRlbXBvcmFsT2JqLCBJU09fWUVBUik7XG4gICAgICAgIGNvbnN0IGlzb01vbnRoID0gR2V0U2xvdCh0ZW1wb3JhbE9iaiwgSVNPX01PTlRIKTtcbiAgICAgICAgY29uc3QgaXNvRGF5ID0gR2V0U2xvdCh0ZW1wb3JhbE9iaiwgSVNPX0RBWSk7XG4gICAgICAgIGNvbnN0IGNhbGVuZGFyID0gVG9TdHJpbmcoR2V0U2xvdCh0ZW1wb3JhbE9iaiwgQ0FMRU5EQVIpKTtcbiAgICAgICAgaWYgKGNhbGVuZGFyICE9PSAnaXNvODYwMScgJiYgY2FsZW5kYXIgIT09IG1haW5bQ0FMX0lEXSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYGNhbm5vdCBmb3JtYXQgUGxhaW5EYXRlIHdpdGggY2FsZW5kYXIgJHtjYWxlbmRhcn0gaW4gbG9jYWxlIHdpdGggY2FsZW5kYXIgJHttYWluW0NBTF9JRF19YCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGF0ZXRpbWUgPSBuZXcgRGF0ZVRpbWUoaXNvWWVhciwgaXNvTW9udGgsIGlzb0RheSwgMTIsIDAsIDAsIDAsIDAsIDAsIG1haW5bQ0FMX0lEXSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpbnN0YW50OiBCdWlsdGluVGltZVpvbmVHZXRJbnN0YW50Rm9yKGdldFJlc29sdmVkVGltZVpvbmVMYXp5KG1haW4pLCBkYXRldGltZSwgJ2NvbXBhdGlibGUnKSxcbiAgICAgICAgICAgIGZvcm1hdHRlcjogZ2V0UHJvcExhenkobWFpbiwgREFURSlcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKElzVGVtcG9yYWxEYXRlVGltZSh0ZW1wb3JhbE9iaikpIHtcbiAgICAgICAgY29uc3QgaXNvWWVhciA9IEdldFNsb3QodGVtcG9yYWxPYmosIElTT19ZRUFSKTtcbiAgICAgICAgY29uc3QgaXNvTW9udGggPSBHZXRTbG90KHRlbXBvcmFsT2JqLCBJU09fTU9OVEgpO1xuICAgICAgICBjb25zdCBpc29EYXkgPSBHZXRTbG90KHRlbXBvcmFsT2JqLCBJU09fREFZKTtcbiAgICAgICAgY29uc3QgaG91ciA9IEdldFNsb3QodGVtcG9yYWxPYmosIElTT19IT1VSKTtcbiAgICAgICAgY29uc3QgbWludXRlID0gR2V0U2xvdCh0ZW1wb3JhbE9iaiwgSVNPX01JTlVURSk7XG4gICAgICAgIGNvbnN0IHNlY29uZCA9IEdldFNsb3QodGVtcG9yYWxPYmosIElTT19TRUNPTkQpO1xuICAgICAgICBjb25zdCBtaWxsaXNlY29uZCA9IEdldFNsb3QodGVtcG9yYWxPYmosIElTT19NSUxMSVNFQ09ORCk7XG4gICAgICAgIGNvbnN0IG1pY3Jvc2Vjb25kID0gR2V0U2xvdCh0ZW1wb3JhbE9iaiwgSVNPX01JQ1JPU0VDT05EKTtcbiAgICAgICAgY29uc3QgbmFub3NlY29uZCA9IEdldFNsb3QodGVtcG9yYWxPYmosIElTT19OQU5PU0VDT05EKTtcbiAgICAgICAgY29uc3QgY2FsZW5kYXIgPSBUb1N0cmluZyhHZXRTbG90KHRlbXBvcmFsT2JqLCBDQUxFTkRBUikpO1xuICAgICAgICBpZiAoY2FsZW5kYXIgIT09ICdpc284NjAxJyAmJiBjYWxlbmRhciAhPT0gbWFpbltDQUxfSURdKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgY2Fubm90IGZvcm1hdCBQbGFpbkRhdGVUaW1lIHdpdGggY2FsZW5kYXIgJHtjYWxlbmRhcn0gaW4gbG9jYWxlIHdpdGggY2FsZW5kYXIgJHttYWluW0NBTF9JRF19YCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGRhdGV0aW1lID0gdGVtcG9yYWxPYmo7XG4gICAgICAgIGlmIChjYWxlbmRhciA9PT0gJ2lzbzg2MDEnKSB7XG4gICAgICAgICAgICBkYXRldGltZSA9IG5ldyBEYXRlVGltZShpc29ZZWFyLCBpc29Nb250aCwgaXNvRGF5LCBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQsIG1pY3Jvc2Vjb25kLCBuYW5vc2Vjb25kLCBtYWluW0NBTF9JRF0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpbnN0YW50OiBCdWlsdGluVGltZVpvbmVHZXRJbnN0YW50Rm9yKGdldFJlc29sdmVkVGltZVpvbmVMYXp5KG1haW4pLCBkYXRldGltZSwgJ2NvbXBhdGlibGUnKSxcbiAgICAgICAgICAgIGZvcm1hdHRlcjogZ2V0UHJvcExhenkobWFpbiwgREFURVRJTUUpXG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmIChJc1RlbXBvcmFsWm9uZWREYXRlVGltZSh0ZW1wb3JhbE9iaikpIHtcbiAgICAgICAgY29uc3QgY2FsZW5kYXIgPSBUb1N0cmluZyhHZXRTbG90KHRlbXBvcmFsT2JqLCBDQUxFTkRBUikpO1xuICAgICAgICBpZiAoY2FsZW5kYXIgIT09ICdpc284NjAxJyAmJiBjYWxlbmRhciAhPT0gbWFpbltDQUxfSURdKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgY2Fubm90IGZvcm1hdCBab25lZERhdGVUaW1lIHdpdGggY2FsZW5kYXIgJHtjYWxlbmRhcn0gaW4gbG9jYWxlIHdpdGggY2FsZW5kYXIgJHttYWluW0NBTF9JRF19YCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGltZVpvbmUgPSBHZXRTbG90KHRlbXBvcmFsT2JqLCBUSU1FX1pPTkUpO1xuICAgICAgICBjb25zdCBvYmpUaW1lWm9uZSA9IFRvU3RyaW5nKHRpbWVab25lKTtcbiAgICAgICAgaWYgKG1haW5bVFpfR0lWRU5dICYmIG1haW5bVFpfR0lWRU5dICE9PSBvYmpUaW1lWm9uZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYHRpbWVab25lIG9wdGlvbiAke21haW5bVFpfR0lWRU5dfSBkb2Vzbid0IG1hdGNoIGFjdHVhbCB0aW1lIHpvbmUgJHtvYmpUaW1lWm9uZX1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaW5zdGFudDogR2V0U2xvdCh0ZW1wb3JhbE9iaiwgSU5TVEFOVCksXG4gICAgICAgICAgICBmb3JtYXR0ZXI6IGdldFByb3BMYXp5KG1haW4sIFpPTkVEKSxcbiAgICAgICAgICAgIHRpbWVab25lOiBvYmpUaW1lWm9uZVxuICAgICAgICB9O1xuICAgIH1cbiAgICBpZiAoSXNUZW1wb3JhbEluc3RhbnQodGVtcG9yYWxPYmopKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpbnN0YW50OiB0ZW1wb3JhbE9iaixcbiAgICAgICAgICAgIGZvcm1hdHRlcjogZ2V0UHJvcExhenkobWFpbiwgSU5TVClcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHt9O1xufVxuXG52YXIgaW50bCA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgRGF0ZVRpbWVGb3JtYXQ6IERhdGVUaW1lRm9ybWF0XG59KTtcblxuY29uc3QgRElTQUxMT1dFRF9VTklUUyQzID0gWyd5ZWFyJywgJ21vbnRoJywgJ3dlZWsnLCAnZGF5J107XG5jb25zdCBNQVhfRElGRkVSRU5DRV9JTkNSRU1FTlRTID0ge1xuICAgIGhvdXI6IDI0LFxuICAgIG1pbnV0ZTogNjAsXG4gICAgc2Vjb25kOiA2MCxcbiAgICBtaWxsaXNlY29uZDogMTAwMCxcbiAgICBtaWNyb3NlY29uZDogMTAwMCxcbiAgICBuYW5vc2Vjb25kOiAxMDAwXG59O1xuY2xhc3MgSW5zdGFudCB7XG4gICAgY29uc3RydWN0b3IoZXBvY2hOYW5vc2Vjb25kcykge1xuICAgICAgICAvLyBOb3RlOiBpZiB0aGUgYXJndW1lbnQgaXMgbm90IHBhc3NlZCwgVG9CaWdJbnQodW5kZWZpbmVkKSB3aWxsIHRocm93LiBUaGlzIGNoZWNrIGV4aXN0cyBvbmx5XG4gICAgICAgIC8vICAgICAgIHRvIGltcHJvdmUgdGhlIGVycm9yIG1lc3NhZ2UuXG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbWlzc2luZyBhcmd1bWVudDogZXBvY2hOYW5vc2Vjb25kcyBpcyByZXF1aXJlZCcpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5zID0gVG9CaWdJbnQoZXBvY2hOYW5vc2Vjb25kcyk7XG4gICAgICAgIFZhbGlkYXRlRXBvY2hOYW5vc2Vjb25kcyhucyk7XG4gICAgICAgIENyZWF0ZVNsb3RzKHRoaXMpO1xuICAgICAgICBTZXRTbG90KHRoaXMsIEVQT0NITkFOT1NFQ09ORFMsIG5zKTtcbiAgICAgICAge1xuICAgICAgICAgICAgY29uc3QgcmVwciA9IFRlbXBvcmFsSW5zdGFudFRvU3RyaW5nKHRoaXMsIHVuZGVmaW5lZCwgJ2F1dG8nKTtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnX3JlcHJfJywge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBgJHt0aGlzW1N5bWJvbC50b1N0cmluZ1RhZ119IDwke3JlcHJ9PmAsXG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBlcG9jaFNlY29uZHMoKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbEluc3RhbnQodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gR2V0U2xvdCh0aGlzLCBFUE9DSE5BTk9TRUNPTkRTKTtcbiAgICAgICAgcmV0dXJuIEpTQkkudG9OdW1iZXIoSlNCSS5kaXZpZGUodmFsdWUsIEJJTExJT04pKTtcbiAgICB9XG4gICAgZ2V0IGVwb2NoTWlsbGlzZWNvbmRzKCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxJbnN0YW50KHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IEpTQkkuQmlnSW50KEdldFNsb3QodGhpcywgRVBPQ0hOQU5PU0VDT05EUykpO1xuICAgICAgICByZXR1cm4gSlNCSS50b051bWJlcihKU0JJLmRpdmlkZSh2YWx1ZSwgTUlMTElPTikpO1xuICAgIH1cbiAgICBnZXQgZXBvY2hNaWNyb3NlY29uZHMoKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbEluc3RhbnQodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gSlNCSS5CaWdJbnQoR2V0U2xvdCh0aGlzLCBFUE9DSE5BTk9TRUNPTkRTKSk7XG4gICAgICAgIHJldHVybiBUb0JpZ0ludEV4dGVybmFsKEpTQkkuZGl2aWRlKHZhbHVlLCBUSE9VU0FORCkpO1xuICAgIH1cbiAgICBnZXQgZXBvY2hOYW5vc2Vjb25kcygpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsSW5zdGFudCh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgcmV0dXJuIFRvQmlnSW50RXh0ZXJuYWwoSlNCSS5CaWdJbnQoR2V0U2xvdCh0aGlzLCBFUE9DSE5BTk9TRUNPTkRTKSkpO1xuICAgIH1cbiAgICBhZGQodGVtcG9yYWxEdXJhdGlvbkxpa2UpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsSW5zdGFudCh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgY29uc3QgeyBob3VycywgbWludXRlcywgc2Vjb25kcywgbWlsbGlzZWNvbmRzLCBtaWNyb3NlY29uZHMsIG5hbm9zZWNvbmRzIH0gPSBUb0xpbWl0ZWRUZW1wb3JhbER1cmF0aW9uKHRlbXBvcmFsRHVyYXRpb25MaWtlLCBbJ3llYXJzJywgJ21vbnRocycsICd3ZWVrcycsICdkYXlzJ10pO1xuICAgICAgICBjb25zdCBucyA9IEFkZEluc3RhbnQoR2V0U2xvdCh0aGlzLCBFUE9DSE5BTk9TRUNPTkRTKSwgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc2Vjb25kcywgbWljcm9zZWNvbmRzLCBuYW5vc2Vjb25kcyk7XG4gICAgICAgIHJldHVybiBuZXcgSW5zdGFudChucyk7XG4gICAgfVxuICAgIHN1YnRyYWN0KHRlbXBvcmFsRHVyYXRpb25MaWtlKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbEluc3RhbnQodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIGNvbnN0IHsgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc2Vjb25kcywgbWljcm9zZWNvbmRzLCBuYW5vc2Vjb25kcyB9ID0gVG9MaW1pdGVkVGVtcG9yYWxEdXJhdGlvbih0ZW1wb3JhbER1cmF0aW9uTGlrZSwgWyd5ZWFycycsICdtb250aHMnLCAnd2Vla3MnLCAnZGF5cyddKTtcbiAgICAgICAgY29uc3QgbnMgPSBBZGRJbnN0YW50KEdldFNsb3QodGhpcywgRVBPQ0hOQU5PU0VDT05EUyksIC1ob3VycywgLW1pbnV0ZXMsIC1zZWNvbmRzLCAtbWlsbGlzZWNvbmRzLCAtbWljcm9zZWNvbmRzLCAtbmFub3NlY29uZHMpO1xuICAgICAgICByZXR1cm4gbmV3IEluc3RhbnQobnMpO1xuICAgIH1cbiAgICB1bnRpbChvdGhlclBhcmFtLCBvcHRpb25zUGFyYW0gPSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsSW5zdGFudCh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgY29uc3Qgb3RoZXIgPSBUb1RlbXBvcmFsSW5zdGFudChvdGhlclBhcmFtKTtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IEdldE9wdGlvbnNPYmplY3Qob3B0aW9uc1BhcmFtKTtcbiAgICAgICAgY29uc3Qgc21hbGxlc3RVbml0ID0gVG9TbWFsbGVzdFRlbXBvcmFsVW5pdChvcHRpb25zLCAnbmFub3NlY29uZCcsIERJU0FMTE9XRURfVU5JVFMkMyk7XG4gICAgICAgIGNvbnN0IGRlZmF1bHRMYXJnZXN0VW5pdCA9IExhcmdlck9mVHdvVGVtcG9yYWxVbml0cygnc2Vjb25kJywgc21hbGxlc3RVbml0KTtcbiAgICAgICAgY29uc3QgbGFyZ2VzdFVuaXQgPSBUb0xhcmdlc3RUZW1wb3JhbFVuaXQob3B0aW9ucywgJ2F1dG8nLCBESVNBTExPV0VEX1VOSVRTJDMsIGRlZmF1bHRMYXJnZXN0VW5pdCk7XG4gICAgICAgIFZhbGlkYXRlVGVtcG9yYWxVbml0UmFuZ2UobGFyZ2VzdFVuaXQsIHNtYWxsZXN0VW5pdCk7XG4gICAgICAgIGNvbnN0IHJvdW5kaW5nTW9kZSA9IFRvVGVtcG9yYWxSb3VuZGluZ01vZGUob3B0aW9ucywgJ3RydW5jJyk7XG4gICAgICAgIGNvbnN0IHJvdW5kaW5nSW5jcmVtZW50ID0gVG9UZW1wb3JhbFJvdW5kaW5nSW5jcmVtZW50KG9wdGlvbnMsIE1BWF9ESUZGRVJFTkNFX0lOQ1JFTUVOVFNbc21hbGxlc3RVbml0XSwgZmFsc2UpO1xuICAgICAgICBjb25zdCBvbmVucyA9IEdldFNsb3QodGhpcywgRVBPQ0hOQU5PU0VDT05EUyk7XG4gICAgICAgIGNvbnN0IHR3b25zID0gR2V0U2xvdChvdGhlciwgRVBPQ0hOQU5PU0VDT05EUyk7XG4gICAgICAgIGxldCB7IHNlY29uZHMsIG1pbGxpc2Vjb25kcywgbWljcm9zZWNvbmRzLCBuYW5vc2Vjb25kcyB9ID0gRGlmZmVyZW5jZUluc3RhbnQob25lbnMsIHR3b25zLCByb3VuZGluZ0luY3JlbWVudCwgc21hbGxlc3RVbml0LCByb3VuZGluZ01vZGUpO1xuICAgICAgICBsZXQgaG91cnMsIG1pbnV0ZXM7XG4gICAgICAgICh7IGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBtaWxsaXNlY29uZHMsIG1pY3Jvc2Vjb25kcywgbmFub3NlY29uZHMgfSA9IEJhbGFuY2VEdXJhdGlvbigwLCAwLCAwLCBzZWNvbmRzLCBtaWxsaXNlY29uZHMsIG1pY3Jvc2Vjb25kcywgbmFub3NlY29uZHMsIGxhcmdlc3RVbml0KSk7XG4gICAgICAgIGNvbnN0IER1cmF0aW9uID0gR2V0SW50cmluc2ljKCclVGVtcG9yYWwuRHVyYXRpb24lJyk7XG4gICAgICAgIHJldHVybiBuZXcgRHVyYXRpb24oMCwgMCwgMCwgMCwgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc2Vjb25kcywgbWljcm9zZWNvbmRzLCBuYW5vc2Vjb25kcyk7XG4gICAgfVxuICAgIHNpbmNlKG90aGVyUGFyYW0sIG9wdGlvbnNQYXJhbSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxJbnN0YW50KHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICBjb25zdCBvdGhlciA9IFRvVGVtcG9yYWxJbnN0YW50KG90aGVyUGFyYW0pO1xuICAgICAgICBjb25zdCBvcHRpb25zID0gR2V0T3B0aW9uc09iamVjdChvcHRpb25zUGFyYW0pO1xuICAgICAgICBjb25zdCBzbWFsbGVzdFVuaXQgPSBUb1NtYWxsZXN0VGVtcG9yYWxVbml0KG9wdGlvbnMsICduYW5vc2Vjb25kJywgRElTQUxMT1dFRF9VTklUUyQzKTtcbiAgICAgICAgY29uc3QgZGVmYXVsdExhcmdlc3RVbml0ID0gTGFyZ2VyT2ZUd29UZW1wb3JhbFVuaXRzKCdzZWNvbmQnLCBzbWFsbGVzdFVuaXQpO1xuICAgICAgICBjb25zdCBsYXJnZXN0VW5pdCA9IFRvTGFyZ2VzdFRlbXBvcmFsVW5pdChvcHRpb25zLCAnYXV0bycsIERJU0FMTE9XRURfVU5JVFMkMywgZGVmYXVsdExhcmdlc3RVbml0KTtcbiAgICAgICAgVmFsaWRhdGVUZW1wb3JhbFVuaXRSYW5nZShsYXJnZXN0VW5pdCwgc21hbGxlc3RVbml0KTtcbiAgICAgICAgY29uc3Qgcm91bmRpbmdNb2RlID0gVG9UZW1wb3JhbFJvdW5kaW5nTW9kZShvcHRpb25zLCAndHJ1bmMnKTtcbiAgICAgICAgY29uc3Qgcm91bmRpbmdJbmNyZW1lbnQgPSBUb1RlbXBvcmFsUm91bmRpbmdJbmNyZW1lbnQob3B0aW9ucywgTUFYX0RJRkZFUkVOQ0VfSU5DUkVNRU5UU1tzbWFsbGVzdFVuaXRdLCBmYWxzZSk7XG4gICAgICAgIGNvbnN0IG9uZW5zID0gR2V0U2xvdChvdGhlciwgRVBPQ0hOQU5PU0VDT05EUyk7XG4gICAgICAgIGNvbnN0IHR3b25zID0gR2V0U2xvdCh0aGlzLCBFUE9DSE5BTk9TRUNPTkRTKTtcbiAgICAgICAgbGV0IHsgc2Vjb25kcywgbWlsbGlzZWNvbmRzLCBtaWNyb3NlY29uZHMsIG5hbm9zZWNvbmRzIH0gPSBEaWZmZXJlbmNlSW5zdGFudChvbmVucywgdHdvbnMsIHJvdW5kaW5nSW5jcmVtZW50LCBzbWFsbGVzdFVuaXQsIHJvdW5kaW5nTW9kZSk7XG4gICAgICAgIGxldCBob3VycywgbWludXRlcztcbiAgICAgICAgKHsgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc2Vjb25kcywgbWljcm9zZWNvbmRzLCBuYW5vc2Vjb25kcyB9ID0gQmFsYW5jZUR1cmF0aW9uKDAsIDAsIDAsIHNlY29uZHMsIG1pbGxpc2Vjb25kcywgbWljcm9zZWNvbmRzLCBuYW5vc2Vjb25kcywgbGFyZ2VzdFVuaXQpKTtcbiAgICAgICAgY29uc3QgRHVyYXRpb24gPSBHZXRJbnRyaW5zaWMoJyVUZW1wb3JhbC5EdXJhdGlvbiUnKTtcbiAgICAgICAgcmV0dXJuIG5ldyBEdXJhdGlvbigwLCAwLCAwLCAwLCBob3VycywgbWludXRlcywgc2Vjb25kcywgbWlsbGlzZWNvbmRzLCBtaWNyb3NlY29uZHMsIG5hbm9zZWNvbmRzKTtcbiAgICB9XG4gICAgcm91bmQob3B0aW9uc1BhcmFtKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbEluc3RhbnQodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIGlmIChvcHRpb25zUGFyYW0gPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ29wdGlvbnMgcGFyYW1ldGVyIGlzIHJlcXVpcmVkJyk7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB0eXBlb2Ygb3B0aW9uc1BhcmFtID09PSAnc3RyaW5nJ1xuICAgICAgICAgICAgPyBDcmVhdGVPbmVQcm9wT2JqZWN0KCdzbWFsbGVzdFVuaXQnLCBvcHRpb25zUGFyYW0pXG4gICAgICAgICAgICA6IEdldE9wdGlvbnNPYmplY3Qob3B0aW9uc1BhcmFtKTtcbiAgICAgICAgY29uc3Qgc21hbGxlc3RVbml0ID0gVG9TbWFsbGVzdFRlbXBvcmFsVW5pdChvcHRpb25zLCB1bmRlZmluZWQsIERJU0FMTE9XRURfVU5JVFMkMyk7XG4gICAgICAgIGlmIChzbWFsbGVzdFVuaXQgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdzbWFsbGVzdFVuaXQgaXMgcmVxdWlyZWQnKTtcbiAgICAgICAgY29uc3Qgcm91bmRpbmdNb2RlID0gVG9UZW1wb3JhbFJvdW5kaW5nTW9kZShvcHRpb25zLCAnaGFsZkV4cGFuZCcpO1xuICAgICAgICBjb25zdCBtYXhpbXVtSW5jcmVtZW50cyA9IHtcbiAgICAgICAgICAgIGhvdXI6IDI0LFxuICAgICAgICAgICAgbWludXRlOiAxNDQwLFxuICAgICAgICAgICAgc2Vjb25kOiA4NjQwMCxcbiAgICAgICAgICAgIG1pbGxpc2Vjb25kOiA4NjQwMGUzLFxuICAgICAgICAgICAgbWljcm9zZWNvbmQ6IDg2NDAwZTYsXG4gICAgICAgICAgICBuYW5vc2Vjb25kOiA4NjQwMGU5XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJvdW5kaW5nSW5jcmVtZW50ID0gVG9UZW1wb3JhbFJvdW5kaW5nSW5jcmVtZW50KG9wdGlvbnMsIG1heGltdW1JbmNyZW1lbnRzW3NtYWxsZXN0VW5pdF0sIHRydWUpO1xuICAgICAgICBjb25zdCBucyA9IEdldFNsb3QodGhpcywgRVBPQ0hOQU5PU0VDT05EUyk7XG4gICAgICAgIGNvbnN0IHJvdW5kZWROcyA9IFJvdW5kSW5zdGFudChucywgcm91bmRpbmdJbmNyZW1lbnQsIHNtYWxsZXN0VW5pdCwgcm91bmRpbmdNb2RlKTtcbiAgICAgICAgcmV0dXJuIG5ldyBJbnN0YW50KHJvdW5kZWROcyk7XG4gICAgfVxuICAgIGVxdWFscyhvdGhlclBhcmFtKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbEluc3RhbnQodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIGNvbnN0IG90aGVyID0gVG9UZW1wb3JhbEluc3RhbnQob3RoZXJQYXJhbSk7XG4gICAgICAgIGNvbnN0IG9uZSA9IEdldFNsb3QodGhpcywgRVBPQ0hOQU5PU0VDT05EUyk7XG4gICAgICAgIGNvbnN0IHR3byA9IEdldFNsb3Qob3RoZXIsIEVQT0NITkFOT1NFQ09ORFMpO1xuICAgICAgICByZXR1cm4gSlNCSS5lcXVhbChKU0JJLkJpZ0ludChvbmUpLCBKU0JJLkJpZ0ludCh0d28pKTtcbiAgICB9XG4gICAgdG9TdHJpbmcob3B0aW9uc1BhcmFtID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbEluc3RhbnQodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSBHZXRPcHRpb25zT2JqZWN0KG9wdGlvbnNQYXJhbSk7XG4gICAgICAgIGxldCB0aW1lWm9uZSA9IG9wdGlvbnMudGltZVpvbmU7XG4gICAgICAgIGlmICh0aW1lWm9uZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgdGltZVpvbmUgPSBUb1RlbXBvcmFsVGltZVpvbmUodGltZVpvbmUpO1xuICAgICAgICAvLyBBbHRob3VnaCBUUyBkb2Vzbid0IGFja25vd2xlZGdlIGl0LCBiZWxvdyBoZXJlIGB0aW1lWm9uZWAgaXMgYSBUZW1wb3JhbC5UaW1lWm9uZVByb3RvY29sXG4gICAgICAgIGNvbnN0IHsgcHJlY2lzaW9uLCB1bml0LCBpbmNyZW1lbnQgfSA9IFRvU2Vjb25kc1N0cmluZ1ByZWNpc2lvbihvcHRpb25zKTtcbiAgICAgICAgY29uc3Qgcm91bmRpbmdNb2RlID0gVG9UZW1wb3JhbFJvdW5kaW5nTW9kZShvcHRpb25zLCAndHJ1bmMnKTtcbiAgICAgICAgY29uc3QgbnMgPSBHZXRTbG90KHRoaXMsIEVQT0NITkFOT1NFQ09ORFMpO1xuICAgICAgICBjb25zdCByb3VuZGVkTnMgPSBSb3VuZEluc3RhbnQobnMsIGluY3JlbWVudCwgdW5pdCwgcm91bmRpbmdNb2RlKTtcbiAgICAgICAgY29uc3Qgcm91bmRlZEluc3RhbnQgPSBuZXcgSW5zdGFudChyb3VuZGVkTnMpO1xuICAgICAgICByZXR1cm4gVGVtcG9yYWxJbnN0YW50VG9TdHJpbmcocm91bmRlZEluc3RhbnQsIHRpbWVab25lLCBwcmVjaXNpb24pO1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbEluc3RhbnQodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIHJldHVybiBUZW1wb3JhbEluc3RhbnRUb1N0cmluZyh0aGlzLCB1bmRlZmluZWQsICdhdXRvJyk7XG4gICAgfVxuICAgIHRvTG9jYWxlU3RyaW5nKGxvY2FsZXMgPSB1bmRlZmluZWQsIG9wdGlvbnMgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsSW5zdGFudCh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlVGltZUZvcm1hdChsb2NhbGVzLCBvcHRpb25zKS5mb3JtYXQodGhpcyk7XG4gICAgfVxuICAgIHZhbHVlT2YoKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3VzZSBjb21wYXJlKCkgb3IgZXF1YWxzKCkgdG8gY29tcGFyZSBUZW1wb3JhbC5JbnN0YW50Jyk7XG4gICAgfVxuICAgIHRvWm9uZWREYXRlVGltZShpdGVtKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbEluc3RhbnQodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIGlmICghSXNPYmplY3QoaXRlbSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgYXJndW1lbnQgaW4gdG9ab25lZERhdGVUaW1lJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2FsZW5kYXJMaWtlID0gaXRlbS5jYWxlbmRhcjtcbiAgICAgICAgaWYgKGNhbGVuZGFyTGlrZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdtaXNzaW5nIGNhbGVuZGFyIHByb3BlcnR5IGluIHRvWm9uZWREYXRlVGltZScpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNhbGVuZGFyID0gVG9UZW1wb3JhbENhbGVuZGFyKGNhbGVuZGFyTGlrZSk7XG4gICAgICAgIGNvbnN0IHRlbXBvcmFsVGltZVpvbmVMaWtlID0gaXRlbS50aW1lWm9uZTtcbiAgICAgICAgaWYgKHRlbXBvcmFsVGltZVpvbmVMaWtlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ21pc3NpbmcgdGltZVpvbmUgcHJvcGVydHkgaW4gdG9ab25lZERhdGVUaW1lJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGltZVpvbmUgPSBUb1RlbXBvcmFsVGltZVpvbmUodGVtcG9yYWxUaW1lWm9uZUxpa2UpO1xuICAgICAgICByZXR1cm4gQ3JlYXRlVGVtcG9yYWxab25lZERhdGVUaW1lKEdldFNsb3QodGhpcywgRVBPQ0hOQU5PU0VDT05EUyksIHRpbWVab25lLCBjYWxlbmRhcik7XG4gICAgfVxuICAgIHRvWm9uZWREYXRlVGltZUlTTyhpdGVtUGFyYW0pIHtcbiAgICAgICAgbGV0IGl0ZW0gPSBpdGVtUGFyYW07XG4gICAgICAgIGlmICghSXNUZW1wb3JhbEluc3RhbnQodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIGlmIChJc09iamVjdChpdGVtKSkge1xuICAgICAgICAgICAgY29uc3QgdGltZVpvbmVQcm9wZXJ0eSA9IGl0ZW0udGltZVpvbmU7XG4gICAgICAgICAgICBpZiAodGltZVpvbmVQcm9wZXJ0eSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgaXRlbSA9IHRpbWVab25lUHJvcGVydHk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGltZVpvbmUgPSBUb1RlbXBvcmFsVGltZVpvbmUoaXRlbSk7XG4gICAgICAgIGNvbnN0IGNhbGVuZGFyID0gR2V0SVNPODYwMUNhbGVuZGFyKCk7XG4gICAgICAgIHJldHVybiBDcmVhdGVUZW1wb3JhbFpvbmVkRGF0ZVRpbWUoR2V0U2xvdCh0aGlzLCBFUE9DSE5BTk9TRUNPTkRTKSwgdGltZVpvbmUsIGNhbGVuZGFyKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21FcG9jaFNlY29uZHMoZXBvY2hTZWNvbmRzUGFyYW0pIHtcbiAgICAgICAgY29uc3QgZXBvY2hTZWNvbmRzID0gVG9OdW1iZXIoZXBvY2hTZWNvbmRzUGFyYW0pO1xuICAgICAgICBjb25zdCBlcG9jaE5hbm9zZWNvbmRzID0gSlNCSS5tdWx0aXBseShKU0JJLkJpZ0ludChlcG9jaFNlY29uZHMpLCBCSUxMSU9OKTtcbiAgICAgICAgVmFsaWRhdGVFcG9jaE5hbm9zZWNvbmRzKGVwb2NoTmFub3NlY29uZHMpO1xuICAgICAgICByZXR1cm4gbmV3IEluc3RhbnQoZXBvY2hOYW5vc2Vjb25kcyk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tRXBvY2hNaWxsaXNlY29uZHMoZXBvY2hNaWxsaXNlY29uZHNQYXJhbSkge1xuICAgICAgICBjb25zdCBlcG9jaE1pbGxpc2Vjb25kcyA9IFRvTnVtYmVyKGVwb2NoTWlsbGlzZWNvbmRzUGFyYW0pO1xuICAgICAgICBjb25zdCBlcG9jaE5hbm9zZWNvbmRzID0gSlNCSS5tdWx0aXBseShKU0JJLkJpZ0ludChlcG9jaE1pbGxpc2Vjb25kcyksIE1JTExJT04pO1xuICAgICAgICBWYWxpZGF0ZUVwb2NoTmFub3NlY29uZHMoZXBvY2hOYW5vc2Vjb25kcyk7XG4gICAgICAgIHJldHVybiBuZXcgSW5zdGFudChlcG9jaE5hbm9zZWNvbmRzKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21FcG9jaE1pY3Jvc2Vjb25kcyhlcG9jaE1pY3Jvc2Vjb25kc1BhcmFtKSB7XG4gICAgICAgIGNvbnN0IGVwb2NoTWljcm9zZWNvbmRzID0gVG9CaWdJbnQoZXBvY2hNaWNyb3NlY29uZHNQYXJhbSk7XG4gICAgICAgIGNvbnN0IGVwb2NoTmFub3NlY29uZHMgPSBKU0JJLm11bHRpcGx5KGVwb2NoTWljcm9zZWNvbmRzLCBUSE9VU0FORCk7XG4gICAgICAgIFZhbGlkYXRlRXBvY2hOYW5vc2Vjb25kcyhlcG9jaE5hbm9zZWNvbmRzKTtcbiAgICAgICAgcmV0dXJuIG5ldyBJbnN0YW50KGVwb2NoTmFub3NlY29uZHMpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUVwb2NoTmFub3NlY29uZHMoZXBvY2hOYW5vc2Vjb25kc1BhcmFtKSB7XG4gICAgICAgIGNvbnN0IGVwb2NoTmFub3NlY29uZHMgPSBUb0JpZ0ludChlcG9jaE5hbm9zZWNvbmRzUGFyYW0pO1xuICAgICAgICBWYWxpZGF0ZUVwb2NoTmFub3NlY29uZHMoZXBvY2hOYW5vc2Vjb25kcyk7XG4gICAgICAgIHJldHVybiBuZXcgSW5zdGFudChlcG9jaE5hbm9zZWNvbmRzKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb20oaXRlbSkge1xuICAgICAgICBpZiAoSXNUZW1wb3JhbEluc3RhbnQoaXRlbSkpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSW5zdGFudChHZXRTbG90KGl0ZW0sIEVQT0NITkFOT1NFQ09ORFMpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gVG9UZW1wb3JhbEluc3RhbnQoaXRlbSk7XG4gICAgfVxuICAgIHN0YXRpYyBjb21wYXJlKG9uZVBhcmFtLCB0d29QYXJhbSkge1xuICAgICAgICBjb25zdCBvbmUgPSBUb1RlbXBvcmFsSW5zdGFudChvbmVQYXJhbSk7XG4gICAgICAgIGNvbnN0IHR3byA9IFRvVGVtcG9yYWxJbnN0YW50KHR3b1BhcmFtKTtcbiAgICAgICAgY29uc3Qgb25lTnMgPSBHZXRTbG90KG9uZSwgRVBPQ0hOQU5PU0VDT05EUyk7XG4gICAgICAgIGNvbnN0IHR3b05zID0gR2V0U2xvdCh0d28sIEVQT0NITkFOT1NFQ09ORFMpO1xuICAgICAgICBpZiAoSlNCSS5sZXNzVGhhbihvbmVOcywgdHdvTnMpKVxuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICBpZiAoSlNCSS5ncmVhdGVyVGhhbihvbmVOcywgdHdvTnMpKVxuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbn1cbk1ha2VJbnRyaW5zaWNDbGFzcyhJbnN0YW50LCAnVGVtcG9yYWwuSW5zdGFudCcpO1xuXG5jb25zdCBESVNBTExPV0VEX1VOSVRTJDIgPSBbJ2hvdXInLCAnbWludXRlJywgJ3NlY29uZCcsICdtaWxsaXNlY29uZCcsICdtaWNyb3NlY29uZCcsICduYW5vc2Vjb25kJ107XG5jbGFzcyBQbGFpbkRhdGUge1xuICAgIGNvbnN0cnVjdG9yKGlzb1llYXJQYXJhbSwgaXNvTW9udGhQYXJhbSwgaXNvRGF5UGFyYW0sIGNhbGVuZGFyUGFyYW0gPSBHZXRJU084NjAxQ2FsZW5kYXIoKSkge1xuICAgICAgICBjb25zdCBpc29ZZWFyID0gVG9JbnRlZ2VyVGhyb3dPbkluZmluaXR5KGlzb1llYXJQYXJhbSk7XG4gICAgICAgIGNvbnN0IGlzb01vbnRoID0gVG9JbnRlZ2VyVGhyb3dPbkluZmluaXR5KGlzb01vbnRoUGFyYW0pO1xuICAgICAgICBjb25zdCBpc29EYXkgPSBUb0ludGVnZXJUaHJvd09uSW5maW5pdHkoaXNvRGF5UGFyYW0pO1xuICAgICAgICBjb25zdCBjYWxlbmRhciA9IFRvVGVtcG9yYWxDYWxlbmRhcihjYWxlbmRhclBhcmFtKTtcbiAgICAgICAgLy8gTm90ZTogaWYgdGhlIGFyZ3VtZW50cyBhcmUgbm90IHBhc3NlZCxcbiAgICAgICAgLy8gICAgICAgVG9JbnRlZ2VyVGhyb3dPbkluZmluaXR5KHVuZGVmaW5lZCkgd2lsbCBoYXZlIHJldHVybmVkIDAsIHdoaWNoIHdpbGxcbiAgICAgICAgLy8gICAgICAgYmUgcmVqZWN0ZWQgYnkgUmVqZWN0SVNPRGF0ZSBpbiBDcmVhdGVUZW1wb3JhbERhdGVTbG90cy4gVGhpcyBjaGVja1xuICAgICAgICAvLyAgICAgICBleGlzdHMgb25seSB0byBpbXByb3ZlIHRoZSBlcnJvciBtZXNzYWdlLlxuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdtaXNzaW5nIGFyZ3VtZW50OiBpc29ZZWFyLCBpc29Nb250aCBhbmQgaXNvRGF5IGFyZSByZXF1aXJlZCcpO1xuICAgICAgICB9XG4gICAgICAgIENyZWF0ZVRlbXBvcmFsRGF0ZVNsb3RzKHRoaXMsIGlzb1llYXIsIGlzb01vbnRoLCBpc29EYXksIGNhbGVuZGFyKTtcbiAgICB9XG4gICAgZ2V0IGNhbGVuZGFyKCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxEYXRlKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICByZXR1cm4gR2V0U2xvdCh0aGlzLCBDQUxFTkRBUik7XG4gICAgfVxuICAgIGdldCBlcmEoKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbERhdGUodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIHJldHVybiBDYWxlbmRhckVyYShHZXRTbG90KHRoaXMsIENBTEVOREFSKSwgdGhpcyk7XG4gICAgfVxuICAgIGdldCBlcmFZZWFyKCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxEYXRlKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICByZXR1cm4gQ2FsZW5kYXJFcmFZZWFyKEdldFNsb3QodGhpcywgQ0FMRU5EQVIpLCB0aGlzKTtcbiAgICB9XG4gICAgZ2V0IHllYXIoKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbERhdGUodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIHJldHVybiBDYWxlbmRhclllYXIoR2V0U2xvdCh0aGlzLCBDQUxFTkRBUiksIHRoaXMpO1xuICAgIH1cbiAgICBnZXQgbW9udGgoKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbERhdGUodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIHJldHVybiBDYWxlbmRhck1vbnRoKEdldFNsb3QodGhpcywgQ0FMRU5EQVIpLCB0aGlzKTtcbiAgICB9XG4gICAgZ2V0IG1vbnRoQ29kZSgpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsRGF0ZSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgcmV0dXJuIENhbGVuZGFyTW9udGhDb2RlKEdldFNsb3QodGhpcywgQ0FMRU5EQVIpLCB0aGlzKTtcbiAgICB9XG4gICAgZ2V0IGRheSgpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsRGF0ZSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgcmV0dXJuIENhbGVuZGFyRGF5KEdldFNsb3QodGhpcywgQ0FMRU5EQVIpLCB0aGlzKTtcbiAgICB9XG4gICAgZ2V0IGRheU9mV2VlaygpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsRGF0ZSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgcmV0dXJuIENhbGVuZGFyRGF5T2ZXZWVrKEdldFNsb3QodGhpcywgQ0FMRU5EQVIpLCB0aGlzKTtcbiAgICB9XG4gICAgZ2V0IGRheU9mWWVhcigpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsRGF0ZSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgcmV0dXJuIENhbGVuZGFyRGF5T2ZZZWFyKEdldFNsb3QodGhpcywgQ0FMRU5EQVIpLCB0aGlzKTtcbiAgICB9XG4gICAgZ2V0IHdlZWtPZlllYXIoKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbERhdGUodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIHJldHVybiBDYWxlbmRhcldlZWtPZlllYXIoR2V0U2xvdCh0aGlzLCBDQUxFTkRBUiksIHRoaXMpO1xuICAgIH1cbiAgICBnZXQgZGF5c0luV2VlaygpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsRGF0ZSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgcmV0dXJuIENhbGVuZGFyRGF5c0luV2VlayhHZXRTbG90KHRoaXMsIENBTEVOREFSKSwgdGhpcyk7XG4gICAgfVxuICAgIGdldCBkYXlzSW5Nb250aCgpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsRGF0ZSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgcmV0dXJuIENhbGVuZGFyRGF5c0luTW9udGgoR2V0U2xvdCh0aGlzLCBDQUxFTkRBUiksIHRoaXMpO1xuICAgIH1cbiAgICBnZXQgZGF5c0luWWVhcigpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsRGF0ZSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgcmV0dXJuIENhbGVuZGFyRGF5c0luWWVhcihHZXRTbG90KHRoaXMsIENBTEVOREFSKSwgdGhpcyk7XG4gICAgfVxuICAgIGdldCBtb250aHNJblllYXIoKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbERhdGUodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIHJldHVybiBDYWxlbmRhck1vbnRoc0luWWVhcihHZXRTbG90KHRoaXMsIENBTEVOREFSKSwgdGhpcyk7XG4gICAgfVxuICAgIGdldCBpbkxlYXBZZWFyKCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxEYXRlKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICByZXR1cm4gQ2FsZW5kYXJJbkxlYXBZZWFyKEdldFNsb3QodGhpcywgQ0FMRU5EQVIpLCB0aGlzKTtcbiAgICB9XG4gICAgd2l0aCh0ZW1wb3JhbERhdGVMaWtlLCBvcHRpb25zUGFyYW0gPSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsRGF0ZSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgaWYgKCFJc09iamVjdCh0ZW1wb3JhbERhdGVMaWtlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBhcmd1bWVudCcpO1xuICAgICAgICB9XG4gICAgICAgIFJlamVjdE9iamVjdFdpdGhDYWxlbmRhck9yVGltZVpvbmUodGVtcG9yYWxEYXRlTGlrZSk7XG4gICAgICAgIGNvbnN0IGNhbGVuZGFyID0gR2V0U2xvdCh0aGlzLCBDQUxFTkRBUik7XG4gICAgICAgIGNvbnN0IGZpZWxkTmFtZXMgPSBDYWxlbmRhckZpZWxkcyhjYWxlbmRhciwgWydkYXknLCAnbW9udGgnLCAnbW9udGhDb2RlJywgJ3llYXInXSk7XG4gICAgICAgIGNvbnN0IHByb3BzID0gVG9QYXJ0aWFsUmVjb3JkKHRlbXBvcmFsRGF0ZUxpa2UsIGZpZWxkTmFtZXMpO1xuICAgICAgICBpZiAoIXByb3BzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIGRhdGUtbGlrZScpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBmaWVsZHMgPSBUb1RlbXBvcmFsRGF0ZUZpZWxkcyh0aGlzLCBmaWVsZE5hbWVzKTtcbiAgICAgICAgZmllbGRzID0gQ2FsZW5kYXJNZXJnZUZpZWxkcyhjYWxlbmRhciwgZmllbGRzLCBwcm9wcyk7XG4gICAgICAgIGZpZWxkcyA9IFRvVGVtcG9yYWxEYXRlRmllbGRzKGZpZWxkcywgZmllbGROYW1lcyk7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSBHZXRPcHRpb25zT2JqZWN0KG9wdGlvbnNQYXJhbSk7XG4gICAgICAgIHJldHVybiBEYXRlRnJvbUZpZWxkcyhjYWxlbmRhciwgZmllbGRzLCBvcHRpb25zKTtcbiAgICB9XG4gICAgd2l0aENhbGVuZGFyKGNhbGVuZGFyUGFyYW0pIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsRGF0ZSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgY29uc3QgY2FsZW5kYXIgPSBUb1RlbXBvcmFsQ2FsZW5kYXIoY2FsZW5kYXJQYXJhbSk7XG4gICAgICAgIHJldHVybiBuZXcgUGxhaW5EYXRlKEdldFNsb3QodGhpcywgSVNPX1lFQVIpLCBHZXRTbG90KHRoaXMsIElTT19NT05USCksIEdldFNsb3QodGhpcywgSVNPX0RBWSksIGNhbGVuZGFyKTtcbiAgICB9XG4gICAgYWRkKHRlbXBvcmFsRHVyYXRpb25MaWtlLCBvcHRpb25zUGFyYW0gPSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsRGF0ZSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgY29uc3QgZHVyYXRpb24gPSBUb1RlbXBvcmFsRHVyYXRpb24odGVtcG9yYWxEdXJhdGlvbkxpa2UpO1xuICAgICAgICBjb25zdCBvcHRpb25zID0gR2V0T3B0aW9uc09iamVjdChvcHRpb25zUGFyYW0pO1xuICAgICAgICByZXR1cm4gQ2FsZW5kYXJEYXRlQWRkKEdldFNsb3QodGhpcywgQ0FMRU5EQVIpLCB0aGlzLCBkdXJhdGlvbiwgb3B0aW9ucyk7XG4gICAgfVxuICAgIHN1YnRyYWN0KHRlbXBvcmFsRHVyYXRpb25MaWtlLCBvcHRpb25zUGFyYW0gPSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsRGF0ZSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgY29uc3QgZHVyYXRpb24gPSBDcmVhdGVOZWdhdGVkVGVtcG9yYWxEdXJhdGlvbihUb1RlbXBvcmFsRHVyYXRpb24odGVtcG9yYWxEdXJhdGlvbkxpa2UpKTtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IEdldE9wdGlvbnNPYmplY3Qob3B0aW9uc1BhcmFtKTtcbiAgICAgICAgcmV0dXJuIENhbGVuZGFyRGF0ZUFkZChHZXRTbG90KHRoaXMsIENBTEVOREFSKSwgdGhpcywgZHVyYXRpb24sIG9wdGlvbnMpO1xuICAgIH1cbiAgICB1bnRpbChvdGhlclBhcmFtLCBvcHRpb25zUGFyYW0gPSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsRGF0ZSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgY29uc3Qgb3RoZXIgPSBUb1RlbXBvcmFsRGF0ZShvdGhlclBhcmFtKTtcbiAgICAgICAgY29uc3QgY2FsZW5kYXIgPSBHZXRTbG90KHRoaXMsIENBTEVOREFSKTtcbiAgICAgICAgY29uc3Qgb3RoZXJDYWxlbmRhciA9IEdldFNsb3Qob3RoZXIsIENBTEVOREFSKTtcbiAgICAgICAgY29uc3QgY2FsZW5kYXJJZCA9IFRvU3RyaW5nKGNhbGVuZGFyKTtcbiAgICAgICAgY29uc3Qgb3RoZXJDYWxlbmRhcklkID0gVG9TdHJpbmcob3RoZXJDYWxlbmRhcik7XG4gICAgICAgIGlmIChjYWxlbmRhcklkICE9PSBvdGhlckNhbGVuZGFySWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBjYW5ub3QgY29tcHV0ZSBkaWZmZXJlbmNlIGJldHdlZW4gZGF0ZXMgb2YgJHtjYWxlbmRhcklkfSBhbmQgJHtvdGhlckNhbGVuZGFySWR9IGNhbGVuZGFyc2ApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSBHZXRPcHRpb25zT2JqZWN0KG9wdGlvbnNQYXJhbSk7XG4gICAgICAgIGNvbnN0IHNtYWxsZXN0VW5pdCA9IFRvU21hbGxlc3RUZW1wb3JhbFVuaXQob3B0aW9ucywgJ2RheScsIERJU0FMTE9XRURfVU5JVFMkMik7XG4gICAgICAgIGNvbnN0IGRlZmF1bHRMYXJnZXN0VW5pdCA9IExhcmdlck9mVHdvVGVtcG9yYWxVbml0cygnZGF5Jywgc21hbGxlc3RVbml0KTtcbiAgICAgICAgY29uc3QgbGFyZ2VzdFVuaXQgPSBUb0xhcmdlc3RUZW1wb3JhbFVuaXQob3B0aW9ucywgJ2F1dG8nLCBESVNBTExPV0VEX1VOSVRTJDIsIGRlZmF1bHRMYXJnZXN0VW5pdCk7XG4gICAgICAgIFZhbGlkYXRlVGVtcG9yYWxVbml0UmFuZ2UobGFyZ2VzdFVuaXQsIHNtYWxsZXN0VW5pdCk7XG4gICAgICAgIGNvbnN0IHJvdW5kaW5nTW9kZSA9IFRvVGVtcG9yYWxSb3VuZGluZ01vZGUob3B0aW9ucywgJ3RydW5jJyk7XG4gICAgICAgIGNvbnN0IHJvdW5kaW5nSW5jcmVtZW50ID0gVG9UZW1wb3JhbFJvdW5kaW5nSW5jcmVtZW50KG9wdGlvbnMsIHVuZGVmaW5lZCwgZmFsc2UpO1xuICAgICAgICBjb25zdCB1bnRpbE9wdGlvbnMgPSB7IC4uLm9wdGlvbnMsIGxhcmdlc3RVbml0IH07XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IENhbGVuZGFyRGF0ZVVudGlsKGNhbGVuZGFyLCB0aGlzLCBvdGhlciwgdW50aWxPcHRpb25zKTtcbiAgICAgICAgaWYgKHNtYWxsZXN0VW5pdCA9PT0gJ2RheScgJiYgcm91bmRpbmdJbmNyZW1lbnQgPT09IDEpXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICBsZXQgeyB5ZWFycywgbW9udGhzLCB3ZWVrcywgZGF5cyB9ID0gcmVzdWx0O1xuICAgICAgICAoeyB5ZWFycywgbW9udGhzLCB3ZWVrcywgZGF5cyB9ID0gUm91bmREdXJhdGlvbih5ZWFycywgbW9udGhzLCB3ZWVrcywgZGF5cywgMCwgMCwgMCwgMCwgMCwgMCwgcm91bmRpbmdJbmNyZW1lbnQsIHNtYWxsZXN0VW5pdCwgcm91bmRpbmdNb2RlLCB0aGlzKSk7XG4gICAgICAgIGNvbnN0IER1cmF0aW9uID0gR2V0SW50cmluc2ljKCclVGVtcG9yYWwuRHVyYXRpb24lJyk7XG4gICAgICAgIHJldHVybiBuZXcgRHVyYXRpb24oeWVhcnMsIG1vbnRocywgd2Vla3MsIGRheXMsIDAsIDAsIDAsIDAsIDAsIDApO1xuICAgIH1cbiAgICBzaW5jZShvdGhlclBhcmFtLCBvcHRpb25zUGFyYW0gPSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsRGF0ZSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgY29uc3Qgb3RoZXIgPSBUb1RlbXBvcmFsRGF0ZShvdGhlclBhcmFtKTtcbiAgICAgICAgY29uc3QgY2FsZW5kYXIgPSBHZXRTbG90KHRoaXMsIENBTEVOREFSKTtcbiAgICAgICAgY29uc3Qgb3RoZXJDYWxlbmRhciA9IEdldFNsb3Qob3RoZXIsIENBTEVOREFSKTtcbiAgICAgICAgY29uc3QgY2FsZW5kYXJJZCA9IFRvU3RyaW5nKGNhbGVuZGFyKTtcbiAgICAgICAgY29uc3Qgb3RoZXJDYWxlbmRhcklkID0gVG9TdHJpbmcob3RoZXJDYWxlbmRhcik7XG4gICAgICAgIGlmIChjYWxlbmRhcklkICE9PSBvdGhlckNhbGVuZGFySWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBjYW5ub3QgY29tcHV0ZSBkaWZmZXJlbmNlIGJldHdlZW4gZGF0ZXMgb2YgJHtjYWxlbmRhcklkfSBhbmQgJHtvdGhlckNhbGVuZGFySWR9IGNhbGVuZGFyc2ApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSBHZXRPcHRpb25zT2JqZWN0KG9wdGlvbnNQYXJhbSk7XG4gICAgICAgIGNvbnN0IHNtYWxsZXN0VW5pdCA9IFRvU21hbGxlc3RUZW1wb3JhbFVuaXQob3B0aW9ucywgJ2RheScsIERJU0FMTE9XRURfVU5JVFMkMik7XG4gICAgICAgIGNvbnN0IGRlZmF1bHRMYXJnZXN0VW5pdCA9IExhcmdlck9mVHdvVGVtcG9yYWxVbml0cygnZGF5Jywgc21hbGxlc3RVbml0KTtcbiAgICAgICAgY29uc3QgbGFyZ2VzdFVuaXQgPSBUb0xhcmdlc3RUZW1wb3JhbFVuaXQob3B0aW9ucywgJ2F1dG8nLCBESVNBTExPV0VEX1VOSVRTJDIsIGRlZmF1bHRMYXJnZXN0VW5pdCk7XG4gICAgICAgIFZhbGlkYXRlVGVtcG9yYWxVbml0UmFuZ2UobGFyZ2VzdFVuaXQsIHNtYWxsZXN0VW5pdCk7XG4gICAgICAgIGNvbnN0IHJvdW5kaW5nTW9kZSA9IFRvVGVtcG9yYWxSb3VuZGluZ01vZGUob3B0aW9ucywgJ3RydW5jJyk7XG4gICAgICAgIGNvbnN0IHJvdW5kaW5nSW5jcmVtZW50ID0gVG9UZW1wb3JhbFJvdW5kaW5nSW5jcmVtZW50KG9wdGlvbnMsIHVuZGVmaW5lZCwgZmFsc2UpO1xuICAgICAgICBjb25zdCB1bnRpbE9wdGlvbnMgPSB7IC4uLm9wdGlvbnMsIGxhcmdlc3RVbml0IH07XG4gICAgICAgIGxldCB7IHllYXJzLCBtb250aHMsIHdlZWtzLCBkYXlzIH0gPSBDYWxlbmRhckRhdGVVbnRpbChjYWxlbmRhciwgdGhpcywgb3RoZXIsIHVudGlsT3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IER1cmF0aW9uID0gR2V0SW50cmluc2ljKCclVGVtcG9yYWwuRHVyYXRpb24lJyk7XG4gICAgICAgIGlmIChzbWFsbGVzdFVuaXQgPT09ICdkYXknICYmIHJvdW5kaW5nSW5jcmVtZW50ID09PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IER1cmF0aW9uKC15ZWFycywgLW1vbnRocywgLXdlZWtzLCAtZGF5cywgMCwgMCwgMCwgMCwgMCwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgKHsgeWVhcnMsIG1vbnRocywgd2Vla3MsIGRheXMgfSA9IFJvdW5kRHVyYXRpb24oeWVhcnMsIG1vbnRocywgd2Vla3MsIGRheXMsIDAsIDAsIDAsIDAsIDAsIDAsIHJvdW5kaW5nSW5jcmVtZW50LCBzbWFsbGVzdFVuaXQsIE5lZ2F0ZVRlbXBvcmFsUm91bmRpbmdNb2RlKHJvdW5kaW5nTW9kZSksIHRoaXMpKTtcbiAgICAgICAgcmV0dXJuIG5ldyBEdXJhdGlvbigteWVhcnMsIC1tb250aHMsIC13ZWVrcywgLWRheXMsIDAsIDAsIDAsIDAsIDAsIDApO1xuICAgIH1cbiAgICBlcXVhbHMob3RoZXJQYXJhbSkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxEYXRlKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICBjb25zdCBvdGhlciA9IFRvVGVtcG9yYWxEYXRlKG90aGVyUGFyYW0pO1xuICAgICAgICBmb3IgKGNvbnN0IHNsb3Qgb2YgW0lTT19ZRUFSLCBJU09fTU9OVEgsIElTT19EQVldKSB7XG4gICAgICAgICAgICBjb25zdCB2YWwxID0gR2V0U2xvdCh0aGlzLCBzbG90KTtcbiAgICAgICAgICAgIGNvbnN0IHZhbDIgPSBHZXRTbG90KG90aGVyLCBzbG90KTtcbiAgICAgICAgICAgIGlmICh2YWwxICE9PSB2YWwyKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQ2FsZW5kYXJFcXVhbHMoR2V0U2xvdCh0aGlzLCBDQUxFTkRBUiksIEdldFNsb3Qob3RoZXIsIENBTEVOREFSKSk7XG4gICAgfVxuICAgIHRvU3RyaW5nKG9wdGlvbnNQYXJhbSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxEYXRlKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICBjb25zdCBvcHRpb25zID0gR2V0T3B0aW9uc09iamVjdChvcHRpb25zUGFyYW0pO1xuICAgICAgICBjb25zdCBzaG93Q2FsZW5kYXIgPSBUb1Nob3dDYWxlbmRhck9wdGlvbihvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIFRlbXBvcmFsRGF0ZVRvU3RyaW5nKHRoaXMsIHNob3dDYWxlbmRhcik7XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsRGF0ZSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgcmV0dXJuIFRlbXBvcmFsRGF0ZVRvU3RyaW5nKHRoaXMpO1xuICAgIH1cbiAgICB0b0xvY2FsZVN0cmluZyhsb2NhbGVzID0gdW5kZWZpbmVkLCBvcHRpb25zID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbERhdGUodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZVRpbWVGb3JtYXQobG9jYWxlcywgb3B0aW9ucykuZm9ybWF0KHRoaXMpO1xuICAgIH1cbiAgICB2YWx1ZU9mKCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd1c2UgY29tcGFyZSgpIG9yIGVxdWFscygpIHRvIGNvbXBhcmUgVGVtcG9yYWwuUGxhaW5EYXRlJyk7XG4gICAgfVxuICAgIHRvUGxhaW5EYXRlVGltZSh0ZW1wb3JhbFRpbWVQYXJhbSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxEYXRlKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICBjb25zdCB5ZWFyID0gR2V0U2xvdCh0aGlzLCBJU09fWUVBUik7XG4gICAgICAgIGNvbnN0IG1vbnRoID0gR2V0U2xvdCh0aGlzLCBJU09fTU9OVEgpO1xuICAgICAgICBjb25zdCBkYXkgPSBHZXRTbG90KHRoaXMsIElTT19EQVkpO1xuICAgICAgICBjb25zdCBjYWxlbmRhciA9IEdldFNsb3QodGhpcywgQ0FMRU5EQVIpO1xuICAgICAgICBpZiAodGVtcG9yYWxUaW1lUGFyYW0gPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJldHVybiBDcmVhdGVUZW1wb3JhbERhdGVUaW1lKHllYXIsIG1vbnRoLCBkYXksIDAsIDAsIDAsIDAsIDAsIDAsIGNhbGVuZGFyKTtcbiAgICAgICAgY29uc3QgdGVtcG9yYWxUaW1lID0gVG9UZW1wb3JhbFRpbWUodGVtcG9yYWxUaW1lUGFyYW0pO1xuICAgICAgICBjb25zdCBob3VyID0gR2V0U2xvdCh0ZW1wb3JhbFRpbWUsIElTT19IT1VSKTtcbiAgICAgICAgY29uc3QgbWludXRlID0gR2V0U2xvdCh0ZW1wb3JhbFRpbWUsIElTT19NSU5VVEUpO1xuICAgICAgICBjb25zdCBzZWNvbmQgPSBHZXRTbG90KHRlbXBvcmFsVGltZSwgSVNPX1NFQ09ORCk7XG4gICAgICAgIGNvbnN0IG1pbGxpc2Vjb25kID0gR2V0U2xvdCh0ZW1wb3JhbFRpbWUsIElTT19NSUxMSVNFQ09ORCk7XG4gICAgICAgIGNvbnN0IG1pY3Jvc2Vjb25kID0gR2V0U2xvdCh0ZW1wb3JhbFRpbWUsIElTT19NSUNST1NFQ09ORCk7XG4gICAgICAgIGNvbnN0IG5hbm9zZWNvbmQgPSBHZXRTbG90KHRlbXBvcmFsVGltZSwgSVNPX05BTk9TRUNPTkQpO1xuICAgICAgICByZXR1cm4gQ3JlYXRlVGVtcG9yYWxEYXRlVGltZSh5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQsIG1pY3Jvc2Vjb25kLCBuYW5vc2Vjb25kLCBjYWxlbmRhcik7XG4gICAgfVxuICAgIHRvWm9uZWREYXRlVGltZShpdGVtKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbERhdGUodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIGxldCB0aW1lWm9uZSwgdGVtcG9yYWxUaW1lO1xuICAgICAgICBpZiAoSXNPYmplY3QoaXRlbSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHRpbWVab25lTGlrZSA9IGl0ZW0udGltZVpvbmU7XG4gICAgICAgICAgICBpZiAodGltZVpvbmVMaWtlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgY2FzdCBiZWxvdyBpcyBuZWVkZWQgYmVjYXVzZSBpdCdzIHBvc3NpYmxlIGhlcmUgZm9yXG4gICAgICAgICAgICAgICAgLy8gYHRpbWVab25lTGlrZWAgaGVyZSB0byBiZSBgeyBwbGFpblRpbWU6IFRlbXBvcmFsLlBsYWluVGltZUxpa2UgfWAsXG4gICAgICAgICAgICAgICAgLy8gbm90IGEgVGltZVpvbmVQcm90b2NvbC5cbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBzaG91bGQgd2UgY2hlY2sgZm9yIHRoYXQgc2hhcGUgdG8gaW1wcm92ZSBvbiB0aGUgKGJhZCkgZXJyb3JcbiAgICAgICAgICAgICAgICAvLyBtZXNzYWdlIHRoYXQgdGhlIGNhbGxlciB3aWxsIGdldCBmcm9tIFRvVGVtcG9yYWxUaW1lWm9uZT9cbiAgICAgICAgICAgICAgICB0aW1lWm9uZSA9IFRvVGVtcG9yYWxUaW1lWm9uZShpdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRpbWVab25lID0gVG9UZW1wb3JhbFRpbWVab25lKHRpbWVab25lTGlrZSk7XG4gICAgICAgICAgICAgICAgdGVtcG9yYWxUaW1lID0gaXRlbS5wbGFpblRpbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aW1lWm9uZSA9IFRvVGVtcG9yYWxUaW1lWm9uZShpdGVtKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB5ZWFyID0gR2V0U2xvdCh0aGlzLCBJU09fWUVBUik7XG4gICAgICAgIGNvbnN0IG1vbnRoID0gR2V0U2xvdCh0aGlzLCBJU09fTU9OVEgpO1xuICAgICAgICBjb25zdCBkYXkgPSBHZXRTbG90KHRoaXMsIElTT19EQVkpO1xuICAgICAgICBjb25zdCBjYWxlbmRhciA9IEdldFNsb3QodGhpcywgQ0FMRU5EQVIpO1xuICAgICAgICBsZXQgaG91ciA9IDAsIG1pbnV0ZSA9IDAsIHNlY29uZCA9IDAsIG1pbGxpc2Vjb25kID0gMCwgbWljcm9zZWNvbmQgPSAwLCBuYW5vc2Vjb25kID0gMDtcbiAgICAgICAgaWYgKHRlbXBvcmFsVGltZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0ZW1wb3JhbFRpbWUgPSBUb1RlbXBvcmFsVGltZSh0ZW1wb3JhbFRpbWUpO1xuICAgICAgICAgICAgaG91ciA9IEdldFNsb3QodGVtcG9yYWxUaW1lLCBJU09fSE9VUik7XG4gICAgICAgICAgICBtaW51dGUgPSBHZXRTbG90KHRlbXBvcmFsVGltZSwgSVNPX01JTlVURSk7XG4gICAgICAgICAgICBzZWNvbmQgPSBHZXRTbG90KHRlbXBvcmFsVGltZSwgSVNPX1NFQ09ORCk7XG4gICAgICAgICAgICBtaWxsaXNlY29uZCA9IEdldFNsb3QodGVtcG9yYWxUaW1lLCBJU09fTUlMTElTRUNPTkQpO1xuICAgICAgICAgICAgbWljcm9zZWNvbmQgPSBHZXRTbG90KHRlbXBvcmFsVGltZSwgSVNPX01JQ1JPU0VDT05EKTtcbiAgICAgICAgICAgIG5hbm9zZWNvbmQgPSBHZXRTbG90KHRlbXBvcmFsVGltZSwgSVNPX05BTk9TRUNPTkQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGR0ID0gQ3JlYXRlVGVtcG9yYWxEYXRlVGltZSh5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQsIG1pY3Jvc2Vjb25kLCBuYW5vc2Vjb25kLCBjYWxlbmRhcik7XG4gICAgICAgIGNvbnN0IGluc3RhbnQgPSBCdWlsdGluVGltZVpvbmVHZXRJbnN0YW50Rm9yKHRpbWVab25lLCBkdCwgJ2NvbXBhdGlibGUnKTtcbiAgICAgICAgcmV0dXJuIENyZWF0ZVRlbXBvcmFsWm9uZWREYXRlVGltZShHZXRTbG90KGluc3RhbnQsIEVQT0NITkFOT1NFQ09ORFMpLCB0aW1lWm9uZSwgY2FsZW5kYXIpO1xuICAgIH1cbiAgICB0b1BsYWluWWVhck1vbnRoKCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxEYXRlKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICBjb25zdCBjYWxlbmRhciA9IEdldFNsb3QodGhpcywgQ0FMRU5EQVIpO1xuICAgICAgICBjb25zdCBmaWVsZE5hbWVzID0gQ2FsZW5kYXJGaWVsZHMoY2FsZW5kYXIsIFsnbW9udGhDb2RlJywgJ3llYXInXSk7XG4gICAgICAgIGNvbnN0IGZpZWxkcyA9IFRvVGVtcG9yYWxZZWFyTW9udGhGaWVsZHModGhpcywgZmllbGROYW1lcyk7XG4gICAgICAgIHJldHVybiBZZWFyTW9udGhGcm9tRmllbGRzKGNhbGVuZGFyLCBmaWVsZHMpO1xuICAgIH1cbiAgICB0b1BsYWluTW9udGhEYXkoKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbERhdGUodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIGNvbnN0IGNhbGVuZGFyID0gR2V0U2xvdCh0aGlzLCBDQUxFTkRBUik7XG4gICAgICAgIGNvbnN0IGZpZWxkTmFtZXMgPSBDYWxlbmRhckZpZWxkcyhjYWxlbmRhciwgWydkYXknLCAnbW9udGhDb2RlJ10pO1xuICAgICAgICBjb25zdCBmaWVsZHMgPSBUb1RlbXBvcmFsTW9udGhEYXlGaWVsZHModGhpcywgZmllbGROYW1lcyk7XG4gICAgICAgIHJldHVybiBNb250aERheUZyb21GaWVsZHMoY2FsZW5kYXIsIGZpZWxkcyk7XG4gICAgfVxuICAgIGdldElTT0ZpZWxkcygpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsRGF0ZSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNhbGVuZGFyOiBHZXRTbG90KHRoaXMsIENBTEVOREFSKSxcbiAgICAgICAgICAgIGlzb0RheTogR2V0U2xvdCh0aGlzLCBJU09fREFZKSxcbiAgICAgICAgICAgIGlzb01vbnRoOiBHZXRTbG90KHRoaXMsIElTT19NT05USCksXG4gICAgICAgICAgICBpc29ZZWFyOiBHZXRTbG90KHRoaXMsIElTT19ZRUFSKVxuICAgICAgICB9O1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbShpdGVtLCBvcHRpb25zUGFyYW0gPSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IEdldE9wdGlvbnNPYmplY3Qob3B0aW9uc1BhcmFtKTtcbiAgICAgICAgaWYgKElzVGVtcG9yYWxEYXRlKGl0ZW0pKSB7XG4gICAgICAgICAgICBUb1RlbXBvcmFsT3ZlcmZsb3cob3B0aW9ucyk7IC8vIHZhbGlkYXRlIGFuZCBpZ25vcmVcbiAgICAgICAgICAgIHJldHVybiBDcmVhdGVUZW1wb3JhbERhdGUoR2V0U2xvdChpdGVtLCBJU09fWUVBUiksIEdldFNsb3QoaXRlbSwgSVNPX01PTlRIKSwgR2V0U2xvdChpdGVtLCBJU09fREFZKSwgR2V0U2xvdChpdGVtLCBDQUxFTkRBUikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBUb1RlbXBvcmFsRGF0ZShpdGVtLCBvcHRpb25zKTtcbiAgICB9XG4gICAgc3RhdGljIGNvbXBhcmUob25lUGFyYW0sIHR3b1BhcmFtKSB7XG4gICAgICAgIGNvbnN0IG9uZSA9IFRvVGVtcG9yYWxEYXRlKG9uZVBhcmFtKTtcbiAgICAgICAgY29uc3QgdHdvID0gVG9UZW1wb3JhbERhdGUodHdvUGFyYW0pO1xuICAgICAgICByZXR1cm4gQ29tcGFyZUlTT0RhdGUoR2V0U2xvdChvbmUsIElTT19ZRUFSKSwgR2V0U2xvdChvbmUsIElTT19NT05USCksIEdldFNsb3Qob25lLCBJU09fREFZKSwgR2V0U2xvdCh0d28sIElTT19ZRUFSKSwgR2V0U2xvdCh0d28sIElTT19NT05USCksIEdldFNsb3QodHdvLCBJU09fREFZKSk7XG4gICAgfVxufVxuTWFrZUludHJpbnNpY0NsYXNzKFBsYWluRGF0ZSwgJ1RlbXBvcmFsLlBsYWluRGF0ZScpO1xuXG5jbGFzcyBQbGFpbkRhdGVUaW1lIHtcbiAgICBjb25zdHJ1Y3Rvcihpc29ZZWFyUGFyYW0sIGlzb01vbnRoUGFyYW0sIGlzb0RheVBhcmFtLCBob3VyUGFyYW0gPSAwLCBtaW51dGVQYXJhbSA9IDAsIHNlY29uZFBhcmFtID0gMCwgbWlsbGlzZWNvbmRQYXJhbSA9IDAsIG1pY3Jvc2Vjb25kUGFyYW0gPSAwLCBuYW5vc2Vjb25kUGFyYW0gPSAwLCBjYWxlbmRhclBhcmFtID0gR2V0SVNPODYwMUNhbGVuZGFyKCkpIHtcbiAgICAgICAgY29uc3QgaXNvWWVhciA9IFRvSW50ZWdlclRocm93T25JbmZpbml0eShpc29ZZWFyUGFyYW0pO1xuICAgICAgICBjb25zdCBpc29Nb250aCA9IFRvSW50ZWdlclRocm93T25JbmZpbml0eShpc29Nb250aFBhcmFtKTtcbiAgICAgICAgY29uc3QgaXNvRGF5ID0gVG9JbnRlZ2VyVGhyb3dPbkluZmluaXR5KGlzb0RheVBhcmFtKTtcbiAgICAgICAgY29uc3QgaG91ciA9IFRvSW50ZWdlclRocm93T25JbmZpbml0eShob3VyUGFyYW0pO1xuICAgICAgICBjb25zdCBtaW51dGUgPSBUb0ludGVnZXJUaHJvd09uSW5maW5pdHkobWludXRlUGFyYW0pO1xuICAgICAgICBjb25zdCBzZWNvbmQgPSBUb0ludGVnZXJUaHJvd09uSW5maW5pdHkoc2Vjb25kUGFyYW0pO1xuICAgICAgICBjb25zdCBtaWxsaXNlY29uZCA9IFRvSW50ZWdlclRocm93T25JbmZpbml0eShtaWxsaXNlY29uZFBhcmFtKTtcbiAgICAgICAgY29uc3QgbWljcm9zZWNvbmQgPSBUb0ludGVnZXJUaHJvd09uSW5maW5pdHkobWljcm9zZWNvbmRQYXJhbSk7XG4gICAgICAgIGNvbnN0IG5hbm9zZWNvbmQgPSBUb0ludGVnZXJUaHJvd09uSW5maW5pdHkobmFub3NlY29uZFBhcmFtKTtcbiAgICAgICAgY29uc3QgY2FsZW5kYXIgPSBUb1RlbXBvcmFsQ2FsZW5kYXIoY2FsZW5kYXJQYXJhbSk7XG4gICAgICAgIC8vIE5vdGU6IGlmIHRoZSBhcmd1bWVudHMgYXJlIG5vdCBwYXNzZWQsXG4gICAgICAgIC8vICAgICAgIFRvSW50ZWdlclRocm93T25JbmZpbml0eSh1bmRlZmluZWQpIHdpbGwgaGF2ZSByZXR1cm5lZCAwLCB3aGljaCB3aWxsXG4gICAgICAgIC8vICAgICAgIGJlIHJlamVjdGVkIGJ5IFJlamVjdERhdGVUaW1lIGluIENyZWF0ZVRlbXBvcmFsRGF0ZVRpbWVTbG90cy4gVGhpc1xuICAgICAgICAvLyAgICAgICBjaGVjayBleGlzdHMgb25seSB0byBpbXByb3ZlIHRoZSBlcnJvciBtZXNzYWdlLlxuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdtaXNzaW5nIGFyZ3VtZW50OiBpc29ZZWFyLCBpc29Nb250aCBhbmQgaXNvRGF5IGFyZSByZXF1aXJlZCcpO1xuICAgICAgICB9XG4gICAgICAgIENyZWF0ZVRlbXBvcmFsRGF0ZVRpbWVTbG90cyh0aGlzLCBpc29ZZWFyLCBpc29Nb250aCwgaXNvRGF5LCBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQsIG1pY3Jvc2Vjb25kLCBuYW5vc2Vjb25kLCBjYWxlbmRhcik7XG4gICAgfVxuICAgIGdldCBjYWxlbmRhcigpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsRGF0ZVRpbWUodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIHJldHVybiBHZXRTbG90KHRoaXMsIENBTEVOREFSKTtcbiAgICB9XG4gICAgZ2V0IHllYXIoKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbERhdGVUaW1lKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICByZXR1cm4gQ2FsZW5kYXJZZWFyKEdldFNsb3QodGhpcywgQ0FMRU5EQVIpLCB0aGlzKTtcbiAgICB9XG4gICAgZ2V0IG1vbnRoKCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxEYXRlVGltZSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgcmV0dXJuIENhbGVuZGFyTW9udGgoR2V0U2xvdCh0aGlzLCBDQUxFTkRBUiksIHRoaXMpO1xuICAgIH1cbiAgICBnZXQgbW9udGhDb2RlKCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxEYXRlVGltZSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgcmV0dXJuIENhbGVuZGFyTW9udGhDb2RlKEdldFNsb3QodGhpcywgQ0FMRU5EQVIpLCB0aGlzKTtcbiAgICB9XG4gICAgZ2V0IGRheSgpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsRGF0ZVRpbWUodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIHJldHVybiBDYWxlbmRhckRheShHZXRTbG90KHRoaXMsIENBTEVOREFSKSwgdGhpcyk7XG4gICAgfVxuICAgIGdldCBob3VyKCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxEYXRlVGltZSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgcmV0dXJuIEdldFNsb3QodGhpcywgSVNPX0hPVVIpO1xuICAgIH1cbiAgICBnZXQgbWludXRlKCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxEYXRlVGltZSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgcmV0dXJuIEdldFNsb3QodGhpcywgSVNPX01JTlVURSk7XG4gICAgfVxuICAgIGdldCBzZWNvbmQoKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbERhdGVUaW1lKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICByZXR1cm4gR2V0U2xvdCh0aGlzLCBJU09fU0VDT05EKTtcbiAgICB9XG4gICAgZ2V0IG1pbGxpc2Vjb25kKCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxEYXRlVGltZSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgcmV0dXJuIEdldFNsb3QodGhpcywgSVNPX01JTExJU0VDT05EKTtcbiAgICB9XG4gICAgZ2V0IG1pY3Jvc2Vjb25kKCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxEYXRlVGltZSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgcmV0dXJuIEdldFNsb3QodGhpcywgSVNPX01JQ1JPU0VDT05EKTtcbiAgICB9XG4gICAgZ2V0IG5hbm9zZWNvbmQoKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbERhdGVUaW1lKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICByZXR1cm4gR2V0U2xvdCh0aGlzLCBJU09fTkFOT1NFQ09ORCk7XG4gICAgfVxuICAgIGdldCBlcmEoKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbERhdGVUaW1lKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICByZXR1cm4gQ2FsZW5kYXJFcmEoR2V0U2xvdCh0aGlzLCBDQUxFTkRBUiksIHRoaXMpO1xuICAgIH1cbiAgICBnZXQgZXJhWWVhcigpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsRGF0ZVRpbWUodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIHJldHVybiBDYWxlbmRhckVyYVllYXIoR2V0U2xvdCh0aGlzLCBDQUxFTkRBUiksIHRoaXMpO1xuICAgIH1cbiAgICBnZXQgZGF5T2ZXZWVrKCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxEYXRlVGltZSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgcmV0dXJuIENhbGVuZGFyRGF5T2ZXZWVrKEdldFNsb3QodGhpcywgQ0FMRU5EQVIpLCB0aGlzKTtcbiAgICB9XG4gICAgZ2V0IGRheU9mWWVhcigpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsRGF0ZVRpbWUodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIHJldHVybiBDYWxlbmRhckRheU9mWWVhcihHZXRTbG90KHRoaXMsIENBTEVOREFSKSwgdGhpcyk7XG4gICAgfVxuICAgIGdldCB3ZWVrT2ZZZWFyKCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxEYXRlVGltZSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgcmV0dXJuIENhbGVuZGFyV2Vla09mWWVhcihHZXRTbG90KHRoaXMsIENBTEVOREFSKSwgdGhpcyk7XG4gICAgfVxuICAgIGdldCBkYXlzSW5XZWVrKCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxEYXRlVGltZSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgcmV0dXJuIENhbGVuZGFyRGF5c0luV2VlayhHZXRTbG90KHRoaXMsIENBTEVOREFSKSwgdGhpcyk7XG4gICAgfVxuICAgIGdldCBkYXlzSW5ZZWFyKCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxEYXRlVGltZSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgcmV0dXJuIENhbGVuZGFyRGF5c0luWWVhcihHZXRTbG90KHRoaXMsIENBTEVOREFSKSwgdGhpcyk7XG4gICAgfVxuICAgIGdldCBkYXlzSW5Nb250aCgpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsRGF0ZVRpbWUodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIHJldHVybiBDYWxlbmRhckRheXNJbk1vbnRoKEdldFNsb3QodGhpcywgQ0FMRU5EQVIpLCB0aGlzKTtcbiAgICB9XG4gICAgZ2V0IG1vbnRoc0luWWVhcigpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsRGF0ZVRpbWUodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIHJldHVybiBDYWxlbmRhck1vbnRoc0luWWVhcihHZXRTbG90KHRoaXMsIENBTEVOREFSKSwgdGhpcyk7XG4gICAgfVxuICAgIGdldCBpbkxlYXBZZWFyKCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxEYXRlVGltZSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgcmV0dXJuIENhbGVuZGFySW5MZWFwWWVhcihHZXRTbG90KHRoaXMsIENBTEVOREFSKSwgdGhpcyk7XG4gICAgfVxuICAgIHdpdGgodGVtcG9yYWxEYXRlVGltZUxpa2UsIG9wdGlvbnNQYXJhbSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxEYXRlVGltZSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgaWYgKCFJc09iamVjdCh0ZW1wb3JhbERhdGVUaW1lTGlrZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgYXJndW1lbnQnKTtcbiAgICAgICAgfVxuICAgICAgICBSZWplY3RPYmplY3RXaXRoQ2FsZW5kYXJPclRpbWVab25lKHRlbXBvcmFsRGF0ZVRpbWVMaWtlKTtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IEdldE9wdGlvbnNPYmplY3Qob3B0aW9uc1BhcmFtKTtcbiAgICAgICAgY29uc3QgY2FsZW5kYXIgPSBHZXRTbG90KHRoaXMsIENBTEVOREFSKTtcbiAgICAgICAgY29uc3QgZmllbGROYW1lcyA9IENhbGVuZGFyRmllbGRzKGNhbGVuZGFyLCBbXG4gICAgICAgICAgICAnZGF5JyxcbiAgICAgICAgICAgICdob3VyJyxcbiAgICAgICAgICAgICdtaWNyb3NlY29uZCcsXG4gICAgICAgICAgICAnbWlsbGlzZWNvbmQnLFxuICAgICAgICAgICAgJ21pbnV0ZScsXG4gICAgICAgICAgICAnbW9udGgnLFxuICAgICAgICAgICAgJ21vbnRoQ29kZScsXG4gICAgICAgICAgICAnbmFub3NlY29uZCcsXG4gICAgICAgICAgICAnc2Vjb25kJyxcbiAgICAgICAgICAgICd5ZWFyJ1xuICAgICAgICBdKTtcbiAgICAgICAgY29uc3QgcHJvcHMgPSBUb1BhcnRpYWxSZWNvcmQodGVtcG9yYWxEYXRlVGltZUxpa2UsIGZpZWxkTmFtZXMpO1xuICAgICAgICBpZiAoIXByb3BzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIGRhdGUtdGltZS1saWtlJyk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGZpZWxkcyA9IFRvVGVtcG9yYWxEYXRlVGltZUZpZWxkcyh0aGlzLCBmaWVsZE5hbWVzKTtcbiAgICAgICAgZmllbGRzID0gQ2FsZW5kYXJNZXJnZUZpZWxkcyhjYWxlbmRhciwgZmllbGRzLCBwcm9wcyk7XG4gICAgICAgIGZpZWxkcyA9IFRvVGVtcG9yYWxEYXRlVGltZUZpZWxkcyhmaWVsZHMsIGZpZWxkTmFtZXMpO1xuICAgICAgICBjb25zdCB7IHllYXIsIG1vbnRoLCBkYXksIGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZCwgbWljcm9zZWNvbmQsIG5hbm9zZWNvbmQgfSA9IEludGVycHJldFRlbXBvcmFsRGF0ZVRpbWVGaWVsZHMoY2FsZW5kYXIsIGZpZWxkcywgb3B0aW9ucyk7XG4gICAgICAgIHJldHVybiBDcmVhdGVUZW1wb3JhbERhdGVUaW1lKHllYXIsIG1vbnRoLCBkYXksIGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZCwgbWljcm9zZWNvbmQsIG5hbm9zZWNvbmQsIGNhbGVuZGFyKTtcbiAgICB9XG4gICAgd2l0aFBsYWluVGltZSh0ZW1wb3JhbFRpbWVQYXJhbSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxEYXRlVGltZSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgY29uc3QgeWVhciA9IEdldFNsb3QodGhpcywgSVNPX1lFQVIpO1xuICAgICAgICBjb25zdCBtb250aCA9IEdldFNsb3QodGhpcywgSVNPX01PTlRIKTtcbiAgICAgICAgY29uc3QgZGF5ID0gR2V0U2xvdCh0aGlzLCBJU09fREFZKTtcbiAgICAgICAgY29uc3QgY2FsZW5kYXIgPSBHZXRTbG90KHRoaXMsIENBTEVOREFSKTtcbiAgICAgICAgaWYgKHRlbXBvcmFsVGltZVBhcmFtID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXR1cm4gQ3JlYXRlVGVtcG9yYWxEYXRlVGltZSh5ZWFyLCBtb250aCwgZGF5LCAwLCAwLCAwLCAwLCAwLCAwLCBjYWxlbmRhcik7XG4gICAgICAgIGNvbnN0IHRlbXBvcmFsVGltZSA9IFRvVGVtcG9yYWxUaW1lKHRlbXBvcmFsVGltZVBhcmFtKTtcbiAgICAgICAgY29uc3QgaG91ciA9IEdldFNsb3QodGVtcG9yYWxUaW1lLCBJU09fSE9VUik7XG4gICAgICAgIGNvbnN0IG1pbnV0ZSA9IEdldFNsb3QodGVtcG9yYWxUaW1lLCBJU09fTUlOVVRFKTtcbiAgICAgICAgY29uc3Qgc2Vjb25kID0gR2V0U2xvdCh0ZW1wb3JhbFRpbWUsIElTT19TRUNPTkQpO1xuICAgICAgICBjb25zdCBtaWxsaXNlY29uZCA9IEdldFNsb3QodGVtcG9yYWxUaW1lLCBJU09fTUlMTElTRUNPTkQpO1xuICAgICAgICBjb25zdCBtaWNyb3NlY29uZCA9IEdldFNsb3QodGVtcG9yYWxUaW1lLCBJU09fTUlDUk9TRUNPTkQpO1xuICAgICAgICBjb25zdCBuYW5vc2Vjb25kID0gR2V0U2xvdCh0ZW1wb3JhbFRpbWUsIElTT19OQU5PU0VDT05EKTtcbiAgICAgICAgcmV0dXJuIENyZWF0ZVRlbXBvcmFsRGF0ZVRpbWUoeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kLCBtaWNyb3NlY29uZCwgbmFub3NlY29uZCwgY2FsZW5kYXIpO1xuICAgIH1cbiAgICB3aXRoUGxhaW5EYXRlKHRlbXBvcmFsRGF0ZVBhcmFtKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbERhdGVUaW1lKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICBjb25zdCB0ZW1wb3JhbERhdGUgPSBUb1RlbXBvcmFsRGF0ZSh0ZW1wb3JhbERhdGVQYXJhbSk7XG4gICAgICAgIGNvbnN0IHllYXIgPSBHZXRTbG90KHRlbXBvcmFsRGF0ZSwgSVNPX1lFQVIpO1xuICAgICAgICBjb25zdCBtb250aCA9IEdldFNsb3QodGVtcG9yYWxEYXRlLCBJU09fTU9OVEgpO1xuICAgICAgICBjb25zdCBkYXkgPSBHZXRTbG90KHRlbXBvcmFsRGF0ZSwgSVNPX0RBWSk7XG4gICAgICAgIGxldCBjYWxlbmRhciA9IEdldFNsb3QodGVtcG9yYWxEYXRlLCBDQUxFTkRBUik7XG4gICAgICAgIGNvbnN0IGhvdXIgPSBHZXRTbG90KHRoaXMsIElTT19IT1VSKTtcbiAgICAgICAgY29uc3QgbWludXRlID0gR2V0U2xvdCh0aGlzLCBJU09fTUlOVVRFKTtcbiAgICAgICAgY29uc3Qgc2Vjb25kID0gR2V0U2xvdCh0aGlzLCBJU09fU0VDT05EKTtcbiAgICAgICAgY29uc3QgbWlsbGlzZWNvbmQgPSBHZXRTbG90KHRoaXMsIElTT19NSUxMSVNFQ09ORCk7XG4gICAgICAgIGNvbnN0IG1pY3Jvc2Vjb25kID0gR2V0U2xvdCh0aGlzLCBJU09fTUlDUk9TRUNPTkQpO1xuICAgICAgICBjb25zdCBuYW5vc2Vjb25kID0gR2V0U2xvdCh0aGlzLCBJU09fTkFOT1NFQ09ORCk7XG4gICAgICAgIGNhbGVuZGFyID0gQ29uc29saWRhdGVDYWxlbmRhcnMoR2V0U2xvdCh0aGlzLCBDQUxFTkRBUiksIGNhbGVuZGFyKTtcbiAgICAgICAgcmV0dXJuIENyZWF0ZVRlbXBvcmFsRGF0ZVRpbWUoeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kLCBtaWNyb3NlY29uZCwgbmFub3NlY29uZCwgY2FsZW5kYXIpO1xuICAgIH1cbiAgICB3aXRoQ2FsZW5kYXIoY2FsZW5kYXJQYXJhbSkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxEYXRlVGltZSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgY29uc3QgY2FsZW5kYXIgPSBUb1RlbXBvcmFsQ2FsZW5kYXIoY2FsZW5kYXJQYXJhbSk7XG4gICAgICAgIHJldHVybiBuZXcgUGxhaW5EYXRlVGltZShHZXRTbG90KHRoaXMsIElTT19ZRUFSKSwgR2V0U2xvdCh0aGlzLCBJU09fTU9OVEgpLCBHZXRTbG90KHRoaXMsIElTT19EQVkpLCBHZXRTbG90KHRoaXMsIElTT19IT1VSKSwgR2V0U2xvdCh0aGlzLCBJU09fTUlOVVRFKSwgR2V0U2xvdCh0aGlzLCBJU09fU0VDT05EKSwgR2V0U2xvdCh0aGlzLCBJU09fTUlMTElTRUNPTkQpLCBHZXRTbG90KHRoaXMsIElTT19NSUNST1NFQ09ORCksIEdldFNsb3QodGhpcywgSVNPX05BTk9TRUNPTkQpLCBjYWxlbmRhcik7XG4gICAgfVxuICAgIGFkZCh0ZW1wb3JhbER1cmF0aW9uTGlrZSwgb3B0aW9uc1BhcmFtID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbERhdGVUaW1lKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICBjb25zdCBkdXJhdGlvbiA9IFRvTGltaXRlZFRlbXBvcmFsRHVyYXRpb24odGVtcG9yYWxEdXJhdGlvbkxpa2UpO1xuICAgICAgICBjb25zdCB7IHllYXJzLCBtb250aHMsIHdlZWtzLCBkYXlzLCBob3VycywgbWludXRlcywgc2Vjb25kcywgbWlsbGlzZWNvbmRzLCBtaWNyb3NlY29uZHMsIG5hbm9zZWNvbmRzIH0gPSBkdXJhdGlvbjtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IEdldE9wdGlvbnNPYmplY3Qob3B0aW9uc1BhcmFtKTtcbiAgICAgICAgY29uc3QgY2FsZW5kYXIgPSBHZXRTbG90KHRoaXMsIENBTEVOREFSKTtcbiAgICAgICAgY29uc3QgeyB5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQsIG1pY3Jvc2Vjb25kLCBuYW5vc2Vjb25kIH0gPSBBZGREYXRlVGltZShHZXRTbG90KHRoaXMsIElTT19ZRUFSKSwgR2V0U2xvdCh0aGlzLCBJU09fTU9OVEgpLCBHZXRTbG90KHRoaXMsIElTT19EQVkpLCBHZXRTbG90KHRoaXMsIElTT19IT1VSKSwgR2V0U2xvdCh0aGlzLCBJU09fTUlOVVRFKSwgR2V0U2xvdCh0aGlzLCBJU09fU0VDT05EKSwgR2V0U2xvdCh0aGlzLCBJU09fTUlMTElTRUNPTkQpLCBHZXRTbG90KHRoaXMsIElTT19NSUNST1NFQ09ORCksIEdldFNsb3QodGhpcywgSVNPX05BTk9TRUNPTkQpLCBjYWxlbmRhciwgeWVhcnMsIG1vbnRocywgd2Vla3MsIGRheXMsIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBtaWxsaXNlY29uZHMsIG1pY3Jvc2Vjb25kcywgbmFub3NlY29uZHMsIG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gQ3JlYXRlVGVtcG9yYWxEYXRlVGltZSh5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQsIG1pY3Jvc2Vjb25kLCBuYW5vc2Vjb25kLCBjYWxlbmRhcik7XG4gICAgfVxuICAgIHN1YnRyYWN0KHRlbXBvcmFsRHVyYXRpb25MaWtlLCBvcHRpb25zUGFyYW0gPSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsRGF0ZVRpbWUodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIGNvbnN0IGR1cmF0aW9uID0gVG9MaW1pdGVkVGVtcG9yYWxEdXJhdGlvbih0ZW1wb3JhbER1cmF0aW9uTGlrZSk7XG4gICAgICAgIGNvbnN0IHsgeWVhcnMsIG1vbnRocywgd2Vla3MsIGRheXMsIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBtaWxsaXNlY29uZHMsIG1pY3Jvc2Vjb25kcywgbmFub3NlY29uZHMgfSA9IGR1cmF0aW9uO1xuICAgICAgICBjb25zdCBvcHRpb25zID0gR2V0T3B0aW9uc09iamVjdChvcHRpb25zUGFyYW0pO1xuICAgICAgICBjb25zdCBjYWxlbmRhciA9IEdldFNsb3QodGhpcywgQ0FMRU5EQVIpO1xuICAgICAgICBjb25zdCB7IHllYXIsIG1vbnRoLCBkYXksIGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZCwgbWljcm9zZWNvbmQsIG5hbm9zZWNvbmQgfSA9IEFkZERhdGVUaW1lKEdldFNsb3QodGhpcywgSVNPX1lFQVIpLCBHZXRTbG90KHRoaXMsIElTT19NT05USCksIEdldFNsb3QodGhpcywgSVNPX0RBWSksIEdldFNsb3QodGhpcywgSVNPX0hPVVIpLCBHZXRTbG90KHRoaXMsIElTT19NSU5VVEUpLCBHZXRTbG90KHRoaXMsIElTT19TRUNPTkQpLCBHZXRTbG90KHRoaXMsIElTT19NSUxMSVNFQ09ORCksIEdldFNsb3QodGhpcywgSVNPX01JQ1JPU0VDT05EKSwgR2V0U2xvdCh0aGlzLCBJU09fTkFOT1NFQ09ORCksIGNhbGVuZGFyLCAteWVhcnMsIC1tb250aHMsIC13ZWVrcywgLWRheXMsIC1ob3VycywgLW1pbnV0ZXMsIC1zZWNvbmRzLCAtbWlsbGlzZWNvbmRzLCAtbWljcm9zZWNvbmRzLCAtbmFub3NlY29uZHMsIG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gQ3JlYXRlVGVtcG9yYWxEYXRlVGltZSh5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQsIG1pY3Jvc2Vjb25kLCBuYW5vc2Vjb25kLCBjYWxlbmRhcik7XG4gICAgfVxuICAgIHVudGlsKG90aGVyUGFyYW0sIG9wdGlvbnNQYXJhbSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxEYXRlVGltZSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgY29uc3Qgb3RoZXIgPSBUb1RlbXBvcmFsRGF0ZVRpbWUob3RoZXJQYXJhbSk7XG4gICAgICAgIGNvbnN0IGNhbGVuZGFyID0gR2V0U2xvdCh0aGlzLCBDQUxFTkRBUik7XG4gICAgICAgIGNvbnN0IG90aGVyQ2FsZW5kYXIgPSBHZXRTbG90KG90aGVyLCBDQUxFTkRBUik7XG4gICAgICAgIGNvbnN0IGNhbGVuZGFySWQgPSBUb1N0cmluZyhjYWxlbmRhcik7XG4gICAgICAgIGNvbnN0IG90aGVyQ2FsZW5kYXJJZCA9IFRvU3RyaW5nKG90aGVyQ2FsZW5kYXIpO1xuICAgICAgICBpZiAoY2FsZW5kYXJJZCAhPT0gb3RoZXJDYWxlbmRhcklkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgY2Fubm90IGNvbXB1dGUgZGlmZmVyZW5jZSBiZXR3ZWVuIGRhdGVzIG9mICR7Y2FsZW5kYXJJZH0gYW5kICR7b3RoZXJDYWxlbmRhcklkfSBjYWxlbmRhcnNgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvcHRpb25zID0gR2V0T3B0aW9uc09iamVjdChvcHRpb25zUGFyYW0pO1xuICAgICAgICBjb25zdCBzbWFsbGVzdFVuaXQgPSBUb1NtYWxsZXN0VGVtcG9yYWxVbml0KG9wdGlvbnMsICduYW5vc2Vjb25kJyk7XG4gICAgICAgIGNvbnN0IGRlZmF1bHRMYXJnZXN0VW5pdCA9IExhcmdlck9mVHdvVGVtcG9yYWxVbml0cygnZGF5Jywgc21hbGxlc3RVbml0KTtcbiAgICAgICAgY29uc3QgbGFyZ2VzdFVuaXQgPSBUb0xhcmdlc3RUZW1wb3JhbFVuaXQob3B0aW9ucywgJ2F1dG8nLCBbXSwgZGVmYXVsdExhcmdlc3RVbml0KTtcbiAgICAgICAgVmFsaWRhdGVUZW1wb3JhbFVuaXRSYW5nZShsYXJnZXN0VW5pdCwgc21hbGxlc3RVbml0KTtcbiAgICAgICAgY29uc3Qgcm91bmRpbmdNb2RlID0gVG9UZW1wb3JhbFJvdW5kaW5nTW9kZShvcHRpb25zLCAndHJ1bmMnKTtcbiAgICAgICAgY29uc3Qgcm91bmRpbmdJbmNyZW1lbnQgPSBUb1RlbXBvcmFsRGF0ZVRpbWVSb3VuZGluZ0luY3JlbWVudChvcHRpb25zLCBzbWFsbGVzdFVuaXQpO1xuICAgICAgICBsZXQgeyB5ZWFycywgbW9udGhzLCB3ZWVrcywgZGF5cywgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc2Vjb25kcywgbWljcm9zZWNvbmRzLCBuYW5vc2Vjb25kcyB9ID0gRGlmZmVyZW5jZUlTT0RhdGVUaW1lKEdldFNsb3QodGhpcywgSVNPX1lFQVIpLCBHZXRTbG90KHRoaXMsIElTT19NT05USCksIEdldFNsb3QodGhpcywgSVNPX0RBWSksIEdldFNsb3QodGhpcywgSVNPX0hPVVIpLCBHZXRTbG90KHRoaXMsIElTT19NSU5VVEUpLCBHZXRTbG90KHRoaXMsIElTT19TRUNPTkQpLCBHZXRTbG90KHRoaXMsIElTT19NSUxMSVNFQ09ORCksIEdldFNsb3QodGhpcywgSVNPX01JQ1JPU0VDT05EKSwgR2V0U2xvdCh0aGlzLCBJU09fTkFOT1NFQ09ORCksIEdldFNsb3Qob3RoZXIsIElTT19ZRUFSKSwgR2V0U2xvdChvdGhlciwgSVNPX01PTlRIKSwgR2V0U2xvdChvdGhlciwgSVNPX0RBWSksIEdldFNsb3Qob3RoZXIsIElTT19IT1VSKSwgR2V0U2xvdChvdGhlciwgSVNPX01JTlVURSksIEdldFNsb3Qob3RoZXIsIElTT19TRUNPTkQpLCBHZXRTbG90KG90aGVyLCBJU09fTUlMTElTRUNPTkQpLCBHZXRTbG90KG90aGVyLCBJU09fTUlDUk9TRUNPTkQpLCBHZXRTbG90KG90aGVyLCBJU09fTkFOT1NFQ09ORCksIGNhbGVuZGFyLCBsYXJnZXN0VW5pdCwgb3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IHJlbGF0aXZlVG8gPSBUZW1wb3JhbERhdGVUaW1lVG9EYXRlKHRoaXMpO1xuICAgICAgICAoeyB5ZWFycywgbW9udGhzLCB3ZWVrcywgZGF5cywgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc2Vjb25kcywgbWljcm9zZWNvbmRzLCBuYW5vc2Vjb25kcyB9ID1cbiAgICAgICAgICAgIFJvdW5kRHVyYXRpb24oeWVhcnMsIG1vbnRocywgd2Vla3MsIGRheXMsIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBtaWxsaXNlY29uZHMsIG1pY3Jvc2Vjb25kcywgbmFub3NlY29uZHMsIHJvdW5kaW5nSW5jcmVtZW50LCBzbWFsbGVzdFVuaXQsIHJvdW5kaW5nTW9kZSwgcmVsYXRpdmVUbykpO1xuICAgICAgICAoeyBkYXlzLCBob3VycywgbWludXRlcywgc2Vjb25kcywgbWlsbGlzZWNvbmRzLCBtaWNyb3NlY29uZHMsIG5hbm9zZWNvbmRzIH0gPSBCYWxhbmNlRHVyYXRpb24oZGF5cywgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc2Vjb25kcywgbWljcm9zZWNvbmRzLCBuYW5vc2Vjb25kcywgbGFyZ2VzdFVuaXQpKTtcbiAgICAgICAgY29uc3QgRHVyYXRpb24gPSBHZXRJbnRyaW5zaWMoJyVUZW1wb3JhbC5EdXJhdGlvbiUnKTtcbiAgICAgICAgcmV0dXJuIG5ldyBEdXJhdGlvbih5ZWFycywgbW9udGhzLCB3ZWVrcywgZGF5cywgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc2Vjb25kcywgbWljcm9zZWNvbmRzLCBuYW5vc2Vjb25kcyk7XG4gICAgfVxuICAgIHNpbmNlKG90aGVyUGFyYW0sIG9wdGlvbnNQYXJhbSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxEYXRlVGltZSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgY29uc3Qgb3RoZXIgPSBUb1RlbXBvcmFsRGF0ZVRpbWUob3RoZXJQYXJhbSk7XG4gICAgICAgIGNvbnN0IGNhbGVuZGFyID0gR2V0U2xvdCh0aGlzLCBDQUxFTkRBUik7XG4gICAgICAgIGNvbnN0IG90aGVyQ2FsZW5kYXIgPSBHZXRTbG90KG90aGVyLCBDQUxFTkRBUik7XG4gICAgICAgIGNvbnN0IGNhbGVuZGFySWQgPSBUb1N0cmluZyhjYWxlbmRhcik7XG4gICAgICAgIGNvbnN0IG90aGVyQ2FsZW5kYXJJZCA9IFRvU3RyaW5nKG90aGVyQ2FsZW5kYXIpO1xuICAgICAgICBpZiAoY2FsZW5kYXJJZCAhPT0gb3RoZXJDYWxlbmRhcklkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgY2Fubm90IGNvbXB1dGUgZGlmZmVyZW5jZSBiZXR3ZWVuIGRhdGVzIG9mICR7Y2FsZW5kYXJJZH0gYW5kICR7b3RoZXJDYWxlbmRhcklkfSBjYWxlbmRhcnNgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvcHRpb25zID0gR2V0T3B0aW9uc09iamVjdChvcHRpb25zUGFyYW0pO1xuICAgICAgICBjb25zdCBzbWFsbGVzdFVuaXQgPSBUb1NtYWxsZXN0VGVtcG9yYWxVbml0KG9wdGlvbnMsICduYW5vc2Vjb25kJyk7XG4gICAgICAgIGNvbnN0IGRlZmF1bHRMYXJnZXN0VW5pdCA9IExhcmdlck9mVHdvVGVtcG9yYWxVbml0cygnZGF5Jywgc21hbGxlc3RVbml0KTtcbiAgICAgICAgY29uc3QgbGFyZ2VzdFVuaXQgPSBUb0xhcmdlc3RUZW1wb3JhbFVuaXQob3B0aW9ucywgJ2F1dG8nLCBbXSwgZGVmYXVsdExhcmdlc3RVbml0KTtcbiAgICAgICAgVmFsaWRhdGVUZW1wb3JhbFVuaXRSYW5nZShsYXJnZXN0VW5pdCwgc21hbGxlc3RVbml0KTtcbiAgICAgICAgY29uc3Qgcm91bmRpbmdNb2RlID0gVG9UZW1wb3JhbFJvdW5kaW5nTW9kZShvcHRpb25zLCAndHJ1bmMnKTtcbiAgICAgICAgY29uc3Qgcm91bmRpbmdJbmNyZW1lbnQgPSBUb1RlbXBvcmFsRGF0ZVRpbWVSb3VuZGluZ0luY3JlbWVudChvcHRpb25zLCBzbWFsbGVzdFVuaXQpO1xuICAgICAgICBsZXQgeyB5ZWFycywgbW9udGhzLCB3ZWVrcywgZGF5cywgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc2Vjb25kcywgbWljcm9zZWNvbmRzLCBuYW5vc2Vjb25kcyB9ID0gRGlmZmVyZW5jZUlTT0RhdGVUaW1lKEdldFNsb3QodGhpcywgSVNPX1lFQVIpLCBHZXRTbG90KHRoaXMsIElTT19NT05USCksIEdldFNsb3QodGhpcywgSVNPX0RBWSksIEdldFNsb3QodGhpcywgSVNPX0hPVVIpLCBHZXRTbG90KHRoaXMsIElTT19NSU5VVEUpLCBHZXRTbG90KHRoaXMsIElTT19TRUNPTkQpLCBHZXRTbG90KHRoaXMsIElTT19NSUxMSVNFQ09ORCksIEdldFNsb3QodGhpcywgSVNPX01JQ1JPU0VDT05EKSwgR2V0U2xvdCh0aGlzLCBJU09fTkFOT1NFQ09ORCksIEdldFNsb3Qob3RoZXIsIElTT19ZRUFSKSwgR2V0U2xvdChvdGhlciwgSVNPX01PTlRIKSwgR2V0U2xvdChvdGhlciwgSVNPX0RBWSksIEdldFNsb3Qob3RoZXIsIElTT19IT1VSKSwgR2V0U2xvdChvdGhlciwgSVNPX01JTlVURSksIEdldFNsb3Qob3RoZXIsIElTT19TRUNPTkQpLCBHZXRTbG90KG90aGVyLCBJU09fTUlMTElTRUNPTkQpLCBHZXRTbG90KG90aGVyLCBJU09fTUlDUk9TRUNPTkQpLCBHZXRTbG90KG90aGVyLCBJU09fTkFOT1NFQ09ORCksIGNhbGVuZGFyLCBsYXJnZXN0VW5pdCwgb3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IHJlbGF0aXZlVG8gPSBUZW1wb3JhbERhdGVUaW1lVG9EYXRlKHRoaXMpO1xuICAgICAgICAoeyB5ZWFycywgbW9udGhzLCB3ZWVrcywgZGF5cywgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc2Vjb25kcywgbWljcm9zZWNvbmRzLCBuYW5vc2Vjb25kcyB9ID1cbiAgICAgICAgICAgIFJvdW5kRHVyYXRpb24oeWVhcnMsIG1vbnRocywgd2Vla3MsIGRheXMsIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBtaWxsaXNlY29uZHMsIG1pY3Jvc2Vjb25kcywgbmFub3NlY29uZHMsIHJvdW5kaW5nSW5jcmVtZW50LCBzbWFsbGVzdFVuaXQsIE5lZ2F0ZVRlbXBvcmFsUm91bmRpbmdNb2RlKHJvdW5kaW5nTW9kZSksIHJlbGF0aXZlVG8pKTtcbiAgICAgICAgKHsgZGF5cywgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc2Vjb25kcywgbWljcm9zZWNvbmRzLCBuYW5vc2Vjb25kcyB9ID0gQmFsYW5jZUR1cmF0aW9uKGRheXMsIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBtaWxsaXNlY29uZHMsIG1pY3Jvc2Vjb25kcywgbmFub3NlY29uZHMsIGxhcmdlc3RVbml0KSk7XG4gICAgICAgIGNvbnN0IER1cmF0aW9uID0gR2V0SW50cmluc2ljKCclVGVtcG9yYWwuRHVyYXRpb24lJyk7XG4gICAgICAgIHJldHVybiBuZXcgRHVyYXRpb24oLXllYXJzLCAtbW9udGhzLCAtd2Vla3MsIC1kYXlzLCAtaG91cnMsIC1taW51dGVzLCAtc2Vjb25kcywgLW1pbGxpc2Vjb25kcywgLW1pY3Jvc2Vjb25kcywgLW5hbm9zZWNvbmRzKTtcbiAgICB9XG4gICAgcm91bmQob3B0aW9uc1BhcmFtKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbERhdGVUaW1lKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICBpZiAob3B0aW9uc1BhcmFtID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdvcHRpb25zIHBhcmFtZXRlciBpcyByZXF1aXJlZCcpO1xuICAgICAgICBjb25zdCBvcHRpb25zID0gdHlwZW9mIG9wdGlvbnNQYXJhbSA9PT0gJ3N0cmluZydcbiAgICAgICAgICAgID8gQ3JlYXRlT25lUHJvcE9iamVjdCgnc21hbGxlc3RVbml0Jywgb3B0aW9uc1BhcmFtKVxuICAgICAgICAgICAgOiBHZXRPcHRpb25zT2JqZWN0KG9wdGlvbnNQYXJhbSk7XG4gICAgICAgIGNvbnN0IHNtYWxsZXN0VW5pdCA9IFRvU21hbGxlc3RUZW1wb3JhbFVuaXQob3B0aW9ucywgdW5kZWZpbmVkLCBbJ3llYXInLCAnbW9udGgnLCAnd2VlayddKTtcbiAgICAgICAgaWYgKHNtYWxsZXN0VW5pdCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NtYWxsZXN0VW5pdCBpcyByZXF1aXJlZCcpO1xuICAgICAgICBjb25zdCByb3VuZGluZ01vZGUgPSBUb1RlbXBvcmFsUm91bmRpbmdNb2RlKG9wdGlvbnMsICdoYWxmRXhwYW5kJyk7XG4gICAgICAgIGNvbnN0IG1heGltdW1JbmNyZW1lbnRzID0ge1xuICAgICAgICAgICAgZGF5OiAxLFxuICAgICAgICAgICAgaG91cjogMjQsXG4gICAgICAgICAgICBtaW51dGU6IDYwLFxuICAgICAgICAgICAgc2Vjb25kOiA2MCxcbiAgICAgICAgICAgIG1pbGxpc2Vjb25kOiAxMDAwLFxuICAgICAgICAgICAgbWljcm9zZWNvbmQ6IDEwMDAsXG4gICAgICAgICAgICBuYW5vc2Vjb25kOiAxMDAwXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJvdW5kaW5nSW5jcmVtZW50ID0gVG9UZW1wb3JhbFJvdW5kaW5nSW5jcmVtZW50KG9wdGlvbnMsIG1heGltdW1JbmNyZW1lbnRzW3NtYWxsZXN0VW5pdF0sIGZhbHNlKTtcbiAgICAgICAgbGV0IHllYXIgPSBHZXRTbG90KHRoaXMsIElTT19ZRUFSKTtcbiAgICAgICAgbGV0IG1vbnRoID0gR2V0U2xvdCh0aGlzLCBJU09fTU9OVEgpO1xuICAgICAgICBsZXQgZGF5ID0gR2V0U2xvdCh0aGlzLCBJU09fREFZKTtcbiAgICAgICAgbGV0IGhvdXIgPSBHZXRTbG90KHRoaXMsIElTT19IT1VSKTtcbiAgICAgICAgbGV0IG1pbnV0ZSA9IEdldFNsb3QodGhpcywgSVNPX01JTlVURSk7XG4gICAgICAgIGxldCBzZWNvbmQgPSBHZXRTbG90KHRoaXMsIElTT19TRUNPTkQpO1xuICAgICAgICBsZXQgbWlsbGlzZWNvbmQgPSBHZXRTbG90KHRoaXMsIElTT19NSUxMSVNFQ09ORCk7XG4gICAgICAgIGxldCBtaWNyb3NlY29uZCA9IEdldFNsb3QodGhpcywgSVNPX01JQ1JPU0VDT05EKTtcbiAgICAgICAgbGV0IG5hbm9zZWNvbmQgPSBHZXRTbG90KHRoaXMsIElTT19OQU5PU0VDT05EKTtcbiAgICAgICAgKHsgeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kLCBtaWNyb3NlY29uZCwgbmFub3NlY29uZCB9ID0gUm91bmRJU09EYXRlVGltZSh5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQsIG1pY3Jvc2Vjb25kLCBuYW5vc2Vjb25kLCByb3VuZGluZ0luY3JlbWVudCwgc21hbGxlc3RVbml0LCByb3VuZGluZ01vZGUpKTtcbiAgICAgICAgcmV0dXJuIENyZWF0ZVRlbXBvcmFsRGF0ZVRpbWUoeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kLCBtaWNyb3NlY29uZCwgbmFub3NlY29uZCwgR2V0U2xvdCh0aGlzLCBDQUxFTkRBUikpO1xuICAgIH1cbiAgICBlcXVhbHMob3RoZXJQYXJhbSkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxEYXRlVGltZSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgY29uc3Qgb3RoZXIgPSBUb1RlbXBvcmFsRGF0ZVRpbWUob3RoZXJQYXJhbSk7XG4gICAgICAgIGZvciAoY29uc3Qgc2xvdCBvZiBbXG4gICAgICAgICAgICBJU09fWUVBUixcbiAgICAgICAgICAgIElTT19NT05USCxcbiAgICAgICAgICAgIElTT19EQVksXG4gICAgICAgICAgICBJU09fSE9VUixcbiAgICAgICAgICAgIElTT19NSU5VVEUsXG4gICAgICAgICAgICBJU09fU0VDT05ELFxuICAgICAgICAgICAgSVNPX01JTExJU0VDT05ELFxuICAgICAgICAgICAgSVNPX01JQ1JPU0VDT05ELFxuICAgICAgICAgICAgSVNPX05BTk9TRUNPTkRcbiAgICAgICAgXSkge1xuICAgICAgICAgICAgY29uc3QgdmFsMSA9IEdldFNsb3QodGhpcywgc2xvdCk7XG4gICAgICAgICAgICBjb25zdCB2YWwyID0gR2V0U2xvdChvdGhlciwgc2xvdCk7XG4gICAgICAgICAgICBpZiAodmFsMSAhPT0gdmFsMilcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIENhbGVuZGFyRXF1YWxzKEdldFNsb3QodGhpcywgQ0FMRU5EQVIpLCBHZXRTbG90KG90aGVyLCBDQUxFTkRBUikpO1xuICAgIH1cbiAgICB0b1N0cmluZyhvcHRpb25zUGFyYW0gPSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsRGF0ZVRpbWUodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSBHZXRPcHRpb25zT2JqZWN0KG9wdGlvbnNQYXJhbSk7XG4gICAgICAgIGNvbnN0IHsgcHJlY2lzaW9uLCB1bml0LCBpbmNyZW1lbnQgfSA9IFRvU2Vjb25kc1N0cmluZ1ByZWNpc2lvbihvcHRpb25zKTtcbiAgICAgICAgY29uc3Qgc2hvd0NhbGVuZGFyID0gVG9TaG93Q2FsZW5kYXJPcHRpb24ob3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IHJvdW5kaW5nTW9kZSA9IFRvVGVtcG9yYWxSb3VuZGluZ01vZGUob3B0aW9ucywgJ3RydW5jJyk7XG4gICAgICAgIHJldHVybiBUZW1wb3JhbERhdGVUaW1lVG9TdHJpbmcodGhpcywgcHJlY2lzaW9uLCBzaG93Q2FsZW5kYXIsIHsgdW5pdCwgaW5jcmVtZW50LCByb3VuZGluZ01vZGUgfSk7XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsRGF0ZVRpbWUodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIHJldHVybiBUZW1wb3JhbERhdGVUaW1lVG9TdHJpbmcodGhpcywgJ2F1dG8nKTtcbiAgICB9XG4gICAgdG9Mb2NhbGVTdHJpbmcobG9jYWxlcyA9IHVuZGVmaW5lZCwgb3B0aW9ucyA9IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxEYXRlVGltZSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlVGltZUZvcm1hdChsb2NhbGVzLCBvcHRpb25zKS5mb3JtYXQodGhpcyk7XG4gICAgfVxuICAgIHZhbHVlT2YoKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3VzZSBjb21wYXJlKCkgb3IgZXF1YWxzKCkgdG8gY29tcGFyZSBUZW1wb3JhbC5QbGFpbkRhdGVUaW1lJyk7XG4gICAgfVxuICAgIHRvWm9uZWREYXRlVGltZSh0ZW1wb3JhbFRpbWVab25lTGlrZSwgb3B0aW9uc1BhcmFtID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbERhdGVUaW1lKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICBjb25zdCB0aW1lWm9uZSA9IFRvVGVtcG9yYWxUaW1lWm9uZSh0ZW1wb3JhbFRpbWVab25lTGlrZSk7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSBHZXRPcHRpb25zT2JqZWN0KG9wdGlvbnNQYXJhbSk7XG4gICAgICAgIGNvbnN0IGRpc2FtYmlndWF0aW9uID0gVG9UZW1wb3JhbERpc2FtYmlndWF0aW9uKG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBpbnN0YW50ID0gQnVpbHRpblRpbWVab25lR2V0SW5zdGFudEZvcih0aW1lWm9uZSwgdGhpcywgZGlzYW1iaWd1YXRpb24pO1xuICAgICAgICByZXR1cm4gQ3JlYXRlVGVtcG9yYWxab25lZERhdGVUaW1lKEdldFNsb3QoaW5zdGFudCwgRVBPQ0hOQU5PU0VDT05EUyksIHRpbWVab25lLCBHZXRTbG90KHRoaXMsIENBTEVOREFSKSk7XG4gICAgfVxuICAgIHRvUGxhaW5EYXRlKCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxEYXRlVGltZSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgcmV0dXJuIFRlbXBvcmFsRGF0ZVRpbWVUb0RhdGUodGhpcyk7XG4gICAgfVxuICAgIHRvUGxhaW5ZZWFyTW9udGgoKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbERhdGVUaW1lKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICBjb25zdCBjYWxlbmRhciA9IEdldFNsb3QodGhpcywgQ0FMRU5EQVIpO1xuICAgICAgICBjb25zdCBmaWVsZE5hbWVzID0gQ2FsZW5kYXJGaWVsZHMoY2FsZW5kYXIsIFsnbW9udGhDb2RlJywgJ3llYXInXSk7XG4gICAgICAgIGNvbnN0IGZpZWxkcyA9IFRvVGVtcG9yYWxZZWFyTW9udGhGaWVsZHModGhpcywgZmllbGROYW1lcyk7XG4gICAgICAgIHJldHVybiBZZWFyTW9udGhGcm9tRmllbGRzKGNhbGVuZGFyLCBmaWVsZHMpO1xuICAgIH1cbiAgICB0b1BsYWluTW9udGhEYXkoKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbERhdGVUaW1lKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICBjb25zdCBjYWxlbmRhciA9IEdldFNsb3QodGhpcywgQ0FMRU5EQVIpO1xuICAgICAgICBjb25zdCBmaWVsZE5hbWVzID0gQ2FsZW5kYXJGaWVsZHMoY2FsZW5kYXIsIFsnZGF5JywgJ21vbnRoQ29kZSddKTtcbiAgICAgICAgY29uc3QgZmllbGRzID0gVG9UZW1wb3JhbE1vbnRoRGF5RmllbGRzKHRoaXMsIGZpZWxkTmFtZXMpO1xuICAgICAgICByZXR1cm4gTW9udGhEYXlGcm9tRmllbGRzKGNhbGVuZGFyLCBmaWVsZHMpO1xuICAgIH1cbiAgICB0b1BsYWluVGltZSgpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsRGF0ZVRpbWUodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIHJldHVybiBUZW1wb3JhbERhdGVUaW1lVG9UaW1lKHRoaXMpO1xuICAgIH1cbiAgICBnZXRJU09GaWVsZHMoKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbERhdGVUaW1lKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY2FsZW5kYXI6IEdldFNsb3QodGhpcywgQ0FMRU5EQVIpLFxuICAgICAgICAgICAgaXNvRGF5OiBHZXRTbG90KHRoaXMsIElTT19EQVkpLFxuICAgICAgICAgICAgaXNvSG91cjogR2V0U2xvdCh0aGlzLCBJU09fSE9VUiksXG4gICAgICAgICAgICBpc29NaWNyb3NlY29uZDogR2V0U2xvdCh0aGlzLCBJU09fTUlDUk9TRUNPTkQpLFxuICAgICAgICAgICAgaXNvTWlsbGlzZWNvbmQ6IEdldFNsb3QodGhpcywgSVNPX01JTExJU0VDT05EKSxcbiAgICAgICAgICAgIGlzb01pbnV0ZTogR2V0U2xvdCh0aGlzLCBJU09fTUlOVVRFKSxcbiAgICAgICAgICAgIGlzb01vbnRoOiBHZXRTbG90KHRoaXMsIElTT19NT05USCksXG4gICAgICAgICAgICBpc29OYW5vc2Vjb25kOiBHZXRTbG90KHRoaXMsIElTT19OQU5PU0VDT05EKSxcbiAgICAgICAgICAgIGlzb1NlY29uZDogR2V0U2xvdCh0aGlzLCBJU09fU0VDT05EKSxcbiAgICAgICAgICAgIGlzb1llYXI6IEdldFNsb3QodGhpcywgSVNPX1lFQVIpXG4gICAgICAgIH07XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tKGl0ZW0sIG9wdGlvbnNQYXJhbSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCBvcHRpb25zID0gR2V0T3B0aW9uc09iamVjdChvcHRpb25zUGFyYW0pO1xuICAgICAgICBpZiAoSXNUZW1wb3JhbERhdGVUaW1lKGl0ZW0pKSB7XG4gICAgICAgICAgICBUb1RlbXBvcmFsT3ZlcmZsb3cob3B0aW9ucyk7IC8vIHZhbGlkYXRlIGFuZCBpZ25vcmVcbiAgICAgICAgICAgIHJldHVybiBDcmVhdGVUZW1wb3JhbERhdGVUaW1lKEdldFNsb3QoaXRlbSwgSVNPX1lFQVIpLCBHZXRTbG90KGl0ZW0sIElTT19NT05USCksIEdldFNsb3QoaXRlbSwgSVNPX0RBWSksIEdldFNsb3QoaXRlbSwgSVNPX0hPVVIpLCBHZXRTbG90KGl0ZW0sIElTT19NSU5VVEUpLCBHZXRTbG90KGl0ZW0sIElTT19TRUNPTkQpLCBHZXRTbG90KGl0ZW0sIElTT19NSUxMSVNFQ09ORCksIEdldFNsb3QoaXRlbSwgSVNPX01JQ1JPU0VDT05EKSwgR2V0U2xvdChpdGVtLCBJU09fTkFOT1NFQ09ORCksIEdldFNsb3QoaXRlbSwgQ0FMRU5EQVIpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gVG9UZW1wb3JhbERhdGVUaW1lKGl0ZW0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBzdGF0aWMgY29tcGFyZShvbmVQYXJhbSwgdHdvUGFyYW0pIHtcbiAgICAgICAgY29uc3Qgb25lID0gVG9UZW1wb3JhbERhdGVUaW1lKG9uZVBhcmFtKTtcbiAgICAgICAgY29uc3QgdHdvID0gVG9UZW1wb3JhbERhdGVUaW1lKHR3b1BhcmFtKTtcbiAgICAgICAgZm9yIChjb25zdCBzbG90IG9mIFtcbiAgICAgICAgICAgIElTT19ZRUFSLFxuICAgICAgICAgICAgSVNPX01PTlRILFxuICAgICAgICAgICAgSVNPX0RBWSxcbiAgICAgICAgICAgIElTT19IT1VSLFxuICAgICAgICAgICAgSVNPX01JTlVURSxcbiAgICAgICAgICAgIElTT19TRUNPTkQsXG4gICAgICAgICAgICBJU09fTUlMTElTRUNPTkQsXG4gICAgICAgICAgICBJU09fTUlDUk9TRUNPTkQsXG4gICAgICAgICAgICBJU09fTkFOT1NFQ09ORFxuICAgICAgICBdKSB7XG4gICAgICAgICAgICBjb25zdCB2YWwxID0gR2V0U2xvdChvbmUsIHNsb3QpO1xuICAgICAgICAgICAgY29uc3QgdmFsMiA9IEdldFNsb3QodHdvLCBzbG90KTtcbiAgICAgICAgICAgIGlmICh2YWwxICE9PSB2YWwyKVxuICAgICAgICAgICAgICAgIHJldHVybiBDb21wYXJpc29uUmVzdWx0KHZhbDEgLSB2YWwyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG59XG5NYWtlSW50cmluc2ljQ2xhc3MoUGxhaW5EYXRlVGltZSwgJ1RlbXBvcmFsLlBsYWluRGF0ZVRpbWUnKTtcblxuY2xhc3MgRHVyYXRpb24ge1xuICAgIGNvbnN0cnVjdG9yKHllYXJzUGFyYW0gPSAwLCBtb250aHNQYXJhbSA9IDAsIHdlZWtzUGFyYW0gPSAwLCBkYXlzUGFyYW0gPSAwLCBob3Vyc1BhcmFtID0gMCwgbWludXRlc1BhcmFtID0gMCwgc2Vjb25kc1BhcmFtID0gMCwgbWlsbGlzZWNvbmRzUGFyYW0gPSAwLCBtaWNyb3NlY29uZHNQYXJhbSA9IDAsIG5hbm9zZWNvbmRzUGFyYW0gPSAwKSB7XG4gICAgICAgIGNvbnN0IHllYXJzID0gVG9JbnRlZ2VyV2l0aG91dFJvdW5kaW5nKHllYXJzUGFyYW0pO1xuICAgICAgICBjb25zdCBtb250aHMgPSBUb0ludGVnZXJXaXRob3V0Um91bmRpbmcobW9udGhzUGFyYW0pO1xuICAgICAgICBjb25zdCB3ZWVrcyA9IFRvSW50ZWdlcldpdGhvdXRSb3VuZGluZyh3ZWVrc1BhcmFtKTtcbiAgICAgICAgY29uc3QgZGF5cyA9IFRvSW50ZWdlcldpdGhvdXRSb3VuZGluZyhkYXlzUGFyYW0pO1xuICAgICAgICBjb25zdCBob3VycyA9IFRvSW50ZWdlcldpdGhvdXRSb3VuZGluZyhob3Vyc1BhcmFtKTtcbiAgICAgICAgY29uc3QgbWludXRlcyA9IFRvSW50ZWdlcldpdGhvdXRSb3VuZGluZyhtaW51dGVzUGFyYW0pO1xuICAgICAgICBjb25zdCBzZWNvbmRzID0gVG9JbnRlZ2VyV2l0aG91dFJvdW5kaW5nKHNlY29uZHNQYXJhbSk7XG4gICAgICAgIGNvbnN0IG1pbGxpc2Vjb25kcyA9IFRvSW50ZWdlcldpdGhvdXRSb3VuZGluZyhtaWxsaXNlY29uZHNQYXJhbSk7XG4gICAgICAgIGNvbnN0IG1pY3Jvc2Vjb25kcyA9IFRvSW50ZWdlcldpdGhvdXRSb3VuZGluZyhtaWNyb3NlY29uZHNQYXJhbSk7XG4gICAgICAgIGNvbnN0IG5hbm9zZWNvbmRzID0gVG9JbnRlZ2VyV2l0aG91dFJvdW5kaW5nKG5hbm9zZWNvbmRzUGFyYW0pO1xuICAgICAgICBjb25zdCBzaWduID0gRHVyYXRpb25TaWduKHllYXJzLCBtb250aHMsIHdlZWtzLCBkYXlzLCBob3VycywgbWludXRlcywgc2Vjb25kcywgbWlsbGlzZWNvbmRzLCBtaWNyb3NlY29uZHMsIG5hbm9zZWNvbmRzKTtcbiAgICAgICAgZm9yIChjb25zdCBwcm9wIG9mIFt5ZWFycywgbW9udGhzLCB3ZWVrcywgZGF5cywgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc2Vjb25kcywgbWljcm9zZWNvbmRzLCBuYW5vc2Vjb25kc10pIHtcbiAgICAgICAgICAgIGlmICghTnVtYmVyLmlzRmluaXRlKHByb3ApKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdpbmZpbml0ZSB2YWx1ZXMgbm90IGFsbG93ZWQgYXMgZHVyYXRpb24gZmllbGRzJyk7XG4gICAgICAgICAgICBjb25zdCBwcm9wU2lnbiA9IE1hdGguc2lnbihwcm9wKTtcbiAgICAgICAgICAgIGlmIChwcm9wU2lnbiAhPT0gMCAmJiBwcm9wU2lnbiAhPT0gc2lnbilcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignbWl4ZWQtc2lnbiB2YWx1ZXMgbm90IGFsbG93ZWQgYXMgZHVyYXRpb24gZmllbGRzJyk7XG4gICAgICAgIH1cbiAgICAgICAgQ3JlYXRlU2xvdHModGhpcyk7XG4gICAgICAgIFNldFNsb3QodGhpcywgWUVBUlMsIHllYXJzKTtcbiAgICAgICAgU2V0U2xvdCh0aGlzLCBNT05USFMsIG1vbnRocyk7XG4gICAgICAgIFNldFNsb3QodGhpcywgV0VFS1MsIHdlZWtzKTtcbiAgICAgICAgU2V0U2xvdCh0aGlzLCBEQVlTLCBkYXlzKTtcbiAgICAgICAgU2V0U2xvdCh0aGlzLCBIT1VSUywgaG91cnMpO1xuICAgICAgICBTZXRTbG90KHRoaXMsIE1JTlVURVMsIG1pbnV0ZXMpO1xuICAgICAgICBTZXRTbG90KHRoaXMsIFNFQ09ORFMsIHNlY29uZHMpO1xuICAgICAgICBTZXRTbG90KHRoaXMsIE1JTExJU0VDT05EUywgbWlsbGlzZWNvbmRzKTtcbiAgICAgICAgU2V0U2xvdCh0aGlzLCBNSUNST1NFQ09ORFMsIG1pY3Jvc2Vjb25kcyk7XG4gICAgICAgIFNldFNsb3QodGhpcywgTkFOT1NFQ09ORFMsIG5hbm9zZWNvbmRzKTtcbiAgICAgICAge1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdfcmVwcl8nLCB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IGAke3RoaXNbU3ltYm9sLnRvU3RyaW5nVGFnXX0gPCR7VGVtcG9yYWxEdXJhdGlvblRvU3RyaW5nKHRoaXMpfT5gLFxuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgeWVhcnMoKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbER1cmF0aW9uKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICByZXR1cm4gR2V0U2xvdCh0aGlzLCBZRUFSUyk7XG4gICAgfVxuICAgIGdldCBtb250aHMoKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbER1cmF0aW9uKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICByZXR1cm4gR2V0U2xvdCh0aGlzLCBNT05USFMpO1xuICAgIH1cbiAgICBnZXQgd2Vla3MoKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbER1cmF0aW9uKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICByZXR1cm4gR2V0U2xvdCh0aGlzLCBXRUVLUyk7XG4gICAgfVxuICAgIGdldCBkYXlzKCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxEdXJhdGlvbih0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgcmV0dXJuIEdldFNsb3QodGhpcywgREFZUyk7XG4gICAgfVxuICAgIGdldCBob3VycygpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsRHVyYXRpb24odGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIHJldHVybiBHZXRTbG90KHRoaXMsIEhPVVJTKTtcbiAgICB9XG4gICAgZ2V0IG1pbnV0ZXMoKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbER1cmF0aW9uKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICByZXR1cm4gR2V0U2xvdCh0aGlzLCBNSU5VVEVTKTtcbiAgICB9XG4gICAgZ2V0IHNlY29uZHMoKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbER1cmF0aW9uKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICByZXR1cm4gR2V0U2xvdCh0aGlzLCBTRUNPTkRTKTtcbiAgICB9XG4gICAgZ2V0IG1pbGxpc2Vjb25kcygpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsRHVyYXRpb24odGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIHJldHVybiBHZXRTbG90KHRoaXMsIE1JTExJU0VDT05EUyk7XG4gICAgfVxuICAgIGdldCBtaWNyb3NlY29uZHMoKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbER1cmF0aW9uKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICByZXR1cm4gR2V0U2xvdCh0aGlzLCBNSUNST1NFQ09ORFMpO1xuICAgIH1cbiAgICBnZXQgbmFub3NlY29uZHMoKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbER1cmF0aW9uKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICByZXR1cm4gR2V0U2xvdCh0aGlzLCBOQU5PU0VDT05EUyk7XG4gICAgfVxuICAgIGdldCBzaWduKCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxEdXJhdGlvbih0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgcmV0dXJuIER1cmF0aW9uU2lnbihHZXRTbG90KHRoaXMsIFlFQVJTKSwgR2V0U2xvdCh0aGlzLCBNT05USFMpLCBHZXRTbG90KHRoaXMsIFdFRUtTKSwgR2V0U2xvdCh0aGlzLCBEQVlTKSwgR2V0U2xvdCh0aGlzLCBIT1VSUyksIEdldFNsb3QodGhpcywgTUlOVVRFUyksIEdldFNsb3QodGhpcywgU0VDT05EUyksIEdldFNsb3QodGhpcywgTUlMTElTRUNPTkRTKSwgR2V0U2xvdCh0aGlzLCBNSUNST1NFQ09ORFMpLCBHZXRTbG90KHRoaXMsIE5BTk9TRUNPTkRTKSk7XG4gICAgfVxuICAgIGdldCBibGFuaygpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsRHVyYXRpb24odGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIHJldHVybiAoRHVyYXRpb25TaWduKEdldFNsb3QodGhpcywgWUVBUlMpLCBHZXRTbG90KHRoaXMsIE1PTlRIUyksIEdldFNsb3QodGhpcywgV0VFS1MpLCBHZXRTbG90KHRoaXMsIERBWVMpLCBHZXRTbG90KHRoaXMsIEhPVVJTKSwgR2V0U2xvdCh0aGlzLCBNSU5VVEVTKSwgR2V0U2xvdCh0aGlzLCBTRUNPTkRTKSwgR2V0U2xvdCh0aGlzLCBNSUxMSVNFQ09ORFMpLCBHZXRTbG90KHRoaXMsIE1JQ1JPU0VDT05EUyksIEdldFNsb3QodGhpcywgTkFOT1NFQ09ORFMpKSA9PT0gMCk7XG4gICAgfVxuICAgIHdpdGgoZHVyYXRpb25MaWtlKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbER1cmF0aW9uKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICBjb25zdCBwcm9wcyA9IFRvUGFydGlhbFJlY29yZChkdXJhdGlvbkxpa2UsIFtcbiAgICAgICAgICAgICdkYXlzJyxcbiAgICAgICAgICAgICdob3VycycsXG4gICAgICAgICAgICAnbWljcm9zZWNvbmRzJyxcbiAgICAgICAgICAgICdtaWxsaXNlY29uZHMnLFxuICAgICAgICAgICAgJ21pbnV0ZXMnLFxuICAgICAgICAgICAgJ21vbnRocycsXG4gICAgICAgICAgICAnbmFub3NlY29uZHMnLFxuICAgICAgICAgICAgJ3NlY29uZHMnLFxuICAgICAgICAgICAgJ3dlZWtzJyxcbiAgICAgICAgICAgICd5ZWFycydcbiAgICAgICAgXSk7XG4gICAgICAgIGlmICghcHJvcHMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgZHVyYXRpb24tbGlrZScpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgeWVhcnMgPSBHZXRTbG90KHRoaXMsIFlFQVJTKSwgbW9udGhzID0gR2V0U2xvdCh0aGlzLCBNT05USFMpLCB3ZWVrcyA9IEdldFNsb3QodGhpcywgV0VFS1MpLCBkYXlzID0gR2V0U2xvdCh0aGlzLCBEQVlTKSwgaG91cnMgPSBHZXRTbG90KHRoaXMsIEhPVVJTKSwgbWludXRlcyA9IEdldFNsb3QodGhpcywgTUlOVVRFUyksIHNlY29uZHMgPSBHZXRTbG90KHRoaXMsIFNFQ09ORFMpLCBtaWxsaXNlY29uZHMgPSBHZXRTbG90KHRoaXMsIE1JTExJU0VDT05EUyksIG1pY3Jvc2Vjb25kcyA9IEdldFNsb3QodGhpcywgTUlDUk9TRUNPTkRTKSwgbmFub3NlY29uZHMgPSBHZXRTbG90KHRoaXMsIE5BTk9TRUNPTkRTKSB9ID0gcHJvcHM7XG4gICAgICAgIHJldHVybiBuZXcgRHVyYXRpb24oeWVhcnMsIG1vbnRocywgd2Vla3MsIGRheXMsIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBtaWxsaXNlY29uZHMsIG1pY3Jvc2Vjb25kcywgbmFub3NlY29uZHMpO1xuICAgIH1cbiAgICBuZWdhdGVkKCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxEdXJhdGlvbih0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgcmV0dXJuIENyZWF0ZU5lZ2F0ZWRUZW1wb3JhbER1cmF0aW9uKHRoaXMpO1xuICAgIH1cbiAgICBhYnMoKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbER1cmF0aW9uKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICByZXR1cm4gbmV3IER1cmF0aW9uKE1hdGguYWJzKEdldFNsb3QodGhpcywgWUVBUlMpKSwgTWF0aC5hYnMoR2V0U2xvdCh0aGlzLCBNT05USFMpKSwgTWF0aC5hYnMoR2V0U2xvdCh0aGlzLCBXRUVLUykpLCBNYXRoLmFicyhHZXRTbG90KHRoaXMsIERBWVMpKSwgTWF0aC5hYnMoR2V0U2xvdCh0aGlzLCBIT1VSUykpLCBNYXRoLmFicyhHZXRTbG90KHRoaXMsIE1JTlVURVMpKSwgTWF0aC5hYnMoR2V0U2xvdCh0aGlzLCBTRUNPTkRTKSksIE1hdGguYWJzKEdldFNsb3QodGhpcywgTUlMTElTRUNPTkRTKSksIE1hdGguYWJzKEdldFNsb3QodGhpcywgTUlDUk9TRUNPTkRTKSksIE1hdGguYWJzKEdldFNsb3QodGhpcywgTkFOT1NFQ09ORFMpKSk7XG4gICAgfVxuICAgIGFkZChvdGhlciwgb3B0aW9uc1BhcmFtID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbER1cmF0aW9uKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICBsZXQgeyB5ZWFycywgbW9udGhzLCB3ZWVrcywgZGF5cywgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc2Vjb25kcywgbWljcm9zZWNvbmRzLCBuYW5vc2Vjb25kcyB9ID0gVG9MaW1pdGVkVGVtcG9yYWxEdXJhdGlvbihvdGhlcik7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSBHZXRPcHRpb25zT2JqZWN0KG9wdGlvbnNQYXJhbSk7XG4gICAgICAgIGNvbnN0IHJlbGF0aXZlVG8gPSBUb1JlbGF0aXZlVGVtcG9yYWxPYmplY3Qob3B0aW9ucyk7XG4gICAgICAgICh7IHllYXJzLCBtb250aHMsIHdlZWtzLCBkYXlzLCBob3VycywgbWludXRlcywgc2Vjb25kcywgbWlsbGlzZWNvbmRzLCBtaWNyb3NlY29uZHMsIG5hbm9zZWNvbmRzIH0gPSBBZGREdXJhdGlvbihHZXRTbG90KHRoaXMsIFlFQVJTKSwgR2V0U2xvdCh0aGlzLCBNT05USFMpLCBHZXRTbG90KHRoaXMsIFdFRUtTKSwgR2V0U2xvdCh0aGlzLCBEQVlTKSwgR2V0U2xvdCh0aGlzLCBIT1VSUyksIEdldFNsb3QodGhpcywgTUlOVVRFUyksIEdldFNsb3QodGhpcywgU0VDT05EUyksIEdldFNsb3QodGhpcywgTUlMTElTRUNPTkRTKSwgR2V0U2xvdCh0aGlzLCBNSUNST1NFQ09ORFMpLCBHZXRTbG90KHRoaXMsIE5BTk9TRUNPTkRTKSwgeWVhcnMsIG1vbnRocywgd2Vla3MsIGRheXMsIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBtaWxsaXNlY29uZHMsIG1pY3Jvc2Vjb25kcywgbmFub3NlY29uZHMsIHJlbGF0aXZlVG8pKTtcbiAgICAgICAgcmV0dXJuIG5ldyBEdXJhdGlvbih5ZWFycywgbW9udGhzLCB3ZWVrcywgZGF5cywgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc2Vjb25kcywgbWljcm9zZWNvbmRzLCBuYW5vc2Vjb25kcyk7XG4gICAgfVxuICAgIHN1YnRyYWN0KG90aGVyLCBvcHRpb25zUGFyYW0gPSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsRHVyYXRpb24odGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIGxldCB7IHllYXJzLCBtb250aHMsIHdlZWtzLCBkYXlzLCBob3VycywgbWludXRlcywgc2Vjb25kcywgbWlsbGlzZWNvbmRzLCBtaWNyb3NlY29uZHMsIG5hbm9zZWNvbmRzIH0gPSBUb0xpbWl0ZWRUZW1wb3JhbER1cmF0aW9uKG90aGVyKTtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IEdldE9wdGlvbnNPYmplY3Qob3B0aW9uc1BhcmFtKTtcbiAgICAgICAgY29uc3QgcmVsYXRpdmVUbyA9IFRvUmVsYXRpdmVUZW1wb3JhbE9iamVjdChvcHRpb25zKTtcbiAgICAgICAgKHsgeWVhcnMsIG1vbnRocywgd2Vla3MsIGRheXMsIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBtaWxsaXNlY29uZHMsIG1pY3Jvc2Vjb25kcywgbmFub3NlY29uZHMgfSA9IEFkZER1cmF0aW9uKEdldFNsb3QodGhpcywgWUVBUlMpLCBHZXRTbG90KHRoaXMsIE1PTlRIUyksIEdldFNsb3QodGhpcywgV0VFS1MpLCBHZXRTbG90KHRoaXMsIERBWVMpLCBHZXRTbG90KHRoaXMsIEhPVVJTKSwgR2V0U2xvdCh0aGlzLCBNSU5VVEVTKSwgR2V0U2xvdCh0aGlzLCBTRUNPTkRTKSwgR2V0U2xvdCh0aGlzLCBNSUxMSVNFQ09ORFMpLCBHZXRTbG90KHRoaXMsIE1JQ1JPU0VDT05EUyksIEdldFNsb3QodGhpcywgTkFOT1NFQ09ORFMpLCAteWVhcnMsIC1tb250aHMsIC13ZWVrcywgLWRheXMsIC1ob3VycywgLW1pbnV0ZXMsIC1zZWNvbmRzLCAtbWlsbGlzZWNvbmRzLCAtbWljcm9zZWNvbmRzLCAtbmFub3NlY29uZHMsIHJlbGF0aXZlVG8pKTtcbiAgICAgICAgcmV0dXJuIG5ldyBEdXJhdGlvbih5ZWFycywgbW9udGhzLCB3ZWVrcywgZGF5cywgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc2Vjb25kcywgbWljcm9zZWNvbmRzLCBuYW5vc2Vjb25kcyk7XG4gICAgfVxuICAgIHJvdW5kKG9wdGlvbnNQYXJhbSkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxEdXJhdGlvbih0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgaWYgKG9wdGlvbnNQYXJhbSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignb3B0aW9ucyBwYXJhbWV0ZXIgaXMgcmVxdWlyZWQnKTtcbiAgICAgICAgbGV0IHllYXJzID0gR2V0U2xvdCh0aGlzLCBZRUFSUyk7XG4gICAgICAgIGxldCBtb250aHMgPSBHZXRTbG90KHRoaXMsIE1PTlRIUyk7XG4gICAgICAgIGxldCB3ZWVrcyA9IEdldFNsb3QodGhpcywgV0VFS1MpO1xuICAgICAgICBsZXQgZGF5cyA9IEdldFNsb3QodGhpcywgREFZUyk7XG4gICAgICAgIGxldCBob3VycyA9IEdldFNsb3QodGhpcywgSE9VUlMpO1xuICAgICAgICBsZXQgbWludXRlcyA9IEdldFNsb3QodGhpcywgTUlOVVRFUyk7XG4gICAgICAgIGxldCBzZWNvbmRzID0gR2V0U2xvdCh0aGlzLCBTRUNPTkRTKTtcbiAgICAgICAgbGV0IG1pbGxpc2Vjb25kcyA9IEdldFNsb3QodGhpcywgTUlMTElTRUNPTkRTKTtcbiAgICAgICAgbGV0IG1pY3Jvc2Vjb25kcyA9IEdldFNsb3QodGhpcywgTUlDUk9TRUNPTkRTKTtcbiAgICAgICAgbGV0IG5hbm9zZWNvbmRzID0gR2V0U2xvdCh0aGlzLCBOQU5PU0VDT05EUyk7XG4gICAgICAgIGxldCBkZWZhdWx0TGFyZ2VzdFVuaXQgPSBEZWZhdWx0VGVtcG9yYWxMYXJnZXN0VW5pdCh5ZWFycywgbW9udGhzLCB3ZWVrcywgZGF5cywgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc2Vjb25kcywgbWljcm9zZWNvbmRzLCBuYW5vc2Vjb25kcyk7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB0eXBlb2Ygb3B0aW9uc1BhcmFtID09PSAnc3RyaW5nJ1xuICAgICAgICAgICAgPyBDcmVhdGVPbmVQcm9wT2JqZWN0KCdzbWFsbGVzdFVuaXQnLCBvcHRpb25zUGFyYW0pXG4gICAgICAgICAgICA6IEdldE9wdGlvbnNPYmplY3Qob3B0aW9uc1BhcmFtKTtcbiAgICAgICAgbGV0IHNtYWxsZXN0VW5pdCA9IFRvU21hbGxlc3RUZW1wb3JhbFVuaXQob3B0aW9ucywgdW5kZWZpbmVkKTtcbiAgICAgICAgbGV0IHNtYWxsZXN0VW5pdFByZXNlbnQgPSB0cnVlO1xuICAgICAgICBpZiAoIXNtYWxsZXN0VW5pdCkge1xuICAgICAgICAgICAgc21hbGxlc3RVbml0UHJlc2VudCA9IGZhbHNlO1xuICAgICAgICAgICAgc21hbGxlc3RVbml0ID0gJ25hbm9zZWNvbmQnO1xuICAgICAgICB9XG4gICAgICAgIGRlZmF1bHRMYXJnZXN0VW5pdCA9IExhcmdlck9mVHdvVGVtcG9yYWxVbml0cyhkZWZhdWx0TGFyZ2VzdFVuaXQsIHNtYWxsZXN0VW5pdCk7XG4gICAgICAgIGxldCBsYXJnZXN0VW5pdCA9IFRvTGFyZ2VzdFRlbXBvcmFsVW5pdChvcHRpb25zLCB1bmRlZmluZWQpO1xuICAgICAgICBsZXQgbGFyZ2VzdFVuaXRQcmVzZW50ID0gdHJ1ZTtcbiAgICAgICAgaWYgKCFsYXJnZXN0VW5pdCkge1xuICAgICAgICAgICAgbGFyZ2VzdFVuaXRQcmVzZW50ID0gZmFsc2U7XG4gICAgICAgICAgICBsYXJnZXN0VW5pdCA9IGRlZmF1bHRMYXJnZXN0VW5pdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGFyZ2VzdFVuaXQgPT09ICdhdXRvJylcbiAgICAgICAgICAgIGxhcmdlc3RVbml0ID0gZGVmYXVsdExhcmdlc3RVbml0O1xuICAgICAgICBpZiAoIXNtYWxsZXN0VW5pdFByZXNlbnQgJiYgIWxhcmdlc3RVbml0UHJlc2VudCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2F0IGxlYXN0IG9uZSBvZiBzbWFsbGVzdFVuaXQgb3IgbGFyZ2VzdFVuaXQgaXMgcmVxdWlyZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBWYWxpZGF0ZVRlbXBvcmFsVW5pdFJhbmdlKGxhcmdlc3RVbml0LCBzbWFsbGVzdFVuaXQpO1xuICAgICAgICBjb25zdCByb3VuZGluZ01vZGUgPSBUb1RlbXBvcmFsUm91bmRpbmdNb2RlKG9wdGlvbnMsICdoYWxmRXhwYW5kJyk7XG4gICAgICAgIGNvbnN0IHJvdW5kaW5nSW5jcmVtZW50ID0gVG9UZW1wb3JhbERhdGVUaW1lUm91bmRpbmdJbmNyZW1lbnQob3B0aW9ucywgc21hbGxlc3RVbml0KTtcbiAgICAgICAgbGV0IHJlbGF0aXZlVG8gPSBUb1JlbGF0aXZlVGVtcG9yYWxPYmplY3Qob3B0aW9ucyk7XG4gICAgICAgICh7IHllYXJzLCBtb250aHMsIHdlZWtzLCBkYXlzIH0gPSBVbmJhbGFuY2VEdXJhdGlvblJlbGF0aXZlKHllYXJzLCBtb250aHMsIHdlZWtzLCBkYXlzLCBsYXJnZXN0VW5pdCwgcmVsYXRpdmVUbykpO1xuICAgICAgICAoeyB5ZWFycywgbW9udGhzLCB3ZWVrcywgZGF5cywgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc2Vjb25kcywgbWljcm9zZWNvbmRzLCBuYW5vc2Vjb25kcyB9ID1cbiAgICAgICAgICAgIFJvdW5kRHVyYXRpb24oeWVhcnMsIG1vbnRocywgd2Vla3MsIGRheXMsIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBtaWxsaXNlY29uZHMsIG1pY3Jvc2Vjb25kcywgbmFub3NlY29uZHMsIHJvdW5kaW5nSW5jcmVtZW50LCBzbWFsbGVzdFVuaXQsIHJvdW5kaW5nTW9kZSwgcmVsYXRpdmVUbykpO1xuICAgICAgICAoeyB5ZWFycywgbW9udGhzLCB3ZWVrcywgZGF5cywgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc2Vjb25kcywgbWljcm9zZWNvbmRzLCBuYW5vc2Vjb25kcyB9ID1cbiAgICAgICAgICAgIEFkanVzdFJvdW5kZWREdXJhdGlvbkRheXMoeWVhcnMsIG1vbnRocywgd2Vla3MsIGRheXMsIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBtaWxsaXNlY29uZHMsIG1pY3Jvc2Vjb25kcywgbmFub3NlY29uZHMsIHJvdW5kaW5nSW5jcmVtZW50LCBzbWFsbGVzdFVuaXQsIHJvdW5kaW5nTW9kZSwgcmVsYXRpdmVUbykpO1xuICAgICAgICAoeyB5ZWFycywgbW9udGhzLCB3ZWVrcywgZGF5cyB9ID0gQmFsYW5jZUR1cmF0aW9uUmVsYXRpdmUoeWVhcnMsIG1vbnRocywgd2Vla3MsIGRheXMsIGxhcmdlc3RVbml0LCByZWxhdGl2ZVRvKSk7XG4gICAgICAgIGlmIChJc1RlbXBvcmFsWm9uZWREYXRlVGltZShyZWxhdGl2ZVRvKSkge1xuICAgICAgICAgICAgcmVsYXRpdmVUbyA9IE1vdmVSZWxhdGl2ZVpvbmVkRGF0ZVRpbWUocmVsYXRpdmVUbywgeWVhcnMsIG1vbnRocywgd2Vla3MsIDApO1xuICAgICAgICB9XG4gICAgICAgICh7IGRheXMsIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBtaWxsaXNlY29uZHMsIG1pY3Jvc2Vjb25kcywgbmFub3NlY29uZHMgfSA9IEJhbGFuY2VEdXJhdGlvbihkYXlzLCBob3VycywgbWludXRlcywgc2Vjb25kcywgbWlsbGlzZWNvbmRzLCBtaWNyb3NlY29uZHMsIG5hbm9zZWNvbmRzLCBsYXJnZXN0VW5pdCwgcmVsYXRpdmVUbykpO1xuICAgICAgICByZXR1cm4gbmV3IER1cmF0aW9uKHllYXJzLCBtb250aHMsIHdlZWtzLCBkYXlzLCBob3VycywgbWludXRlcywgc2Vjb25kcywgbWlsbGlzZWNvbmRzLCBtaWNyb3NlY29uZHMsIG5hbm9zZWNvbmRzKTtcbiAgICB9XG4gICAgdG90YWwob3B0aW9uc1BhcmFtKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbER1cmF0aW9uKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICBsZXQgeWVhcnMgPSBHZXRTbG90KHRoaXMsIFlFQVJTKTtcbiAgICAgICAgbGV0IG1vbnRocyA9IEdldFNsb3QodGhpcywgTU9OVEhTKTtcbiAgICAgICAgbGV0IHdlZWtzID0gR2V0U2xvdCh0aGlzLCBXRUVLUyk7XG4gICAgICAgIGxldCBkYXlzID0gR2V0U2xvdCh0aGlzLCBEQVlTKTtcbiAgICAgICAgbGV0IGhvdXJzID0gR2V0U2xvdCh0aGlzLCBIT1VSUyk7XG4gICAgICAgIGxldCBtaW51dGVzID0gR2V0U2xvdCh0aGlzLCBNSU5VVEVTKTtcbiAgICAgICAgbGV0IHNlY29uZHMgPSBHZXRTbG90KHRoaXMsIFNFQ09ORFMpO1xuICAgICAgICBsZXQgbWlsbGlzZWNvbmRzID0gR2V0U2xvdCh0aGlzLCBNSUxMSVNFQ09ORFMpO1xuICAgICAgICBsZXQgbWljcm9zZWNvbmRzID0gR2V0U2xvdCh0aGlzLCBNSUNST1NFQ09ORFMpO1xuICAgICAgICBsZXQgbmFub3NlY29uZHMgPSBHZXRTbG90KHRoaXMsIE5BTk9TRUNPTkRTKTtcbiAgICAgICAgaWYgKG9wdGlvbnNQYXJhbSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignb3B0aW9ucyBhcmd1bWVudCBpcyByZXF1aXJlZCcpO1xuICAgICAgICBjb25zdCBvcHRpb25zID0gdHlwZW9mIG9wdGlvbnNQYXJhbSA9PT0gJ3N0cmluZydcbiAgICAgICAgICAgID8gQ3JlYXRlT25lUHJvcE9iamVjdCgndW5pdCcsIG9wdGlvbnNQYXJhbSlcbiAgICAgICAgICAgIDogR2V0T3B0aW9uc09iamVjdChvcHRpb25zUGFyYW0pO1xuICAgICAgICBjb25zdCB1bml0ID0gVG9UZW1wb3JhbER1cmF0aW9uVG90YWxVbml0KG9wdGlvbnMpO1xuICAgICAgICBpZiAodW5pdCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3VuaXQgb3B0aW9uIGlzIHJlcXVpcmVkJyk7XG4gICAgICAgIGNvbnN0IHJlbGF0aXZlVG8gPSBUb1JlbGF0aXZlVGVtcG9yYWxPYmplY3Qob3B0aW9ucyk7XG4gICAgICAgIC8vIENvbnZlcnQgbGFyZ2VyIHVuaXRzIGRvd24gdG8gZGF5c1xuICAgICAgICAoeyB5ZWFycywgbW9udGhzLCB3ZWVrcywgZGF5cyB9ID0gVW5iYWxhbmNlRHVyYXRpb25SZWxhdGl2ZSh5ZWFycywgbW9udGhzLCB3ZWVrcywgZGF5cywgdW5pdCwgcmVsYXRpdmVUbykpO1xuICAgICAgICAvLyBJZiB0aGUgdW5pdCB3ZSdyZSB0b3RhbGxpbmcgaXMgc21hbGxlciB0aGFuIGBkYXlzYCwgY29udmVydCBkYXlzIGRvd24gdG8gdGhhdCB1bml0LlxuICAgICAgICBsZXQgaW50ZXJtZWRpYXRlO1xuICAgICAgICBpZiAoSXNUZW1wb3JhbFpvbmVkRGF0ZVRpbWUocmVsYXRpdmVUbykpIHtcbiAgICAgICAgICAgIGludGVybWVkaWF0ZSA9IE1vdmVSZWxhdGl2ZVpvbmVkRGF0ZVRpbWUocmVsYXRpdmVUbywgeWVhcnMsIG1vbnRocywgd2Vla3MsIDApO1xuICAgICAgICB9XG4gICAgICAgICh7IGRheXMsIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBtaWxsaXNlY29uZHMsIG1pY3Jvc2Vjb25kcywgbmFub3NlY29uZHMgfSA9IEJhbGFuY2VEdXJhdGlvbihkYXlzLCBob3VycywgbWludXRlcywgc2Vjb25kcywgbWlsbGlzZWNvbmRzLCBtaWNyb3NlY29uZHMsIG5hbm9zZWNvbmRzLCB1bml0LCBpbnRlcm1lZGlhdGUpKTtcbiAgICAgICAgLy8gRmluYWxseSwgdHJ1bmNhdGUgdG8gdGhlIGNvcnJlY3QgdW5pdCBhbmQgY2FsY3VsYXRlIHJlbWFpbmRlclxuICAgICAgICBjb25zdCB7IHRvdGFsIH0gPSBSb3VuZER1cmF0aW9uKHllYXJzLCBtb250aHMsIHdlZWtzLCBkYXlzLCBob3VycywgbWludXRlcywgc2Vjb25kcywgbWlsbGlzZWNvbmRzLCBtaWNyb3NlY29uZHMsIG5hbm9zZWNvbmRzLCAxLCB1bml0LCAndHJ1bmMnLCByZWxhdGl2ZVRvKTtcbiAgICAgICAgcmV0dXJuIHRvdGFsO1xuICAgIH1cbiAgICB0b1N0cmluZyhvcHRpb25zUGFyYW0gPSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsRHVyYXRpb24odGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSBHZXRPcHRpb25zT2JqZWN0KG9wdGlvbnNQYXJhbSk7XG4gICAgICAgIGNvbnN0IHsgcHJlY2lzaW9uLCB1bml0LCBpbmNyZW1lbnQgfSA9IFRvU2Vjb25kc1N0cmluZ1ByZWNpc2lvbihvcHRpb25zKTtcbiAgICAgICAgaWYgKHByZWNpc2lvbiA9PT0gJ21pbnV0ZScpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc21hbGxlc3RVbml0IG11c3Qgbm90IGJlIFwibWludXRlXCInKTtcbiAgICAgICAgY29uc3Qgcm91bmRpbmdNb2RlID0gVG9UZW1wb3JhbFJvdW5kaW5nTW9kZShvcHRpb25zLCAndHJ1bmMnKTtcbiAgICAgICAgcmV0dXJuIFRlbXBvcmFsRHVyYXRpb25Ub1N0cmluZyh0aGlzLCBwcmVjaXNpb24sIHsgdW5pdCwgaW5jcmVtZW50LCByb3VuZGluZ01vZGUgfSk7XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsRHVyYXRpb24odGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIHJldHVybiBUZW1wb3JhbER1cmF0aW9uVG9TdHJpbmcodGhpcyk7XG4gICAgfVxuICAgIHRvTG9jYWxlU3RyaW5nKGxvY2FsZXMgPSB1bmRlZmluZWQsIG9wdGlvbnMgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsRHVyYXRpb24odGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIGlmICh0eXBlb2YgSW50bCAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIEludGwuRHVyYXRpb25Gb3JtYXQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEludGwuRHVyYXRpb25Gb3JtYXQobG9jYWxlcywgb3B0aW9ucykuZm9ybWF0KHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnNvbGUud2FybignVGVtcG9yYWwuRHVyYXRpb24ucHJvdG90eXBlLnRvTG9jYWxlU3RyaW5nKCkgcmVxdWlyZXMgSW50bC5EdXJhdGlvbkZvcm1hdC4nKTtcbiAgICAgICAgcmV0dXJuIFRlbXBvcmFsRHVyYXRpb25Ub1N0cmluZyh0aGlzKTtcbiAgICB9XG4gICAgdmFsdWVPZigpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigndXNlIGNvbXBhcmUoKSB0byBjb21wYXJlIFRlbXBvcmFsLkR1cmF0aW9uJyk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tKGl0ZW0pIHtcbiAgICAgICAgaWYgKElzVGVtcG9yYWxEdXJhdGlvbihpdGVtKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBEdXJhdGlvbihHZXRTbG90KGl0ZW0sIFlFQVJTKSwgR2V0U2xvdChpdGVtLCBNT05USFMpLCBHZXRTbG90KGl0ZW0sIFdFRUtTKSwgR2V0U2xvdChpdGVtLCBEQVlTKSwgR2V0U2xvdChpdGVtLCBIT1VSUyksIEdldFNsb3QoaXRlbSwgTUlOVVRFUyksIEdldFNsb3QoaXRlbSwgU0VDT05EUyksIEdldFNsb3QoaXRlbSwgTUlMTElTRUNPTkRTKSwgR2V0U2xvdChpdGVtLCBNSUNST1NFQ09ORFMpLCBHZXRTbG90KGl0ZW0sIE5BTk9TRUNPTkRTKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFRvVGVtcG9yYWxEdXJhdGlvbihpdGVtKTtcbiAgICB9XG4gICAgc3RhdGljIGNvbXBhcmUob25lUGFyYW0sIHR3b1BhcmFtLCBvcHRpb25zUGFyYW0gPSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3Qgb25lID0gVG9UZW1wb3JhbER1cmF0aW9uKG9uZVBhcmFtKTtcbiAgICAgICAgY29uc3QgdHdvID0gVG9UZW1wb3JhbER1cmF0aW9uKHR3b1BhcmFtKTtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IEdldE9wdGlvbnNPYmplY3Qob3B0aW9uc1BhcmFtKTtcbiAgICAgICAgY29uc3QgcmVsYXRpdmVUbyA9IFRvUmVsYXRpdmVUZW1wb3JhbE9iamVjdChvcHRpb25zKTtcbiAgICAgICAgY29uc3QgeTEgPSBHZXRTbG90KG9uZSwgWUVBUlMpO1xuICAgICAgICBjb25zdCBtb24xID0gR2V0U2xvdChvbmUsIE1PTlRIUyk7XG4gICAgICAgIGNvbnN0IHcxID0gR2V0U2xvdChvbmUsIFdFRUtTKTtcbiAgICAgICAgbGV0IGQxID0gR2V0U2xvdChvbmUsIERBWVMpO1xuICAgICAgICBjb25zdCBoMSA9IEdldFNsb3Qob25lLCBIT1VSUyk7XG4gICAgICAgIGNvbnN0IG1pbjEgPSBHZXRTbG90KG9uZSwgTUlOVVRFUyk7XG4gICAgICAgIGNvbnN0IHMxID0gR2V0U2xvdChvbmUsIFNFQ09ORFMpO1xuICAgICAgICBjb25zdCBtczEgPSBHZXRTbG90KG9uZSwgTUlMTElTRUNPTkRTKTtcbiAgICAgICAgY29uc3QgwrVzMSA9IEdldFNsb3Qob25lLCBNSUNST1NFQ09ORFMpO1xuICAgICAgICBsZXQgbnMxID0gR2V0U2xvdChvbmUsIE5BTk9TRUNPTkRTKTtcbiAgICAgICAgY29uc3QgeTIgPSBHZXRTbG90KHR3bywgWUVBUlMpO1xuICAgICAgICBjb25zdCBtb24yID0gR2V0U2xvdCh0d28sIE1PTlRIUyk7XG4gICAgICAgIGNvbnN0IHcyID0gR2V0U2xvdCh0d28sIFdFRUtTKTtcbiAgICAgICAgbGV0IGQyID0gR2V0U2xvdCh0d28sIERBWVMpO1xuICAgICAgICBjb25zdCBoMiA9IEdldFNsb3QodHdvLCBIT1VSUyk7XG4gICAgICAgIGNvbnN0IG1pbjIgPSBHZXRTbG90KHR3bywgTUlOVVRFUyk7XG4gICAgICAgIGNvbnN0IHMyID0gR2V0U2xvdCh0d28sIFNFQ09ORFMpO1xuICAgICAgICBjb25zdCBtczIgPSBHZXRTbG90KHR3bywgTUlMTElTRUNPTkRTKTtcbiAgICAgICAgY29uc3QgwrVzMiA9IEdldFNsb3QodHdvLCBNSUNST1NFQ09ORFMpO1xuICAgICAgICBsZXQgbnMyID0gR2V0U2xvdCh0d28sIE5BTk9TRUNPTkRTKTtcbiAgICAgICAgY29uc3Qgc2hpZnQxID0gQ2FsY3VsYXRlT2Zmc2V0U2hpZnQocmVsYXRpdmVUbywgeTEsIG1vbjEsIHcxLCBkMSwgaDEsIG1pbjEsIHMxLCBtczEsIMK1czEsIG5zMSk7XG4gICAgICAgIGNvbnN0IHNoaWZ0MiA9IENhbGN1bGF0ZU9mZnNldFNoaWZ0KHJlbGF0aXZlVG8sIHkyLCBtb24yLCB3MiwgZDIsIGgyLCBtaW4yLCBzMiwgbXMyLCDCtXMyLCBuczIpO1xuICAgICAgICBpZiAoeTEgIT09IDAgfHwgeTIgIT09IDAgfHwgbW9uMSAhPT0gMCB8fCBtb24yICE9PSAwIHx8IHcxICE9PSAwIHx8IHcyICE9PSAwKSB7XG4gICAgICAgICAgICAoeyBkYXlzOiBkMSB9ID0gVW5iYWxhbmNlRHVyYXRpb25SZWxhdGl2ZSh5MSwgbW9uMSwgdzEsIGQxLCAnZGF5JywgcmVsYXRpdmVUbykpO1xuICAgICAgICAgICAgKHsgZGF5czogZDIgfSA9IFVuYmFsYW5jZUR1cmF0aW9uUmVsYXRpdmUoeTIsIG1vbjIsIHcyLCBkMiwgJ2RheScsIHJlbGF0aXZlVG8pKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0b3RhbE5zMSA9IFRvdGFsRHVyYXRpb25OYW5vc2Vjb25kcyhkMSwgaDEsIG1pbjEsIHMxLCBtczEsIMK1czEsIG5zMSwgc2hpZnQxKTtcbiAgICAgICAgY29uc3QgdG90YWxOczIgPSBUb3RhbER1cmF0aW9uTmFub3NlY29uZHMoZDIsIGgyLCBtaW4yLCBzMiwgbXMyLCDCtXMyLCBuczIsIHNoaWZ0Mik7XG4gICAgICAgIHJldHVybiBDb21wYXJpc29uUmVzdWx0KEpTQkkudG9OdW1iZXIoSlNCSS5zdWJ0cmFjdCh0b3RhbE5zMSwgdG90YWxOczIpKSk7XG4gICAgfVxufVxuTWFrZUludHJpbnNpY0NsYXNzKER1cmF0aW9uLCAnVGVtcG9yYWwuRHVyYXRpb24nKTtcblxuY29uc3QgT2JqZWN0Q3JlYXRlJDEgPSBPYmplY3QuY3JlYXRlO1xuY2xhc3MgUGxhaW5Nb250aERheSB7XG4gICAgY29uc3RydWN0b3IoaXNvTW9udGhQYXJhbSwgaXNvRGF5UGFyYW0sIGNhbGVuZGFyUGFyYW0gPSBHZXRJU084NjAxQ2FsZW5kYXIoKSwgcmVmZXJlbmNlSVNPWWVhclBhcmFtID0gMTk3Mikge1xuICAgICAgICBjb25zdCBpc29Nb250aCA9IFRvSW50ZWdlclRocm93T25JbmZpbml0eShpc29Nb250aFBhcmFtKTtcbiAgICAgICAgY29uc3QgaXNvRGF5ID0gVG9JbnRlZ2VyVGhyb3dPbkluZmluaXR5KGlzb0RheVBhcmFtKTtcbiAgICAgICAgY29uc3QgY2FsZW5kYXIgPSBUb1RlbXBvcmFsQ2FsZW5kYXIoY2FsZW5kYXJQYXJhbSk7XG4gICAgICAgIGNvbnN0IHJlZmVyZW5jZUlTT1llYXIgPSBUb0ludGVnZXJUaHJvd09uSW5maW5pdHkocmVmZXJlbmNlSVNPWWVhclBhcmFtKTtcbiAgICAgICAgLy8gTm90ZTogaWYgdGhlIGFyZ3VtZW50cyBhcmUgbm90IHBhc3NlZCxcbiAgICAgICAgLy8gICAgICAgVG9JbnRlZ2VyVGhyb3dPbkluZmluaXR5KHVuZGVmaW5lZCkgd2lsbCBoYXZlIHJldHVybmVkIDAsIHdoaWNoIHdpbGxcbiAgICAgICAgLy8gICAgICAgYmUgcmVqZWN0ZWQgYnkgUmVqZWN0SVNPRGF0ZSBpbiBDcmVhdGVUZW1wb3JhbE1vbnRoRGF5U2xvdHMuIFRoaXNcbiAgICAgICAgLy8gICAgICAgY2hlY2sgZXhpc3RzIG9ubHkgdG8gaW1wcm92ZSB0aGUgZXJyb3IgbWVzc2FnZS5cbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignbWlzc2luZyBhcmd1bWVudDogaXNvTW9udGggYW5kIGlzb0RheSBhcmUgcmVxdWlyZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBDcmVhdGVUZW1wb3JhbE1vbnRoRGF5U2xvdHModGhpcywgaXNvTW9udGgsIGlzb0RheSwgY2FsZW5kYXIsIHJlZmVyZW5jZUlTT1llYXIpO1xuICAgIH1cbiAgICBnZXQgbW9udGhDb2RlKCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxNb250aERheSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgcmV0dXJuIENhbGVuZGFyTW9udGhDb2RlKEdldFNsb3QodGhpcywgQ0FMRU5EQVIpLCB0aGlzKTtcbiAgICB9XG4gICAgZ2V0IGRheSgpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsTW9udGhEYXkodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIHJldHVybiBDYWxlbmRhckRheShHZXRTbG90KHRoaXMsIENBTEVOREFSKSwgdGhpcyk7XG4gICAgfVxuICAgIGdldCBjYWxlbmRhcigpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsTW9udGhEYXkodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIHJldHVybiBHZXRTbG90KHRoaXMsIENBTEVOREFSKTtcbiAgICB9XG4gICAgd2l0aCh0ZW1wb3JhbE1vbnRoRGF5TGlrZSwgb3B0aW9uc1BhcmFtID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbE1vbnRoRGF5KHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICBpZiAoIUlzT2JqZWN0KHRlbXBvcmFsTW9udGhEYXlMaWtlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBhcmd1bWVudCcpO1xuICAgICAgICB9XG4gICAgICAgIFJlamVjdE9iamVjdFdpdGhDYWxlbmRhck9yVGltZVpvbmUodGVtcG9yYWxNb250aERheUxpa2UpO1xuICAgICAgICBjb25zdCBjYWxlbmRhciA9IEdldFNsb3QodGhpcywgQ0FMRU5EQVIpO1xuICAgICAgICBjb25zdCBmaWVsZE5hbWVzID0gQ2FsZW5kYXJGaWVsZHMoY2FsZW5kYXIsIFsnZGF5JywgJ21vbnRoJywgJ21vbnRoQ29kZScsICd5ZWFyJ10pO1xuICAgICAgICBjb25zdCBwcm9wcyA9IFRvUGFydGlhbFJlY29yZCh0ZW1wb3JhbE1vbnRoRGF5TGlrZSwgZmllbGROYW1lcyk7XG4gICAgICAgIGlmICghcHJvcHMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgbW9udGgtZGF5LWxpa2UnKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZmllbGRzID0gVG9UZW1wb3JhbE1vbnRoRGF5RmllbGRzKHRoaXMsIGZpZWxkTmFtZXMpO1xuICAgICAgICBmaWVsZHMgPSBDYWxlbmRhck1lcmdlRmllbGRzKGNhbGVuZGFyLCBmaWVsZHMsIHByb3BzKTtcbiAgICAgICAgZmllbGRzID0gVG9UZW1wb3JhbE1vbnRoRGF5RmllbGRzKGZpZWxkcywgZmllbGROYW1lcyk7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSBHZXRPcHRpb25zT2JqZWN0KG9wdGlvbnNQYXJhbSk7XG4gICAgICAgIHJldHVybiBNb250aERheUZyb21GaWVsZHMoY2FsZW5kYXIsIGZpZWxkcywgb3B0aW9ucyk7XG4gICAgfVxuICAgIGVxdWFscyhvdGhlclBhcmFtKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbE1vbnRoRGF5KHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICBjb25zdCBvdGhlciA9IFRvVGVtcG9yYWxNb250aERheShvdGhlclBhcmFtKTtcbiAgICAgICAgZm9yIChjb25zdCBzbG90IG9mIFtJU09fTU9OVEgsIElTT19EQVksIElTT19ZRUFSXSkge1xuICAgICAgICAgICAgY29uc3QgdmFsMSA9IEdldFNsb3QodGhpcywgc2xvdCk7XG4gICAgICAgICAgICBjb25zdCB2YWwyID0gR2V0U2xvdChvdGhlciwgc2xvdCk7XG4gICAgICAgICAgICBpZiAodmFsMSAhPT0gdmFsMilcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIENhbGVuZGFyRXF1YWxzKEdldFNsb3QodGhpcywgQ0FMRU5EQVIpLCBHZXRTbG90KG90aGVyLCBDQUxFTkRBUikpO1xuICAgIH1cbiAgICB0b1N0cmluZyhvcHRpb25zUGFyYW0gPSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsTW9udGhEYXkodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSBHZXRPcHRpb25zT2JqZWN0KG9wdGlvbnNQYXJhbSk7XG4gICAgICAgIGNvbnN0IHNob3dDYWxlbmRhciA9IFRvU2hvd0NhbGVuZGFyT3B0aW9uKG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gVGVtcG9yYWxNb250aERheVRvU3RyaW5nKHRoaXMsIHNob3dDYWxlbmRhcik7XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsTW9udGhEYXkodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIHJldHVybiBUZW1wb3JhbE1vbnRoRGF5VG9TdHJpbmcodGhpcyk7XG4gICAgfVxuICAgIHRvTG9jYWxlU3RyaW5nKGxvY2FsZXMgPSB1bmRlZmluZWQsIG9wdGlvbnMgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsTW9udGhEYXkodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZVRpbWVGb3JtYXQobG9jYWxlcywgb3B0aW9ucykuZm9ybWF0KHRoaXMpO1xuICAgIH1cbiAgICB2YWx1ZU9mKCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd1c2UgZXF1YWxzKCkgdG8gY29tcGFyZSBUZW1wb3JhbC5QbGFpbk1vbnRoRGF5Jyk7XG4gICAgfVxuICAgIHRvUGxhaW5EYXRlKGl0ZW0pIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsTW9udGhEYXkodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIGlmICghSXNPYmplY3QoaXRlbSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdhcmd1bWVudCBzaG91bGQgYmUgYW4gb2JqZWN0Jyk7XG4gICAgICAgIGNvbnN0IGNhbGVuZGFyID0gR2V0U2xvdCh0aGlzLCBDQUxFTkRBUik7XG4gICAgICAgIGNvbnN0IHJlY2VpdmVyRmllbGROYW1lcyA9IENhbGVuZGFyRmllbGRzKGNhbGVuZGFyLCBbJ2RheScsICdtb250aENvZGUnXSk7XG4gICAgICAgIGNvbnN0IGZpZWxkcyA9IFRvVGVtcG9yYWxNb250aERheUZpZWxkcyh0aGlzLCByZWNlaXZlckZpZWxkTmFtZXMpO1xuICAgICAgICBjb25zdCBpbnB1dEZpZWxkTmFtZXMgPSBDYWxlbmRhckZpZWxkcyhjYWxlbmRhciwgWyd5ZWFyJ10pO1xuICAgICAgICBjb25zdCBpbnB1dEVudHJpZXMgPSBbWyd5ZWFyJywgdW5kZWZpbmVkXV07XG4gICAgICAgIC8vIEFkZCBleHRyYSBmaWVsZHMgZnJvbSB0aGUgY2FsZW5kYXIgYXQgdGhlIGVuZFxuICAgICAgICBpbnB1dEZpZWxkTmFtZXMuZm9yRWFjaCgoZmllbGROYW1lKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWlucHV0RW50cmllcy5zb21lKChbbmFtZV0pID0+IG5hbWUgPT09IGZpZWxkTmFtZSkpIHtcbiAgICAgICAgICAgICAgICBpbnB1dEVudHJpZXMucHVzaChbZmllbGROYW1lLCB1bmRlZmluZWRdKTsgLy8gTWFrZSBUUyBpZ25vcmUgZXh0cmEgZmllbGRzXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBpbnB1dEZpZWxkcyA9IFByZXBhcmVUZW1wb3JhbEZpZWxkcyhpdGVtLCBpbnB1dEVudHJpZXMpO1xuICAgICAgICBsZXQgbWVyZ2VkRmllbGRzID0gQ2FsZW5kYXJNZXJnZUZpZWxkcyhjYWxlbmRhciwgZmllbGRzLCBpbnB1dEZpZWxkcyk7XG4gICAgICAgIGNvbnN0IG1lcmdlZEZpZWxkTmFtZXMgPSBbLi4ubmV3IFNldChbLi4ucmVjZWl2ZXJGaWVsZE5hbWVzLCAuLi5pbnB1dEZpZWxkTmFtZXNdKV07XG4gICAgICAgIGNvbnN0IG1lcmdlZEVudHJpZXMgPSBbXTtcbiAgICAgICAgbWVyZ2VkRmllbGROYW1lcy5mb3JFYWNoKChmaWVsZE5hbWUpID0+IHtcbiAgICAgICAgICAgIGlmICghbWVyZ2VkRW50cmllcy5zb21lKChbbmFtZV0pID0+IG5hbWUgPT09IGZpZWxkTmFtZSkpIHtcbiAgICAgICAgICAgICAgICBtZXJnZWRFbnRyaWVzLnB1c2goW2ZpZWxkTmFtZSwgdW5kZWZpbmVkXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBtZXJnZWRGaWVsZHMgPSBQcmVwYXJlVGVtcG9yYWxGaWVsZHMobWVyZ2VkRmllbGRzLCBtZXJnZWRFbnRyaWVzKTtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IE9iamVjdENyZWF0ZSQxKG51bGwpO1xuICAgICAgICBvcHRpb25zLm92ZXJmbG93ID0gJ3JlamVjdCc7XG4gICAgICAgIHJldHVybiBEYXRlRnJvbUZpZWxkcyhjYWxlbmRhciwgbWVyZ2VkRmllbGRzLCBvcHRpb25zKTtcbiAgICB9XG4gICAgZ2V0SVNPRmllbGRzKCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxNb250aERheSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNhbGVuZGFyOiBHZXRTbG90KHRoaXMsIENBTEVOREFSKSxcbiAgICAgICAgICAgIGlzb0RheTogR2V0U2xvdCh0aGlzLCBJU09fREFZKSxcbiAgICAgICAgICAgIGlzb01vbnRoOiBHZXRTbG90KHRoaXMsIElTT19NT05USCksXG4gICAgICAgICAgICBpc29ZZWFyOiBHZXRTbG90KHRoaXMsIElTT19ZRUFSKVxuICAgICAgICB9O1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbShpdGVtLCBvcHRpb25zUGFyYW0gPSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IEdldE9wdGlvbnNPYmplY3Qob3B0aW9uc1BhcmFtKTtcbiAgICAgICAgaWYgKElzVGVtcG9yYWxNb250aERheShpdGVtKSkge1xuICAgICAgICAgICAgVG9UZW1wb3JhbE92ZXJmbG93KG9wdGlvbnMpOyAvLyB2YWxpZGF0ZSBhbmQgaWdub3JlXG4gICAgICAgICAgICByZXR1cm4gQ3JlYXRlVGVtcG9yYWxNb250aERheShHZXRTbG90KGl0ZW0sIElTT19NT05USCksIEdldFNsb3QoaXRlbSwgSVNPX0RBWSksIEdldFNsb3QoaXRlbSwgQ0FMRU5EQVIpLCBHZXRTbG90KGl0ZW0sIElTT19ZRUFSKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFRvVGVtcG9yYWxNb250aERheShpdGVtLCBvcHRpb25zKTtcbiAgICB9XG59XG5NYWtlSW50cmluc2ljQ2xhc3MoUGxhaW5Nb250aERheSwgJ1RlbXBvcmFsLlBsYWluTW9udGhEYXknKTtcblxuY29uc3QgaW5zdGFudCA9ICgpID0+IHtcbiAgICBjb25zdCBJbnN0YW50ID0gR2V0SW50cmluc2ljKCclVGVtcG9yYWwuSW5zdGFudCUnKTtcbiAgICByZXR1cm4gbmV3IEluc3RhbnQoU3lzdGVtVVRDRXBvY2hOYW5vU2Vjb25kcygpKTtcbn07XG5jb25zdCBwbGFpbkRhdGVUaW1lID0gKGNhbGVuZGFyTGlrZSwgdGVtcG9yYWxUaW1lWm9uZUxpa2UgPSB0aW1lWm9uZSgpKSA9PiB7XG4gICAgY29uc3QgdFogPSBUb1RlbXBvcmFsVGltZVpvbmUodGVtcG9yYWxUaW1lWm9uZUxpa2UpO1xuICAgIGNvbnN0IGNhbGVuZGFyID0gVG9UZW1wb3JhbENhbGVuZGFyKGNhbGVuZGFyTGlrZSk7XG4gICAgY29uc3QgaW5zdCA9IGluc3RhbnQoKTtcbiAgICByZXR1cm4gQnVpbHRpblRpbWVab25lR2V0UGxhaW5EYXRlVGltZUZvcih0WiwgaW5zdCwgY2FsZW5kYXIpO1xufTtcbmNvbnN0IHBsYWluRGF0ZVRpbWVJU08gPSAodGVtcG9yYWxUaW1lWm9uZUxpa2UgPSB0aW1lWm9uZSgpKSA9PiB7XG4gICAgY29uc3QgdFogPSBUb1RlbXBvcmFsVGltZVpvbmUodGVtcG9yYWxUaW1lWm9uZUxpa2UpO1xuICAgIGNvbnN0IGNhbGVuZGFyID0gR2V0SVNPODYwMUNhbGVuZGFyKCk7XG4gICAgY29uc3QgaW5zdCA9IGluc3RhbnQoKTtcbiAgICByZXR1cm4gQnVpbHRpblRpbWVab25lR2V0UGxhaW5EYXRlVGltZUZvcih0WiwgaW5zdCwgY2FsZW5kYXIpO1xufTtcbmNvbnN0IHpvbmVkRGF0ZVRpbWUgPSAoY2FsZW5kYXJMaWtlLCB0ZW1wb3JhbFRpbWVab25lTGlrZSA9IHRpbWVab25lKCkpID0+IHtcbiAgICBjb25zdCB0WiA9IFRvVGVtcG9yYWxUaW1lWm9uZSh0ZW1wb3JhbFRpbWVab25lTGlrZSk7XG4gICAgY29uc3QgY2FsZW5kYXIgPSBUb1RlbXBvcmFsQ2FsZW5kYXIoY2FsZW5kYXJMaWtlKTtcbiAgICByZXR1cm4gQ3JlYXRlVGVtcG9yYWxab25lZERhdGVUaW1lKFN5c3RlbVVUQ0Vwb2NoTmFub1NlY29uZHMoKSwgdFosIGNhbGVuZGFyKTtcbn07XG5jb25zdCB6b25lZERhdGVUaW1lSVNPID0gKHRlbXBvcmFsVGltZVpvbmVMaWtlID0gdGltZVpvbmUoKSkgPT4ge1xuICAgIHJldHVybiB6b25lZERhdGVUaW1lKEdldElTTzg2MDFDYWxlbmRhcigpLCB0ZW1wb3JhbFRpbWVab25lTGlrZSk7XG59O1xuY29uc3QgcGxhaW5EYXRlID0gKGNhbGVuZGFyTGlrZSwgdGVtcG9yYWxUaW1lWm9uZUxpa2UgPSB0aW1lWm9uZSgpKSA9PiB7XG4gICAgcmV0dXJuIFRlbXBvcmFsRGF0ZVRpbWVUb0RhdGUocGxhaW5EYXRlVGltZShjYWxlbmRhckxpa2UsIHRlbXBvcmFsVGltZVpvbmVMaWtlKSk7XG59O1xuY29uc3QgcGxhaW5EYXRlSVNPID0gKHRlbXBvcmFsVGltZVpvbmVMaWtlID0gdGltZVpvbmUoKSkgPT4ge1xuICAgIHJldHVybiBUZW1wb3JhbERhdGVUaW1lVG9EYXRlKHBsYWluRGF0ZVRpbWVJU08odGVtcG9yYWxUaW1lWm9uZUxpa2UpKTtcbn07XG5jb25zdCBwbGFpblRpbWVJU08gPSAodGVtcG9yYWxUaW1lWm9uZUxpa2UgPSB0aW1lWm9uZSgpKSA9PiB7XG4gICAgcmV0dXJuIFRlbXBvcmFsRGF0ZVRpbWVUb1RpbWUocGxhaW5EYXRlVGltZUlTTyh0ZW1wb3JhbFRpbWVab25lTGlrZSkpO1xufTtcbmNvbnN0IHRpbWVab25lID0gKCkgPT4ge1xuICAgIHJldHVybiBTeXN0ZW1UaW1lWm9uZSgpO1xufTtcbmNvbnN0IE5vdyA9IHtcbiAgICBpbnN0YW50LFxuICAgIHBsYWluRGF0ZVRpbWUsXG4gICAgcGxhaW5EYXRlVGltZUlTTyxcbiAgICBwbGFpbkRhdGUsXG4gICAgcGxhaW5EYXRlSVNPLFxuICAgIHBsYWluVGltZUlTTyxcbiAgICB0aW1lWm9uZSxcbiAgICB6b25lZERhdGVUaW1lLFxuICAgIHpvbmVkRGF0ZVRpbWVJU08sXG4gICAgW1N5bWJvbC50b1N0cmluZ1RhZ106ICdUZW1wb3JhbC5Ob3cnXG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KE5vdywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7XG4gICAgdmFsdWU6ICdUZW1wb3JhbC5Ob3cnLFxuICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbn0pO1xuXG5jb25zdCBPYmplY3RBc3NpZ24gPSBPYmplY3QuYXNzaWduO1xuY29uc3QgRElTQUxMT1dFRF9VTklUUyQxID0gWyd5ZWFyJywgJ21vbnRoJywgJ3dlZWsnLCAnZGF5J107XG5jb25zdCBNQVhfSU5DUkVNRU5UUyA9IHtcbiAgICBob3VyOiAyNCxcbiAgICBtaW51dGU6IDYwLFxuICAgIHNlY29uZDogNjAsXG4gICAgbWlsbGlzZWNvbmQ6IDEwMDAsXG4gICAgbWljcm9zZWNvbmQ6IDEwMDAsXG4gICAgbmFub3NlY29uZDogMTAwMFxufTtcbmZ1bmN0aW9uIFRlbXBvcmFsVGltZVRvU3RyaW5nKHRpbWUsIHByZWNpc2lvbiwgb3B0aW9ucyA9IHVuZGVmaW5lZCkge1xuICAgIGxldCBob3VyID0gR2V0U2xvdCh0aW1lLCBJU09fSE9VUik7XG4gICAgbGV0IG1pbnV0ZSA9IEdldFNsb3QodGltZSwgSVNPX01JTlVURSk7XG4gICAgbGV0IHNlY29uZCA9IEdldFNsb3QodGltZSwgSVNPX1NFQ09ORCk7XG4gICAgbGV0IG1pbGxpc2Vjb25kID0gR2V0U2xvdCh0aW1lLCBJU09fTUlMTElTRUNPTkQpO1xuICAgIGxldCBtaWNyb3NlY29uZCA9IEdldFNsb3QodGltZSwgSVNPX01JQ1JPU0VDT05EKTtcbiAgICBsZXQgbmFub3NlY29uZCA9IEdldFNsb3QodGltZSwgSVNPX05BTk9TRUNPTkQpO1xuICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHsgdW5pdCwgaW5jcmVtZW50LCByb3VuZGluZ01vZGUgfSA9IG9wdGlvbnM7XG4gICAgICAgICh7IGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZCwgbWljcm9zZWNvbmQsIG5hbm9zZWNvbmQgfSA9IFJvdW5kVGltZShob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQsIG1pY3Jvc2Vjb25kLCBuYW5vc2Vjb25kLCBpbmNyZW1lbnQsIHVuaXQsIHJvdW5kaW5nTW9kZSkpO1xuICAgIH1cbiAgICBjb25zdCBob3VyU3RyaW5nID0gSVNPRGF0ZVRpbWVQYXJ0U3RyaW5nKGhvdXIpO1xuICAgIGNvbnN0IG1pbnV0ZVN0cmluZyA9IElTT0RhdGVUaW1lUGFydFN0cmluZyhtaW51dGUpO1xuICAgIGNvbnN0IHNlY29uZHMgPSBGb3JtYXRTZWNvbmRzU3RyaW5nUGFydChzZWNvbmQsIG1pbGxpc2Vjb25kLCBtaWNyb3NlY29uZCwgbmFub3NlY29uZCwgcHJlY2lzaW9uKTtcbiAgICByZXR1cm4gYCR7aG91clN0cmluZ306JHttaW51dGVTdHJpbmd9JHtzZWNvbmRzfWA7XG59XG5jbGFzcyBQbGFpblRpbWUge1xuICAgIGNvbnN0cnVjdG9yKGlzb0hvdXJQYXJhbSA9IDAsIGlzb01pbnV0ZVBhcmFtID0gMCwgaXNvU2Vjb25kUGFyYW0gPSAwLCBpc29NaWxsaXNlY29uZFBhcmFtID0gMCwgaXNvTWljcm9zZWNvbmRQYXJhbSA9IDAsIGlzb05hbm9zZWNvbmRQYXJhbSA9IDApIHtcbiAgICAgICAgY29uc3QgaXNvSG91ciA9IFRvSW50ZWdlclRocm93T25JbmZpbml0eShpc29Ib3VyUGFyYW0pO1xuICAgICAgICBjb25zdCBpc29NaW51dGUgPSBUb0ludGVnZXJUaHJvd09uSW5maW5pdHkoaXNvTWludXRlUGFyYW0pO1xuICAgICAgICBjb25zdCBpc29TZWNvbmQgPSBUb0ludGVnZXJUaHJvd09uSW5maW5pdHkoaXNvU2Vjb25kUGFyYW0pO1xuICAgICAgICBjb25zdCBpc29NaWxsaXNlY29uZCA9IFRvSW50ZWdlclRocm93T25JbmZpbml0eShpc29NaWxsaXNlY29uZFBhcmFtKTtcbiAgICAgICAgY29uc3QgaXNvTWljcm9zZWNvbmQgPSBUb0ludGVnZXJUaHJvd09uSW5maW5pdHkoaXNvTWljcm9zZWNvbmRQYXJhbSk7XG4gICAgICAgIGNvbnN0IGlzb05hbm9zZWNvbmQgPSBUb0ludGVnZXJUaHJvd09uSW5maW5pdHkoaXNvTmFub3NlY29uZFBhcmFtKTtcbiAgICAgICAgUmVqZWN0VGltZShpc29Ib3VyLCBpc29NaW51dGUsIGlzb1NlY29uZCwgaXNvTWlsbGlzZWNvbmQsIGlzb01pY3Jvc2Vjb25kLCBpc29OYW5vc2Vjb25kKTtcbiAgICAgICAgQ3JlYXRlU2xvdHModGhpcyk7XG4gICAgICAgIFNldFNsb3QodGhpcywgSVNPX0hPVVIsIGlzb0hvdXIpO1xuICAgICAgICBTZXRTbG90KHRoaXMsIElTT19NSU5VVEUsIGlzb01pbnV0ZSk7XG4gICAgICAgIFNldFNsb3QodGhpcywgSVNPX1NFQ09ORCwgaXNvU2Vjb25kKTtcbiAgICAgICAgU2V0U2xvdCh0aGlzLCBJU09fTUlMTElTRUNPTkQsIGlzb01pbGxpc2Vjb25kKTtcbiAgICAgICAgU2V0U2xvdCh0aGlzLCBJU09fTUlDUk9TRUNPTkQsIGlzb01pY3Jvc2Vjb25kKTtcbiAgICAgICAgU2V0U2xvdCh0aGlzLCBJU09fTkFOT1NFQ09ORCwgaXNvTmFub3NlY29uZCk7XG4gICAgICAgIFNldFNsb3QodGhpcywgQ0FMRU5EQVIsIEdldElTTzg2MDFDYWxlbmRhcigpKTtcbiAgICAgICAge1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdfcmVwcl8nLCB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IGAke3RoaXNbU3ltYm9sLnRvU3RyaW5nVGFnXX0gPCR7VGVtcG9yYWxUaW1lVG9TdHJpbmcodGhpcywgJ2F1dG8nKX0+YCxcbiAgICAgICAgICAgICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGNhbGVuZGFyKCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxUaW1lKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICAvLyBQbGFpblRpbWUncyBjYWxlbmRhciBpc24ndCBzZXR0YWJsZSwgc28gY2FuJ3QgYmUgYSB1c2VybGFuZCBjYWxlbmRhclxuICAgICAgICByZXR1cm4gR2V0U2xvdCh0aGlzLCBDQUxFTkRBUik7XG4gICAgfVxuICAgIGdldCBob3VyKCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxUaW1lKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICByZXR1cm4gR2V0U2xvdCh0aGlzLCBJU09fSE9VUik7XG4gICAgfVxuICAgIGdldCBtaW51dGUoKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbFRpbWUodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIHJldHVybiBHZXRTbG90KHRoaXMsIElTT19NSU5VVEUpO1xuICAgIH1cbiAgICBnZXQgc2Vjb25kKCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxUaW1lKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICByZXR1cm4gR2V0U2xvdCh0aGlzLCBJU09fU0VDT05EKTtcbiAgICB9XG4gICAgZ2V0IG1pbGxpc2Vjb25kKCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxUaW1lKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICByZXR1cm4gR2V0U2xvdCh0aGlzLCBJU09fTUlMTElTRUNPTkQpO1xuICAgIH1cbiAgICBnZXQgbWljcm9zZWNvbmQoKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbFRpbWUodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIHJldHVybiBHZXRTbG90KHRoaXMsIElTT19NSUNST1NFQ09ORCk7XG4gICAgfVxuICAgIGdldCBuYW5vc2Vjb25kKCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxUaW1lKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICByZXR1cm4gR2V0U2xvdCh0aGlzLCBJU09fTkFOT1NFQ09ORCk7XG4gICAgfVxuICAgIHdpdGgodGVtcG9yYWxUaW1lTGlrZSwgb3B0aW9uc1BhcmFtID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbFRpbWUodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIGlmICghSXNPYmplY3QodGVtcG9yYWxUaW1lTGlrZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgYXJndW1lbnQnKTtcbiAgICAgICAgfVxuICAgICAgICBSZWplY3RPYmplY3RXaXRoQ2FsZW5kYXJPclRpbWVab25lKHRlbXBvcmFsVGltZUxpa2UpO1xuICAgICAgICBjb25zdCBvcHRpb25zID0gR2V0T3B0aW9uc09iamVjdChvcHRpb25zUGFyYW0pO1xuICAgICAgICBjb25zdCBvdmVyZmxvdyA9IFRvVGVtcG9yYWxPdmVyZmxvdyhvcHRpb25zKTtcbiAgICAgICAgY29uc3QgcHJvcHMgPSBUb1BhcnRpYWxSZWNvcmQodGVtcG9yYWxUaW1lTGlrZSwgW1xuICAgICAgICAgICAgJ2hvdXInLFxuICAgICAgICAgICAgJ21pY3Jvc2Vjb25kJyxcbiAgICAgICAgICAgICdtaWxsaXNlY29uZCcsXG4gICAgICAgICAgICAnbWludXRlJyxcbiAgICAgICAgICAgICduYW5vc2Vjb25kJyxcbiAgICAgICAgICAgICdzZWNvbmQnXG4gICAgICAgIF0pO1xuICAgICAgICBpZiAoIXByb3BzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHRpbWUtbGlrZScpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZpZWxkcyA9IFRvVGVtcG9yYWxUaW1lUmVjb3JkKHRoaXMpO1xuICAgICAgICBsZXQgeyBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQsIG1pY3Jvc2Vjb25kLCBuYW5vc2Vjb25kIH0gPSBPYmplY3RBc3NpZ24oZmllbGRzLCBwcm9wcyk7XG4gICAgICAgICh7IGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZCwgbWljcm9zZWNvbmQsIG5hbm9zZWNvbmQgfSA9IFJlZ3VsYXRlVGltZShob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQsIG1pY3Jvc2Vjb25kLCBuYW5vc2Vjb25kLCBvdmVyZmxvdykpO1xuICAgICAgICByZXR1cm4gbmV3IFBsYWluVGltZShob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQsIG1pY3Jvc2Vjb25kLCBuYW5vc2Vjb25kKTtcbiAgICB9XG4gICAgYWRkKHRlbXBvcmFsRHVyYXRpb25MaWtlKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbFRpbWUodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIGNvbnN0IGR1cmF0aW9uID0gVG9MaW1pdGVkVGVtcG9yYWxEdXJhdGlvbih0ZW1wb3JhbER1cmF0aW9uTGlrZSk7XG4gICAgICAgIGNvbnN0IHsgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc2Vjb25kcywgbWljcm9zZWNvbmRzLCBuYW5vc2Vjb25kcyB9ID0gZHVyYXRpb247XG4gICAgICAgIGxldCBob3VyID0gR2V0U2xvdCh0aGlzLCBJU09fSE9VUik7XG4gICAgICAgIGxldCBtaW51dGUgPSBHZXRTbG90KHRoaXMsIElTT19NSU5VVEUpO1xuICAgICAgICBsZXQgc2Vjb25kID0gR2V0U2xvdCh0aGlzLCBJU09fU0VDT05EKTtcbiAgICAgICAgbGV0IG1pbGxpc2Vjb25kID0gR2V0U2xvdCh0aGlzLCBJU09fTUlMTElTRUNPTkQpO1xuICAgICAgICBsZXQgbWljcm9zZWNvbmQgPSBHZXRTbG90KHRoaXMsIElTT19NSUNST1NFQ09ORCk7XG4gICAgICAgIGxldCBuYW5vc2Vjb25kID0gR2V0U2xvdCh0aGlzLCBJU09fTkFOT1NFQ09ORCk7XG4gICAgICAgICh7IGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZCwgbWljcm9zZWNvbmQsIG5hbm9zZWNvbmQgfSA9IEFkZFRpbWUoaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kLCBtaWNyb3NlY29uZCwgbmFub3NlY29uZCwgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc2Vjb25kcywgbWljcm9zZWNvbmRzLCBuYW5vc2Vjb25kcykpO1xuICAgICAgICAoeyBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQsIG1pY3Jvc2Vjb25kLCBuYW5vc2Vjb25kIH0gPSBSZWd1bGF0ZVRpbWUoaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kLCBtaWNyb3NlY29uZCwgbmFub3NlY29uZCwgJ3JlamVjdCcpKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQbGFpblRpbWUoaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kLCBtaWNyb3NlY29uZCwgbmFub3NlY29uZCk7XG4gICAgfVxuICAgIHN1YnRyYWN0KHRlbXBvcmFsRHVyYXRpb25MaWtlKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbFRpbWUodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIGNvbnN0IGR1cmF0aW9uID0gVG9MaW1pdGVkVGVtcG9yYWxEdXJhdGlvbih0ZW1wb3JhbER1cmF0aW9uTGlrZSk7XG4gICAgICAgIGNvbnN0IHsgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc2Vjb25kcywgbWljcm9zZWNvbmRzLCBuYW5vc2Vjb25kcyB9ID0gZHVyYXRpb247XG4gICAgICAgIGxldCBob3VyID0gR2V0U2xvdCh0aGlzLCBJU09fSE9VUik7XG4gICAgICAgIGxldCBtaW51dGUgPSBHZXRTbG90KHRoaXMsIElTT19NSU5VVEUpO1xuICAgICAgICBsZXQgc2Vjb25kID0gR2V0U2xvdCh0aGlzLCBJU09fU0VDT05EKTtcbiAgICAgICAgbGV0IG1pbGxpc2Vjb25kID0gR2V0U2xvdCh0aGlzLCBJU09fTUlMTElTRUNPTkQpO1xuICAgICAgICBsZXQgbWljcm9zZWNvbmQgPSBHZXRTbG90KHRoaXMsIElTT19NSUNST1NFQ09ORCk7XG4gICAgICAgIGxldCBuYW5vc2Vjb25kID0gR2V0U2xvdCh0aGlzLCBJU09fTkFOT1NFQ09ORCk7XG4gICAgICAgICh7IGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZCwgbWljcm9zZWNvbmQsIG5hbm9zZWNvbmQgfSA9IEFkZFRpbWUoaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kLCBtaWNyb3NlY29uZCwgbmFub3NlY29uZCwgLWhvdXJzLCAtbWludXRlcywgLXNlY29uZHMsIC1taWxsaXNlY29uZHMsIC1taWNyb3NlY29uZHMsIC1uYW5vc2Vjb25kcykpO1xuICAgICAgICAoeyBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQsIG1pY3Jvc2Vjb25kLCBuYW5vc2Vjb25kIH0gPSBSZWd1bGF0ZVRpbWUoaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kLCBtaWNyb3NlY29uZCwgbmFub3NlY29uZCwgJ3JlamVjdCcpKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQbGFpblRpbWUoaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kLCBtaWNyb3NlY29uZCwgbmFub3NlY29uZCk7XG4gICAgfVxuICAgIHVudGlsKG90aGVyUGFyYW0sIG9wdGlvbnNQYXJhbSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxUaW1lKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICBjb25zdCBvdGhlciA9IFRvVGVtcG9yYWxUaW1lKG90aGVyUGFyYW0pO1xuICAgICAgICBjb25zdCBvcHRpb25zID0gR2V0T3B0aW9uc09iamVjdChvcHRpb25zUGFyYW0pO1xuICAgICAgICBjb25zdCBsYXJnZXN0VW5pdCA9IFRvTGFyZ2VzdFRlbXBvcmFsVW5pdChvcHRpb25zLCAnYXV0bycsIERJU0FMTE9XRURfVU5JVFMkMSwgJ2hvdXInKTtcbiAgICAgICAgY29uc3Qgc21hbGxlc3RVbml0ID0gVG9TbWFsbGVzdFRlbXBvcmFsVW5pdChvcHRpb25zLCAnbmFub3NlY29uZCcsIERJU0FMTE9XRURfVU5JVFMkMSk7XG4gICAgICAgIFZhbGlkYXRlVGVtcG9yYWxVbml0UmFuZ2UobGFyZ2VzdFVuaXQsIHNtYWxsZXN0VW5pdCk7XG4gICAgICAgIGNvbnN0IHJvdW5kaW5nTW9kZSA9IFRvVGVtcG9yYWxSb3VuZGluZ01vZGUob3B0aW9ucywgJ3RydW5jJyk7XG4gICAgICAgIGNvbnN0IHJvdW5kaW5nSW5jcmVtZW50ID0gVG9UZW1wb3JhbFJvdW5kaW5nSW5jcmVtZW50KG9wdGlvbnMsIE1BWF9JTkNSRU1FTlRTW3NtYWxsZXN0VW5pdF0sIGZhbHNlKTtcbiAgICAgICAgbGV0IHsgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc2Vjb25kcywgbWljcm9zZWNvbmRzLCBuYW5vc2Vjb25kcyB9ID0gRGlmZmVyZW5jZVRpbWUoR2V0U2xvdCh0aGlzLCBJU09fSE9VUiksIEdldFNsb3QodGhpcywgSVNPX01JTlVURSksIEdldFNsb3QodGhpcywgSVNPX1NFQ09ORCksIEdldFNsb3QodGhpcywgSVNPX01JTExJU0VDT05EKSwgR2V0U2xvdCh0aGlzLCBJU09fTUlDUk9TRUNPTkQpLCBHZXRTbG90KHRoaXMsIElTT19OQU5PU0VDT05EKSwgR2V0U2xvdChvdGhlciwgSVNPX0hPVVIpLCBHZXRTbG90KG90aGVyLCBJU09fTUlOVVRFKSwgR2V0U2xvdChvdGhlciwgSVNPX1NFQ09ORCksIEdldFNsb3Qob3RoZXIsIElTT19NSUxMSVNFQ09ORCksIEdldFNsb3Qob3RoZXIsIElTT19NSUNST1NFQ09ORCksIEdldFNsb3Qob3RoZXIsIElTT19OQU5PU0VDT05EKSk7XG4gICAgICAgICh7IGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBtaWxsaXNlY29uZHMsIG1pY3Jvc2Vjb25kcywgbmFub3NlY29uZHMgfSA9IFJvdW5kRHVyYXRpb24oMCwgMCwgMCwgMCwgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc2Vjb25kcywgbWljcm9zZWNvbmRzLCBuYW5vc2Vjb25kcywgcm91bmRpbmdJbmNyZW1lbnQsIHNtYWxsZXN0VW5pdCwgcm91bmRpbmdNb2RlKSk7XG4gICAgICAgICh7IGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBtaWxsaXNlY29uZHMsIG1pY3Jvc2Vjb25kcywgbmFub3NlY29uZHMgfSA9IEJhbGFuY2VEdXJhdGlvbigwLCBob3VycywgbWludXRlcywgc2Vjb25kcywgbWlsbGlzZWNvbmRzLCBtaWNyb3NlY29uZHMsIG5hbm9zZWNvbmRzLCBsYXJnZXN0VW5pdCkpO1xuICAgICAgICBjb25zdCBEdXJhdGlvbiA9IEdldEludHJpbnNpYygnJVRlbXBvcmFsLkR1cmF0aW9uJScpO1xuICAgICAgICByZXR1cm4gbmV3IER1cmF0aW9uKDAsIDAsIDAsIDAsIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBtaWxsaXNlY29uZHMsIG1pY3Jvc2Vjb25kcywgbmFub3NlY29uZHMpO1xuICAgIH1cbiAgICBzaW5jZShvdGhlclBhcmFtLCBvcHRpb25zUGFyYW0gPSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsVGltZSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgY29uc3Qgb3RoZXIgPSBUb1RlbXBvcmFsVGltZShvdGhlclBhcmFtKTtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IEdldE9wdGlvbnNPYmplY3Qob3B0aW9uc1BhcmFtKTtcbiAgICAgICAgY29uc3QgbGFyZ2VzdFVuaXQgPSBUb0xhcmdlc3RUZW1wb3JhbFVuaXQob3B0aW9ucywgJ2F1dG8nLCBESVNBTExPV0VEX1VOSVRTJDEsICdob3VyJyk7XG4gICAgICAgIGNvbnN0IHNtYWxsZXN0VW5pdCA9IFRvU21hbGxlc3RUZW1wb3JhbFVuaXQob3B0aW9ucywgJ25hbm9zZWNvbmQnLCBESVNBTExPV0VEX1VOSVRTJDEpO1xuICAgICAgICBWYWxpZGF0ZVRlbXBvcmFsVW5pdFJhbmdlKGxhcmdlc3RVbml0LCBzbWFsbGVzdFVuaXQpO1xuICAgICAgICBjb25zdCByb3VuZGluZ01vZGUgPSBUb1RlbXBvcmFsUm91bmRpbmdNb2RlKG9wdGlvbnMsICd0cnVuYycpO1xuICAgICAgICBjb25zdCByb3VuZGluZ0luY3JlbWVudCA9IFRvVGVtcG9yYWxSb3VuZGluZ0luY3JlbWVudChvcHRpb25zLCBNQVhfSU5DUkVNRU5UU1tzbWFsbGVzdFVuaXRdLCBmYWxzZSk7XG4gICAgICAgIGxldCB7IGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBtaWxsaXNlY29uZHMsIG1pY3Jvc2Vjb25kcywgbmFub3NlY29uZHMgfSA9IERpZmZlcmVuY2VUaW1lKEdldFNsb3Qob3RoZXIsIElTT19IT1VSKSwgR2V0U2xvdChvdGhlciwgSVNPX01JTlVURSksIEdldFNsb3Qob3RoZXIsIElTT19TRUNPTkQpLCBHZXRTbG90KG90aGVyLCBJU09fTUlMTElTRUNPTkQpLCBHZXRTbG90KG90aGVyLCBJU09fTUlDUk9TRUNPTkQpLCBHZXRTbG90KG90aGVyLCBJU09fTkFOT1NFQ09ORCksIEdldFNsb3QodGhpcywgSVNPX0hPVVIpLCBHZXRTbG90KHRoaXMsIElTT19NSU5VVEUpLCBHZXRTbG90KHRoaXMsIElTT19TRUNPTkQpLCBHZXRTbG90KHRoaXMsIElTT19NSUxMSVNFQ09ORCksIEdldFNsb3QodGhpcywgSVNPX01JQ1JPU0VDT05EKSwgR2V0U2xvdCh0aGlzLCBJU09fTkFOT1NFQ09ORCkpO1xuICAgICAgICAoeyBob3VycywgbWludXRlcywgc2Vjb25kcywgbWlsbGlzZWNvbmRzLCBtaWNyb3NlY29uZHMsIG5hbm9zZWNvbmRzIH0gPSBSb3VuZER1cmF0aW9uKDAsIDAsIDAsIDAsIC1ob3VycywgLW1pbnV0ZXMsIC1zZWNvbmRzLCAtbWlsbGlzZWNvbmRzLCAtbWljcm9zZWNvbmRzLCAtbmFub3NlY29uZHMsIHJvdW5kaW5nSW5jcmVtZW50LCBzbWFsbGVzdFVuaXQsIE5lZ2F0ZVRlbXBvcmFsUm91bmRpbmdNb2RlKHJvdW5kaW5nTW9kZSkpKTtcbiAgICAgICAgaG91cnMgPSAtaG91cnM7XG4gICAgICAgIG1pbnV0ZXMgPSAtbWludXRlcztcbiAgICAgICAgc2Vjb25kcyA9IC1zZWNvbmRzO1xuICAgICAgICBtaWxsaXNlY29uZHMgPSAtbWlsbGlzZWNvbmRzO1xuICAgICAgICBtaWNyb3NlY29uZHMgPSAtbWljcm9zZWNvbmRzO1xuICAgICAgICBuYW5vc2Vjb25kcyA9IC1uYW5vc2Vjb25kcztcbiAgICAgICAgKHsgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc2Vjb25kcywgbWljcm9zZWNvbmRzLCBuYW5vc2Vjb25kcyB9ID0gQmFsYW5jZUR1cmF0aW9uKDAsIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBtaWxsaXNlY29uZHMsIG1pY3Jvc2Vjb25kcywgbmFub3NlY29uZHMsIGxhcmdlc3RVbml0KSk7XG4gICAgICAgIGNvbnN0IER1cmF0aW9uID0gR2V0SW50cmluc2ljKCclVGVtcG9yYWwuRHVyYXRpb24lJyk7XG4gICAgICAgIHJldHVybiBuZXcgRHVyYXRpb24oMCwgMCwgMCwgMCwgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc2Vjb25kcywgbWljcm9zZWNvbmRzLCBuYW5vc2Vjb25kcyk7XG4gICAgfVxuICAgIHJvdW5kKG9wdGlvbnNQYXJhbSkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxUaW1lKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICBpZiAob3B0aW9uc1BhcmFtID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdvcHRpb25zIHBhcmFtZXRlciBpcyByZXF1aXJlZCcpO1xuICAgICAgICBjb25zdCBvcHRpb25zID0gdHlwZW9mIG9wdGlvbnNQYXJhbSA9PT0gJ3N0cmluZydcbiAgICAgICAgICAgID8gQ3JlYXRlT25lUHJvcE9iamVjdCgnc21hbGxlc3RVbml0Jywgb3B0aW9uc1BhcmFtKVxuICAgICAgICAgICAgOiBHZXRPcHRpb25zT2JqZWN0KG9wdGlvbnNQYXJhbSk7XG4gICAgICAgIGNvbnN0IHNtYWxsZXN0VW5pdCA9IFRvU21hbGxlc3RUZW1wb3JhbFVuaXQob3B0aW9ucywgdW5kZWZpbmVkLCBESVNBTExPV0VEX1VOSVRTJDEpO1xuICAgICAgICBpZiAoc21hbGxlc3RVbml0ID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc21hbGxlc3RVbml0IGlzIHJlcXVpcmVkJyk7XG4gICAgICAgIGNvbnN0IHJvdW5kaW5nTW9kZSA9IFRvVGVtcG9yYWxSb3VuZGluZ01vZGUob3B0aW9ucywgJ2hhbGZFeHBhbmQnKTtcbiAgICAgICAgY29uc3Qgcm91bmRpbmdJbmNyZW1lbnQgPSBUb1RlbXBvcmFsUm91bmRpbmdJbmNyZW1lbnQob3B0aW9ucywgTUFYX0lOQ1JFTUVOVFNbc21hbGxlc3RVbml0XSwgZmFsc2UpO1xuICAgICAgICBsZXQgaG91ciA9IEdldFNsb3QodGhpcywgSVNPX0hPVVIpO1xuICAgICAgICBsZXQgbWludXRlID0gR2V0U2xvdCh0aGlzLCBJU09fTUlOVVRFKTtcbiAgICAgICAgbGV0IHNlY29uZCA9IEdldFNsb3QodGhpcywgSVNPX1NFQ09ORCk7XG4gICAgICAgIGxldCBtaWxsaXNlY29uZCA9IEdldFNsb3QodGhpcywgSVNPX01JTExJU0VDT05EKTtcbiAgICAgICAgbGV0IG1pY3Jvc2Vjb25kID0gR2V0U2xvdCh0aGlzLCBJU09fTUlDUk9TRUNPTkQpO1xuICAgICAgICBsZXQgbmFub3NlY29uZCA9IEdldFNsb3QodGhpcywgSVNPX05BTk9TRUNPTkQpO1xuICAgICAgICAoeyBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQsIG1pY3Jvc2Vjb25kLCBuYW5vc2Vjb25kIH0gPSBSb3VuZFRpbWUoaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kLCBtaWNyb3NlY29uZCwgbmFub3NlY29uZCwgcm91bmRpbmdJbmNyZW1lbnQsIHNtYWxsZXN0VW5pdCwgcm91bmRpbmdNb2RlKSk7XG4gICAgICAgIHJldHVybiBuZXcgUGxhaW5UaW1lKGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZCwgbWljcm9zZWNvbmQsIG5hbm9zZWNvbmQpO1xuICAgIH1cbiAgICBlcXVhbHMob3RoZXJQYXJhbSkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxUaW1lKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICBjb25zdCBvdGhlciA9IFRvVGVtcG9yYWxUaW1lKG90aGVyUGFyYW0pO1xuICAgICAgICBmb3IgKGNvbnN0IHNsb3Qgb2YgW0lTT19IT1VSLCBJU09fTUlOVVRFLCBJU09fU0VDT05ELCBJU09fTUlMTElTRUNPTkQsIElTT19NSUNST1NFQ09ORCwgSVNPX05BTk9TRUNPTkRdKSB7XG4gICAgICAgICAgICBjb25zdCB2YWwxID0gR2V0U2xvdCh0aGlzLCBzbG90KTtcbiAgICAgICAgICAgIGNvbnN0IHZhbDIgPSBHZXRTbG90KG90aGVyLCBzbG90KTtcbiAgICAgICAgICAgIGlmICh2YWwxICE9PSB2YWwyKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgdG9TdHJpbmcob3B0aW9uc1BhcmFtID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbFRpbWUodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSBHZXRPcHRpb25zT2JqZWN0KG9wdGlvbnNQYXJhbSk7XG4gICAgICAgIGNvbnN0IHsgcHJlY2lzaW9uLCB1bml0LCBpbmNyZW1lbnQgfSA9IFRvU2Vjb25kc1N0cmluZ1ByZWNpc2lvbihvcHRpb25zKTtcbiAgICAgICAgY29uc3Qgcm91bmRpbmdNb2RlID0gVG9UZW1wb3JhbFJvdW5kaW5nTW9kZShvcHRpb25zLCAndHJ1bmMnKTtcbiAgICAgICAgcmV0dXJuIFRlbXBvcmFsVGltZVRvU3RyaW5nKHRoaXMsIHByZWNpc2lvbiwgeyB1bml0LCBpbmNyZW1lbnQsIHJvdW5kaW5nTW9kZSB9KTtcbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxUaW1lKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICByZXR1cm4gVGVtcG9yYWxUaW1lVG9TdHJpbmcodGhpcywgJ2F1dG8nKTtcbiAgICB9XG4gICAgdG9Mb2NhbGVTdHJpbmcobG9jYWxlcyA9IHVuZGVmaW5lZCwgb3B0aW9ucyA9IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxUaW1lKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICByZXR1cm4gbmV3IERhdGVUaW1lRm9ybWF0KGxvY2FsZXMsIG9wdGlvbnMpLmZvcm1hdCh0aGlzKTtcbiAgICB9XG4gICAgdmFsdWVPZigpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigndXNlIGNvbXBhcmUoKSBvciBlcXVhbHMoKSB0byBjb21wYXJlIFRlbXBvcmFsLlBsYWluVGltZScpO1xuICAgIH1cbiAgICB0b1BsYWluRGF0ZVRpbWUodGVtcG9yYWxEYXRlUGFyYW0pIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsVGltZSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgY29uc3QgdGVtcG9yYWxEYXRlID0gVG9UZW1wb3JhbERhdGUodGVtcG9yYWxEYXRlUGFyYW0pO1xuICAgICAgICBjb25zdCB5ZWFyID0gR2V0U2xvdCh0ZW1wb3JhbERhdGUsIElTT19ZRUFSKTtcbiAgICAgICAgY29uc3QgbW9udGggPSBHZXRTbG90KHRlbXBvcmFsRGF0ZSwgSVNPX01PTlRIKTtcbiAgICAgICAgY29uc3QgZGF5ID0gR2V0U2xvdCh0ZW1wb3JhbERhdGUsIElTT19EQVkpO1xuICAgICAgICBjb25zdCBjYWxlbmRhciA9IEdldFNsb3QodGVtcG9yYWxEYXRlLCBDQUxFTkRBUik7XG4gICAgICAgIGNvbnN0IGhvdXIgPSBHZXRTbG90KHRoaXMsIElTT19IT1VSKTtcbiAgICAgICAgY29uc3QgbWludXRlID0gR2V0U2xvdCh0aGlzLCBJU09fTUlOVVRFKTtcbiAgICAgICAgY29uc3Qgc2Vjb25kID0gR2V0U2xvdCh0aGlzLCBJU09fU0VDT05EKTtcbiAgICAgICAgY29uc3QgbWlsbGlzZWNvbmQgPSBHZXRTbG90KHRoaXMsIElTT19NSUxMSVNFQ09ORCk7XG4gICAgICAgIGNvbnN0IG1pY3Jvc2Vjb25kID0gR2V0U2xvdCh0aGlzLCBJU09fTUlDUk9TRUNPTkQpO1xuICAgICAgICBjb25zdCBuYW5vc2Vjb25kID0gR2V0U2xvdCh0aGlzLCBJU09fTkFOT1NFQ09ORCk7XG4gICAgICAgIHJldHVybiBDcmVhdGVUZW1wb3JhbERhdGVUaW1lKHllYXIsIG1vbnRoLCBkYXksIGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZCwgbWljcm9zZWNvbmQsIG5hbm9zZWNvbmQsIGNhbGVuZGFyKTtcbiAgICB9XG4gICAgdG9ab25lZERhdGVUaW1lKGl0ZW0pIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsVGltZSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgaWYgKCFJc09iamVjdChpdGVtKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBhcmd1bWVudCcpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRhdGVMaWtlID0gaXRlbS5wbGFpbkRhdGU7XG4gICAgICAgIGlmIChkYXRlTGlrZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdtaXNzaW5nIGRhdGUgcHJvcGVydHknKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0ZW1wb3JhbERhdGUgPSBUb1RlbXBvcmFsRGF0ZShkYXRlTGlrZSk7XG4gICAgICAgIGNvbnN0IHRpbWVab25lTGlrZSA9IGl0ZW0udGltZVpvbmU7XG4gICAgICAgIGlmICh0aW1lWm9uZUxpa2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbWlzc2luZyB0aW1lWm9uZSBwcm9wZXJ0eScpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRpbWVab25lID0gVG9UZW1wb3JhbFRpbWVab25lKHRpbWVab25lTGlrZSk7XG4gICAgICAgIGNvbnN0IHllYXIgPSBHZXRTbG90KHRlbXBvcmFsRGF0ZSwgSVNPX1lFQVIpO1xuICAgICAgICBjb25zdCBtb250aCA9IEdldFNsb3QodGVtcG9yYWxEYXRlLCBJU09fTU9OVEgpO1xuICAgICAgICBjb25zdCBkYXkgPSBHZXRTbG90KHRlbXBvcmFsRGF0ZSwgSVNPX0RBWSk7XG4gICAgICAgIGNvbnN0IGNhbGVuZGFyID0gR2V0U2xvdCh0ZW1wb3JhbERhdGUsIENBTEVOREFSKTtcbiAgICAgICAgY29uc3QgaG91ciA9IEdldFNsb3QodGhpcywgSVNPX0hPVVIpO1xuICAgICAgICBjb25zdCBtaW51dGUgPSBHZXRTbG90KHRoaXMsIElTT19NSU5VVEUpO1xuICAgICAgICBjb25zdCBzZWNvbmQgPSBHZXRTbG90KHRoaXMsIElTT19TRUNPTkQpO1xuICAgICAgICBjb25zdCBtaWxsaXNlY29uZCA9IEdldFNsb3QodGhpcywgSVNPX01JTExJU0VDT05EKTtcbiAgICAgICAgY29uc3QgbWljcm9zZWNvbmQgPSBHZXRTbG90KHRoaXMsIElTT19NSUNST1NFQ09ORCk7XG4gICAgICAgIGNvbnN0IG5hbm9zZWNvbmQgPSBHZXRTbG90KHRoaXMsIElTT19OQU5PU0VDT05EKTtcbiAgICAgICAgY29uc3QgUGxhaW5EYXRlVGltZSA9IEdldEludHJpbnNpYygnJVRlbXBvcmFsLlBsYWluRGF0ZVRpbWUlJyk7XG4gICAgICAgIGNvbnN0IGR0ID0gbmV3IFBsYWluRGF0ZVRpbWUoeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kLCBtaWNyb3NlY29uZCwgbmFub3NlY29uZCwgY2FsZW5kYXIpO1xuICAgICAgICBjb25zdCBpbnN0YW50ID0gQnVpbHRpblRpbWVab25lR2V0SW5zdGFudEZvcih0aW1lWm9uZSwgZHQsICdjb21wYXRpYmxlJyk7XG4gICAgICAgIHJldHVybiBDcmVhdGVUZW1wb3JhbFpvbmVkRGF0ZVRpbWUoR2V0U2xvdChpbnN0YW50LCBFUE9DSE5BTk9TRUNPTkRTKSwgdGltZVpvbmUsIGNhbGVuZGFyKTtcbiAgICB9XG4gICAgZ2V0SVNPRmllbGRzKCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxUaW1lKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY2FsZW5kYXI6IEdldFNsb3QodGhpcywgQ0FMRU5EQVIpLFxuICAgICAgICAgICAgaXNvSG91cjogR2V0U2xvdCh0aGlzLCBJU09fSE9VUiksXG4gICAgICAgICAgICBpc29NaWNyb3NlY29uZDogR2V0U2xvdCh0aGlzLCBJU09fTUlDUk9TRUNPTkQpLFxuICAgICAgICAgICAgaXNvTWlsbGlzZWNvbmQ6IEdldFNsb3QodGhpcywgSVNPX01JTExJU0VDT05EKSxcbiAgICAgICAgICAgIGlzb01pbnV0ZTogR2V0U2xvdCh0aGlzLCBJU09fTUlOVVRFKSxcbiAgICAgICAgICAgIGlzb05hbm9zZWNvbmQ6IEdldFNsb3QodGhpcywgSVNPX05BTk9TRUNPTkQpLFxuICAgICAgICAgICAgaXNvU2Vjb25kOiBHZXRTbG90KHRoaXMsIElTT19TRUNPTkQpXG4gICAgICAgIH07XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tKGl0ZW0sIG9wdGlvbnNQYXJhbSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCBvcHRpb25zID0gR2V0T3B0aW9uc09iamVjdChvcHRpb25zUGFyYW0pO1xuICAgICAgICBjb25zdCBvdmVyZmxvdyA9IFRvVGVtcG9yYWxPdmVyZmxvdyhvcHRpb25zKTtcbiAgICAgICAgaWYgKElzVGVtcG9yYWxUaW1lKGl0ZW0pKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFBsYWluVGltZShHZXRTbG90KGl0ZW0sIElTT19IT1VSKSwgR2V0U2xvdChpdGVtLCBJU09fTUlOVVRFKSwgR2V0U2xvdChpdGVtLCBJU09fU0VDT05EKSwgR2V0U2xvdChpdGVtLCBJU09fTUlMTElTRUNPTkQpLCBHZXRTbG90KGl0ZW0sIElTT19NSUNST1NFQ09ORCksIEdldFNsb3QoaXRlbSwgSVNPX05BTk9TRUNPTkQpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gVG9UZW1wb3JhbFRpbWUoaXRlbSwgb3ZlcmZsb3cpO1xuICAgIH1cbiAgICBzdGF0aWMgY29tcGFyZShvbmVQYXJhbSwgdHdvUGFyYW0pIHtcbiAgICAgICAgY29uc3Qgb25lID0gVG9UZW1wb3JhbFRpbWUob25lUGFyYW0pO1xuICAgICAgICBjb25zdCB0d28gPSBUb1RlbXBvcmFsVGltZSh0d29QYXJhbSk7XG4gICAgICAgIGZvciAoY29uc3Qgc2xvdCBvZiBbSVNPX0hPVVIsIElTT19NSU5VVEUsIElTT19TRUNPTkQsIElTT19NSUxMSVNFQ09ORCwgSVNPX01JQ1JPU0VDT05ELCBJU09fTkFOT1NFQ09ORF0pIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbDEgPSBHZXRTbG90KG9uZSwgc2xvdCk7XG4gICAgICAgICAgICBjb25zdCB2YWwyID0gR2V0U2xvdCh0d28sIHNsb3QpO1xuICAgICAgICAgICAgaWYgKHZhbDEgIT09IHZhbDIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIENvbXBhcmlzb25SZXN1bHQodmFsMSAtIHZhbDIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbn1cbk1ha2VJbnRyaW5zaWNDbGFzcyhQbGFpblRpbWUsICdUZW1wb3JhbC5QbGFpblRpbWUnKTtcblxuY2xhc3MgVGltZVpvbmUge1xuICAgIGNvbnN0cnVjdG9yKHRpbWVab25lSWRlbnRpZmllclBhcmFtKSB7XG4gICAgICAgIC8vIE5vdGU6IGlmIHRoZSBhcmd1bWVudCBpcyBub3QgcGFzc2VkLCBHZXRDYW5vbmljYWxUaW1lWm9uZUlkZW50aWZpZXIodW5kZWZpbmVkKSB3aWxsIHRocm93LlxuICAgICAgICAvLyAgICAgICBUaGlzIGNoZWNrIGV4aXN0cyBvbmx5IHRvIGltcHJvdmUgdGhlIGVycm9yIG1lc3NhZ2UuXG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ21pc3NpbmcgYXJndW1lbnQ6IGlkZW50aWZpZXIgaXMgcmVxdWlyZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0aW1lWm9uZUlkZW50aWZpZXIgPSBHZXRDYW5vbmljYWxUaW1lWm9uZUlkZW50aWZpZXIodGltZVpvbmVJZGVudGlmaWVyUGFyYW0pO1xuICAgICAgICBDcmVhdGVTbG90cyh0aGlzKTtcbiAgICAgICAgU2V0U2xvdCh0aGlzLCBUSU1FWk9ORV9JRCwgdGltZVpvbmVJZGVudGlmaWVyKTtcbiAgICAgICAge1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdfcmVwcl8nLCB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IGAke3RoaXNbU3ltYm9sLnRvU3RyaW5nVGFnXX0gPCR7dGltZVpvbmVJZGVudGlmaWVyfT5gLFxuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgaWQoKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbFRpbWVab25lKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICByZXR1cm4gVG9TdHJpbmcodGhpcyk7XG4gICAgfVxuICAgIGdldE9mZnNldE5hbm9zZWNvbmRzRm9yKGluc3RhbnRQYXJhbSkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxUaW1lWm9uZSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgY29uc3QgaW5zdGFudCA9IFRvVGVtcG9yYWxJbnN0YW50KGluc3RhbnRQYXJhbSk7XG4gICAgICAgIGNvbnN0IGlkID0gR2V0U2xvdCh0aGlzLCBUSU1FWk9ORV9JRCk7XG4gICAgICAgIGlmIChUZXN0VGltZVpvbmVPZmZzZXRTdHJpbmcoaWQpKSB7XG4gICAgICAgICAgICByZXR1cm4gUGFyc2VUaW1lWm9uZU9mZnNldFN0cmluZyhpZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEdldElBTkFUaW1lWm9uZU9mZnNldE5hbm9zZWNvbmRzKEdldFNsb3QoaW5zdGFudCwgRVBPQ0hOQU5PU0VDT05EUyksIGlkKTtcbiAgICB9XG4gICAgZ2V0T2Zmc2V0U3RyaW5nRm9yKGluc3RhbnRQYXJhbSkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxUaW1lWm9uZSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgY29uc3QgaW5zdGFudCA9IFRvVGVtcG9yYWxJbnN0YW50KGluc3RhbnRQYXJhbSk7XG4gICAgICAgIHJldHVybiBCdWlsdGluVGltZVpvbmVHZXRPZmZzZXRTdHJpbmdGb3IodGhpcywgaW5zdGFudCk7XG4gICAgfVxuICAgIGdldFBsYWluRGF0ZVRpbWVGb3IoaW5zdGFudFBhcmFtLCBjYWxlbmRhclBhcmFtID0gR2V0SVNPODYwMUNhbGVuZGFyKCkpIHtcbiAgICAgICAgY29uc3QgaW5zdGFudCA9IFRvVGVtcG9yYWxJbnN0YW50KGluc3RhbnRQYXJhbSk7XG4gICAgICAgIGNvbnN0IGNhbGVuZGFyID0gVG9UZW1wb3JhbENhbGVuZGFyKGNhbGVuZGFyUGFyYW0pO1xuICAgICAgICByZXR1cm4gQnVpbHRpblRpbWVab25lR2V0UGxhaW5EYXRlVGltZUZvcih0aGlzLCBpbnN0YW50LCBjYWxlbmRhcik7XG4gICAgfVxuICAgIGdldEluc3RhbnRGb3IoZGF0ZVRpbWVQYXJhbSwgb3B0aW9uc1BhcmFtID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbFRpbWVab25lKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICBjb25zdCBkYXRlVGltZSA9IFRvVGVtcG9yYWxEYXRlVGltZShkYXRlVGltZVBhcmFtKTtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IEdldE9wdGlvbnNPYmplY3Qob3B0aW9uc1BhcmFtKTtcbiAgICAgICAgY29uc3QgZGlzYW1iaWd1YXRpb24gPSBUb1RlbXBvcmFsRGlzYW1iaWd1YXRpb24ob3B0aW9ucyk7XG4gICAgICAgIHJldHVybiBCdWlsdGluVGltZVpvbmVHZXRJbnN0YW50Rm9yKHRoaXMsIGRhdGVUaW1lLCBkaXNhbWJpZ3VhdGlvbik7XG4gICAgfVxuICAgIGdldFBvc3NpYmxlSW5zdGFudHNGb3IoZGF0ZVRpbWVQYXJhbSkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxUaW1lWm9uZSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgY29uc3QgZGF0ZVRpbWUgPSBUb1RlbXBvcmFsRGF0ZVRpbWUoZGF0ZVRpbWVQYXJhbSk7XG4gICAgICAgIGNvbnN0IEluc3RhbnQgPSBHZXRJbnRyaW5zaWMoJyVUZW1wb3JhbC5JbnN0YW50JScpO1xuICAgICAgICBjb25zdCBpZCA9IEdldFNsb3QodGhpcywgVElNRVpPTkVfSUQpO1xuICAgICAgICBpZiAoVGVzdFRpbWVab25lT2Zmc2V0U3RyaW5nKGlkKSkge1xuICAgICAgICAgICAgY29uc3QgZXBvY2hOcyA9IEdldEVwb2NoRnJvbUlTT1BhcnRzKEdldFNsb3QoZGF0ZVRpbWUsIElTT19ZRUFSKSwgR2V0U2xvdChkYXRlVGltZSwgSVNPX01PTlRIKSwgR2V0U2xvdChkYXRlVGltZSwgSVNPX0RBWSksIEdldFNsb3QoZGF0ZVRpbWUsIElTT19IT1VSKSwgR2V0U2xvdChkYXRlVGltZSwgSVNPX01JTlVURSksIEdldFNsb3QoZGF0ZVRpbWUsIElTT19TRUNPTkQpLCBHZXRTbG90KGRhdGVUaW1lLCBJU09fTUlMTElTRUNPTkQpLCBHZXRTbG90KGRhdGVUaW1lLCBJU09fTUlDUk9TRUNPTkQpLCBHZXRTbG90KGRhdGVUaW1lLCBJU09fTkFOT1NFQ09ORCkpO1xuICAgICAgICAgICAgaWYgKGVwb2NoTnMgPT09IG51bGwpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0RhdGVUaW1lIG91dHNpZGUgb2Ygc3VwcG9ydGVkIHJhbmdlJyk7XG4gICAgICAgICAgICBjb25zdCBvZmZzZXROcyA9IFBhcnNlVGltZVpvbmVPZmZzZXRTdHJpbmcoaWQpO1xuICAgICAgICAgICAgcmV0dXJuIFtuZXcgSW5zdGFudChKU0JJLnN1YnRyYWN0KGVwb2NoTnMsIEpTQkkuQmlnSW50KG9mZnNldE5zKSkpXTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwb3NzaWJsZUVwb2NoTnMgPSBHZXRJQU5BVGltZVpvbmVFcG9jaFZhbHVlKGlkLCBHZXRTbG90KGRhdGVUaW1lLCBJU09fWUVBUiksIEdldFNsb3QoZGF0ZVRpbWUsIElTT19NT05USCksIEdldFNsb3QoZGF0ZVRpbWUsIElTT19EQVkpLCBHZXRTbG90KGRhdGVUaW1lLCBJU09fSE9VUiksIEdldFNsb3QoZGF0ZVRpbWUsIElTT19NSU5VVEUpLCBHZXRTbG90KGRhdGVUaW1lLCBJU09fU0VDT05EKSwgR2V0U2xvdChkYXRlVGltZSwgSVNPX01JTExJU0VDT05EKSwgR2V0U2xvdChkYXRlVGltZSwgSVNPX01JQ1JPU0VDT05EKSwgR2V0U2xvdChkYXRlVGltZSwgSVNPX05BTk9TRUNPTkQpKTtcbiAgICAgICAgcmV0dXJuIHBvc3NpYmxlRXBvY2hOcy5tYXAoKG5zKSA9PiBuZXcgSW5zdGFudChucykpO1xuICAgIH1cbiAgICBnZXROZXh0VHJhbnNpdGlvbihzdGFydGluZ1BvaW50UGFyYW0pIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsVGltZVpvbmUodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIGNvbnN0IHN0YXJ0aW5nUG9pbnQgPSBUb1RlbXBvcmFsSW5zdGFudChzdGFydGluZ1BvaW50UGFyYW0pO1xuICAgICAgICBjb25zdCBpZCA9IEdldFNsb3QodGhpcywgVElNRVpPTkVfSUQpO1xuICAgICAgICAvLyBPZmZzZXQgdGltZSB6b25lcyBvciBVVEMgaGF2ZSBubyB0cmFuc2l0aW9uc1xuICAgICAgICBpZiAoVGVzdFRpbWVab25lT2Zmc2V0U3RyaW5nKGlkKSB8fCBpZCA9PT0gJ1VUQycpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGxldCBlcG9jaE5hbm9zZWNvbmRzID0gR2V0U2xvdChzdGFydGluZ1BvaW50LCBFUE9DSE5BTk9TRUNPTkRTKTtcbiAgICAgICAgY29uc3QgSW5zdGFudCA9IEdldEludHJpbnNpYygnJVRlbXBvcmFsLkluc3RhbnQlJyk7XG4gICAgICAgIGVwb2NoTmFub3NlY29uZHMgPSBHZXRJQU5BVGltZVpvbmVOZXh0VHJhbnNpdGlvbihlcG9jaE5hbm9zZWNvbmRzLCBpZCk7XG4gICAgICAgIHJldHVybiBlcG9jaE5hbm9zZWNvbmRzID09PSBudWxsID8gbnVsbCA6IG5ldyBJbnN0YW50KGVwb2NoTmFub3NlY29uZHMpO1xuICAgIH1cbiAgICBnZXRQcmV2aW91c1RyYW5zaXRpb24oc3RhcnRpbmdQb2ludFBhcmFtKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbFRpbWVab25lKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICBjb25zdCBzdGFydGluZ1BvaW50ID0gVG9UZW1wb3JhbEluc3RhbnQoc3RhcnRpbmdQb2ludFBhcmFtKTtcbiAgICAgICAgY29uc3QgaWQgPSBHZXRTbG90KHRoaXMsIFRJTUVaT05FX0lEKTtcbiAgICAgICAgLy8gT2Zmc2V0IHRpbWUgem9uZXMgb3IgVVRDIGhhdmUgbm8gdHJhbnNpdGlvbnNcbiAgICAgICAgaWYgKFRlc3RUaW1lWm9uZU9mZnNldFN0cmluZyhpZCkgfHwgaWQgPT09ICdVVEMnKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZXBvY2hOYW5vc2Vjb25kcyA9IEdldFNsb3Qoc3RhcnRpbmdQb2ludCwgRVBPQ0hOQU5PU0VDT05EUyk7XG4gICAgICAgIGNvbnN0IEluc3RhbnQgPSBHZXRJbnRyaW5zaWMoJyVUZW1wb3JhbC5JbnN0YW50JScpO1xuICAgICAgICBlcG9jaE5hbm9zZWNvbmRzID0gR2V0SUFOQVRpbWVab25lUHJldmlvdXNUcmFuc2l0aW9uKGVwb2NoTmFub3NlY29uZHMsIGlkKTtcbiAgICAgICAgcmV0dXJuIGVwb2NoTmFub3NlY29uZHMgPT09IG51bGwgPyBudWxsIDogbmV3IEluc3RhbnQoZXBvY2hOYW5vc2Vjb25kcyk7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxUaW1lWm9uZSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgcmV0dXJuIFRvU3RyaW5nKEdldFNsb3QodGhpcywgVElNRVpPTkVfSUQpKTtcbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxUaW1lWm9uZSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgcmV0dXJuIFRvU3RyaW5nKHRoaXMpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbShpdGVtKSB7XG4gICAgICAgIHJldHVybiBUb1RlbXBvcmFsVGltZVpvbmUoaXRlbSk7XG4gICAgfVxufVxuTWFrZUludHJpbnNpY0NsYXNzKFRpbWVab25lLCAnVGVtcG9yYWwuVGltZVpvbmUnKTtcblxuY29uc3QgT2JqZWN0Q3JlYXRlID0gT2JqZWN0LmNyZWF0ZTtcbmNvbnN0IERJU0FMTE9XRURfVU5JVFMgPSBbXG4gICAgJ3dlZWsnLFxuICAgICdkYXknLFxuICAgICdob3VyJyxcbiAgICAnbWludXRlJyxcbiAgICAnc2Vjb25kJyxcbiAgICAnbWlsbGlzZWNvbmQnLFxuICAgICdtaWNyb3NlY29uZCcsXG4gICAgJ25hbm9zZWNvbmQnXG5dO1xuY2xhc3MgUGxhaW5ZZWFyTW9udGgge1xuICAgIGNvbnN0cnVjdG9yKGlzb1llYXJQYXJhbSwgaXNvTW9udGhQYXJhbSwgY2FsZW5kYXJQYXJhbSA9IEdldElTTzg2MDFDYWxlbmRhcigpLCByZWZlcmVuY2VJU09EYXlQYXJhbSA9IDEpIHtcbiAgICAgICAgY29uc3QgaXNvWWVhciA9IFRvSW50ZWdlclRocm93T25JbmZpbml0eShpc29ZZWFyUGFyYW0pO1xuICAgICAgICBjb25zdCBpc29Nb250aCA9IFRvSW50ZWdlclRocm93T25JbmZpbml0eShpc29Nb250aFBhcmFtKTtcbiAgICAgICAgY29uc3QgY2FsZW5kYXIgPSBUb1RlbXBvcmFsQ2FsZW5kYXIoY2FsZW5kYXJQYXJhbSk7XG4gICAgICAgIGNvbnN0IHJlZmVyZW5jZUlTT0RheSA9IFRvSW50ZWdlclRocm93T25JbmZpbml0eShyZWZlcmVuY2VJU09EYXlQYXJhbSk7XG4gICAgICAgIC8vIE5vdGU6IGlmIHRoZSBhcmd1bWVudHMgYXJlIG5vdCBwYXNzZWQsXG4gICAgICAgIC8vICAgICAgIFRvSW50ZWdlclRocm93T25JbmZpbml0eSh1bmRlZmluZWQpIHdpbGwgaGF2ZSByZXR1cm5lZCAwLCB3aGljaCB3aWxsXG4gICAgICAgIC8vICAgICAgIGJlIHJlamVjdGVkIGJ5IFJlamVjdElTT0RhdGUgaW4gQ3JlYXRlVGVtcG9yYWxZZWFyTW9udGhTbG90cy4gVGhpc1xuICAgICAgICAvLyAgICAgICBjaGVjayBleGlzdHMgb25seSB0byBpbXByb3ZlIHRoZSBlcnJvciBtZXNzYWdlLlxuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdtaXNzaW5nIGFyZ3VtZW50OiBpc29ZZWFyIGFuZCBpc29Nb250aCBhcmUgcmVxdWlyZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBDcmVhdGVUZW1wb3JhbFllYXJNb250aFNsb3RzKHRoaXMsIGlzb1llYXIsIGlzb01vbnRoLCBjYWxlbmRhciwgcmVmZXJlbmNlSVNPRGF5KTtcbiAgICB9XG4gICAgZ2V0IHllYXIoKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbFllYXJNb250aCh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgcmV0dXJuIENhbGVuZGFyWWVhcihHZXRTbG90KHRoaXMsIENBTEVOREFSKSwgdGhpcyk7XG4gICAgfVxuICAgIGdldCBtb250aCgpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsWWVhck1vbnRoKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICByZXR1cm4gQ2FsZW5kYXJNb250aChHZXRTbG90KHRoaXMsIENBTEVOREFSKSwgdGhpcyk7XG4gICAgfVxuICAgIGdldCBtb250aENvZGUoKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbFllYXJNb250aCh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgcmV0dXJuIENhbGVuZGFyTW9udGhDb2RlKEdldFNsb3QodGhpcywgQ0FMRU5EQVIpLCB0aGlzKTtcbiAgICB9XG4gICAgZ2V0IGNhbGVuZGFyKCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxZZWFyTW9udGgodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIHJldHVybiBHZXRTbG90KHRoaXMsIENBTEVOREFSKTtcbiAgICB9XG4gICAgZ2V0IGVyYSgpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsWWVhck1vbnRoKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICByZXR1cm4gQ2FsZW5kYXJFcmEoR2V0U2xvdCh0aGlzLCBDQUxFTkRBUiksIHRoaXMpO1xuICAgIH1cbiAgICBnZXQgZXJhWWVhcigpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsWWVhck1vbnRoKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICByZXR1cm4gQ2FsZW5kYXJFcmFZZWFyKEdldFNsb3QodGhpcywgQ0FMRU5EQVIpLCB0aGlzKTtcbiAgICB9XG4gICAgZ2V0IGRheXNJbk1vbnRoKCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxZZWFyTW9udGgodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIHJldHVybiBDYWxlbmRhckRheXNJbk1vbnRoKEdldFNsb3QodGhpcywgQ0FMRU5EQVIpLCB0aGlzKTtcbiAgICB9XG4gICAgZ2V0IGRheXNJblllYXIoKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbFllYXJNb250aCh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgcmV0dXJuIENhbGVuZGFyRGF5c0luWWVhcihHZXRTbG90KHRoaXMsIENBTEVOREFSKSwgdGhpcyk7XG4gICAgfVxuICAgIGdldCBtb250aHNJblllYXIoKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbFllYXJNb250aCh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgcmV0dXJuIENhbGVuZGFyTW9udGhzSW5ZZWFyKEdldFNsb3QodGhpcywgQ0FMRU5EQVIpLCB0aGlzKTtcbiAgICB9XG4gICAgZ2V0IGluTGVhcFllYXIoKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbFllYXJNb250aCh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgcmV0dXJuIENhbGVuZGFySW5MZWFwWWVhcihHZXRTbG90KHRoaXMsIENBTEVOREFSKSwgdGhpcyk7XG4gICAgfVxuICAgIHdpdGgodGVtcG9yYWxZZWFyTW9udGhMaWtlLCBvcHRpb25zUGFyYW0gPSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsWWVhck1vbnRoKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICBpZiAoIUlzT2JqZWN0KHRlbXBvcmFsWWVhck1vbnRoTGlrZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgYXJndW1lbnQnKTtcbiAgICAgICAgfVxuICAgICAgICBSZWplY3RPYmplY3RXaXRoQ2FsZW5kYXJPclRpbWVab25lKHRlbXBvcmFsWWVhck1vbnRoTGlrZSk7XG4gICAgICAgIGNvbnN0IGNhbGVuZGFyID0gR2V0U2xvdCh0aGlzLCBDQUxFTkRBUik7XG4gICAgICAgIGNvbnN0IGZpZWxkTmFtZXMgPSBDYWxlbmRhckZpZWxkcyhjYWxlbmRhciwgWydtb250aCcsICdtb250aENvZGUnLCAneWVhciddKTtcbiAgICAgICAgY29uc3QgcHJvcHMgPSBUb1BhcnRpYWxSZWNvcmQodGVtcG9yYWxZZWFyTW9udGhMaWtlLCBmaWVsZE5hbWVzKTtcbiAgICAgICAgaWYgKCFwcm9wcykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCB5ZWFyLW1vbnRoLWxpa2UnKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZmllbGRzID0gVG9UZW1wb3JhbFllYXJNb250aEZpZWxkcyh0aGlzLCBmaWVsZE5hbWVzKTtcbiAgICAgICAgZmllbGRzID0gQ2FsZW5kYXJNZXJnZUZpZWxkcyhjYWxlbmRhciwgZmllbGRzLCBwcm9wcyk7XG4gICAgICAgIGZpZWxkcyA9IFRvVGVtcG9yYWxZZWFyTW9udGhGaWVsZHMoZmllbGRzLCBmaWVsZE5hbWVzKTtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IEdldE9wdGlvbnNPYmplY3Qob3B0aW9uc1BhcmFtKTtcbiAgICAgICAgcmV0dXJuIFllYXJNb250aEZyb21GaWVsZHMoY2FsZW5kYXIsIGZpZWxkcywgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFkZCh0ZW1wb3JhbER1cmF0aW9uTGlrZSwgb3B0aW9uc1BhcmFtID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbFllYXJNb250aCh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgY29uc3QgZHVyYXRpb24gPSBUb0xpbWl0ZWRUZW1wb3JhbER1cmF0aW9uKHRlbXBvcmFsRHVyYXRpb25MaWtlKTtcbiAgICAgICAgbGV0IHsgeWVhcnMsIG1vbnRocywgd2Vla3MsIGRheXMsIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBtaWxsaXNlY29uZHMsIG1pY3Jvc2Vjb25kcywgbmFub3NlY29uZHMgfSA9IGR1cmF0aW9uO1xuICAgICAgICAoeyBkYXlzIH0gPSBCYWxhbmNlRHVyYXRpb24oZGF5cywgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc2Vjb25kcywgbWljcm9zZWNvbmRzLCBuYW5vc2Vjb25kcywgJ2RheScpKTtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IEdldE9wdGlvbnNPYmplY3Qob3B0aW9uc1BhcmFtKTtcbiAgICAgICAgY29uc3QgY2FsZW5kYXIgPSBHZXRTbG90KHRoaXMsIENBTEVOREFSKTtcbiAgICAgICAgY29uc3QgZmllbGROYW1lcyA9IENhbGVuZGFyRmllbGRzKGNhbGVuZGFyLCBbJ21vbnRoQ29kZScsICd5ZWFyJ10pO1xuICAgICAgICBjb25zdCBmaWVsZHMgPSBUb1RlbXBvcmFsWWVhck1vbnRoRmllbGRzKHRoaXMsIGZpZWxkTmFtZXMpO1xuICAgICAgICBjb25zdCBzaWduID0gRHVyYXRpb25TaWduKHllYXJzLCBtb250aHMsIHdlZWtzLCBkYXlzLCAwLCAwLCAwLCAwLCAwLCAwKTtcbiAgICAgICAgY29uc3QgZGF5ID0gc2lnbiA8IDAgPyBUb1Bvc2l0aXZlSW50ZWdlcihDYWxlbmRhckRheXNJbk1vbnRoKGNhbGVuZGFyLCB0aGlzKSkgOiAxO1xuICAgICAgICBjb25zdCBzdGFydERhdGUgPSBEYXRlRnJvbUZpZWxkcyhjYWxlbmRhciwgeyAuLi5maWVsZHMsIGRheSB9KTtcbiAgICAgICAgY29uc3Qgb3B0aW9uc0NvcHkgPSB7IC4uLm9wdGlvbnMgfTtcbiAgICAgICAgY29uc3QgYWRkZWREYXRlID0gQ2FsZW5kYXJEYXRlQWRkKGNhbGVuZGFyLCBzdGFydERhdGUsIHsgLi4uZHVyYXRpb24sIGRheXMgfSwgb3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IGFkZGVkRGF0ZUZpZWxkcyA9IFRvVGVtcG9yYWxZZWFyTW9udGhGaWVsZHMoYWRkZWREYXRlLCBmaWVsZE5hbWVzKTtcbiAgICAgICAgcmV0dXJuIFllYXJNb250aEZyb21GaWVsZHMoY2FsZW5kYXIsIGFkZGVkRGF0ZUZpZWxkcywgb3B0aW9uc0NvcHkpO1xuICAgIH1cbiAgICBzdWJ0cmFjdCh0ZW1wb3JhbER1cmF0aW9uTGlrZSwgb3B0aW9uc1BhcmFtID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbFllYXJNb250aCh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgbGV0IGR1cmF0aW9uID0gVG9MaW1pdGVkVGVtcG9yYWxEdXJhdGlvbih0ZW1wb3JhbER1cmF0aW9uTGlrZSk7XG4gICAgICAgIGR1cmF0aW9uID0ge1xuICAgICAgICAgICAgeWVhcnM6IC1kdXJhdGlvbi55ZWFycyxcbiAgICAgICAgICAgIG1vbnRoczogLWR1cmF0aW9uLm1vbnRocyxcbiAgICAgICAgICAgIHdlZWtzOiAtZHVyYXRpb24ud2Vla3MsXG4gICAgICAgICAgICBkYXlzOiAtZHVyYXRpb24uZGF5cyxcbiAgICAgICAgICAgIGhvdXJzOiAtZHVyYXRpb24uaG91cnMsXG4gICAgICAgICAgICBtaW51dGVzOiAtZHVyYXRpb24ubWludXRlcyxcbiAgICAgICAgICAgIHNlY29uZHM6IC1kdXJhdGlvbi5zZWNvbmRzLFxuICAgICAgICAgICAgbWlsbGlzZWNvbmRzOiAtZHVyYXRpb24ubWlsbGlzZWNvbmRzLFxuICAgICAgICAgICAgbWljcm9zZWNvbmRzOiAtZHVyYXRpb24ubWljcm9zZWNvbmRzLFxuICAgICAgICAgICAgbmFub3NlY29uZHM6IC1kdXJhdGlvbi5uYW5vc2Vjb25kc1xuICAgICAgICB9O1xuICAgICAgICBsZXQgeyB5ZWFycywgbW9udGhzLCB3ZWVrcywgZGF5cywgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc2Vjb25kcywgbWljcm9zZWNvbmRzLCBuYW5vc2Vjb25kcyB9ID0gZHVyYXRpb247XG4gICAgICAgICh7IGRheXMgfSA9IEJhbGFuY2VEdXJhdGlvbihkYXlzLCBob3VycywgbWludXRlcywgc2Vjb25kcywgbWlsbGlzZWNvbmRzLCBtaWNyb3NlY29uZHMsIG5hbm9zZWNvbmRzLCAnZGF5JykpO1xuICAgICAgICBjb25zdCBvcHRpb25zID0gR2V0T3B0aW9uc09iamVjdChvcHRpb25zUGFyYW0pO1xuICAgICAgICBjb25zdCBjYWxlbmRhciA9IEdldFNsb3QodGhpcywgQ0FMRU5EQVIpO1xuICAgICAgICBjb25zdCBmaWVsZE5hbWVzID0gQ2FsZW5kYXJGaWVsZHMoY2FsZW5kYXIsIFsnbW9udGhDb2RlJywgJ3llYXInXSk7XG4gICAgICAgIGNvbnN0IGZpZWxkcyA9IFRvVGVtcG9yYWxZZWFyTW9udGhGaWVsZHModGhpcywgZmllbGROYW1lcyk7XG4gICAgICAgIGNvbnN0IHNpZ24gPSBEdXJhdGlvblNpZ24oeWVhcnMsIG1vbnRocywgd2Vla3MsIGRheXMsIDAsIDAsIDAsIDAsIDAsIDApO1xuICAgICAgICBjb25zdCBkYXkgPSBzaWduIDwgMCA/IFRvUG9zaXRpdmVJbnRlZ2VyKENhbGVuZGFyRGF5c0luTW9udGgoY2FsZW5kYXIsIHRoaXMpKSA6IDE7XG4gICAgICAgIGNvbnN0IHN0YXJ0RGF0ZSA9IERhdGVGcm9tRmllbGRzKGNhbGVuZGFyLCB7IC4uLmZpZWxkcywgZGF5IH0pO1xuICAgICAgICBjb25zdCBvcHRpb25zQ29weSA9IHsgLi4ub3B0aW9ucyB9O1xuICAgICAgICBjb25zdCBhZGRlZERhdGUgPSBDYWxlbmRhckRhdGVBZGQoY2FsZW5kYXIsIHN0YXJ0RGF0ZSwgeyAuLi5kdXJhdGlvbiwgZGF5cyB9LCBvcHRpb25zKTtcbiAgICAgICAgY29uc3QgYWRkZWREYXRlRmllbGRzID0gVG9UZW1wb3JhbFllYXJNb250aEZpZWxkcyhhZGRlZERhdGUsIGZpZWxkTmFtZXMpO1xuICAgICAgICByZXR1cm4gWWVhck1vbnRoRnJvbUZpZWxkcyhjYWxlbmRhciwgYWRkZWREYXRlRmllbGRzLCBvcHRpb25zQ29weSk7XG4gICAgfVxuICAgIHVudGlsKG90aGVyUGFyYW0sIG9wdGlvbnNQYXJhbSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxZZWFyTW9udGgodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIGNvbnN0IG90aGVyID0gVG9UZW1wb3JhbFllYXJNb250aChvdGhlclBhcmFtKTtcbiAgICAgICAgY29uc3QgY2FsZW5kYXIgPSBHZXRTbG90KHRoaXMsIENBTEVOREFSKTtcbiAgICAgICAgY29uc3Qgb3RoZXJDYWxlbmRhciA9IEdldFNsb3Qob3RoZXIsIENBTEVOREFSKTtcbiAgICAgICAgY29uc3QgY2FsZW5kYXJJRCA9IFRvU3RyaW5nKGNhbGVuZGFyKTtcbiAgICAgICAgY29uc3Qgb3RoZXJDYWxlbmRhcklEID0gVG9TdHJpbmcob3RoZXJDYWxlbmRhcik7XG4gICAgICAgIGlmIChjYWxlbmRhcklEICE9PSBvdGhlckNhbGVuZGFySUQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBjYW5ub3QgY29tcHV0ZSBkaWZmZXJlbmNlIGJldHdlZW4gbW9udGhzIG9mICR7Y2FsZW5kYXJJRH0gYW5kICR7b3RoZXJDYWxlbmRhcklEfSBjYWxlbmRhcnNgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvcHRpb25zID0gR2V0T3B0aW9uc09iamVjdChvcHRpb25zUGFyYW0pO1xuICAgICAgICBjb25zdCBzbWFsbGVzdFVuaXQgPSBUb1NtYWxsZXN0VGVtcG9yYWxVbml0KG9wdGlvbnMsICdtb250aCcsIERJU0FMTE9XRURfVU5JVFMpO1xuICAgICAgICBjb25zdCBsYXJnZXN0VW5pdCA9IFRvTGFyZ2VzdFRlbXBvcmFsVW5pdChvcHRpb25zLCAnYXV0bycsIERJU0FMTE9XRURfVU5JVFMsICd5ZWFyJyk7XG4gICAgICAgIFZhbGlkYXRlVGVtcG9yYWxVbml0UmFuZ2UobGFyZ2VzdFVuaXQsIHNtYWxsZXN0VW5pdCk7XG4gICAgICAgIGNvbnN0IHJvdW5kaW5nTW9kZSA9IFRvVGVtcG9yYWxSb3VuZGluZ01vZGUob3B0aW9ucywgJ3RydW5jJyk7XG4gICAgICAgIGNvbnN0IHJvdW5kaW5nSW5jcmVtZW50ID0gVG9UZW1wb3JhbFJvdW5kaW5nSW5jcmVtZW50KG9wdGlvbnMsIHVuZGVmaW5lZCwgZmFsc2UpO1xuICAgICAgICBjb25zdCBmaWVsZE5hbWVzID0gQ2FsZW5kYXJGaWVsZHMoY2FsZW5kYXIsIFsnbW9udGhDb2RlJywgJ3llYXInXSk7XG4gICAgICAgIGNvbnN0IG90aGVyRmllbGRzID0gVG9UZW1wb3JhbFllYXJNb250aEZpZWxkcyhvdGhlciwgZmllbGROYW1lcyk7XG4gICAgICAgIGNvbnN0IHRoaXNGaWVsZHMgPSBUb1RlbXBvcmFsWWVhck1vbnRoRmllbGRzKHRoaXMsIGZpZWxkTmFtZXMpO1xuICAgICAgICBjb25zdCBvdGhlckRhdGUgPSBEYXRlRnJvbUZpZWxkcyhjYWxlbmRhciwgeyAuLi5vdGhlckZpZWxkcywgZGF5OiAxIH0pO1xuICAgICAgICBjb25zdCB0aGlzRGF0ZSA9IERhdGVGcm9tRmllbGRzKGNhbGVuZGFyLCB7IC4uLnRoaXNGaWVsZHMsIGRheTogMSB9KTtcbiAgICAgICAgY29uc3QgdW50aWxPcHRpb25zID0geyAuLi5vcHRpb25zLCBsYXJnZXN0VW5pdCB9O1xuICAgICAgICBjb25zdCByZXN1bHQgPSBDYWxlbmRhckRhdGVVbnRpbChjYWxlbmRhciwgdGhpc0RhdGUsIG90aGVyRGF0ZSwgdW50aWxPcHRpb25zKTtcbiAgICAgICAgaWYgKHNtYWxsZXN0VW5pdCA9PT0gJ21vbnRoJyAmJiByb3VuZGluZ0luY3JlbWVudCA9PT0gMSlcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIGxldCB7IHllYXJzLCBtb250aHMgfSA9IHJlc3VsdDtcbiAgICAgICAgKHsgeWVhcnMsIG1vbnRocyB9ID0gUm91bmREdXJhdGlvbih5ZWFycywgbW9udGhzLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCByb3VuZGluZ0luY3JlbWVudCwgc21hbGxlc3RVbml0LCByb3VuZGluZ01vZGUsIHRoaXNEYXRlKSk7XG4gICAgICAgIGNvbnN0IER1cmF0aW9uID0gR2V0SW50cmluc2ljKCclVGVtcG9yYWwuRHVyYXRpb24lJyk7XG4gICAgICAgIHJldHVybiBuZXcgRHVyYXRpb24oeWVhcnMsIG1vbnRocywgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCk7XG4gICAgfVxuICAgIHNpbmNlKG90aGVyUGFyYW0sIG9wdGlvbnNQYXJhbSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxZZWFyTW9udGgodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIGNvbnN0IG90aGVyID0gVG9UZW1wb3JhbFllYXJNb250aChvdGhlclBhcmFtKTtcbiAgICAgICAgY29uc3QgY2FsZW5kYXIgPSBHZXRTbG90KHRoaXMsIENBTEVOREFSKTtcbiAgICAgICAgY29uc3Qgb3RoZXJDYWxlbmRhciA9IEdldFNsb3Qob3RoZXIsIENBTEVOREFSKTtcbiAgICAgICAgY29uc3QgY2FsZW5kYXJJRCA9IFRvU3RyaW5nKGNhbGVuZGFyKTtcbiAgICAgICAgY29uc3Qgb3RoZXJDYWxlbmRhcklEID0gVG9TdHJpbmcob3RoZXJDYWxlbmRhcik7XG4gICAgICAgIGlmIChjYWxlbmRhcklEICE9PSBvdGhlckNhbGVuZGFySUQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBjYW5ub3QgY29tcHV0ZSBkaWZmZXJlbmNlIGJldHdlZW4gbW9udGhzIG9mICR7Y2FsZW5kYXJJRH0gYW5kICR7b3RoZXJDYWxlbmRhcklEfSBjYWxlbmRhcnNgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvcHRpb25zID0gR2V0T3B0aW9uc09iamVjdChvcHRpb25zUGFyYW0pO1xuICAgICAgICBjb25zdCBzbWFsbGVzdFVuaXQgPSBUb1NtYWxsZXN0VGVtcG9yYWxVbml0KG9wdGlvbnMsICdtb250aCcsIERJU0FMTE9XRURfVU5JVFMpO1xuICAgICAgICBjb25zdCBsYXJnZXN0VW5pdCA9IFRvTGFyZ2VzdFRlbXBvcmFsVW5pdChvcHRpb25zLCAnYXV0bycsIERJU0FMTE9XRURfVU5JVFMsICd5ZWFyJyk7XG4gICAgICAgIFZhbGlkYXRlVGVtcG9yYWxVbml0UmFuZ2UobGFyZ2VzdFVuaXQsIHNtYWxsZXN0VW5pdCk7XG4gICAgICAgIGNvbnN0IHJvdW5kaW5nTW9kZSA9IFRvVGVtcG9yYWxSb3VuZGluZ01vZGUob3B0aW9ucywgJ3RydW5jJyk7XG4gICAgICAgIGNvbnN0IHJvdW5kaW5nSW5jcmVtZW50ID0gVG9UZW1wb3JhbFJvdW5kaW5nSW5jcmVtZW50KG9wdGlvbnMsIHVuZGVmaW5lZCwgZmFsc2UpO1xuICAgICAgICBjb25zdCBmaWVsZE5hbWVzID0gQ2FsZW5kYXJGaWVsZHMoY2FsZW5kYXIsIFsnbW9udGhDb2RlJywgJ3llYXInXSk7XG4gICAgICAgIGNvbnN0IG90aGVyRmllbGRzID0gVG9UZW1wb3JhbFllYXJNb250aEZpZWxkcyhvdGhlciwgZmllbGROYW1lcyk7XG4gICAgICAgIGNvbnN0IHRoaXNGaWVsZHMgPSBUb1RlbXBvcmFsWWVhck1vbnRoRmllbGRzKHRoaXMsIGZpZWxkTmFtZXMpO1xuICAgICAgICBjb25zdCBvdGhlckRhdGUgPSBEYXRlRnJvbUZpZWxkcyhjYWxlbmRhciwgeyAuLi5vdGhlckZpZWxkcywgZGF5OiAxIH0pO1xuICAgICAgICBjb25zdCB0aGlzRGF0ZSA9IERhdGVGcm9tRmllbGRzKGNhbGVuZGFyLCB7IC4uLnRoaXNGaWVsZHMsIGRheTogMSB9KTtcbiAgICAgICAgY29uc3QgdW50aWxPcHRpb25zID0geyAuLi5vcHRpb25zLCBsYXJnZXN0VW5pdCB9O1xuICAgICAgICBsZXQgeyB5ZWFycywgbW9udGhzIH0gPSBDYWxlbmRhckRhdGVVbnRpbChjYWxlbmRhciwgdGhpc0RhdGUsIG90aGVyRGF0ZSwgdW50aWxPcHRpb25zKTtcbiAgICAgICAgY29uc3QgRHVyYXRpb24gPSBHZXRJbnRyaW5zaWMoJyVUZW1wb3JhbC5EdXJhdGlvbiUnKTtcbiAgICAgICAgaWYgKHNtYWxsZXN0VW5pdCA9PT0gJ21vbnRoJyAmJiByb3VuZGluZ0luY3JlbWVudCA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBEdXJhdGlvbigteWVhcnMsIC1tb250aHMsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDApO1xuICAgICAgICB9XG4gICAgICAgICh7IHllYXJzLCBtb250aHMgfSA9IFJvdW5kRHVyYXRpb24oeWVhcnMsIG1vbnRocywgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgcm91bmRpbmdJbmNyZW1lbnQsIHNtYWxsZXN0VW5pdCwgTmVnYXRlVGVtcG9yYWxSb3VuZGluZ01vZGUocm91bmRpbmdNb2RlKSwgdGhpc0RhdGUpKTtcbiAgICAgICAgcmV0dXJuIG5ldyBEdXJhdGlvbigteWVhcnMsIC1tb250aHMsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDApO1xuICAgIH1cbiAgICBlcXVhbHMob3RoZXJQYXJhbSkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxZZWFyTW9udGgodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIGNvbnN0IG90aGVyID0gVG9UZW1wb3JhbFllYXJNb250aChvdGhlclBhcmFtKTtcbiAgICAgICAgZm9yIChjb25zdCBzbG90IG9mIFtJU09fWUVBUiwgSVNPX01PTlRILCBJU09fREFZXSkge1xuICAgICAgICAgICAgY29uc3QgdmFsMSA9IEdldFNsb3QodGhpcywgc2xvdCk7XG4gICAgICAgICAgICBjb25zdCB2YWwyID0gR2V0U2xvdChvdGhlciwgc2xvdCk7XG4gICAgICAgICAgICBpZiAodmFsMSAhPT0gdmFsMilcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIENhbGVuZGFyRXF1YWxzKEdldFNsb3QodGhpcywgQ0FMRU5EQVIpLCBHZXRTbG90KG90aGVyLCBDQUxFTkRBUikpO1xuICAgIH1cbiAgICB0b1N0cmluZyhvcHRpb25zUGFyYW0gPSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsWWVhck1vbnRoKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICBjb25zdCBvcHRpb25zID0gR2V0T3B0aW9uc09iamVjdChvcHRpb25zUGFyYW0pO1xuICAgICAgICBjb25zdCBzaG93Q2FsZW5kYXIgPSBUb1Nob3dDYWxlbmRhck9wdGlvbihvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIFRlbXBvcmFsWWVhck1vbnRoVG9TdHJpbmcodGhpcywgc2hvd0NhbGVuZGFyKTtcbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxZZWFyTW9udGgodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIHJldHVybiBUZW1wb3JhbFllYXJNb250aFRvU3RyaW5nKHRoaXMpO1xuICAgIH1cbiAgICB0b0xvY2FsZVN0cmluZyhsb2NhbGVzID0gdW5kZWZpbmVkLCBvcHRpb25zID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbFllYXJNb250aCh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlVGltZUZvcm1hdChsb2NhbGVzLCBvcHRpb25zKS5mb3JtYXQodGhpcyk7XG4gICAgfVxuICAgIHZhbHVlT2YoKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3VzZSBjb21wYXJlKCkgb3IgZXF1YWxzKCkgdG8gY29tcGFyZSBUZW1wb3JhbC5QbGFpblllYXJNb250aCcpO1xuICAgIH1cbiAgICB0b1BsYWluRGF0ZShpdGVtKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbFllYXJNb250aCh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgaWYgKCFJc09iamVjdChpdGVtKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2FyZ3VtZW50IHNob3VsZCBiZSBhbiBvYmplY3QnKTtcbiAgICAgICAgY29uc3QgY2FsZW5kYXIgPSBHZXRTbG90KHRoaXMsIENBTEVOREFSKTtcbiAgICAgICAgY29uc3QgcmVjZWl2ZXJGaWVsZE5hbWVzID0gQ2FsZW5kYXJGaWVsZHMoY2FsZW5kYXIsIFsnbW9udGhDb2RlJywgJ3llYXInXSk7XG4gICAgICAgIGNvbnN0IGZpZWxkcyA9IFRvVGVtcG9yYWxZZWFyTW9udGhGaWVsZHModGhpcywgcmVjZWl2ZXJGaWVsZE5hbWVzKTtcbiAgICAgICAgY29uc3QgaW5wdXRGaWVsZE5hbWVzID0gQ2FsZW5kYXJGaWVsZHMoY2FsZW5kYXIsIFsnZGF5J10pO1xuICAgICAgICBjb25zdCBpbnB1dEVudHJpZXMgPSBbWydkYXknXV07XG4gICAgICAgIC8vIEFkZCBleHRyYSBmaWVsZHMgZnJvbSB0aGUgY2FsZW5kYXIgYXQgdGhlIGVuZFxuICAgICAgICBpbnB1dEZpZWxkTmFtZXMuZm9yRWFjaCgoZmllbGROYW1lKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWlucHV0RW50cmllcy5zb21lKChbbmFtZV0pID0+IG5hbWUgPT09IGZpZWxkTmFtZSkpIHtcbiAgICAgICAgICAgICAgICBpbnB1dEVudHJpZXMucHVzaChbXG4gICAgICAgICAgICAgICAgICAgIGZpZWxkTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgXSk7IC8vIE1ha2UgVFMgaWdub3JlIGV4dHJhIGZpZWxkc1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgaW5wdXRGaWVsZHMgPSBQcmVwYXJlVGVtcG9yYWxGaWVsZHMoaXRlbSwgaW5wdXRFbnRyaWVzKTtcbiAgICAgICAgbGV0IG1lcmdlZEZpZWxkcyA9IENhbGVuZGFyTWVyZ2VGaWVsZHMoY2FsZW5kYXIsIGZpZWxkcywgaW5wdXRGaWVsZHMpO1xuICAgICAgICBjb25zdCBtZXJnZWRGaWVsZE5hbWVzID0gWy4uLm5ldyBTZXQoWy4uLnJlY2VpdmVyRmllbGROYW1lcywgLi4uaW5wdXRGaWVsZE5hbWVzXSldO1xuICAgICAgICBjb25zdCBtZXJnZWRFbnRyaWVzID0gW107XG4gICAgICAgIG1lcmdlZEZpZWxkTmFtZXMuZm9yRWFjaCgoZmllbGROYW1lKSA9PiB7XG4gICAgICAgICAgICBpZiAoIW1lcmdlZEVudHJpZXMuc29tZSgoW25hbWVdKSA9PiBuYW1lID09PSBmaWVsZE5hbWUpKSB7XG4gICAgICAgICAgICAgICAgbWVyZ2VkRW50cmllcy5wdXNoKFtmaWVsZE5hbWUsIHVuZGVmaW5lZF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgbWVyZ2VkRmllbGRzID0gUHJlcGFyZVRlbXBvcmFsRmllbGRzKG1lcmdlZEZpZWxkcywgbWVyZ2VkRW50cmllcyk7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSBPYmplY3RDcmVhdGUobnVsbCk7XG4gICAgICAgIG9wdGlvbnMub3ZlcmZsb3cgPSAncmVqZWN0JztcbiAgICAgICAgcmV0dXJuIERhdGVGcm9tRmllbGRzKGNhbGVuZGFyLCBtZXJnZWRGaWVsZHMsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBnZXRJU09GaWVsZHMoKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbFllYXJNb250aCh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNhbGVuZGFyOiBHZXRTbG90KHRoaXMsIENBTEVOREFSKSxcbiAgICAgICAgICAgIGlzb0RheTogR2V0U2xvdCh0aGlzLCBJU09fREFZKSxcbiAgICAgICAgICAgIGlzb01vbnRoOiBHZXRTbG90KHRoaXMsIElTT19NT05USCksXG4gICAgICAgICAgICBpc29ZZWFyOiBHZXRTbG90KHRoaXMsIElTT19ZRUFSKVxuICAgICAgICB9O1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbShpdGVtLCBvcHRpb25zUGFyYW0gPSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IEdldE9wdGlvbnNPYmplY3Qob3B0aW9uc1BhcmFtKTtcbiAgICAgICAgaWYgKElzVGVtcG9yYWxZZWFyTW9udGgoaXRlbSkpIHtcbiAgICAgICAgICAgIFRvVGVtcG9yYWxPdmVyZmxvdyhvcHRpb25zKTsgLy8gdmFsaWRhdGUgYW5kIGlnbm9yZVxuICAgICAgICAgICAgcmV0dXJuIENyZWF0ZVRlbXBvcmFsWWVhck1vbnRoKEdldFNsb3QoaXRlbSwgSVNPX1lFQVIpLCBHZXRTbG90KGl0ZW0sIElTT19NT05USCksIEdldFNsb3QoaXRlbSwgQ0FMRU5EQVIpLCBHZXRTbG90KGl0ZW0sIElTT19EQVkpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gVG9UZW1wb3JhbFllYXJNb250aChpdGVtLCBvcHRpb25zKTtcbiAgICB9XG4gICAgc3RhdGljIGNvbXBhcmUob25lUGFyYW0sIHR3b1BhcmFtKSB7XG4gICAgICAgIGNvbnN0IG9uZSA9IFRvVGVtcG9yYWxZZWFyTW9udGgob25lUGFyYW0pO1xuICAgICAgICBjb25zdCB0d28gPSBUb1RlbXBvcmFsWWVhck1vbnRoKHR3b1BhcmFtKTtcbiAgICAgICAgcmV0dXJuIENvbXBhcmVJU09EYXRlKEdldFNsb3Qob25lLCBJU09fWUVBUiksIEdldFNsb3Qob25lLCBJU09fTU9OVEgpLCBHZXRTbG90KG9uZSwgSVNPX0RBWSksIEdldFNsb3QodHdvLCBJU09fWUVBUiksIEdldFNsb3QodHdvLCBJU09fTU9OVEgpLCBHZXRTbG90KHR3bywgSVNPX0RBWSkpO1xuICAgIH1cbn1cbk1ha2VJbnRyaW5zaWNDbGFzcyhQbGFpblllYXJNb250aCwgJ1RlbXBvcmFsLlBsYWluWWVhck1vbnRoJyk7XG5cbmNvbnN0IEFycmF5UHJvdG90eXBlUHVzaCA9IEFycmF5LnByb3RvdHlwZS5wdXNoO1xuY2xhc3MgWm9uZWREYXRlVGltZSB7XG4gICAgY29uc3RydWN0b3IoZXBvY2hOYW5vc2Vjb25kc1BhcmFtLCB0aW1lWm9uZVBhcmFtLCBjYWxlbmRhclBhcmFtID0gR2V0SVNPODYwMUNhbGVuZGFyKCkpIHtcbiAgICAgICAgLy8gTm90ZTogaWYgdGhlIGFyZ3VtZW50IGlzIG5vdCBwYXNzZWQsIFRvQmlnSW50KHVuZGVmaW5lZCkgd2lsbCB0aHJvdy4gVGhpcyBjaGVjayBleGlzdHMgb25seVxuICAgICAgICAvLyAgICAgICB0byBpbXByb3ZlIHRoZSBlcnJvciBtZXNzYWdlLlxuICAgICAgICAvLyAgICAgICBUb1RlbXBvcmFsVGltZVpvbmUodW5kZWZpbmVkKSB3aWxsIGVuZCB1cCBjYWxsaW5nIFRpbWVab25lLmZyb20oXCJ1bmRlZmluZWRcIiksIHdoaWNoXG4gICAgICAgIC8vICAgICAgIGNvdWxkIHN1Y2NlZWQuXG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbWlzc2luZyBhcmd1bWVudDogZXBvY2hOYW5vc2Vjb25kcyBpcyByZXF1aXJlZCcpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVwb2NoTmFub3NlY29uZHMgPSBUb0JpZ0ludChlcG9jaE5hbm9zZWNvbmRzUGFyYW0pO1xuICAgICAgICBjb25zdCB0aW1lWm9uZSA9IFRvVGVtcG9yYWxUaW1lWm9uZSh0aW1lWm9uZVBhcmFtKTtcbiAgICAgICAgY29uc3QgY2FsZW5kYXIgPSBUb1RlbXBvcmFsQ2FsZW5kYXIoY2FsZW5kYXJQYXJhbSk7XG4gICAgICAgIENyZWF0ZVRlbXBvcmFsWm9uZWREYXRlVGltZVNsb3RzKHRoaXMsIGVwb2NoTmFub3NlY29uZHMsIHRpbWVab25lLCBjYWxlbmRhcik7XG4gICAgfVxuICAgIGdldCBjYWxlbmRhcigpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsWm9uZWREYXRlVGltZSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgcmV0dXJuIEdldFNsb3QodGhpcywgQ0FMRU5EQVIpO1xuICAgIH1cbiAgICBnZXQgdGltZVpvbmUoKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbFpvbmVkRGF0ZVRpbWUodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIHJldHVybiBHZXRTbG90KHRoaXMsIFRJTUVfWk9ORSk7XG4gICAgfVxuICAgIGdldCB5ZWFyKCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxab25lZERhdGVUaW1lKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICByZXR1cm4gQ2FsZW5kYXJZZWFyKEdldFNsb3QodGhpcywgQ0FMRU5EQVIpLCBkYXRlVGltZSh0aGlzKSk7XG4gICAgfVxuICAgIGdldCBtb250aCgpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsWm9uZWREYXRlVGltZSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgcmV0dXJuIENhbGVuZGFyTW9udGgoR2V0U2xvdCh0aGlzLCBDQUxFTkRBUiksIGRhdGVUaW1lKHRoaXMpKTtcbiAgICB9XG4gICAgZ2V0IG1vbnRoQ29kZSgpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsWm9uZWREYXRlVGltZSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgcmV0dXJuIENhbGVuZGFyTW9udGhDb2RlKEdldFNsb3QodGhpcywgQ0FMRU5EQVIpLCBkYXRlVGltZSh0aGlzKSk7XG4gICAgfVxuICAgIGdldCBkYXkoKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbFpvbmVkRGF0ZVRpbWUodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIHJldHVybiBDYWxlbmRhckRheShHZXRTbG90KHRoaXMsIENBTEVOREFSKSwgZGF0ZVRpbWUodGhpcykpO1xuICAgIH1cbiAgICBnZXQgaG91cigpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsWm9uZWREYXRlVGltZSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgcmV0dXJuIEdldFNsb3QoZGF0ZVRpbWUodGhpcyksIElTT19IT1VSKTtcbiAgICB9XG4gICAgZ2V0IG1pbnV0ZSgpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsWm9uZWREYXRlVGltZSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgcmV0dXJuIEdldFNsb3QoZGF0ZVRpbWUodGhpcyksIElTT19NSU5VVEUpO1xuICAgIH1cbiAgICBnZXQgc2Vjb25kKCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxab25lZERhdGVUaW1lKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICByZXR1cm4gR2V0U2xvdChkYXRlVGltZSh0aGlzKSwgSVNPX1NFQ09ORCk7XG4gICAgfVxuICAgIGdldCBtaWxsaXNlY29uZCgpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsWm9uZWREYXRlVGltZSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgcmV0dXJuIEdldFNsb3QoZGF0ZVRpbWUodGhpcyksIElTT19NSUxMSVNFQ09ORCk7XG4gICAgfVxuICAgIGdldCBtaWNyb3NlY29uZCgpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsWm9uZWREYXRlVGltZSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgcmV0dXJuIEdldFNsb3QoZGF0ZVRpbWUodGhpcyksIElTT19NSUNST1NFQ09ORCk7XG4gICAgfVxuICAgIGdldCBuYW5vc2Vjb25kKCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxab25lZERhdGVUaW1lKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICByZXR1cm4gR2V0U2xvdChkYXRlVGltZSh0aGlzKSwgSVNPX05BTk9TRUNPTkQpO1xuICAgIH1cbiAgICBnZXQgZXJhKCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxab25lZERhdGVUaW1lKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICByZXR1cm4gQ2FsZW5kYXJFcmEoR2V0U2xvdCh0aGlzLCBDQUxFTkRBUiksIGRhdGVUaW1lKHRoaXMpKTtcbiAgICB9XG4gICAgZ2V0IGVyYVllYXIoKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbFpvbmVkRGF0ZVRpbWUodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIHJldHVybiBDYWxlbmRhckVyYVllYXIoR2V0U2xvdCh0aGlzLCBDQUxFTkRBUiksIGRhdGVUaW1lKHRoaXMpKTtcbiAgICB9XG4gICAgZ2V0IGVwb2NoU2Vjb25kcygpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsWm9uZWREYXRlVGltZSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBHZXRTbG90KHRoaXMsIEVQT0NITkFOT1NFQ09ORFMpO1xuICAgICAgICByZXR1cm4gSlNCSS50b051bWJlcihKU0JJLmRpdmlkZSh2YWx1ZSwgQklMTElPTikpO1xuICAgIH1cbiAgICBnZXQgZXBvY2hNaWxsaXNlY29uZHMoKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbFpvbmVkRGF0ZVRpbWUodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gR2V0U2xvdCh0aGlzLCBFUE9DSE5BTk9TRUNPTkRTKTtcbiAgICAgICAgcmV0dXJuIEpTQkkudG9OdW1iZXIoSlNCSS5kaXZpZGUodmFsdWUsIE1JTExJT04pKTtcbiAgICB9XG4gICAgZ2V0IGVwb2NoTWljcm9zZWNvbmRzKCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxab25lZERhdGVUaW1lKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IEdldFNsb3QodGhpcywgRVBPQ0hOQU5PU0VDT05EUyk7XG4gICAgICAgIHJldHVybiBUb0JpZ0ludEV4dGVybmFsKEpTQkkuZGl2aWRlKHZhbHVlLCBUSE9VU0FORCkpO1xuICAgIH1cbiAgICBnZXQgZXBvY2hOYW5vc2Vjb25kcygpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsWm9uZWREYXRlVGltZSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgcmV0dXJuIFRvQmlnSW50RXh0ZXJuYWwoR2V0U2xvdCh0aGlzLCBFUE9DSE5BTk9TRUNPTkRTKSk7XG4gICAgfVxuICAgIGdldCBkYXlPZldlZWsoKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbFpvbmVkRGF0ZVRpbWUodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIHJldHVybiBDYWxlbmRhckRheU9mV2VlayhHZXRTbG90KHRoaXMsIENBTEVOREFSKSwgZGF0ZVRpbWUodGhpcykpO1xuICAgIH1cbiAgICBnZXQgZGF5T2ZZZWFyKCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxab25lZERhdGVUaW1lKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICByZXR1cm4gQ2FsZW5kYXJEYXlPZlllYXIoR2V0U2xvdCh0aGlzLCBDQUxFTkRBUiksIGRhdGVUaW1lKHRoaXMpKTtcbiAgICB9XG4gICAgZ2V0IHdlZWtPZlllYXIoKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbFpvbmVkRGF0ZVRpbWUodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIHJldHVybiBDYWxlbmRhcldlZWtPZlllYXIoR2V0U2xvdCh0aGlzLCBDQUxFTkRBUiksIGRhdGVUaW1lKHRoaXMpKTtcbiAgICB9XG4gICAgZ2V0IGhvdXJzSW5EYXkoKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbFpvbmVkRGF0ZVRpbWUodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIGNvbnN0IGR0ID0gZGF0ZVRpbWUodGhpcyk7XG4gICAgICAgIGNvbnN0IERhdGVUaW1lID0gR2V0SW50cmluc2ljKCclVGVtcG9yYWwuUGxhaW5EYXRlVGltZSUnKTtcbiAgICAgICAgY29uc3QgeWVhciA9IEdldFNsb3QoZHQsIElTT19ZRUFSKTtcbiAgICAgICAgY29uc3QgbW9udGggPSBHZXRTbG90KGR0LCBJU09fTU9OVEgpO1xuICAgICAgICBjb25zdCBkYXkgPSBHZXRTbG90KGR0LCBJU09fREFZKTtcbiAgICAgICAgY29uc3QgdG9kYXkgPSBuZXcgRGF0ZVRpbWUoeWVhciwgbW9udGgsIGRheSwgMCwgMCwgMCwgMCwgMCwgMCk7XG4gICAgICAgIGNvbnN0IHRvbW9ycm93RmllbGRzID0gQWRkSVNPRGF0ZSh5ZWFyLCBtb250aCwgZGF5LCAwLCAwLCAwLCAxLCAncmVqZWN0Jyk7XG4gICAgICAgIGNvbnN0IHRvbW9ycm93ID0gbmV3IERhdGVUaW1lKHRvbW9ycm93RmllbGRzLnllYXIsIHRvbW9ycm93RmllbGRzLm1vbnRoLCB0b21vcnJvd0ZpZWxkcy5kYXksIDAsIDAsIDAsIDAsIDAsIDApO1xuICAgICAgICBjb25zdCB0aW1lWm9uZSA9IEdldFNsb3QodGhpcywgVElNRV9aT05FKTtcbiAgICAgICAgY29uc3QgdG9kYXlOcyA9IEdldFNsb3QoQnVpbHRpblRpbWVab25lR2V0SW5zdGFudEZvcih0aW1lWm9uZSwgdG9kYXksICdjb21wYXRpYmxlJyksIEVQT0NITkFOT1NFQ09ORFMpO1xuICAgICAgICBjb25zdCB0b21vcnJvd05zID0gR2V0U2xvdChCdWlsdGluVGltZVpvbmVHZXRJbnN0YW50Rm9yKHRpbWVab25lLCB0b21vcnJvdywgJ2NvbXBhdGlibGUnKSwgRVBPQ0hOQU5PU0VDT05EUyk7XG4gICAgICAgIHJldHVybiBKU0JJLnRvTnVtYmVyKEpTQkkuc3VidHJhY3QodG9tb3Jyb3dOcywgdG9kYXlOcykpIC8gMy42ZTEyO1xuICAgIH1cbiAgICBnZXQgZGF5c0luV2VlaygpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsWm9uZWREYXRlVGltZSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgcmV0dXJuIENhbGVuZGFyRGF5c0luV2VlayhHZXRTbG90KHRoaXMsIENBTEVOREFSKSwgZGF0ZVRpbWUodGhpcykpO1xuICAgIH1cbiAgICBnZXQgZGF5c0luTW9udGgoKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbFpvbmVkRGF0ZVRpbWUodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIHJldHVybiBDYWxlbmRhckRheXNJbk1vbnRoKEdldFNsb3QodGhpcywgQ0FMRU5EQVIpLCBkYXRlVGltZSh0aGlzKSk7XG4gICAgfVxuICAgIGdldCBkYXlzSW5ZZWFyKCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxab25lZERhdGVUaW1lKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICByZXR1cm4gQ2FsZW5kYXJEYXlzSW5ZZWFyKEdldFNsb3QodGhpcywgQ0FMRU5EQVIpLCBkYXRlVGltZSh0aGlzKSk7XG4gICAgfVxuICAgIGdldCBtb250aHNJblllYXIoKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbFpvbmVkRGF0ZVRpbWUodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIHJldHVybiBDYWxlbmRhck1vbnRoc0luWWVhcihHZXRTbG90KHRoaXMsIENBTEVOREFSKSwgZGF0ZVRpbWUodGhpcykpO1xuICAgIH1cbiAgICBnZXQgaW5MZWFwWWVhcigpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsWm9uZWREYXRlVGltZSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgcmV0dXJuIENhbGVuZGFySW5MZWFwWWVhcihHZXRTbG90KHRoaXMsIENBTEVOREFSKSwgZGF0ZVRpbWUodGhpcykpO1xuICAgIH1cbiAgICBnZXQgb2Zmc2V0KCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxab25lZERhdGVUaW1lKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICByZXR1cm4gQnVpbHRpblRpbWVab25lR2V0T2Zmc2V0U3RyaW5nRm9yKEdldFNsb3QodGhpcywgVElNRV9aT05FKSwgR2V0U2xvdCh0aGlzLCBJTlNUQU5UKSk7XG4gICAgfVxuICAgIGdldCBvZmZzZXROYW5vc2Vjb25kcygpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsWm9uZWREYXRlVGltZSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgcmV0dXJuIEdldE9mZnNldE5hbm9zZWNvbmRzRm9yKEdldFNsb3QodGhpcywgVElNRV9aT05FKSwgR2V0U2xvdCh0aGlzLCBJTlNUQU5UKSk7XG4gICAgfVxuICAgIHdpdGgodGVtcG9yYWxab25lZERhdGVUaW1lTGlrZSwgb3B0aW9uc1BhcmFtID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbFpvbmVkRGF0ZVRpbWUodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIGlmICghSXNPYmplY3QodGVtcG9yYWxab25lZERhdGVUaW1lTGlrZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgem9uZWQtZGF0ZS10aW1lLWxpa2UnKTtcbiAgICAgICAgfVxuICAgICAgICBSZWplY3RPYmplY3RXaXRoQ2FsZW5kYXJPclRpbWVab25lKHRlbXBvcmFsWm9uZWREYXRlVGltZUxpa2UpO1xuICAgICAgICBjb25zdCBvcHRpb25zID0gR2V0T3B0aW9uc09iamVjdChvcHRpb25zUGFyYW0pO1xuICAgICAgICBjb25zdCBkaXNhbWJpZ3VhdGlvbiA9IFRvVGVtcG9yYWxEaXNhbWJpZ3VhdGlvbihvcHRpb25zKTtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gVG9UZW1wb3JhbE9mZnNldChvcHRpb25zLCAncHJlZmVyJyk7XG4gICAgICAgIGNvbnN0IHRpbWVab25lID0gR2V0U2xvdCh0aGlzLCBUSU1FX1pPTkUpO1xuICAgICAgICBjb25zdCBjYWxlbmRhciA9IEdldFNsb3QodGhpcywgQ0FMRU5EQVIpO1xuICAgICAgICBjb25zdCBmaWVsZE5hbWVzID0gQ2FsZW5kYXJGaWVsZHMoY2FsZW5kYXIsIFtcbiAgICAgICAgICAgICdkYXknLFxuICAgICAgICAgICAgJ2hvdXInLFxuICAgICAgICAgICAgJ21pY3Jvc2Vjb25kJyxcbiAgICAgICAgICAgICdtaWxsaXNlY29uZCcsXG4gICAgICAgICAgICAnbWludXRlJyxcbiAgICAgICAgICAgICdtb250aCcsXG4gICAgICAgICAgICAnbW9udGhDb2RlJyxcbiAgICAgICAgICAgICduYW5vc2Vjb25kJyxcbiAgICAgICAgICAgICdzZWNvbmQnLFxuICAgICAgICAgICAgJ3llYXInXG4gICAgICAgIF0pO1xuICAgICAgICBBcnJheVByb3RvdHlwZVB1c2guY2FsbChmaWVsZE5hbWVzLCAnb2Zmc2V0Jyk7XG4gICAgICAgIGNvbnN0IHByb3BzID0gVG9QYXJ0aWFsUmVjb3JkKHRlbXBvcmFsWm9uZWREYXRlVGltZUxpa2UsIGZpZWxkTmFtZXMpO1xuICAgICAgICBpZiAoIXByb3BzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHpvbmVkLWRhdGUtdGltZS1saWtlJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVW5saWtlIFRvVGVtcG9yYWxab25lZERhdGVUaW1lRmllbGRzLCB0aGUgb2Zmc2V0IHByb3BlcnR5IHdpbGwgYmUgcmVxdWlyZWQuXG4gICAgICAgIGNvbnN0IGVudHJpZXMgPSBbXG4gICAgICAgICAgICBbJ2RheScsIHVuZGVmaW5lZF0sXG4gICAgICAgICAgICBbJ2hvdXInLCAwXSxcbiAgICAgICAgICAgIFsnbWljcm9zZWNvbmQnLCAwXSxcbiAgICAgICAgICAgIFsnbWlsbGlzZWNvbmQnLCAwXSxcbiAgICAgICAgICAgIFsnbWludXRlJywgMF0sXG4gICAgICAgICAgICBbJ21vbnRoJywgdW5kZWZpbmVkXSxcbiAgICAgICAgICAgIFsnbW9udGhDb2RlJywgdW5kZWZpbmVkXSxcbiAgICAgICAgICAgIFsnbmFub3NlY29uZCcsIDBdLFxuICAgICAgICAgICAgWydzZWNvbmQnLCAwXSxcbiAgICAgICAgICAgIFsneWVhcicsIHVuZGVmaW5lZF0sXG4gICAgICAgICAgICBbJ29mZnNldCddLFxuICAgICAgICAgICAgWyd0aW1lWm9uZSddXG4gICAgICAgIF07XG4gICAgICAgIC8vIEFkZCBleHRyYSBmaWVsZHMgZnJvbSB0aGUgY2FsZW5kYXIgYXQgdGhlIGVuZFxuICAgICAgICBmaWVsZE5hbWVzLmZvckVhY2goKGZpZWxkTmFtZSkgPT4ge1xuICAgICAgICAgICAgaWYgKCFlbnRyaWVzLnNvbWUoKFtuYW1lXSkgPT4gbmFtZSA9PT0gZmllbGROYW1lKSkge1xuICAgICAgICAgICAgICAgIGVudHJpZXMucHVzaChbZmllbGROYW1lLCB1bmRlZmluZWRdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGxldCBmaWVsZHMgPSBQcmVwYXJlVGVtcG9yYWxGaWVsZHModGhpcywgZW50cmllcyk7XG4gICAgICAgIGZpZWxkcyA9IENhbGVuZGFyTWVyZ2VGaWVsZHMoY2FsZW5kYXIsIGZpZWxkcywgcHJvcHMpO1xuICAgICAgICBmaWVsZHMgPSBQcmVwYXJlVGVtcG9yYWxGaWVsZHMoZmllbGRzLCBlbnRyaWVzKTtcbiAgICAgICAgY29uc3QgeyB5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQsIG1pY3Jvc2Vjb25kLCBuYW5vc2Vjb25kIH0gPSBJbnRlcnByZXRUZW1wb3JhbERhdGVUaW1lRmllbGRzKGNhbGVuZGFyLCBmaWVsZHMsIG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBvZmZzZXROcyA9IFBhcnNlVGltZVpvbmVPZmZzZXRTdHJpbmcoZmllbGRzLm9mZnNldCk7XG4gICAgICAgIGNvbnN0IGVwb2NoTmFub3NlY29uZHMgPSBJbnRlcnByZXRJU09EYXRlVGltZU9mZnNldCh5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQsIG1pY3Jvc2Vjb25kLCBuYW5vc2Vjb25kLCAnb3B0aW9uJywgb2Zmc2V0TnMsIHRpbWVab25lLCBkaXNhbWJpZ3VhdGlvbiwgb2Zmc2V0LCBcbiAgICAgICAgLyogbWF0Y2hNaW51dGUgPSAqLyBmYWxzZSk7XG4gICAgICAgIHJldHVybiBDcmVhdGVUZW1wb3JhbFpvbmVkRGF0ZVRpbWUoZXBvY2hOYW5vc2Vjb25kcywgR2V0U2xvdCh0aGlzLCBUSU1FX1pPTkUpLCBjYWxlbmRhcik7XG4gICAgfVxuICAgIHdpdGhQbGFpbkRhdGUodGVtcG9yYWxEYXRlUGFyYW0pIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsWm9uZWREYXRlVGltZSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgY29uc3QgdGVtcG9yYWxEYXRlID0gVG9UZW1wb3JhbERhdGUodGVtcG9yYWxEYXRlUGFyYW0pO1xuICAgICAgICBjb25zdCB5ZWFyID0gR2V0U2xvdCh0ZW1wb3JhbERhdGUsIElTT19ZRUFSKTtcbiAgICAgICAgY29uc3QgbW9udGggPSBHZXRTbG90KHRlbXBvcmFsRGF0ZSwgSVNPX01PTlRIKTtcbiAgICAgICAgY29uc3QgZGF5ID0gR2V0U2xvdCh0ZW1wb3JhbERhdGUsIElTT19EQVkpO1xuICAgICAgICBsZXQgY2FsZW5kYXIgPSBHZXRTbG90KHRlbXBvcmFsRGF0ZSwgQ0FMRU5EQVIpO1xuICAgICAgICBjb25zdCB0aGlzRHQgPSBkYXRlVGltZSh0aGlzKTtcbiAgICAgICAgY29uc3QgaG91ciA9IEdldFNsb3QodGhpc0R0LCBJU09fSE9VUik7XG4gICAgICAgIGNvbnN0IG1pbnV0ZSA9IEdldFNsb3QodGhpc0R0LCBJU09fTUlOVVRFKTtcbiAgICAgICAgY29uc3Qgc2Vjb25kID0gR2V0U2xvdCh0aGlzRHQsIElTT19TRUNPTkQpO1xuICAgICAgICBjb25zdCBtaWxsaXNlY29uZCA9IEdldFNsb3QodGhpc0R0LCBJU09fTUlMTElTRUNPTkQpO1xuICAgICAgICBjb25zdCBtaWNyb3NlY29uZCA9IEdldFNsb3QodGhpc0R0LCBJU09fTUlDUk9TRUNPTkQpO1xuICAgICAgICBjb25zdCBuYW5vc2Vjb25kID0gR2V0U2xvdCh0aGlzRHQsIElTT19OQU5PU0VDT05EKTtcbiAgICAgICAgY2FsZW5kYXIgPSBDb25zb2xpZGF0ZUNhbGVuZGFycyhHZXRTbG90KHRoaXMsIENBTEVOREFSKSwgY2FsZW5kYXIpO1xuICAgICAgICBjb25zdCB0aW1lWm9uZSA9IEdldFNsb3QodGhpcywgVElNRV9aT05FKTtcbiAgICAgICAgY29uc3QgUGxhaW5EYXRlVGltZSA9IEdldEludHJpbnNpYygnJVRlbXBvcmFsLlBsYWluRGF0ZVRpbWUlJyk7XG4gICAgICAgIGNvbnN0IGR0ID0gbmV3IFBsYWluRGF0ZVRpbWUoeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kLCBtaWNyb3NlY29uZCwgbmFub3NlY29uZCwgY2FsZW5kYXIpO1xuICAgICAgICBjb25zdCBpbnN0YW50ID0gQnVpbHRpblRpbWVab25lR2V0SW5zdGFudEZvcih0aW1lWm9uZSwgZHQsICdjb21wYXRpYmxlJyk7XG4gICAgICAgIHJldHVybiBDcmVhdGVUZW1wb3JhbFpvbmVkRGF0ZVRpbWUoR2V0U2xvdChpbnN0YW50LCBFUE9DSE5BTk9TRUNPTkRTKSwgdGltZVpvbmUsIGNhbGVuZGFyKTtcbiAgICB9XG4gICAgd2l0aFBsYWluVGltZSh0ZW1wb3JhbFRpbWVQYXJhbSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxab25lZERhdGVUaW1lKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICBjb25zdCBQbGFpblRpbWUgPSBHZXRJbnRyaW5zaWMoJyVUZW1wb3JhbC5QbGFpblRpbWUlJyk7XG4gICAgICAgIGNvbnN0IHRlbXBvcmFsVGltZSA9IHRlbXBvcmFsVGltZVBhcmFtID09IHVuZGVmaW5lZCA/IG5ldyBQbGFpblRpbWUoKSA6IFRvVGVtcG9yYWxUaW1lKHRlbXBvcmFsVGltZVBhcmFtKTtcbiAgICAgICAgY29uc3QgdGhpc0R0ID0gZGF0ZVRpbWUodGhpcyk7XG4gICAgICAgIGNvbnN0IHllYXIgPSBHZXRTbG90KHRoaXNEdCwgSVNPX1lFQVIpO1xuICAgICAgICBjb25zdCBtb250aCA9IEdldFNsb3QodGhpc0R0LCBJU09fTU9OVEgpO1xuICAgICAgICBjb25zdCBkYXkgPSBHZXRTbG90KHRoaXNEdCwgSVNPX0RBWSk7XG4gICAgICAgIGNvbnN0IGNhbGVuZGFyID0gR2V0U2xvdCh0aGlzLCBDQUxFTkRBUik7XG4gICAgICAgIGNvbnN0IGhvdXIgPSBHZXRTbG90KHRlbXBvcmFsVGltZSwgSVNPX0hPVVIpO1xuICAgICAgICBjb25zdCBtaW51dGUgPSBHZXRTbG90KHRlbXBvcmFsVGltZSwgSVNPX01JTlVURSk7XG4gICAgICAgIGNvbnN0IHNlY29uZCA9IEdldFNsb3QodGVtcG9yYWxUaW1lLCBJU09fU0VDT05EKTtcbiAgICAgICAgY29uc3QgbWlsbGlzZWNvbmQgPSBHZXRTbG90KHRlbXBvcmFsVGltZSwgSVNPX01JTExJU0VDT05EKTtcbiAgICAgICAgY29uc3QgbWljcm9zZWNvbmQgPSBHZXRTbG90KHRlbXBvcmFsVGltZSwgSVNPX01JQ1JPU0VDT05EKTtcbiAgICAgICAgY29uc3QgbmFub3NlY29uZCA9IEdldFNsb3QodGVtcG9yYWxUaW1lLCBJU09fTkFOT1NFQ09ORCk7XG4gICAgICAgIGNvbnN0IHRpbWVab25lID0gR2V0U2xvdCh0aGlzLCBUSU1FX1pPTkUpO1xuICAgICAgICBjb25zdCBQbGFpbkRhdGVUaW1lID0gR2V0SW50cmluc2ljKCclVGVtcG9yYWwuUGxhaW5EYXRlVGltZSUnKTtcbiAgICAgICAgY29uc3QgZHQgPSBuZXcgUGxhaW5EYXRlVGltZSh5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQsIG1pY3Jvc2Vjb25kLCBuYW5vc2Vjb25kLCBjYWxlbmRhcik7XG4gICAgICAgIGNvbnN0IGluc3RhbnQgPSBCdWlsdGluVGltZVpvbmVHZXRJbnN0YW50Rm9yKHRpbWVab25lLCBkdCwgJ2NvbXBhdGlibGUnKTtcbiAgICAgICAgcmV0dXJuIENyZWF0ZVRlbXBvcmFsWm9uZWREYXRlVGltZShHZXRTbG90KGluc3RhbnQsIEVQT0NITkFOT1NFQ09ORFMpLCB0aW1lWm9uZSwgY2FsZW5kYXIpO1xuICAgIH1cbiAgICB3aXRoVGltZVpvbmUodGltZVpvbmVQYXJhbSkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxab25lZERhdGVUaW1lKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICBjb25zdCB0aW1lWm9uZSA9IFRvVGVtcG9yYWxUaW1lWm9uZSh0aW1lWm9uZVBhcmFtKTtcbiAgICAgICAgcmV0dXJuIENyZWF0ZVRlbXBvcmFsWm9uZWREYXRlVGltZShHZXRTbG90KHRoaXMsIEVQT0NITkFOT1NFQ09ORFMpLCB0aW1lWm9uZSwgR2V0U2xvdCh0aGlzLCBDQUxFTkRBUikpO1xuICAgIH1cbiAgICB3aXRoQ2FsZW5kYXIoY2FsZW5kYXJQYXJhbSkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxab25lZERhdGVUaW1lKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICBjb25zdCBjYWxlbmRhciA9IFRvVGVtcG9yYWxDYWxlbmRhcihjYWxlbmRhclBhcmFtKTtcbiAgICAgICAgcmV0dXJuIENyZWF0ZVRlbXBvcmFsWm9uZWREYXRlVGltZShHZXRTbG90KHRoaXMsIEVQT0NITkFOT1NFQ09ORFMpLCBHZXRTbG90KHRoaXMsIFRJTUVfWk9ORSksIGNhbGVuZGFyKTtcbiAgICB9XG4gICAgYWRkKHRlbXBvcmFsRHVyYXRpb25MaWtlLCBvcHRpb25zUGFyYW0gPSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsWm9uZWREYXRlVGltZSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgY29uc3QgZHVyYXRpb24gPSBUb0xpbWl0ZWRUZW1wb3JhbER1cmF0aW9uKHRlbXBvcmFsRHVyYXRpb25MaWtlKTtcbiAgICAgICAgY29uc3QgeyB5ZWFycywgbW9udGhzLCB3ZWVrcywgZGF5cywgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc2Vjb25kcywgbWljcm9zZWNvbmRzLCBuYW5vc2Vjb25kcyB9ID0gZHVyYXRpb247XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSBHZXRPcHRpb25zT2JqZWN0KG9wdGlvbnNQYXJhbSk7XG4gICAgICAgIGNvbnN0IHRpbWVab25lID0gR2V0U2xvdCh0aGlzLCBUSU1FX1pPTkUpO1xuICAgICAgICBjb25zdCBjYWxlbmRhciA9IEdldFNsb3QodGhpcywgQ0FMRU5EQVIpO1xuICAgICAgICBjb25zdCBlcG9jaE5hbm9zZWNvbmRzID0gQWRkWm9uZWREYXRlVGltZShHZXRTbG90KHRoaXMsIElOU1RBTlQpLCB0aW1lWm9uZSwgY2FsZW5kYXIsIHllYXJzLCBtb250aHMsIHdlZWtzLCBkYXlzLCBob3VycywgbWludXRlcywgc2Vjb25kcywgbWlsbGlzZWNvbmRzLCBtaWNyb3NlY29uZHMsIG5hbm9zZWNvbmRzLCBvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIENyZWF0ZVRlbXBvcmFsWm9uZWREYXRlVGltZShlcG9jaE5hbm9zZWNvbmRzLCB0aW1lWm9uZSwgY2FsZW5kYXIpO1xuICAgIH1cbiAgICBzdWJ0cmFjdCh0ZW1wb3JhbER1cmF0aW9uTGlrZSwgb3B0aW9uc1BhcmFtID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbFpvbmVkRGF0ZVRpbWUodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIGNvbnN0IGR1cmF0aW9uID0gVG9MaW1pdGVkVGVtcG9yYWxEdXJhdGlvbih0ZW1wb3JhbER1cmF0aW9uTGlrZSk7XG4gICAgICAgIGNvbnN0IHsgeWVhcnMsIG1vbnRocywgd2Vla3MsIGRheXMsIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBtaWxsaXNlY29uZHMsIG1pY3Jvc2Vjb25kcywgbmFub3NlY29uZHMgfSA9IGR1cmF0aW9uO1xuICAgICAgICBjb25zdCBvcHRpb25zID0gR2V0T3B0aW9uc09iamVjdChvcHRpb25zUGFyYW0pO1xuICAgICAgICBjb25zdCB0aW1lWm9uZSA9IEdldFNsb3QodGhpcywgVElNRV9aT05FKTtcbiAgICAgICAgY29uc3QgY2FsZW5kYXIgPSBHZXRTbG90KHRoaXMsIENBTEVOREFSKTtcbiAgICAgICAgY29uc3QgZXBvY2hOYW5vc2Vjb25kcyA9IEFkZFpvbmVkRGF0ZVRpbWUoR2V0U2xvdCh0aGlzLCBJTlNUQU5UKSwgdGltZVpvbmUsIGNhbGVuZGFyLCAteWVhcnMsIC1tb250aHMsIC13ZWVrcywgLWRheXMsIC1ob3VycywgLW1pbnV0ZXMsIC1zZWNvbmRzLCAtbWlsbGlzZWNvbmRzLCAtbWljcm9zZWNvbmRzLCAtbmFub3NlY29uZHMsIG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gQ3JlYXRlVGVtcG9yYWxab25lZERhdGVUaW1lKGVwb2NoTmFub3NlY29uZHMsIHRpbWVab25lLCBjYWxlbmRhcik7XG4gICAgfVxuICAgIHVudGlsKG90aGVyUGFyYW0sIG9wdGlvbnNQYXJhbSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxab25lZERhdGVUaW1lKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICBjb25zdCBvdGhlciA9IFRvVGVtcG9yYWxab25lZERhdGVUaW1lKG90aGVyUGFyYW0pO1xuICAgICAgICBjb25zdCBjYWxlbmRhciA9IEdldFNsb3QodGhpcywgQ0FMRU5EQVIpO1xuICAgICAgICBjb25zdCBvdGhlckNhbGVuZGFyID0gR2V0U2xvdChvdGhlciwgQ0FMRU5EQVIpO1xuICAgICAgICBjb25zdCBjYWxlbmRhcklkID0gVG9TdHJpbmcoY2FsZW5kYXIpO1xuICAgICAgICBjb25zdCBvdGhlckNhbGVuZGFySWQgPSBUb1N0cmluZyhvdGhlckNhbGVuZGFyKTtcbiAgICAgICAgaWYgKGNhbGVuZGFySWQgIT09IG90aGVyQ2FsZW5kYXJJZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYGNhbm5vdCBjb21wdXRlIGRpZmZlcmVuY2UgYmV0d2VlbiBkYXRlcyBvZiAke2NhbGVuZGFySWR9IGFuZCAke290aGVyQ2FsZW5kYXJJZH0gY2FsZW5kYXJzYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IEdldE9wdGlvbnNPYmplY3Qob3B0aW9uc1BhcmFtKTtcbiAgICAgICAgY29uc3Qgc21hbGxlc3RVbml0ID0gVG9TbWFsbGVzdFRlbXBvcmFsVW5pdChvcHRpb25zLCAnbmFub3NlY29uZCcpO1xuICAgICAgICBjb25zdCBkZWZhdWx0TGFyZ2VzdFVuaXQgPSBMYXJnZXJPZlR3b1RlbXBvcmFsVW5pdHMoJ2hvdXInLCBzbWFsbGVzdFVuaXQpO1xuICAgICAgICBjb25zdCBsYXJnZXN0VW5pdCA9IFRvTGFyZ2VzdFRlbXBvcmFsVW5pdChvcHRpb25zLCAnYXV0bycsIFtdLCBkZWZhdWx0TGFyZ2VzdFVuaXQpO1xuICAgICAgICBWYWxpZGF0ZVRlbXBvcmFsVW5pdFJhbmdlKGxhcmdlc3RVbml0LCBzbWFsbGVzdFVuaXQpO1xuICAgICAgICBjb25zdCByb3VuZGluZ01vZGUgPSBUb1RlbXBvcmFsUm91bmRpbmdNb2RlKG9wdGlvbnMsICd0cnVuYycpO1xuICAgICAgICBjb25zdCByb3VuZGluZ0luY3JlbWVudCA9IFRvVGVtcG9yYWxEYXRlVGltZVJvdW5kaW5nSW5jcmVtZW50KG9wdGlvbnMsIHNtYWxsZXN0VW5pdCk7XG4gICAgICAgIGNvbnN0IG5zMSA9IEdldFNsb3QodGhpcywgRVBPQ0hOQU5PU0VDT05EUyk7XG4gICAgICAgIGNvbnN0IG5zMiA9IEdldFNsb3Qob3RoZXIsIEVQT0NITkFOT1NFQ09ORFMpO1xuICAgICAgICBsZXQgeWVhcnMsIG1vbnRocywgd2Vla3MsIGRheXMsIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBtaWxsaXNlY29uZHMsIG1pY3Jvc2Vjb25kcywgbmFub3NlY29uZHM7XG4gICAgICAgIGlmIChsYXJnZXN0VW5pdCAhPT0gJ3llYXInICYmIGxhcmdlc3RVbml0ICE9PSAnbW9udGgnICYmIGxhcmdlc3RVbml0ICE9PSAnd2VlaycgJiYgbGFyZ2VzdFVuaXQgIT09ICdkYXknKSB7XG4gICAgICAgICAgICAvLyBUaGUgdXNlciBpcyBvbmx5IGFza2luZyBmb3IgYSB0aW1lIGRpZmZlcmVuY2UsIHNvIHJldHVybiBkaWZmZXJlbmNlIG9mIGluc3RhbnRzLlxuICAgICAgICAgICAgeWVhcnMgPSAwO1xuICAgICAgICAgICAgbW9udGhzID0gMDtcbiAgICAgICAgICAgIHdlZWtzID0gMDtcbiAgICAgICAgICAgIGRheXMgPSAwO1xuICAgICAgICAgICAgKHsgc2Vjb25kcywgbWlsbGlzZWNvbmRzLCBtaWNyb3NlY29uZHMsIG5hbm9zZWNvbmRzIH0gPSBEaWZmZXJlbmNlSW5zdGFudChuczEsIG5zMiwgcm91bmRpbmdJbmNyZW1lbnQsIHNtYWxsZXN0VW5pdCwgcm91bmRpbmdNb2RlKSk7XG4gICAgICAgICAgICAoeyBob3VycywgbWludXRlcywgc2Vjb25kcywgbWlsbGlzZWNvbmRzLCBtaWNyb3NlY29uZHMsIG5hbm9zZWNvbmRzIH0gPSBCYWxhbmNlRHVyYXRpb24oMCwgMCwgMCwgc2Vjb25kcywgbWlsbGlzZWNvbmRzLCBtaWNyb3NlY29uZHMsIG5hbm9zZWNvbmRzLCBsYXJnZXN0VW5pdCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgdGltZVpvbmUgPSBHZXRTbG90KHRoaXMsIFRJTUVfWk9ORSk7XG4gICAgICAgICAgICBpZiAoIVRpbWVab25lRXF1YWxzKHRpbWVab25lLCBHZXRTbG90KG90aGVyLCBUSU1FX1pPTkUpKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiV2hlbiBjYWxjdWxhdGluZyBkaWZmZXJlbmNlIGJldHdlZW4gdGltZSB6b25lcywgbGFyZ2VzdFVuaXQgbXVzdCBiZSAnaG91cnMnIFwiICtcbiAgICAgICAgICAgICAgICAgICAgJ29yIHNtYWxsZXIgYmVjYXVzZSBkYXkgbGVuZ3RocyBjYW4gdmFyeSBiZXR3ZWVuIHRpbWUgem9uZXMgZHVlIHRvIERTVCBvciB0aW1lIHpvbmUgb2Zmc2V0IGNoYW5nZXMuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB1bnRpbE9wdGlvbnMgPSB7IC4uLm9wdGlvbnMsIGxhcmdlc3RVbml0IH07XG4gICAgICAgICAgICAoeyB5ZWFycywgbW9udGhzLCB3ZWVrcywgZGF5cywgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc2Vjb25kcywgbWljcm9zZWNvbmRzLCBuYW5vc2Vjb25kcyB9ID1cbiAgICAgICAgICAgICAgICBEaWZmZXJlbmNlWm9uZWREYXRlVGltZShuczEsIG5zMiwgdGltZVpvbmUsIGNhbGVuZGFyLCBsYXJnZXN0VW5pdCwgdW50aWxPcHRpb25zKSk7XG4gICAgICAgICAgICAoeyB5ZWFycywgbW9udGhzLCB3ZWVrcywgZGF5cywgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc2Vjb25kcywgbWljcm9zZWNvbmRzLCBuYW5vc2Vjb25kcyB9ID1cbiAgICAgICAgICAgICAgICBSb3VuZER1cmF0aW9uKHllYXJzLCBtb250aHMsIHdlZWtzLCBkYXlzLCBob3VycywgbWludXRlcywgc2Vjb25kcywgbWlsbGlzZWNvbmRzLCBtaWNyb3NlY29uZHMsIG5hbm9zZWNvbmRzLCByb3VuZGluZ0luY3JlbWVudCwgc21hbGxlc3RVbml0LCByb3VuZGluZ01vZGUsIHRoaXMpKTtcbiAgICAgICAgICAgICh7IHllYXJzLCBtb250aHMsIHdlZWtzLCBkYXlzLCBob3VycywgbWludXRlcywgc2Vjb25kcywgbWlsbGlzZWNvbmRzLCBtaWNyb3NlY29uZHMsIG5hbm9zZWNvbmRzIH0gPVxuICAgICAgICAgICAgICAgIEFkanVzdFJvdW5kZWREdXJhdGlvbkRheXMoeWVhcnMsIG1vbnRocywgd2Vla3MsIGRheXMsIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBtaWxsaXNlY29uZHMsIG1pY3Jvc2Vjb25kcywgbmFub3NlY29uZHMsIHJvdW5kaW5nSW5jcmVtZW50LCBzbWFsbGVzdFVuaXQsIHJvdW5kaW5nTW9kZSwgdGhpcykpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IER1cmF0aW9uID0gR2V0SW50cmluc2ljKCclVGVtcG9yYWwuRHVyYXRpb24lJyk7XG4gICAgICAgIHJldHVybiBuZXcgRHVyYXRpb24oeWVhcnMsIG1vbnRocywgd2Vla3MsIGRheXMsIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBtaWxsaXNlY29uZHMsIG1pY3Jvc2Vjb25kcywgbmFub3NlY29uZHMpO1xuICAgIH1cbiAgICBzaW5jZShvdGhlclBhcmFtLCBvcHRpb25zUGFyYW0gPSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsWm9uZWREYXRlVGltZSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgY29uc3Qgb3RoZXIgPSBUb1RlbXBvcmFsWm9uZWREYXRlVGltZShvdGhlclBhcmFtKTtcbiAgICAgICAgY29uc3QgY2FsZW5kYXIgPSBHZXRTbG90KHRoaXMsIENBTEVOREFSKTtcbiAgICAgICAgY29uc3Qgb3RoZXJDYWxlbmRhciA9IEdldFNsb3Qob3RoZXIsIENBTEVOREFSKTtcbiAgICAgICAgY29uc3QgY2FsZW5kYXJJZCA9IFRvU3RyaW5nKGNhbGVuZGFyKTtcbiAgICAgICAgY29uc3Qgb3RoZXJDYWxlbmRhcklkID0gVG9TdHJpbmcob3RoZXJDYWxlbmRhcik7XG4gICAgICAgIGlmIChjYWxlbmRhcklkICE9PSBvdGhlckNhbGVuZGFySWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBjYW5ub3QgY29tcHV0ZSBkaWZmZXJlbmNlIGJldHdlZW4gZGF0ZXMgb2YgJHtjYWxlbmRhcklkfSBhbmQgJHtvdGhlckNhbGVuZGFySWR9IGNhbGVuZGFyc2ApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSBHZXRPcHRpb25zT2JqZWN0KG9wdGlvbnNQYXJhbSk7XG4gICAgICAgIGNvbnN0IHNtYWxsZXN0VW5pdCA9IFRvU21hbGxlc3RUZW1wb3JhbFVuaXQob3B0aW9ucywgJ25hbm9zZWNvbmQnKTtcbiAgICAgICAgY29uc3QgZGVmYXVsdExhcmdlc3RVbml0ID0gTGFyZ2VyT2ZUd29UZW1wb3JhbFVuaXRzKCdob3VyJywgc21hbGxlc3RVbml0KTtcbiAgICAgICAgY29uc3QgbGFyZ2VzdFVuaXQgPSBUb0xhcmdlc3RUZW1wb3JhbFVuaXQob3B0aW9ucywgJ2F1dG8nLCBbXSwgZGVmYXVsdExhcmdlc3RVbml0KTtcbiAgICAgICAgVmFsaWRhdGVUZW1wb3JhbFVuaXRSYW5nZShsYXJnZXN0VW5pdCwgc21hbGxlc3RVbml0KTtcbiAgICAgICAgbGV0IHJvdW5kaW5nTW9kZSA9IFRvVGVtcG9yYWxSb3VuZGluZ01vZGUob3B0aW9ucywgJ3RydW5jJyk7XG4gICAgICAgIHJvdW5kaW5nTW9kZSA9IE5lZ2F0ZVRlbXBvcmFsUm91bmRpbmdNb2RlKHJvdW5kaW5nTW9kZSk7XG4gICAgICAgIGNvbnN0IHJvdW5kaW5nSW5jcmVtZW50ID0gVG9UZW1wb3JhbERhdGVUaW1lUm91bmRpbmdJbmNyZW1lbnQob3B0aW9ucywgc21hbGxlc3RVbml0KTtcbiAgICAgICAgY29uc3QgbnMxID0gR2V0U2xvdCh0aGlzLCBFUE9DSE5BTk9TRUNPTkRTKTtcbiAgICAgICAgY29uc3QgbnMyID0gR2V0U2xvdChvdGhlciwgRVBPQ0hOQU5PU0VDT05EUyk7XG4gICAgICAgIGxldCB5ZWFycywgbW9udGhzLCB3ZWVrcywgZGF5cywgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc2Vjb25kcywgbWljcm9zZWNvbmRzLCBuYW5vc2Vjb25kcztcbiAgICAgICAgaWYgKGxhcmdlc3RVbml0ICE9PSAneWVhcicgJiYgbGFyZ2VzdFVuaXQgIT09ICdtb250aCcgJiYgbGFyZ2VzdFVuaXQgIT09ICd3ZWVrJyAmJiBsYXJnZXN0VW5pdCAhPT0gJ2RheScpIHtcbiAgICAgICAgICAgIC8vIFRoZSB1c2VyIGlzIG9ubHkgYXNraW5nIGZvciBhIHRpbWUgZGlmZmVyZW5jZSwgc28gcmV0dXJuIGRpZmZlcmVuY2Ugb2YgaW5zdGFudHMuXG4gICAgICAgICAgICB5ZWFycyA9IDA7XG4gICAgICAgICAgICBtb250aHMgPSAwO1xuICAgICAgICAgICAgd2Vla3MgPSAwO1xuICAgICAgICAgICAgZGF5cyA9IDA7XG4gICAgICAgICAgICAoeyBzZWNvbmRzLCBtaWxsaXNlY29uZHMsIG1pY3Jvc2Vjb25kcywgbmFub3NlY29uZHMgfSA9IERpZmZlcmVuY2VJbnN0YW50KG5zMSwgbnMyLCByb3VuZGluZ0luY3JlbWVudCwgc21hbGxlc3RVbml0LCByb3VuZGluZ01vZGUpKTtcbiAgICAgICAgICAgICh7IGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBtaWxsaXNlY29uZHMsIG1pY3Jvc2Vjb25kcywgbmFub3NlY29uZHMgfSA9IEJhbGFuY2VEdXJhdGlvbigwLCAwLCAwLCBzZWNvbmRzLCBtaWxsaXNlY29uZHMsIG1pY3Jvc2Vjb25kcywgbmFub3NlY29uZHMsIGxhcmdlc3RVbml0KSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCB0aW1lWm9uZSA9IEdldFNsb3QodGhpcywgVElNRV9aT05FKTtcbiAgICAgICAgICAgIGlmICghVGltZVpvbmVFcXVhbHModGltZVpvbmUsIEdldFNsb3Qob3RoZXIsIFRJTUVfWk9ORSkpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJXaGVuIGNhbGN1bGF0aW5nIGRpZmZlcmVuY2UgYmV0d2VlbiB0aW1lIHpvbmVzLCBsYXJnZXN0VW5pdCBtdXN0IGJlICdob3VycycgXCIgK1xuICAgICAgICAgICAgICAgICAgICAnb3Igc21hbGxlciBiZWNhdXNlIGRheSBsZW5ndGhzIGNhbiB2YXJ5IGJldHdlZW4gdGltZSB6b25lcyBkdWUgdG8gRFNUIG9yIHRpbWUgem9uZSBvZmZzZXQgY2hhbmdlcy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHVudGlsT3B0aW9ucyA9IHsgLi4ub3B0aW9ucywgbGFyZ2VzdFVuaXQgfTtcbiAgICAgICAgICAgICh7IHllYXJzLCBtb250aHMsIHdlZWtzLCBkYXlzLCBob3VycywgbWludXRlcywgc2Vjb25kcywgbWlsbGlzZWNvbmRzLCBtaWNyb3NlY29uZHMsIG5hbm9zZWNvbmRzIH0gPVxuICAgICAgICAgICAgICAgIERpZmZlcmVuY2Vab25lZERhdGVUaW1lKG5zMSwgbnMyLCB0aW1lWm9uZSwgY2FsZW5kYXIsIGxhcmdlc3RVbml0LCB1bnRpbE9wdGlvbnMpKTtcbiAgICAgICAgICAgICh7IHllYXJzLCBtb250aHMsIHdlZWtzLCBkYXlzLCBob3VycywgbWludXRlcywgc2Vjb25kcywgbWlsbGlzZWNvbmRzLCBtaWNyb3NlY29uZHMsIG5hbm9zZWNvbmRzIH0gPVxuICAgICAgICAgICAgICAgIFJvdW5kRHVyYXRpb24oeWVhcnMsIG1vbnRocywgd2Vla3MsIGRheXMsIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBtaWxsaXNlY29uZHMsIG1pY3Jvc2Vjb25kcywgbmFub3NlY29uZHMsIHJvdW5kaW5nSW5jcmVtZW50LCBzbWFsbGVzdFVuaXQsIHJvdW5kaW5nTW9kZSwgdGhpcykpO1xuICAgICAgICAgICAgKHsgeWVhcnMsIG1vbnRocywgd2Vla3MsIGRheXMsIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBtaWxsaXNlY29uZHMsIG1pY3Jvc2Vjb25kcywgbmFub3NlY29uZHMgfSA9XG4gICAgICAgICAgICAgICAgQWRqdXN0Um91bmRlZER1cmF0aW9uRGF5cyh5ZWFycywgbW9udGhzLCB3ZWVrcywgZGF5cywgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc2Vjb25kcywgbWljcm9zZWNvbmRzLCBuYW5vc2Vjb25kcywgcm91bmRpbmdJbmNyZW1lbnQsIHNtYWxsZXN0VW5pdCwgcm91bmRpbmdNb2RlLCB0aGlzKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgRHVyYXRpb24gPSBHZXRJbnRyaW5zaWMoJyVUZW1wb3JhbC5EdXJhdGlvbiUnKTtcbiAgICAgICAgcmV0dXJuIG5ldyBEdXJhdGlvbigteWVhcnMsIC1tb250aHMsIC13ZWVrcywgLWRheXMsIC1ob3VycywgLW1pbnV0ZXMsIC1zZWNvbmRzLCAtbWlsbGlzZWNvbmRzLCAtbWljcm9zZWNvbmRzLCAtbmFub3NlY29uZHMpO1xuICAgIH1cbiAgICByb3VuZChvcHRpb25zUGFyYW0pIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsWm9uZWREYXRlVGltZSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgaWYgKG9wdGlvbnNQYXJhbSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignb3B0aW9ucyBwYXJhbWV0ZXIgaXMgcmVxdWlyZWQnKTtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHR5cGVvZiBvcHRpb25zUGFyYW0gPT09ICdzdHJpbmcnXG4gICAgICAgICAgICA/IENyZWF0ZU9uZVByb3BPYmplY3QoJ3NtYWxsZXN0VW5pdCcsIG9wdGlvbnNQYXJhbSlcbiAgICAgICAgICAgIDogR2V0T3B0aW9uc09iamVjdChvcHRpb25zUGFyYW0pO1xuICAgICAgICBjb25zdCBzbWFsbGVzdFVuaXQgPSBUb1NtYWxsZXN0VGVtcG9yYWxVbml0KG9wdGlvbnMsIHVuZGVmaW5lZCwgWyd5ZWFyJywgJ21vbnRoJywgJ3dlZWsnXSk7XG4gICAgICAgIGlmIChzbWFsbGVzdFVuaXQgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdzbWFsbGVzdFVuaXQgaXMgcmVxdWlyZWQnKTtcbiAgICAgICAgY29uc3Qgcm91bmRpbmdNb2RlID0gVG9UZW1wb3JhbFJvdW5kaW5nTW9kZShvcHRpb25zLCAnaGFsZkV4cGFuZCcpO1xuICAgICAgICBjb25zdCBtYXhpbXVtSW5jcmVtZW50cyA9IHtcbiAgICAgICAgICAgIGRheTogMSxcbiAgICAgICAgICAgIGhvdXI6IDI0LFxuICAgICAgICAgICAgbWludXRlOiA2MCxcbiAgICAgICAgICAgIHNlY29uZDogNjAsXG4gICAgICAgICAgICBtaWxsaXNlY29uZDogMTAwMCxcbiAgICAgICAgICAgIG1pY3Jvc2Vjb25kOiAxMDAwLFxuICAgICAgICAgICAgbmFub3NlY29uZDogMTAwMFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCByb3VuZGluZ0luY3JlbWVudCA9IFRvVGVtcG9yYWxSb3VuZGluZ0luY3JlbWVudChvcHRpb25zLCBtYXhpbXVtSW5jcmVtZW50c1tzbWFsbGVzdFVuaXRdLCBmYWxzZSk7XG4gICAgICAgIC8vIGZpcnN0LCByb3VuZCB0aGUgdW5kZXJseWluZyBEYXRlVGltZSBmaWVsZHNcbiAgICAgICAgY29uc3QgZHQgPSBkYXRlVGltZSh0aGlzKTtcbiAgICAgICAgbGV0IHllYXIgPSBHZXRTbG90KGR0LCBJU09fWUVBUik7XG4gICAgICAgIGxldCBtb250aCA9IEdldFNsb3QoZHQsIElTT19NT05USCk7XG4gICAgICAgIGxldCBkYXkgPSBHZXRTbG90KGR0LCBJU09fREFZKTtcbiAgICAgICAgbGV0IGhvdXIgPSBHZXRTbG90KGR0LCBJU09fSE9VUik7XG4gICAgICAgIGxldCBtaW51dGUgPSBHZXRTbG90KGR0LCBJU09fTUlOVVRFKTtcbiAgICAgICAgbGV0IHNlY29uZCA9IEdldFNsb3QoZHQsIElTT19TRUNPTkQpO1xuICAgICAgICBsZXQgbWlsbGlzZWNvbmQgPSBHZXRTbG90KGR0LCBJU09fTUlMTElTRUNPTkQpO1xuICAgICAgICBsZXQgbWljcm9zZWNvbmQgPSBHZXRTbG90KGR0LCBJU09fTUlDUk9TRUNPTkQpO1xuICAgICAgICBsZXQgbmFub3NlY29uZCA9IEdldFNsb3QoZHQsIElTT19OQU5PU0VDT05EKTtcbiAgICAgICAgY29uc3QgRGF0ZVRpbWUgPSBHZXRJbnRyaW5zaWMoJyVUZW1wb3JhbC5QbGFpbkRhdGVUaW1lJScpO1xuICAgICAgICBjb25zdCB0aW1lWm9uZSA9IEdldFNsb3QodGhpcywgVElNRV9aT05FKTtcbiAgICAgICAgY29uc3QgY2FsZW5kYXIgPSBHZXRTbG90KHRoaXMsIENBTEVOREFSKTtcbiAgICAgICAgY29uc3QgZHRTdGFydCA9IG5ldyBEYXRlVGltZShHZXRTbG90KGR0LCBJU09fWUVBUiksIEdldFNsb3QoZHQsIElTT19NT05USCksIEdldFNsb3QoZHQsIElTT19EQVkpLCAwLCAwLCAwLCAwLCAwLCAwKTtcbiAgICAgICAgY29uc3QgaW5zdGFudFN0YXJ0ID0gQnVpbHRpblRpbWVab25lR2V0SW5zdGFudEZvcih0aW1lWm9uZSwgZHRTdGFydCwgJ2NvbXBhdGlibGUnKTtcbiAgICAgICAgY29uc3QgZW5kTnMgPSBBZGRab25lZERhdGVUaW1lKGluc3RhbnRTdGFydCwgdGltZVpvbmUsIGNhbGVuZGFyLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAwLCAwKTtcbiAgICAgICAgY29uc3QgZGF5TGVuZ3RoTnMgPSBKU0JJLnN1YnRyYWN0KGVuZE5zLCBKU0JJLkJpZ0ludChHZXRTbG90KGluc3RhbnRTdGFydCwgRVBPQ0hOQU5PU0VDT05EUykpKTtcbiAgICAgICAgaWYgKEpTQkkuZXF1YWwoZGF5TGVuZ3RoTnMsIFpFUk8pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignY2Fubm90IHJvdW5kIGEgWm9uZWREYXRlVGltZSBpbiBhIGNhbGVuZGFyIHdpdGggemVyby1sZW5ndGggZGF5cycpO1xuICAgICAgICB9XG4gICAgICAgICh7IHllYXIsIG1vbnRoLCBkYXksIGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZCwgbWljcm9zZWNvbmQsIG5hbm9zZWNvbmQgfSA9IFJvdW5kSVNPRGF0ZVRpbWUoeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kLCBtaWNyb3NlY29uZCwgbmFub3NlY29uZCwgcm91bmRpbmdJbmNyZW1lbnQsIHNtYWxsZXN0VW5pdCwgcm91bmRpbmdNb2RlLCBcbiAgICAgICAgLy8gRGF5cyBhcmUgZ3VhcmFudGVlZCB0byBiZSBzaG9ydGVyIHRoYW4gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJcbiAgICAgICAgLy8gKHdoaWNoIGNhbiBob2xkIHVwIHRvIDEwNCBkYXlzIGluIG5hbm9zZWNvbmRzKVxuICAgICAgICBKU0JJLnRvTnVtYmVyKGRheUxlbmd0aE5zKSkpO1xuICAgICAgICAvLyBOb3cgcmVzZXQgYWxsIERhdGVUaW1lIGZpZWxkcyBidXQgbGVhdmUgdGhlIFRpbWVab25lLiBUaGUgb2Zmc2V0IHdpbGxcbiAgICAgICAgLy8gYWxzbyBiZSByZXRhaW5lZCBpZiB0aGUgbmV3IGRhdGUvdGltZSB2YWx1ZXMgYXJlIHN0aWxsIE9LIHdpdGggdGhlIG9sZFxuICAgICAgICAvLyBvZmZzZXQuIE90aGVyd2lzZSB0aGUgb2Zmc2V0IHdpbGwgYmUgY2hhbmdlZCB0byBiZSBjb21wYXRpYmxlIHdpdGggdGhlXG4gICAgICAgIC8vIG5ldyBkYXRlL3RpbWUgdmFsdWVzLiBJZiBEU1QgZGlzYW1iaWd1YXRpb24gaXMgcmVxdWlyZWQsIHRoZSBgY29tcGF0aWJsZWBcbiAgICAgICAgLy8gZGlzYW1iaWd1YXRpb24gYWxnb3JpdGhtIHdpbGwgYmUgdXNlZC5cbiAgICAgICAgY29uc3Qgb2Zmc2V0TnMgPSBHZXRPZmZzZXROYW5vc2Vjb25kc0Zvcih0aW1lWm9uZSwgR2V0U2xvdCh0aGlzLCBJTlNUQU5UKSk7XG4gICAgICAgIGNvbnN0IGVwb2NoTmFub3NlY29uZHMgPSBJbnRlcnByZXRJU09EYXRlVGltZU9mZnNldCh5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQsIG1pY3Jvc2Vjb25kLCBuYW5vc2Vjb25kLCAnb3B0aW9uJywgb2Zmc2V0TnMsIHRpbWVab25lLCAnY29tcGF0aWJsZScsICdwcmVmZXInLCBcbiAgICAgICAgLyogbWF0Y2hNaW51dGUgPSAqLyBmYWxzZSk7XG4gICAgICAgIHJldHVybiBDcmVhdGVUZW1wb3JhbFpvbmVkRGF0ZVRpbWUoZXBvY2hOYW5vc2Vjb25kcywgdGltZVpvbmUsIEdldFNsb3QodGhpcywgQ0FMRU5EQVIpKTtcbiAgICB9XG4gICAgZXF1YWxzKG90aGVyUGFyYW0pIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsWm9uZWREYXRlVGltZSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgY29uc3Qgb3RoZXIgPSBUb1RlbXBvcmFsWm9uZWREYXRlVGltZShvdGhlclBhcmFtKTtcbiAgICAgICAgY29uc3Qgb25lID0gR2V0U2xvdCh0aGlzLCBFUE9DSE5BTk9TRUNPTkRTKTtcbiAgICAgICAgY29uc3QgdHdvID0gR2V0U2xvdChvdGhlciwgRVBPQ0hOQU5PU0VDT05EUyk7XG4gICAgICAgIGlmICghSlNCSS5lcXVhbChKU0JJLkJpZ0ludChvbmUpLCBKU0JJLkJpZ0ludCh0d28pKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKCFUaW1lWm9uZUVxdWFscyhHZXRTbG90KHRoaXMsIFRJTUVfWk9ORSksIEdldFNsb3Qob3RoZXIsIFRJTUVfWk9ORSkpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXR1cm4gQ2FsZW5kYXJFcXVhbHMoR2V0U2xvdCh0aGlzLCBDQUxFTkRBUiksIEdldFNsb3Qob3RoZXIsIENBTEVOREFSKSk7XG4gICAgfVxuICAgIHRvU3RyaW5nKG9wdGlvbnNQYXJhbSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxab25lZERhdGVUaW1lKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICBjb25zdCBvcHRpb25zID0gR2V0T3B0aW9uc09iamVjdChvcHRpb25zUGFyYW0pO1xuICAgICAgICBjb25zdCB7IHByZWNpc2lvbiwgdW5pdCwgaW5jcmVtZW50IH0gPSBUb1NlY29uZHNTdHJpbmdQcmVjaXNpb24ob3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IHJvdW5kaW5nTW9kZSA9IFRvVGVtcG9yYWxSb3VuZGluZ01vZGUob3B0aW9ucywgJ3RydW5jJyk7XG4gICAgICAgIGNvbnN0IHNob3dDYWxlbmRhciA9IFRvU2hvd0NhbGVuZGFyT3B0aW9uKG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBzaG93VGltZVpvbmUgPSBUb1Nob3dUaW1lWm9uZU5hbWVPcHRpb24ob3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IHNob3dPZmZzZXQgPSBUb1Nob3dPZmZzZXRPcHRpb24ob3B0aW9ucyk7XG4gICAgICAgIHJldHVybiBUZW1wb3JhbFpvbmVkRGF0ZVRpbWVUb1N0cmluZyh0aGlzLCBwcmVjaXNpb24sIHNob3dDYWxlbmRhciwgc2hvd1RpbWVab25lLCBzaG93T2Zmc2V0LCB7XG4gICAgICAgICAgICB1bml0LFxuICAgICAgICAgICAgaW5jcmVtZW50LFxuICAgICAgICAgICAgcm91bmRpbmdNb2RlXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB0b0xvY2FsZVN0cmluZyhsb2NhbGVzID0gdW5kZWZpbmVkLCBvcHRpb25zID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbFpvbmVkRGF0ZVRpbWUodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZVRpbWVGb3JtYXQobG9jYWxlcywgb3B0aW9ucykuZm9ybWF0KHRoaXMpO1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbFpvbmVkRGF0ZVRpbWUodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIHJldHVybiBUZW1wb3JhbFpvbmVkRGF0ZVRpbWVUb1N0cmluZyh0aGlzLCAnYXV0bycpO1xuICAgIH1cbiAgICB2YWx1ZU9mKCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd1c2UgY29tcGFyZSgpIG9yIGVxdWFscygpIHRvIGNvbXBhcmUgVGVtcG9yYWwuWm9uZWREYXRlVGltZScpO1xuICAgIH1cbiAgICBzdGFydE9mRGF5KCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxab25lZERhdGVUaW1lKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICBjb25zdCBkdCA9IGRhdGVUaW1lKHRoaXMpO1xuICAgICAgICBjb25zdCBEYXRlVGltZSA9IEdldEludHJpbnNpYygnJVRlbXBvcmFsLlBsYWluRGF0ZVRpbWUlJyk7XG4gICAgICAgIGNvbnN0IGNhbGVuZGFyID0gR2V0U2xvdCh0aGlzLCBDQUxFTkRBUik7XG4gICAgICAgIGNvbnN0IGR0U3RhcnQgPSBuZXcgRGF0ZVRpbWUoR2V0U2xvdChkdCwgSVNPX1lFQVIpLCBHZXRTbG90KGR0LCBJU09fTU9OVEgpLCBHZXRTbG90KGR0LCBJU09fREFZKSwgMCwgMCwgMCwgMCwgMCwgMCwgY2FsZW5kYXIpO1xuICAgICAgICBjb25zdCB0aW1lWm9uZSA9IEdldFNsb3QodGhpcywgVElNRV9aT05FKTtcbiAgICAgICAgY29uc3QgaW5zdGFudCA9IEJ1aWx0aW5UaW1lWm9uZUdldEluc3RhbnRGb3IodGltZVpvbmUsIGR0U3RhcnQsICdjb21wYXRpYmxlJyk7XG4gICAgICAgIHJldHVybiBDcmVhdGVUZW1wb3JhbFpvbmVkRGF0ZVRpbWUoR2V0U2xvdChpbnN0YW50LCBFUE9DSE5BTk9TRUNPTkRTKSwgdGltZVpvbmUsIGNhbGVuZGFyKTtcbiAgICB9XG4gICAgdG9JbnN0YW50KCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxab25lZERhdGVUaW1lKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICBjb25zdCBUZW1wb3JhbEluc3RhbnQgPSBHZXRJbnRyaW5zaWMoJyVUZW1wb3JhbC5JbnN0YW50JScpO1xuICAgICAgICByZXR1cm4gbmV3IFRlbXBvcmFsSW5zdGFudChHZXRTbG90KHRoaXMsIEVQT0NITkFOT1NFQ09ORFMpKTtcbiAgICB9XG4gICAgdG9QbGFpbkRhdGUoKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbFpvbmVkRGF0ZVRpbWUodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIHJldHVybiBUZW1wb3JhbERhdGVUaW1lVG9EYXRlKGRhdGVUaW1lKHRoaXMpKTtcbiAgICB9XG4gICAgdG9QbGFpblRpbWUoKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbFpvbmVkRGF0ZVRpbWUodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIHJldHVybiBUZW1wb3JhbERhdGVUaW1lVG9UaW1lKGRhdGVUaW1lKHRoaXMpKTtcbiAgICB9XG4gICAgdG9QbGFpbkRhdGVUaW1lKCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxab25lZERhdGVUaW1lKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICByZXR1cm4gZGF0ZVRpbWUodGhpcyk7XG4gICAgfVxuICAgIHRvUGxhaW5ZZWFyTW9udGgoKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbFpvbmVkRGF0ZVRpbWUodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIGNvbnN0IGNhbGVuZGFyID0gR2V0U2xvdCh0aGlzLCBDQUxFTkRBUik7XG4gICAgICAgIGNvbnN0IGZpZWxkTmFtZXMgPSBDYWxlbmRhckZpZWxkcyhjYWxlbmRhciwgWydtb250aENvZGUnLCAneWVhciddKTtcbiAgICAgICAgY29uc3QgZmllbGRzID0gVG9UZW1wb3JhbFllYXJNb250aEZpZWxkcyh0aGlzLCBmaWVsZE5hbWVzKTtcbiAgICAgICAgcmV0dXJuIFllYXJNb250aEZyb21GaWVsZHMoY2FsZW5kYXIsIGZpZWxkcyk7XG4gICAgfVxuICAgIHRvUGxhaW5Nb250aERheSgpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsWm9uZWREYXRlVGltZSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgY29uc3QgY2FsZW5kYXIgPSBHZXRTbG90KHRoaXMsIENBTEVOREFSKTtcbiAgICAgICAgY29uc3QgZmllbGROYW1lcyA9IENhbGVuZGFyRmllbGRzKGNhbGVuZGFyLCBbJ2RheScsICdtb250aENvZGUnXSk7XG4gICAgICAgIGNvbnN0IGZpZWxkcyA9IFRvVGVtcG9yYWxNb250aERheUZpZWxkcyh0aGlzLCBmaWVsZE5hbWVzKTtcbiAgICAgICAgcmV0dXJuIE1vbnRoRGF5RnJvbUZpZWxkcyhjYWxlbmRhciwgZmllbGRzKTtcbiAgICB9XG4gICAgZ2V0SVNPRmllbGRzKCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxab25lZERhdGVUaW1lKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICBjb25zdCBkdCA9IGRhdGVUaW1lKHRoaXMpO1xuICAgICAgICBjb25zdCB0eiA9IEdldFNsb3QodGhpcywgVElNRV9aT05FKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNhbGVuZGFyOiBHZXRTbG90KHRoaXMsIENBTEVOREFSKSxcbiAgICAgICAgICAgIGlzb0RheTogR2V0U2xvdChkdCwgSVNPX0RBWSksXG4gICAgICAgICAgICBpc29Ib3VyOiBHZXRTbG90KGR0LCBJU09fSE9VUiksXG4gICAgICAgICAgICBpc29NaWNyb3NlY29uZDogR2V0U2xvdChkdCwgSVNPX01JQ1JPU0VDT05EKSxcbiAgICAgICAgICAgIGlzb01pbGxpc2Vjb25kOiBHZXRTbG90KGR0LCBJU09fTUlMTElTRUNPTkQpLFxuICAgICAgICAgICAgaXNvTWludXRlOiBHZXRTbG90KGR0LCBJU09fTUlOVVRFKSxcbiAgICAgICAgICAgIGlzb01vbnRoOiBHZXRTbG90KGR0LCBJU09fTU9OVEgpLFxuICAgICAgICAgICAgaXNvTmFub3NlY29uZDogR2V0U2xvdChkdCwgSVNPX05BTk9TRUNPTkQpLFxuICAgICAgICAgICAgaXNvU2Vjb25kOiBHZXRTbG90KGR0LCBJU09fU0VDT05EKSxcbiAgICAgICAgICAgIGlzb1llYXI6IEdldFNsb3QoZHQsIElTT19ZRUFSKSxcbiAgICAgICAgICAgIG9mZnNldDogQnVpbHRpblRpbWVab25lR2V0T2Zmc2V0U3RyaW5nRm9yKHR6LCBHZXRTbG90KHRoaXMsIElOU1RBTlQpKSxcbiAgICAgICAgICAgIHRpbWVab25lOiB0elxuICAgICAgICB9O1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbShpdGVtLCBvcHRpb25zUGFyYW0gPSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IEdldE9wdGlvbnNPYmplY3Qob3B0aW9uc1BhcmFtKTtcbiAgICAgICAgaWYgKElzVGVtcG9yYWxab25lZERhdGVUaW1lKGl0ZW0pKSB7XG4gICAgICAgICAgICBUb1RlbXBvcmFsT3ZlcmZsb3cob3B0aW9ucyk7IC8vIHZhbGlkYXRlIGFuZCBpZ25vcmVcbiAgICAgICAgICAgIFRvVGVtcG9yYWxEaXNhbWJpZ3VhdGlvbihvcHRpb25zKTtcbiAgICAgICAgICAgIFRvVGVtcG9yYWxPZmZzZXQob3B0aW9ucywgJ3JlamVjdCcpO1xuICAgICAgICAgICAgcmV0dXJuIENyZWF0ZVRlbXBvcmFsWm9uZWREYXRlVGltZShHZXRTbG90KGl0ZW0sIEVQT0NITkFOT1NFQ09ORFMpLCBHZXRTbG90KGl0ZW0sIFRJTUVfWk9ORSksIEdldFNsb3QoaXRlbSwgQ0FMRU5EQVIpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gVG9UZW1wb3JhbFpvbmVkRGF0ZVRpbWUoaXRlbSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIHN0YXRpYyBjb21wYXJlKG9uZVBhcmFtLCB0d29QYXJhbSkge1xuICAgICAgICBjb25zdCBvbmUgPSBUb1RlbXBvcmFsWm9uZWREYXRlVGltZShvbmVQYXJhbSk7XG4gICAgICAgIGNvbnN0IHR3byA9IFRvVGVtcG9yYWxab25lZERhdGVUaW1lKHR3b1BhcmFtKTtcbiAgICAgICAgY29uc3QgbnMxID0gR2V0U2xvdChvbmUsIEVQT0NITkFOT1NFQ09ORFMpO1xuICAgICAgICBjb25zdCBuczIgPSBHZXRTbG90KHR3bywgRVBPQ0hOQU5PU0VDT05EUyk7XG4gICAgICAgIGlmIChKU0JJLmxlc3NUaGFuKEpTQkkuQmlnSW50KG5zMSksIEpTQkkuQmlnSW50KG5zMikpKVxuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICBpZiAoSlNCSS5ncmVhdGVyVGhhbihKU0JJLkJpZ0ludChuczEpLCBKU0JJLkJpZ0ludChuczIpKSlcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG59XG5NYWtlSW50cmluc2ljQ2xhc3MoWm9uZWREYXRlVGltZSwgJ1RlbXBvcmFsLlpvbmVkRGF0ZVRpbWUnKTtcbmZ1bmN0aW9uIGRhdGVUaW1lKHpkdCkge1xuICAgIHJldHVybiBCdWlsdGluVGltZVpvbmVHZXRQbGFpbkRhdGVUaW1lRm9yKEdldFNsb3QoemR0LCBUSU1FX1pPTkUpLCBHZXRTbG90KHpkdCwgSU5TVEFOVCksIEdldFNsb3QoemR0LCBDQUxFTkRBUikpO1xufVxuXG52YXIgdGVtcG9yYWwgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIEluc3RhbnQ6IEluc3RhbnQsXG4gICAgQ2FsZW5kYXI6IENhbGVuZGFyLFxuICAgIFBsYWluRGF0ZTogUGxhaW5EYXRlLFxuICAgIFBsYWluRGF0ZVRpbWU6IFBsYWluRGF0ZVRpbWUsXG4gICAgRHVyYXRpb246IER1cmF0aW9uLFxuICAgIFBsYWluTW9udGhEYXk6IFBsYWluTW9udGhEYXksXG4gICAgTm93OiBOb3csXG4gICAgUGxhaW5UaW1lOiBQbGFpblRpbWUsXG4gICAgVGltZVpvbmU6IFRpbWVab25lLFxuICAgIFBsYWluWWVhck1vbnRoOiBQbGFpblllYXJNb250aCxcbiAgICBab25lZERhdGVUaW1lOiBab25lZERhdGVUaW1lXG59KTtcblxuZnVuY3Rpb24gdG9UZW1wb3JhbEluc3RhbnQoKSB7XG4gICAgLy8gT2JzZXJ2YWJsZSBhY2Nlc3MgdG8gdmFsdWVPZiBpcyBub3QgY29ycmVjdCBoZXJlLCBidXQgdW5hdm9pZGFibGVcbiAgICBjb25zdCBlcG9jaE5hbm9zZWNvbmRzID0gSlNCSS5tdWx0aXBseShKU0JJLkJpZ0ludCgrdGhpcyksIE1JTExJT04pO1xuICAgIHJldHVybiBuZXcgSW5zdGFudChUb0JpZ0ludChlcG9jaE5hbm9zZWNvbmRzKSk7XG59XG5cbi8vIFRoaXMgZW50cnkgcG9pbnQgdHJlYXRzIFRlbXBvcmFsIGFzIGEgbGlicmFyeSwgYW5kIGRvZXMgbm90IHBvbHlmaWxsIGl0IG9udG9cbi8vIFdvcmsgYXJvdW5kIGh0dHBzOi8vZ2l0aHViLmNvbS9iYWJlbC9iYWJlbC9pc3N1ZXMvMjAyNS5cbmNvbnN0IHR5cGVzID0gW1xuICAgIEluc3RhbnQsXG4gICAgQ2FsZW5kYXIsXG4gICAgUGxhaW5EYXRlLFxuICAgIFBsYWluRGF0ZVRpbWUsXG4gICAgRHVyYXRpb24sXG4gICAgUGxhaW5Nb250aERheSxcbiAgICAvLyBUZW1wb3JhbC5Ob3csIC8vIHBsYWluIG9iamVjdCAobm90IGEgY29uc3RydWN0b3IpLCBzbyBubyBgcHJvdG90eXBlYFxuICAgIFBsYWluVGltZSxcbiAgICBUaW1lWm9uZSxcbiAgICBQbGFpblllYXJNb250aCxcbiAgICBab25lZERhdGVUaW1lXG5dO1xuZm9yIChjb25zdCB0eXBlIG9mIHR5cGVzKSB7XG4gICAgY29uc3QgZGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodHlwZSwgJ3Byb3RvdHlwZScpO1xuICAgIGlmIChkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSB8fCBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZGVzY3JpcHRvci53cml0YWJsZSkge1xuICAgICAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IGZhbHNlO1xuICAgICAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBmYWxzZTtcbiAgICAgICAgZGVzY3JpcHRvci53cml0YWJsZSA9IGZhbHNlO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodHlwZSwgJ3Byb3RvdHlwZScsIGRlc2NyaXB0b3IpO1xuICAgIH1cbn1cblxuZXhwb3J0IHsgaW50bCBhcyBJbnRsLCB0ZW1wb3JhbCBhcyBUZW1wb3JhbCwgdG9UZW1wb3JhbEluc3RhbnQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmVzbS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@js-temporal/polyfill/dist/index.esm.js\n");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval-source-map devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.js");
/******/ 	
/******/ })()
;