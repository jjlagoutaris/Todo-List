/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/array-union/index.js":
/*!*******************************************!*\
  !*** ./node_modules/array-union/index.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nvar arrayUniq = __webpack_require__(/*! array-uniq */ \"./node_modules/array-uniq/index.js\");\n\nmodule.exports = function () {\n\treturn arrayUniq([].concat.apply([], arguments));\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXJyYXktdW5pb24vaW5kZXguanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixnQkFBZ0IsbUJBQU8sQ0FBQyxzREFBWTs7QUFFcEM7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdG9kby1saXN0Ly4vbm9kZV9tb2R1bGVzL2FycmF5LXVuaW9uL2luZGV4LmpzPzNlMmQiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xudmFyIGFycmF5VW5pcSA9IHJlcXVpcmUoJ2FycmF5LXVuaXEnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG5cdHJldHVybiBhcnJheVVuaXEoW10uY29uY2F0LmFwcGx5KFtdLCBhcmd1bWVudHMpKTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/array-union/index.js\n");

/***/ }),

/***/ "./node_modules/array-uniq/index.js":
/*!******************************************!*\
  !*** ./node_modules/array-uniq/index.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n// there's 3 implementations written in increasing order of efficiency\n\n// 1 - no Set type is defined\nfunction uniqNoSet(arr) {\n\tvar ret = [];\n\n\tfor (var i = 0; i < arr.length; i++) {\n\t\tif (ret.indexOf(arr[i]) === -1) {\n\t\t\tret.push(arr[i]);\n\t\t}\n\t}\n\n\treturn ret;\n}\n\n// 2 - a simple Set type is defined\nfunction uniqSet(arr) {\n\tvar seen = new Set();\n\treturn arr.filter(function (el) {\n\t\tif (!seen.has(el)) {\n\t\t\tseen.add(el);\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t});\n}\n\n// 3 - a standard Set type is defined and it has a forEach method\nfunction uniqSetWithForEach(arr) {\n\tvar ret = [];\n\n\t(new Set(arr)).forEach(function (el) {\n\t\tret.push(el);\n\t});\n\n\treturn ret;\n}\n\n// V8 currently has a broken implementation\n// https://github.com/joyent/node/issues/8449\nfunction doesForEachActuallyWork() {\n\tvar ret = false;\n\n\t(new Set([true])).forEach(function (el) {\n\t\tret = el;\n\t});\n\n\treturn ret === true;\n}\n\nif ('Set' in __webpack_require__.g) {\n\tif (typeof Set.prototype.forEach === 'function' && doesForEachActuallyWork()) {\n\t\tmodule.exports = uniqSetWithForEach;\n\t} else {\n\t\tmodule.exports = uniqSet;\n\t}\n} else {\n\tmodule.exports = uniqNoSet;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXJyYXktdW5pcS9pbmRleC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLGdCQUFnQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQSxhQUFhLHFCQUFNO0FBQ25CO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdG9kby1saXN0Ly4vbm9kZV9tb2R1bGVzL2FycmF5LXVuaXEvaW5kZXguanM/NmI0NyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8vIHRoZXJlJ3MgMyBpbXBsZW1lbnRhdGlvbnMgd3JpdHRlbiBpbiBpbmNyZWFzaW5nIG9yZGVyIG9mIGVmZmljaWVuY3lcblxuLy8gMSAtIG5vIFNldCB0eXBlIGlzIGRlZmluZWRcbmZ1bmN0aW9uIHVuaXFOb1NldChhcnIpIHtcblx0dmFyIHJldCA9IFtdO1xuXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG5cdFx0aWYgKHJldC5pbmRleE9mKGFycltpXSkgPT09IC0xKSB7XG5cdFx0XHRyZXQucHVzaChhcnJbaV0pO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiByZXQ7XG59XG5cbi8vIDIgLSBhIHNpbXBsZSBTZXQgdHlwZSBpcyBkZWZpbmVkXG5mdW5jdGlvbiB1bmlxU2V0KGFycikge1xuXHR2YXIgc2VlbiA9IG5ldyBTZXQoKTtcblx0cmV0dXJuIGFyci5maWx0ZXIoZnVuY3Rpb24gKGVsKSB7XG5cdFx0aWYgKCFzZWVuLmhhcyhlbCkpIHtcblx0XHRcdHNlZW4uYWRkKGVsKTtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTtcblx0fSk7XG59XG5cbi8vIDMgLSBhIHN0YW5kYXJkIFNldCB0eXBlIGlzIGRlZmluZWQgYW5kIGl0IGhhcyBhIGZvckVhY2ggbWV0aG9kXG5mdW5jdGlvbiB1bmlxU2V0V2l0aEZvckVhY2goYXJyKSB7XG5cdHZhciByZXQgPSBbXTtcblxuXHQobmV3IFNldChhcnIpKS5mb3JFYWNoKGZ1bmN0aW9uIChlbCkge1xuXHRcdHJldC5wdXNoKGVsKTtcblx0fSk7XG5cblx0cmV0dXJuIHJldDtcbn1cblxuLy8gVjggY3VycmVudGx5IGhhcyBhIGJyb2tlbiBpbXBsZW1lbnRhdGlvblxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2pveWVudC9ub2RlL2lzc3Vlcy84NDQ5XG5mdW5jdGlvbiBkb2VzRm9yRWFjaEFjdHVhbGx5V29yaygpIHtcblx0dmFyIHJldCA9IGZhbHNlO1xuXG5cdChuZXcgU2V0KFt0cnVlXSkpLmZvckVhY2goZnVuY3Rpb24gKGVsKSB7XG5cdFx0cmV0ID0gZWw7XG5cdH0pO1xuXG5cdHJldHVybiByZXQgPT09IHRydWU7XG59XG5cbmlmICgnU2V0JyBpbiBnbG9iYWwpIHtcblx0aWYgKHR5cGVvZiBTZXQucHJvdG90eXBlLmZvckVhY2ggPT09ICdmdW5jdGlvbicgJiYgZG9lc0ZvckVhY2hBY3R1YWxseVdvcmsoKSkge1xuXHRcdG1vZHVsZS5leHBvcnRzID0gdW5pcVNldFdpdGhGb3JFYWNoO1xuXHR9IGVsc2Uge1xuXHRcdG1vZHVsZS5leHBvcnRzID0gdW5pcVNldDtcblx0fVxufSBlbHNlIHtcblx0bW9kdWxlLmV4cG9ydHMgPSB1bmlxTm9TZXQ7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/array-uniq/index.js\n");

/***/ }),

/***/ "./node_modules/async/dist/async.js":
/*!******************************************!*\
  !*** ./node_modules/async/dist/async.js ***!
  \******************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\n(function (global, factory) {\n   true ? factory(exports) :\n  0;\n}(this, (function (exports) { 'use strict';\n\nfunction slice(arrayLike, start) {\n    start = start|0;\n    var newLen = Math.max(arrayLike.length - start, 0);\n    var newArr = Array(newLen);\n    for(var idx = 0; idx < newLen; idx++)  {\n        newArr[idx] = arrayLike[start + idx];\n    }\n    return newArr;\n}\n\n/**\n * Creates a continuation function with some arguments already applied.\n *\n * Useful as a shorthand when combined with other control flow functions. Any\n * arguments passed to the returned function are added to the arguments\n * originally passed to apply.\n *\n * @name apply\n * @static\n * @memberOf module:Utils\n * @method\n * @category Util\n * @param {Function} fn - The function you want to eventually apply all\n * arguments to. Invokes with (arguments...).\n * @param {...*} arguments... - Any number of arguments to automatically apply\n * when the continuation is called.\n * @returns {Function} the partially-applied function\n * @example\n *\n * // using apply\n * async.parallel([\n *     async.apply(fs.writeFile, 'testfile1', 'test1'),\n *     async.apply(fs.writeFile, 'testfile2', 'test2')\n * ]);\n *\n *\n * // the same process without using apply\n * async.parallel([\n *     function(callback) {\n *         fs.writeFile('testfile1', 'test1', callback);\n *     },\n *     function(callback) {\n *         fs.writeFile('testfile2', 'test2', callback);\n *     }\n * ]);\n *\n * // It's possible to pass any number of additional arguments when calling the\n * // continuation:\n *\n * node> var fn = async.apply(sys.puts, 'one');\n * node> fn('two', 'three');\n * one\n * two\n * three\n */\nvar apply = function(fn/*, ...args*/) {\n    var args = slice(arguments, 1);\n    return function(/*callArgs*/) {\n        var callArgs = slice(arguments);\n        return fn.apply(null, args.concat(callArgs));\n    };\n};\n\nvar initialParams = function (fn) {\n    return function (/*...args, callback*/) {\n        var args = slice(arguments);\n        var callback = args.pop();\n        fn.call(this, args, callback);\n    };\n};\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return value != null && (type == 'object' || type == 'function');\n}\n\nvar hasSetImmediate = typeof setImmediate === 'function' && setImmediate;\nvar hasNextTick = typeof process === 'object' && typeof process.nextTick === 'function';\n\nfunction fallback(fn) {\n    setTimeout(fn, 0);\n}\n\nfunction wrap(defer) {\n    return function (fn/*, ...args*/) {\n        var args = slice(arguments, 1);\n        defer(function () {\n            fn.apply(null, args);\n        });\n    };\n}\n\nvar _defer;\n\nif (hasSetImmediate) {\n    _defer = setImmediate;\n} else if (hasNextTick) {\n    _defer = process.nextTick;\n} else {\n    _defer = fallback;\n}\n\nvar setImmediate$1 = wrap(_defer);\n\n/**\n * Take a sync function and make it async, passing its return value to a\n * callback. This is useful for plugging sync functions into a waterfall,\n * series, or other async functions. Any arguments passed to the generated\n * function will be passed to the wrapped function (except for the final\n * callback argument). Errors thrown will be passed to the callback.\n *\n * If the function passed to `asyncify` returns a Promise, that promises's\n * resolved/rejected state will be used to call the callback, rather than simply\n * the synchronous return value.\n *\n * This also means you can asyncify ES2017 `async` functions.\n *\n * @name asyncify\n * @static\n * @memberOf module:Utils\n * @method\n * @alias wrapSync\n * @category Util\n * @param {Function} func - The synchronous function, or Promise-returning\n * function to convert to an {@link AsyncFunction}.\n * @returns {AsyncFunction} An asynchronous wrapper of the `func`. To be\n * invoked with `(args..., callback)`.\n * @example\n *\n * // passing a regular synchronous function\n * async.waterfall([\n *     async.apply(fs.readFile, filename, \"utf8\"),\n *     async.asyncify(JSON.parse),\n *     function (data, next) {\n *         // data is the result of parsing the text.\n *         // If there was a parsing error, it would have been caught.\n *     }\n * ], callback);\n *\n * // passing a function returning a promise\n * async.waterfall([\n *     async.apply(fs.readFile, filename, \"utf8\"),\n *     async.asyncify(function (contents) {\n *         return db.model.create(contents);\n *     }),\n *     function (model, next) {\n *         // `model` is the instantiated model object.\n *         // If there was an error, this function would be skipped.\n *     }\n * ], callback);\n *\n * // es2017 example, though `asyncify` is not needed if your JS environment\n * // supports async functions out of the box\n * var q = async.queue(async.asyncify(async function(file) {\n *     var intermediateStep = await processFile(file);\n *     return await somePromise(intermediateStep)\n * }));\n *\n * q.push(files);\n */\nfunction asyncify(func) {\n    return initialParams(function (args, callback) {\n        var result;\n        try {\n            result = func.apply(this, args);\n        } catch (e) {\n            return callback(e);\n        }\n        // if result is Promise object\n        if (isObject(result) && typeof result.then === 'function') {\n            result.then(function(value) {\n                invokeCallback(callback, null, value);\n            }, function(err) {\n                invokeCallback(callback, err.message ? err : new Error(err));\n            });\n        } else {\n            callback(null, result);\n        }\n    });\n}\n\nfunction invokeCallback(callback, error, value) {\n    try {\n        callback(error, value);\n    } catch (e) {\n        setImmediate$1(rethrow, e);\n    }\n}\n\nfunction rethrow(error) {\n    throw error;\n}\n\nvar supportsSymbol = typeof Symbol === 'function';\n\nfunction isAsync(fn) {\n    return supportsSymbol && fn[Symbol.toStringTag] === 'AsyncFunction';\n}\n\nfunction wrapAsync(asyncFn) {\n    return isAsync(asyncFn) ? asyncify(asyncFn) : asyncFn;\n}\n\nfunction applyEach$1(eachfn) {\n    return function(fns/*, ...args*/) {\n        var args = slice(arguments, 1);\n        var go = initialParams(function(args, callback) {\n            var that = this;\n            return eachfn(fns, function (fn, cb) {\n                wrapAsync(fn).apply(that, args.concat(cb));\n            }, callback);\n        });\n        if (args.length) {\n            return go.apply(this, args);\n        }\n        else {\n            return go;\n        }\n    };\n}\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof __webpack_require__.g == 'object' && __webpack_require__.g && __webpack_require__.g.Object === Object && __webpack_require__.g;\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\n/** Built-in value references. */\nvar Symbol$1 = root.Symbol;\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/** Built-in value references. */\nvar symToStringTag$1 = Symbol$1 ? Symbol$1.toStringTag : undefined;\n\n/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */\nfunction getRawTag(value) {\n  var isOwn = hasOwnProperty.call(value, symToStringTag$1),\n      tag = value[symToStringTag$1];\n\n  try {\n    value[symToStringTag$1] = undefined;\n    var unmasked = true;\n  } catch (e) {}\n\n  var result = nativeObjectToString.call(value);\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag$1] = tag;\n    } else {\n      delete value[symToStringTag$1];\n    }\n  }\n  return result;\n}\n\n/** Used for built-in method references. */\nvar objectProto$1 = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString$1 = objectProto$1.toString;\n\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */\nfunction objectToString(value) {\n  return nativeObjectToString$1.call(value);\n}\n\n/** `Object#toString` result references. */\nvar nullTag = '[object Null]';\nvar undefinedTag = '[object Undefined]';\n\n/** Built-in value references. */\nvar symToStringTag = Symbol$1 ? Symbol$1.toStringTag : undefined;\n\n/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === undefined ? undefinedTag : nullTag;\n  }\n  return (symToStringTag && symToStringTag in Object(value))\n    ? getRawTag(value)\n    : objectToString(value);\n}\n\n/** `Object#toString` result references. */\nvar asyncTag = '[object AsyncFunction]';\nvar funcTag = '[object Function]';\nvar genTag = '[object GeneratorFunction]';\nvar proxyTag = '[object Proxy]';\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  if (!isObject(value)) {\n    return false;\n  }\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 9 which returns 'object' for typed arrays and other constructors.\n  var tag = baseGetTag(value);\n  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\n}\n\n/** Used as references for various `Number` constants. */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/**\n * Checks if `value` is a valid array-like length.\n *\n * **Note:** This method is loosely based on\n * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n * @example\n *\n * _.isLength(3);\n * // => true\n *\n * _.isLength(Number.MIN_VALUE);\n * // => false\n *\n * _.isLength(Infinity);\n * // => false\n *\n * _.isLength('3');\n * // => false\n */\nfunction isLength(value) {\n  return typeof value == 'number' &&\n    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n}\n\n/**\n * Checks if `value` is array-like. A value is considered array-like if it's\n * not a function and has a `value.length` that's an integer greater than or\n * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n * @example\n *\n * _.isArrayLike([1, 2, 3]);\n * // => true\n *\n * _.isArrayLike(document.body.children);\n * // => true\n *\n * _.isArrayLike('abc');\n * // => true\n *\n * _.isArrayLike(_.noop);\n * // => false\n */\nfunction isArrayLike(value) {\n  return value != null && isLength(value.length) && !isFunction(value);\n}\n\n// A temporary value used to identify if the loop should be broken.\n// See #1064, #1293\nvar breakLoop = {};\n\n/**\n * This method returns `undefined`.\n *\n * @static\n * @memberOf _\n * @since 2.3.0\n * @category Util\n * @example\n *\n * _.times(2, _.noop);\n * // => [undefined, undefined]\n */\nfunction noop() {\n  // No operation performed.\n}\n\nfunction once(fn) {\n    return function () {\n        if (fn === null) return;\n        var callFn = fn;\n        fn = null;\n        callFn.apply(this, arguments);\n    };\n}\n\nvar iteratorSymbol = typeof Symbol === 'function' && Symbol.iterator;\n\nvar getIterator = function (coll) {\n    return iteratorSymbol && coll[iteratorSymbol] && coll[iteratorSymbol]();\n};\n\n/**\n * The base implementation of `_.times` without support for iteratee shorthands\n * or max array length checks.\n *\n * @private\n * @param {number} n The number of times to invoke `iteratee`.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the array of results.\n */\nfunction baseTimes(n, iteratee) {\n  var index = -1,\n      result = Array(n);\n\n  while (++index < n) {\n    result[index] = iteratee(index);\n  }\n  return result;\n}\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return value != null && typeof value == 'object';\n}\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]';\n\n/**\n * The base implementation of `_.isArguments`.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n */\nfunction baseIsArguments(value) {\n  return isObjectLike(value) && baseGetTag(value) == argsTag;\n}\n\n/** Used for built-in method references. */\nvar objectProto$3 = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty$2 = objectProto$3.hasOwnProperty;\n\n/** Built-in value references. */\nvar propertyIsEnumerable = objectProto$3.propertyIsEnumerable;\n\n/**\n * Checks if `value` is likely an `arguments` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n *  else `false`.\n * @example\n *\n * _.isArguments(function() { return arguments; }());\n * // => true\n *\n * _.isArguments([1, 2, 3]);\n * // => false\n */\nvar isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {\n  return isObjectLike(value) && hasOwnProperty$2.call(value, 'callee') &&\n    !propertyIsEnumerable.call(value, 'callee');\n};\n\n/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\n/**\n * This method returns `false`.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {boolean} Returns `false`.\n * @example\n *\n * _.times(2, _.stubFalse);\n * // => [false, false]\n */\nfunction stubFalse() {\n  return false;\n}\n\n/** Detect free variable `exports`. */\nvar freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && \"object\" == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/** Built-in value references. */\nvar Buffer = moduleExports ? root.Buffer : undefined;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;\n\n/**\n * Checks if `value` is a buffer.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.\n * @example\n *\n * _.isBuffer(new Buffer(2));\n * // => true\n *\n * _.isBuffer(new Uint8Array(2));\n * // => false\n */\nvar isBuffer = nativeIsBuffer || stubFalse;\n\n/** Used as references for various `Number` constants. */\nvar MAX_SAFE_INTEGER$1 = 9007199254740991;\n\n/** Used to detect unsigned integer values. */\nvar reIsUint = /^(?:0|[1-9]\\d*)$/;\n\n/**\n * Checks if `value` is a valid array-like index.\n *\n * @private\n * @param {*} value The value to check.\n * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n */\nfunction isIndex(value, length) {\n  var type = typeof value;\n  length = length == null ? MAX_SAFE_INTEGER$1 : length;\n\n  return !!length &&\n    (type == 'number' ||\n      (type != 'symbol' && reIsUint.test(value))) &&\n        (value > -1 && value % 1 == 0 && value < length);\n}\n\n/** `Object#toString` result references. */\nvar argsTag$1 = '[object Arguments]';\nvar arrayTag = '[object Array]';\nvar boolTag = '[object Boolean]';\nvar dateTag = '[object Date]';\nvar errorTag = '[object Error]';\nvar funcTag$1 = '[object Function]';\nvar mapTag = '[object Map]';\nvar numberTag = '[object Number]';\nvar objectTag = '[object Object]';\nvar regexpTag = '[object RegExp]';\nvar setTag = '[object Set]';\nvar stringTag = '[object String]';\nvar weakMapTag = '[object WeakMap]';\n\nvar arrayBufferTag = '[object ArrayBuffer]';\nvar dataViewTag = '[object DataView]';\nvar float32Tag = '[object Float32Array]';\nvar float64Tag = '[object Float64Array]';\nvar int8Tag = '[object Int8Array]';\nvar int16Tag = '[object Int16Array]';\nvar int32Tag = '[object Int32Array]';\nvar uint8Tag = '[object Uint8Array]';\nvar uint8ClampedTag = '[object Uint8ClampedArray]';\nvar uint16Tag = '[object Uint16Array]';\nvar uint32Tag = '[object Uint32Array]';\n\n/** Used to identify `toStringTag` values of typed arrays. */\nvar typedArrayTags = {};\ntypedArrayTags[float32Tag] = typedArrayTags[float64Tag] =\ntypedArrayTags[int8Tag] = typedArrayTags[int16Tag] =\ntypedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =\ntypedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =\ntypedArrayTags[uint32Tag] = true;\ntypedArrayTags[argsTag$1] = typedArrayTags[arrayTag] =\ntypedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =\ntypedArrayTags[dataViewTag] = typedArrayTags[dateTag] =\ntypedArrayTags[errorTag] = typedArrayTags[funcTag$1] =\ntypedArrayTags[mapTag] = typedArrayTags[numberTag] =\ntypedArrayTags[objectTag] = typedArrayTags[regexpTag] =\ntypedArrayTags[setTag] = typedArrayTags[stringTag] =\ntypedArrayTags[weakMapTag] = false;\n\n/**\n * The base implementation of `_.isTypedArray` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n */\nfunction baseIsTypedArray(value) {\n  return isObjectLike(value) &&\n    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];\n}\n\n/**\n * The base implementation of `_.unary` without support for storing metadata.\n *\n * @private\n * @param {Function} func The function to cap arguments for.\n * @returns {Function} Returns the new capped function.\n */\nfunction baseUnary(func) {\n  return function(value) {\n    return func(value);\n  };\n}\n\n/** Detect free variable `exports`. */\nvar freeExports$1 = typeof exports == 'object' && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule$1 = freeExports$1 && \"object\" == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;\n\n/** Detect free variable `process` from Node.js. */\nvar freeProcess = moduleExports$1 && freeGlobal.process;\n\n/** Used to access faster Node.js helpers. */\nvar nodeUtil = (function() {\n  try {\n    // Use `util.types` for Node.js 10+.\n    var types = freeModule$1 && freeModule$1.require && freeModule$1.require('util').types;\n\n    if (types) {\n      return types;\n    }\n\n    // Legacy `process.binding('util')` for Node.js < 10.\n    return freeProcess && freeProcess.binding && freeProcess.binding('util');\n  } catch (e) {}\n}());\n\n/* Node.js helper references. */\nvar nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;\n\n/**\n * Checks if `value` is classified as a typed array.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n * @example\n *\n * _.isTypedArray(new Uint8Array);\n * // => true\n *\n * _.isTypedArray([]);\n * // => false\n */\nvar isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;\n\n/** Used for built-in method references. */\nvar objectProto$2 = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty$1 = objectProto$2.hasOwnProperty;\n\n/**\n * Creates an array of the enumerable property names of the array-like `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @param {boolean} inherited Specify returning inherited property names.\n * @returns {Array} Returns the array of property names.\n */\nfunction arrayLikeKeys(value, inherited) {\n  var isArr = isArray(value),\n      isArg = !isArr && isArguments(value),\n      isBuff = !isArr && !isArg && isBuffer(value),\n      isType = !isArr && !isArg && !isBuff && isTypedArray(value),\n      skipIndexes = isArr || isArg || isBuff || isType,\n      result = skipIndexes ? baseTimes(value.length, String) : [],\n      length = result.length;\n\n  for (var key in value) {\n    if ((inherited || hasOwnProperty$1.call(value, key)) &&\n        !(skipIndexes && (\n           // Safari 9 has enumerable `arguments.length` in strict mode.\n           key == 'length' ||\n           // Node.js 0.10 has enumerable non-index properties on buffers.\n           (isBuff && (key == 'offset' || key == 'parent')) ||\n           // PhantomJS 2 has enumerable non-index properties on typed arrays.\n           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||\n           // Skip index properties.\n           isIndex(key, length)\n        ))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/** Used for built-in method references. */\nvar objectProto$5 = Object.prototype;\n\n/**\n * Checks if `value` is likely a prototype object.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\n */\nfunction isPrototype(value) {\n  var Ctor = value && value.constructor,\n      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto$5;\n\n  return value === proto;\n}\n\n/**\n * Creates a unary function that invokes `func` with its argument transformed.\n *\n * @private\n * @param {Function} func The function to wrap.\n * @param {Function} transform The argument transform.\n * @returns {Function} Returns the new function.\n */\nfunction overArg(func, transform) {\n  return function(arg) {\n    return func(transform(arg));\n  };\n}\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeKeys = overArg(Object.keys, Object);\n\n/** Used for built-in method references. */\nvar objectProto$4 = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty$3 = objectProto$4.hasOwnProperty;\n\n/**\n * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction baseKeys(object) {\n  if (!isPrototype(object)) {\n    return nativeKeys(object);\n  }\n  var result = [];\n  for (var key in Object(object)) {\n    if (hasOwnProperty$3.call(object, key) && key != 'constructor') {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * Creates an array of the own enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects. See the\n * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n * for more details.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keys(new Foo);\n * // => ['a', 'b'] (iteration order is not guaranteed)\n *\n * _.keys('hi');\n * // => ['0', '1']\n */\nfunction keys(object) {\n  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);\n}\n\nfunction createArrayIterator(coll) {\n    var i = -1;\n    var len = coll.length;\n    return function next() {\n        return ++i < len ? {value: coll[i], key: i} : null;\n    }\n}\n\nfunction createES2015Iterator(iterator) {\n    var i = -1;\n    return function next() {\n        var item = iterator.next();\n        if (item.done)\n            return null;\n        i++;\n        return {value: item.value, key: i};\n    }\n}\n\nfunction createObjectIterator(obj) {\n    var okeys = keys(obj);\n    var i = -1;\n    var len = okeys.length;\n    return function next() {\n        var key = okeys[++i];\n        if (key === '__proto__') {\n            return next();\n        }\n        return i < len ? {value: obj[key], key: key} : null;\n    };\n}\n\nfunction iterator(coll) {\n    if (isArrayLike(coll)) {\n        return createArrayIterator(coll);\n    }\n\n    var iterator = getIterator(coll);\n    return iterator ? createES2015Iterator(iterator) : createObjectIterator(coll);\n}\n\nfunction onlyOnce(fn) {\n    return function() {\n        if (fn === null) throw new Error(\"Callback was already called.\");\n        var callFn = fn;\n        fn = null;\n        callFn.apply(this, arguments);\n    };\n}\n\nfunction _eachOfLimit(limit) {\n    return function (obj, iteratee, callback) {\n        callback = once(callback || noop);\n        if (limit <= 0 || !obj) {\n            return callback(null);\n        }\n        var nextElem = iterator(obj);\n        var done = false;\n        var running = 0;\n        var looping = false;\n\n        function iterateeCallback(err, value) {\n            running -= 1;\n            if (err) {\n                done = true;\n                callback(err);\n            }\n            else if (value === breakLoop || (done && running <= 0)) {\n                done = true;\n                return callback(null);\n            }\n            else if (!looping) {\n                replenish();\n            }\n        }\n\n        function replenish () {\n            looping = true;\n            while (running < limit && !done) {\n                var elem = nextElem();\n                if (elem === null) {\n                    done = true;\n                    if (running <= 0) {\n                        callback(null);\n                    }\n                    return;\n                }\n                running += 1;\n                iteratee(elem.value, elem.key, onlyOnce(iterateeCallback));\n            }\n            looping = false;\n        }\n\n        replenish();\n    };\n}\n\n/**\n * The same as [`eachOf`]{@link module:Collections.eachOf} but runs a maximum of `limit` async operations at a\n * time.\n *\n * @name eachOfLimit\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.eachOf]{@link module:Collections.eachOf}\n * @alias forEachOfLimit\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {AsyncFunction} iteratee - An async function to apply to each\n * item in `coll`. The `key` is the item's key, or index in the case of an\n * array.\n * Invoked with (item, key, callback).\n * @param {Function} [callback] - A callback which is called when all\n * `iteratee` functions have finished, or an error occurs. Invoked with (err).\n */\nfunction eachOfLimit(coll, limit, iteratee, callback) {\n    _eachOfLimit(limit)(coll, wrapAsync(iteratee), callback);\n}\n\nfunction doLimit(fn, limit) {\n    return function (iterable, iteratee, callback) {\n        return fn(iterable, limit, iteratee, callback);\n    };\n}\n\n// eachOf implementation optimized for array-likes\nfunction eachOfArrayLike(coll, iteratee, callback) {\n    callback = once(callback || noop);\n    var index = 0,\n        completed = 0,\n        length = coll.length;\n    if (length === 0) {\n        callback(null);\n    }\n\n    function iteratorCallback(err, value) {\n        if (err) {\n            callback(err);\n        } else if ((++completed === length) || value === breakLoop) {\n            callback(null);\n        }\n    }\n\n    for (; index < length; index++) {\n        iteratee(coll[index], index, onlyOnce(iteratorCallback));\n    }\n}\n\n// a generic version of eachOf which can handle array, object, and iterator cases.\nvar eachOfGeneric = doLimit(eachOfLimit, Infinity);\n\n/**\n * Like [`each`]{@link module:Collections.each}, except that it passes the key (or index) as the second argument\n * to the iteratee.\n *\n * @name eachOf\n * @static\n * @memberOf module:Collections\n * @method\n * @alias forEachOf\n * @category Collection\n * @see [async.each]{@link module:Collections.each}\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - A function to apply to each\n * item in `coll`.\n * The `key` is the item's key, or index in the case of an array.\n * Invoked with (item, key, callback).\n * @param {Function} [callback] - A callback which is called when all\n * `iteratee` functions have finished, or an error occurs. Invoked with (err).\n * @example\n *\n * var obj = {dev: \"/dev.json\", test: \"/test.json\", prod: \"/prod.json\"};\n * var configs = {};\n *\n * async.forEachOf(obj, function (value, key, callback) {\n *     fs.readFile(__dirname + value, \"utf8\", function (err, data) {\n *         if (err) return callback(err);\n *         try {\n *             configs[key] = JSON.parse(data);\n *         } catch (e) {\n *             return callback(e);\n *         }\n *         callback();\n *     });\n * }, function (err) {\n *     if (err) console.error(err.message);\n *     // configs is now a map of JSON data\n *     doSomethingWith(configs);\n * });\n */\nvar eachOf = function(coll, iteratee, callback) {\n    var eachOfImplementation = isArrayLike(coll) ? eachOfArrayLike : eachOfGeneric;\n    eachOfImplementation(coll, wrapAsync(iteratee), callback);\n};\n\nfunction doParallel(fn) {\n    return function (obj, iteratee, callback) {\n        return fn(eachOf, obj, wrapAsync(iteratee), callback);\n    };\n}\n\nfunction _asyncMap(eachfn, arr, iteratee, callback) {\n    callback = callback || noop;\n    arr = arr || [];\n    var results = [];\n    var counter = 0;\n    var _iteratee = wrapAsync(iteratee);\n\n    eachfn(arr, function (value, _, callback) {\n        var index = counter++;\n        _iteratee(value, function (err, v) {\n            results[index] = v;\n            callback(err);\n        });\n    }, function (err) {\n        callback(err, results);\n    });\n}\n\n/**\n * Produces a new collection of values by mapping each value in `coll` through\n * the `iteratee` function. The `iteratee` is called with an item from `coll`\n * and a callback for when it has finished processing. Each of these callback\n * takes 2 arguments: an `error`, and the transformed item from `coll`. If\n * `iteratee` passes an error to its callback, the main `callback` (for the\n * `map` function) is immediately called with the error.\n *\n * Note, that since this function applies the `iteratee` to each item in\n * parallel, there is no guarantee that the `iteratee` functions will complete\n * in order. However, the results array will be in the same order as the\n * original `coll`.\n *\n * If `map` is passed an Object, the results will be an Array.  The results\n * will roughly be in the order of the original Objects' keys (but this can\n * vary across JavaScript engines).\n *\n * @name map\n * @static\n * @memberOf module:Collections\n * @method\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - An async function to apply to each item in\n * `coll`.\n * The iteratee should complete with the transformed item.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called when all `iteratee`\n * functions have finished, or an error occurs. Results is an Array of the\n * transformed items from the `coll`. Invoked with (err, results).\n * @example\n *\n * async.map(['file1','file2','file3'], fs.stat, function(err, results) {\n *     // results is now an array of stats for each file\n * });\n */\nvar map = doParallel(_asyncMap);\n\n/**\n * Applies the provided arguments to each function in the array, calling\n * `callback` after all functions have completed. If you only provide the first\n * argument, `fns`, then it will return a function which lets you pass in the\n * arguments as if it were a single function call. If more arguments are\n * provided, `callback` is required while `args` is still optional.\n *\n * @name applyEach\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @param {Array|Iterable|Object} fns - A collection of {@link AsyncFunction}s\n * to all call with the same arguments\n * @param {...*} [args] - any number of separate arguments to pass to the\n * function.\n * @param {Function} [callback] - the final argument should be the callback,\n * called when all functions have completed processing.\n * @returns {Function} - If only the first argument, `fns`, is provided, it will\n * return a function which lets you pass in the arguments as if it were a single\n * function call. The signature is `(..args, callback)`. If invoked with any\n * arguments, `callback` is required.\n * @example\n *\n * async.applyEach([enableSearch, updateSchema], 'bucket', callback);\n *\n * // partial application example:\n * async.each(\n *     buckets,\n *     async.applyEach([enableSearch, updateSchema]),\n *     callback\n * );\n */\nvar applyEach = applyEach$1(map);\n\nfunction doParallelLimit(fn) {\n    return function (obj, limit, iteratee, callback) {\n        return fn(_eachOfLimit(limit), obj, wrapAsync(iteratee), callback);\n    };\n}\n\n/**\n * The same as [`map`]{@link module:Collections.map} but runs a maximum of `limit` async operations at a time.\n *\n * @name mapLimit\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.map]{@link module:Collections.map}\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {AsyncFunction} iteratee - An async function to apply to each item in\n * `coll`.\n * The iteratee should complete with the transformed item.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called when all `iteratee`\n * functions have finished, or an error occurs. Results is an array of the\n * transformed items from the `coll`. Invoked with (err, results).\n */\nvar mapLimit = doParallelLimit(_asyncMap);\n\n/**\n * The same as [`map`]{@link module:Collections.map} but runs only a single async operation at a time.\n *\n * @name mapSeries\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.map]{@link module:Collections.map}\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - An async function to apply to each item in\n * `coll`.\n * The iteratee should complete with the transformed item.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called when all `iteratee`\n * functions have finished, or an error occurs. Results is an array of the\n * transformed items from the `coll`. Invoked with (err, results).\n */\nvar mapSeries = doLimit(mapLimit, 1);\n\n/**\n * The same as [`applyEach`]{@link module:ControlFlow.applyEach} but runs only a single async operation at a time.\n *\n * @name applyEachSeries\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.applyEach]{@link module:ControlFlow.applyEach}\n * @category Control Flow\n * @param {Array|Iterable|Object} fns - A collection of {@link AsyncFunction}s to all\n * call with the same arguments\n * @param {...*} [args] - any number of separate arguments to pass to the\n * function.\n * @param {Function} [callback] - the final argument should be the callback,\n * called when all functions have completed processing.\n * @returns {Function} - If only the first argument is provided, it will return\n * a function which lets you pass in the arguments as if it were a single\n * function call.\n */\nvar applyEachSeries = applyEach$1(mapSeries);\n\n/**\n * A specialized version of `_.forEach` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns `array`.\n */\nfunction arrayEach(array, iteratee) {\n  var index = -1,\n      length = array == null ? 0 : array.length;\n\n  while (++index < length) {\n    if (iteratee(array[index], index, array) === false) {\n      break;\n    }\n  }\n  return array;\n}\n\n/**\n * Creates a base function for methods like `_.forIn` and `_.forOwn`.\n *\n * @private\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {Function} Returns the new base function.\n */\nfunction createBaseFor(fromRight) {\n  return function(object, iteratee, keysFunc) {\n    var index = -1,\n        iterable = Object(object),\n        props = keysFunc(object),\n        length = props.length;\n\n    while (length--) {\n      var key = props[fromRight ? length : ++index];\n      if (iteratee(iterable[key], key, iterable) === false) {\n        break;\n      }\n    }\n    return object;\n  };\n}\n\n/**\n * The base implementation of `baseForOwn` which iterates over `object`\n * properties returned by `keysFunc` and invokes `iteratee` for each property.\n * Iteratee functions may exit iteration early by explicitly returning `false`.\n *\n * @private\n * @param {Object} object The object to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @param {Function} keysFunc The function to get the keys of `object`.\n * @returns {Object} Returns `object`.\n */\nvar baseFor = createBaseFor();\n\n/**\n * The base implementation of `_.forOwn` without support for iteratee shorthands.\n *\n * @private\n * @param {Object} object The object to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Object} Returns `object`.\n */\nfunction baseForOwn(object, iteratee) {\n  return object && baseFor(object, iteratee, keys);\n}\n\n/**\n * The base implementation of `_.findIndex` and `_.findLastIndex` without\n * support for iteratee shorthands.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {Function} predicate The function invoked per iteration.\n * @param {number} fromIndex The index to search from.\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction baseFindIndex(array, predicate, fromIndex, fromRight) {\n  var length = array.length,\n      index = fromIndex + (fromRight ? 1 : -1);\n\n  while ((fromRight ? index-- : ++index < length)) {\n    if (predicate(array[index], index, array)) {\n      return index;\n    }\n  }\n  return -1;\n}\n\n/**\n * The base implementation of `_.isNaN` without support for number objects.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.\n */\nfunction baseIsNaN(value) {\n  return value !== value;\n}\n\n/**\n * A specialized version of `_.indexOf` which performs strict equality\n * comparisons of values, i.e. `===`.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} value The value to search for.\n * @param {number} fromIndex The index to search from.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction strictIndexOf(array, value, fromIndex) {\n  var index = fromIndex - 1,\n      length = array.length;\n\n  while (++index < length) {\n    if (array[index] === value) {\n      return index;\n    }\n  }\n  return -1;\n}\n\n/**\n * The base implementation of `_.indexOf` without `fromIndex` bounds checks.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} value The value to search for.\n * @param {number} fromIndex The index to search from.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction baseIndexOf(array, value, fromIndex) {\n  return value === value\n    ? strictIndexOf(array, value, fromIndex)\n    : baseFindIndex(array, baseIsNaN, fromIndex);\n}\n\n/**\n * Determines the best order for running the {@link AsyncFunction}s in `tasks`, based on\n * their requirements. Each function can optionally depend on other functions\n * being completed first, and each function is run as soon as its requirements\n * are satisfied.\n *\n * If any of the {@link AsyncFunction}s pass an error to their callback, the `auto` sequence\n * will stop. Further tasks will not execute (so any other functions depending\n * on it will not run), and the main `callback` is immediately called with the\n * error.\n *\n * {@link AsyncFunction}s also receive an object containing the results of functions which\n * have completed so far as the first argument, if they have dependencies. If a\n * task function has no dependencies, it will only be passed a callback.\n *\n * @name auto\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @param {Object} tasks - An object. Each of its properties is either a\n * function or an array of requirements, with the {@link AsyncFunction} itself the last item\n * in the array. The object's key of a property serves as the name of the task\n * defined by that property, i.e. can be used when specifying requirements for\n * other tasks. The function receives one or two arguments:\n * * a `results` object, containing the results of the previously executed\n *   functions, only passed if the task has any dependencies,\n * * a `callback(err, result)` function, which must be called when finished,\n *   passing an `error` (which can be `null`) and the result of the function's\n *   execution.\n * @param {number} [concurrency=Infinity] - An optional `integer` for\n * determining the maximum number of tasks that can be run in parallel. By\n * default, as many as possible.\n * @param {Function} [callback] - An optional callback which is called when all\n * the tasks have been completed. It receives the `err` argument if any `tasks`\n * pass an error to their callback. Results are always returned; however, if an\n * error occurs, no further `tasks` will be performed, and the results object\n * will only contain partial results. Invoked with (err, results).\n * @returns undefined\n * @example\n *\n * async.auto({\n *     // this function will just be passed a callback\n *     readData: async.apply(fs.readFile, 'data.txt', 'utf-8'),\n *     showData: ['readData', function(results, cb) {\n *         // results.readData is the file's contents\n *         // ...\n *     }]\n * }, callback);\n *\n * async.auto({\n *     get_data: function(callback) {\n *         console.log('in get_data');\n *         // async code to get some data\n *         callback(null, 'data', 'converted to array');\n *     },\n *     make_folder: function(callback) {\n *         console.log('in make_folder');\n *         // async code to create a directory to store a file in\n *         // this is run at the same time as getting the data\n *         callback(null, 'folder');\n *     },\n *     write_file: ['get_data', 'make_folder', function(results, callback) {\n *         console.log('in write_file', JSON.stringify(results));\n *         // once there is some data and the directory exists,\n *         // write the data to a file in the directory\n *         callback(null, 'filename');\n *     }],\n *     email_link: ['write_file', function(results, callback) {\n *         console.log('in email_link', JSON.stringify(results));\n *         // once the file is written let's email a link to it...\n *         // results.write_file contains the filename returned by write_file.\n *         callback(null, {'file':results.write_file, 'email':'user@example.com'});\n *     }]\n * }, function(err, results) {\n *     console.log('err = ', err);\n *     console.log('results = ', results);\n * });\n */\nvar auto = function (tasks, concurrency, callback) {\n    if (typeof concurrency === 'function') {\n        // concurrency is optional, shift the args.\n        callback = concurrency;\n        concurrency = null;\n    }\n    callback = once(callback || noop);\n    var keys$$1 = keys(tasks);\n    var numTasks = keys$$1.length;\n    if (!numTasks) {\n        return callback(null);\n    }\n    if (!concurrency) {\n        concurrency = numTasks;\n    }\n\n    var results = {};\n    var runningTasks = 0;\n    var hasError = false;\n\n    var listeners = Object.create(null);\n\n    var readyTasks = [];\n\n    // for cycle detection:\n    var readyToCheck = []; // tasks that have been identified as reachable\n    // without the possibility of returning to an ancestor task\n    var uncheckedDependencies = {};\n\n    baseForOwn(tasks, function (task, key) {\n        if (!isArray(task)) {\n            // no dependencies\n            enqueueTask(key, [task]);\n            readyToCheck.push(key);\n            return;\n        }\n\n        var dependencies = task.slice(0, task.length - 1);\n        var remainingDependencies = dependencies.length;\n        if (remainingDependencies === 0) {\n            enqueueTask(key, task);\n            readyToCheck.push(key);\n            return;\n        }\n        uncheckedDependencies[key] = remainingDependencies;\n\n        arrayEach(dependencies, function (dependencyName) {\n            if (!tasks[dependencyName]) {\n                throw new Error('async.auto task `' + key +\n                    '` has a non-existent dependency `' +\n                    dependencyName + '` in ' +\n                    dependencies.join(', '));\n            }\n            addListener(dependencyName, function () {\n                remainingDependencies--;\n                if (remainingDependencies === 0) {\n                    enqueueTask(key, task);\n                }\n            });\n        });\n    });\n\n    checkForDeadlocks();\n    processQueue();\n\n    function enqueueTask(key, task) {\n        readyTasks.push(function () {\n            runTask(key, task);\n        });\n    }\n\n    function processQueue() {\n        if (readyTasks.length === 0 && runningTasks === 0) {\n            return callback(null, results);\n        }\n        while(readyTasks.length && runningTasks < concurrency) {\n            var run = readyTasks.shift();\n            run();\n        }\n\n    }\n\n    function addListener(taskName, fn) {\n        var taskListeners = listeners[taskName];\n        if (!taskListeners) {\n            taskListeners = listeners[taskName] = [];\n        }\n\n        taskListeners.push(fn);\n    }\n\n    function taskComplete(taskName) {\n        var taskListeners = listeners[taskName] || [];\n        arrayEach(taskListeners, function (fn) {\n            fn();\n        });\n        processQueue();\n    }\n\n\n    function runTask(key, task) {\n        if (hasError) return;\n\n        var taskCallback = onlyOnce(function(err, result) {\n            runningTasks--;\n            if (arguments.length > 2) {\n                result = slice(arguments, 1);\n            }\n            if (err) {\n                var safeResults = {};\n                baseForOwn(results, function(val, rkey) {\n                    safeResults[rkey] = val;\n                });\n                safeResults[key] = result;\n                hasError = true;\n                listeners = Object.create(null);\n\n                callback(err, safeResults);\n            } else {\n                results[key] = result;\n                taskComplete(key);\n            }\n        });\n\n        runningTasks++;\n        var taskFn = wrapAsync(task[task.length - 1]);\n        if (task.length > 1) {\n            taskFn(results, taskCallback);\n        } else {\n            taskFn(taskCallback);\n        }\n    }\n\n    function checkForDeadlocks() {\n        // Kahn's algorithm\n        // https://en.wikipedia.org/wiki/Topological_sorting#Kahn.27s_algorithm\n        // http://connalle.blogspot.com/2013/10/topological-sortingkahn-algorithm.html\n        var currentTask;\n        var counter = 0;\n        while (readyToCheck.length) {\n            currentTask = readyToCheck.pop();\n            counter++;\n            arrayEach(getDependents(currentTask), function (dependent) {\n                if (--uncheckedDependencies[dependent] === 0) {\n                    readyToCheck.push(dependent);\n                }\n            });\n        }\n\n        if (counter !== numTasks) {\n            throw new Error(\n                'async.auto cannot execute tasks due to a recursive dependency'\n            );\n        }\n    }\n\n    function getDependents(taskName) {\n        var result = [];\n        baseForOwn(tasks, function (task, key) {\n            if (isArray(task) && baseIndexOf(task, taskName, 0) >= 0) {\n                result.push(key);\n            }\n        });\n        return result;\n    }\n};\n\n/**\n * A specialized version of `_.map` for arrays without support for iteratee\n * shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the new mapped array.\n */\nfunction arrayMap(array, iteratee) {\n  var index = -1,\n      length = array == null ? 0 : array.length,\n      result = Array(length);\n\n  while (++index < length) {\n    result[index] = iteratee(array[index], index, array);\n  }\n  return result;\n}\n\n/** `Object#toString` result references. */\nvar symbolTag = '[object Symbol]';\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && baseGetTag(value) == symbolTag);\n}\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0;\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol$1 ? Symbol$1.prototype : undefined;\nvar symbolToString = symbolProto ? symbolProto.toString : undefined;\n\n/**\n * The base implementation of `_.toString` which doesn't convert nullish\n * values to empty strings.\n *\n * @private\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n */\nfunction baseToString(value) {\n  // Exit early for strings to avoid a performance hit in some environments.\n  if (typeof value == 'string') {\n    return value;\n  }\n  if (isArray(value)) {\n    // Recursively convert values (susceptible to call stack limits).\n    return arrayMap(value, baseToString) + '';\n  }\n  if (isSymbol(value)) {\n    return symbolToString ? symbolToString.call(value) : '';\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\n/**\n * The base implementation of `_.slice` without an iteratee call guard.\n *\n * @private\n * @param {Array} array The array to slice.\n * @param {number} [start=0] The start position.\n * @param {number} [end=array.length] The end position.\n * @returns {Array} Returns the slice of `array`.\n */\nfunction baseSlice(array, start, end) {\n  var index = -1,\n      length = array.length;\n\n  if (start < 0) {\n    start = -start > length ? 0 : (length + start);\n  }\n  end = end > length ? length : end;\n  if (end < 0) {\n    end += length;\n  }\n  length = start > end ? 0 : ((end - start) >>> 0);\n  start >>>= 0;\n\n  var result = Array(length);\n  while (++index < length) {\n    result[index] = array[index + start];\n  }\n  return result;\n}\n\n/**\n * Casts `array` to a slice if it's needed.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {number} start The start position.\n * @param {number} [end=array.length] The end position.\n * @returns {Array} Returns the cast slice.\n */\nfunction castSlice(array, start, end) {\n  var length = array.length;\n  end = end === undefined ? length : end;\n  return (!start && end >= length) ? array : baseSlice(array, start, end);\n}\n\n/**\n * Used by `_.trim` and `_.trimEnd` to get the index of the last string symbol\n * that is not found in the character symbols.\n *\n * @private\n * @param {Array} strSymbols The string symbols to inspect.\n * @param {Array} chrSymbols The character symbols to find.\n * @returns {number} Returns the index of the last unmatched string symbol.\n */\nfunction charsEndIndex(strSymbols, chrSymbols) {\n  var index = strSymbols.length;\n\n  while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}\n  return index;\n}\n\n/**\n * Used by `_.trim` and `_.trimStart` to get the index of the first string symbol\n * that is not found in the character symbols.\n *\n * @private\n * @param {Array} strSymbols The string symbols to inspect.\n * @param {Array} chrSymbols The character symbols to find.\n * @returns {number} Returns the index of the first unmatched string symbol.\n */\nfunction charsStartIndex(strSymbols, chrSymbols) {\n  var index = -1,\n      length = strSymbols.length;\n\n  while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}\n  return index;\n}\n\n/**\n * Converts an ASCII `string` to an array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the converted array.\n */\nfunction asciiToArray(string) {\n  return string.split('');\n}\n\n/** Used to compose unicode character classes. */\nvar rsAstralRange = '\\\\ud800-\\\\udfff';\nvar rsComboMarksRange = '\\\\u0300-\\\\u036f';\nvar reComboHalfMarksRange = '\\\\ufe20-\\\\ufe2f';\nvar rsComboSymbolsRange = '\\\\u20d0-\\\\u20ff';\nvar rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;\nvar rsVarRange = '\\\\ufe0e\\\\ufe0f';\n\n/** Used to compose unicode capture groups. */\nvar rsZWJ = '\\\\u200d';\n\n/** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */\nvar reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange  + rsComboRange + rsVarRange + ']');\n\n/**\n * Checks if `string` contains Unicode symbols.\n *\n * @private\n * @param {string} string The string to inspect.\n * @returns {boolean} Returns `true` if a symbol is found, else `false`.\n */\nfunction hasUnicode(string) {\n  return reHasUnicode.test(string);\n}\n\n/** Used to compose unicode character classes. */\nvar rsAstralRange$1 = '\\\\ud800-\\\\udfff';\nvar rsComboMarksRange$1 = '\\\\u0300-\\\\u036f';\nvar reComboHalfMarksRange$1 = '\\\\ufe20-\\\\ufe2f';\nvar rsComboSymbolsRange$1 = '\\\\u20d0-\\\\u20ff';\nvar rsComboRange$1 = rsComboMarksRange$1 + reComboHalfMarksRange$1 + rsComboSymbolsRange$1;\nvar rsVarRange$1 = '\\\\ufe0e\\\\ufe0f';\n\n/** Used to compose unicode capture groups. */\nvar rsAstral = '[' + rsAstralRange$1 + ']';\nvar rsCombo = '[' + rsComboRange$1 + ']';\nvar rsFitz = '\\\\ud83c[\\\\udffb-\\\\udfff]';\nvar rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')';\nvar rsNonAstral = '[^' + rsAstralRange$1 + ']';\nvar rsRegional = '(?:\\\\ud83c[\\\\udde6-\\\\uddff]){2}';\nvar rsSurrPair = '[\\\\ud800-\\\\udbff][\\\\udc00-\\\\udfff]';\nvar rsZWJ$1 = '\\\\u200d';\n\n/** Used to compose unicode regexes. */\nvar reOptMod = rsModifier + '?';\nvar rsOptVar = '[' + rsVarRange$1 + ']?';\nvar rsOptJoin = '(?:' + rsZWJ$1 + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*';\nvar rsSeq = rsOptVar + reOptMod + rsOptJoin;\nvar rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';\n\n/** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */\nvar reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');\n\n/**\n * Converts a Unicode `string` to an array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the converted array.\n */\nfunction unicodeToArray(string) {\n  return string.match(reUnicode) || [];\n}\n\n/**\n * Converts `string` to an array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the converted array.\n */\nfunction stringToArray(string) {\n  return hasUnicode(string)\n    ? unicodeToArray(string)\n    : asciiToArray(string);\n}\n\n/**\n * Converts `value` to a string. An empty string is returned for `null`\n * and `undefined` values. The sign of `-0` is preserved.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n * @example\n *\n * _.toString(null);\n * // => ''\n *\n * _.toString(-0);\n * // => '-0'\n *\n * _.toString([1, 2, 3]);\n * // => '1,2,3'\n */\nfunction toString(value) {\n  return value == null ? '' : baseToString(value);\n}\n\n/** Used to match leading and trailing whitespace. */\nvar reTrim = /^\\s+|\\s+$/g;\n\n/**\n * Removes leading and trailing whitespace or specified characters from `string`.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category String\n * @param {string} [string=''] The string to trim.\n * @param {string} [chars=whitespace] The characters to trim.\n * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n * @returns {string} Returns the trimmed string.\n * @example\n *\n * _.trim('  abc  ');\n * // => 'abc'\n *\n * _.trim('-_-abc-_-', '_-');\n * // => 'abc'\n *\n * _.map(['  foo  ', '  bar  '], _.trim);\n * // => ['foo', 'bar']\n */\nfunction trim(string, chars, guard) {\n  string = toString(string);\n  if (string && (guard || chars === undefined)) {\n    return string.replace(reTrim, '');\n  }\n  if (!string || !(chars = baseToString(chars))) {\n    return string;\n  }\n  var strSymbols = stringToArray(string),\n      chrSymbols = stringToArray(chars),\n      start = charsStartIndex(strSymbols, chrSymbols),\n      end = charsEndIndex(strSymbols, chrSymbols) + 1;\n\n  return castSlice(strSymbols, start, end).join('');\n}\n\nvar FN_ARGS = /^(?:async\\s+)?(function)?\\s*[^\\(]*\\(\\s*([^\\)]*)\\)/m;\nvar FN_ARG_SPLIT = /,/;\nvar FN_ARG = /(=.+)?(\\s*)$/;\nvar STRIP_COMMENTS = /((\\/\\/.*$)|(\\/\\*[\\s\\S]*?\\*\\/))/mg;\n\nfunction parseParams(func) {\n    func = func.toString().replace(STRIP_COMMENTS, '');\n    func = func.match(FN_ARGS)[2].replace(' ', '');\n    func = func ? func.split(FN_ARG_SPLIT) : [];\n    func = func.map(function (arg){\n        return trim(arg.replace(FN_ARG, ''));\n    });\n    return func;\n}\n\n/**\n * A dependency-injected version of the [async.auto]{@link module:ControlFlow.auto} function. Dependent\n * tasks are specified as parameters to the function, after the usual callback\n * parameter, with the parameter names matching the names of the tasks it\n * depends on. This can provide even more readable task graphs which can be\n * easier to maintain.\n *\n * If a final callback is specified, the task results are similarly injected,\n * specified as named parameters after the initial error parameter.\n *\n * The autoInject function is purely syntactic sugar and its semantics are\n * otherwise equivalent to [async.auto]{@link module:ControlFlow.auto}.\n *\n * @name autoInject\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.auto]{@link module:ControlFlow.auto}\n * @category Control Flow\n * @param {Object} tasks - An object, each of whose properties is an {@link AsyncFunction} of\n * the form 'func([dependencies...], callback). The object's key of a property\n * serves as the name of the task defined by that property, i.e. can be used\n * when specifying requirements for other tasks.\n * * The `callback` parameter is a `callback(err, result)` which must be called\n *   when finished, passing an `error` (which can be `null`) and the result of\n *   the function's execution. The remaining parameters name other tasks on\n *   which the task is dependent, and the results from those tasks are the\n *   arguments of those parameters.\n * @param {Function} [callback] - An optional callback which is called when all\n * the tasks have been completed. It receives the `err` argument if any `tasks`\n * pass an error to their callback, and a `results` object with any completed\n * task results, similar to `auto`.\n * @example\n *\n * //  The example from `auto` can be rewritten as follows:\n * async.autoInject({\n *     get_data: function(callback) {\n *         // async code to get some data\n *         callback(null, 'data', 'converted to array');\n *     },\n *     make_folder: function(callback) {\n *         // async code to create a directory to store a file in\n *         // this is run at the same time as getting the data\n *         callback(null, 'folder');\n *     },\n *     write_file: function(get_data, make_folder, callback) {\n *         // once there is some data and the directory exists,\n *         // write the data to a file in the directory\n *         callback(null, 'filename');\n *     },\n *     email_link: function(write_file, callback) {\n *         // once the file is written let's email a link to it...\n *         // write_file contains the filename returned by write_file.\n *         callback(null, {'file':write_file, 'email':'user@example.com'});\n *     }\n * }, function(err, results) {\n *     console.log('err = ', err);\n *     console.log('email_link = ', results.email_link);\n * });\n *\n * // If you are using a JS minifier that mangles parameter names, `autoInject`\n * // will not work with plain functions, since the parameter names will be\n * // collapsed to a single letter identifier.  To work around this, you can\n * // explicitly specify the names of the parameters your task function needs\n * // in an array, similar to Angular.js dependency injection.\n *\n * // This still has an advantage over plain `auto`, since the results a task\n * // depends on are still spread into arguments.\n * async.autoInject({\n *     //...\n *     write_file: ['get_data', 'make_folder', function(get_data, make_folder, callback) {\n *         callback(null, 'filename');\n *     }],\n *     email_link: ['write_file', function(write_file, callback) {\n *         callback(null, {'file':write_file, 'email':'user@example.com'});\n *     }]\n *     //...\n * }, function(err, results) {\n *     console.log('err = ', err);\n *     console.log('email_link = ', results.email_link);\n * });\n */\nfunction autoInject(tasks, callback) {\n    var newTasks = {};\n\n    baseForOwn(tasks, function (taskFn, key) {\n        var params;\n        var fnIsAsync = isAsync(taskFn);\n        var hasNoDeps =\n            (!fnIsAsync && taskFn.length === 1) ||\n            (fnIsAsync && taskFn.length === 0);\n\n        if (isArray(taskFn)) {\n            params = taskFn.slice(0, -1);\n            taskFn = taskFn[taskFn.length - 1];\n\n            newTasks[key] = params.concat(params.length > 0 ? newTask : taskFn);\n        } else if (hasNoDeps) {\n            // no dependencies, use the function as-is\n            newTasks[key] = taskFn;\n        } else {\n            params = parseParams(taskFn);\n            if (taskFn.length === 0 && !fnIsAsync && params.length === 0) {\n                throw new Error(\"autoInject task functions require explicit parameters.\");\n            }\n\n            // remove callback param\n            if (!fnIsAsync) params.pop();\n\n            newTasks[key] = params.concat(newTask);\n        }\n\n        function newTask(results, taskCb) {\n            var newArgs = arrayMap(params, function (name) {\n                return results[name];\n            });\n            newArgs.push(taskCb);\n            wrapAsync(taskFn).apply(null, newArgs);\n        }\n    });\n\n    auto(newTasks, callback);\n}\n\n// Simple doubly linked list (https://en.wikipedia.org/wiki/Doubly_linked_list) implementation\n// used for queues. This implementation assumes that the node provided by the user can be modified\n// to adjust the next and last properties. We implement only the minimal functionality\n// for queue support.\nfunction DLL() {\n    this.head = this.tail = null;\n    this.length = 0;\n}\n\nfunction setInitial(dll, node) {\n    dll.length = 1;\n    dll.head = dll.tail = node;\n}\n\nDLL.prototype.removeLink = function(node) {\n    if (node.prev) node.prev.next = node.next;\n    else this.head = node.next;\n    if (node.next) node.next.prev = node.prev;\n    else this.tail = node.prev;\n\n    node.prev = node.next = null;\n    this.length -= 1;\n    return node;\n};\n\nDLL.prototype.empty = function () {\n    while(this.head) this.shift();\n    return this;\n};\n\nDLL.prototype.insertAfter = function(node, newNode) {\n    newNode.prev = node;\n    newNode.next = node.next;\n    if (node.next) node.next.prev = newNode;\n    else this.tail = newNode;\n    node.next = newNode;\n    this.length += 1;\n};\n\nDLL.prototype.insertBefore = function(node, newNode) {\n    newNode.prev = node.prev;\n    newNode.next = node;\n    if (node.prev) node.prev.next = newNode;\n    else this.head = newNode;\n    node.prev = newNode;\n    this.length += 1;\n};\n\nDLL.prototype.unshift = function(node) {\n    if (this.head) this.insertBefore(this.head, node);\n    else setInitial(this, node);\n};\n\nDLL.prototype.push = function(node) {\n    if (this.tail) this.insertAfter(this.tail, node);\n    else setInitial(this, node);\n};\n\nDLL.prototype.shift = function() {\n    return this.head && this.removeLink(this.head);\n};\n\nDLL.prototype.pop = function() {\n    return this.tail && this.removeLink(this.tail);\n};\n\nDLL.prototype.toArray = function () {\n    var arr = Array(this.length);\n    var curr = this.head;\n    for(var idx = 0; idx < this.length; idx++) {\n        arr[idx] = curr.data;\n        curr = curr.next;\n    }\n    return arr;\n};\n\nDLL.prototype.remove = function (testFn) {\n    var curr = this.head;\n    while(!!curr) {\n        var next = curr.next;\n        if (testFn(curr)) {\n            this.removeLink(curr);\n        }\n        curr = next;\n    }\n    return this;\n};\n\nfunction queue(worker, concurrency, payload) {\n    if (concurrency == null) {\n        concurrency = 1;\n    }\n    else if(concurrency === 0) {\n        throw new Error('Concurrency must not be zero');\n    }\n\n    var _worker = wrapAsync(worker);\n    var numRunning = 0;\n    var workersList = [];\n\n    var processingScheduled = false;\n    function _insert(data, insertAtFront, callback) {\n        if (callback != null && typeof callback !== 'function') {\n            throw new Error('task callback must be a function');\n        }\n        q.started = true;\n        if (!isArray(data)) {\n            data = [data];\n        }\n        if (data.length === 0 && q.idle()) {\n            // call drain immediately if there are no tasks\n            return setImmediate$1(function() {\n                q.drain();\n            });\n        }\n\n        for (var i = 0, l = data.length; i < l; i++) {\n            var item = {\n                data: data[i],\n                callback: callback || noop\n            };\n\n            if (insertAtFront) {\n                q._tasks.unshift(item);\n            } else {\n                q._tasks.push(item);\n            }\n        }\n\n        if (!processingScheduled) {\n            processingScheduled = true;\n            setImmediate$1(function() {\n                processingScheduled = false;\n                q.process();\n            });\n        }\n    }\n\n    function _next(tasks) {\n        return function(err){\n            numRunning -= 1;\n\n            for (var i = 0, l = tasks.length; i < l; i++) {\n                var task = tasks[i];\n\n                var index = baseIndexOf(workersList, task, 0);\n                if (index === 0) {\n                    workersList.shift();\n                } else if (index > 0) {\n                    workersList.splice(index, 1);\n                }\n\n                task.callback.apply(task, arguments);\n\n                if (err != null) {\n                    q.error(err, task.data);\n                }\n            }\n\n            if (numRunning <= (q.concurrency - q.buffer) ) {\n                q.unsaturated();\n            }\n\n            if (q.idle()) {\n                q.drain();\n            }\n            q.process();\n        };\n    }\n\n    var isProcessing = false;\n    var q = {\n        _tasks: new DLL(),\n        concurrency: concurrency,\n        payload: payload,\n        saturated: noop,\n        unsaturated:noop,\n        buffer: concurrency / 4,\n        empty: noop,\n        drain: noop,\n        error: noop,\n        started: false,\n        paused: false,\n        push: function (data, callback) {\n            _insert(data, false, callback);\n        },\n        kill: function () {\n            q.drain = noop;\n            q._tasks.empty();\n        },\n        unshift: function (data, callback) {\n            _insert(data, true, callback);\n        },\n        remove: function (testFn) {\n            q._tasks.remove(testFn);\n        },\n        process: function () {\n            // Avoid trying to start too many processing operations. This can occur\n            // when callbacks resolve synchronously (#1267).\n            if (isProcessing) {\n                return;\n            }\n            isProcessing = true;\n            while(!q.paused && numRunning < q.concurrency && q._tasks.length){\n                var tasks = [], data = [];\n                var l = q._tasks.length;\n                if (q.payload) l = Math.min(l, q.payload);\n                for (var i = 0; i < l; i++) {\n                    var node = q._tasks.shift();\n                    tasks.push(node);\n                    workersList.push(node);\n                    data.push(node.data);\n                }\n\n                numRunning += 1;\n\n                if (q._tasks.length === 0) {\n                    q.empty();\n                }\n\n                if (numRunning === q.concurrency) {\n                    q.saturated();\n                }\n\n                var cb = onlyOnce(_next(tasks));\n                _worker(data, cb);\n            }\n            isProcessing = false;\n        },\n        length: function () {\n            return q._tasks.length;\n        },\n        running: function () {\n            return numRunning;\n        },\n        workersList: function () {\n            return workersList;\n        },\n        idle: function() {\n            return q._tasks.length + numRunning === 0;\n        },\n        pause: function () {\n            q.paused = true;\n        },\n        resume: function () {\n            if (q.paused === false) { return; }\n            q.paused = false;\n            setImmediate$1(q.process);\n        }\n    };\n    return q;\n}\n\n/**\n * A cargo of tasks for the worker function to complete. Cargo inherits all of\n * the same methods and event callbacks as [`queue`]{@link module:ControlFlow.queue}.\n * @typedef {Object} CargoObject\n * @memberOf module:ControlFlow\n * @property {Function} length - A function returning the number of items\n * waiting to be processed. Invoke like `cargo.length()`.\n * @property {number} payload - An `integer` for determining how many tasks\n * should be process per round. This property can be changed after a `cargo` is\n * created to alter the payload on-the-fly.\n * @property {Function} push - Adds `task` to the `queue`. The callback is\n * called once the `worker` has finished processing the task. Instead of a\n * single task, an array of `tasks` can be submitted. The respective callback is\n * used for every task in the list. Invoke like `cargo.push(task, [callback])`.\n * @property {Function} saturated - A callback that is called when the\n * `queue.length()` hits the concurrency and further tasks will be queued.\n * @property {Function} empty - A callback that is called when the last item\n * from the `queue` is given to a `worker`.\n * @property {Function} drain - A callback that is called when the last item\n * from the `queue` has returned from the `worker`.\n * @property {Function} idle - a function returning false if there are items\n * waiting or being processed, or true if not. Invoke like `cargo.idle()`.\n * @property {Function} pause - a function that pauses the processing of tasks\n * until `resume()` is called. Invoke like `cargo.pause()`.\n * @property {Function} resume - a function that resumes the processing of\n * queued tasks when the queue is paused. Invoke like `cargo.resume()`.\n * @property {Function} kill - a function that removes the `drain` callback and\n * empties remaining tasks from the queue forcing it to go idle. Invoke like `cargo.kill()`.\n */\n\n/**\n * Creates a `cargo` object with the specified payload. Tasks added to the\n * cargo will be processed altogether (up to the `payload` limit). If the\n * `worker` is in progress, the task is queued until it becomes available. Once\n * the `worker` has completed some tasks, each callback of those tasks is\n * called. Check out [these](https://camo.githubusercontent.com/6bbd36f4cf5b35a0f11a96dcd2e97711ffc2fb37/68747470733a2f2f662e636c6f75642e6769746875622e636f6d2f6173736574732f313637363837312f36383130382f62626330636662302d356632392d313165322d393734662d3333393763363464633835382e676966) [animations](https://camo.githubusercontent.com/f4810e00e1c5f5f8addbe3e9f49064fd5d102699/68747470733a2f2f662e636c6f75642e6769746875622e636f6d2f6173736574732f313637363837312f36383130312f38346339323036362d356632392d313165322d383134662d3964336430323431336266642e676966)\n * for how `cargo` and `queue` work.\n *\n * While [`queue`]{@link module:ControlFlow.queue} passes only one task to one of a group of workers\n * at a time, cargo passes an array of tasks to a single worker, repeating\n * when the worker is finished.\n *\n * @name cargo\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.queue]{@link module:ControlFlow.queue}\n * @category Control Flow\n * @param {AsyncFunction} worker - An asynchronous function for processing an array\n * of queued tasks. Invoked with `(tasks, callback)`.\n * @param {number} [payload=Infinity] - An optional `integer` for determining\n * how many tasks should be processed per round; if omitted, the default is\n * unlimited.\n * @returns {module:ControlFlow.CargoObject} A cargo object to manage the tasks. Callbacks can\n * attached as certain properties to listen for specific events during the\n * lifecycle of the cargo and inner queue.\n * @example\n *\n * // create a cargo object with payload 2\n * var cargo = async.cargo(function(tasks, callback) {\n *     for (var i=0; i<tasks.length; i++) {\n *         console.log('hello ' + tasks[i].name);\n *     }\n *     callback();\n * }, 2);\n *\n * // add some items\n * cargo.push({name: 'foo'}, function(err) {\n *     console.log('finished processing foo');\n * });\n * cargo.push({name: 'bar'}, function(err) {\n *     console.log('finished processing bar');\n * });\n * cargo.push({name: 'baz'}, function(err) {\n *     console.log('finished processing baz');\n * });\n */\nfunction cargo(worker, payload) {\n    return queue(worker, 1, payload);\n}\n\n/**\n * The same as [`eachOf`]{@link module:Collections.eachOf} but runs only a single async operation at a time.\n *\n * @name eachOfSeries\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.eachOf]{@link module:Collections.eachOf}\n * @alias forEachOfSeries\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - An async function to apply to each item in\n * `coll`.\n * Invoked with (item, key, callback).\n * @param {Function} [callback] - A callback which is called when all `iteratee`\n * functions have finished, or an error occurs. Invoked with (err).\n */\nvar eachOfSeries = doLimit(eachOfLimit, 1);\n\n/**\n * Reduces `coll` into a single value using an async `iteratee` to return each\n * successive step. `memo` is the initial state of the reduction. This function\n * only operates in series.\n *\n * For performance reasons, it may make sense to split a call to this function\n * into a parallel map, and then use the normal `Array.prototype.reduce` on the\n * results. This function is for situations where each step in the reduction\n * needs to be async; if you can get the data before reducing it, then it's\n * probably a good idea to do so.\n *\n * @name reduce\n * @static\n * @memberOf module:Collections\n * @method\n * @alias inject\n * @alias foldl\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {*} memo - The initial state of the reduction.\n * @param {AsyncFunction} iteratee - A function applied to each item in the\n * array to produce the next step in the reduction.\n * The `iteratee` should complete with the next state of the reduction.\n * If the iteratee complete with an error, the reduction is stopped and the\n * main `callback` is immediately called with the error.\n * Invoked with (memo, item, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished. Result is the reduced value. Invoked with\n * (err, result).\n * @example\n *\n * async.reduce([1,2,3], 0, function(memo, item, callback) {\n *     // pointless async:\n *     process.nextTick(function() {\n *         callback(null, memo + item)\n *     });\n * }, function(err, result) {\n *     // result is now equal to the last value of memo, which is 6\n * });\n */\nfunction reduce(coll, memo, iteratee, callback) {\n    callback = once(callback || noop);\n    var _iteratee = wrapAsync(iteratee);\n    eachOfSeries(coll, function(x, i, callback) {\n        _iteratee(memo, x, function(err, v) {\n            memo = v;\n            callback(err);\n        });\n    }, function(err) {\n        callback(err, memo);\n    });\n}\n\n/**\n * Version of the compose function that is more natural to read. Each function\n * consumes the return value of the previous function. It is the equivalent of\n * [compose]{@link module:ControlFlow.compose} with the arguments reversed.\n *\n * Each function is executed with the `this` binding of the composed function.\n *\n * @name seq\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.compose]{@link module:ControlFlow.compose}\n * @category Control Flow\n * @param {...AsyncFunction} functions - the asynchronous functions to compose\n * @returns {Function} a function that composes the `functions` in order\n * @example\n *\n * // Requires lodash (or underscore), express3 and dresende's orm2.\n * // Part of an app, that fetches cats of the logged user.\n * // This example uses `seq` function to avoid overnesting and error\n * // handling clutter.\n * app.get('/cats', function(request, response) {\n *     var User = request.models.User;\n *     async.seq(\n *         _.bind(User.get, User),  // 'User.get' has signature (id, callback(err, data))\n *         function(user, fn) {\n *             user.getCats(fn);      // 'getCats' has signature (callback(err, data))\n *         }\n *     )(req.session.user_id, function (err, cats) {\n *         if (err) {\n *             console.error(err);\n *             response.json({ status: 'error', message: err.message });\n *         } else {\n *             response.json({ status: 'ok', message: 'Cats found', data: cats });\n *         }\n *     });\n * });\n */\nfunction seq(/*...functions*/) {\n    var _functions = arrayMap(arguments, wrapAsync);\n    return function(/*...args*/) {\n        var args = slice(arguments);\n        var that = this;\n\n        var cb = args[args.length - 1];\n        if (typeof cb == 'function') {\n            args.pop();\n        } else {\n            cb = noop;\n        }\n\n        reduce(_functions, args, function(newargs, fn, cb) {\n            fn.apply(that, newargs.concat(function(err/*, ...nextargs*/) {\n                var nextargs = slice(arguments, 1);\n                cb(err, nextargs);\n            }));\n        },\n        function(err, results) {\n            cb.apply(that, [err].concat(results));\n        });\n    };\n}\n\n/**\n * Creates a function which is a composition of the passed asynchronous\n * functions. Each function consumes the return value of the function that\n * follows. Composing functions `f()`, `g()`, and `h()` would produce the result\n * of `f(g(h()))`, only this version uses callbacks to obtain the return values.\n *\n * Each function is executed with the `this` binding of the composed function.\n *\n * @name compose\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @param {...AsyncFunction} functions - the asynchronous functions to compose\n * @returns {Function} an asynchronous function that is the composed\n * asynchronous `functions`\n * @example\n *\n * function add1(n, callback) {\n *     setTimeout(function () {\n *         callback(null, n + 1);\n *     }, 10);\n * }\n *\n * function mul3(n, callback) {\n *     setTimeout(function () {\n *         callback(null, n * 3);\n *     }, 10);\n * }\n *\n * var add1mul3 = async.compose(mul3, add1);\n * add1mul3(4, function (err, result) {\n *     // result now equals 15\n * });\n */\nvar compose = function(/*...args*/) {\n    return seq.apply(null, slice(arguments).reverse());\n};\n\nvar _concat = Array.prototype.concat;\n\n/**\n * The same as [`concat`]{@link module:Collections.concat} but runs a maximum of `limit` async operations at a time.\n *\n * @name concatLimit\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.concat]{@link module:Collections.concat}\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {AsyncFunction} iteratee - A function to apply to each item in `coll`,\n * which should use an array as its result. Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished, or an error occurs. Results is an array\n * containing the concatenated results of the `iteratee` function. Invoked with\n * (err, results).\n */\nvar concatLimit = function(coll, limit, iteratee, callback) {\n    callback = callback || noop;\n    var _iteratee = wrapAsync(iteratee);\n    mapLimit(coll, limit, function(val, callback) {\n        _iteratee(val, function(err /*, ...args*/) {\n            if (err) return callback(err);\n            return callback(null, slice(arguments, 1));\n        });\n    }, function(err, mapResults) {\n        var result = [];\n        for (var i = 0; i < mapResults.length; i++) {\n            if (mapResults[i]) {\n                result = _concat.apply(result, mapResults[i]);\n            }\n        }\n\n        return callback(err, result);\n    });\n};\n\n/**\n * Applies `iteratee` to each item in `coll`, concatenating the results. Returns\n * the concatenated list. The `iteratee`s are called in parallel, and the\n * results are concatenated as they return. There is no guarantee that the\n * results array will be returned in the original order of `coll` passed to the\n * `iteratee` function.\n *\n * @name concat\n * @static\n * @memberOf module:Collections\n * @method\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - A function to apply to each item in `coll`,\n * which should use an array as its result. Invoked with (item, callback).\n * @param {Function} [callback(err)] - A callback which is called after all the\n * `iteratee` functions have finished, or an error occurs. Results is an array\n * containing the concatenated results of the `iteratee` function. Invoked with\n * (err, results).\n * @example\n *\n * async.concat(['dir1','dir2','dir3'], fs.readdir, function(err, files) {\n *     // files is now a list of filenames that exist in the 3 directories\n * });\n */\nvar concat = doLimit(concatLimit, Infinity);\n\n/**\n * The same as [`concat`]{@link module:Collections.concat} but runs only a single async operation at a time.\n *\n * @name concatSeries\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.concat]{@link module:Collections.concat}\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - A function to apply to each item in `coll`.\n * The iteratee should complete with an array an array of results.\n * Invoked with (item, callback).\n * @param {Function} [callback(err)] - A callback which is called after all the\n * `iteratee` functions have finished, or an error occurs. Results is an array\n * containing the concatenated results of the `iteratee` function. Invoked with\n * (err, results).\n */\nvar concatSeries = doLimit(concatLimit, 1);\n\n/**\n * Returns a function that when called, calls-back with the values provided.\n * Useful as the first function in a [`waterfall`]{@link module:ControlFlow.waterfall}, or for plugging values in to\n * [`auto`]{@link module:ControlFlow.auto}.\n *\n * @name constant\n * @static\n * @memberOf module:Utils\n * @method\n * @category Util\n * @param {...*} arguments... - Any number of arguments to automatically invoke\n * callback with.\n * @returns {AsyncFunction} Returns a function that when invoked, automatically\n * invokes the callback with the previous given arguments.\n * @example\n *\n * async.waterfall([\n *     async.constant(42),\n *     function (value, next) {\n *         // value === 42\n *     },\n *     //...\n * ], callback);\n *\n * async.waterfall([\n *     async.constant(filename, \"utf8\"),\n *     fs.readFile,\n *     function (fileData, next) {\n *         //...\n *     }\n *     //...\n * ], callback);\n *\n * async.auto({\n *     hostname: async.constant(\"https://server.net/\"),\n *     port: findFreePort,\n *     launchServer: [\"hostname\", \"port\", function (options, cb) {\n *         startServer(options, cb);\n *     }],\n *     //...\n * }, callback);\n */\nvar constant = function(/*...values*/) {\n    var values = slice(arguments);\n    var args = [null].concat(values);\n    return function (/*...ignoredArgs, callback*/) {\n        var callback = arguments[arguments.length - 1];\n        return callback.apply(this, args);\n    };\n};\n\n/**\n * This method returns the first argument it receives.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Util\n * @param {*} value Any value.\n * @returns {*} Returns `value`.\n * @example\n *\n * var object = { 'a': 1 };\n *\n * console.log(_.identity(object) === object);\n * // => true\n */\nfunction identity(value) {\n  return value;\n}\n\nfunction _createTester(check, getResult) {\n    return function(eachfn, arr, iteratee, cb) {\n        cb = cb || noop;\n        var testPassed = false;\n        var testResult;\n        eachfn(arr, function(value, _, callback) {\n            iteratee(value, function(err, result) {\n                if (err) {\n                    callback(err);\n                } else if (check(result) && !testResult) {\n                    testPassed = true;\n                    testResult = getResult(true, value);\n                    callback(null, breakLoop);\n                } else {\n                    callback();\n                }\n            });\n        }, function(err) {\n            if (err) {\n                cb(err);\n            } else {\n                cb(null, testPassed ? testResult : getResult(false));\n            }\n        });\n    };\n}\n\nfunction _findGetResult(v, x) {\n    return x;\n}\n\n/**\n * Returns the first value in `coll` that passes an async truth test. The\n * `iteratee` is applied in parallel, meaning the first iteratee to return\n * `true` will fire the detect `callback` with that result. That means the\n * result might not be the first item in the original `coll` (in terms of order)\n * that passes the test.\n\n * If order within the original `coll` is important, then look at\n * [`detectSeries`]{@link module:Collections.detectSeries}.\n *\n * @name detect\n * @static\n * @memberOf module:Collections\n * @method\n * @alias find\n * @category Collections\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - A truth test to apply to each item in `coll`.\n * The iteratee must complete with a boolean value as its result.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called as soon as any\n * iteratee returns `true`, or after all the `iteratee` functions have finished.\n * Result will be the first item in the array that passes the truth test\n * (iteratee) or the value `undefined` if none passed. Invoked with\n * (err, result).\n * @example\n *\n * async.detect(['file1','file2','file3'], function(filePath, callback) {\n *     fs.access(filePath, function(err) {\n *         callback(null, !err)\n *     });\n * }, function(err, result) {\n *     // result now equals the first file in the list that exists\n * });\n */\nvar detect = doParallel(_createTester(identity, _findGetResult));\n\n/**\n * The same as [`detect`]{@link module:Collections.detect} but runs a maximum of `limit` async operations at a\n * time.\n *\n * @name detectLimit\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.detect]{@link module:Collections.detect}\n * @alias findLimit\n * @category Collections\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {AsyncFunction} iteratee - A truth test to apply to each item in `coll`.\n * The iteratee must complete with a boolean value as its result.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called as soon as any\n * iteratee returns `true`, or after all the `iteratee` functions have finished.\n * Result will be the first item in the array that passes the truth test\n * (iteratee) or the value `undefined` if none passed. Invoked with\n * (err, result).\n */\nvar detectLimit = doParallelLimit(_createTester(identity, _findGetResult));\n\n/**\n * The same as [`detect`]{@link module:Collections.detect} but runs only a single async operation at a time.\n *\n * @name detectSeries\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.detect]{@link module:Collections.detect}\n * @alias findSeries\n * @category Collections\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - A truth test to apply to each item in `coll`.\n * The iteratee must complete with a boolean value as its result.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called as soon as any\n * iteratee returns `true`, or after all the `iteratee` functions have finished.\n * Result will be the first item in the array that passes the truth test\n * (iteratee) or the value `undefined` if none passed. Invoked with\n * (err, result).\n */\nvar detectSeries = doLimit(detectLimit, 1);\n\nfunction consoleFunc(name) {\n    return function (fn/*, ...args*/) {\n        var args = slice(arguments, 1);\n        args.push(function (err/*, ...args*/) {\n            var args = slice(arguments, 1);\n            if (typeof console === 'object') {\n                if (err) {\n                    if (console.error) {\n                        console.error(err);\n                    }\n                } else if (console[name]) {\n                    arrayEach(args, function (x) {\n                        console[name](x);\n                    });\n                }\n            }\n        });\n        wrapAsync(fn).apply(null, args);\n    };\n}\n\n/**\n * Logs the result of an [`async` function]{@link AsyncFunction} to the\n * `console` using `console.dir` to display the properties of the resulting object.\n * Only works in Node.js or in browsers that support `console.dir` and\n * `console.error` (such as FF and Chrome).\n * If multiple arguments are returned from the async function,\n * `console.dir` is called on each argument in order.\n *\n * @name dir\n * @static\n * @memberOf module:Utils\n * @method\n * @category Util\n * @param {AsyncFunction} function - The function you want to eventually apply\n * all arguments to.\n * @param {...*} arguments... - Any number of arguments to apply to the function.\n * @example\n *\n * // in a module\n * var hello = function(name, callback) {\n *     setTimeout(function() {\n *         callback(null, {hello: name});\n *     }, 1000);\n * };\n *\n * // in the node repl\n * node> async.dir(hello, 'world');\n * {hello: 'world'}\n */\nvar dir = consoleFunc('dir');\n\n/**\n * The post-check version of [`during`]{@link module:ControlFlow.during}. To reflect the difference in\n * the order of operations, the arguments `test` and `fn` are switched.\n *\n * Also a version of [`doWhilst`]{@link module:ControlFlow.doWhilst} with asynchronous `test` function.\n * @name doDuring\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.during]{@link module:ControlFlow.during}\n * @category Control Flow\n * @param {AsyncFunction} fn - An async function which is called each time\n * `test` passes. Invoked with (callback).\n * @param {AsyncFunction} test - asynchronous truth test to perform before each\n * execution of `fn`. Invoked with (...args, callback), where `...args` are the\n * non-error args from the previous callback of `fn`.\n * @param {Function} [callback] - A callback which is called after the test\n * function has failed and repeated execution of `fn` has stopped. `callback`\n * will be passed an error if one occurred, otherwise `null`.\n */\nfunction doDuring(fn, test, callback) {\n    callback = onlyOnce(callback || noop);\n    var _fn = wrapAsync(fn);\n    var _test = wrapAsync(test);\n\n    function next(err/*, ...args*/) {\n        if (err) return callback(err);\n        var args = slice(arguments, 1);\n        args.push(check);\n        _test.apply(this, args);\n    }\n\n    function check(err, truth) {\n        if (err) return callback(err);\n        if (!truth) return callback(null);\n        _fn(next);\n    }\n\n    check(null, true);\n\n}\n\n/**\n * The post-check version of [`whilst`]{@link module:ControlFlow.whilst}. To reflect the difference in\n * the order of operations, the arguments `test` and `iteratee` are switched.\n *\n * `doWhilst` is to `whilst` as `do while` is to `while` in plain JavaScript.\n *\n * @name doWhilst\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.whilst]{@link module:ControlFlow.whilst}\n * @category Control Flow\n * @param {AsyncFunction} iteratee - A function which is called each time `test`\n * passes. Invoked with (callback).\n * @param {Function} test - synchronous truth test to perform after each\n * execution of `iteratee`. Invoked with any non-error callback results of\n * `iteratee`.\n * @param {Function} [callback] - A callback which is called after the test\n * function has failed and repeated execution of `iteratee` has stopped.\n * `callback` will be passed an error and any arguments passed to the final\n * `iteratee`'s callback. Invoked with (err, [results]);\n */\nfunction doWhilst(iteratee, test, callback) {\n    callback = onlyOnce(callback || noop);\n    var _iteratee = wrapAsync(iteratee);\n    var next = function(err/*, ...args*/) {\n        if (err) return callback(err);\n        var args = slice(arguments, 1);\n        if (test.apply(this, args)) return _iteratee(next);\n        callback.apply(null, [null].concat(args));\n    };\n    _iteratee(next);\n}\n\n/**\n * Like ['doWhilst']{@link module:ControlFlow.doWhilst}, except the `test` is inverted. Note the\n * argument ordering differs from `until`.\n *\n * @name doUntil\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.doWhilst]{@link module:ControlFlow.doWhilst}\n * @category Control Flow\n * @param {AsyncFunction} iteratee - An async function which is called each time\n * `test` fails. Invoked with (callback).\n * @param {Function} test - synchronous truth test to perform after each\n * execution of `iteratee`. Invoked with any non-error callback results of\n * `iteratee`.\n * @param {Function} [callback] - A callback which is called after the test\n * function has passed and repeated execution of `iteratee` has stopped. `callback`\n * will be passed an error and any arguments passed to the final `iteratee`'s\n * callback. Invoked with (err, [results]);\n */\nfunction doUntil(iteratee, test, callback) {\n    doWhilst(iteratee, function() {\n        return !test.apply(this, arguments);\n    }, callback);\n}\n\n/**\n * Like [`whilst`]{@link module:ControlFlow.whilst}, except the `test` is an asynchronous function that\n * is passed a callback in the form of `function (err, truth)`. If error is\n * passed to `test` or `fn`, the main callback is immediately called with the\n * value of the error.\n *\n * @name during\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.whilst]{@link module:ControlFlow.whilst}\n * @category Control Flow\n * @param {AsyncFunction} test - asynchronous truth test to perform before each\n * execution of `fn`. Invoked with (callback).\n * @param {AsyncFunction} fn - An async function which is called each time\n * `test` passes. Invoked with (callback).\n * @param {Function} [callback] - A callback which is called after the test\n * function has failed and repeated execution of `fn` has stopped. `callback`\n * will be passed an error, if one occurred, otherwise `null`.\n * @example\n *\n * var count = 0;\n *\n * async.during(\n *     function (callback) {\n *         return callback(null, count < 5);\n *     },\n *     function (callback) {\n *         count++;\n *         setTimeout(callback, 1000);\n *     },\n *     function (err) {\n *         // 5 seconds have passed\n *     }\n * );\n */\nfunction during(test, fn, callback) {\n    callback = onlyOnce(callback || noop);\n    var _fn = wrapAsync(fn);\n    var _test = wrapAsync(test);\n\n    function next(err) {\n        if (err) return callback(err);\n        _test(check);\n    }\n\n    function check(err, truth) {\n        if (err) return callback(err);\n        if (!truth) return callback(null);\n        _fn(next);\n    }\n\n    _test(check);\n}\n\nfunction _withoutIndex(iteratee) {\n    return function (value, index, callback) {\n        return iteratee(value, callback);\n    };\n}\n\n/**\n * Applies the function `iteratee` to each item in `coll`, in parallel.\n * The `iteratee` is called with an item from the list, and a callback for when\n * it has finished. If the `iteratee` passes an error to its `callback`, the\n * main `callback` (for the `each` function) is immediately called with the\n * error.\n *\n * Note, that since this function applies `iteratee` to each item in parallel,\n * there is no guarantee that the iteratee functions will complete in order.\n *\n * @name each\n * @static\n * @memberOf module:Collections\n * @method\n * @alias forEach\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - An async function to apply to\n * each item in `coll`. Invoked with (item, callback).\n * The array index is not passed to the iteratee.\n * If you need the index, use `eachOf`.\n * @param {Function} [callback] - A callback which is called when all\n * `iteratee` functions have finished, or an error occurs. Invoked with (err).\n * @example\n *\n * // assuming openFiles is an array of file names and saveFile is a function\n * // to save the modified contents of that file:\n *\n * async.each(openFiles, saveFile, function(err){\n *   // if any of the saves produced an error, err would equal that error\n * });\n *\n * // assuming openFiles is an array of file names\n * async.each(openFiles, function(file, callback) {\n *\n *     // Perform operation on file here.\n *     console.log('Processing file ' + file);\n *\n *     if( file.length > 32 ) {\n *       console.log('This file name is too long');\n *       callback('File name too long');\n *     } else {\n *       // Do work to process file here\n *       console.log('File processed');\n *       callback();\n *     }\n * }, function(err) {\n *     // if any of the file processing produced an error, err would equal that error\n *     if( err ) {\n *       // One of the iterations produced an error.\n *       // All processing will now stop.\n *       console.log('A file failed to process');\n *     } else {\n *       console.log('All files have been processed successfully');\n *     }\n * });\n */\nfunction eachLimit(coll, iteratee, callback) {\n    eachOf(coll, _withoutIndex(wrapAsync(iteratee)), callback);\n}\n\n/**\n * The same as [`each`]{@link module:Collections.each} but runs a maximum of `limit` async operations at a time.\n *\n * @name eachLimit\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.each]{@link module:Collections.each}\n * @alias forEachLimit\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {AsyncFunction} iteratee - An async function to apply to each item in\n * `coll`.\n * The array index is not passed to the iteratee.\n * If you need the index, use `eachOfLimit`.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called when all\n * `iteratee` functions have finished, or an error occurs. Invoked with (err).\n */\nfunction eachLimit$1(coll, limit, iteratee, callback) {\n    _eachOfLimit(limit)(coll, _withoutIndex(wrapAsync(iteratee)), callback);\n}\n\n/**\n * The same as [`each`]{@link module:Collections.each} but runs only a single async operation at a time.\n *\n * @name eachSeries\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.each]{@link module:Collections.each}\n * @alias forEachSeries\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - An async function to apply to each\n * item in `coll`.\n * The array index is not passed to the iteratee.\n * If you need the index, use `eachOfSeries`.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called when all\n * `iteratee` functions have finished, or an error occurs. Invoked with (err).\n */\nvar eachSeries = doLimit(eachLimit$1, 1);\n\n/**\n * Wrap an async function and ensure it calls its callback on a later tick of\n * the event loop.  If the function already calls its callback on a next tick,\n * no extra deferral is added. This is useful for preventing stack overflows\n * (`RangeError: Maximum call stack size exceeded`) and generally keeping\n * [Zalgo](http://blog.izs.me/post/59142742143/designing-apis-for-asynchrony)\n * contained. ES2017 `async` functions are returned as-is -- they are immune\n * to Zalgo's corrupting influences, as they always resolve on a later tick.\n *\n * @name ensureAsync\n * @static\n * @memberOf module:Utils\n * @method\n * @category Util\n * @param {AsyncFunction} fn - an async function, one that expects a node-style\n * callback as its last argument.\n * @returns {AsyncFunction} Returns a wrapped function with the exact same call\n * signature as the function passed in.\n * @example\n *\n * function sometimesAsync(arg, callback) {\n *     if (cache[arg]) {\n *         return callback(null, cache[arg]); // this would be synchronous!!\n *     } else {\n *         doSomeIO(arg, callback); // this IO would be asynchronous\n *     }\n * }\n *\n * // this has a risk of stack overflows if many results are cached in a row\n * async.mapSeries(args, sometimesAsync, done);\n *\n * // this will defer sometimesAsync's callback if necessary,\n * // preventing stack overflows\n * async.mapSeries(args, async.ensureAsync(sometimesAsync), done);\n */\nfunction ensureAsync(fn) {\n    if (isAsync(fn)) return fn;\n    return initialParams(function (args, callback) {\n        var sync = true;\n        args.push(function () {\n            var innerArgs = arguments;\n            if (sync) {\n                setImmediate$1(function () {\n                    callback.apply(null, innerArgs);\n                });\n            } else {\n                callback.apply(null, innerArgs);\n            }\n        });\n        fn.apply(this, args);\n        sync = false;\n    });\n}\n\nfunction notId(v) {\n    return !v;\n}\n\n/**\n * Returns `true` if every element in `coll` satisfies an async test. If any\n * iteratee call returns `false`, the main `callback` is immediately called.\n *\n * @name every\n * @static\n * @memberOf module:Collections\n * @method\n * @alias all\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - An async truth test to apply to each item\n * in the collection in parallel.\n * The iteratee must complete with a boolean result value.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished. Result will be either `true` or `false`\n * depending on the values of the async tests. Invoked with (err, result).\n * @example\n *\n * async.every(['file1','file2','file3'], function(filePath, callback) {\n *     fs.access(filePath, function(err) {\n *         callback(null, !err)\n *     });\n * }, function(err, result) {\n *     // if result is true then every file exists\n * });\n */\nvar every = doParallel(_createTester(notId, notId));\n\n/**\n * The same as [`every`]{@link module:Collections.every} but runs a maximum of `limit` async operations at a time.\n *\n * @name everyLimit\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.every]{@link module:Collections.every}\n * @alias allLimit\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {AsyncFunction} iteratee - An async truth test to apply to each item\n * in the collection in parallel.\n * The iteratee must complete with a boolean result value.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished. Result will be either `true` or `false`\n * depending on the values of the async tests. Invoked with (err, result).\n */\nvar everyLimit = doParallelLimit(_createTester(notId, notId));\n\n/**\n * The same as [`every`]{@link module:Collections.every} but runs only a single async operation at a time.\n *\n * @name everySeries\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.every]{@link module:Collections.every}\n * @alias allSeries\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - An async truth test to apply to each item\n * in the collection in series.\n * The iteratee must complete with a boolean result value.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished. Result will be either `true` or `false`\n * depending on the values of the async tests. Invoked with (err, result).\n */\nvar everySeries = doLimit(everyLimit, 1);\n\n/**\n * The base implementation of `_.property` without support for deep paths.\n *\n * @private\n * @param {string} key The key of the property to get.\n * @returns {Function} Returns the new accessor function.\n */\nfunction baseProperty(key) {\n  return function(object) {\n    return object == null ? undefined : object[key];\n  };\n}\n\nfunction filterArray(eachfn, arr, iteratee, callback) {\n    var truthValues = new Array(arr.length);\n    eachfn(arr, function (x, index, callback) {\n        iteratee(x, function (err, v) {\n            truthValues[index] = !!v;\n            callback(err);\n        });\n    }, function (err) {\n        if (err) return callback(err);\n        var results = [];\n        for (var i = 0; i < arr.length; i++) {\n            if (truthValues[i]) results.push(arr[i]);\n        }\n        callback(null, results);\n    });\n}\n\nfunction filterGeneric(eachfn, coll, iteratee, callback) {\n    var results = [];\n    eachfn(coll, function (x, index, callback) {\n        iteratee(x, function (err, v) {\n            if (err) {\n                callback(err);\n            } else {\n                if (v) {\n                    results.push({index: index, value: x});\n                }\n                callback();\n            }\n        });\n    }, function (err) {\n        if (err) {\n            callback(err);\n        } else {\n            callback(null, arrayMap(results.sort(function (a, b) {\n                return a.index - b.index;\n            }), baseProperty('value')));\n        }\n    });\n}\n\nfunction _filter(eachfn, coll, iteratee, callback) {\n    var filter = isArrayLike(coll) ? filterArray : filterGeneric;\n    filter(eachfn, coll, wrapAsync(iteratee), callback || noop);\n}\n\n/**\n * Returns a new array of all the values in `coll` which pass an async truth\n * test. This operation is performed in parallel, but the results array will be\n * in the same order as the original.\n *\n * @name filter\n * @static\n * @memberOf module:Collections\n * @method\n * @alias select\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {Function} iteratee - A truth test to apply to each item in `coll`.\n * The `iteratee` is passed a `callback(err, truthValue)`, which must be called\n * with a boolean argument once it has completed. Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished. Invoked with (err, results).\n * @example\n *\n * async.filter(['file1','file2','file3'], function(filePath, callback) {\n *     fs.access(filePath, function(err) {\n *         callback(null, !err)\n *     });\n * }, function(err, results) {\n *     // results now equals an array of the existing files\n * });\n */\nvar filter = doParallel(_filter);\n\n/**\n * The same as [`filter`]{@link module:Collections.filter} but runs a maximum of `limit` async operations at a\n * time.\n *\n * @name filterLimit\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.filter]{@link module:Collections.filter}\n * @alias selectLimit\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {Function} iteratee - A truth test to apply to each item in `coll`.\n * The `iteratee` is passed a `callback(err, truthValue)`, which must be called\n * with a boolean argument once it has completed. Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished. Invoked with (err, results).\n */\nvar filterLimit = doParallelLimit(_filter);\n\n/**\n * The same as [`filter`]{@link module:Collections.filter} but runs only a single async operation at a time.\n *\n * @name filterSeries\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.filter]{@link module:Collections.filter}\n * @alias selectSeries\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {Function} iteratee - A truth test to apply to each item in `coll`.\n * The `iteratee` is passed a `callback(err, truthValue)`, which must be called\n * with a boolean argument once it has completed. Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished. Invoked with (err, results)\n */\nvar filterSeries = doLimit(filterLimit, 1);\n\n/**\n * Calls the asynchronous function `fn` with a callback parameter that allows it\n * to call itself again, in series, indefinitely.\n\n * If an error is passed to the callback then `errback` is called with the\n * error, and execution stops, otherwise it will never be called.\n *\n * @name forever\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @param {AsyncFunction} fn - an async function to call repeatedly.\n * Invoked with (next).\n * @param {Function} [errback] - when `fn` passes an error to it's callback,\n * this function will be called, and execution stops. Invoked with (err).\n * @example\n *\n * async.forever(\n *     function(next) {\n *         // next is suitable for passing to things that need a callback(err [, whatever]);\n *         // it will result in this function being called again.\n *     },\n *     function(err) {\n *         // if next is called with a value in its first parameter, it will appear\n *         // in here as 'err', and execution will stop.\n *     }\n * );\n */\nfunction forever(fn, errback) {\n    var done = onlyOnce(errback || noop);\n    var task = wrapAsync(ensureAsync(fn));\n\n    function next(err) {\n        if (err) return done(err);\n        task(next);\n    }\n    next();\n}\n\n/**\n * The same as [`groupBy`]{@link module:Collections.groupBy} but runs a maximum of `limit` async operations at a time.\n *\n * @name groupByLimit\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.groupBy]{@link module:Collections.groupBy}\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {AsyncFunction} iteratee - An async function to apply to each item in\n * `coll`.\n * The iteratee should complete with a `key` to group the value under.\n * Invoked with (value, callback).\n * @param {Function} [callback] - A callback which is called when all `iteratee`\n * functions have finished, or an error occurs. Result is an `Object` whoses\n * properties are arrays of values which returned the corresponding key.\n */\nvar groupByLimit = function(coll, limit, iteratee, callback) {\n    callback = callback || noop;\n    var _iteratee = wrapAsync(iteratee);\n    mapLimit(coll, limit, function(val, callback) {\n        _iteratee(val, function(err, key) {\n            if (err) return callback(err);\n            return callback(null, {key: key, val: val});\n        });\n    }, function(err, mapResults) {\n        var result = {};\n        // from MDN, handle object having an `hasOwnProperty` prop\n        var hasOwnProperty = Object.prototype.hasOwnProperty;\n\n        for (var i = 0; i < mapResults.length; i++) {\n            if (mapResults[i]) {\n                var key = mapResults[i].key;\n                var val = mapResults[i].val;\n\n                if (hasOwnProperty.call(result, key)) {\n                    result[key].push(val);\n                } else {\n                    result[key] = [val];\n                }\n            }\n        }\n\n        return callback(err, result);\n    });\n};\n\n/**\n * Returns a new object, where each value corresponds to an array of items, from\n * `coll`, that returned the corresponding key. That is, the keys of the object\n * correspond to the values passed to the `iteratee` callback.\n *\n * Note: Since this function applies the `iteratee` to each item in parallel,\n * there is no guarantee that the `iteratee` functions will complete in order.\n * However, the values for each key in the `result` will be in the same order as\n * the original `coll`. For Objects, the values will roughly be in the order of\n * the original Objects' keys (but this can vary across JavaScript engines).\n *\n * @name groupBy\n * @static\n * @memberOf module:Collections\n * @method\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - An async function to apply to each item in\n * `coll`.\n * The iteratee should complete with a `key` to group the value under.\n * Invoked with (value, callback).\n * @param {Function} [callback] - A callback which is called when all `iteratee`\n * functions have finished, or an error occurs. Result is an `Object` whoses\n * properties are arrays of values which returned the corresponding key.\n * @example\n *\n * async.groupBy(['userId1', 'userId2', 'userId3'], function(userId, callback) {\n *     db.findById(userId, function(err, user) {\n *         if (err) return callback(err);\n *         return callback(null, user.age);\n *     });\n * }, function(err, result) {\n *     // result is object containing the userIds grouped by age\n *     // e.g. { 30: ['userId1', 'userId3'], 42: ['userId2']};\n * });\n */\nvar groupBy = doLimit(groupByLimit, Infinity);\n\n/**\n * The same as [`groupBy`]{@link module:Collections.groupBy} but runs only a single async operation at a time.\n *\n * @name groupBySeries\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.groupBy]{@link module:Collections.groupBy}\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {AsyncFunction} iteratee - An async function to apply to each item in\n * `coll`.\n * The iteratee should complete with a `key` to group the value under.\n * Invoked with (value, callback).\n * @param {Function} [callback] - A callback which is called when all `iteratee`\n * functions have finished, or an error occurs. Result is an `Object` whoses\n * properties are arrays of values which returned the corresponding key.\n */\nvar groupBySeries = doLimit(groupByLimit, 1);\n\n/**\n * Logs the result of an `async` function to the `console`. Only works in\n * Node.js or in browsers that support `console.log` and `console.error` (such\n * as FF and Chrome). If multiple arguments are returned from the async\n * function, `console.log` is called on each argument in order.\n *\n * @name log\n * @static\n * @memberOf module:Utils\n * @method\n * @category Util\n * @param {AsyncFunction} function - The function you want to eventually apply\n * all arguments to.\n * @param {...*} arguments... - Any number of arguments to apply to the function.\n * @example\n *\n * // in a module\n * var hello = function(name, callback) {\n *     setTimeout(function() {\n *         callback(null, 'hello ' + name);\n *     }, 1000);\n * };\n *\n * // in the node repl\n * node> async.log(hello, 'world');\n * 'hello world'\n */\nvar log = consoleFunc('log');\n\n/**\n * The same as [`mapValues`]{@link module:Collections.mapValues} but runs a maximum of `limit` async operations at a\n * time.\n *\n * @name mapValuesLimit\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.mapValues]{@link module:Collections.mapValues}\n * @category Collection\n * @param {Object} obj - A collection to iterate over.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {AsyncFunction} iteratee - A function to apply to each value and key\n * in `coll`.\n * The iteratee should complete with the transformed value as its result.\n * Invoked with (value, key, callback).\n * @param {Function} [callback] - A callback which is called when all `iteratee`\n * functions have finished, or an error occurs. `result` is a new object consisting\n * of each key from `obj`, with each transformed value on the right-hand side.\n * Invoked with (err, result).\n */\nfunction mapValuesLimit(obj, limit, iteratee, callback) {\n    callback = once(callback || noop);\n    var newObj = {};\n    var _iteratee = wrapAsync(iteratee);\n    eachOfLimit(obj, limit, function(val, key, next) {\n        _iteratee(val, key, function (err, result) {\n            if (err) return next(err);\n            newObj[key] = result;\n            next();\n        });\n    }, function (err) {\n        callback(err, newObj);\n    });\n}\n\n/**\n * A relative of [`map`]{@link module:Collections.map}, designed for use with objects.\n *\n * Produces a new Object by mapping each value of `obj` through the `iteratee`\n * function. The `iteratee` is called each `value` and `key` from `obj` and a\n * callback for when it has finished processing. Each of these callbacks takes\n * two arguments: an `error`, and the transformed item from `obj`. If `iteratee`\n * passes an error to its callback, the main `callback` (for the `mapValues`\n * function) is immediately called with the error.\n *\n * Note, the order of the keys in the result is not guaranteed.  The keys will\n * be roughly in the order they complete, (but this is very engine-specific)\n *\n * @name mapValues\n * @static\n * @memberOf module:Collections\n * @method\n * @category Collection\n * @param {Object} obj - A collection to iterate over.\n * @param {AsyncFunction} iteratee - A function to apply to each value and key\n * in `coll`.\n * The iteratee should complete with the transformed value as its result.\n * Invoked with (value, key, callback).\n * @param {Function} [callback] - A callback which is called when all `iteratee`\n * functions have finished, or an error occurs. `result` is a new object consisting\n * of each key from `obj`, with each transformed value on the right-hand side.\n * Invoked with (err, result).\n * @example\n *\n * async.mapValues({\n *     f1: 'file1',\n *     f2: 'file2',\n *     f3: 'file3'\n * }, function (file, key, callback) {\n *   fs.stat(file, callback);\n * }, function(err, result) {\n *     // result is now a map of stats for each file, e.g.\n *     // {\n *     //     f1: [stats for file1],\n *     //     f2: [stats for file2],\n *     //     f3: [stats for file3]\n *     // }\n * });\n */\n\nvar mapValues = doLimit(mapValuesLimit, Infinity);\n\n/**\n * The same as [`mapValues`]{@link module:Collections.mapValues} but runs only a single async operation at a time.\n *\n * @name mapValuesSeries\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.mapValues]{@link module:Collections.mapValues}\n * @category Collection\n * @param {Object} obj - A collection to iterate over.\n * @param {AsyncFunction} iteratee - A function to apply to each value and key\n * in `coll`.\n * The iteratee should complete with the transformed value as its result.\n * Invoked with (value, key, callback).\n * @param {Function} [callback] - A callback which is called when all `iteratee`\n * functions have finished, or an error occurs. `result` is a new object consisting\n * of each key from `obj`, with each transformed value on the right-hand side.\n * Invoked with (err, result).\n */\nvar mapValuesSeries = doLimit(mapValuesLimit, 1);\n\nfunction has(obj, key) {\n    return key in obj;\n}\n\n/**\n * Caches the results of an async function. When creating a hash to store\n * function results against, the callback is omitted from the hash and an\n * optional hash function can be used.\n *\n * If no hash function is specified, the first argument is used as a hash key,\n * which may work reasonably if it is a string or a data type that converts to a\n * distinct string. Note that objects and arrays will not behave reasonably.\n * Neither will cases where the other arguments are significant. In such cases,\n * specify your own hash function.\n *\n * The cache of results is exposed as the `memo` property of the function\n * returned by `memoize`.\n *\n * @name memoize\n * @static\n * @memberOf module:Utils\n * @method\n * @category Util\n * @param {AsyncFunction} fn - The async function to proxy and cache results from.\n * @param {Function} hasher - An optional function for generating a custom hash\n * for storing results. It has all the arguments applied to it apart from the\n * callback, and must be synchronous.\n * @returns {AsyncFunction} a memoized version of `fn`\n * @example\n *\n * var slow_fn = function(name, callback) {\n *     // do something\n *     callback(null, result);\n * };\n * var fn = async.memoize(slow_fn);\n *\n * // fn can now be used as if it were slow_fn\n * fn('some name', function() {\n *     // callback\n * });\n */\nfunction memoize(fn, hasher) {\n    var memo = Object.create(null);\n    var queues = Object.create(null);\n    hasher = hasher || identity;\n    var _fn = wrapAsync(fn);\n    var memoized = initialParams(function memoized(args, callback) {\n        var key = hasher.apply(null, args);\n        if (has(memo, key)) {\n            setImmediate$1(function() {\n                callback.apply(null, memo[key]);\n            });\n        } else if (has(queues, key)) {\n            queues[key].push(callback);\n        } else {\n            queues[key] = [callback];\n            _fn.apply(null, args.concat(function(/*args*/) {\n                var args = slice(arguments);\n                memo[key] = args;\n                var q = queues[key];\n                delete queues[key];\n                for (var i = 0, l = q.length; i < l; i++) {\n                    q[i].apply(null, args);\n                }\n            }));\n        }\n    });\n    memoized.memo = memo;\n    memoized.unmemoized = fn;\n    return memoized;\n}\n\n/**\n * Calls `callback` on a later loop around the event loop. In Node.js this just\n * calls `process.nextTick`.  In the browser it will use `setImmediate` if\n * available, otherwise `setTimeout(callback, 0)`, which means other higher\n * priority events may precede the execution of `callback`.\n *\n * This is used internally for browser-compatibility purposes.\n *\n * @name nextTick\n * @static\n * @memberOf module:Utils\n * @method\n * @see [async.setImmediate]{@link module:Utils.setImmediate}\n * @category Util\n * @param {Function} callback - The function to call on a later loop around\n * the event loop. Invoked with (args...).\n * @param {...*} args... - any number of additional arguments to pass to the\n * callback on the next tick.\n * @example\n *\n * var call_order = [];\n * async.nextTick(function() {\n *     call_order.push('two');\n *     // call_order now equals ['one','two']\n * });\n * call_order.push('one');\n *\n * async.setImmediate(function (a, b, c) {\n *     // a, b, and c equal 1, 2, and 3\n * }, 1, 2, 3);\n */\nvar _defer$1;\n\nif (hasNextTick) {\n    _defer$1 = process.nextTick;\n} else if (hasSetImmediate) {\n    _defer$1 = setImmediate;\n} else {\n    _defer$1 = fallback;\n}\n\nvar nextTick = wrap(_defer$1);\n\nfunction _parallel(eachfn, tasks, callback) {\n    callback = callback || noop;\n    var results = isArrayLike(tasks) ? [] : {};\n\n    eachfn(tasks, function (task, key, callback) {\n        wrapAsync(task)(function (err, result) {\n            if (arguments.length > 2) {\n                result = slice(arguments, 1);\n            }\n            results[key] = result;\n            callback(err);\n        });\n    }, function (err) {\n        callback(err, results);\n    });\n}\n\n/**\n * Run the `tasks` collection of functions in parallel, without waiting until\n * the previous function has completed. If any of the functions pass an error to\n * its callback, the main `callback` is immediately called with the value of the\n * error. Once the `tasks` have completed, the results are passed to the final\n * `callback` as an array.\n *\n * **Note:** `parallel` is about kicking-off I/O tasks in parallel, not about\n * parallel execution of code.  If your tasks do not use any timers or perform\n * any I/O, they will actually be executed in series.  Any synchronous setup\n * sections for each task will happen one after the other.  JavaScript remains\n * single-threaded.\n *\n * **Hint:** Use [`reflect`]{@link module:Utils.reflect} to continue the\n * execution of other tasks when a task fails.\n *\n * It is also possible to use an object instead of an array. Each property will\n * be run as a function and the results will be passed to the final `callback`\n * as an object instead of an array. This can be a more readable way of handling\n * results from {@link async.parallel}.\n *\n * @name parallel\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @param {Array|Iterable|Object} tasks - A collection of\n * [async functions]{@link AsyncFunction} to run.\n * Each async function can complete with any number of optional `result` values.\n * @param {Function} [callback] - An optional callback to run once all the\n * functions have completed successfully. This function gets a results array\n * (or object) containing all the result arguments passed to the task callbacks.\n * Invoked with (err, results).\n *\n * @example\n * async.parallel([\n *     function(callback) {\n *         setTimeout(function() {\n *             callback(null, 'one');\n *         }, 200);\n *     },\n *     function(callback) {\n *         setTimeout(function() {\n *             callback(null, 'two');\n *         }, 100);\n *     }\n * ],\n * // optional callback\n * function(err, results) {\n *     // the results array will equal ['one','two'] even though\n *     // the second function had a shorter timeout.\n * });\n *\n * // an example using an object instead of an array\n * async.parallel({\n *     one: function(callback) {\n *         setTimeout(function() {\n *             callback(null, 1);\n *         }, 200);\n *     },\n *     two: function(callback) {\n *         setTimeout(function() {\n *             callback(null, 2);\n *         }, 100);\n *     }\n * }, function(err, results) {\n *     // results is now equals to: {one: 1, two: 2}\n * });\n */\nfunction parallelLimit(tasks, callback) {\n    _parallel(eachOf, tasks, callback);\n}\n\n/**\n * The same as [`parallel`]{@link module:ControlFlow.parallel} but runs a maximum of `limit` async operations at a\n * time.\n *\n * @name parallelLimit\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.parallel]{@link module:ControlFlow.parallel}\n * @category Control Flow\n * @param {Array|Iterable|Object} tasks - A collection of\n * [async functions]{@link AsyncFunction} to run.\n * Each async function can complete with any number of optional `result` values.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {Function} [callback] - An optional callback to run once all the\n * functions have completed successfully. This function gets a results array\n * (or object) containing all the result arguments passed to the task callbacks.\n * Invoked with (err, results).\n */\nfunction parallelLimit$1(tasks, limit, callback) {\n    _parallel(_eachOfLimit(limit), tasks, callback);\n}\n\n/**\n * A queue of tasks for the worker function to complete.\n * @typedef {Object} QueueObject\n * @memberOf module:ControlFlow\n * @property {Function} length - a function returning the number of items\n * waiting to be processed. Invoke with `queue.length()`.\n * @property {boolean} started - a boolean indicating whether or not any\n * items have been pushed and processed by the queue.\n * @property {Function} running - a function returning the number of items\n * currently being processed. Invoke with `queue.running()`.\n * @property {Function} workersList - a function returning the array of items\n * currently being processed. Invoke with `queue.workersList()`.\n * @property {Function} idle - a function returning false if there are items\n * waiting or being processed, or true if not. Invoke with `queue.idle()`.\n * @property {number} concurrency - an integer for determining how many `worker`\n * functions should be run in parallel. This property can be changed after a\n * `queue` is created to alter the concurrency on-the-fly.\n * @property {Function} push - add a new task to the `queue`. Calls `callback`\n * once the `worker` has finished processing the task. Instead of a single task,\n * a `tasks` array can be submitted. The respective callback is used for every\n * task in the list. Invoke with `queue.push(task, [callback])`,\n * @property {Function} unshift - add a new task to the front of the `queue`.\n * Invoke with `queue.unshift(task, [callback])`.\n * @property {Function} remove - remove items from the queue that match a test\n * function.  The test function will be passed an object with a `data` property,\n * and a `priority` property, if this is a\n * [priorityQueue]{@link module:ControlFlow.priorityQueue} object.\n * Invoked with `queue.remove(testFn)`, where `testFn` is of the form\n * `function ({data, priority}) {}` and returns a Boolean.\n * @property {Function} saturated - a callback that is called when the number of\n * running workers hits the `concurrency` limit, and further tasks will be\n * queued.\n * @property {Function} unsaturated - a callback that is called when the number\n * of running workers is less than the `concurrency` & `buffer` limits, and\n * further tasks will not be queued.\n * @property {number} buffer - A minimum threshold buffer in order to say that\n * the `queue` is `unsaturated`.\n * @property {Function} empty - a callback that is called when the last item\n * from the `queue` is given to a `worker`.\n * @property {Function} drain - a callback that is called when the last item\n * from the `queue` has returned from the `worker`.\n * @property {Function} error - a callback that is called when a task errors.\n * Has the signature `function(error, task)`.\n * @property {boolean} paused - a boolean for determining whether the queue is\n * in a paused state.\n * @property {Function} pause - a function that pauses the processing of tasks\n * until `resume()` is called. Invoke with `queue.pause()`.\n * @property {Function} resume - a function that resumes the processing of\n * queued tasks when the queue is paused. Invoke with `queue.resume()`.\n * @property {Function} kill - a function that removes the `drain` callback and\n * empties remaining tasks from the queue forcing it to go idle. No more tasks\n * should be pushed to the queue after calling this function. Invoke with `queue.kill()`.\n */\n\n/**\n * Creates a `queue` object with the specified `concurrency`. Tasks added to the\n * `queue` are processed in parallel (up to the `concurrency` limit). If all\n * `worker`s are in progress, the task is queued until one becomes available.\n * Once a `worker` completes a `task`, that `task`'s callback is called.\n *\n * @name queue\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @param {AsyncFunction} worker - An async function for processing a queued task.\n * If you want to handle errors from an individual task, pass a callback to\n * `q.push()`. Invoked with (task, callback).\n * @param {number} [concurrency=1] - An `integer` for determining how many\n * `worker` functions should be run in parallel.  If omitted, the concurrency\n * defaults to `1`.  If the concurrency is `0`, an error is thrown.\n * @returns {module:ControlFlow.QueueObject} A queue object to manage the tasks. Callbacks can\n * attached as certain properties to listen for specific events during the\n * lifecycle of the queue.\n * @example\n *\n * // create a queue object with concurrency 2\n * var q = async.queue(function(task, callback) {\n *     console.log('hello ' + task.name);\n *     callback();\n * }, 2);\n *\n * // assign a callback\n * q.drain = function() {\n *     console.log('all items have been processed');\n * };\n *\n * // add some items to the queue\n * q.push({name: 'foo'}, function(err) {\n *     console.log('finished processing foo');\n * });\n * q.push({name: 'bar'}, function (err) {\n *     console.log('finished processing bar');\n * });\n *\n * // add some items to the queue (batch-wise)\n * q.push([{name: 'baz'},{name: 'bay'},{name: 'bax'}], function(err) {\n *     console.log('finished processing item');\n * });\n *\n * // add some items to the front of the queue\n * q.unshift({name: 'bar'}, function (err) {\n *     console.log('finished processing bar');\n * });\n */\nvar queue$1 = function (worker, concurrency) {\n    var _worker = wrapAsync(worker);\n    return queue(function (items, cb) {\n        _worker(items[0], cb);\n    }, concurrency, 1);\n};\n\n/**\n * The same as [async.queue]{@link module:ControlFlow.queue} only tasks are assigned a priority and\n * completed in ascending priority order.\n *\n * @name priorityQueue\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.queue]{@link module:ControlFlow.queue}\n * @category Control Flow\n * @param {AsyncFunction} worker - An async function for processing a queued task.\n * If you want to handle errors from an individual task, pass a callback to\n * `q.push()`.\n * Invoked with (task, callback).\n * @param {number} concurrency - An `integer` for determining how many `worker`\n * functions should be run in parallel.  If omitted, the concurrency defaults to\n * `1`.  If the concurrency is `0`, an error is thrown.\n * @returns {module:ControlFlow.QueueObject} A priorityQueue object to manage the tasks. There are two\n * differences between `queue` and `priorityQueue` objects:\n * * `push(task, priority, [callback])` - `priority` should be a number. If an\n *   array of `tasks` is given, all tasks will be assigned the same priority.\n * * The `unshift` method was removed.\n */\nvar priorityQueue = function(worker, concurrency) {\n    // Start with a normal queue\n    var q = queue$1(worker, concurrency);\n\n    // Override push to accept second parameter representing priority\n    q.push = function(data, priority, callback) {\n        if (callback == null) callback = noop;\n        if (typeof callback !== 'function') {\n            throw new Error('task callback must be a function');\n        }\n        q.started = true;\n        if (!isArray(data)) {\n            data = [data];\n        }\n        if (data.length === 0) {\n            // call drain immediately if there are no tasks\n            return setImmediate$1(function() {\n                q.drain();\n            });\n        }\n\n        priority = priority || 0;\n        var nextNode = q._tasks.head;\n        while (nextNode && priority >= nextNode.priority) {\n            nextNode = nextNode.next;\n        }\n\n        for (var i = 0, l = data.length; i < l; i++) {\n            var item = {\n                data: data[i],\n                priority: priority,\n                callback: callback\n            };\n\n            if (nextNode) {\n                q._tasks.insertBefore(nextNode, item);\n            } else {\n                q._tasks.push(item);\n            }\n        }\n        setImmediate$1(q.process);\n    };\n\n    // Remove unshift function\n    delete q.unshift;\n\n    return q;\n};\n\n/**\n * Runs the `tasks` array of functions in parallel, without waiting until the\n * previous function has completed. Once any of the `tasks` complete or pass an\n * error to its callback, the main `callback` is immediately called. It's\n * equivalent to `Promise.race()`.\n *\n * @name race\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @param {Array} tasks - An array containing [async functions]{@link AsyncFunction}\n * to run. Each function can complete with an optional `result` value.\n * @param {Function} callback - A callback to run once any of the functions have\n * completed. This function gets an error or result from the first function that\n * completed. Invoked with (err, result).\n * @returns undefined\n * @example\n *\n * async.race([\n *     function(callback) {\n *         setTimeout(function() {\n *             callback(null, 'one');\n *         }, 200);\n *     },\n *     function(callback) {\n *         setTimeout(function() {\n *             callback(null, 'two');\n *         }, 100);\n *     }\n * ],\n * // main callback\n * function(err, result) {\n *     // the result will be equal to 'two' as it finishes earlier\n * });\n */\nfunction race(tasks, callback) {\n    callback = once(callback || noop);\n    if (!isArray(tasks)) return callback(new TypeError('First argument to race must be an array of functions'));\n    if (!tasks.length) return callback();\n    for (var i = 0, l = tasks.length; i < l; i++) {\n        wrapAsync(tasks[i])(callback);\n    }\n}\n\n/**\n * Same as [`reduce`]{@link module:Collections.reduce}, only operates on `array` in reverse order.\n *\n * @name reduceRight\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.reduce]{@link module:Collections.reduce}\n * @alias foldr\n * @category Collection\n * @param {Array} array - A collection to iterate over.\n * @param {*} memo - The initial state of the reduction.\n * @param {AsyncFunction} iteratee - A function applied to each item in the\n * array to produce the next step in the reduction.\n * The `iteratee` should complete with the next state of the reduction.\n * If the iteratee complete with an error, the reduction is stopped and the\n * main `callback` is immediately called with the error.\n * Invoked with (memo, item, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished. Result is the reduced value. Invoked with\n * (err, result).\n */\nfunction reduceRight (array, memo, iteratee, callback) {\n    var reversed = slice(array).reverse();\n    reduce(reversed, memo, iteratee, callback);\n}\n\n/**\n * Wraps the async function in another function that always completes with a\n * result object, even when it errors.\n *\n * The result object has either the property `error` or `value`.\n *\n * @name reflect\n * @static\n * @memberOf module:Utils\n * @method\n * @category Util\n * @param {AsyncFunction} fn - The async function you want to wrap\n * @returns {Function} - A function that always passes null to it's callback as\n * the error. The second argument to the callback will be an `object` with\n * either an `error` or a `value` property.\n * @example\n *\n * async.parallel([\n *     async.reflect(function(callback) {\n *         // do some stuff ...\n *         callback(null, 'one');\n *     }),\n *     async.reflect(function(callback) {\n *         // do some more stuff but error ...\n *         callback('bad stuff happened');\n *     }),\n *     async.reflect(function(callback) {\n *         // do some more stuff ...\n *         callback(null, 'two');\n *     })\n * ],\n * // optional callback\n * function(err, results) {\n *     // values\n *     // results[0].value = 'one'\n *     // results[1].error = 'bad stuff happened'\n *     // results[2].value = 'two'\n * });\n */\nfunction reflect(fn) {\n    var _fn = wrapAsync(fn);\n    return initialParams(function reflectOn(args, reflectCallback) {\n        args.push(function callback(error, cbArg) {\n            if (error) {\n                reflectCallback(null, { error: error });\n            } else {\n                var value;\n                if (arguments.length <= 2) {\n                    value = cbArg;\n                } else {\n                    value = slice(arguments, 1);\n                }\n                reflectCallback(null, { value: value });\n            }\n        });\n\n        return _fn.apply(this, args);\n    });\n}\n\n/**\n * A helper function that wraps an array or an object of functions with `reflect`.\n *\n * @name reflectAll\n * @static\n * @memberOf module:Utils\n * @method\n * @see [async.reflect]{@link module:Utils.reflect}\n * @category Util\n * @param {Array|Object|Iterable} tasks - The collection of\n * [async functions]{@link AsyncFunction} to wrap in `async.reflect`.\n * @returns {Array} Returns an array of async functions, each wrapped in\n * `async.reflect`\n * @example\n *\n * let tasks = [\n *     function(callback) {\n *         setTimeout(function() {\n *             callback(null, 'one');\n *         }, 200);\n *     },\n *     function(callback) {\n *         // do some more stuff but error ...\n *         callback(new Error('bad stuff happened'));\n *     },\n *     function(callback) {\n *         setTimeout(function() {\n *             callback(null, 'two');\n *         }, 100);\n *     }\n * ];\n *\n * async.parallel(async.reflectAll(tasks),\n * // optional callback\n * function(err, results) {\n *     // values\n *     // results[0].value = 'one'\n *     // results[1].error = Error('bad stuff happened')\n *     // results[2].value = 'two'\n * });\n *\n * // an example using an object instead of an array\n * let tasks = {\n *     one: function(callback) {\n *         setTimeout(function() {\n *             callback(null, 'one');\n *         }, 200);\n *     },\n *     two: function(callback) {\n *         callback('two');\n *     },\n *     three: function(callback) {\n *         setTimeout(function() {\n *             callback(null, 'three');\n *         }, 100);\n *     }\n * };\n *\n * async.parallel(async.reflectAll(tasks),\n * // optional callback\n * function(err, results) {\n *     // values\n *     // results.one.value = 'one'\n *     // results.two.error = 'two'\n *     // results.three.value = 'three'\n * });\n */\nfunction reflectAll(tasks) {\n    var results;\n    if (isArray(tasks)) {\n        results = arrayMap(tasks, reflect);\n    } else {\n        results = {};\n        baseForOwn(tasks, function(task, key) {\n            results[key] = reflect.call(this, task);\n        });\n    }\n    return results;\n}\n\nfunction reject$1(eachfn, arr, iteratee, callback) {\n    _filter(eachfn, arr, function(value, cb) {\n        iteratee(value, function(err, v) {\n            cb(err, !v);\n        });\n    }, callback);\n}\n\n/**\n * The opposite of [`filter`]{@link module:Collections.filter}. Removes values that pass an `async` truth test.\n *\n * @name reject\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.filter]{@link module:Collections.filter}\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {Function} iteratee - An async truth test to apply to each item in\n * `coll`.\n * The should complete with a boolean value as its `result`.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished. Invoked with (err, results).\n * @example\n *\n * async.reject(['file1','file2','file3'], function(filePath, callback) {\n *     fs.access(filePath, function(err) {\n *         callback(null, !err)\n *     });\n * }, function(err, results) {\n *     // results now equals an array of missing files\n *     createFiles(results);\n * });\n */\nvar reject = doParallel(reject$1);\n\n/**\n * The same as [`reject`]{@link module:Collections.reject} but runs a maximum of `limit` async operations at a\n * time.\n *\n * @name rejectLimit\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.reject]{@link module:Collections.reject}\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {Function} iteratee - An async truth test to apply to each item in\n * `coll`.\n * The should complete with a boolean value as its `result`.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished. Invoked with (err, results).\n */\nvar rejectLimit = doParallelLimit(reject$1);\n\n/**\n * The same as [`reject`]{@link module:Collections.reject} but runs only a single async operation at a time.\n *\n * @name rejectSeries\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.reject]{@link module:Collections.reject}\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {Function} iteratee - An async truth test to apply to each item in\n * `coll`.\n * The should complete with a boolean value as its `result`.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished. Invoked with (err, results).\n */\nvar rejectSeries = doLimit(rejectLimit, 1);\n\n/**\n * Creates a function that returns `value`.\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Util\n * @param {*} value The value to return from the new function.\n * @returns {Function} Returns the new constant function.\n * @example\n *\n * var objects = _.times(2, _.constant({ 'a': 1 }));\n *\n * console.log(objects);\n * // => [{ 'a': 1 }, { 'a': 1 }]\n *\n * console.log(objects[0] === objects[1]);\n * // => true\n */\nfunction constant$1(value) {\n  return function() {\n    return value;\n  };\n}\n\n/**\n * Attempts to get a successful response from `task` no more than `times` times\n * before returning an error. If the task is successful, the `callback` will be\n * passed the result of the successful task. If all attempts fail, the callback\n * will be passed the error and result (if any) of the final attempt.\n *\n * @name retry\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @see [async.retryable]{@link module:ControlFlow.retryable}\n * @param {Object|number} [opts = {times: 5, interval: 0}| 5] - Can be either an\n * object with `times` and `interval` or a number.\n * * `times` - The number of attempts to make before giving up.  The default\n *   is `5`.\n * * `interval` - The time to wait between retries, in milliseconds.  The\n *   default is `0`. The interval may also be specified as a function of the\n *   retry count (see example).\n * * `errorFilter` - An optional synchronous function that is invoked on\n *   erroneous result. If it returns `true` the retry attempts will continue;\n *   if the function returns `false` the retry flow is aborted with the current\n *   attempt's error and result being returned to the final callback.\n *   Invoked with (err).\n * * If `opts` is a number, the number specifies the number of times to retry,\n *   with the default interval of `0`.\n * @param {AsyncFunction} task - An async function to retry.\n * Invoked with (callback).\n * @param {Function} [callback] - An optional callback which is called when the\n * task has succeeded, or after the final failed attempt. It receives the `err`\n * and `result` arguments of the last attempt at completing the `task`. Invoked\n * with (err, results).\n *\n * @example\n *\n * // The `retry` function can be used as a stand-alone control flow by passing\n * // a callback, as shown below:\n *\n * // try calling apiMethod 3 times\n * async.retry(3, apiMethod, function(err, result) {\n *     // do something with the result\n * });\n *\n * // try calling apiMethod 3 times, waiting 200 ms between each retry\n * async.retry({times: 3, interval: 200}, apiMethod, function(err, result) {\n *     // do something with the result\n * });\n *\n * // try calling apiMethod 10 times with exponential backoff\n * // (i.e. intervals of 100, 200, 400, 800, 1600, ... milliseconds)\n * async.retry({\n *   times: 10,\n *   interval: function(retryCount) {\n *     return 50 * Math.pow(2, retryCount);\n *   }\n * }, apiMethod, function(err, result) {\n *     // do something with the result\n * });\n *\n * // try calling apiMethod the default 5 times no delay between each retry\n * async.retry(apiMethod, function(err, result) {\n *     // do something with the result\n * });\n *\n * // try calling apiMethod only when error condition satisfies, all other\n * // errors will abort the retry control flow and return to final callback\n * async.retry({\n *   errorFilter: function(err) {\n *     return err.message === 'Temporary error'; // only retry on a specific error\n *   }\n * }, apiMethod, function(err, result) {\n *     // do something with the result\n * });\n *\n * // to retry individual methods that are not as reliable within other\n * // control flow functions, use the `retryable` wrapper:\n * async.auto({\n *     users: api.getUsers.bind(api),\n *     payments: async.retryable(3, api.getPayments.bind(api))\n * }, function(err, results) {\n *     // do something with the results\n * });\n *\n */\nfunction retry(opts, task, callback) {\n    var DEFAULT_TIMES = 5;\n    var DEFAULT_INTERVAL = 0;\n\n    var options = {\n        times: DEFAULT_TIMES,\n        intervalFunc: constant$1(DEFAULT_INTERVAL)\n    };\n\n    function parseTimes(acc, t) {\n        if (typeof t === 'object') {\n            acc.times = +t.times || DEFAULT_TIMES;\n\n            acc.intervalFunc = typeof t.interval === 'function' ?\n                t.interval :\n                constant$1(+t.interval || DEFAULT_INTERVAL);\n\n            acc.errorFilter = t.errorFilter;\n        } else if (typeof t === 'number' || typeof t === 'string') {\n            acc.times = +t || DEFAULT_TIMES;\n        } else {\n            throw new Error(\"Invalid arguments for async.retry\");\n        }\n    }\n\n    if (arguments.length < 3 && typeof opts === 'function') {\n        callback = task || noop;\n        task = opts;\n    } else {\n        parseTimes(options, opts);\n        callback = callback || noop;\n    }\n\n    if (typeof task !== 'function') {\n        throw new Error(\"Invalid arguments for async.retry\");\n    }\n\n    var _task = wrapAsync(task);\n\n    var attempt = 1;\n    function retryAttempt() {\n        _task(function(err) {\n            if (err && attempt++ < options.times &&\n                (typeof options.errorFilter != 'function' ||\n                    options.errorFilter(err))) {\n                setTimeout(retryAttempt, options.intervalFunc(attempt));\n            } else {\n                callback.apply(null, arguments);\n            }\n        });\n    }\n\n    retryAttempt();\n}\n\n/**\n * A close relative of [`retry`]{@link module:ControlFlow.retry}.  This method\n * wraps a task and makes it retryable, rather than immediately calling it\n * with retries.\n *\n * @name retryable\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.retry]{@link module:ControlFlow.retry}\n * @category Control Flow\n * @param {Object|number} [opts = {times: 5, interval: 0}| 5] - optional\n * options, exactly the same as from `retry`\n * @param {AsyncFunction} task - the asynchronous function to wrap.\n * This function will be passed any arguments passed to the returned wrapper.\n * Invoked with (...args, callback).\n * @returns {AsyncFunction} The wrapped function, which when invoked, will\n * retry on an error, based on the parameters specified in `opts`.\n * This function will accept the same parameters as `task`.\n * @example\n *\n * async.auto({\n *     dep1: async.retryable(3, getFromFlakyService),\n *     process: [\"dep1\", async.retryable(3, function (results, cb) {\n *         maybeProcessData(results.dep1, cb);\n *     })]\n * }, callback);\n */\nvar retryable = function (opts, task) {\n    if (!task) {\n        task = opts;\n        opts = null;\n    }\n    var _task = wrapAsync(task);\n    return initialParams(function (args, callback) {\n        function taskFn(cb) {\n            _task.apply(null, args.concat(cb));\n        }\n\n        if (opts) retry(opts, taskFn, callback);\n        else retry(taskFn, callback);\n\n    });\n};\n\n/**\n * Run the functions in the `tasks` collection in series, each one running once\n * the previous function has completed. If any functions in the series pass an\n * error to its callback, no more functions are run, and `callback` is\n * immediately called with the value of the error. Otherwise, `callback`\n * receives an array of results when `tasks` have completed.\n *\n * It is also possible to use an object instead of an array. Each property will\n * be run as a function, and the results will be passed to the final `callback`\n * as an object instead of an array. This can be a more readable way of handling\n *  results from {@link async.series}.\n *\n * **Note** that while many implementations preserve the order of object\n * properties, the [ECMAScript Language Specification](http://www.ecma-international.org/ecma-262/5.1/#sec-8.6)\n * explicitly states that\n *\n * > The mechanics and order of enumerating the properties is not specified.\n *\n * So if you rely on the order in which your series of functions are executed,\n * and want this to work on all platforms, consider using an array.\n *\n * @name series\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @param {Array|Iterable|Object} tasks - A collection containing\n * [async functions]{@link AsyncFunction} to run in series.\n * Each function can complete with any number of optional `result` values.\n * @param {Function} [callback] - An optional callback to run once all the\n * functions have completed. This function gets a results array (or object)\n * containing all the result arguments passed to the `task` callbacks. Invoked\n * with (err, result).\n * @example\n * async.series([\n *     function(callback) {\n *         // do some stuff ...\n *         callback(null, 'one');\n *     },\n *     function(callback) {\n *         // do some more stuff ...\n *         callback(null, 'two');\n *     }\n * ],\n * // optional callback\n * function(err, results) {\n *     // results is now equal to ['one', 'two']\n * });\n *\n * async.series({\n *     one: function(callback) {\n *         setTimeout(function() {\n *             callback(null, 1);\n *         }, 200);\n *     },\n *     two: function(callback){\n *         setTimeout(function() {\n *             callback(null, 2);\n *         }, 100);\n *     }\n * }, function(err, results) {\n *     // results is now equal to: {one: 1, two: 2}\n * });\n */\nfunction series(tasks, callback) {\n    _parallel(eachOfSeries, tasks, callback);\n}\n\n/**\n * Returns `true` if at least one element in the `coll` satisfies an async test.\n * If any iteratee call returns `true`, the main `callback` is immediately\n * called.\n *\n * @name some\n * @static\n * @memberOf module:Collections\n * @method\n * @alias any\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - An async truth test to apply to each item\n * in the collections in parallel.\n * The iteratee should complete with a boolean `result` value.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called as soon as any\n * iteratee returns `true`, or after all the iteratee functions have finished.\n * Result will be either `true` or `false` depending on the values of the async\n * tests. Invoked with (err, result).\n * @example\n *\n * async.some(['file1','file2','file3'], function(filePath, callback) {\n *     fs.access(filePath, function(err) {\n *         callback(null, !err)\n *     });\n * }, function(err, result) {\n *     // if result is true then at least one of the files exists\n * });\n */\nvar some = doParallel(_createTester(Boolean, identity));\n\n/**\n * The same as [`some`]{@link module:Collections.some} but runs a maximum of `limit` async operations at a time.\n *\n * @name someLimit\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.some]{@link module:Collections.some}\n * @alias anyLimit\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {AsyncFunction} iteratee - An async truth test to apply to each item\n * in the collections in parallel.\n * The iteratee should complete with a boolean `result` value.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called as soon as any\n * iteratee returns `true`, or after all the iteratee functions have finished.\n * Result will be either `true` or `false` depending on the values of the async\n * tests. Invoked with (err, result).\n */\nvar someLimit = doParallelLimit(_createTester(Boolean, identity));\n\n/**\n * The same as [`some`]{@link module:Collections.some} but runs only a single async operation at a time.\n *\n * @name someSeries\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.some]{@link module:Collections.some}\n * @alias anySeries\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - An async truth test to apply to each item\n * in the collections in series.\n * The iteratee should complete with a boolean `result` value.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called as soon as any\n * iteratee returns `true`, or after all the iteratee functions have finished.\n * Result will be either `true` or `false` depending on the values of the async\n * tests. Invoked with (err, result).\n */\nvar someSeries = doLimit(someLimit, 1);\n\n/**\n * Sorts a list by the results of running each `coll` value through an async\n * `iteratee`.\n *\n * @name sortBy\n * @static\n * @memberOf module:Collections\n * @method\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - An async function to apply to each item in\n * `coll`.\n * The iteratee should complete with a value to use as the sort criteria as\n * its `result`.\n * Invoked with (item, callback).\n * @param {Function} callback - A callback which is called after all the\n * `iteratee` functions have finished, or an error occurs. Results is the items\n * from the original `coll` sorted by the values returned by the `iteratee`\n * calls. Invoked with (err, results).\n * @example\n *\n * async.sortBy(['file1','file2','file3'], function(file, callback) {\n *     fs.stat(file, function(err, stats) {\n *         callback(err, stats.mtime);\n *     });\n * }, function(err, results) {\n *     // results is now the original array of files sorted by\n *     // modified date\n * });\n *\n * // By modifying the callback parameter the\n * // sorting order can be influenced:\n *\n * // ascending order\n * async.sortBy([1,9,3,5], function(x, callback) {\n *     callback(null, x);\n * }, function(err,result) {\n *     // result callback\n * });\n *\n * // descending order\n * async.sortBy([1,9,3,5], function(x, callback) {\n *     callback(null, x*-1);    //<- x*-1 instead of x, turns the order around\n * }, function(err,result) {\n *     // result callback\n * });\n */\nfunction sortBy (coll, iteratee, callback) {\n    var _iteratee = wrapAsync(iteratee);\n    map(coll, function (x, callback) {\n        _iteratee(x, function (err, criteria) {\n            if (err) return callback(err);\n            callback(null, {value: x, criteria: criteria});\n        });\n    }, function (err, results) {\n        if (err) return callback(err);\n        callback(null, arrayMap(results.sort(comparator), baseProperty('value')));\n    });\n\n    function comparator(left, right) {\n        var a = left.criteria, b = right.criteria;\n        return a < b ? -1 : a > b ? 1 : 0;\n    }\n}\n\n/**\n * Sets a time limit on an asynchronous function. If the function does not call\n * its callback within the specified milliseconds, it will be called with a\n * timeout error. The code property for the error object will be `'ETIMEDOUT'`.\n *\n * @name timeout\n * @static\n * @memberOf module:Utils\n * @method\n * @category Util\n * @param {AsyncFunction} asyncFn - The async function to limit in time.\n * @param {number} milliseconds - The specified time limit.\n * @param {*} [info] - Any variable you want attached (`string`, `object`, etc)\n * to timeout Error for more information..\n * @returns {AsyncFunction} Returns a wrapped function that can be used with any\n * of the control flow functions.\n * Invoke this function with the same parameters as you would `asyncFunc`.\n * @example\n *\n * function myFunction(foo, callback) {\n *     doAsyncTask(foo, function(err, data) {\n *         // handle errors\n *         if (err) return callback(err);\n *\n *         // do some stuff ...\n *\n *         // return processed data\n *         return callback(null, data);\n *     });\n * }\n *\n * var wrapped = async.timeout(myFunction, 1000);\n *\n * // call `wrapped` as you would `myFunction`\n * wrapped({ bar: 'bar' }, function(err, data) {\n *     // if `myFunction` takes < 1000 ms to execute, `err`\n *     // and `data` will have their expected values\n *\n *     // else `err` will be an Error with the code 'ETIMEDOUT'\n * });\n */\nfunction timeout(asyncFn, milliseconds, info) {\n    var fn = wrapAsync(asyncFn);\n\n    return initialParams(function (args, callback) {\n        var timedOut = false;\n        var timer;\n\n        function timeoutCallback() {\n            var name = asyncFn.name || 'anonymous';\n            var error  = new Error('Callback function \"' + name + '\" timed out.');\n            error.code = 'ETIMEDOUT';\n            if (info) {\n                error.info = info;\n            }\n            timedOut = true;\n            callback(error);\n        }\n\n        args.push(function () {\n            if (!timedOut) {\n                callback.apply(null, arguments);\n                clearTimeout(timer);\n            }\n        });\n\n        // setup timer and call original function\n        timer = setTimeout(timeoutCallback, milliseconds);\n        fn.apply(null, args);\n    });\n}\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeCeil = Math.ceil;\nvar nativeMax = Math.max;\n\n/**\n * The base implementation of `_.range` and `_.rangeRight` which doesn't\n * coerce arguments.\n *\n * @private\n * @param {number} start The start of the range.\n * @param {number} end The end of the range.\n * @param {number} step The value to increment or decrement by.\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {Array} Returns the range of numbers.\n */\nfunction baseRange(start, end, step, fromRight) {\n  var index = -1,\n      length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),\n      result = Array(length);\n\n  while (length--) {\n    result[fromRight ? length : ++index] = start;\n    start += step;\n  }\n  return result;\n}\n\n/**\n * The same as [times]{@link module:ControlFlow.times} but runs a maximum of `limit` async operations at a\n * time.\n *\n * @name timesLimit\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.times]{@link module:ControlFlow.times}\n * @category Control Flow\n * @param {number} count - The number of times to run the function.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {AsyncFunction} iteratee - The async function to call `n` times.\n * Invoked with the iteration index and a callback: (n, next).\n * @param {Function} callback - see [async.map]{@link module:Collections.map}.\n */\nfunction timeLimit(count, limit, iteratee, callback) {\n    var _iteratee = wrapAsync(iteratee);\n    mapLimit(baseRange(0, count, 1), limit, _iteratee, callback);\n}\n\n/**\n * Calls the `iteratee` function `n` times, and accumulates results in the same\n * manner you would use with [map]{@link module:Collections.map}.\n *\n * @name times\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.map]{@link module:Collections.map}\n * @category Control Flow\n * @param {number} n - The number of times to run the function.\n * @param {AsyncFunction} iteratee - The async function to call `n` times.\n * Invoked with the iteration index and a callback: (n, next).\n * @param {Function} callback - see {@link module:Collections.map}.\n * @example\n *\n * // Pretend this is some complicated async factory\n * var createUser = function(id, callback) {\n *     callback(null, {\n *         id: 'user' + id\n *     });\n * };\n *\n * // generate 5 users\n * async.times(5, function(n, next) {\n *     createUser(n, function(err, user) {\n *         next(err, user);\n *     });\n * }, function(err, users) {\n *     // we should now have 5 users\n * });\n */\nvar times = doLimit(timeLimit, Infinity);\n\n/**\n * The same as [times]{@link module:ControlFlow.times} but runs only a single async operation at a time.\n *\n * @name timesSeries\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.times]{@link module:ControlFlow.times}\n * @category Control Flow\n * @param {number} n - The number of times to run the function.\n * @param {AsyncFunction} iteratee - The async function to call `n` times.\n * Invoked with the iteration index and a callback: (n, next).\n * @param {Function} callback - see {@link module:Collections.map}.\n */\nvar timesSeries = doLimit(timeLimit, 1);\n\n/**\n * A relative of `reduce`.  Takes an Object or Array, and iterates over each\n * element in series, each step potentially mutating an `accumulator` value.\n * The type of the accumulator defaults to the type of collection passed in.\n *\n * @name transform\n * @static\n * @memberOf module:Collections\n * @method\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {*} [accumulator] - The initial state of the transform.  If omitted,\n * it will default to an empty Object or Array, depending on the type of `coll`\n * @param {AsyncFunction} iteratee - A function applied to each item in the\n * collection that potentially modifies the accumulator.\n * Invoked with (accumulator, item, key, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished. Result is the transformed accumulator.\n * Invoked with (err, result).\n * @example\n *\n * async.transform([1,2,3], function(acc, item, index, callback) {\n *     // pointless async:\n *     process.nextTick(function() {\n *         acc.push(item * 2)\n *         callback(null)\n *     });\n * }, function(err, result) {\n *     // result is now equal to [2, 4, 6]\n * });\n *\n * @example\n *\n * async.transform({a: 1, b: 2, c: 3}, function (obj, val, key, callback) {\n *     setImmediate(function () {\n *         obj[key] = val * 2;\n *         callback();\n *     })\n * }, function (err, result) {\n *     // result is equal to {a: 2, b: 4, c: 6}\n * })\n */\nfunction transform (coll, accumulator, iteratee, callback) {\n    if (arguments.length <= 3) {\n        callback = iteratee;\n        iteratee = accumulator;\n        accumulator = isArray(coll) ? [] : {};\n    }\n    callback = once(callback || noop);\n    var _iteratee = wrapAsync(iteratee);\n\n    eachOf(coll, function(v, k, cb) {\n        _iteratee(accumulator, v, k, cb);\n    }, function(err) {\n        callback(err, accumulator);\n    });\n}\n\n/**\n * It runs each task in series but stops whenever any of the functions were\n * successful. If one of the tasks were successful, the `callback` will be\n * passed the result of the successful task. If all tasks fail, the callback\n * will be passed the error and result (if any) of the final attempt.\n *\n * @name tryEach\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @param {Array|Iterable|Object} tasks - A collection containing functions to\n * run, each function is passed a `callback(err, result)` it must call on\n * completion with an error `err` (which can be `null`) and an optional `result`\n * value.\n * @param {Function} [callback] - An optional callback which is called when one\n * of the tasks has succeeded, or all have failed. It receives the `err` and\n * `result` arguments of the last attempt at completing the `task`. Invoked with\n * (err, results).\n * @example\n * async.tryEach([\n *     function getDataFromFirstWebsite(callback) {\n *         // Try getting the data from the first website\n *         callback(err, data);\n *     },\n *     function getDataFromSecondWebsite(callback) {\n *         // First website failed,\n *         // Try getting the data from the backup website\n *         callback(err, data);\n *     }\n * ],\n * // optional callback\n * function(err, results) {\n *     Now do something with the data.\n * });\n *\n */\nfunction tryEach(tasks, callback) {\n    var error = null;\n    var result;\n    callback = callback || noop;\n    eachSeries(tasks, function(task, callback) {\n        wrapAsync(task)(function (err, res/*, ...args*/) {\n            if (arguments.length > 2) {\n                result = slice(arguments, 1);\n            } else {\n                result = res;\n            }\n            error = err;\n            callback(!err);\n        });\n    }, function () {\n        callback(error, result);\n    });\n}\n\n/**\n * Undoes a [memoize]{@link module:Utils.memoize}d function, reverting it to the original,\n * unmemoized form. Handy for testing.\n *\n * @name unmemoize\n * @static\n * @memberOf module:Utils\n * @method\n * @see [async.memoize]{@link module:Utils.memoize}\n * @category Util\n * @param {AsyncFunction} fn - the memoized function\n * @returns {AsyncFunction} a function that calls the original unmemoized function\n */\nfunction unmemoize(fn) {\n    return function () {\n        return (fn.unmemoized || fn).apply(null, arguments);\n    };\n}\n\n/**\n * Repeatedly call `iteratee`, while `test` returns `true`. Calls `callback` when\n * stopped, or an error occurs.\n *\n * @name whilst\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @param {Function} test - synchronous truth test to perform before each\n * execution of `iteratee`. Invoked with ().\n * @param {AsyncFunction} iteratee - An async function which is called each time\n * `test` passes. Invoked with (callback).\n * @param {Function} [callback] - A callback which is called after the test\n * function has failed and repeated execution of `iteratee` has stopped. `callback`\n * will be passed an error and any arguments passed to the final `iteratee`'s\n * callback. Invoked with (err, [results]);\n * @returns undefined\n * @example\n *\n * var count = 0;\n * async.whilst(\n *     function() { return count < 5; },\n *     function(callback) {\n *         count++;\n *         setTimeout(function() {\n *             callback(null, count);\n *         }, 1000);\n *     },\n *     function (err, n) {\n *         // 5 seconds have passed, n = 5\n *     }\n * );\n */\nfunction whilst(test, iteratee, callback) {\n    callback = onlyOnce(callback || noop);\n    var _iteratee = wrapAsync(iteratee);\n    if (!test()) return callback(null);\n    var next = function(err/*, ...args*/) {\n        if (err) return callback(err);\n        if (test()) return _iteratee(next);\n        var args = slice(arguments, 1);\n        callback.apply(null, [null].concat(args));\n    };\n    _iteratee(next);\n}\n\n/**\n * Repeatedly call `iteratee` until `test` returns `true`. Calls `callback` when\n * stopped, or an error occurs. `callback` will be passed an error and any\n * arguments passed to the final `iteratee`'s callback.\n *\n * The inverse of [whilst]{@link module:ControlFlow.whilst}.\n *\n * @name until\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.whilst]{@link module:ControlFlow.whilst}\n * @category Control Flow\n * @param {Function} test - synchronous truth test to perform before each\n * execution of `iteratee`. Invoked with ().\n * @param {AsyncFunction} iteratee - An async function which is called each time\n * `test` fails. Invoked with (callback).\n * @param {Function} [callback] - A callback which is called after the test\n * function has passed and repeated execution of `iteratee` has stopped. `callback`\n * will be passed an error and any arguments passed to the final `iteratee`'s\n * callback. Invoked with (err, [results]);\n */\nfunction until(test, iteratee, callback) {\n    whilst(function() {\n        return !test.apply(this, arguments);\n    }, iteratee, callback);\n}\n\n/**\n * Runs the `tasks` array of functions in series, each passing their results to\n * the next in the array. However, if any of the `tasks` pass an error to their\n * own callback, the next function is not executed, and the main `callback` is\n * immediately called with the error.\n *\n * @name waterfall\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @param {Array} tasks - An array of [async functions]{@link AsyncFunction}\n * to run.\n * Each function should complete with any number of `result` values.\n * The `result` values will be passed as arguments, in order, to the next task.\n * @param {Function} [callback] - An optional callback to run once all the\n * functions have completed. This will be passed the results of the last task's\n * callback. Invoked with (err, [results]).\n * @returns undefined\n * @example\n *\n * async.waterfall([\n *     function(callback) {\n *         callback(null, 'one', 'two');\n *     },\n *     function(arg1, arg2, callback) {\n *         // arg1 now equals 'one' and arg2 now equals 'two'\n *         callback(null, 'three');\n *     },\n *     function(arg1, callback) {\n *         // arg1 now equals 'three'\n *         callback(null, 'done');\n *     }\n * ], function (err, result) {\n *     // result now equals 'done'\n * });\n *\n * // Or, with named functions:\n * async.waterfall([\n *     myFirstFunction,\n *     mySecondFunction,\n *     myLastFunction,\n * ], function (err, result) {\n *     // result now equals 'done'\n * });\n * function myFirstFunction(callback) {\n *     callback(null, 'one', 'two');\n * }\n * function mySecondFunction(arg1, arg2, callback) {\n *     // arg1 now equals 'one' and arg2 now equals 'two'\n *     callback(null, 'three');\n * }\n * function myLastFunction(arg1, callback) {\n *     // arg1 now equals 'three'\n *     callback(null, 'done');\n * }\n */\nvar waterfall = function(tasks, callback) {\n    callback = once(callback || noop);\n    if (!isArray(tasks)) return callback(new Error('First argument to waterfall must be an array of functions'));\n    if (!tasks.length) return callback();\n    var taskIndex = 0;\n\n    function nextTask(args) {\n        var task = wrapAsync(tasks[taskIndex++]);\n        args.push(onlyOnce(next));\n        task.apply(null, args);\n    }\n\n    function next(err/*, ...args*/) {\n        if (err || taskIndex === tasks.length) {\n            return callback.apply(null, arguments);\n        }\n        nextTask(slice(arguments, 1));\n    }\n\n    nextTask([]);\n};\n\n/**\n * An \"async function\" in the context of Async is an asynchronous function with\n * a variable number of parameters, with the final parameter being a callback.\n * (`function (arg1, arg2, ..., callback) {}`)\n * The final callback is of the form `callback(err, results...)`, which must be\n * called once the function is completed.  The callback should be called with a\n * Error as its first argument to signal that an error occurred.\n * Otherwise, if no error occurred, it should be called with `null` as the first\n * argument, and any additional `result` arguments that may apply, to signal\n * successful completion.\n * The callback must be called exactly once, ideally on a later tick of the\n * JavaScript event loop.\n *\n * This type of function is also referred to as a \"Node-style async function\",\n * or a \"continuation passing-style function\" (CPS). Most of the methods of this\n * library are themselves CPS/Node-style async functions, or functions that\n * return CPS/Node-style async functions.\n *\n * Wherever we accept a Node-style async function, we also directly accept an\n * [ES2017 `async` function]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function}.\n * In this case, the `async` function will not be passed a final callback\n * argument, and any thrown error will be used as the `err` argument of the\n * implicit callback, and the return value will be used as the `result` value.\n * (i.e. a `rejected` of the returned Promise becomes the `err` callback\n * argument, and a `resolved` value becomes the `result`.)\n *\n * Note, due to JavaScript limitations, we can only detect native `async`\n * functions and not transpilied implementations.\n * Your environment must have `async`/`await` support for this to work.\n * (e.g. Node > v7.6, or a recent version of a modern browser).\n * If you are using `async` functions through a transpiler (e.g. Babel), you\n * must still wrap the function with [asyncify]{@link module:Utils.asyncify},\n * because the `async function` will be compiled to an ordinary function that\n * returns a promise.\n *\n * @typedef {Function} AsyncFunction\n * @static\n */\n\n/**\n * Async is a utility module which provides straight-forward, powerful functions\n * for working with asynchronous JavaScript. Although originally designed for\n * use with [Node.js](http://nodejs.org) and installable via\n * `npm install --save async`, it can also be used directly in the browser.\n * @module async\n * @see AsyncFunction\n */\n\n\n/**\n * A collection of `async` functions for manipulating collections, such as\n * arrays and objects.\n * @module Collections\n */\n\n/**\n * A collection of `async` functions for controlling the flow through a script.\n * @module ControlFlow\n */\n\n/**\n * A collection of `async` utility functions.\n * @module Utils\n */\n\nvar index = {\n    apply: apply,\n    applyEach: applyEach,\n    applyEachSeries: applyEachSeries,\n    asyncify: asyncify,\n    auto: auto,\n    autoInject: autoInject,\n    cargo: cargo,\n    compose: compose,\n    concat: concat,\n    concatLimit: concatLimit,\n    concatSeries: concatSeries,\n    constant: constant,\n    detect: detect,\n    detectLimit: detectLimit,\n    detectSeries: detectSeries,\n    dir: dir,\n    doDuring: doDuring,\n    doUntil: doUntil,\n    doWhilst: doWhilst,\n    during: during,\n    each: eachLimit,\n    eachLimit: eachLimit$1,\n    eachOf: eachOf,\n    eachOfLimit: eachOfLimit,\n    eachOfSeries: eachOfSeries,\n    eachSeries: eachSeries,\n    ensureAsync: ensureAsync,\n    every: every,\n    everyLimit: everyLimit,\n    everySeries: everySeries,\n    filter: filter,\n    filterLimit: filterLimit,\n    filterSeries: filterSeries,\n    forever: forever,\n    groupBy: groupBy,\n    groupByLimit: groupByLimit,\n    groupBySeries: groupBySeries,\n    log: log,\n    map: map,\n    mapLimit: mapLimit,\n    mapSeries: mapSeries,\n    mapValues: mapValues,\n    mapValuesLimit: mapValuesLimit,\n    mapValuesSeries: mapValuesSeries,\n    memoize: memoize,\n    nextTick: nextTick,\n    parallel: parallelLimit,\n    parallelLimit: parallelLimit$1,\n    priorityQueue: priorityQueue,\n    queue: queue$1,\n    race: race,\n    reduce: reduce,\n    reduceRight: reduceRight,\n    reflect: reflect,\n    reflectAll: reflectAll,\n    reject: reject,\n    rejectLimit: rejectLimit,\n    rejectSeries: rejectSeries,\n    retry: retry,\n    retryable: retryable,\n    seq: seq,\n    series: series,\n    setImmediate: setImmediate$1,\n    some: some,\n    someLimit: someLimit,\n    someSeries: someSeries,\n    sortBy: sortBy,\n    timeout: timeout,\n    times: times,\n    timesLimit: timeLimit,\n    timesSeries: timesSeries,\n    transform: transform,\n    tryEach: tryEach,\n    unmemoize: unmemoize,\n    until: until,\n    waterfall: waterfall,\n    whilst: whilst,\n\n    // aliases\n    all: every,\n    allLimit: everyLimit,\n    allSeries: everySeries,\n    any: some,\n    anyLimit: someLimit,\n    anySeries: someSeries,\n    find: detect,\n    findLimit: detectLimit,\n    findSeries: detectSeries,\n    forEach: eachLimit,\n    forEachSeries: eachSeries,\n    forEachLimit: eachLimit$1,\n    forEachOf: eachOf,\n    forEachOfSeries: eachOfSeries,\n    forEachOfLimit: eachOfLimit,\n    inject: reduce,\n    foldl: reduce,\n    foldr: reduceRight,\n    select: filter,\n    selectLimit: filterLimit,\n    selectSeries: filterSeries,\n    wrapSync: asyncify\n};\n\nexports['default'] = index;\nexports.apply = apply;\nexports.applyEach = applyEach;\nexports.applyEachSeries = applyEachSeries;\nexports.asyncify = asyncify;\nexports.auto = auto;\nexports.autoInject = autoInject;\nexports.cargo = cargo;\nexports.compose = compose;\nexports.concat = concat;\nexports.concatLimit = concatLimit;\nexports.concatSeries = concatSeries;\nexports.constant = constant;\nexports.detect = detect;\nexports.detectLimit = detectLimit;\nexports.detectSeries = detectSeries;\nexports.dir = dir;\nexports.doDuring = doDuring;\nexports.doUntil = doUntil;\nexports.doWhilst = doWhilst;\nexports.during = during;\nexports.each = eachLimit;\nexports.eachLimit = eachLimit$1;\nexports.eachOf = eachOf;\nexports.eachOfLimit = eachOfLimit;\nexports.eachOfSeries = eachOfSeries;\nexports.eachSeries = eachSeries;\nexports.ensureAsync = ensureAsync;\nexports.every = every;\nexports.everyLimit = everyLimit;\nexports.everySeries = everySeries;\nexports.filter = filter;\nexports.filterLimit = filterLimit;\nexports.filterSeries = filterSeries;\nexports.forever = forever;\nexports.groupBy = groupBy;\nexports.groupByLimit = groupByLimit;\nexports.groupBySeries = groupBySeries;\nexports.log = log;\nexports.map = map;\nexports.mapLimit = mapLimit;\nexports.mapSeries = mapSeries;\nexports.mapValues = mapValues;\nexports.mapValuesLimit = mapValuesLimit;\nexports.mapValuesSeries = mapValuesSeries;\nexports.memoize = memoize;\nexports.nextTick = nextTick;\nexports.parallel = parallelLimit;\nexports.parallelLimit = parallelLimit$1;\nexports.priorityQueue = priorityQueue;\nexports.queue = queue$1;\nexports.race = race;\nexports.reduce = reduce;\nexports.reduceRight = reduceRight;\nexports.reflect = reflect;\nexports.reflectAll = reflectAll;\nexports.reject = reject;\nexports.rejectLimit = rejectLimit;\nexports.rejectSeries = rejectSeries;\nexports.retry = retry;\nexports.retryable = retryable;\nexports.seq = seq;\nexports.series = series;\nexports.setImmediate = setImmediate$1;\nexports.some = some;\nexports.someLimit = someLimit;\nexports.someSeries = someSeries;\nexports.sortBy = sortBy;\nexports.timeout = timeout;\nexports.times = times;\nexports.timesLimit = timeLimit;\nexports.timesSeries = timesSeries;\nexports.transform = transform;\nexports.tryEach = tryEach;\nexports.unmemoize = unmemoize;\nexports.until = until;\nexports.waterfall = waterfall;\nexports.whilst = whilst;\nexports.all = every;\nexports.allLimit = everyLimit;\nexports.allSeries = everySeries;\nexports.any = some;\nexports.anyLimit = someLimit;\nexports.anySeries = someSeries;\nexports.find = detect;\nexports.findLimit = detectLimit;\nexports.findSeries = detectSeries;\nexports.forEach = eachLimit;\nexports.forEachSeries = eachSeries;\nexports.forEachLimit = eachLimit$1;\nexports.forEachOf = eachOf;\nexports.forEachOfSeries = eachOfSeries;\nexports.forEachOfLimit = eachOfLimit;\nexports.inject = reduce;\nexports.foldl = reduce;\nexports.foldr = reduceRight;\nexports.select = filter;\nexports.selectLimit = filterLimit;\nexports.selectSeries = filterSeries;\nexports.wrapSync = asyncify;\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FB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Q0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGtHQUFrRztBQUMvSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELDRCQUE0QjtBQUM1RTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFVBQVU7QUFDdkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsK0NBQStDLGFBQWE7O0FBRTVELENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90b2RvLWxpc3QvLi9ub2RlX21vZHVsZXMvYXN5bmMvZGlzdC9hc3luYy5qcz83MWYxIl0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cykgOlxuICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJ10sIGZhY3RvcnkpIDpcbiAgKGZhY3RvcnkoKGdsb2JhbC5hc3luYyA9IGdsb2JhbC5hc3luYyB8fCB7fSkpKTtcbn0odGhpcywgKGZ1bmN0aW9uIChleHBvcnRzKSB7ICd1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gc2xpY2UoYXJyYXlMaWtlLCBzdGFydCkge1xuICAgIHN0YXJ0ID0gc3RhcnR8MDtcbiAgICB2YXIgbmV3TGVuID0gTWF0aC5tYXgoYXJyYXlMaWtlLmxlbmd0aCAtIHN0YXJ0LCAwKTtcbiAgICB2YXIgbmV3QXJyID0gQXJyYXkobmV3TGVuKTtcbiAgICBmb3IodmFyIGlkeCA9IDA7IGlkeCA8IG5ld0xlbjsgaWR4KyspICB7XG4gICAgICAgIG5ld0FycltpZHhdID0gYXJyYXlMaWtlW3N0YXJ0ICsgaWR4XTtcbiAgICB9XG4gICAgcmV0dXJuIG5ld0Fycjtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgY29udGludWF0aW9uIGZ1bmN0aW9uIHdpdGggc29tZSBhcmd1bWVudHMgYWxyZWFkeSBhcHBsaWVkLlxuICpcbiAqIFVzZWZ1bCBhcyBhIHNob3J0aGFuZCB3aGVuIGNvbWJpbmVkIHdpdGggb3RoZXIgY29udHJvbCBmbG93IGZ1bmN0aW9ucy4gQW55XG4gKiBhcmd1bWVudHMgcGFzc2VkIHRvIHRoZSByZXR1cm5lZCBmdW5jdGlvbiBhcmUgYWRkZWQgdG8gdGhlIGFyZ3VtZW50c1xuICogb3JpZ2luYWxseSBwYXNzZWQgdG8gYXBwbHkuXG4gKlxuICogQG5hbWUgYXBwbHlcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6VXRpbHNcbiAqIEBtZXRob2RcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiAtIFRoZSBmdW5jdGlvbiB5b3Ugd2FudCB0byBldmVudHVhbGx5IGFwcGx5IGFsbFxuICogYXJndW1lbnRzIHRvLiBJbnZva2VzIHdpdGggKGFyZ3VtZW50cy4uLikuXG4gKiBAcGFyYW0gey4uLip9IGFyZ3VtZW50cy4uLiAtIEFueSBudW1iZXIgb2YgYXJndW1lbnRzIHRvIGF1dG9tYXRpY2FsbHkgYXBwbHlcbiAqIHdoZW4gdGhlIGNvbnRpbnVhdGlvbiBpcyBjYWxsZWQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IHRoZSBwYXJ0aWFsbHktYXBwbGllZCBmdW5jdGlvblxuICogQGV4YW1wbGVcbiAqXG4gKiAvLyB1c2luZyBhcHBseVxuICogYXN5bmMucGFyYWxsZWwoW1xuICogICAgIGFzeW5jLmFwcGx5KGZzLndyaXRlRmlsZSwgJ3Rlc3RmaWxlMScsICd0ZXN0MScpLFxuICogICAgIGFzeW5jLmFwcGx5KGZzLndyaXRlRmlsZSwgJ3Rlc3RmaWxlMicsICd0ZXN0MicpXG4gKiBdKTtcbiAqXG4gKlxuICogLy8gdGhlIHNhbWUgcHJvY2VzcyB3aXRob3V0IHVzaW5nIGFwcGx5XG4gKiBhc3luYy5wYXJhbGxlbChbXG4gKiAgICAgZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAqICAgICAgICAgZnMud3JpdGVGaWxlKCd0ZXN0ZmlsZTEnLCAndGVzdDEnLCBjYWxsYmFjayk7XG4gKiAgICAgfSxcbiAqICAgICBmdW5jdGlvbihjYWxsYmFjaykge1xuICogICAgICAgICBmcy53cml0ZUZpbGUoJ3Rlc3RmaWxlMicsICd0ZXN0MicsIGNhbGxiYWNrKTtcbiAqICAgICB9XG4gKiBdKTtcbiAqXG4gKiAvLyBJdCdzIHBvc3NpYmxlIHRvIHBhc3MgYW55IG51bWJlciBvZiBhZGRpdGlvbmFsIGFyZ3VtZW50cyB3aGVuIGNhbGxpbmcgdGhlXG4gKiAvLyBjb250aW51YXRpb246XG4gKlxuICogbm9kZT4gdmFyIGZuID0gYXN5bmMuYXBwbHkoc3lzLnB1dHMsICdvbmUnKTtcbiAqIG5vZGU+IGZuKCd0d28nLCAndGhyZWUnKTtcbiAqIG9uZVxuICogdHdvXG4gKiB0aHJlZVxuICovXG52YXIgYXBwbHkgPSBmdW5jdGlvbihmbi8qLCAuLi5hcmdzKi8pIHtcbiAgICB2YXIgYXJncyA9IHNsaWNlKGFyZ3VtZW50cywgMSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKC8qY2FsbEFyZ3MqLykge1xuICAgICAgICB2YXIgY2FsbEFyZ3MgPSBzbGljZShhcmd1bWVudHMpO1xuICAgICAgICByZXR1cm4gZm4uYXBwbHkobnVsbCwgYXJncy5jb25jYXQoY2FsbEFyZ3MpKTtcbiAgICB9O1xufTtcblxudmFyIGluaXRpYWxQYXJhbXMgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKC8qLi4uYXJncywgY2FsbGJhY2sqLykge1xuICAgICAgICB2YXIgYXJncyA9IHNsaWNlKGFyZ3VtZW50cyk7XG4gICAgICAgIHZhciBjYWxsYmFjayA9IGFyZ3MucG9wKCk7XG4gICAgICAgIGZuLmNhbGwodGhpcywgYXJncywgY2FsbGJhY2spO1xuICAgIH07XG59O1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHRoZVxuICogW2xhbmd1YWdlIHR5cGVdKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1lY21hc2NyaXB0LWxhbmd1YWdlLXR5cGVzKVxuICogb2YgYE9iamVjdGAuIChlLmcuIGFycmF5cywgZnVuY3Rpb25zLCBvYmplY3RzLCByZWdleGVzLCBgbmV3IE51bWJlcigwKWAsIGFuZCBgbmV3IFN0cmluZygnJylgKVxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0KHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChfLm5vb3ApO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgKHR5cGUgPT0gJ29iamVjdCcgfHwgdHlwZSA9PSAnZnVuY3Rpb24nKTtcbn1cblxudmFyIGhhc1NldEltbWVkaWF0ZSA9IHR5cGVvZiBzZXRJbW1lZGlhdGUgPT09ICdmdW5jdGlvbicgJiYgc2V0SW1tZWRpYXRlO1xudmFyIGhhc05leHRUaWNrID0gdHlwZW9mIHByb2Nlc3MgPT09ICdvYmplY3QnICYmIHR5cGVvZiBwcm9jZXNzLm5leHRUaWNrID09PSAnZnVuY3Rpb24nO1xuXG5mdW5jdGlvbiBmYWxsYmFjayhmbikge1xuICAgIHNldFRpbWVvdXQoZm4sIDApO1xufVxuXG5mdW5jdGlvbiB3cmFwKGRlZmVyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChmbi8qLCAuLi5hcmdzKi8pIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBzbGljZShhcmd1bWVudHMsIDEpO1xuICAgICAgICBkZWZlcihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBmbi5hcHBseShudWxsLCBhcmdzKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbn1cblxudmFyIF9kZWZlcjtcblxuaWYgKGhhc1NldEltbWVkaWF0ZSkge1xuICAgIF9kZWZlciA9IHNldEltbWVkaWF0ZTtcbn0gZWxzZSBpZiAoaGFzTmV4dFRpY2spIHtcbiAgICBfZGVmZXIgPSBwcm9jZXNzLm5leHRUaWNrO1xufSBlbHNlIHtcbiAgICBfZGVmZXIgPSBmYWxsYmFjaztcbn1cblxudmFyIHNldEltbWVkaWF0ZSQxID0gd3JhcChfZGVmZXIpO1xuXG4vKipcbiAqIFRha2UgYSBzeW5jIGZ1bmN0aW9uIGFuZCBtYWtlIGl0IGFzeW5jLCBwYXNzaW5nIGl0cyByZXR1cm4gdmFsdWUgdG8gYVxuICogY2FsbGJhY2suIFRoaXMgaXMgdXNlZnVsIGZvciBwbHVnZ2luZyBzeW5jIGZ1bmN0aW9ucyBpbnRvIGEgd2F0ZXJmYWxsLFxuICogc2VyaWVzLCBvciBvdGhlciBhc3luYyBmdW5jdGlvbnMuIEFueSBhcmd1bWVudHMgcGFzc2VkIHRvIHRoZSBnZW5lcmF0ZWRcbiAqIGZ1bmN0aW9uIHdpbGwgYmUgcGFzc2VkIHRvIHRoZSB3cmFwcGVkIGZ1bmN0aW9uIChleGNlcHQgZm9yIHRoZSBmaW5hbFxuICogY2FsbGJhY2sgYXJndW1lbnQpLiBFcnJvcnMgdGhyb3duIHdpbGwgYmUgcGFzc2VkIHRvIHRoZSBjYWxsYmFjay5cbiAqXG4gKiBJZiB0aGUgZnVuY3Rpb24gcGFzc2VkIHRvIGBhc3luY2lmeWAgcmV0dXJucyBhIFByb21pc2UsIHRoYXQgcHJvbWlzZXMnc1xuICogcmVzb2x2ZWQvcmVqZWN0ZWQgc3RhdGUgd2lsbCBiZSB1c2VkIHRvIGNhbGwgdGhlIGNhbGxiYWNrLCByYXRoZXIgdGhhbiBzaW1wbHlcbiAqIHRoZSBzeW5jaHJvbm91cyByZXR1cm4gdmFsdWUuXG4gKlxuICogVGhpcyBhbHNvIG1lYW5zIHlvdSBjYW4gYXN5bmNpZnkgRVMyMDE3IGBhc3luY2AgZnVuY3Rpb25zLlxuICpcbiAqIEBuYW1lIGFzeW5jaWZ5XG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOlV0aWxzXG4gKiBAbWV0aG9kXG4gKiBAYWxpYXMgd3JhcFN5bmNcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIC0gVGhlIHN5bmNocm9ub3VzIGZ1bmN0aW9uLCBvciBQcm9taXNlLXJldHVybmluZ1xuICogZnVuY3Rpb24gdG8gY29udmVydCB0byBhbiB7QGxpbmsgQXN5bmNGdW5jdGlvbn0uXG4gKiBAcmV0dXJucyB7QXN5bmNGdW5jdGlvbn0gQW4gYXN5bmNocm9ub3VzIHdyYXBwZXIgb2YgdGhlIGBmdW5jYC4gVG8gYmVcbiAqIGludm9rZWQgd2l0aCBgKGFyZ3MuLi4sIGNhbGxiYWNrKWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIC8vIHBhc3NpbmcgYSByZWd1bGFyIHN5bmNocm9ub3VzIGZ1bmN0aW9uXG4gKiBhc3luYy53YXRlcmZhbGwoW1xuICogICAgIGFzeW5jLmFwcGx5KGZzLnJlYWRGaWxlLCBmaWxlbmFtZSwgXCJ1dGY4XCIpLFxuICogICAgIGFzeW5jLmFzeW5jaWZ5KEpTT04ucGFyc2UpLFxuICogICAgIGZ1bmN0aW9uIChkYXRhLCBuZXh0KSB7XG4gKiAgICAgICAgIC8vIGRhdGEgaXMgdGhlIHJlc3VsdCBvZiBwYXJzaW5nIHRoZSB0ZXh0LlxuICogICAgICAgICAvLyBJZiB0aGVyZSB3YXMgYSBwYXJzaW5nIGVycm9yLCBpdCB3b3VsZCBoYXZlIGJlZW4gY2F1Z2h0LlxuICogICAgIH1cbiAqIF0sIGNhbGxiYWNrKTtcbiAqXG4gKiAvLyBwYXNzaW5nIGEgZnVuY3Rpb24gcmV0dXJuaW5nIGEgcHJvbWlzZVxuICogYXN5bmMud2F0ZXJmYWxsKFtcbiAqICAgICBhc3luYy5hcHBseShmcy5yZWFkRmlsZSwgZmlsZW5hbWUsIFwidXRmOFwiKSxcbiAqICAgICBhc3luYy5hc3luY2lmeShmdW5jdGlvbiAoY29udGVudHMpIHtcbiAqICAgICAgICAgcmV0dXJuIGRiLm1vZGVsLmNyZWF0ZShjb250ZW50cyk7XG4gKiAgICAgfSksXG4gKiAgICAgZnVuY3Rpb24gKG1vZGVsLCBuZXh0KSB7XG4gKiAgICAgICAgIC8vIGBtb2RlbGAgaXMgdGhlIGluc3RhbnRpYXRlZCBtb2RlbCBvYmplY3QuXG4gKiAgICAgICAgIC8vIElmIHRoZXJlIHdhcyBhbiBlcnJvciwgdGhpcyBmdW5jdGlvbiB3b3VsZCBiZSBza2lwcGVkLlxuICogICAgIH1cbiAqIF0sIGNhbGxiYWNrKTtcbiAqXG4gKiAvLyBlczIwMTcgZXhhbXBsZSwgdGhvdWdoIGBhc3luY2lmeWAgaXMgbm90IG5lZWRlZCBpZiB5b3VyIEpTIGVudmlyb25tZW50XG4gKiAvLyBzdXBwb3J0cyBhc3luYyBmdW5jdGlvbnMgb3V0IG9mIHRoZSBib3hcbiAqIHZhciBxID0gYXN5bmMucXVldWUoYXN5bmMuYXN5bmNpZnkoYXN5bmMgZnVuY3Rpb24oZmlsZSkge1xuICogICAgIHZhciBpbnRlcm1lZGlhdGVTdGVwID0gYXdhaXQgcHJvY2Vzc0ZpbGUoZmlsZSk7XG4gKiAgICAgcmV0dXJuIGF3YWl0IHNvbWVQcm9taXNlKGludGVybWVkaWF0ZVN0ZXApXG4gKiB9KSk7XG4gKlxuICogcS5wdXNoKGZpbGVzKTtcbiAqL1xuZnVuY3Rpb24gYXN5bmNpZnkoZnVuYykge1xuICAgIHJldHVybiBpbml0aWFsUGFyYW1zKGZ1bmN0aW9uIChhcmdzLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGlmIHJlc3VsdCBpcyBQcm9taXNlIG9iamVjdFxuICAgICAgICBpZiAoaXNPYmplY3QocmVzdWx0KSAmJiB0eXBlb2YgcmVzdWx0LnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJlc3VsdC50aGVuKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaW52b2tlQ2FsbGJhY2soY2FsbGJhY2ssIG51bGwsIHZhbHVlKTtcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgICAgIGludm9rZUNhbGxiYWNrKGNhbGxiYWNrLCBlcnIubWVzc2FnZSA/IGVyciA6IG5ldyBFcnJvcihlcnIpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgcmVzdWx0KTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBpbnZva2VDYWxsYmFjayhjYWxsYmFjaywgZXJyb3IsIHZhbHVlKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY2FsbGJhY2soZXJyb3IsIHZhbHVlKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHNldEltbWVkaWF0ZSQxKHJldGhyb3csIGUpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gcmV0aHJvdyhlcnJvcikge1xuICAgIHRocm93IGVycm9yO1xufVxuXG52YXIgc3VwcG9ydHNTeW1ib2wgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nO1xuXG5mdW5jdGlvbiBpc0FzeW5jKGZuKSB7XG4gICAgcmV0dXJuIHN1cHBvcnRzU3ltYm9sICYmIGZuW1N5bWJvbC50b1N0cmluZ1RhZ10gPT09ICdBc3luY0Z1bmN0aW9uJztcbn1cblxuZnVuY3Rpb24gd3JhcEFzeW5jKGFzeW5jRm4pIHtcbiAgICByZXR1cm4gaXNBc3luYyhhc3luY0ZuKSA/IGFzeW5jaWZ5KGFzeW5jRm4pIDogYXN5bmNGbjtcbn1cblxuZnVuY3Rpb24gYXBwbHlFYWNoJDEoZWFjaGZuKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGZucy8qLCAuLi5hcmdzKi8pIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBzbGljZShhcmd1bWVudHMsIDEpO1xuICAgICAgICB2YXIgZ28gPSBpbml0aWFsUGFyYW1zKGZ1bmN0aW9uKGFyZ3MsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgICAgICByZXR1cm4gZWFjaGZuKGZucywgZnVuY3Rpb24gKGZuLCBjYikge1xuICAgICAgICAgICAgICAgIHdyYXBBc3luYyhmbikuYXBwbHkodGhhdCwgYXJncy5jb25jYXQoY2IpKTtcbiAgICAgICAgICAgIH0sIGNhbGxiYWNrKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChhcmdzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGdvLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGdvO1xuICAgICAgICB9XG4gICAgfTtcbn1cblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWwgJiYgZ2xvYmFsLk9iamVjdCA9PT0gT2JqZWN0ICYmIGdsb2JhbDtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBzZWxmYC4gKi9cbnZhciBmcmVlU2VsZiA9IHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYgJiYgc2VsZi5PYmplY3QgPT09IE9iamVjdCAmJiBzZWxmO1xuXG4vKiogVXNlZCBhcyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdC4gKi9cbnZhciByb290ID0gZnJlZUdsb2JhbCB8fCBmcmVlU2VsZiB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBTeW1ib2wkMSA9IHJvb3QuU3ltYm9sO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgbmF0aXZlT2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3ltVG9TdHJpbmdUYWckMSA9IFN5bWJvbCQxID8gU3ltYm9sJDEudG9TdHJpbmdUYWcgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlR2V0VGFnYCB3aGljaCBpZ25vcmVzIGBTeW1ib2wudG9TdHJpbmdUYWdgIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSByYXcgYHRvU3RyaW5nVGFnYC5cbiAqL1xuZnVuY3Rpb24gZ2V0UmF3VGFnKHZhbHVlKSB7XG4gIHZhciBpc093biA9IGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIHN5bVRvU3RyaW5nVGFnJDEpLFxuICAgICAgdGFnID0gdmFsdWVbc3ltVG9TdHJpbmdUYWckMV07XG5cbiAgdHJ5IHtcbiAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZyQxXSA9IHVuZGVmaW5lZDtcbiAgICB2YXIgdW5tYXNrZWQgPSB0cnVlO1xuICB9IGNhdGNoIChlKSB7fVxuXG4gIHZhciByZXN1bHQgPSBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgaWYgKHVubWFza2VkKSB7XG4gICAgaWYgKGlzT3duKSB7XG4gICAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZyQxXSA9IHRhZztcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlIHZhbHVlW3N5bVRvU3RyaW5nVGFnJDFdO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8kMSA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBuYXRpdmVPYmplY3RUb1N0cmluZyQxID0gb2JqZWN0UHJvdG8kMS50b1N0cmluZztcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nIHVzaW5nIGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiBuYXRpdmVPYmplY3RUb1N0cmluZyQxLmNhbGwodmFsdWUpO1xufVxuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgbnVsbFRhZyA9ICdbb2JqZWN0IE51bGxdJztcbnZhciB1bmRlZmluZWRUYWcgPSAnW29iamVjdCBVbmRlZmluZWRdJztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3ltVG9TdHJpbmdUYWcgPSBTeW1ib2wkMSA/IFN5bWJvbCQxLnRvU3RyaW5nVGFnIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBnZXRUYWdgIHdpdGhvdXQgZmFsbGJhY2tzIGZvciBidWdneSBlbnZpcm9ubWVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgYHRvU3RyaW5nVGFnYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUdldFRhZyh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkVGFnIDogbnVsbFRhZztcbiAgfVxuICByZXR1cm4gKHN5bVRvU3RyaW5nVGFnICYmIHN5bVRvU3RyaW5nVGFnIGluIE9iamVjdCh2YWx1ZSkpXG4gICAgPyBnZXRSYXdUYWcodmFsdWUpXG4gICAgOiBvYmplY3RUb1N0cmluZyh2YWx1ZSk7XG59XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhc3luY1RhZyA9ICdbb2JqZWN0IEFzeW5jRnVuY3Rpb25dJztcbnZhciBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJztcbnZhciBnZW5UYWcgPSAnW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl0nO1xudmFyIHByb3h5VGFnID0gJ1tvYmplY3QgUHJveHldJztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYEZ1bmN0aW9uYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBmdW5jdGlvbiwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzRnVuY3Rpb24oXyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0Z1bmN0aW9uKC9hYmMvKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHtcbiAgaWYgKCFpc09iamVjdCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy8gVGhlIHVzZSBvZiBgT2JqZWN0I3RvU3RyaW5nYCBhdm9pZHMgaXNzdWVzIHdpdGggdGhlIGB0eXBlb2ZgIG9wZXJhdG9yXG4gIC8vIGluIFNhZmFyaSA5IHdoaWNoIHJldHVybnMgJ29iamVjdCcgZm9yIHR5cGVkIGFycmF5cyBhbmQgb3RoZXIgY29uc3RydWN0b3JzLlxuICB2YXIgdGFnID0gYmFzZUdldFRhZyh2YWx1ZSk7XG4gIHJldHVybiB0YWcgPT0gZnVuY1RhZyB8fCB0YWcgPT0gZ2VuVGFnIHx8IHRhZyA9PSBhc3luY1RhZyB8fCB0YWcgPT0gcHJveHlUYWc7XG59XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIE1BWF9TQUZFX0lOVEVHRVIgPSA5MDA3MTk5MjU0NzQwOTkxO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBsZW5ndGguXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGxvb3NlbHkgYmFzZWQgb25cbiAqIFtgVG9MZW5ndGhgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy10b2xlbmd0aCkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBsZW5ndGgsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0xlbmd0aCgzKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzTGVuZ3RoKE51bWJlci5NSU5fVkFMVUUpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzTGVuZ3RoKEluZmluaXR5KTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0xlbmd0aCgnMycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNMZW5ndGgodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyAmJlxuICAgIHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPD0gTUFYX1NBRkVfSU5URUdFUjtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLiBBIHZhbHVlIGlzIGNvbnNpZGVyZWQgYXJyYXktbGlrZSBpZiBpdCdzXG4gKiBub3QgYSBmdW5jdGlvbiBhbmQgaGFzIGEgYHZhbHVlLmxlbmd0aGAgdGhhdCdzIGFuIGludGVnZXIgZ3JlYXRlciB0aGFuIG9yXG4gKiBlcXVhbCB0byBgMGAgYW5kIGxlc3MgdGhhbiBvciBlcXVhbCB0byBgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZSgnYWJjJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheUxpa2UodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiAhaXNGdW5jdGlvbih2YWx1ZSk7XG59XG5cbi8vIEEgdGVtcG9yYXJ5IHZhbHVlIHVzZWQgdG8gaWRlbnRpZnkgaWYgdGhlIGxvb3Agc2hvdWxkIGJlIGJyb2tlbi5cbi8vIFNlZSAjMTA2NCwgIzEyOTNcbnZhciBicmVha0xvb3AgPSB7fTtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIGB1bmRlZmluZWRgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMi4zLjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udGltZXMoMiwgXy5ub29wKTtcbiAqIC8vID0+IFt1bmRlZmluZWQsIHVuZGVmaW5lZF1cbiAqL1xuZnVuY3Rpb24gbm9vcCgpIHtcbiAgLy8gTm8gb3BlcmF0aW9uIHBlcmZvcm1lZC5cbn1cblxuZnVuY3Rpb24gb25jZShmbikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChmbiA9PT0gbnVsbCkgcmV0dXJuO1xuICAgICAgICB2YXIgY2FsbEZuID0gZm47XG4gICAgICAgIGZuID0gbnVsbDtcbiAgICAgICAgY2FsbEZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbn1cblxudmFyIGl0ZXJhdG9yU3ltYm9sID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuaXRlcmF0b3I7XG5cbnZhciBnZXRJdGVyYXRvciA9IGZ1bmN0aW9uIChjb2xsKSB7XG4gICAgcmV0dXJuIGl0ZXJhdG9yU3ltYm9sICYmIGNvbGxbaXRlcmF0b3JTeW1ib2xdICYmIGNvbGxbaXRlcmF0b3JTeW1ib2xdKCk7XG59O1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRpbWVzYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHNcbiAqIG9yIG1heCBhcnJheSBsZW5ndGggY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIGludm9rZSBgaXRlcmF0ZWVgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcmVzdWx0cy5cbiAqL1xuZnVuY3Rpb24gYmFzZVRpbWVzKG4sIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobik7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBuKSB7XG4gICAgcmVzdWx0W2luZGV4XSA9IGl0ZXJhdGVlKGluZGV4KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLiBBIHZhbHVlIGlzIG9iamVjdC1saWtlIGlmIGl0J3Mgbm90IGBudWxsYFxuICogYW5kIGhhcyBhIGB0eXBlb2ZgIHJlc3VsdCBvZiBcIm9iamVjdFwiLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jztcbn1cblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFyZ3NUYWcgPSAnW29iamVjdCBBcmd1bWVudHNdJztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc0FyZ3VtZW50c2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LFxuICovXG5mdW5jdGlvbiBiYXNlSXNBcmd1bWVudHModmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gYXJnc1RhZztcbn1cblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvJDMgPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSQyID0gb2JqZWN0UHJvdG8kMy5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgcHJvcGVydHlJc0VudW1lcmFibGUgPSBvYmplY3RQcm90byQzLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhbiBgYXJndW1lbnRzYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LFxuICogIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJndW1lbnRzKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNBcmd1bWVudHMgPSBiYXNlSXNBcmd1bWVudHMoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSkgPyBiYXNlSXNBcmd1bWVudHMgOiBmdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBoYXNPd25Qcm9wZXJ0eSQyLmNhbGwodmFsdWUsICdjYWxsZWUnKSAmJlxuICAgICFwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHZhbHVlLCAnY2FsbGVlJyk7XG59O1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYW4gYEFycmF5YCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5KGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXkoJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXkoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIGBmYWxzZWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjEzLjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRpbWVzKDIsIF8uc3R1YkZhbHNlKTtcbiAqIC8vID0+IFtmYWxzZSwgZmFsc2VdXG4gKi9cbmZ1bmN0aW9uIHN0dWJGYWxzZSgpIHtcbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xudmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG52YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG4vKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgLiAqL1xudmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHM7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIEJ1ZmZlciA9IG1vZHVsZUV4cG9ydHMgPyByb290LkJ1ZmZlciA6IHVuZGVmaW5lZDtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUlzQnVmZmVyID0gQnVmZmVyID8gQnVmZmVyLmlzQnVmZmVyIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgYnVmZmVyLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4zLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgYnVmZmVyLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNCdWZmZXIobmV3IEJ1ZmZlcigyKSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0J1ZmZlcihuZXcgVWludDhBcnJheSgyKSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNCdWZmZXIgPSBuYXRpdmVJc0J1ZmZlciB8fCBzdHViRmFsc2U7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIE1BWF9TQUZFX0lOVEVHRVIkMSA9IDkwMDcxOTkyNTQ3NDA5OTE7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCB1bnNpZ25lZCBpbnRlZ2VyIHZhbHVlcy4gKi9cbnZhciByZUlzVWludCA9IC9eKD86MHxbMS05XVxcZCopJC87XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGluZGV4LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoPU1BWF9TQUZFX0lOVEVHRVJdIFRoZSB1cHBlciBib3VuZHMgb2YgYSB2YWxpZCBpbmRleC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgaW5kZXgsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNJbmRleCh2YWx1ZSwgbGVuZ3RoKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICBsZW5ndGggPSBsZW5ndGggPT0gbnVsbCA/IE1BWF9TQUZFX0lOVEVHRVIkMSA6IGxlbmd0aDtcblxuICByZXR1cm4gISFsZW5ndGggJiZcbiAgICAodHlwZSA9PSAnbnVtYmVyJyB8fFxuICAgICAgKHR5cGUgIT0gJ3N5bWJvbCcgJiYgcmVJc1VpbnQudGVzdCh2YWx1ZSkpKSAmJlxuICAgICAgICAodmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8IGxlbmd0aCk7XG59XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnJDEgPSAnW29iamVjdCBBcmd1bWVudHNdJztcbnZhciBhcnJheVRhZyA9ICdbb2JqZWN0IEFycmF5XSc7XG52YXIgYm9vbFRhZyA9ICdbb2JqZWN0IEJvb2xlYW5dJztcbnZhciBkYXRlVGFnID0gJ1tvYmplY3QgRGF0ZV0nO1xudmFyIGVycm9yVGFnID0gJ1tvYmplY3QgRXJyb3JdJztcbnZhciBmdW5jVGFnJDEgPSAnW29iamVjdCBGdW5jdGlvbl0nO1xudmFyIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nO1xudmFyIG51bWJlclRhZyA9ICdbb2JqZWN0IE51bWJlcl0nO1xudmFyIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nO1xudmFyIHJlZ2V4cFRhZyA9ICdbb2JqZWN0IFJlZ0V4cF0nO1xudmFyIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nO1xudmFyIHN0cmluZ1RhZyA9ICdbb2JqZWN0IFN0cmluZ10nO1xudmFyIHdlYWtNYXBUYWcgPSAnW29iamVjdCBXZWFrTWFwXSc7XG5cbnZhciBhcnJheUJ1ZmZlclRhZyA9ICdbb2JqZWN0IEFycmF5QnVmZmVyXSc7XG52YXIgZGF0YVZpZXdUYWcgPSAnW29iamVjdCBEYXRhVmlld10nO1xudmFyIGZsb2F0MzJUYWcgPSAnW29iamVjdCBGbG9hdDMyQXJyYXldJztcbnZhciBmbG9hdDY0VGFnID0gJ1tvYmplY3QgRmxvYXQ2NEFycmF5XSc7XG52YXIgaW50OFRhZyA9ICdbb2JqZWN0IEludDhBcnJheV0nO1xudmFyIGludDE2VGFnID0gJ1tvYmplY3QgSW50MTZBcnJheV0nO1xudmFyIGludDMyVGFnID0gJ1tvYmplY3QgSW50MzJBcnJheV0nO1xudmFyIHVpbnQ4VGFnID0gJ1tvYmplY3QgVWludDhBcnJheV0nO1xudmFyIHVpbnQ4Q2xhbXBlZFRhZyA9ICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XSc7XG52YXIgdWludDE2VGFnID0gJ1tvYmplY3QgVWludDE2QXJyYXldJztcbnZhciB1aW50MzJUYWcgPSAnW29iamVjdCBVaW50MzJBcnJheV0nO1xuXG4vKiogVXNlZCB0byBpZGVudGlmeSBgdG9TdHJpbmdUYWdgIHZhbHVlcyBvZiB0eXBlZCBhcnJheXMuICovXG52YXIgdHlwZWRBcnJheVRhZ3MgPSB7fTtcbnR5cGVkQXJyYXlUYWdzW2Zsb2F0MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbZmxvYXQ2NFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbaW50OFRhZ10gPSB0eXBlZEFycmF5VGFnc1tpbnQxNlRhZ10gPVxudHlwZWRBcnJheVRhZ3NbaW50MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDhUYWddID1cbnR5cGVkQXJyYXlUYWdzW3VpbnQ4Q2xhbXBlZFRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50MTZUYWddID1cbnR5cGVkQXJyYXlUYWdzW3VpbnQzMlRhZ10gPSB0cnVlO1xudHlwZWRBcnJheVRhZ3NbYXJnc1RhZyQxXSA9IHR5cGVkQXJyYXlUYWdzW2FycmF5VGFnXSA9XG50eXBlZEFycmF5VGFnc1thcnJheUJ1ZmZlclRhZ10gPSB0eXBlZEFycmF5VGFnc1tib29sVGFnXSA9XG50eXBlZEFycmF5VGFnc1tkYXRhVmlld1RhZ10gPSB0eXBlZEFycmF5VGFnc1tkYXRlVGFnXSA9XG50eXBlZEFycmF5VGFnc1tlcnJvclRhZ10gPSB0eXBlZEFycmF5VGFnc1tmdW5jVGFnJDFdID1cbnR5cGVkQXJyYXlUYWdzW21hcFRhZ10gPSB0eXBlZEFycmF5VGFnc1tudW1iZXJUYWddID1cbnR5cGVkQXJyYXlUYWdzW29iamVjdFRhZ10gPSB0eXBlZEFycmF5VGFnc1tyZWdleHBUYWddID1cbnR5cGVkQXJyYXlUYWdzW3NldFRhZ10gPSB0eXBlZEFycmF5VGFnc1tzdHJpbmdUYWddID1cbnR5cGVkQXJyYXlUYWdzW3dlYWtNYXBUYWddID0gZmFsc2U7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNUeXBlZEFycmF5YCB3aXRob3V0IE5vZGUuanMgb3B0aW1pemF0aW9ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHR5cGVkIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc1R5cGVkQXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiZcbiAgICBpc0xlbmd0aCh2YWx1ZS5sZW5ndGgpICYmICEhdHlwZWRBcnJheVRhZ3NbYmFzZUdldFRhZyh2YWx1ZSldO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnVuYXJ5YCB3aXRob3V0IHN1cHBvcnQgZm9yIHN0b3JpbmcgbWV0YWRhdGEuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNhcCBhcmd1bWVudHMgZm9yLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY2FwcGVkIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlVW5hcnkoZnVuYykge1xuICByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gZnVuYyh2YWx1ZSk7XG4gIH07XG59XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZXhwb3J0c2AuICovXG52YXIgZnJlZUV4cG9ydHMkMSA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgLiAqL1xudmFyIGZyZWVNb2R1bGUkMSA9IGZyZWVFeHBvcnRzJDEgJiYgdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cbi8qKiBEZXRlY3QgdGhlIHBvcHVsYXIgQ29tbW9uSlMgZXh0ZW5zaW9uIGBtb2R1bGUuZXhwb3J0c2AuICovXG52YXIgbW9kdWxlRXhwb3J0cyQxID0gZnJlZU1vZHVsZSQxICYmIGZyZWVNb2R1bGUkMS5leHBvcnRzID09PSBmcmVlRXhwb3J0cyQxO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHByb2Nlc3NgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlUHJvY2VzcyA9IG1vZHVsZUV4cG9ydHMkMSAmJiBmcmVlR2xvYmFsLnByb2Nlc3M7XG5cbi8qKiBVc2VkIHRvIGFjY2VzcyBmYXN0ZXIgTm9kZS5qcyBoZWxwZXJzLiAqL1xudmFyIG5vZGVVdGlsID0gKGZ1bmN0aW9uKCkge1xuICB0cnkge1xuICAgIC8vIFVzZSBgdXRpbC50eXBlc2AgZm9yIE5vZGUuanMgMTArLlxuICAgIHZhciB0eXBlcyA9IGZyZWVNb2R1bGUkMSAmJiBmcmVlTW9kdWxlJDEucmVxdWlyZSAmJiBmcmVlTW9kdWxlJDEucmVxdWlyZSgndXRpbCcpLnR5cGVzO1xuXG4gICAgaWYgKHR5cGVzKSB7XG4gICAgICByZXR1cm4gdHlwZXM7XG4gICAgfVxuXG4gICAgLy8gTGVnYWN5IGBwcm9jZXNzLmJpbmRpbmcoJ3V0aWwnKWAgZm9yIE5vZGUuanMgPCAxMC5cbiAgICByZXR1cm4gZnJlZVByb2Nlc3MgJiYgZnJlZVByb2Nlc3MuYmluZGluZyAmJiBmcmVlUHJvY2Vzcy5iaW5kaW5nKCd1dGlsJyk7XG4gIH0gY2F0Y2ggKGUpIHt9XG59KCkpO1xuXG4vKiBOb2RlLmpzIGhlbHBlciByZWZlcmVuY2VzLiAqL1xudmFyIG5vZGVJc1R5cGVkQXJyYXkgPSBub2RlVXRpbCAmJiBub2RlVXRpbC5pc1R5cGVkQXJyYXk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIHR5cGVkIGFycmF5LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdHlwZWQgYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1R5cGVkQXJyYXkobmV3IFVpbnQ4QXJyYXkpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNUeXBlZEFycmF5KFtdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc1R5cGVkQXJyYXkgPSBub2RlSXNUeXBlZEFycmF5ID8gYmFzZVVuYXJ5KG5vZGVJc1R5cGVkQXJyYXkpIDogYmFzZUlzVHlwZWRBcnJheTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvJDIgPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSQxID0gb2JqZWN0UHJvdG8kMi5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIHRoZSBhcnJheS1saWtlIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtib29sZWFufSBpbmhlcml0ZWQgU3BlY2lmeSByZXR1cm5pbmcgaW5oZXJpdGVkIHByb3BlcnR5IG5hbWVzLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gYXJyYXlMaWtlS2V5cyh2YWx1ZSwgaW5oZXJpdGVkKSB7XG4gIHZhciBpc0FyciA9IGlzQXJyYXkodmFsdWUpLFxuICAgICAgaXNBcmcgPSAhaXNBcnIgJiYgaXNBcmd1bWVudHModmFsdWUpLFxuICAgICAgaXNCdWZmID0gIWlzQXJyICYmICFpc0FyZyAmJiBpc0J1ZmZlcih2YWx1ZSksXG4gICAgICBpc1R5cGUgPSAhaXNBcnIgJiYgIWlzQXJnICYmICFpc0J1ZmYgJiYgaXNUeXBlZEFycmF5KHZhbHVlKSxcbiAgICAgIHNraXBJbmRleGVzID0gaXNBcnIgfHwgaXNBcmcgfHwgaXNCdWZmIHx8IGlzVHlwZSxcbiAgICAgIHJlc3VsdCA9IHNraXBJbmRleGVzID8gYmFzZVRpbWVzKHZhbHVlLmxlbmd0aCwgU3RyaW5nKSA6IFtdLFxuICAgICAgbGVuZ3RoID0gcmVzdWx0Lmxlbmd0aDtcblxuICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICBpZiAoKGluaGVyaXRlZCB8fCBoYXNPd25Qcm9wZXJ0eSQxLmNhbGwodmFsdWUsIGtleSkpICYmXG4gICAgICAgICEoc2tpcEluZGV4ZXMgJiYgKFxuICAgICAgICAgICAvLyBTYWZhcmkgOSBoYXMgZW51bWVyYWJsZSBgYXJndW1lbnRzLmxlbmd0aGAgaW4gc3RyaWN0IG1vZGUuXG4gICAgICAgICAgIGtleSA9PSAnbGVuZ3RoJyB8fFxuICAgICAgICAgICAvLyBOb2RlLmpzIDAuMTAgaGFzIGVudW1lcmFibGUgbm9uLWluZGV4IHByb3BlcnRpZXMgb24gYnVmZmVycy5cbiAgICAgICAgICAgKGlzQnVmZiAmJiAoa2V5ID09ICdvZmZzZXQnIHx8IGtleSA9PSAncGFyZW50JykpIHx8XG4gICAgICAgICAgIC8vIFBoYW50b21KUyAyIGhhcyBlbnVtZXJhYmxlIG5vbi1pbmRleCBwcm9wZXJ0aWVzIG9uIHR5cGVkIGFycmF5cy5cbiAgICAgICAgICAgKGlzVHlwZSAmJiAoa2V5ID09ICdidWZmZXInIHx8IGtleSA9PSAnYnl0ZUxlbmd0aCcgfHwga2V5ID09ICdieXRlT2Zmc2V0JykpIHx8XG4gICAgICAgICAgIC8vIFNraXAgaW5kZXggcHJvcGVydGllcy5cbiAgICAgICAgICAgaXNJbmRleChrZXksIGxlbmd0aClcbiAgICAgICAgKSkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byQ1ID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYSBwcm90b3R5cGUgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcHJvdG90eXBlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzUHJvdG90eXBlKHZhbHVlKSB7XG4gIHZhciBDdG9yID0gdmFsdWUgJiYgdmFsdWUuY29uc3RydWN0b3IsXG4gICAgICBwcm90byA9ICh0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmIEN0b3IucHJvdG90eXBlKSB8fCBvYmplY3RQcm90byQ1O1xuXG4gIHJldHVybiB2YWx1ZSA9PT0gcHJvdG87XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIHVuYXJ5IGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCBpdHMgYXJndW1lbnQgdHJhbnNmb3JtZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHdyYXAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSB0cmFuc2Zvcm0gVGhlIGFyZ3VtZW50IHRyYW5zZm9ybS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBvdmVyQXJnKGZ1bmMsIHRyYW5zZm9ybSkge1xuICByZXR1cm4gZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIGZ1bmModHJhbnNmb3JtKGFyZykpO1xuICB9O1xufVxuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlS2V5cyA9IG92ZXJBcmcoT2JqZWN0LmtleXMsIE9iamVjdCk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byQ0ID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkkMyA9IG9iamVjdFByb3RvJDQuaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ua2V5c2Agd2hpY2ggZG9lc24ndCB0cmVhdCBzcGFyc2UgYXJyYXlzIGFzIGRlbnNlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBiYXNlS2V5cyhvYmplY3QpIHtcbiAgaWYgKCFpc1Byb3RvdHlwZShvYmplY3QpKSB7XG4gICAgcmV0dXJuIG5hdGl2ZUtleXMob2JqZWN0KTtcbiAgfVxuICB2YXIgcmVzdWx0ID0gW107XG4gIGZvciAodmFyIGtleSBpbiBPYmplY3Qob2JqZWN0KSkge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eSQzLmNhbGwob2JqZWN0LCBrZXkpICYmIGtleSAhPSAnY29uc3RydWN0b3InKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGBvYmplY3RgLlxuICpcbiAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLiBTZWUgdGhlXG4gKiBbRVMgc3BlY10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LmtleXMpXG4gKiBmb3IgbW9yZSBkZXRhaWxzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqICAgdGhpcy5iID0gMjtcbiAqIH1cbiAqXG4gKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICpcbiAqIF8ua2V5cyhuZXcgRm9vKTtcbiAqIC8vID0+IFsnYScsICdiJ10gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAqXG4gKiBfLmtleXMoJ2hpJyk7XG4gKiAvLyA9PiBbJzAnLCAnMSddXG4gKi9cbmZ1bmN0aW9uIGtleXMob2JqZWN0KSB7XG4gIHJldHVybiBpc0FycmF5TGlrZShvYmplY3QpID8gYXJyYXlMaWtlS2V5cyhvYmplY3QpIDogYmFzZUtleXMob2JqZWN0KTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQXJyYXlJdGVyYXRvcihjb2xsKSB7XG4gICAgdmFyIGkgPSAtMTtcbiAgICB2YXIgbGVuID0gY29sbC5sZW5ndGg7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgIHJldHVybiArK2kgPCBsZW4gPyB7dmFsdWU6IGNvbGxbaV0sIGtleTogaX0gOiBudWxsO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlRVMyMDE1SXRlcmF0b3IoaXRlcmF0b3IpIHtcbiAgICB2YXIgaSA9IC0xO1xuICAgIHJldHVybiBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICB2YXIgaXRlbSA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgaWYgKGl0ZW0uZG9uZSlcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBpKys7XG4gICAgICAgIHJldHVybiB7dmFsdWU6IGl0ZW0udmFsdWUsIGtleTogaX07XG4gICAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVPYmplY3RJdGVyYXRvcihvYmopIHtcbiAgICB2YXIgb2tleXMgPSBrZXlzKG9iaik7XG4gICAgdmFyIGkgPSAtMTtcbiAgICB2YXIgbGVuID0gb2tleXMubGVuZ3RoO1xuICAgIHJldHVybiBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICB2YXIga2V5ID0gb2tleXNbKytpXTtcbiAgICAgICAgaWYgKGtleSA9PT0gJ19fcHJvdG9fXycpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGkgPCBsZW4gPyB7dmFsdWU6IG9ialtrZXldLCBrZXk6IGtleX0gOiBudWxsO1xuICAgIH07XG59XG5cbmZ1bmN0aW9uIGl0ZXJhdG9yKGNvbGwpIHtcbiAgICBpZiAoaXNBcnJheUxpa2UoY29sbCkpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUFycmF5SXRlcmF0b3IoY29sbCk7XG4gICAgfVxuXG4gICAgdmFyIGl0ZXJhdG9yID0gZ2V0SXRlcmF0b3IoY29sbCk7XG4gICAgcmV0dXJuIGl0ZXJhdG9yID8gY3JlYXRlRVMyMDE1SXRlcmF0b3IoaXRlcmF0b3IpIDogY3JlYXRlT2JqZWN0SXRlcmF0b3IoY29sbCk7XG59XG5cbmZ1bmN0aW9uIG9ubHlPbmNlKGZuKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoZm4gPT09IG51bGwpIHRocm93IG5ldyBFcnJvcihcIkNhbGxiYWNrIHdhcyBhbHJlYWR5IGNhbGxlZC5cIik7XG4gICAgICAgIHZhciBjYWxsRm4gPSBmbjtcbiAgICAgICAgZm4gPSBudWxsO1xuICAgICAgICBjYWxsRm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBfZWFjaE9mTGltaXQobGltaXQpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKG9iaiwgaXRlcmF0ZWUsIGNhbGxiYWNrKSB7XG4gICAgICAgIGNhbGxiYWNrID0gb25jZShjYWxsYmFjayB8fCBub29wKTtcbiAgICAgICAgaWYgKGxpbWl0IDw9IDAgfHwgIW9iaikge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBuZXh0RWxlbSA9IGl0ZXJhdG9yKG9iaik7XG4gICAgICAgIHZhciBkb25lID0gZmFsc2U7XG4gICAgICAgIHZhciBydW5uaW5nID0gMDtcbiAgICAgICAgdmFyIGxvb3BpbmcgPSBmYWxzZTtcblxuICAgICAgICBmdW5jdGlvbiBpdGVyYXRlZUNhbGxiYWNrKGVyciwgdmFsdWUpIHtcbiAgICAgICAgICAgIHJ1bm5pbmcgLT0gMTtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUgPT09IGJyZWFrTG9vcCB8fCAoZG9uZSAmJiBydW5uaW5nIDw9IDApKSB7XG4gICAgICAgICAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIWxvb3BpbmcpIHtcbiAgICAgICAgICAgICAgICByZXBsZW5pc2goKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHJlcGxlbmlzaCAoKSB7XG4gICAgICAgICAgICBsb29waW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIHdoaWxlIChydW5uaW5nIDwgbGltaXQgJiYgIWRvbmUpIHtcbiAgICAgICAgICAgICAgICB2YXIgZWxlbSA9IG5leHRFbGVtKCk7XG4gICAgICAgICAgICAgICAgaWYgKGVsZW0gPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChydW5uaW5nIDw9IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcnVubmluZyArPSAxO1xuICAgICAgICAgICAgICAgIGl0ZXJhdGVlKGVsZW0udmFsdWUsIGVsZW0ua2V5LCBvbmx5T25jZShpdGVyYXRlZUNhbGxiYWNrKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsb29waW5nID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXBsZW5pc2goKTtcbiAgICB9O1xufVxuXG4vKipcbiAqIFRoZSBzYW1lIGFzIFtgZWFjaE9mYF17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLmVhY2hPZn0gYnV0IHJ1bnMgYSBtYXhpbXVtIG9mIGBsaW1pdGAgYXN5bmMgb3BlcmF0aW9ucyBhdCBhXG4gKiB0aW1lLlxuICpcbiAqIEBuYW1lIGVhY2hPZkxpbWl0XG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbGxlY3Rpb25zXG4gKiBAbWV0aG9kXG4gKiBAc2VlIFthc3luYy5lYWNoT2Zde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5lYWNoT2Z9XG4gKiBAYWxpYXMgZm9yRWFjaE9mTGltaXRcbiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gKiBAcGFyYW0ge0FycmF5fEl0ZXJhYmxlfE9iamVjdH0gY29sbCAtIEEgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge251bWJlcn0gbGltaXQgLSBUaGUgbWF4aW11bSBudW1iZXIgb2YgYXN5bmMgb3BlcmF0aW9ucyBhdCBhIHRpbWUuXG4gKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGl0ZXJhdGVlIC0gQW4gYXN5bmMgZnVuY3Rpb24gdG8gYXBwbHkgdG8gZWFjaFxuICogaXRlbSBpbiBgY29sbGAuIFRoZSBga2V5YCBpcyB0aGUgaXRlbSdzIGtleSwgb3IgaW5kZXggaW4gdGhlIGNhc2Ugb2YgYW5cbiAqIGFycmF5LlxuICogSW52b2tlZCB3aXRoIChpdGVtLCBrZXksIGNhbGxiYWNrKS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCB3aGVuIGFsbFxuICogYGl0ZXJhdGVlYCBmdW5jdGlvbnMgaGF2ZSBmaW5pc2hlZCwgb3IgYW4gZXJyb3Igb2NjdXJzLiBJbnZva2VkIHdpdGggKGVycikuXG4gKi9cbmZ1bmN0aW9uIGVhY2hPZkxpbWl0KGNvbGwsIGxpbWl0LCBpdGVyYXRlZSwgY2FsbGJhY2spIHtcbiAgICBfZWFjaE9mTGltaXQobGltaXQpKGNvbGwsIHdyYXBBc3luYyhpdGVyYXRlZSksIGNhbGxiYWNrKTtcbn1cblxuZnVuY3Rpb24gZG9MaW1pdChmbiwgbGltaXQpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGl0ZXJhYmxlLCBpdGVyYXRlZSwgY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIGZuKGl0ZXJhYmxlLCBsaW1pdCwgaXRlcmF0ZWUsIGNhbGxiYWNrKTtcbiAgICB9O1xufVxuXG4vLyBlYWNoT2YgaW1wbGVtZW50YXRpb24gb3B0aW1pemVkIGZvciBhcnJheS1saWtlc1xuZnVuY3Rpb24gZWFjaE9mQXJyYXlMaWtlKGNvbGwsIGl0ZXJhdGVlLCBjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrID0gb25jZShjYWxsYmFjayB8fCBub29wKTtcbiAgICB2YXIgaW5kZXggPSAwLFxuICAgICAgICBjb21wbGV0ZWQgPSAwLFxuICAgICAgICBsZW5ndGggPSBjb2xsLmxlbmd0aDtcbiAgICBpZiAobGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGNhbGxiYWNrKG51bGwpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGl0ZXJhdG9yQ2FsbGJhY2soZXJyLCB2YWx1ZSkge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICB9IGVsc2UgaWYgKCgrK2NvbXBsZXRlZCA9PT0gbGVuZ3RoKSB8fCB2YWx1ZSA9PT0gYnJlYWtMb29wKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhudWxsKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZvciAoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICBpdGVyYXRlZShjb2xsW2luZGV4XSwgaW5kZXgsIG9ubHlPbmNlKGl0ZXJhdG9yQ2FsbGJhY2spKTtcbiAgICB9XG59XG5cbi8vIGEgZ2VuZXJpYyB2ZXJzaW9uIG9mIGVhY2hPZiB3aGljaCBjYW4gaGFuZGxlIGFycmF5LCBvYmplY3QsIGFuZCBpdGVyYXRvciBjYXNlcy5cbnZhciBlYWNoT2ZHZW5lcmljID0gZG9MaW1pdChlYWNoT2ZMaW1pdCwgSW5maW5pdHkpO1xuXG4vKipcbiAqIExpa2UgW2BlYWNoYF17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLmVhY2h9LCBleGNlcHQgdGhhdCBpdCBwYXNzZXMgdGhlIGtleSAob3IgaW5kZXgpIGFzIHRoZSBzZWNvbmQgYXJndW1lbnRcbiAqIHRvIHRoZSBpdGVyYXRlZS5cbiAqXG4gKiBAbmFtZSBlYWNoT2ZcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29sbGVjdGlvbnNcbiAqIEBtZXRob2RcbiAqIEBhbGlhcyBmb3JFYWNoT2ZcbiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gKiBAc2VlIFthc3luYy5lYWNoXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMuZWFjaH1cbiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8T2JqZWN0fSBjb2xsIC0gQSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gaXRlcmF0ZWUgLSBBIGZ1bmN0aW9uIHRvIGFwcGx5IHRvIGVhY2hcbiAqIGl0ZW0gaW4gYGNvbGxgLlxuICogVGhlIGBrZXlgIGlzIHRoZSBpdGVtJ3Mga2V5LCBvciBpbmRleCBpbiB0aGUgY2FzZSBvZiBhbiBhcnJheS5cbiAqIEludm9rZWQgd2l0aCAoaXRlbSwga2V5LCBjYWxsYmFjaykuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgd2hlbiBhbGxcbiAqIGBpdGVyYXRlZWAgZnVuY3Rpb25zIGhhdmUgZmluaXNoZWQsIG9yIGFuIGVycm9yIG9jY3Vycy4gSW52b2tlZCB3aXRoIChlcnIpLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqID0ge2RldjogXCIvZGV2Lmpzb25cIiwgdGVzdDogXCIvdGVzdC5qc29uXCIsIHByb2Q6IFwiL3Byb2QuanNvblwifTtcbiAqIHZhciBjb25maWdzID0ge307XG4gKlxuICogYXN5bmMuZm9yRWFjaE9mKG9iaiwgZnVuY3Rpb24gKHZhbHVlLCBrZXksIGNhbGxiYWNrKSB7XG4gKiAgICAgZnMucmVhZEZpbGUoX19kaXJuYW1lICsgdmFsdWUsIFwidXRmOFwiLCBmdW5jdGlvbiAoZXJyLCBkYXRhKSB7XG4gKiAgICAgICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICogICAgICAgICB0cnkge1xuICogICAgICAgICAgICAgY29uZmlnc1trZXldID0gSlNPTi5wYXJzZShkYXRhKTtcbiAqICAgICAgICAgfSBjYXRjaCAoZSkge1xuICogICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGUpO1xuICogICAgICAgICB9XG4gKiAgICAgICAgIGNhbGxiYWNrKCk7XG4gKiAgICAgfSk7XG4gKiB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gKiAgICAgaWYgKGVycikgY29uc29sZS5lcnJvcihlcnIubWVzc2FnZSk7XG4gKiAgICAgLy8gY29uZmlncyBpcyBub3cgYSBtYXAgb2YgSlNPTiBkYXRhXG4gKiAgICAgZG9Tb21ldGhpbmdXaXRoKGNvbmZpZ3MpO1xuICogfSk7XG4gKi9cbnZhciBlYWNoT2YgPSBmdW5jdGlvbihjb2xsLCBpdGVyYXRlZSwgY2FsbGJhY2spIHtcbiAgICB2YXIgZWFjaE9mSW1wbGVtZW50YXRpb24gPSBpc0FycmF5TGlrZShjb2xsKSA/IGVhY2hPZkFycmF5TGlrZSA6IGVhY2hPZkdlbmVyaWM7XG4gICAgZWFjaE9mSW1wbGVtZW50YXRpb24oY29sbCwgd3JhcEFzeW5jKGl0ZXJhdGVlKSwgY2FsbGJhY2spO1xufTtcblxuZnVuY3Rpb24gZG9QYXJhbGxlbChmbikge1xuICAgIHJldHVybiBmdW5jdGlvbiAob2JqLCBpdGVyYXRlZSwgY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIGZuKGVhY2hPZiwgb2JqLCB3cmFwQXN5bmMoaXRlcmF0ZWUpLCBjYWxsYmFjayk7XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gX2FzeW5jTWFwKGVhY2hmbiwgYXJyLCBpdGVyYXRlZSwgY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjayA9IGNhbGxiYWNrIHx8IG5vb3A7XG4gICAgYXJyID0gYXJyIHx8IFtdO1xuICAgIHZhciByZXN1bHRzID0gW107XG4gICAgdmFyIGNvdW50ZXIgPSAwO1xuICAgIHZhciBfaXRlcmF0ZWUgPSB3cmFwQXN5bmMoaXRlcmF0ZWUpO1xuXG4gICAgZWFjaGZuKGFyciwgZnVuY3Rpb24gKHZhbHVlLCBfLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgaW5kZXggPSBjb3VudGVyKys7XG4gICAgICAgIF9pdGVyYXRlZSh2YWx1ZSwgZnVuY3Rpb24gKGVyciwgdikge1xuICAgICAgICAgICAgcmVzdWx0c1tpbmRleF0gPSB2O1xuICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgfSk7XG4gICAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICBjYWxsYmFjayhlcnIsIHJlc3VsdHMpO1xuICAgIH0pO1xufVxuXG4vKipcbiAqIFByb2R1Y2VzIGEgbmV3IGNvbGxlY3Rpb24gb2YgdmFsdWVzIGJ5IG1hcHBpbmcgZWFjaCB2YWx1ZSBpbiBgY29sbGAgdGhyb3VnaFxuICogdGhlIGBpdGVyYXRlZWAgZnVuY3Rpb24uIFRoZSBgaXRlcmF0ZWVgIGlzIGNhbGxlZCB3aXRoIGFuIGl0ZW0gZnJvbSBgY29sbGBcbiAqIGFuZCBhIGNhbGxiYWNrIGZvciB3aGVuIGl0IGhhcyBmaW5pc2hlZCBwcm9jZXNzaW5nLiBFYWNoIG9mIHRoZXNlIGNhbGxiYWNrXG4gKiB0YWtlcyAyIGFyZ3VtZW50czogYW4gYGVycm9yYCwgYW5kIHRoZSB0cmFuc2Zvcm1lZCBpdGVtIGZyb20gYGNvbGxgLiBJZlxuICogYGl0ZXJhdGVlYCBwYXNzZXMgYW4gZXJyb3IgdG8gaXRzIGNhbGxiYWNrLCB0aGUgbWFpbiBgY2FsbGJhY2tgIChmb3IgdGhlXG4gKiBgbWFwYCBmdW5jdGlvbikgaXMgaW1tZWRpYXRlbHkgY2FsbGVkIHdpdGggdGhlIGVycm9yLlxuICpcbiAqIE5vdGUsIHRoYXQgc2luY2UgdGhpcyBmdW5jdGlvbiBhcHBsaWVzIHRoZSBgaXRlcmF0ZWVgIHRvIGVhY2ggaXRlbSBpblxuICogcGFyYWxsZWwsIHRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IHRoZSBgaXRlcmF0ZWVgIGZ1bmN0aW9ucyB3aWxsIGNvbXBsZXRlXG4gKiBpbiBvcmRlci4gSG93ZXZlciwgdGhlIHJlc3VsdHMgYXJyYXkgd2lsbCBiZSBpbiB0aGUgc2FtZSBvcmRlciBhcyB0aGVcbiAqIG9yaWdpbmFsIGBjb2xsYC5cbiAqXG4gKiBJZiBgbWFwYCBpcyBwYXNzZWQgYW4gT2JqZWN0LCB0aGUgcmVzdWx0cyB3aWxsIGJlIGFuIEFycmF5LiAgVGhlIHJlc3VsdHNcbiAqIHdpbGwgcm91Z2hseSBiZSBpbiB0aGUgb3JkZXIgb2YgdGhlIG9yaWdpbmFsIE9iamVjdHMnIGtleXMgKGJ1dCB0aGlzIGNhblxuICogdmFyeSBhY3Jvc3MgSmF2YVNjcmlwdCBlbmdpbmVzKS5cbiAqXG4gKiBAbmFtZSBtYXBcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29sbGVjdGlvbnNcbiAqIEBtZXRob2RcbiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gKiBAcGFyYW0ge0FycmF5fEl0ZXJhYmxlfE9iamVjdH0gY29sbCAtIEEgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGl0ZXJhdGVlIC0gQW4gYXN5bmMgZnVuY3Rpb24gdG8gYXBwbHkgdG8gZWFjaCBpdGVtIGluXG4gKiBgY29sbGAuXG4gKiBUaGUgaXRlcmF0ZWUgc2hvdWxkIGNvbXBsZXRlIHdpdGggdGhlIHRyYW5zZm9ybWVkIGl0ZW0uXG4gKiBJbnZva2VkIHdpdGggKGl0ZW0sIGNhbGxiYWNrKS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCB3aGVuIGFsbCBgaXRlcmF0ZWVgXG4gKiBmdW5jdGlvbnMgaGF2ZSBmaW5pc2hlZCwgb3IgYW4gZXJyb3Igb2NjdXJzLiBSZXN1bHRzIGlzIGFuIEFycmF5IG9mIHRoZVxuICogdHJhbnNmb3JtZWQgaXRlbXMgZnJvbSB0aGUgYGNvbGxgLiBJbnZva2VkIHdpdGggKGVyciwgcmVzdWx0cykuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGFzeW5jLm1hcChbJ2ZpbGUxJywnZmlsZTInLCdmaWxlMyddLCBmcy5zdGF0LCBmdW5jdGlvbihlcnIsIHJlc3VsdHMpIHtcbiAqICAgICAvLyByZXN1bHRzIGlzIG5vdyBhbiBhcnJheSBvZiBzdGF0cyBmb3IgZWFjaCBmaWxlXG4gKiB9KTtcbiAqL1xudmFyIG1hcCA9IGRvUGFyYWxsZWwoX2FzeW5jTWFwKTtcblxuLyoqXG4gKiBBcHBsaWVzIHRoZSBwcm92aWRlZCBhcmd1bWVudHMgdG8gZWFjaCBmdW5jdGlvbiBpbiB0aGUgYXJyYXksIGNhbGxpbmdcbiAqIGBjYWxsYmFja2AgYWZ0ZXIgYWxsIGZ1bmN0aW9ucyBoYXZlIGNvbXBsZXRlZC4gSWYgeW91IG9ubHkgcHJvdmlkZSB0aGUgZmlyc3RcbiAqIGFyZ3VtZW50LCBgZm5zYCwgdGhlbiBpdCB3aWxsIHJldHVybiBhIGZ1bmN0aW9uIHdoaWNoIGxldHMgeW91IHBhc3MgaW4gdGhlXG4gKiBhcmd1bWVudHMgYXMgaWYgaXQgd2VyZSBhIHNpbmdsZSBmdW5jdGlvbiBjYWxsLiBJZiBtb3JlIGFyZ3VtZW50cyBhcmVcbiAqIHByb3ZpZGVkLCBgY2FsbGJhY2tgIGlzIHJlcXVpcmVkIHdoaWxlIGBhcmdzYCBpcyBzdGlsbCBvcHRpb25hbC5cbiAqXG4gKiBAbmFtZSBhcHBseUVhY2hcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29udHJvbEZsb3dcbiAqIEBtZXRob2RcbiAqIEBjYXRlZ29yeSBDb250cm9sIEZsb3dcbiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8T2JqZWN0fSBmbnMgLSBBIGNvbGxlY3Rpb24gb2Yge0BsaW5rIEFzeW5jRnVuY3Rpb259c1xuICogdG8gYWxsIGNhbGwgd2l0aCB0aGUgc2FtZSBhcmd1bWVudHNcbiAqIEBwYXJhbSB7Li4uKn0gW2FyZ3NdIC0gYW55IG51bWJlciBvZiBzZXBhcmF0ZSBhcmd1bWVudHMgdG8gcGFzcyB0byB0aGVcbiAqIGZ1bmN0aW9uLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIHRoZSBmaW5hbCBhcmd1bWVudCBzaG91bGQgYmUgdGhlIGNhbGxiYWNrLFxuICogY2FsbGVkIHdoZW4gYWxsIGZ1bmN0aW9ucyBoYXZlIGNvbXBsZXRlZCBwcm9jZXNzaW5nLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSAtIElmIG9ubHkgdGhlIGZpcnN0IGFyZ3VtZW50LCBgZm5zYCwgaXMgcHJvdmlkZWQsIGl0IHdpbGxcbiAqIHJldHVybiBhIGZ1bmN0aW9uIHdoaWNoIGxldHMgeW91IHBhc3MgaW4gdGhlIGFyZ3VtZW50cyBhcyBpZiBpdCB3ZXJlIGEgc2luZ2xlXG4gKiBmdW5jdGlvbiBjYWxsLiBUaGUgc2lnbmF0dXJlIGlzIGAoLi5hcmdzLCBjYWxsYmFjaylgLiBJZiBpbnZva2VkIHdpdGggYW55XG4gKiBhcmd1bWVudHMsIGBjYWxsYmFja2AgaXMgcmVxdWlyZWQuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGFzeW5jLmFwcGx5RWFjaChbZW5hYmxlU2VhcmNoLCB1cGRhdGVTY2hlbWFdLCAnYnVja2V0JywgY2FsbGJhY2spO1xuICpcbiAqIC8vIHBhcnRpYWwgYXBwbGljYXRpb24gZXhhbXBsZTpcbiAqIGFzeW5jLmVhY2goXG4gKiAgICAgYnVja2V0cyxcbiAqICAgICBhc3luYy5hcHBseUVhY2goW2VuYWJsZVNlYXJjaCwgdXBkYXRlU2NoZW1hXSksXG4gKiAgICAgY2FsbGJhY2tcbiAqICk7XG4gKi9cbnZhciBhcHBseUVhY2ggPSBhcHBseUVhY2gkMShtYXApO1xuXG5mdW5jdGlvbiBkb1BhcmFsbGVsTGltaXQoZm4pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKG9iaiwgbGltaXQsIGl0ZXJhdGVlLCBjYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gZm4oX2VhY2hPZkxpbWl0KGxpbWl0KSwgb2JqLCB3cmFwQXN5bmMoaXRlcmF0ZWUpLCBjYWxsYmFjayk7XG4gICAgfTtcbn1cblxuLyoqXG4gKiBUaGUgc2FtZSBhcyBbYG1hcGBde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5tYXB9IGJ1dCBydW5zIGEgbWF4aW11bSBvZiBgbGltaXRgIGFzeW5jIG9wZXJhdGlvbnMgYXQgYSB0aW1lLlxuICpcbiAqIEBuYW1lIG1hcExpbWl0XG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbGxlY3Rpb25zXG4gKiBAbWV0aG9kXG4gKiBAc2VlIFthc3luYy5tYXBde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5tYXB9XG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxPYmplY3R9IGNvbGwgLSBBIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtudW1iZXJ9IGxpbWl0IC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIGFzeW5jIG9wZXJhdGlvbnMgYXQgYSB0aW1lLlxuICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEFuIGFzeW5jIGZ1bmN0aW9uIHRvIGFwcGx5IHRvIGVhY2ggaXRlbSBpblxuICogYGNvbGxgLlxuICogVGhlIGl0ZXJhdGVlIHNob3VsZCBjb21wbGV0ZSB3aXRoIHRoZSB0cmFuc2Zvcm1lZCBpdGVtLlxuICogSW52b2tlZCB3aXRoIChpdGVtLCBjYWxsYmFjaykuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgd2hlbiBhbGwgYGl0ZXJhdGVlYFxuICogZnVuY3Rpb25zIGhhdmUgZmluaXNoZWQsIG9yIGFuIGVycm9yIG9jY3Vycy4gUmVzdWx0cyBpcyBhbiBhcnJheSBvZiB0aGVcbiAqIHRyYW5zZm9ybWVkIGl0ZW1zIGZyb20gdGhlIGBjb2xsYC4gSW52b2tlZCB3aXRoIChlcnIsIHJlc3VsdHMpLlxuICovXG52YXIgbWFwTGltaXQgPSBkb1BhcmFsbGVsTGltaXQoX2FzeW5jTWFwKTtcblxuLyoqXG4gKiBUaGUgc2FtZSBhcyBbYG1hcGBde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5tYXB9IGJ1dCBydW5zIG9ubHkgYSBzaW5nbGUgYXN5bmMgb3BlcmF0aW9uIGF0IGEgdGltZS5cbiAqXG4gKiBAbmFtZSBtYXBTZXJpZXNcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29sbGVjdGlvbnNcbiAqIEBtZXRob2RcbiAqIEBzZWUgW2FzeW5jLm1hcF17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLm1hcH1cbiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gKiBAcGFyYW0ge0FycmF5fEl0ZXJhYmxlfE9iamVjdH0gY29sbCAtIEEgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGl0ZXJhdGVlIC0gQW4gYXN5bmMgZnVuY3Rpb24gdG8gYXBwbHkgdG8gZWFjaCBpdGVtIGluXG4gKiBgY29sbGAuXG4gKiBUaGUgaXRlcmF0ZWUgc2hvdWxkIGNvbXBsZXRlIHdpdGggdGhlIHRyYW5zZm9ybWVkIGl0ZW0uXG4gKiBJbnZva2VkIHdpdGggKGl0ZW0sIGNhbGxiYWNrKS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCB3aGVuIGFsbCBgaXRlcmF0ZWVgXG4gKiBmdW5jdGlvbnMgaGF2ZSBmaW5pc2hlZCwgb3IgYW4gZXJyb3Igb2NjdXJzLiBSZXN1bHRzIGlzIGFuIGFycmF5IG9mIHRoZVxuICogdHJhbnNmb3JtZWQgaXRlbXMgZnJvbSB0aGUgYGNvbGxgLiBJbnZva2VkIHdpdGggKGVyciwgcmVzdWx0cykuXG4gKi9cbnZhciBtYXBTZXJpZXMgPSBkb0xpbWl0KG1hcExpbWl0LCAxKTtcblxuLyoqXG4gKiBUaGUgc2FtZSBhcyBbYGFwcGx5RWFjaGBde0BsaW5rIG1vZHVsZTpDb250cm9sRmxvdy5hcHBseUVhY2h9IGJ1dCBydW5zIG9ubHkgYSBzaW5nbGUgYXN5bmMgb3BlcmF0aW9uIGF0IGEgdGltZS5cbiAqXG4gKiBAbmFtZSBhcHBseUVhY2hTZXJpZXNcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29udHJvbEZsb3dcbiAqIEBtZXRob2RcbiAqIEBzZWUgW2FzeW5jLmFwcGx5RWFjaF17QGxpbmsgbW9kdWxlOkNvbnRyb2xGbG93LmFwcGx5RWFjaH1cbiAqIEBjYXRlZ29yeSBDb250cm9sIEZsb3dcbiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8T2JqZWN0fSBmbnMgLSBBIGNvbGxlY3Rpb24gb2Yge0BsaW5rIEFzeW5jRnVuY3Rpb259cyB0byBhbGxcbiAqIGNhbGwgd2l0aCB0aGUgc2FtZSBhcmd1bWVudHNcbiAqIEBwYXJhbSB7Li4uKn0gW2FyZ3NdIC0gYW55IG51bWJlciBvZiBzZXBhcmF0ZSBhcmd1bWVudHMgdG8gcGFzcyB0byB0aGVcbiAqIGZ1bmN0aW9uLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIHRoZSBmaW5hbCBhcmd1bWVudCBzaG91bGQgYmUgdGhlIGNhbGxiYWNrLFxuICogY2FsbGVkIHdoZW4gYWxsIGZ1bmN0aW9ucyBoYXZlIGNvbXBsZXRlZCBwcm9jZXNzaW5nLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSAtIElmIG9ubHkgdGhlIGZpcnN0IGFyZ3VtZW50IGlzIHByb3ZpZGVkLCBpdCB3aWxsIHJldHVyblxuICogYSBmdW5jdGlvbiB3aGljaCBsZXRzIHlvdSBwYXNzIGluIHRoZSBhcmd1bWVudHMgYXMgaWYgaXQgd2VyZSBhIHNpbmdsZVxuICogZnVuY3Rpb24gY2FsbC5cbiAqL1xudmFyIGFwcGx5RWFjaFNlcmllcyA9IGFwcGx5RWFjaCQxKG1hcFNlcmllcyk7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmZvckVhY2hgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvclxuICogaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICovXG5mdW5jdGlvbiBhcnJheUVhY2goYXJyYXksIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBpZiAoaXRlcmF0ZWUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpID09PSBmYWxzZSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBhcnJheTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgYmFzZSBmdW5jdGlvbiBmb3IgbWV0aG9kcyBsaWtlIGBfLmZvckluYCBhbmQgYF8uZm9yT3duYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBiYXNlIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjcmVhdGVCYXNlRm9yKGZyb21SaWdodCkge1xuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0LCBpdGVyYXRlZSwga2V5c0Z1bmMpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgaXRlcmFibGUgPSBPYmplY3Qob2JqZWN0KSxcbiAgICAgICAgcHJvcHMgPSBrZXlzRnVuYyhvYmplY3QpLFxuICAgICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cbiAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgIHZhciBrZXkgPSBwcm9wc1tmcm9tUmlnaHQgPyBsZW5ndGggOiArK2luZGV4XTtcbiAgICAgIGlmIChpdGVyYXRlZShpdGVyYWJsZVtrZXldLCBrZXksIGl0ZXJhYmxlKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvYmplY3Q7XG4gIH07XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGJhc2VGb3JPd25gIHdoaWNoIGl0ZXJhdGVzIG92ZXIgYG9iamVjdGBcbiAqIHByb3BlcnRpZXMgcmV0dXJuZWQgYnkgYGtleXNGdW5jYCBhbmQgaW52b2tlcyBgaXRlcmF0ZWVgIGZvciBlYWNoIHByb3BlcnR5LlxuICogSXRlcmF0ZWUgZnVuY3Rpb25zIG1heSBleGl0IGl0ZXJhdGlvbiBlYXJseSBieSBleHBsaWNpdGx5IHJldHVybmluZyBgZmFsc2VgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGtleXNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIGtleXMgb2YgYG9iamVjdGAuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG52YXIgYmFzZUZvciA9IGNyZWF0ZUJhc2VGb3IoKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5mb3JPd25gIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBiYXNlRm9yT3duKG9iamVjdCwgaXRlcmF0ZWUpIHtcbiAgcmV0dXJuIG9iamVjdCAmJiBiYXNlRm9yKG9iamVjdCwgaXRlcmF0ZWUsIGtleXMpO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZpbmRJbmRleGAgYW5kIGBfLmZpbmRMYXN0SW5kZXhgIHdpdGhvdXRcbiAqIHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcGFyYW0ge251bWJlcn0gZnJvbUluZGV4IFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUZpbmRJbmRleChhcnJheSwgcHJlZGljYXRlLCBmcm9tSW5kZXgsIGZyb21SaWdodCkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgaW5kZXggPSBmcm9tSW5kZXggKyAoZnJvbVJpZ2h0ID8gMSA6IC0xKTtcblxuICB3aGlsZSAoKGZyb21SaWdodCA/IGluZGV4LS0gOiArK2luZGV4IDwgbGVuZ3RoKSkge1xuICAgIGlmIChwcmVkaWNhdGUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICByZXR1cm4gaW5kZXg7XG4gICAgfVxuICB9XG4gIHJldHVybiAtMTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc05hTmAgd2l0aG91dCBzdXBwb3J0IGZvciBudW1iZXIgb2JqZWN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBgTmFOYCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNOYU4odmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9PSB2YWx1ZTtcbn1cblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uaW5kZXhPZmAgd2hpY2ggcGVyZm9ybXMgc3RyaWN0IGVxdWFsaXR5XG4gKiBjb21wYXJpc29ucyBvZiB2YWx1ZXMsIGkuZS4gYD09PWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tSW5kZXggVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAqL1xuZnVuY3Rpb24gc3RyaWN0SW5kZXhPZihhcnJheSwgdmFsdWUsIGZyb21JbmRleCkge1xuICB2YXIgaW5kZXggPSBmcm9tSW5kZXggLSAxLFxuICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgaWYgKGFycmF5W2luZGV4XSA9PT0gdmFsdWUpIHtcbiAgICAgIHJldHVybiBpbmRleDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmluZGV4T2ZgIHdpdGhvdXQgYGZyb21JbmRleGAgYm91bmRzIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICogQHBhcmFtIHtudW1iZXJ9IGZyb21JbmRleCBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICovXG5mdW5jdGlvbiBiYXNlSW5kZXhPZihhcnJheSwgdmFsdWUsIGZyb21JbmRleCkge1xuICByZXR1cm4gdmFsdWUgPT09IHZhbHVlXG4gICAgPyBzdHJpY3RJbmRleE9mKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4KVxuICAgIDogYmFzZUZpbmRJbmRleChhcnJheSwgYmFzZUlzTmFOLCBmcm9tSW5kZXgpO1xufVxuXG4vKipcbiAqIERldGVybWluZXMgdGhlIGJlc3Qgb3JkZXIgZm9yIHJ1bm5pbmcgdGhlIHtAbGluayBBc3luY0Z1bmN0aW9ufXMgaW4gYHRhc2tzYCwgYmFzZWQgb25cbiAqIHRoZWlyIHJlcXVpcmVtZW50cy4gRWFjaCBmdW5jdGlvbiBjYW4gb3B0aW9uYWxseSBkZXBlbmQgb24gb3RoZXIgZnVuY3Rpb25zXG4gKiBiZWluZyBjb21wbGV0ZWQgZmlyc3QsIGFuZCBlYWNoIGZ1bmN0aW9uIGlzIHJ1biBhcyBzb29uIGFzIGl0cyByZXF1aXJlbWVudHNcbiAqIGFyZSBzYXRpc2ZpZWQuXG4gKlxuICogSWYgYW55IG9mIHRoZSB7QGxpbmsgQXN5bmNGdW5jdGlvbn1zIHBhc3MgYW4gZXJyb3IgdG8gdGhlaXIgY2FsbGJhY2ssIHRoZSBgYXV0b2Agc2VxdWVuY2VcbiAqIHdpbGwgc3RvcC4gRnVydGhlciB0YXNrcyB3aWxsIG5vdCBleGVjdXRlIChzbyBhbnkgb3RoZXIgZnVuY3Rpb25zIGRlcGVuZGluZ1xuICogb24gaXQgd2lsbCBub3QgcnVuKSwgYW5kIHRoZSBtYWluIGBjYWxsYmFja2AgaXMgaW1tZWRpYXRlbHkgY2FsbGVkIHdpdGggdGhlXG4gKiBlcnJvci5cbiAqXG4gKiB7QGxpbmsgQXN5bmNGdW5jdGlvbn1zIGFsc28gcmVjZWl2ZSBhbiBvYmplY3QgY29udGFpbmluZyB0aGUgcmVzdWx0cyBvZiBmdW5jdGlvbnMgd2hpY2hcbiAqIGhhdmUgY29tcGxldGVkIHNvIGZhciBhcyB0aGUgZmlyc3QgYXJndW1lbnQsIGlmIHRoZXkgaGF2ZSBkZXBlbmRlbmNpZXMuIElmIGFcbiAqIHRhc2sgZnVuY3Rpb24gaGFzIG5vIGRlcGVuZGVuY2llcywgaXQgd2lsbCBvbmx5IGJlIHBhc3NlZCBhIGNhbGxiYWNrLlxuICpcbiAqIEBuYW1lIGF1dG9cbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29udHJvbEZsb3dcbiAqIEBtZXRob2RcbiAqIEBjYXRlZ29yeSBDb250cm9sIEZsb3dcbiAqIEBwYXJhbSB7T2JqZWN0fSB0YXNrcyAtIEFuIG9iamVjdC4gRWFjaCBvZiBpdHMgcHJvcGVydGllcyBpcyBlaXRoZXIgYVxuICogZnVuY3Rpb24gb3IgYW4gYXJyYXkgb2YgcmVxdWlyZW1lbnRzLCB3aXRoIHRoZSB7QGxpbmsgQXN5bmNGdW5jdGlvbn0gaXRzZWxmIHRoZSBsYXN0IGl0ZW1cbiAqIGluIHRoZSBhcnJheS4gVGhlIG9iamVjdCdzIGtleSBvZiBhIHByb3BlcnR5IHNlcnZlcyBhcyB0aGUgbmFtZSBvZiB0aGUgdGFza1xuICogZGVmaW5lZCBieSB0aGF0IHByb3BlcnR5LCBpLmUuIGNhbiBiZSB1c2VkIHdoZW4gc3BlY2lmeWluZyByZXF1aXJlbWVudHMgZm9yXG4gKiBvdGhlciB0YXNrcy4gVGhlIGZ1bmN0aW9uIHJlY2VpdmVzIG9uZSBvciB0d28gYXJndW1lbnRzOlxuICogKiBhIGByZXN1bHRzYCBvYmplY3QsIGNvbnRhaW5pbmcgdGhlIHJlc3VsdHMgb2YgdGhlIHByZXZpb3VzbHkgZXhlY3V0ZWRcbiAqICAgZnVuY3Rpb25zLCBvbmx5IHBhc3NlZCBpZiB0aGUgdGFzayBoYXMgYW55IGRlcGVuZGVuY2llcyxcbiAqICogYSBgY2FsbGJhY2soZXJyLCByZXN1bHQpYCBmdW5jdGlvbiwgd2hpY2ggbXVzdCBiZSBjYWxsZWQgd2hlbiBmaW5pc2hlZCxcbiAqICAgcGFzc2luZyBhbiBgZXJyb3JgICh3aGljaCBjYW4gYmUgYG51bGxgKSBhbmQgdGhlIHJlc3VsdCBvZiB0aGUgZnVuY3Rpb24nc1xuICogICBleGVjdXRpb24uXG4gKiBAcGFyYW0ge251bWJlcn0gW2NvbmN1cnJlbmN5PUluZmluaXR5XSAtIEFuIG9wdGlvbmFsIGBpbnRlZ2VyYCBmb3JcbiAqIGRldGVybWluaW5nIHRoZSBtYXhpbXVtIG51bWJlciBvZiB0YXNrcyB0aGF0IGNhbiBiZSBydW4gaW4gcGFyYWxsZWwuIEJ5XG4gKiBkZWZhdWx0LCBhcyBtYW55IGFzIHBvc3NpYmxlLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEFuIG9wdGlvbmFsIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCB3aGVuIGFsbFxuICogdGhlIHRhc2tzIGhhdmUgYmVlbiBjb21wbGV0ZWQuIEl0IHJlY2VpdmVzIHRoZSBgZXJyYCBhcmd1bWVudCBpZiBhbnkgYHRhc2tzYFxuICogcGFzcyBhbiBlcnJvciB0byB0aGVpciBjYWxsYmFjay4gUmVzdWx0cyBhcmUgYWx3YXlzIHJldHVybmVkOyBob3dldmVyLCBpZiBhblxuICogZXJyb3Igb2NjdXJzLCBubyBmdXJ0aGVyIGB0YXNrc2Agd2lsbCBiZSBwZXJmb3JtZWQsIGFuZCB0aGUgcmVzdWx0cyBvYmplY3RcbiAqIHdpbGwgb25seSBjb250YWluIHBhcnRpYWwgcmVzdWx0cy4gSW52b2tlZCB3aXRoIChlcnIsIHJlc3VsdHMpLlxuICogQHJldHVybnMgdW5kZWZpbmVkXG4gKiBAZXhhbXBsZVxuICpcbiAqIGFzeW5jLmF1dG8oe1xuICogICAgIC8vIHRoaXMgZnVuY3Rpb24gd2lsbCBqdXN0IGJlIHBhc3NlZCBhIGNhbGxiYWNrXG4gKiAgICAgcmVhZERhdGE6IGFzeW5jLmFwcGx5KGZzLnJlYWRGaWxlLCAnZGF0YS50eHQnLCAndXRmLTgnKSxcbiAqICAgICBzaG93RGF0YTogWydyZWFkRGF0YScsIGZ1bmN0aW9uKHJlc3VsdHMsIGNiKSB7XG4gKiAgICAgICAgIC8vIHJlc3VsdHMucmVhZERhdGEgaXMgdGhlIGZpbGUncyBjb250ZW50c1xuICogICAgICAgICAvLyAuLi5cbiAqICAgICB9XVxuICogfSwgY2FsbGJhY2spO1xuICpcbiAqIGFzeW5jLmF1dG8oe1xuICogICAgIGdldF9kYXRhOiBmdW5jdGlvbihjYWxsYmFjaykge1xuICogICAgICAgICBjb25zb2xlLmxvZygnaW4gZ2V0X2RhdGEnKTtcbiAqICAgICAgICAgLy8gYXN5bmMgY29kZSB0byBnZXQgc29tZSBkYXRhXG4gKiAgICAgICAgIGNhbGxiYWNrKG51bGwsICdkYXRhJywgJ2NvbnZlcnRlZCB0byBhcnJheScpO1xuICogICAgIH0sXG4gKiAgICAgbWFrZV9mb2xkZXI6IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gKiAgICAgICAgIGNvbnNvbGUubG9nKCdpbiBtYWtlX2ZvbGRlcicpO1xuICogICAgICAgICAvLyBhc3luYyBjb2RlIHRvIGNyZWF0ZSBhIGRpcmVjdG9yeSB0byBzdG9yZSBhIGZpbGUgaW5cbiAqICAgICAgICAgLy8gdGhpcyBpcyBydW4gYXQgdGhlIHNhbWUgdGltZSBhcyBnZXR0aW5nIHRoZSBkYXRhXG4gKiAgICAgICAgIGNhbGxiYWNrKG51bGwsICdmb2xkZXInKTtcbiAqICAgICB9LFxuICogICAgIHdyaXRlX2ZpbGU6IFsnZ2V0X2RhdGEnLCAnbWFrZV9mb2xkZXInLCBmdW5jdGlvbihyZXN1bHRzLCBjYWxsYmFjaykge1xuICogICAgICAgICBjb25zb2xlLmxvZygnaW4gd3JpdGVfZmlsZScsIEpTT04uc3RyaW5naWZ5KHJlc3VsdHMpKTtcbiAqICAgICAgICAgLy8gb25jZSB0aGVyZSBpcyBzb21lIGRhdGEgYW5kIHRoZSBkaXJlY3RvcnkgZXhpc3RzLFxuICogICAgICAgICAvLyB3cml0ZSB0aGUgZGF0YSB0byBhIGZpbGUgaW4gdGhlIGRpcmVjdG9yeVxuICogICAgICAgICBjYWxsYmFjayhudWxsLCAnZmlsZW5hbWUnKTtcbiAqICAgICB9XSxcbiAqICAgICBlbWFpbF9saW5rOiBbJ3dyaXRlX2ZpbGUnLCBmdW5jdGlvbihyZXN1bHRzLCBjYWxsYmFjaykge1xuICogICAgICAgICBjb25zb2xlLmxvZygnaW4gZW1haWxfbGluaycsIEpTT04uc3RyaW5naWZ5KHJlc3VsdHMpKTtcbiAqICAgICAgICAgLy8gb25jZSB0aGUgZmlsZSBpcyB3cml0dGVuIGxldCdzIGVtYWlsIGEgbGluayB0byBpdC4uLlxuICogICAgICAgICAvLyByZXN1bHRzLndyaXRlX2ZpbGUgY29udGFpbnMgdGhlIGZpbGVuYW1lIHJldHVybmVkIGJ5IHdyaXRlX2ZpbGUuXG4gKiAgICAgICAgIGNhbGxiYWNrKG51bGwsIHsnZmlsZSc6cmVzdWx0cy53cml0ZV9maWxlLCAnZW1haWwnOid1c2VyQGV4YW1wbGUuY29tJ30pO1xuICogICAgIH1dXG4gKiB9LCBmdW5jdGlvbihlcnIsIHJlc3VsdHMpIHtcbiAqICAgICBjb25zb2xlLmxvZygnZXJyID0gJywgZXJyKTtcbiAqICAgICBjb25zb2xlLmxvZygncmVzdWx0cyA9ICcsIHJlc3VsdHMpO1xuICogfSk7XG4gKi9cbnZhciBhdXRvID0gZnVuY3Rpb24gKHRhc2tzLCBjb25jdXJyZW5jeSwgY2FsbGJhY2spIHtcbiAgICBpZiAodHlwZW9mIGNvbmN1cnJlbmN5ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIGNvbmN1cnJlbmN5IGlzIG9wdGlvbmFsLCBzaGlmdCB0aGUgYXJncy5cbiAgICAgICAgY2FsbGJhY2sgPSBjb25jdXJyZW5jeTtcbiAgICAgICAgY29uY3VycmVuY3kgPSBudWxsO1xuICAgIH1cbiAgICBjYWxsYmFjayA9IG9uY2UoY2FsbGJhY2sgfHwgbm9vcCk7XG4gICAgdmFyIGtleXMkJDEgPSBrZXlzKHRhc2tzKTtcbiAgICB2YXIgbnVtVGFza3MgPSBrZXlzJCQxLmxlbmd0aDtcbiAgICBpZiAoIW51bVRhc2tzKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsKTtcbiAgICB9XG4gICAgaWYgKCFjb25jdXJyZW5jeSkge1xuICAgICAgICBjb25jdXJyZW5jeSA9IG51bVRhc2tzO1xuICAgIH1cblxuICAgIHZhciByZXN1bHRzID0ge307XG4gICAgdmFyIHJ1bm5pbmdUYXNrcyA9IDA7XG4gICAgdmFyIGhhc0Vycm9yID0gZmFsc2U7XG5cbiAgICB2YXIgbGlzdGVuZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICAgIHZhciByZWFkeVRhc2tzID0gW107XG5cbiAgICAvLyBmb3IgY3ljbGUgZGV0ZWN0aW9uOlxuICAgIHZhciByZWFkeVRvQ2hlY2sgPSBbXTsgLy8gdGFza3MgdGhhdCBoYXZlIGJlZW4gaWRlbnRpZmllZCBhcyByZWFjaGFibGVcbiAgICAvLyB3aXRob3V0IHRoZSBwb3NzaWJpbGl0eSBvZiByZXR1cm5pbmcgdG8gYW4gYW5jZXN0b3IgdGFza1xuICAgIHZhciB1bmNoZWNrZWREZXBlbmRlbmNpZXMgPSB7fTtcblxuICAgIGJhc2VGb3JPd24odGFza3MsIGZ1bmN0aW9uICh0YXNrLCBrZXkpIHtcbiAgICAgICAgaWYgKCFpc0FycmF5KHRhc2spKSB7XG4gICAgICAgICAgICAvLyBubyBkZXBlbmRlbmNpZXNcbiAgICAgICAgICAgIGVucXVldWVUYXNrKGtleSwgW3Rhc2tdKTtcbiAgICAgICAgICAgIHJlYWR5VG9DaGVjay5wdXNoKGtleSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZGVwZW5kZW5jaWVzID0gdGFzay5zbGljZSgwLCB0YXNrLmxlbmd0aCAtIDEpO1xuICAgICAgICB2YXIgcmVtYWluaW5nRGVwZW5kZW5jaWVzID0gZGVwZW5kZW5jaWVzLmxlbmd0aDtcbiAgICAgICAgaWYgKHJlbWFpbmluZ0RlcGVuZGVuY2llcyA9PT0gMCkge1xuICAgICAgICAgICAgZW5xdWV1ZVRhc2soa2V5LCB0YXNrKTtcbiAgICAgICAgICAgIHJlYWR5VG9DaGVjay5wdXNoKGtleSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdW5jaGVja2VkRGVwZW5kZW5jaWVzW2tleV0gPSByZW1haW5pbmdEZXBlbmRlbmNpZXM7XG5cbiAgICAgICAgYXJyYXlFYWNoKGRlcGVuZGVuY2llcywgZnVuY3Rpb24gKGRlcGVuZGVuY3lOYW1lKSB7XG4gICAgICAgICAgICBpZiAoIXRhc2tzW2RlcGVuZGVuY3lOYW1lXSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYXN5bmMuYXV0byB0YXNrIGAnICsga2V5ICtcbiAgICAgICAgICAgICAgICAgICAgJ2AgaGFzIGEgbm9uLWV4aXN0ZW50IGRlcGVuZGVuY3kgYCcgK1xuICAgICAgICAgICAgICAgICAgICBkZXBlbmRlbmN5TmFtZSArICdgIGluICcgK1xuICAgICAgICAgICAgICAgICAgICBkZXBlbmRlbmNpZXMuam9pbignLCAnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhZGRMaXN0ZW5lcihkZXBlbmRlbmN5TmFtZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJlbWFpbmluZ0RlcGVuZGVuY2llcy0tO1xuICAgICAgICAgICAgICAgIGlmIChyZW1haW5pbmdEZXBlbmRlbmNpZXMgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZW5xdWV1ZVRhc2soa2V5LCB0YXNrKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBjaGVja0ZvckRlYWRsb2NrcygpO1xuICAgIHByb2Nlc3NRdWV1ZSgpO1xuXG4gICAgZnVuY3Rpb24gZW5xdWV1ZVRhc2soa2V5LCB0YXNrKSB7XG4gICAgICAgIHJlYWR5VGFza3MucHVzaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBydW5UYXNrKGtleSwgdGFzayk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHByb2Nlc3NRdWV1ZSgpIHtcbiAgICAgICAgaWYgKHJlYWR5VGFza3MubGVuZ3RoID09PSAwICYmIHJ1bm5pbmdUYXNrcyA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIHJlc3VsdHMpO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlKHJlYWR5VGFza3MubGVuZ3RoICYmIHJ1bm5pbmdUYXNrcyA8IGNvbmN1cnJlbmN5KSB7XG4gICAgICAgICAgICB2YXIgcnVuID0gcmVhZHlUYXNrcy5zaGlmdCgpO1xuICAgICAgICAgICAgcnVuKCk7XG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkZExpc3RlbmVyKHRhc2tOYW1lLCBmbikge1xuICAgICAgICB2YXIgdGFza0xpc3RlbmVycyA9IGxpc3RlbmVyc1t0YXNrTmFtZV07XG4gICAgICAgIGlmICghdGFza0xpc3RlbmVycykge1xuICAgICAgICAgICAgdGFza0xpc3RlbmVycyA9IGxpc3RlbmVyc1t0YXNrTmFtZV0gPSBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRhc2tMaXN0ZW5lcnMucHVzaChmbik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdGFza0NvbXBsZXRlKHRhc2tOYW1lKSB7XG4gICAgICAgIHZhciB0YXNrTGlzdGVuZXJzID0gbGlzdGVuZXJzW3Rhc2tOYW1lXSB8fCBbXTtcbiAgICAgICAgYXJyYXlFYWNoKHRhc2tMaXN0ZW5lcnMsIGZ1bmN0aW9uIChmbikge1xuICAgICAgICAgICAgZm4oKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHByb2Nlc3NRdWV1ZSgpO1xuICAgIH1cblxuXG4gICAgZnVuY3Rpb24gcnVuVGFzayhrZXksIHRhc2spIHtcbiAgICAgICAgaWYgKGhhc0Vycm9yKSByZXR1cm47XG5cbiAgICAgICAgdmFyIHRhc2tDYWxsYmFjayA9IG9ubHlPbmNlKGZ1bmN0aW9uKGVyciwgcmVzdWx0KSB7XG4gICAgICAgICAgICBydW5uaW5nVGFza3MtLTtcbiAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMikge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHNsaWNlKGFyZ3VtZW50cywgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNhZmVSZXN1bHRzID0ge307XG4gICAgICAgICAgICAgICAgYmFzZUZvck93bihyZXN1bHRzLCBmdW5jdGlvbih2YWwsIHJrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgc2FmZVJlc3VsdHNbcmtleV0gPSB2YWw7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgc2FmZVJlc3VsdHNba2V5XSA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgICBoYXNFcnJvciA9IHRydWU7XG4gICAgICAgICAgICAgICAgbGlzdGVuZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVyciwgc2FmZVJlc3VsdHMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHRzW2tleV0gPSByZXN1bHQ7XG4gICAgICAgICAgICAgICAgdGFza0NvbXBsZXRlKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJ1bm5pbmdUYXNrcysrO1xuICAgICAgICB2YXIgdGFza0ZuID0gd3JhcEFzeW5jKHRhc2tbdGFzay5sZW5ndGggLSAxXSk7XG4gICAgICAgIGlmICh0YXNrLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHRhc2tGbihyZXN1bHRzLCB0YXNrQ2FsbGJhY2spO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGFza0ZuKHRhc2tDYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjaGVja0ZvckRlYWRsb2NrcygpIHtcbiAgICAgICAgLy8gS2FobidzIGFsZ29yaXRobVxuICAgICAgICAvLyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Ub3BvbG9naWNhbF9zb3J0aW5nI0thaG4uMjdzX2FsZ29yaXRobVxuICAgICAgICAvLyBodHRwOi8vY29ubmFsbGUuYmxvZ3Nwb3QuY29tLzIwMTMvMTAvdG9wb2xvZ2ljYWwtc29ydGluZ2thaG4tYWxnb3JpdGhtLmh0bWxcbiAgICAgICAgdmFyIGN1cnJlbnRUYXNrO1xuICAgICAgICB2YXIgY291bnRlciA9IDA7XG4gICAgICAgIHdoaWxlIChyZWFkeVRvQ2hlY2subGVuZ3RoKSB7XG4gICAgICAgICAgICBjdXJyZW50VGFzayA9IHJlYWR5VG9DaGVjay5wb3AoKTtcbiAgICAgICAgICAgIGNvdW50ZXIrKztcbiAgICAgICAgICAgIGFycmF5RWFjaChnZXREZXBlbmRlbnRzKGN1cnJlbnRUYXNrKSwgZnVuY3Rpb24gKGRlcGVuZGVudCkge1xuICAgICAgICAgICAgICAgIGlmICgtLXVuY2hlY2tlZERlcGVuZGVuY2llc1tkZXBlbmRlbnRdID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlYWR5VG9DaGVjay5wdXNoKGRlcGVuZGVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY291bnRlciAhPT0gbnVtVGFza3MpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICAnYXN5bmMuYXV0byBjYW5ub3QgZXhlY3V0ZSB0YXNrcyBkdWUgdG8gYSByZWN1cnNpdmUgZGVwZW5kZW5jeSdcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXREZXBlbmRlbnRzKHRhc2tOYW1lKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgYmFzZUZvck93bih0YXNrcywgZnVuY3Rpb24gKHRhc2ssIGtleSkge1xuICAgICAgICAgICAgaWYgKGlzQXJyYXkodGFzaykgJiYgYmFzZUluZGV4T2YodGFzaywgdGFza05hbWUsIDApID49IDApIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59O1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5tYXBgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZVxuICogc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IG1hcHBlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYXJyYXlNYXAoYXJyYXksIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGgsXG4gICAgICByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgcmVzdWx0W2luZGV4XSA9IGl0ZXJhdGVlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXSc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBTeW1ib2xgIHByaW1pdGl2ZSBvciBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzeW1ib2wsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1N5bWJvbChTeW1ib2wuaXRlcmF0b3IpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNTeW1ib2woJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNTeW1ib2wodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnc3ltYm9sJyB8fFxuICAgIChpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IHN5bWJvbFRhZyk7XG59XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIElORklOSVRZID0gMSAvIDA7XG5cbi8qKiBVc2VkIHRvIGNvbnZlcnQgc3ltYm9scyB0byBwcmltaXRpdmVzIGFuZCBzdHJpbmdzLiAqL1xudmFyIHN5bWJvbFByb3RvID0gU3ltYm9sJDEgPyBTeW1ib2wkMS5wcm90b3R5cGUgOiB1bmRlZmluZWQ7XG52YXIgc3ltYm9sVG9TdHJpbmcgPSBzeW1ib2xQcm90byA/IHN5bWJvbFByb3RvLnRvU3RyaW5nIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRvU3RyaW5nYCB3aGljaCBkb2Vzbid0IGNvbnZlcnQgbnVsbGlzaFxuICogdmFsdWVzIHRvIGVtcHR5IHN0cmluZ3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGJhc2VUb1N0cmluZyh2YWx1ZSkge1xuICAvLyBFeGl0IGVhcmx5IGZvciBzdHJpbmdzIHRvIGF2b2lkIGEgcGVyZm9ybWFuY2UgaGl0IGluIHNvbWUgZW52aXJvbm1lbnRzLlxuICBpZiAodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbnZlcnQgdmFsdWVzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgcmV0dXJuIGFycmF5TWFwKHZhbHVlLCBiYXNlVG9TdHJpbmcpICsgJyc7XG4gIH1cbiAgaWYgKGlzU3ltYm9sKHZhbHVlKSkge1xuICAgIHJldHVybiBzeW1ib2xUb1N0cmluZyA/IHN5bWJvbFRvU3RyaW5nLmNhbGwodmFsdWUpIDogJyc7XG4gIH1cbiAgdmFyIHJlc3VsdCA9ICh2YWx1ZSArICcnKTtcbiAgcmV0dXJuIChyZXN1bHQgPT0gJzAnICYmICgxIC8gdmFsdWUpID09IC1JTkZJTklUWSkgPyAnLTAnIDogcmVzdWx0O1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnNsaWNlYCB3aXRob3V0IGFuIGl0ZXJhdGVlIGNhbGwgZ3VhcmQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzbGljZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9MF0gVGhlIHN0YXJ0IHBvc2l0aW9uLlxuICogQHBhcmFtIHtudW1iZXJ9IFtlbmQ9YXJyYXkubGVuZ3RoXSBUaGUgZW5kIHBvc2l0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxuICovXG5mdW5jdGlvbiBiYXNlU2xpY2UoYXJyYXksIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgaWYgKHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ID0gLXN0YXJ0ID4gbGVuZ3RoID8gMCA6IChsZW5ndGggKyBzdGFydCk7XG4gIH1cbiAgZW5kID0gZW5kID4gbGVuZ3RoID8gbGVuZ3RoIDogZW5kO1xuICBpZiAoZW5kIDwgMCkge1xuICAgIGVuZCArPSBsZW5ndGg7XG4gIH1cbiAgbGVuZ3RoID0gc3RhcnQgPiBlbmQgPyAwIDogKChlbmQgLSBzdGFydCkgPj4+IDApO1xuICBzdGFydCA+Pj49IDA7XG5cbiAgdmFyIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgcmVzdWx0W2luZGV4XSA9IGFycmF5W2luZGV4ICsgc3RhcnRdO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQ2FzdHMgYGFycmF5YCB0byBhIHNsaWNlIGlmIGl0J3MgbmVlZGVkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCBUaGUgc3RhcnQgcG9zaXRpb24uXG4gKiBAcGFyYW0ge251bWJlcn0gW2VuZD1hcnJheS5sZW5ndGhdIFRoZSBlbmQgcG9zaXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNhc3Qgc2xpY2UuXG4gKi9cbmZ1bmN0aW9uIGNhc3RTbGljZShhcnJheSwgc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbmd0aCA6IGVuZDtcbiAgcmV0dXJuICghc3RhcnQgJiYgZW5kID49IGxlbmd0aCkgPyBhcnJheSA6IGJhc2VTbGljZShhcnJheSwgc3RhcnQsIGVuZCk7XG59XG5cbi8qKlxuICogVXNlZCBieSBgXy50cmltYCBhbmQgYF8udHJpbUVuZGAgdG8gZ2V0IHRoZSBpbmRleCBvZiB0aGUgbGFzdCBzdHJpbmcgc3ltYm9sXG4gKiB0aGF0IGlzIG5vdCBmb3VuZCBpbiB0aGUgY2hhcmFjdGVyIHN5bWJvbHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IHN0clN5bWJvbHMgVGhlIHN0cmluZyBzeW1ib2xzIHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge0FycmF5fSBjaHJTeW1ib2xzIFRoZSBjaGFyYWN0ZXIgc3ltYm9scyB0byBmaW5kLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGxhc3QgdW5tYXRjaGVkIHN0cmluZyBzeW1ib2wuXG4gKi9cbmZ1bmN0aW9uIGNoYXJzRW5kSW5kZXgoc3RyU3ltYm9scywgY2hyU3ltYm9scykge1xuICB2YXIgaW5kZXggPSBzdHJTeW1ib2xzLmxlbmd0aDtcblxuICB3aGlsZSAoaW5kZXgtLSAmJiBiYXNlSW5kZXhPZihjaHJTeW1ib2xzLCBzdHJTeW1ib2xzW2luZGV4XSwgMCkgPiAtMSkge31cbiAgcmV0dXJuIGluZGV4O1xufVxuXG4vKipcbiAqIFVzZWQgYnkgYF8udHJpbWAgYW5kIGBfLnRyaW1TdGFydGAgdG8gZ2V0IHRoZSBpbmRleCBvZiB0aGUgZmlyc3Qgc3RyaW5nIHN5bWJvbFxuICogdGhhdCBpcyBub3QgZm91bmQgaW4gdGhlIGNoYXJhY3RlciBzeW1ib2xzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBzdHJTeW1ib2xzIFRoZSBzdHJpbmcgc3ltYm9scyB0byBpbnNwZWN0LlxuICogQHBhcmFtIHtBcnJheX0gY2hyU3ltYm9scyBUaGUgY2hhcmFjdGVyIHN5bWJvbHMgdG8gZmluZC5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBmaXJzdCB1bm1hdGNoZWQgc3RyaW5nIHN5bWJvbC5cbiAqL1xuZnVuY3Rpb24gY2hhcnNTdGFydEluZGV4KHN0clN5bWJvbHMsIGNoclN5bWJvbHMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBzdHJTeW1ib2xzLmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCAmJiBiYXNlSW5kZXhPZihjaHJTeW1ib2xzLCBzdHJTeW1ib2xzW2luZGV4XSwgMCkgPiAtMSkge31cbiAgcmV0dXJuIGluZGV4O1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIEFTQ0lJIGBzdHJpbmdgIHRvIGFuIGFycmF5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY29udmVydGVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBhc2NpaVRvQXJyYXkoc3RyaW5nKSB7XG4gIHJldHVybiBzdHJpbmcuc3BsaXQoJycpO1xufVxuXG4vKiogVXNlZCB0byBjb21wb3NlIHVuaWNvZGUgY2hhcmFjdGVyIGNsYXNzZXMuICovXG52YXIgcnNBc3RyYWxSYW5nZSA9ICdcXFxcdWQ4MDAtXFxcXHVkZmZmJztcbnZhciByc0NvbWJvTWFya3NSYW5nZSA9ICdcXFxcdTAzMDAtXFxcXHUwMzZmJztcbnZhciByZUNvbWJvSGFsZk1hcmtzUmFuZ2UgPSAnXFxcXHVmZTIwLVxcXFx1ZmUyZic7XG52YXIgcnNDb21ib1N5bWJvbHNSYW5nZSA9ICdcXFxcdTIwZDAtXFxcXHUyMGZmJztcbnZhciByc0NvbWJvUmFuZ2UgPSByc0NvbWJvTWFya3NSYW5nZSArIHJlQ29tYm9IYWxmTWFya3NSYW5nZSArIHJzQ29tYm9TeW1ib2xzUmFuZ2U7XG52YXIgcnNWYXJSYW5nZSA9ICdcXFxcdWZlMGVcXFxcdWZlMGYnO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIHVuaWNvZGUgY2FwdHVyZSBncm91cHMuICovXG52YXIgcnNaV0ogPSAnXFxcXHUyMDBkJztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IHN0cmluZ3Mgd2l0aCBbemVyby13aWR0aCBqb2luZXJzIG9yIGNvZGUgcG9pbnRzIGZyb20gdGhlIGFzdHJhbCBwbGFuZXNdKGh0dHA6Ly9lZXYuZWUvYmxvZy8yMDE1LzA5LzEyL2RhcmstY29ybmVycy1vZi11bmljb2RlLykuICovXG52YXIgcmVIYXNVbmljb2RlID0gUmVnRXhwKCdbJyArIHJzWldKICsgcnNBc3RyYWxSYW5nZSAgKyByc0NvbWJvUmFuZ2UgKyByc1ZhclJhbmdlICsgJ10nKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHN0cmluZ2AgY29udGFpbnMgVW5pY29kZSBzeW1ib2xzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gaW5zcGVjdC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhIHN5bWJvbCBpcyBmb3VuZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBoYXNVbmljb2RlKHN0cmluZykge1xuICByZXR1cm4gcmVIYXNVbmljb2RlLnRlc3Qoc3RyaW5nKTtcbn1cblxuLyoqIFVzZWQgdG8gY29tcG9zZSB1bmljb2RlIGNoYXJhY3RlciBjbGFzc2VzLiAqL1xudmFyIHJzQXN0cmFsUmFuZ2UkMSA9ICdcXFxcdWQ4MDAtXFxcXHVkZmZmJztcbnZhciByc0NvbWJvTWFya3NSYW5nZSQxID0gJ1xcXFx1MDMwMC1cXFxcdTAzNmYnO1xudmFyIHJlQ29tYm9IYWxmTWFya3NSYW5nZSQxID0gJ1xcXFx1ZmUyMC1cXFxcdWZlMmYnO1xudmFyIHJzQ29tYm9TeW1ib2xzUmFuZ2UkMSA9ICdcXFxcdTIwZDAtXFxcXHUyMGZmJztcbnZhciByc0NvbWJvUmFuZ2UkMSA9IHJzQ29tYm9NYXJrc1JhbmdlJDEgKyByZUNvbWJvSGFsZk1hcmtzUmFuZ2UkMSArIHJzQ29tYm9TeW1ib2xzUmFuZ2UkMTtcbnZhciByc1ZhclJhbmdlJDEgPSAnXFxcXHVmZTBlXFxcXHVmZTBmJztcblxuLyoqIFVzZWQgdG8gY29tcG9zZSB1bmljb2RlIGNhcHR1cmUgZ3JvdXBzLiAqL1xudmFyIHJzQXN0cmFsID0gJ1snICsgcnNBc3RyYWxSYW5nZSQxICsgJ10nO1xudmFyIHJzQ29tYm8gPSAnWycgKyByc0NvbWJvUmFuZ2UkMSArICddJztcbnZhciByc0ZpdHogPSAnXFxcXHVkODNjW1xcXFx1ZGZmYi1cXFxcdWRmZmZdJztcbnZhciByc01vZGlmaWVyID0gJyg/OicgKyByc0NvbWJvICsgJ3wnICsgcnNGaXR6ICsgJyknO1xudmFyIHJzTm9uQXN0cmFsID0gJ1teJyArIHJzQXN0cmFsUmFuZ2UkMSArICddJztcbnZhciByc1JlZ2lvbmFsID0gJyg/OlxcXFx1ZDgzY1tcXFxcdWRkZTYtXFxcXHVkZGZmXSl7Mn0nO1xudmFyIHJzU3VyclBhaXIgPSAnW1xcXFx1ZDgwMC1cXFxcdWRiZmZdW1xcXFx1ZGMwMC1cXFxcdWRmZmZdJztcbnZhciByc1pXSiQxID0gJ1xcXFx1MjAwZCc7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgdW5pY29kZSByZWdleGVzLiAqL1xudmFyIHJlT3B0TW9kID0gcnNNb2RpZmllciArICc/JztcbnZhciByc09wdFZhciA9ICdbJyArIHJzVmFyUmFuZ2UkMSArICddPyc7XG52YXIgcnNPcHRKb2luID0gJyg/OicgKyByc1pXSiQxICsgJyg/OicgKyBbcnNOb25Bc3RyYWwsIHJzUmVnaW9uYWwsIHJzU3VyclBhaXJdLmpvaW4oJ3wnKSArICcpJyArIHJzT3B0VmFyICsgcmVPcHRNb2QgKyAnKSonO1xudmFyIHJzU2VxID0gcnNPcHRWYXIgKyByZU9wdE1vZCArIHJzT3B0Sm9pbjtcbnZhciByc1N5bWJvbCA9ICcoPzonICsgW3JzTm9uQXN0cmFsICsgcnNDb21ibyArICc/JywgcnNDb21ibywgcnNSZWdpb25hbCwgcnNTdXJyUGFpciwgcnNBc3RyYWxdLmpvaW4oJ3wnKSArICcpJztcblxuLyoqIFVzZWQgdG8gbWF0Y2ggW3N0cmluZyBzeW1ib2xzXShodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC11bmljb2RlKS4gKi9cbnZhciByZVVuaWNvZGUgPSBSZWdFeHAocnNGaXR6ICsgJyg/PScgKyByc0ZpdHogKyAnKXwnICsgcnNTeW1ib2wgKyByc1NlcSwgJ2cnKTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIFVuaWNvZGUgYHN0cmluZ2AgdG8gYW4gYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIHVuaWNvZGVUb0FycmF5KHN0cmluZykge1xuICByZXR1cm4gc3RyaW5nLm1hdGNoKHJlVW5pY29kZSkgfHwgW107XG59XG5cbi8qKlxuICogQ29udmVydHMgYHN0cmluZ2AgdG8gYW4gYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIHN0cmluZ1RvQXJyYXkoc3RyaW5nKSB7XG4gIHJldHVybiBoYXNVbmljb2RlKHN0cmluZylcbiAgICA/IHVuaWNvZGVUb0FycmF5KHN0cmluZylcbiAgICA6IGFzY2lpVG9BcnJheShzdHJpbmcpO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcuIEFuIGVtcHR5IHN0cmluZyBpcyByZXR1cm5lZCBmb3IgYG51bGxgXG4gKiBhbmQgYHVuZGVmaW5lZGAgdmFsdWVzLiBUaGUgc2lnbiBvZiBgLTBgIGlzIHByZXNlcnZlZC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBzdHJpbmcuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udG9TdHJpbmcobnVsbCk7XG4gKiAvLyA9PiAnJ1xuICpcbiAqIF8udG9TdHJpbmcoLTApO1xuICogLy8gPT4gJy0wJ1xuICpcbiAqIF8udG9TdHJpbmcoWzEsIDIsIDNdKTtcbiAqIC8vID0+ICcxLDIsMydcbiAqL1xuZnVuY3Rpb24gdG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09IG51bGwgPyAnJyA6IGJhc2VUb1N0cmluZyh2YWx1ZSk7XG59XG5cbi8qKiBVc2VkIHRvIG1hdGNoIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHdoaXRlc3BhY2UuICovXG52YXIgcmVUcmltID0gL15cXHMrfFxccyskL2c7XG5cbi8qKlxuICogUmVtb3ZlcyBsZWFkaW5nIGFuZCB0cmFpbGluZyB3aGl0ZXNwYWNlIG9yIHNwZWNpZmllZCBjaGFyYWN0ZXJzIGZyb20gYHN0cmluZ2AuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjAuMFxuICogQGNhdGVnb3J5IFN0cmluZ1xuICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gdHJpbS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbY2hhcnM9d2hpdGVzcGFjZV0gVGhlIGNoYXJhY3RlcnMgdG8gdHJpbS5cbiAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSB0cmltbWVkIHN0cmluZy5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50cmltKCcgIGFiYyAgJyk7XG4gKiAvLyA9PiAnYWJjJ1xuICpcbiAqIF8udHJpbSgnLV8tYWJjLV8tJywgJ18tJyk7XG4gKiAvLyA9PiAnYWJjJ1xuICpcbiAqIF8ubWFwKFsnICBmb28gICcsICcgIGJhciAgJ10sIF8udHJpbSk7XG4gKiAvLyA9PiBbJ2ZvbycsICdiYXInXVxuICovXG5mdW5jdGlvbiB0cmltKHN0cmluZywgY2hhcnMsIGd1YXJkKSB7XG4gIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gIGlmIChzdHJpbmcgJiYgKGd1YXJkIHx8IGNoYXJzID09PSB1bmRlZmluZWQpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKHJlVHJpbSwgJycpO1xuICB9XG4gIGlmICghc3RyaW5nIHx8ICEoY2hhcnMgPSBiYXNlVG9TdHJpbmcoY2hhcnMpKSkge1xuICAgIHJldHVybiBzdHJpbmc7XG4gIH1cbiAgdmFyIHN0clN5bWJvbHMgPSBzdHJpbmdUb0FycmF5KHN0cmluZyksXG4gICAgICBjaHJTeW1ib2xzID0gc3RyaW5nVG9BcnJheShjaGFycyksXG4gICAgICBzdGFydCA9IGNoYXJzU3RhcnRJbmRleChzdHJTeW1ib2xzLCBjaHJTeW1ib2xzKSxcbiAgICAgIGVuZCA9IGNoYXJzRW5kSW5kZXgoc3RyU3ltYm9scywgY2hyU3ltYm9scykgKyAxO1xuXG4gIHJldHVybiBjYXN0U2xpY2Uoc3RyU3ltYm9scywgc3RhcnQsIGVuZCkuam9pbignJyk7XG59XG5cbnZhciBGTl9BUkdTID0gL14oPzphc3luY1xccyspPyhmdW5jdGlvbik/XFxzKlteXFwoXSpcXChcXHMqKFteXFwpXSopXFwpL207XG52YXIgRk5fQVJHX1NQTElUID0gLywvO1xudmFyIEZOX0FSRyA9IC8oPS4rKT8oXFxzKikkLztcbnZhciBTVFJJUF9DT01NRU5UUyA9IC8oKFxcL1xcLy4qJCl8KFxcL1xcKltcXHNcXFNdKj9cXCpcXC8pKS9tZztcblxuZnVuY3Rpb24gcGFyc2VQYXJhbXMoZnVuYykge1xuICAgIGZ1bmMgPSBmdW5jLnRvU3RyaW5nKCkucmVwbGFjZShTVFJJUF9DT01NRU5UUywgJycpO1xuICAgIGZ1bmMgPSBmdW5jLm1hdGNoKEZOX0FSR1MpWzJdLnJlcGxhY2UoJyAnLCAnJyk7XG4gICAgZnVuYyA9IGZ1bmMgPyBmdW5jLnNwbGl0KEZOX0FSR19TUExJVCkgOiBbXTtcbiAgICBmdW5jID0gZnVuYy5tYXAoZnVuY3Rpb24gKGFyZyl7XG4gICAgICAgIHJldHVybiB0cmltKGFyZy5yZXBsYWNlKEZOX0FSRywgJycpKTtcbiAgICB9KTtcbiAgICByZXR1cm4gZnVuYztcbn1cblxuLyoqXG4gKiBBIGRlcGVuZGVuY3ktaW5qZWN0ZWQgdmVyc2lvbiBvZiB0aGUgW2FzeW5jLmF1dG9de0BsaW5rIG1vZHVsZTpDb250cm9sRmxvdy5hdXRvfSBmdW5jdGlvbi4gRGVwZW5kZW50XG4gKiB0YXNrcyBhcmUgc3BlY2lmaWVkIGFzIHBhcmFtZXRlcnMgdG8gdGhlIGZ1bmN0aW9uLCBhZnRlciB0aGUgdXN1YWwgY2FsbGJhY2tcbiAqIHBhcmFtZXRlciwgd2l0aCB0aGUgcGFyYW1ldGVyIG5hbWVzIG1hdGNoaW5nIHRoZSBuYW1lcyBvZiB0aGUgdGFza3MgaXRcbiAqIGRlcGVuZHMgb24uIFRoaXMgY2FuIHByb3ZpZGUgZXZlbiBtb3JlIHJlYWRhYmxlIHRhc2sgZ3JhcGhzIHdoaWNoIGNhbiBiZVxuICogZWFzaWVyIHRvIG1haW50YWluLlxuICpcbiAqIElmIGEgZmluYWwgY2FsbGJhY2sgaXMgc3BlY2lmaWVkLCB0aGUgdGFzayByZXN1bHRzIGFyZSBzaW1pbGFybHkgaW5qZWN0ZWQsXG4gKiBzcGVjaWZpZWQgYXMgbmFtZWQgcGFyYW1ldGVycyBhZnRlciB0aGUgaW5pdGlhbCBlcnJvciBwYXJhbWV0ZXIuXG4gKlxuICogVGhlIGF1dG9JbmplY3QgZnVuY3Rpb24gaXMgcHVyZWx5IHN5bnRhY3RpYyBzdWdhciBhbmQgaXRzIHNlbWFudGljcyBhcmVcbiAqIG90aGVyd2lzZSBlcXVpdmFsZW50IHRvIFthc3luYy5hdXRvXXtAbGluayBtb2R1bGU6Q29udHJvbEZsb3cuYXV0b30uXG4gKlxuICogQG5hbWUgYXV0b0luamVjdFxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpDb250cm9sRmxvd1xuICogQG1ldGhvZFxuICogQHNlZSBbYXN5bmMuYXV0b117QGxpbmsgbW9kdWxlOkNvbnRyb2xGbG93LmF1dG99XG4gKiBAY2F0ZWdvcnkgQ29udHJvbCBGbG93XG4gKiBAcGFyYW0ge09iamVjdH0gdGFza3MgLSBBbiBvYmplY3QsIGVhY2ggb2Ygd2hvc2UgcHJvcGVydGllcyBpcyBhbiB7QGxpbmsgQXN5bmNGdW5jdGlvbn0gb2ZcbiAqIHRoZSBmb3JtICdmdW5jKFtkZXBlbmRlbmNpZXMuLi5dLCBjYWxsYmFjaykuIFRoZSBvYmplY3QncyBrZXkgb2YgYSBwcm9wZXJ0eVxuICogc2VydmVzIGFzIHRoZSBuYW1lIG9mIHRoZSB0YXNrIGRlZmluZWQgYnkgdGhhdCBwcm9wZXJ0eSwgaS5lLiBjYW4gYmUgdXNlZFxuICogd2hlbiBzcGVjaWZ5aW5nIHJlcXVpcmVtZW50cyBmb3Igb3RoZXIgdGFza3MuXG4gKiAqIFRoZSBgY2FsbGJhY2tgIHBhcmFtZXRlciBpcyBhIGBjYWxsYmFjayhlcnIsIHJlc3VsdClgIHdoaWNoIG11c3QgYmUgY2FsbGVkXG4gKiAgIHdoZW4gZmluaXNoZWQsIHBhc3NpbmcgYW4gYGVycm9yYCAod2hpY2ggY2FuIGJlIGBudWxsYCkgYW5kIHRoZSByZXN1bHQgb2ZcbiAqICAgdGhlIGZ1bmN0aW9uJ3MgZXhlY3V0aW9uLiBUaGUgcmVtYWluaW5nIHBhcmFtZXRlcnMgbmFtZSBvdGhlciB0YXNrcyBvblxuICogICB3aGljaCB0aGUgdGFzayBpcyBkZXBlbmRlbnQsIGFuZCB0aGUgcmVzdWx0cyBmcm9tIHRob3NlIHRhc2tzIGFyZSB0aGVcbiAqICAgYXJndW1lbnRzIG9mIHRob3NlIHBhcmFtZXRlcnMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQW4gb3B0aW9uYWwgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIHdoZW4gYWxsXG4gKiB0aGUgdGFza3MgaGF2ZSBiZWVuIGNvbXBsZXRlZC4gSXQgcmVjZWl2ZXMgdGhlIGBlcnJgIGFyZ3VtZW50IGlmIGFueSBgdGFza3NgXG4gKiBwYXNzIGFuIGVycm9yIHRvIHRoZWlyIGNhbGxiYWNrLCBhbmQgYSBgcmVzdWx0c2Agb2JqZWN0IHdpdGggYW55IGNvbXBsZXRlZFxuICogdGFzayByZXN1bHRzLCBzaW1pbGFyIHRvIGBhdXRvYC5cbiAqIEBleGFtcGxlXG4gKlxuICogLy8gIFRoZSBleGFtcGxlIGZyb20gYGF1dG9gIGNhbiBiZSByZXdyaXR0ZW4gYXMgZm9sbG93czpcbiAqIGFzeW5jLmF1dG9JbmplY3Qoe1xuICogICAgIGdldF9kYXRhOiBmdW5jdGlvbihjYWxsYmFjaykge1xuICogICAgICAgICAvLyBhc3luYyBjb2RlIHRvIGdldCBzb21lIGRhdGFcbiAqICAgICAgICAgY2FsbGJhY2sobnVsbCwgJ2RhdGEnLCAnY29udmVydGVkIHRvIGFycmF5Jyk7XG4gKiAgICAgfSxcbiAqICAgICBtYWtlX2ZvbGRlcjogZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAqICAgICAgICAgLy8gYXN5bmMgY29kZSB0byBjcmVhdGUgYSBkaXJlY3RvcnkgdG8gc3RvcmUgYSBmaWxlIGluXG4gKiAgICAgICAgIC8vIHRoaXMgaXMgcnVuIGF0IHRoZSBzYW1lIHRpbWUgYXMgZ2V0dGluZyB0aGUgZGF0YVxuICogICAgICAgICBjYWxsYmFjayhudWxsLCAnZm9sZGVyJyk7XG4gKiAgICAgfSxcbiAqICAgICB3cml0ZV9maWxlOiBmdW5jdGlvbihnZXRfZGF0YSwgbWFrZV9mb2xkZXIsIGNhbGxiYWNrKSB7XG4gKiAgICAgICAgIC8vIG9uY2UgdGhlcmUgaXMgc29tZSBkYXRhIGFuZCB0aGUgZGlyZWN0b3J5IGV4aXN0cyxcbiAqICAgICAgICAgLy8gd3JpdGUgdGhlIGRhdGEgdG8gYSBmaWxlIGluIHRoZSBkaXJlY3RvcnlcbiAqICAgICAgICAgY2FsbGJhY2sobnVsbCwgJ2ZpbGVuYW1lJyk7XG4gKiAgICAgfSxcbiAqICAgICBlbWFpbF9saW5rOiBmdW5jdGlvbih3cml0ZV9maWxlLCBjYWxsYmFjaykge1xuICogICAgICAgICAvLyBvbmNlIHRoZSBmaWxlIGlzIHdyaXR0ZW4gbGV0J3MgZW1haWwgYSBsaW5rIHRvIGl0Li4uXG4gKiAgICAgICAgIC8vIHdyaXRlX2ZpbGUgY29udGFpbnMgdGhlIGZpbGVuYW1lIHJldHVybmVkIGJ5IHdyaXRlX2ZpbGUuXG4gKiAgICAgICAgIGNhbGxiYWNrKG51bGwsIHsnZmlsZSc6d3JpdGVfZmlsZSwgJ2VtYWlsJzondXNlckBleGFtcGxlLmNvbSd9KTtcbiAqICAgICB9XG4gKiB9LCBmdW5jdGlvbihlcnIsIHJlc3VsdHMpIHtcbiAqICAgICBjb25zb2xlLmxvZygnZXJyID0gJywgZXJyKTtcbiAqICAgICBjb25zb2xlLmxvZygnZW1haWxfbGluayA9ICcsIHJlc3VsdHMuZW1haWxfbGluayk7XG4gKiB9KTtcbiAqXG4gKiAvLyBJZiB5b3UgYXJlIHVzaW5nIGEgSlMgbWluaWZpZXIgdGhhdCBtYW5nbGVzIHBhcmFtZXRlciBuYW1lcywgYGF1dG9JbmplY3RgXG4gKiAvLyB3aWxsIG5vdCB3b3JrIHdpdGggcGxhaW4gZnVuY3Rpb25zLCBzaW5jZSB0aGUgcGFyYW1ldGVyIG5hbWVzIHdpbGwgYmVcbiAqIC8vIGNvbGxhcHNlZCB0byBhIHNpbmdsZSBsZXR0ZXIgaWRlbnRpZmllci4gIFRvIHdvcmsgYXJvdW5kIHRoaXMsIHlvdSBjYW5cbiAqIC8vIGV4cGxpY2l0bHkgc3BlY2lmeSB0aGUgbmFtZXMgb2YgdGhlIHBhcmFtZXRlcnMgeW91ciB0YXNrIGZ1bmN0aW9uIG5lZWRzXG4gKiAvLyBpbiBhbiBhcnJheSwgc2ltaWxhciB0byBBbmd1bGFyLmpzIGRlcGVuZGVuY3kgaW5qZWN0aW9uLlxuICpcbiAqIC8vIFRoaXMgc3RpbGwgaGFzIGFuIGFkdmFudGFnZSBvdmVyIHBsYWluIGBhdXRvYCwgc2luY2UgdGhlIHJlc3VsdHMgYSB0YXNrXG4gKiAvLyBkZXBlbmRzIG9uIGFyZSBzdGlsbCBzcHJlYWQgaW50byBhcmd1bWVudHMuXG4gKiBhc3luYy5hdXRvSW5qZWN0KHtcbiAqICAgICAvLy4uLlxuICogICAgIHdyaXRlX2ZpbGU6IFsnZ2V0X2RhdGEnLCAnbWFrZV9mb2xkZXInLCBmdW5jdGlvbihnZXRfZGF0YSwgbWFrZV9mb2xkZXIsIGNhbGxiYWNrKSB7XG4gKiAgICAgICAgIGNhbGxiYWNrKG51bGwsICdmaWxlbmFtZScpO1xuICogICAgIH1dLFxuICogICAgIGVtYWlsX2xpbms6IFsnd3JpdGVfZmlsZScsIGZ1bmN0aW9uKHdyaXRlX2ZpbGUsIGNhbGxiYWNrKSB7XG4gKiAgICAgICAgIGNhbGxiYWNrKG51bGwsIHsnZmlsZSc6d3JpdGVfZmlsZSwgJ2VtYWlsJzondXNlckBleGFtcGxlLmNvbSd9KTtcbiAqICAgICB9XVxuICogICAgIC8vLi4uXG4gKiB9LCBmdW5jdGlvbihlcnIsIHJlc3VsdHMpIHtcbiAqICAgICBjb25zb2xlLmxvZygnZXJyID0gJywgZXJyKTtcbiAqICAgICBjb25zb2xlLmxvZygnZW1haWxfbGluayA9ICcsIHJlc3VsdHMuZW1haWxfbGluayk7XG4gKiB9KTtcbiAqL1xuZnVuY3Rpb24gYXV0b0luamVjdCh0YXNrcywgY2FsbGJhY2spIHtcbiAgICB2YXIgbmV3VGFza3MgPSB7fTtcblxuICAgIGJhc2VGb3JPd24odGFza3MsIGZ1bmN0aW9uICh0YXNrRm4sIGtleSkge1xuICAgICAgICB2YXIgcGFyYW1zO1xuICAgICAgICB2YXIgZm5Jc0FzeW5jID0gaXNBc3luYyh0YXNrRm4pO1xuICAgICAgICB2YXIgaGFzTm9EZXBzID1cbiAgICAgICAgICAgICghZm5Jc0FzeW5jICYmIHRhc2tGbi5sZW5ndGggPT09IDEpIHx8XG4gICAgICAgICAgICAoZm5Jc0FzeW5jICYmIHRhc2tGbi5sZW5ndGggPT09IDApO1xuXG4gICAgICAgIGlmIChpc0FycmF5KHRhc2tGbikpIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IHRhc2tGbi5zbGljZSgwLCAtMSk7XG4gICAgICAgICAgICB0YXNrRm4gPSB0YXNrRm5bdGFza0ZuLmxlbmd0aCAtIDFdO1xuXG4gICAgICAgICAgICBuZXdUYXNrc1trZXldID0gcGFyYW1zLmNvbmNhdChwYXJhbXMubGVuZ3RoID4gMCA/IG5ld1Rhc2sgOiB0YXNrRm4pO1xuICAgICAgICB9IGVsc2UgaWYgKGhhc05vRGVwcykge1xuICAgICAgICAgICAgLy8gbm8gZGVwZW5kZW5jaWVzLCB1c2UgdGhlIGZ1bmN0aW9uIGFzLWlzXG4gICAgICAgICAgICBuZXdUYXNrc1trZXldID0gdGFza0ZuO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGFyYW1zID0gcGFyc2VQYXJhbXModGFza0ZuKTtcbiAgICAgICAgICAgIGlmICh0YXNrRm4ubGVuZ3RoID09PSAwICYmICFmbklzQXN5bmMgJiYgcGFyYW1zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImF1dG9JbmplY3QgdGFzayBmdW5jdGlvbnMgcmVxdWlyZSBleHBsaWNpdCBwYXJhbWV0ZXJzLlwiKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gcmVtb3ZlIGNhbGxiYWNrIHBhcmFtXG4gICAgICAgICAgICBpZiAoIWZuSXNBc3luYykgcGFyYW1zLnBvcCgpO1xuXG4gICAgICAgICAgICBuZXdUYXNrc1trZXldID0gcGFyYW1zLmNvbmNhdChuZXdUYXNrKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIG5ld1Rhc2socmVzdWx0cywgdGFza0NiKSB7XG4gICAgICAgICAgICB2YXIgbmV3QXJncyA9IGFycmF5TWFwKHBhcmFtcywgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0c1tuYW1lXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbmV3QXJncy5wdXNoKHRhc2tDYik7XG4gICAgICAgICAgICB3cmFwQXN5bmModGFza0ZuKS5hcHBseShudWxsLCBuZXdBcmdzKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgYXV0byhuZXdUYXNrcywgY2FsbGJhY2spO1xufVxuXG4vLyBTaW1wbGUgZG91Ymx5IGxpbmtlZCBsaXN0IChodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Eb3VibHlfbGlua2VkX2xpc3QpIGltcGxlbWVudGF0aW9uXG4vLyB1c2VkIGZvciBxdWV1ZXMuIFRoaXMgaW1wbGVtZW50YXRpb24gYXNzdW1lcyB0aGF0IHRoZSBub2RlIHByb3ZpZGVkIGJ5IHRoZSB1c2VyIGNhbiBiZSBtb2RpZmllZFxuLy8gdG8gYWRqdXN0IHRoZSBuZXh0IGFuZCBsYXN0IHByb3BlcnRpZXMuIFdlIGltcGxlbWVudCBvbmx5IHRoZSBtaW5pbWFsIGZ1bmN0aW9uYWxpdHlcbi8vIGZvciBxdWV1ZSBzdXBwb3J0LlxuZnVuY3Rpb24gRExMKCkge1xuICAgIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG51bGw7XG4gICAgdGhpcy5sZW5ndGggPSAwO1xufVxuXG5mdW5jdGlvbiBzZXRJbml0aWFsKGRsbCwgbm9kZSkge1xuICAgIGRsbC5sZW5ndGggPSAxO1xuICAgIGRsbC5oZWFkID0gZGxsLnRhaWwgPSBub2RlO1xufVxuXG5ETEwucHJvdG90eXBlLnJlbW92ZUxpbmsgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgaWYgKG5vZGUucHJldikgbm9kZS5wcmV2Lm5leHQgPSBub2RlLm5leHQ7XG4gICAgZWxzZSB0aGlzLmhlYWQgPSBub2RlLm5leHQ7XG4gICAgaWYgKG5vZGUubmV4dCkgbm9kZS5uZXh0LnByZXYgPSBub2RlLnByZXY7XG4gICAgZWxzZSB0aGlzLnRhaWwgPSBub2RlLnByZXY7XG5cbiAgICBub2RlLnByZXYgPSBub2RlLm5leHQgPSBudWxsO1xuICAgIHRoaXMubGVuZ3RoIC09IDE7XG4gICAgcmV0dXJuIG5vZGU7XG59O1xuXG5ETEwucHJvdG90eXBlLmVtcHR5ID0gZnVuY3Rpb24gKCkge1xuICAgIHdoaWxlKHRoaXMuaGVhZCkgdGhpcy5zaGlmdCgpO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuRExMLnByb3RvdHlwZS5pbnNlcnRBZnRlciA9IGZ1bmN0aW9uKG5vZGUsIG5ld05vZGUpIHtcbiAgICBuZXdOb2RlLnByZXYgPSBub2RlO1xuICAgIG5ld05vZGUubmV4dCA9IG5vZGUubmV4dDtcbiAgICBpZiAobm9kZS5uZXh0KSBub2RlLm5leHQucHJldiA9IG5ld05vZGU7XG4gICAgZWxzZSB0aGlzLnRhaWwgPSBuZXdOb2RlO1xuICAgIG5vZGUubmV4dCA9IG5ld05vZGU7XG4gICAgdGhpcy5sZW5ndGggKz0gMTtcbn07XG5cbkRMTC5wcm90b3R5cGUuaW5zZXJ0QmVmb3JlID0gZnVuY3Rpb24obm9kZSwgbmV3Tm9kZSkge1xuICAgIG5ld05vZGUucHJldiA9IG5vZGUucHJldjtcbiAgICBuZXdOb2RlLm5leHQgPSBub2RlO1xuICAgIGlmIChub2RlLnByZXYpIG5vZGUucHJldi5uZXh0ID0gbmV3Tm9kZTtcbiAgICBlbHNlIHRoaXMuaGVhZCA9IG5ld05vZGU7XG4gICAgbm9kZS5wcmV2ID0gbmV3Tm9kZTtcbiAgICB0aGlzLmxlbmd0aCArPSAxO1xufTtcblxuRExMLnByb3RvdHlwZS51bnNoaWZ0ID0gZnVuY3Rpb24obm9kZSkge1xuICAgIGlmICh0aGlzLmhlYWQpIHRoaXMuaW5zZXJ0QmVmb3JlKHRoaXMuaGVhZCwgbm9kZSk7XG4gICAgZWxzZSBzZXRJbml0aWFsKHRoaXMsIG5vZGUpO1xufTtcblxuRExMLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24obm9kZSkge1xuICAgIGlmICh0aGlzLnRhaWwpIHRoaXMuaW5zZXJ0QWZ0ZXIodGhpcy50YWlsLCBub2RlKTtcbiAgICBlbHNlIHNldEluaXRpYWwodGhpcywgbm9kZSk7XG59O1xuXG5ETEwucHJvdG90eXBlLnNoaWZ0ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuaGVhZCAmJiB0aGlzLnJlbW92ZUxpbmsodGhpcy5oZWFkKTtcbn07XG5cbkRMTC5wcm90b3R5cGUucG9wID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMudGFpbCAmJiB0aGlzLnJlbW92ZUxpbmsodGhpcy50YWlsKTtcbn07XG5cbkRMTC5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYXJyID0gQXJyYXkodGhpcy5sZW5ndGgpO1xuICAgIHZhciBjdXJyID0gdGhpcy5oZWFkO1xuICAgIGZvcih2YXIgaWR4ID0gMDsgaWR4IDwgdGhpcy5sZW5ndGg7IGlkeCsrKSB7XG4gICAgICAgIGFycltpZHhdID0gY3Vyci5kYXRhO1xuICAgICAgICBjdXJyID0gY3Vyci5uZXh0O1xuICAgIH1cbiAgICByZXR1cm4gYXJyO1xufTtcblxuRExMLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAodGVzdEZuKSB7XG4gICAgdmFyIGN1cnIgPSB0aGlzLmhlYWQ7XG4gICAgd2hpbGUoISFjdXJyKSB7XG4gICAgICAgIHZhciBuZXh0ID0gY3Vyci5uZXh0O1xuICAgICAgICBpZiAodGVzdEZuKGN1cnIpKSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZUxpbmsoY3Vycik7XG4gICAgICAgIH1cbiAgICAgICAgY3VyciA9IG5leHQ7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gcXVldWUod29ya2VyLCBjb25jdXJyZW5jeSwgcGF5bG9hZCkge1xuICAgIGlmIChjb25jdXJyZW5jeSA9PSBudWxsKSB7XG4gICAgICAgIGNvbmN1cnJlbmN5ID0gMTtcbiAgICB9XG4gICAgZWxzZSBpZihjb25jdXJyZW5jeSA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvbmN1cnJlbmN5IG11c3Qgbm90IGJlIHplcm8nKTtcbiAgICB9XG5cbiAgICB2YXIgX3dvcmtlciA9IHdyYXBBc3luYyh3b3JrZXIpO1xuICAgIHZhciBudW1SdW5uaW5nID0gMDtcbiAgICB2YXIgd29ya2Vyc0xpc3QgPSBbXTtcblxuICAgIHZhciBwcm9jZXNzaW5nU2NoZWR1bGVkID0gZmFsc2U7XG4gICAgZnVuY3Rpb24gX2luc2VydChkYXRhLCBpbnNlcnRBdEZyb250LCBjYWxsYmFjaykge1xuICAgICAgICBpZiAoY2FsbGJhY2sgIT0gbnVsbCAmJiB0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndGFzayBjYWxsYmFjayBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICAgICAgfVxuICAgICAgICBxLnN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICBpZiAoIWlzQXJyYXkoZGF0YSkpIHtcbiAgICAgICAgICAgIGRhdGEgPSBbZGF0YV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEubGVuZ3RoID09PSAwICYmIHEuaWRsZSgpKSB7XG4gICAgICAgICAgICAvLyBjYWxsIGRyYWluIGltbWVkaWF0ZWx5IGlmIHRoZXJlIGFyZSBubyB0YXNrc1xuICAgICAgICAgICAgcmV0dXJuIHNldEltbWVkaWF0ZSQxKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHEuZHJhaW4oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBkYXRhLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgdmFyIGl0ZW0gPSB7XG4gICAgICAgICAgICAgICAgZGF0YTogZGF0YVtpXSxcbiAgICAgICAgICAgICAgICBjYWxsYmFjazogY2FsbGJhY2sgfHwgbm9vcFxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaWYgKGluc2VydEF0RnJvbnQpIHtcbiAgICAgICAgICAgICAgICBxLl90YXNrcy51bnNoaWZ0KGl0ZW0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBxLl90YXNrcy5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFwcm9jZXNzaW5nU2NoZWR1bGVkKSB7XG4gICAgICAgICAgICBwcm9jZXNzaW5nU2NoZWR1bGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHNldEltbWVkaWF0ZSQxKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHByb2Nlc3NpbmdTY2hlZHVsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBxLnByb2Nlc3MoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX25leHQodGFza3MpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGVycil7XG4gICAgICAgICAgICBudW1SdW5uaW5nIC09IDE7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gdGFza3MubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRhc2sgPSB0YXNrc1tpXTtcblxuICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IGJhc2VJbmRleE9mKHdvcmtlcnNMaXN0LCB0YXNrLCAwKTtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgd29ya2Vyc0xpc3Quc2hpZnQoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGluZGV4ID4gMCkge1xuICAgICAgICAgICAgICAgICAgICB3b3JrZXJzTGlzdC5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRhc2suY2FsbGJhY2suYXBwbHkodGFzaywgYXJndW1lbnRzKTtcblxuICAgICAgICAgICAgICAgIGlmIChlcnIgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBxLmVycm9yKGVyciwgdGFzay5kYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChudW1SdW5uaW5nIDw9IChxLmNvbmN1cnJlbmN5IC0gcS5idWZmZXIpICkge1xuICAgICAgICAgICAgICAgIHEudW5zYXR1cmF0ZWQoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHEuaWRsZSgpKSB7XG4gICAgICAgICAgICAgICAgcS5kcmFpbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcS5wcm9jZXNzKCk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIGlzUHJvY2Vzc2luZyA9IGZhbHNlO1xuICAgIHZhciBxID0ge1xuICAgICAgICBfdGFza3M6IG5ldyBETEwoKSxcbiAgICAgICAgY29uY3VycmVuY3k6IGNvbmN1cnJlbmN5LFxuICAgICAgICBwYXlsb2FkOiBwYXlsb2FkLFxuICAgICAgICBzYXR1cmF0ZWQ6IG5vb3AsXG4gICAgICAgIHVuc2F0dXJhdGVkOm5vb3AsXG4gICAgICAgIGJ1ZmZlcjogY29uY3VycmVuY3kgLyA0LFxuICAgICAgICBlbXB0eTogbm9vcCxcbiAgICAgICAgZHJhaW46IG5vb3AsXG4gICAgICAgIGVycm9yOiBub29wLFxuICAgICAgICBzdGFydGVkOiBmYWxzZSxcbiAgICAgICAgcGF1c2VkOiBmYWxzZSxcbiAgICAgICAgcHVzaDogZnVuY3Rpb24gKGRhdGEsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBfaW5zZXJ0KGRhdGEsIGZhbHNlLCBjYWxsYmFjayk7XG4gICAgICAgIH0sXG4gICAgICAgIGtpbGw6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHEuZHJhaW4gPSBub29wO1xuICAgICAgICAgICAgcS5fdGFza3MuZW1wdHkoKTtcbiAgICAgICAgfSxcbiAgICAgICAgdW5zaGlmdDogZnVuY3Rpb24gKGRhdGEsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBfaW5zZXJ0KGRhdGEsIHRydWUsIGNhbGxiYWNrKTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbiAodGVzdEZuKSB7XG4gICAgICAgICAgICBxLl90YXNrcy5yZW1vdmUodGVzdEZuKTtcbiAgICAgICAgfSxcbiAgICAgICAgcHJvY2VzczogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gQXZvaWQgdHJ5aW5nIHRvIHN0YXJ0IHRvbyBtYW55IHByb2Nlc3Npbmcgb3BlcmF0aW9ucy4gVGhpcyBjYW4gb2NjdXJcbiAgICAgICAgICAgIC8vIHdoZW4gY2FsbGJhY2tzIHJlc29sdmUgc3luY2hyb25vdXNseSAoIzEyNjcpLlxuICAgICAgICAgICAgaWYgKGlzUHJvY2Vzc2luZykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlzUHJvY2Vzc2luZyA9IHRydWU7XG4gICAgICAgICAgICB3aGlsZSghcS5wYXVzZWQgJiYgbnVtUnVubmluZyA8IHEuY29uY3VycmVuY3kgJiYgcS5fdGFza3MubGVuZ3RoKXtcbiAgICAgICAgICAgICAgICB2YXIgdGFza3MgPSBbXSwgZGF0YSA9IFtdO1xuICAgICAgICAgICAgICAgIHZhciBsID0gcS5fdGFza3MubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGlmIChxLnBheWxvYWQpIGwgPSBNYXRoLm1pbihsLCBxLnBheWxvYWQpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBub2RlID0gcS5fdGFza3Muc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgdGFza3MucHVzaChub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgd29ya2Vyc0xpc3QucHVzaChub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5wdXNoKG5vZGUuZGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbnVtUnVubmluZyArPSAxO1xuXG4gICAgICAgICAgICAgICAgaWYgKHEuX3Rhc2tzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBxLmVtcHR5KCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKG51bVJ1bm5pbmcgPT09IHEuY29uY3VycmVuY3kpIHtcbiAgICAgICAgICAgICAgICAgICAgcS5zYXR1cmF0ZWQoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgY2IgPSBvbmx5T25jZShfbmV4dCh0YXNrcykpO1xuICAgICAgICAgICAgICAgIF93b3JrZXIoZGF0YSwgY2IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaXNQcm9jZXNzaW5nID0gZmFsc2U7XG4gICAgICAgIH0sXG4gICAgICAgIGxlbmd0aDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHEuX3Rhc2tzLmxlbmd0aDtcbiAgICAgICAgfSxcbiAgICAgICAgcnVubmluZzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bVJ1bm5pbmc7XG4gICAgICAgIH0sXG4gICAgICAgIHdvcmtlcnNMaXN0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gd29ya2Vyc0xpc3Q7XG4gICAgICAgIH0sXG4gICAgICAgIGlkbGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHEuX3Rhc2tzLmxlbmd0aCArIG51bVJ1bm5pbmcgPT09IDA7XG4gICAgICAgIH0sXG4gICAgICAgIHBhdXNlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBxLnBhdXNlZCA9IHRydWU7XG4gICAgICAgIH0sXG4gICAgICAgIHJlc3VtZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHEucGF1c2VkID09PSBmYWxzZSkgeyByZXR1cm47IH1cbiAgICAgICAgICAgIHEucGF1c2VkID0gZmFsc2U7XG4gICAgICAgICAgICBzZXRJbW1lZGlhdGUkMShxLnByb2Nlc3MpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gcTtcbn1cblxuLyoqXG4gKiBBIGNhcmdvIG9mIHRhc2tzIGZvciB0aGUgd29ya2VyIGZ1bmN0aW9uIHRvIGNvbXBsZXRlLiBDYXJnbyBpbmhlcml0cyBhbGwgb2ZcbiAqIHRoZSBzYW1lIG1ldGhvZHMgYW5kIGV2ZW50IGNhbGxiYWNrcyBhcyBbYHF1ZXVlYF17QGxpbmsgbW9kdWxlOkNvbnRyb2xGbG93LnF1ZXVlfS5cbiAqIEB0eXBlZGVmIHtPYmplY3R9IENhcmdvT2JqZWN0XG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbnRyb2xGbG93XG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBsZW5ndGggLSBBIGZ1bmN0aW9uIHJldHVybmluZyB0aGUgbnVtYmVyIG9mIGl0ZW1zXG4gKiB3YWl0aW5nIHRvIGJlIHByb2Nlc3NlZC4gSW52b2tlIGxpa2UgYGNhcmdvLmxlbmd0aCgpYC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBwYXlsb2FkIC0gQW4gYGludGVnZXJgIGZvciBkZXRlcm1pbmluZyBob3cgbWFueSB0YXNrc1xuICogc2hvdWxkIGJlIHByb2Nlc3MgcGVyIHJvdW5kLiBUaGlzIHByb3BlcnR5IGNhbiBiZSBjaGFuZ2VkIGFmdGVyIGEgYGNhcmdvYCBpc1xuICogY3JlYXRlZCB0byBhbHRlciB0aGUgcGF5bG9hZCBvbi10aGUtZmx5LlxuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gcHVzaCAtIEFkZHMgYHRhc2tgIHRvIHRoZSBgcXVldWVgLiBUaGUgY2FsbGJhY2sgaXNcbiAqIGNhbGxlZCBvbmNlIHRoZSBgd29ya2VyYCBoYXMgZmluaXNoZWQgcHJvY2Vzc2luZyB0aGUgdGFzay4gSW5zdGVhZCBvZiBhXG4gKiBzaW5nbGUgdGFzaywgYW4gYXJyYXkgb2YgYHRhc2tzYCBjYW4gYmUgc3VibWl0dGVkLiBUaGUgcmVzcGVjdGl2ZSBjYWxsYmFjayBpc1xuICogdXNlZCBmb3IgZXZlcnkgdGFzayBpbiB0aGUgbGlzdC4gSW52b2tlIGxpa2UgYGNhcmdvLnB1c2godGFzaywgW2NhbGxiYWNrXSlgLlxuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gc2F0dXJhdGVkIC0gQSBjYWxsYmFjayB0aGF0IGlzIGNhbGxlZCB3aGVuIHRoZVxuICogYHF1ZXVlLmxlbmd0aCgpYCBoaXRzIHRoZSBjb25jdXJyZW5jeSBhbmQgZnVydGhlciB0YXNrcyB3aWxsIGJlIHF1ZXVlZC5cbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IGVtcHR5IC0gQSBjYWxsYmFjayB0aGF0IGlzIGNhbGxlZCB3aGVuIHRoZSBsYXN0IGl0ZW1cbiAqIGZyb20gdGhlIGBxdWV1ZWAgaXMgZ2l2ZW4gdG8gYSBgd29ya2VyYC5cbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IGRyYWluIC0gQSBjYWxsYmFjayB0aGF0IGlzIGNhbGxlZCB3aGVuIHRoZSBsYXN0IGl0ZW1cbiAqIGZyb20gdGhlIGBxdWV1ZWAgaGFzIHJldHVybmVkIGZyb20gdGhlIGB3b3JrZXJgLlxuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gaWRsZSAtIGEgZnVuY3Rpb24gcmV0dXJuaW5nIGZhbHNlIGlmIHRoZXJlIGFyZSBpdGVtc1xuICogd2FpdGluZyBvciBiZWluZyBwcm9jZXNzZWQsIG9yIHRydWUgaWYgbm90LiBJbnZva2UgbGlrZSBgY2FyZ28uaWRsZSgpYC5cbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IHBhdXNlIC0gYSBmdW5jdGlvbiB0aGF0IHBhdXNlcyB0aGUgcHJvY2Vzc2luZyBvZiB0YXNrc1xuICogdW50aWwgYHJlc3VtZSgpYCBpcyBjYWxsZWQuIEludm9rZSBsaWtlIGBjYXJnby5wYXVzZSgpYC5cbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IHJlc3VtZSAtIGEgZnVuY3Rpb24gdGhhdCByZXN1bWVzIHRoZSBwcm9jZXNzaW5nIG9mXG4gKiBxdWV1ZWQgdGFza3Mgd2hlbiB0aGUgcXVldWUgaXMgcGF1c2VkLiBJbnZva2UgbGlrZSBgY2FyZ28ucmVzdW1lKClgLlxuICogQHByb3BlcnR5IHtGdW5jdGlvbn0ga2lsbCAtIGEgZnVuY3Rpb24gdGhhdCByZW1vdmVzIHRoZSBgZHJhaW5gIGNhbGxiYWNrIGFuZFxuICogZW1wdGllcyByZW1haW5pbmcgdGFza3MgZnJvbSB0aGUgcXVldWUgZm9yY2luZyBpdCB0byBnbyBpZGxlLiBJbnZva2UgbGlrZSBgY2FyZ28ua2lsbCgpYC5cbiAqL1xuXG4vKipcbiAqIENyZWF0ZXMgYSBgY2FyZ29gIG9iamVjdCB3aXRoIHRoZSBzcGVjaWZpZWQgcGF5bG9hZC4gVGFza3MgYWRkZWQgdG8gdGhlXG4gKiBjYXJnbyB3aWxsIGJlIHByb2Nlc3NlZCBhbHRvZ2V0aGVyICh1cCB0byB0aGUgYHBheWxvYWRgIGxpbWl0KS4gSWYgdGhlXG4gKiBgd29ya2VyYCBpcyBpbiBwcm9ncmVzcywgdGhlIHRhc2sgaXMgcXVldWVkIHVudGlsIGl0IGJlY29tZXMgYXZhaWxhYmxlLiBPbmNlXG4gKiB0aGUgYHdvcmtlcmAgaGFzIGNvbXBsZXRlZCBzb21lIHRhc2tzLCBlYWNoIGNhbGxiYWNrIG9mIHRob3NlIHRhc2tzIGlzXG4gKiBjYWxsZWQuIENoZWNrIG91dCBbdGhlc2VdKGh0dHBzOi8vY2Ftby5naXRodWJ1c2VyY29udGVudC5jb20vNmJiZDM2ZjRjZjViMzVhMGYxMWE5NmRjZDJlOTc3MTFmZmMyZmIzNy82ODc0NzQ3MDczM2EyZjJmNjYyZTYzNmM2Zjc1NjQyZTY3Njk3NDY4NzU2MjJlNjM2ZjZkMmY2MTczNzM2NTc0NzMyZjMxMzYzNzM2MzgzNzMxMmYzNjM4MzEzMDM4MmY2MjYyNjMzMDYzNjY2MjMwMmQzNTY2MzIzOTJkMzEzMTY1MzIyZDM5MzczNDY2MmQzMzMzMzkzNzYzMzYzNDY0NjMzODM1MzgyZTY3Njk2NikgW2FuaW1hdGlvbnNdKGh0dHBzOi8vY2Ftby5naXRodWJ1c2VyY29udGVudC5jb20vZjQ4MTBlMDBlMWM1ZjVmOGFkZGJlM2U5ZjQ5MDY0ZmQ1ZDEwMjY5OS82ODc0NzQ3MDczM2EyZjJmNjYyZTYzNmM2Zjc1NjQyZTY3Njk3NDY4NzU2MjJlNjM2ZjZkMmY2MTczNzM2NTc0NzMyZjMxMzYzNzM2MzgzNzMxMmYzNjM4MzEzMDMxMmYzODM0NjMzOTMyMzAzNjM2MmQzNTY2MzIzOTJkMzEzMTY1MzIyZDM4MzEzNDY2MmQzOTY0MzM2NDMwMzIzNDMxMzM2MjY2NjQyZTY3Njk2NilcbiAqIGZvciBob3cgYGNhcmdvYCBhbmQgYHF1ZXVlYCB3b3JrLlxuICpcbiAqIFdoaWxlIFtgcXVldWVgXXtAbGluayBtb2R1bGU6Q29udHJvbEZsb3cucXVldWV9IHBhc3NlcyBvbmx5IG9uZSB0YXNrIHRvIG9uZSBvZiBhIGdyb3VwIG9mIHdvcmtlcnNcbiAqIGF0IGEgdGltZSwgY2FyZ28gcGFzc2VzIGFuIGFycmF5IG9mIHRhc2tzIHRvIGEgc2luZ2xlIHdvcmtlciwgcmVwZWF0aW5nXG4gKiB3aGVuIHRoZSB3b3JrZXIgaXMgZmluaXNoZWQuXG4gKlxuICogQG5hbWUgY2FyZ29cbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29udHJvbEZsb3dcbiAqIEBtZXRob2RcbiAqIEBzZWUgW2FzeW5jLnF1ZXVlXXtAbGluayBtb2R1bGU6Q29udHJvbEZsb3cucXVldWV9XG4gKiBAY2F0ZWdvcnkgQ29udHJvbCBGbG93XG4gKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IHdvcmtlciAtIEFuIGFzeW5jaHJvbm91cyBmdW5jdGlvbiBmb3IgcHJvY2Vzc2luZyBhbiBhcnJheVxuICogb2YgcXVldWVkIHRhc2tzLiBJbnZva2VkIHdpdGggYCh0YXNrcywgY2FsbGJhY2spYC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbcGF5bG9hZD1JbmZpbml0eV0gLSBBbiBvcHRpb25hbCBgaW50ZWdlcmAgZm9yIGRldGVybWluaW5nXG4gKiBob3cgbWFueSB0YXNrcyBzaG91bGQgYmUgcHJvY2Vzc2VkIHBlciByb3VuZDsgaWYgb21pdHRlZCwgdGhlIGRlZmF1bHQgaXNcbiAqIHVubGltaXRlZC5cbiAqIEByZXR1cm5zIHttb2R1bGU6Q29udHJvbEZsb3cuQ2FyZ29PYmplY3R9IEEgY2FyZ28gb2JqZWN0IHRvIG1hbmFnZSB0aGUgdGFza3MuIENhbGxiYWNrcyBjYW5cbiAqIGF0dGFjaGVkIGFzIGNlcnRhaW4gcHJvcGVydGllcyB0byBsaXN0ZW4gZm9yIHNwZWNpZmljIGV2ZW50cyBkdXJpbmcgdGhlXG4gKiBsaWZlY3ljbGUgb2YgdGhlIGNhcmdvIGFuZCBpbm5lciBxdWV1ZS5cbiAqIEBleGFtcGxlXG4gKlxuICogLy8gY3JlYXRlIGEgY2FyZ28gb2JqZWN0IHdpdGggcGF5bG9hZCAyXG4gKiB2YXIgY2FyZ28gPSBhc3luYy5jYXJnbyhmdW5jdGlvbih0YXNrcywgY2FsbGJhY2spIHtcbiAqICAgICBmb3IgKHZhciBpPTA7IGk8dGFza3MubGVuZ3RoOyBpKyspIHtcbiAqICAgICAgICAgY29uc29sZS5sb2coJ2hlbGxvICcgKyB0YXNrc1tpXS5uYW1lKTtcbiAqICAgICB9XG4gKiAgICAgY2FsbGJhY2soKTtcbiAqIH0sIDIpO1xuICpcbiAqIC8vIGFkZCBzb21lIGl0ZW1zXG4gKiBjYXJnby5wdXNoKHtuYW1lOiAnZm9vJ30sIGZ1bmN0aW9uKGVycikge1xuICogICAgIGNvbnNvbGUubG9nKCdmaW5pc2hlZCBwcm9jZXNzaW5nIGZvbycpO1xuICogfSk7XG4gKiBjYXJnby5wdXNoKHtuYW1lOiAnYmFyJ30sIGZ1bmN0aW9uKGVycikge1xuICogICAgIGNvbnNvbGUubG9nKCdmaW5pc2hlZCBwcm9jZXNzaW5nIGJhcicpO1xuICogfSk7XG4gKiBjYXJnby5wdXNoKHtuYW1lOiAnYmF6J30sIGZ1bmN0aW9uKGVycikge1xuICogICAgIGNvbnNvbGUubG9nKCdmaW5pc2hlZCBwcm9jZXNzaW5nIGJheicpO1xuICogfSk7XG4gKi9cbmZ1bmN0aW9uIGNhcmdvKHdvcmtlciwgcGF5bG9hZCkge1xuICAgIHJldHVybiBxdWV1ZSh3b3JrZXIsIDEsIHBheWxvYWQpO1xufVxuXG4vKipcbiAqIFRoZSBzYW1lIGFzIFtgZWFjaE9mYF17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLmVhY2hPZn0gYnV0IHJ1bnMgb25seSBhIHNpbmdsZSBhc3luYyBvcGVyYXRpb24gYXQgYSB0aW1lLlxuICpcbiAqIEBuYW1lIGVhY2hPZlNlcmllc1xuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpDb2xsZWN0aW9uc1xuICogQG1ldGhvZFxuICogQHNlZSBbYXN5bmMuZWFjaE9mXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMuZWFjaE9mfVxuICogQGFsaWFzIGZvckVhY2hPZlNlcmllc1xuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8T2JqZWN0fSBjb2xsIC0gQSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gaXRlcmF0ZWUgLSBBbiBhc3luYyBmdW5jdGlvbiB0byBhcHBseSB0byBlYWNoIGl0ZW0gaW5cbiAqIGBjb2xsYC5cbiAqIEludm9rZWQgd2l0aCAoaXRlbSwga2V5LCBjYWxsYmFjaykuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgd2hlbiBhbGwgYGl0ZXJhdGVlYFxuICogZnVuY3Rpb25zIGhhdmUgZmluaXNoZWQsIG9yIGFuIGVycm9yIG9jY3Vycy4gSW52b2tlZCB3aXRoIChlcnIpLlxuICovXG52YXIgZWFjaE9mU2VyaWVzID0gZG9MaW1pdChlYWNoT2ZMaW1pdCwgMSk7XG5cbi8qKlxuICogUmVkdWNlcyBgY29sbGAgaW50byBhIHNpbmdsZSB2YWx1ZSB1c2luZyBhbiBhc3luYyBgaXRlcmF0ZWVgIHRvIHJldHVybiBlYWNoXG4gKiBzdWNjZXNzaXZlIHN0ZXAuIGBtZW1vYCBpcyB0aGUgaW5pdGlhbCBzdGF0ZSBvZiB0aGUgcmVkdWN0aW9uLiBUaGlzIGZ1bmN0aW9uXG4gKiBvbmx5IG9wZXJhdGVzIGluIHNlcmllcy5cbiAqXG4gKiBGb3IgcGVyZm9ybWFuY2UgcmVhc29ucywgaXQgbWF5IG1ha2Ugc2Vuc2UgdG8gc3BsaXQgYSBjYWxsIHRvIHRoaXMgZnVuY3Rpb25cbiAqIGludG8gYSBwYXJhbGxlbCBtYXAsIGFuZCB0aGVuIHVzZSB0aGUgbm9ybWFsIGBBcnJheS5wcm90b3R5cGUucmVkdWNlYCBvbiB0aGVcbiAqIHJlc3VsdHMuIFRoaXMgZnVuY3Rpb24gaXMgZm9yIHNpdHVhdGlvbnMgd2hlcmUgZWFjaCBzdGVwIGluIHRoZSByZWR1Y3Rpb25cbiAqIG5lZWRzIHRvIGJlIGFzeW5jOyBpZiB5b3UgY2FuIGdldCB0aGUgZGF0YSBiZWZvcmUgcmVkdWNpbmcgaXQsIHRoZW4gaXQnc1xuICogcHJvYmFibHkgYSBnb29kIGlkZWEgdG8gZG8gc28uXG4gKlxuICogQG5hbWUgcmVkdWNlXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbGxlY3Rpb25zXG4gKiBAbWV0aG9kXG4gKiBAYWxpYXMgaW5qZWN0XG4gKiBAYWxpYXMgZm9sZGxcbiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gKiBAcGFyYW0ge0FycmF5fEl0ZXJhYmxlfE9iamVjdH0gY29sbCAtIEEgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0geyp9IG1lbW8gLSBUaGUgaW5pdGlhbCBzdGF0ZSBvZiB0aGUgcmVkdWN0aW9uLlxuICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEEgZnVuY3Rpb24gYXBwbGllZCB0byBlYWNoIGl0ZW0gaW4gdGhlXG4gKiBhcnJheSB0byBwcm9kdWNlIHRoZSBuZXh0IHN0ZXAgaW4gdGhlIHJlZHVjdGlvbi5cbiAqIFRoZSBgaXRlcmF0ZWVgIHNob3VsZCBjb21wbGV0ZSB3aXRoIHRoZSBuZXh0IHN0YXRlIG9mIHRoZSByZWR1Y3Rpb24uXG4gKiBJZiB0aGUgaXRlcmF0ZWUgY29tcGxldGUgd2l0aCBhbiBlcnJvciwgdGhlIHJlZHVjdGlvbiBpcyBzdG9wcGVkIGFuZCB0aGVcbiAqIG1haW4gYGNhbGxiYWNrYCBpcyBpbW1lZGlhdGVseSBjYWxsZWQgd2l0aCB0aGUgZXJyb3IuXG4gKiBJbnZva2VkIHdpdGggKG1lbW8sIGl0ZW0sIGNhbGxiYWNrKS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCBhZnRlciBhbGwgdGhlXG4gKiBgaXRlcmF0ZWVgIGZ1bmN0aW9ucyBoYXZlIGZpbmlzaGVkLiBSZXN1bHQgaXMgdGhlIHJlZHVjZWQgdmFsdWUuIEludm9rZWQgd2l0aFxuICogKGVyciwgcmVzdWx0KS5cbiAqIEBleGFtcGxlXG4gKlxuICogYXN5bmMucmVkdWNlKFsxLDIsM10sIDAsIGZ1bmN0aW9uKG1lbW8sIGl0ZW0sIGNhbGxiYWNrKSB7XG4gKiAgICAgLy8gcG9pbnRsZXNzIGFzeW5jOlxuICogICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gKiAgICAgICAgIGNhbGxiYWNrKG51bGwsIG1lbW8gKyBpdGVtKVxuICogICAgIH0pO1xuICogfSwgZnVuY3Rpb24oZXJyLCByZXN1bHQpIHtcbiAqICAgICAvLyByZXN1bHQgaXMgbm93IGVxdWFsIHRvIHRoZSBsYXN0IHZhbHVlIG9mIG1lbW8sIHdoaWNoIGlzIDZcbiAqIH0pO1xuICovXG5mdW5jdGlvbiByZWR1Y2UoY29sbCwgbWVtbywgaXRlcmF0ZWUsIGNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2sgPSBvbmNlKGNhbGxiYWNrIHx8IG5vb3ApO1xuICAgIHZhciBfaXRlcmF0ZWUgPSB3cmFwQXN5bmMoaXRlcmF0ZWUpO1xuICAgIGVhY2hPZlNlcmllcyhjb2xsLCBmdW5jdGlvbih4LCBpLCBjYWxsYmFjaykge1xuICAgICAgICBfaXRlcmF0ZWUobWVtbywgeCwgZnVuY3Rpb24oZXJyLCB2KSB7XG4gICAgICAgICAgICBtZW1vID0gdjtcbiAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgIH0pO1xuICAgIH0sIGZ1bmN0aW9uKGVycikge1xuICAgICAgICBjYWxsYmFjayhlcnIsIG1lbW8pO1xuICAgIH0pO1xufVxuXG4vKipcbiAqIFZlcnNpb24gb2YgdGhlIGNvbXBvc2UgZnVuY3Rpb24gdGhhdCBpcyBtb3JlIG5hdHVyYWwgdG8gcmVhZC4gRWFjaCBmdW5jdGlvblxuICogY29uc3VtZXMgdGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgcHJldmlvdXMgZnVuY3Rpb24uIEl0IGlzIHRoZSBlcXVpdmFsZW50IG9mXG4gKiBbY29tcG9zZV17QGxpbmsgbW9kdWxlOkNvbnRyb2xGbG93LmNvbXBvc2V9IHdpdGggdGhlIGFyZ3VtZW50cyByZXZlcnNlZC5cbiAqXG4gKiBFYWNoIGZ1bmN0aW9uIGlzIGV4ZWN1dGVkIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIHRoZSBjb21wb3NlZCBmdW5jdGlvbi5cbiAqXG4gKiBAbmFtZSBzZXFcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29udHJvbEZsb3dcbiAqIEBtZXRob2RcbiAqIEBzZWUgW2FzeW5jLmNvbXBvc2Vde0BsaW5rIG1vZHVsZTpDb250cm9sRmxvdy5jb21wb3NlfVxuICogQGNhdGVnb3J5IENvbnRyb2wgRmxvd1xuICogQHBhcmFtIHsuLi5Bc3luY0Z1bmN0aW9ufSBmdW5jdGlvbnMgLSB0aGUgYXN5bmNocm9ub3VzIGZ1bmN0aW9ucyB0byBjb21wb3NlXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IGEgZnVuY3Rpb24gdGhhdCBjb21wb3NlcyB0aGUgYGZ1bmN0aW9uc2AgaW4gb3JkZXJcbiAqIEBleGFtcGxlXG4gKlxuICogLy8gUmVxdWlyZXMgbG9kYXNoIChvciB1bmRlcnNjb3JlKSwgZXhwcmVzczMgYW5kIGRyZXNlbmRlJ3Mgb3JtMi5cbiAqIC8vIFBhcnQgb2YgYW4gYXBwLCB0aGF0IGZldGNoZXMgY2F0cyBvZiB0aGUgbG9nZ2VkIHVzZXIuXG4gKiAvLyBUaGlzIGV4YW1wbGUgdXNlcyBgc2VxYCBmdW5jdGlvbiB0byBhdm9pZCBvdmVybmVzdGluZyBhbmQgZXJyb3JcbiAqIC8vIGhhbmRsaW5nIGNsdXR0ZXIuXG4gKiBhcHAuZ2V0KCcvY2F0cycsIGZ1bmN0aW9uKHJlcXVlc3QsIHJlc3BvbnNlKSB7XG4gKiAgICAgdmFyIFVzZXIgPSByZXF1ZXN0Lm1vZGVscy5Vc2VyO1xuICogICAgIGFzeW5jLnNlcShcbiAqICAgICAgICAgXy5iaW5kKFVzZXIuZ2V0LCBVc2VyKSwgIC8vICdVc2VyLmdldCcgaGFzIHNpZ25hdHVyZSAoaWQsIGNhbGxiYWNrKGVyciwgZGF0YSkpXG4gKiAgICAgICAgIGZ1bmN0aW9uKHVzZXIsIGZuKSB7XG4gKiAgICAgICAgICAgICB1c2VyLmdldENhdHMoZm4pOyAgICAgIC8vICdnZXRDYXRzJyBoYXMgc2lnbmF0dXJlIChjYWxsYmFjayhlcnIsIGRhdGEpKVxuICogICAgICAgICB9XG4gKiAgICAgKShyZXEuc2Vzc2lvbi51c2VyX2lkLCBmdW5jdGlvbiAoZXJyLCBjYXRzKSB7XG4gKiAgICAgICAgIGlmIChlcnIpIHtcbiAqICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAqICAgICAgICAgICAgIHJlc3BvbnNlLmpzb24oeyBzdGF0dXM6ICdlcnJvcicsIG1lc3NhZ2U6IGVyci5tZXNzYWdlIH0pO1xuICogICAgICAgICB9IGVsc2Uge1xuICogICAgICAgICAgICAgcmVzcG9uc2UuanNvbih7IHN0YXR1czogJ29rJywgbWVzc2FnZTogJ0NhdHMgZm91bmQnLCBkYXRhOiBjYXRzIH0pO1xuICogICAgICAgICB9XG4gKiAgICAgfSk7XG4gKiB9KTtcbiAqL1xuZnVuY3Rpb24gc2VxKC8qLi4uZnVuY3Rpb25zKi8pIHtcbiAgICB2YXIgX2Z1bmN0aW9ucyA9IGFycmF5TWFwKGFyZ3VtZW50cywgd3JhcEFzeW5jKTtcbiAgICByZXR1cm4gZnVuY3Rpb24oLyouLi5hcmdzKi8pIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBzbGljZShhcmd1bWVudHMpO1xuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG5cbiAgICAgICAgdmFyIGNiID0gYXJnc1thcmdzLmxlbmd0aCAtIDFdO1xuICAgICAgICBpZiAodHlwZW9mIGNiID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGFyZ3MucG9wKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYiA9IG5vb3A7XG4gICAgICAgIH1cblxuICAgICAgICByZWR1Y2UoX2Z1bmN0aW9ucywgYXJncywgZnVuY3Rpb24obmV3YXJncywgZm4sIGNiKSB7XG4gICAgICAgICAgICBmbi5hcHBseSh0aGF0LCBuZXdhcmdzLmNvbmNhdChmdW5jdGlvbihlcnIvKiwgLi4ubmV4dGFyZ3MqLykge1xuICAgICAgICAgICAgICAgIHZhciBuZXh0YXJncyA9IHNsaWNlKGFyZ3VtZW50cywgMSk7XG4gICAgICAgICAgICAgICAgY2IoZXJyLCBuZXh0YXJncyk7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH0sXG4gICAgICAgIGZ1bmN0aW9uKGVyciwgcmVzdWx0cykge1xuICAgICAgICAgICAgY2IuYXBwbHkodGhhdCwgW2Vycl0uY29uY2F0KHJlc3VsdHMpKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gd2hpY2ggaXMgYSBjb21wb3NpdGlvbiBvZiB0aGUgcGFzc2VkIGFzeW5jaHJvbm91c1xuICogZnVuY3Rpb25zLiBFYWNoIGZ1bmN0aW9uIGNvbnN1bWVzIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIGZ1bmN0aW9uIHRoYXRcbiAqIGZvbGxvd3MuIENvbXBvc2luZyBmdW5jdGlvbnMgYGYoKWAsIGBnKClgLCBhbmQgYGgoKWAgd291bGQgcHJvZHVjZSB0aGUgcmVzdWx0XG4gKiBvZiBgZihnKGgoKSkpYCwgb25seSB0aGlzIHZlcnNpb24gdXNlcyBjYWxsYmFja3MgdG8gb2J0YWluIHRoZSByZXR1cm4gdmFsdWVzLlxuICpcbiAqIEVhY2ggZnVuY3Rpb24gaXMgZXhlY3V0ZWQgd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgdGhlIGNvbXBvc2VkIGZ1bmN0aW9uLlxuICpcbiAqIEBuYW1lIGNvbXBvc2VcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29udHJvbEZsb3dcbiAqIEBtZXRob2RcbiAqIEBjYXRlZ29yeSBDb250cm9sIEZsb3dcbiAqIEBwYXJhbSB7Li4uQXN5bmNGdW5jdGlvbn0gZnVuY3Rpb25zIC0gdGhlIGFzeW5jaHJvbm91cyBmdW5jdGlvbnMgdG8gY29tcG9zZVxuICogQHJldHVybnMge0Z1bmN0aW9ufSBhbiBhc3luY2hyb25vdXMgZnVuY3Rpb24gdGhhdCBpcyB0aGUgY29tcG9zZWRcbiAqIGFzeW5jaHJvbm91cyBgZnVuY3Rpb25zYFxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBhZGQxKG4sIGNhbGxiYWNrKSB7XG4gKiAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gKiAgICAgICAgIGNhbGxiYWNrKG51bGwsIG4gKyAxKTtcbiAqICAgICB9LCAxMCk7XG4gKiB9XG4gKlxuICogZnVuY3Rpb24gbXVsMyhuLCBjYWxsYmFjaykge1xuICogICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICogICAgICAgICBjYWxsYmFjayhudWxsLCBuICogMyk7XG4gKiAgICAgfSwgMTApO1xuICogfVxuICpcbiAqIHZhciBhZGQxbXVsMyA9IGFzeW5jLmNvbXBvc2UobXVsMywgYWRkMSk7XG4gKiBhZGQxbXVsMyg0LCBmdW5jdGlvbiAoZXJyLCByZXN1bHQpIHtcbiAqICAgICAvLyByZXN1bHQgbm93IGVxdWFscyAxNVxuICogfSk7XG4gKi9cbnZhciBjb21wb3NlID0gZnVuY3Rpb24oLyouLi5hcmdzKi8pIHtcbiAgICByZXR1cm4gc2VxLmFwcGx5KG51bGwsIHNsaWNlKGFyZ3VtZW50cykucmV2ZXJzZSgpKTtcbn07XG5cbnZhciBfY29uY2F0ID0gQXJyYXkucHJvdG90eXBlLmNvbmNhdDtcblxuLyoqXG4gKiBUaGUgc2FtZSBhcyBbYGNvbmNhdGBde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5jb25jYXR9IGJ1dCBydW5zIGEgbWF4aW11bSBvZiBgbGltaXRgIGFzeW5jIG9wZXJhdGlvbnMgYXQgYSB0aW1lLlxuICpcbiAqIEBuYW1lIGNvbmNhdExpbWl0XG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbGxlY3Rpb25zXG4gKiBAbWV0aG9kXG4gKiBAc2VlIFthc3luYy5jb25jYXRde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5jb25jYXR9XG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxPYmplY3R9IGNvbGwgLSBBIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtudW1iZXJ9IGxpbWl0IC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIGFzeW5jIG9wZXJhdGlvbnMgYXQgYSB0aW1lLlxuICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEEgZnVuY3Rpb24gdG8gYXBwbHkgdG8gZWFjaCBpdGVtIGluIGBjb2xsYCxcbiAqIHdoaWNoIHNob3VsZCB1c2UgYW4gYXJyYXkgYXMgaXRzIHJlc3VsdC4gSW52b2tlZCB3aXRoIChpdGVtLCBjYWxsYmFjaykuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgYWZ0ZXIgYWxsIHRoZVxuICogYGl0ZXJhdGVlYCBmdW5jdGlvbnMgaGF2ZSBmaW5pc2hlZCwgb3IgYW4gZXJyb3Igb2NjdXJzLiBSZXN1bHRzIGlzIGFuIGFycmF5XG4gKiBjb250YWluaW5nIHRoZSBjb25jYXRlbmF0ZWQgcmVzdWx0cyBvZiB0aGUgYGl0ZXJhdGVlYCBmdW5jdGlvbi4gSW52b2tlZCB3aXRoXG4gKiAoZXJyLCByZXN1bHRzKS5cbiAqL1xudmFyIGNvbmNhdExpbWl0ID0gZnVuY3Rpb24oY29sbCwgbGltaXQsIGl0ZXJhdGVlLCBjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgbm9vcDtcbiAgICB2YXIgX2l0ZXJhdGVlID0gd3JhcEFzeW5jKGl0ZXJhdGVlKTtcbiAgICBtYXBMaW1pdChjb2xsLCBsaW1pdCwgZnVuY3Rpb24odmFsLCBjYWxsYmFjaykge1xuICAgICAgICBfaXRlcmF0ZWUodmFsLCBmdW5jdGlvbihlcnIgLyosIC4uLmFyZ3MqLykge1xuICAgICAgICAgICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgc2xpY2UoYXJndW1lbnRzLCAxKSk7XG4gICAgICAgIH0pO1xuICAgIH0sIGZ1bmN0aW9uKGVyciwgbWFwUmVzdWx0cykge1xuICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWFwUmVzdWx0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKG1hcFJlc3VsdHNbaV0pIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBfY29uY2F0LmFwcGx5KHJlc3VsdCwgbWFwUmVzdWx0c1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyLCByZXN1bHQpO1xuICAgIH0pO1xufTtcblxuLyoqXG4gKiBBcHBsaWVzIGBpdGVyYXRlZWAgdG8gZWFjaCBpdGVtIGluIGBjb2xsYCwgY29uY2F0ZW5hdGluZyB0aGUgcmVzdWx0cy4gUmV0dXJuc1xuICogdGhlIGNvbmNhdGVuYXRlZCBsaXN0LiBUaGUgYGl0ZXJhdGVlYHMgYXJlIGNhbGxlZCBpbiBwYXJhbGxlbCwgYW5kIHRoZVxuICogcmVzdWx0cyBhcmUgY29uY2F0ZW5hdGVkIGFzIHRoZXkgcmV0dXJuLiBUaGVyZSBpcyBubyBndWFyYW50ZWUgdGhhdCB0aGVcbiAqIHJlc3VsdHMgYXJyYXkgd2lsbCBiZSByZXR1cm5lZCBpbiB0aGUgb3JpZ2luYWwgb3JkZXIgb2YgYGNvbGxgIHBhc3NlZCB0byB0aGVcbiAqIGBpdGVyYXRlZWAgZnVuY3Rpb24uXG4gKlxuICogQG5hbWUgY29uY2F0XG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbGxlY3Rpb25zXG4gKiBAbWV0aG9kXG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxPYmplY3R9IGNvbGwgLSBBIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEEgZnVuY3Rpb24gdG8gYXBwbHkgdG8gZWFjaCBpdGVtIGluIGBjb2xsYCxcbiAqIHdoaWNoIHNob3VsZCB1c2UgYW4gYXJyYXkgYXMgaXRzIHJlc3VsdC4gSW52b2tlZCB3aXRoIChpdGVtLCBjYWxsYmFjaykuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2soZXJyKV0gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCBhZnRlciBhbGwgdGhlXG4gKiBgaXRlcmF0ZWVgIGZ1bmN0aW9ucyBoYXZlIGZpbmlzaGVkLCBvciBhbiBlcnJvciBvY2N1cnMuIFJlc3VsdHMgaXMgYW4gYXJyYXlcbiAqIGNvbnRhaW5pbmcgdGhlIGNvbmNhdGVuYXRlZCByZXN1bHRzIG9mIHRoZSBgaXRlcmF0ZWVgIGZ1bmN0aW9uLiBJbnZva2VkIHdpdGhcbiAqIChlcnIsIHJlc3VsdHMpLlxuICogQGV4YW1wbGVcbiAqXG4gKiBhc3luYy5jb25jYXQoWydkaXIxJywnZGlyMicsJ2RpcjMnXSwgZnMucmVhZGRpciwgZnVuY3Rpb24oZXJyLCBmaWxlcykge1xuICogICAgIC8vIGZpbGVzIGlzIG5vdyBhIGxpc3Qgb2YgZmlsZW5hbWVzIHRoYXQgZXhpc3QgaW4gdGhlIDMgZGlyZWN0b3JpZXNcbiAqIH0pO1xuICovXG52YXIgY29uY2F0ID0gZG9MaW1pdChjb25jYXRMaW1pdCwgSW5maW5pdHkpO1xuXG4vKipcbiAqIFRoZSBzYW1lIGFzIFtgY29uY2F0YF17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLmNvbmNhdH0gYnV0IHJ1bnMgb25seSBhIHNpbmdsZSBhc3luYyBvcGVyYXRpb24gYXQgYSB0aW1lLlxuICpcbiAqIEBuYW1lIGNvbmNhdFNlcmllc1xuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpDb2xsZWN0aW9uc1xuICogQG1ldGhvZFxuICogQHNlZSBbYXN5bmMuY29uY2F0XXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMuY29uY2F0fVxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8T2JqZWN0fSBjb2xsIC0gQSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gaXRlcmF0ZWUgLSBBIGZ1bmN0aW9uIHRvIGFwcGx5IHRvIGVhY2ggaXRlbSBpbiBgY29sbGAuXG4gKiBUaGUgaXRlcmF0ZWUgc2hvdWxkIGNvbXBsZXRlIHdpdGggYW4gYXJyYXkgYW4gYXJyYXkgb2YgcmVzdWx0cy5cbiAqIEludm9rZWQgd2l0aCAoaXRlbSwgY2FsbGJhY2spLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrKGVycildIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgYWZ0ZXIgYWxsIHRoZVxuICogYGl0ZXJhdGVlYCBmdW5jdGlvbnMgaGF2ZSBmaW5pc2hlZCwgb3IgYW4gZXJyb3Igb2NjdXJzLiBSZXN1bHRzIGlzIGFuIGFycmF5XG4gKiBjb250YWluaW5nIHRoZSBjb25jYXRlbmF0ZWQgcmVzdWx0cyBvZiB0aGUgYGl0ZXJhdGVlYCBmdW5jdGlvbi4gSW52b2tlZCB3aXRoXG4gKiAoZXJyLCByZXN1bHRzKS5cbiAqL1xudmFyIGNvbmNhdFNlcmllcyA9IGRvTGltaXQoY29uY2F0TGltaXQsIDEpO1xuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHdoZW4gY2FsbGVkLCBjYWxscy1iYWNrIHdpdGggdGhlIHZhbHVlcyBwcm92aWRlZC5cbiAqIFVzZWZ1bCBhcyB0aGUgZmlyc3QgZnVuY3Rpb24gaW4gYSBbYHdhdGVyZmFsbGBde0BsaW5rIG1vZHVsZTpDb250cm9sRmxvdy53YXRlcmZhbGx9LCBvciBmb3IgcGx1Z2dpbmcgdmFsdWVzIGluIHRvXG4gKiBbYGF1dG9gXXtAbGluayBtb2R1bGU6Q29udHJvbEZsb3cuYXV0b30uXG4gKlxuICogQG5hbWUgY29uc3RhbnRcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6VXRpbHNcbiAqIEBtZXRob2RcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcGFyYW0gey4uLip9IGFyZ3VtZW50cy4uLiAtIEFueSBudW1iZXIgb2YgYXJndW1lbnRzIHRvIGF1dG9tYXRpY2FsbHkgaW52b2tlXG4gKiBjYWxsYmFjayB3aXRoLlxuICogQHJldHVybnMge0FzeW5jRnVuY3Rpb259IFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHdoZW4gaW52b2tlZCwgYXV0b21hdGljYWxseVxuICogaW52b2tlcyB0aGUgY2FsbGJhY2sgd2l0aCB0aGUgcHJldmlvdXMgZ2l2ZW4gYXJndW1lbnRzLlxuICogQGV4YW1wbGVcbiAqXG4gKiBhc3luYy53YXRlcmZhbGwoW1xuICogICAgIGFzeW5jLmNvbnN0YW50KDQyKSxcbiAqICAgICBmdW5jdGlvbiAodmFsdWUsIG5leHQpIHtcbiAqICAgICAgICAgLy8gdmFsdWUgPT09IDQyXG4gKiAgICAgfSxcbiAqICAgICAvLy4uLlxuICogXSwgY2FsbGJhY2spO1xuICpcbiAqIGFzeW5jLndhdGVyZmFsbChbXG4gKiAgICAgYXN5bmMuY29uc3RhbnQoZmlsZW5hbWUsIFwidXRmOFwiKSxcbiAqICAgICBmcy5yZWFkRmlsZSxcbiAqICAgICBmdW5jdGlvbiAoZmlsZURhdGEsIG5leHQpIHtcbiAqICAgICAgICAgLy8uLi5cbiAqICAgICB9XG4gKiAgICAgLy8uLi5cbiAqIF0sIGNhbGxiYWNrKTtcbiAqXG4gKiBhc3luYy5hdXRvKHtcbiAqICAgICBob3N0bmFtZTogYXN5bmMuY29uc3RhbnQoXCJodHRwczovL3NlcnZlci5uZXQvXCIpLFxuICogICAgIHBvcnQ6IGZpbmRGcmVlUG9ydCxcbiAqICAgICBsYXVuY2hTZXJ2ZXI6IFtcImhvc3RuYW1lXCIsIFwicG9ydFwiLCBmdW5jdGlvbiAob3B0aW9ucywgY2IpIHtcbiAqICAgICAgICAgc3RhcnRTZXJ2ZXIob3B0aW9ucywgY2IpO1xuICogICAgIH1dLFxuICogICAgIC8vLi4uXG4gKiB9LCBjYWxsYmFjayk7XG4gKi9cbnZhciBjb25zdGFudCA9IGZ1bmN0aW9uKC8qLi4udmFsdWVzKi8pIHtcbiAgICB2YXIgdmFsdWVzID0gc2xpY2UoYXJndW1lbnRzKTtcbiAgICB2YXIgYXJncyA9IFtudWxsXS5jb25jYXQodmFsdWVzKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKC8qLi4uaWdub3JlZEFyZ3MsIGNhbGxiYWNrKi8pIHtcbiAgICAgICAgdmFyIGNhbGxiYWNrID0gYXJndW1lbnRzW2FyZ3VtZW50cy5sZW5ndGggLSAxXTtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH07XG59O1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgdGhlIGZpcnN0IGFyZ3VtZW50IGl0IHJlY2VpdmVzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcGFyYW0geyp9IHZhbHVlIEFueSB2YWx1ZS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIGB2YWx1ZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSB9O1xuICpcbiAqIGNvbnNvbGUubG9nKF8uaWRlbnRpdHkob2JqZWN0KSA9PT0gb2JqZWN0KTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gaWRlbnRpdHkodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5mdW5jdGlvbiBfY3JlYXRlVGVzdGVyKGNoZWNrLCBnZXRSZXN1bHQpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oZWFjaGZuLCBhcnIsIGl0ZXJhdGVlLCBjYikge1xuICAgICAgICBjYiA9IGNiIHx8IG5vb3A7XG4gICAgICAgIHZhciB0ZXN0UGFzc2VkID0gZmFsc2U7XG4gICAgICAgIHZhciB0ZXN0UmVzdWx0O1xuICAgICAgICBlYWNoZm4oYXJyLCBmdW5jdGlvbih2YWx1ZSwgXywgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGl0ZXJhdGVlKHZhbHVlLCBmdW5jdGlvbihlcnIsIHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNoZWNrKHJlc3VsdCkgJiYgIXRlc3RSZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGVzdFBhc3NlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHRlc3RSZXN1bHQgPSBnZXRSZXN1bHQodHJ1ZSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCBicmVha0xvb3ApO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIGNiKGVycik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNiKG51bGwsIHRlc3RQYXNzZWQgPyB0ZXN0UmVzdWx0IDogZ2V0UmVzdWx0KGZhbHNlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG59XG5cbmZ1bmN0aW9uIF9maW5kR2V0UmVzdWx0KHYsIHgpIHtcbiAgICByZXR1cm4geDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBmaXJzdCB2YWx1ZSBpbiBgY29sbGAgdGhhdCBwYXNzZXMgYW4gYXN5bmMgdHJ1dGggdGVzdC4gVGhlXG4gKiBgaXRlcmF0ZWVgIGlzIGFwcGxpZWQgaW4gcGFyYWxsZWwsIG1lYW5pbmcgdGhlIGZpcnN0IGl0ZXJhdGVlIHRvIHJldHVyblxuICogYHRydWVgIHdpbGwgZmlyZSB0aGUgZGV0ZWN0IGBjYWxsYmFja2Agd2l0aCB0aGF0IHJlc3VsdC4gVGhhdCBtZWFucyB0aGVcbiAqIHJlc3VsdCBtaWdodCBub3QgYmUgdGhlIGZpcnN0IGl0ZW0gaW4gdGhlIG9yaWdpbmFsIGBjb2xsYCAoaW4gdGVybXMgb2Ygb3JkZXIpXG4gKiB0aGF0IHBhc3NlcyB0aGUgdGVzdC5cblxuICogSWYgb3JkZXIgd2l0aGluIHRoZSBvcmlnaW5hbCBgY29sbGAgaXMgaW1wb3J0YW50LCB0aGVuIGxvb2sgYXRcbiAqIFtgZGV0ZWN0U2VyaWVzYF17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLmRldGVjdFNlcmllc30uXG4gKlxuICogQG5hbWUgZGV0ZWN0XG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbGxlY3Rpb25zXG4gKiBAbWV0aG9kXG4gKiBAYWxpYXMgZmluZFxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25zXG4gKiBAcGFyYW0ge0FycmF5fEl0ZXJhYmxlfE9iamVjdH0gY29sbCAtIEEgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGl0ZXJhdGVlIC0gQSB0cnV0aCB0ZXN0IHRvIGFwcGx5IHRvIGVhY2ggaXRlbSBpbiBgY29sbGAuXG4gKiBUaGUgaXRlcmF0ZWUgbXVzdCBjb21wbGV0ZSB3aXRoIGEgYm9vbGVhbiB2YWx1ZSBhcyBpdHMgcmVzdWx0LlxuICogSW52b2tlZCB3aXRoIChpdGVtLCBjYWxsYmFjaykuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgYXMgc29vbiBhcyBhbnlcbiAqIGl0ZXJhdGVlIHJldHVybnMgYHRydWVgLCBvciBhZnRlciBhbGwgdGhlIGBpdGVyYXRlZWAgZnVuY3Rpb25zIGhhdmUgZmluaXNoZWQuXG4gKiBSZXN1bHQgd2lsbCBiZSB0aGUgZmlyc3QgaXRlbSBpbiB0aGUgYXJyYXkgdGhhdCBwYXNzZXMgdGhlIHRydXRoIHRlc3RcbiAqIChpdGVyYXRlZSkgb3IgdGhlIHZhbHVlIGB1bmRlZmluZWRgIGlmIG5vbmUgcGFzc2VkLiBJbnZva2VkIHdpdGhcbiAqIChlcnIsIHJlc3VsdCkuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGFzeW5jLmRldGVjdChbJ2ZpbGUxJywnZmlsZTInLCdmaWxlMyddLCBmdW5jdGlvbihmaWxlUGF0aCwgY2FsbGJhY2spIHtcbiAqICAgICBmcy5hY2Nlc3MoZmlsZVBhdGgsIGZ1bmN0aW9uKGVycikge1xuICogICAgICAgICBjYWxsYmFjayhudWxsLCAhZXJyKVxuICogICAgIH0pO1xuICogfSwgZnVuY3Rpb24oZXJyLCByZXN1bHQpIHtcbiAqICAgICAvLyByZXN1bHQgbm93IGVxdWFscyB0aGUgZmlyc3QgZmlsZSBpbiB0aGUgbGlzdCB0aGF0IGV4aXN0c1xuICogfSk7XG4gKi9cbnZhciBkZXRlY3QgPSBkb1BhcmFsbGVsKF9jcmVhdGVUZXN0ZXIoaWRlbnRpdHksIF9maW5kR2V0UmVzdWx0KSk7XG5cbi8qKlxuICogVGhlIHNhbWUgYXMgW2BkZXRlY3RgXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMuZGV0ZWN0fSBidXQgcnVucyBhIG1heGltdW0gb2YgYGxpbWl0YCBhc3luYyBvcGVyYXRpb25zIGF0IGFcbiAqIHRpbWUuXG4gKlxuICogQG5hbWUgZGV0ZWN0TGltaXRcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29sbGVjdGlvbnNcbiAqIEBtZXRob2RcbiAqIEBzZWUgW2FzeW5jLmRldGVjdF17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLmRldGVjdH1cbiAqIEBhbGlhcyBmaW5kTGltaXRcbiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uc1xuICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxPYmplY3R9IGNvbGwgLSBBIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtudW1iZXJ9IGxpbWl0IC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIGFzeW5jIG9wZXJhdGlvbnMgYXQgYSB0aW1lLlxuICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEEgdHJ1dGggdGVzdCB0byBhcHBseSB0byBlYWNoIGl0ZW0gaW4gYGNvbGxgLlxuICogVGhlIGl0ZXJhdGVlIG11c3QgY29tcGxldGUgd2l0aCBhIGJvb2xlYW4gdmFsdWUgYXMgaXRzIHJlc3VsdC5cbiAqIEludm9rZWQgd2l0aCAoaXRlbSwgY2FsbGJhY2spLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIGFzIHNvb24gYXMgYW55XG4gKiBpdGVyYXRlZSByZXR1cm5zIGB0cnVlYCwgb3IgYWZ0ZXIgYWxsIHRoZSBgaXRlcmF0ZWVgIGZ1bmN0aW9ucyBoYXZlIGZpbmlzaGVkLlxuICogUmVzdWx0IHdpbGwgYmUgdGhlIGZpcnN0IGl0ZW0gaW4gdGhlIGFycmF5IHRoYXQgcGFzc2VzIHRoZSB0cnV0aCB0ZXN0XG4gKiAoaXRlcmF0ZWUpIG9yIHRoZSB2YWx1ZSBgdW5kZWZpbmVkYCBpZiBub25lIHBhc3NlZC4gSW52b2tlZCB3aXRoXG4gKiAoZXJyLCByZXN1bHQpLlxuICovXG52YXIgZGV0ZWN0TGltaXQgPSBkb1BhcmFsbGVsTGltaXQoX2NyZWF0ZVRlc3RlcihpZGVudGl0eSwgX2ZpbmRHZXRSZXN1bHQpKTtcblxuLyoqXG4gKiBUaGUgc2FtZSBhcyBbYGRldGVjdGBde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5kZXRlY3R9IGJ1dCBydW5zIG9ubHkgYSBzaW5nbGUgYXN5bmMgb3BlcmF0aW9uIGF0IGEgdGltZS5cbiAqXG4gKiBAbmFtZSBkZXRlY3RTZXJpZXNcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29sbGVjdGlvbnNcbiAqIEBtZXRob2RcbiAqIEBzZWUgW2FzeW5jLmRldGVjdF17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLmRldGVjdH1cbiAqIEBhbGlhcyBmaW5kU2VyaWVzXG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbnNcbiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8T2JqZWN0fSBjb2xsIC0gQSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gaXRlcmF0ZWUgLSBBIHRydXRoIHRlc3QgdG8gYXBwbHkgdG8gZWFjaCBpdGVtIGluIGBjb2xsYC5cbiAqIFRoZSBpdGVyYXRlZSBtdXN0IGNvbXBsZXRlIHdpdGggYSBib29sZWFuIHZhbHVlIGFzIGl0cyByZXN1bHQuXG4gKiBJbnZva2VkIHdpdGggKGl0ZW0sIGNhbGxiYWNrKS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCBhcyBzb29uIGFzIGFueVxuICogaXRlcmF0ZWUgcmV0dXJucyBgdHJ1ZWAsIG9yIGFmdGVyIGFsbCB0aGUgYGl0ZXJhdGVlYCBmdW5jdGlvbnMgaGF2ZSBmaW5pc2hlZC5cbiAqIFJlc3VsdCB3aWxsIGJlIHRoZSBmaXJzdCBpdGVtIGluIHRoZSBhcnJheSB0aGF0IHBhc3NlcyB0aGUgdHJ1dGggdGVzdFxuICogKGl0ZXJhdGVlKSBvciB0aGUgdmFsdWUgYHVuZGVmaW5lZGAgaWYgbm9uZSBwYXNzZWQuIEludm9rZWQgd2l0aFxuICogKGVyciwgcmVzdWx0KS5cbiAqL1xudmFyIGRldGVjdFNlcmllcyA9IGRvTGltaXQoZGV0ZWN0TGltaXQsIDEpO1xuXG5mdW5jdGlvbiBjb25zb2xlRnVuYyhuYW1lKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChmbi8qLCAuLi5hcmdzKi8pIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBzbGljZShhcmd1bWVudHMsIDEpO1xuICAgICAgICBhcmdzLnB1c2goZnVuY3Rpb24gKGVyci8qLCAuLi5hcmdzKi8pIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gc2xpY2UoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY29uc29sZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb25zb2xlLmVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNvbnNvbGVbbmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgYXJyYXlFYWNoKGFyZ3MsIGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlW25hbWVdKHgpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB3cmFwQXN5bmMoZm4pLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgIH07XG59XG5cbi8qKlxuICogTG9ncyB0aGUgcmVzdWx0IG9mIGFuIFtgYXN5bmNgIGZ1bmN0aW9uXXtAbGluayBBc3luY0Z1bmN0aW9ufSB0byB0aGVcbiAqIGBjb25zb2xlYCB1c2luZyBgY29uc29sZS5kaXJgIHRvIGRpc3BsYXkgdGhlIHByb3BlcnRpZXMgb2YgdGhlIHJlc3VsdGluZyBvYmplY3QuXG4gKiBPbmx5IHdvcmtzIGluIE5vZGUuanMgb3IgaW4gYnJvd3NlcnMgdGhhdCBzdXBwb3J0IGBjb25zb2xlLmRpcmAgYW5kXG4gKiBgY29uc29sZS5lcnJvcmAgKHN1Y2ggYXMgRkYgYW5kIENocm9tZSkuXG4gKiBJZiBtdWx0aXBsZSBhcmd1bWVudHMgYXJlIHJldHVybmVkIGZyb20gdGhlIGFzeW5jIGZ1bmN0aW9uLFxuICogYGNvbnNvbGUuZGlyYCBpcyBjYWxsZWQgb24gZWFjaCBhcmd1bWVudCBpbiBvcmRlci5cbiAqXG4gKiBAbmFtZSBkaXJcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6VXRpbHNcbiAqIEBtZXRob2RcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGZ1bmN0aW9uIC0gVGhlIGZ1bmN0aW9uIHlvdSB3YW50IHRvIGV2ZW50dWFsbHkgYXBwbHlcbiAqIGFsbCBhcmd1bWVudHMgdG8uXG4gKiBAcGFyYW0gey4uLip9IGFyZ3VtZW50cy4uLiAtIEFueSBudW1iZXIgb2YgYXJndW1lbnRzIHRvIGFwcGx5IHRvIHRoZSBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogLy8gaW4gYSBtb2R1bGVcbiAqIHZhciBoZWxsbyA9IGZ1bmN0aW9uKG5hbWUsIGNhbGxiYWNrKSB7XG4gKiAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAqICAgICAgICAgY2FsbGJhY2sobnVsbCwge2hlbGxvOiBuYW1lfSk7XG4gKiAgICAgfSwgMTAwMCk7XG4gKiB9O1xuICpcbiAqIC8vIGluIHRoZSBub2RlIHJlcGxcbiAqIG5vZGU+IGFzeW5jLmRpcihoZWxsbywgJ3dvcmxkJyk7XG4gKiB7aGVsbG86ICd3b3JsZCd9XG4gKi9cbnZhciBkaXIgPSBjb25zb2xlRnVuYygnZGlyJyk7XG5cbi8qKlxuICogVGhlIHBvc3QtY2hlY2sgdmVyc2lvbiBvZiBbYGR1cmluZ2Bde0BsaW5rIG1vZHVsZTpDb250cm9sRmxvdy5kdXJpbmd9LiBUbyByZWZsZWN0IHRoZSBkaWZmZXJlbmNlIGluXG4gKiB0aGUgb3JkZXIgb2Ygb3BlcmF0aW9ucywgdGhlIGFyZ3VtZW50cyBgdGVzdGAgYW5kIGBmbmAgYXJlIHN3aXRjaGVkLlxuICpcbiAqIEFsc28gYSB2ZXJzaW9uIG9mIFtgZG9XaGlsc3RgXXtAbGluayBtb2R1bGU6Q29udHJvbEZsb3cuZG9XaGlsc3R9IHdpdGggYXN5bmNocm9ub3VzIGB0ZXN0YCBmdW5jdGlvbi5cbiAqIEBuYW1lIGRvRHVyaW5nXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbnRyb2xGbG93XG4gKiBAbWV0aG9kXG4gKiBAc2VlIFthc3luYy5kdXJpbmdde0BsaW5rIG1vZHVsZTpDb250cm9sRmxvdy5kdXJpbmd9XG4gKiBAY2F0ZWdvcnkgQ29udHJvbCBGbG93XG4gKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGZuIC0gQW4gYXN5bmMgZnVuY3Rpb24gd2hpY2ggaXMgY2FsbGVkIGVhY2ggdGltZVxuICogYHRlc3RgIHBhc3Nlcy4gSW52b2tlZCB3aXRoIChjYWxsYmFjaykuXG4gKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IHRlc3QgLSBhc3luY2hyb25vdXMgdHJ1dGggdGVzdCB0byBwZXJmb3JtIGJlZm9yZSBlYWNoXG4gKiBleGVjdXRpb24gb2YgYGZuYC4gSW52b2tlZCB3aXRoICguLi5hcmdzLCBjYWxsYmFjayksIHdoZXJlIGAuLi5hcmdzYCBhcmUgdGhlXG4gKiBub24tZXJyb3IgYXJncyBmcm9tIHRoZSBwcmV2aW91cyBjYWxsYmFjayBvZiBgZm5gLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIGFmdGVyIHRoZSB0ZXN0XG4gKiBmdW5jdGlvbiBoYXMgZmFpbGVkIGFuZCByZXBlYXRlZCBleGVjdXRpb24gb2YgYGZuYCBoYXMgc3RvcHBlZC4gYGNhbGxiYWNrYFxuICogd2lsbCBiZSBwYXNzZWQgYW4gZXJyb3IgaWYgb25lIG9jY3VycmVkLCBvdGhlcndpc2UgYG51bGxgLlxuICovXG5mdW5jdGlvbiBkb0R1cmluZyhmbiwgdGVzdCwgY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjayA9IG9ubHlPbmNlKGNhbGxiYWNrIHx8IG5vb3ApO1xuICAgIHZhciBfZm4gPSB3cmFwQXN5bmMoZm4pO1xuICAgIHZhciBfdGVzdCA9IHdyYXBBc3luYyh0ZXN0KTtcblxuICAgIGZ1bmN0aW9uIG5leHQoZXJyLyosIC4uLmFyZ3MqLykge1xuICAgICAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgdmFyIGFyZ3MgPSBzbGljZShhcmd1bWVudHMsIDEpO1xuICAgICAgICBhcmdzLnB1c2goY2hlY2spO1xuICAgICAgICBfdGVzdC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjaGVjayhlcnIsIHRydXRoKSB7XG4gICAgICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICBpZiAoIXRydXRoKSByZXR1cm4gY2FsbGJhY2sobnVsbCk7XG4gICAgICAgIF9mbihuZXh0KTtcbiAgICB9XG5cbiAgICBjaGVjayhudWxsLCB0cnVlKTtcblxufVxuXG4vKipcbiAqIFRoZSBwb3N0LWNoZWNrIHZlcnNpb24gb2YgW2B3aGlsc3RgXXtAbGluayBtb2R1bGU6Q29udHJvbEZsb3cud2hpbHN0fS4gVG8gcmVmbGVjdCB0aGUgZGlmZmVyZW5jZSBpblxuICogdGhlIG9yZGVyIG9mIG9wZXJhdGlvbnMsIHRoZSBhcmd1bWVudHMgYHRlc3RgIGFuZCBgaXRlcmF0ZWVgIGFyZSBzd2l0Y2hlZC5cbiAqXG4gKiBgZG9XaGlsc3RgIGlzIHRvIGB3aGlsc3RgIGFzIGBkbyB3aGlsZWAgaXMgdG8gYHdoaWxlYCBpbiBwbGFpbiBKYXZhU2NyaXB0LlxuICpcbiAqIEBuYW1lIGRvV2hpbHN0XG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbnRyb2xGbG93XG4gKiBAbWV0aG9kXG4gKiBAc2VlIFthc3luYy53aGlsc3Rde0BsaW5rIG1vZHVsZTpDb250cm9sRmxvdy53aGlsc3R9XG4gKiBAY2F0ZWdvcnkgQ29udHJvbCBGbG93XG4gKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGl0ZXJhdGVlIC0gQSBmdW5jdGlvbiB3aGljaCBpcyBjYWxsZWQgZWFjaCB0aW1lIGB0ZXN0YFxuICogcGFzc2VzLiBJbnZva2VkIHdpdGggKGNhbGxiYWNrKS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHRlc3QgLSBzeW5jaHJvbm91cyB0cnV0aCB0ZXN0IHRvIHBlcmZvcm0gYWZ0ZXIgZWFjaFxuICogZXhlY3V0aW9uIG9mIGBpdGVyYXRlZWAuIEludm9rZWQgd2l0aCBhbnkgbm9uLWVycm9yIGNhbGxiYWNrIHJlc3VsdHMgb2ZcbiAqIGBpdGVyYXRlZWAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgYWZ0ZXIgdGhlIHRlc3RcbiAqIGZ1bmN0aW9uIGhhcyBmYWlsZWQgYW5kIHJlcGVhdGVkIGV4ZWN1dGlvbiBvZiBgaXRlcmF0ZWVgIGhhcyBzdG9wcGVkLlxuICogYGNhbGxiYWNrYCB3aWxsIGJlIHBhc3NlZCBhbiBlcnJvciBhbmQgYW55IGFyZ3VtZW50cyBwYXNzZWQgdG8gdGhlIGZpbmFsXG4gKiBgaXRlcmF0ZWVgJ3MgY2FsbGJhY2suIEludm9rZWQgd2l0aCAoZXJyLCBbcmVzdWx0c10pO1xuICovXG5mdW5jdGlvbiBkb1doaWxzdChpdGVyYXRlZSwgdGVzdCwgY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjayA9IG9ubHlPbmNlKGNhbGxiYWNrIHx8IG5vb3ApO1xuICAgIHZhciBfaXRlcmF0ZWUgPSB3cmFwQXN5bmMoaXRlcmF0ZWUpO1xuICAgIHZhciBuZXh0ID0gZnVuY3Rpb24oZXJyLyosIC4uLmFyZ3MqLykge1xuICAgICAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgdmFyIGFyZ3MgPSBzbGljZShhcmd1bWVudHMsIDEpO1xuICAgICAgICBpZiAodGVzdC5hcHBseSh0aGlzLCBhcmdzKSkgcmV0dXJuIF9pdGVyYXRlZShuZXh0KTtcbiAgICAgICAgY2FsbGJhY2suYXBwbHkobnVsbCwgW251bGxdLmNvbmNhdChhcmdzKSk7XG4gICAgfTtcbiAgICBfaXRlcmF0ZWUobmV4dCk7XG59XG5cbi8qKlxuICogTGlrZSBbJ2RvV2hpbHN0J117QGxpbmsgbW9kdWxlOkNvbnRyb2xGbG93LmRvV2hpbHN0fSwgZXhjZXB0IHRoZSBgdGVzdGAgaXMgaW52ZXJ0ZWQuIE5vdGUgdGhlXG4gKiBhcmd1bWVudCBvcmRlcmluZyBkaWZmZXJzIGZyb20gYHVudGlsYC5cbiAqXG4gKiBAbmFtZSBkb1VudGlsXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbnRyb2xGbG93XG4gKiBAbWV0aG9kXG4gKiBAc2VlIFthc3luYy5kb1doaWxzdF17QGxpbmsgbW9kdWxlOkNvbnRyb2xGbG93LmRvV2hpbHN0fVxuICogQGNhdGVnb3J5IENvbnRyb2wgRmxvd1xuICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEFuIGFzeW5jIGZ1bmN0aW9uIHdoaWNoIGlzIGNhbGxlZCBlYWNoIHRpbWVcbiAqIGB0ZXN0YCBmYWlscy4gSW52b2tlZCB3aXRoIChjYWxsYmFjaykuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSB0ZXN0IC0gc3luY2hyb25vdXMgdHJ1dGggdGVzdCB0byBwZXJmb3JtIGFmdGVyIGVhY2hcbiAqIGV4ZWN1dGlvbiBvZiBgaXRlcmF0ZWVgLiBJbnZva2VkIHdpdGggYW55IG5vbi1lcnJvciBjYWxsYmFjayByZXN1bHRzIG9mXG4gKiBgaXRlcmF0ZWVgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIGFmdGVyIHRoZSB0ZXN0XG4gKiBmdW5jdGlvbiBoYXMgcGFzc2VkIGFuZCByZXBlYXRlZCBleGVjdXRpb24gb2YgYGl0ZXJhdGVlYCBoYXMgc3RvcHBlZC4gYGNhbGxiYWNrYFxuICogd2lsbCBiZSBwYXNzZWQgYW4gZXJyb3IgYW5kIGFueSBhcmd1bWVudHMgcGFzc2VkIHRvIHRoZSBmaW5hbCBgaXRlcmF0ZWVgJ3NcbiAqIGNhbGxiYWNrLiBJbnZva2VkIHdpdGggKGVyciwgW3Jlc3VsdHNdKTtcbiAqL1xuZnVuY3Rpb24gZG9VbnRpbChpdGVyYXRlZSwgdGVzdCwgY2FsbGJhY2spIHtcbiAgICBkb1doaWxzdChpdGVyYXRlZSwgZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAhdGVzdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH0sIGNhbGxiYWNrKTtcbn1cblxuLyoqXG4gKiBMaWtlIFtgd2hpbHN0YF17QGxpbmsgbW9kdWxlOkNvbnRyb2xGbG93LndoaWxzdH0sIGV4Y2VwdCB0aGUgYHRlc3RgIGlzIGFuIGFzeW5jaHJvbm91cyBmdW5jdGlvbiB0aGF0XG4gKiBpcyBwYXNzZWQgYSBjYWxsYmFjayBpbiB0aGUgZm9ybSBvZiBgZnVuY3Rpb24gKGVyciwgdHJ1dGgpYC4gSWYgZXJyb3IgaXNcbiAqIHBhc3NlZCB0byBgdGVzdGAgb3IgYGZuYCwgdGhlIG1haW4gY2FsbGJhY2sgaXMgaW1tZWRpYXRlbHkgY2FsbGVkIHdpdGggdGhlXG4gKiB2YWx1ZSBvZiB0aGUgZXJyb3IuXG4gKlxuICogQG5hbWUgZHVyaW5nXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbnRyb2xGbG93XG4gKiBAbWV0aG9kXG4gKiBAc2VlIFthc3luYy53aGlsc3Rde0BsaW5rIG1vZHVsZTpDb250cm9sRmxvdy53aGlsc3R9XG4gKiBAY2F0ZWdvcnkgQ29udHJvbCBGbG93XG4gKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IHRlc3QgLSBhc3luY2hyb25vdXMgdHJ1dGggdGVzdCB0byBwZXJmb3JtIGJlZm9yZSBlYWNoXG4gKiBleGVjdXRpb24gb2YgYGZuYC4gSW52b2tlZCB3aXRoIChjYWxsYmFjaykuXG4gKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGZuIC0gQW4gYXN5bmMgZnVuY3Rpb24gd2hpY2ggaXMgY2FsbGVkIGVhY2ggdGltZVxuICogYHRlc3RgIHBhc3Nlcy4gSW52b2tlZCB3aXRoIChjYWxsYmFjaykuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgYWZ0ZXIgdGhlIHRlc3RcbiAqIGZ1bmN0aW9uIGhhcyBmYWlsZWQgYW5kIHJlcGVhdGVkIGV4ZWN1dGlvbiBvZiBgZm5gIGhhcyBzdG9wcGVkLiBgY2FsbGJhY2tgXG4gKiB3aWxsIGJlIHBhc3NlZCBhbiBlcnJvciwgaWYgb25lIG9jY3VycmVkLCBvdGhlcndpc2UgYG51bGxgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgY291bnQgPSAwO1xuICpcbiAqIGFzeW5jLmR1cmluZyhcbiAqICAgICBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAqICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIGNvdW50IDwgNSk7XG4gKiAgICAgfSxcbiAqICAgICBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAqICAgICAgICAgY291bnQrKztcbiAqICAgICAgICAgc2V0VGltZW91dChjYWxsYmFjaywgMTAwMCk7XG4gKiAgICAgfSxcbiAqICAgICBmdW5jdGlvbiAoZXJyKSB7XG4gKiAgICAgICAgIC8vIDUgc2Vjb25kcyBoYXZlIHBhc3NlZFxuICogICAgIH1cbiAqICk7XG4gKi9cbmZ1bmN0aW9uIGR1cmluZyh0ZXN0LCBmbiwgY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjayA9IG9ubHlPbmNlKGNhbGxiYWNrIHx8IG5vb3ApO1xuICAgIHZhciBfZm4gPSB3cmFwQXN5bmMoZm4pO1xuICAgIHZhciBfdGVzdCA9IHdyYXBBc3luYyh0ZXN0KTtcblxuICAgIGZ1bmN0aW9uIG5leHQoZXJyKSB7XG4gICAgICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICBfdGVzdChjaGVjayk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2hlY2soZXJyLCB0cnV0aCkge1xuICAgICAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgaWYgKCF0cnV0aCkgcmV0dXJuIGNhbGxiYWNrKG51bGwpO1xuICAgICAgICBfZm4obmV4dCk7XG4gICAgfVxuXG4gICAgX3Rlc3QoY2hlY2spO1xufVxuXG5mdW5jdGlvbiBfd2l0aG91dEluZGV4KGl0ZXJhdGVlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSwgaW5kZXgsIGNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiBpdGVyYXRlZSh2YWx1ZSwgY2FsbGJhY2spO1xuICAgIH07XG59XG5cbi8qKlxuICogQXBwbGllcyB0aGUgZnVuY3Rpb24gYGl0ZXJhdGVlYCB0byBlYWNoIGl0ZW0gaW4gYGNvbGxgLCBpbiBwYXJhbGxlbC5cbiAqIFRoZSBgaXRlcmF0ZWVgIGlzIGNhbGxlZCB3aXRoIGFuIGl0ZW0gZnJvbSB0aGUgbGlzdCwgYW5kIGEgY2FsbGJhY2sgZm9yIHdoZW5cbiAqIGl0IGhhcyBmaW5pc2hlZC4gSWYgdGhlIGBpdGVyYXRlZWAgcGFzc2VzIGFuIGVycm9yIHRvIGl0cyBgY2FsbGJhY2tgLCB0aGVcbiAqIG1haW4gYGNhbGxiYWNrYCAoZm9yIHRoZSBgZWFjaGAgZnVuY3Rpb24pIGlzIGltbWVkaWF0ZWx5IGNhbGxlZCB3aXRoIHRoZVxuICogZXJyb3IuXG4gKlxuICogTm90ZSwgdGhhdCBzaW5jZSB0aGlzIGZ1bmN0aW9uIGFwcGxpZXMgYGl0ZXJhdGVlYCB0byBlYWNoIGl0ZW0gaW4gcGFyYWxsZWwsXG4gKiB0aGVyZSBpcyBubyBndWFyYW50ZWUgdGhhdCB0aGUgaXRlcmF0ZWUgZnVuY3Rpb25zIHdpbGwgY29tcGxldGUgaW4gb3JkZXIuXG4gKlxuICogQG5hbWUgZWFjaFxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpDb2xsZWN0aW9uc1xuICogQG1ldGhvZFxuICogQGFsaWFzIGZvckVhY2hcbiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gKiBAcGFyYW0ge0FycmF5fEl0ZXJhYmxlfE9iamVjdH0gY29sbCAtIEEgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGl0ZXJhdGVlIC0gQW4gYXN5bmMgZnVuY3Rpb24gdG8gYXBwbHkgdG9cbiAqIGVhY2ggaXRlbSBpbiBgY29sbGAuIEludm9rZWQgd2l0aCAoaXRlbSwgY2FsbGJhY2spLlxuICogVGhlIGFycmF5IGluZGV4IGlzIG5vdCBwYXNzZWQgdG8gdGhlIGl0ZXJhdGVlLlxuICogSWYgeW91IG5lZWQgdGhlIGluZGV4LCB1c2UgYGVhY2hPZmAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgd2hlbiBhbGxcbiAqIGBpdGVyYXRlZWAgZnVuY3Rpb25zIGhhdmUgZmluaXNoZWQsIG9yIGFuIGVycm9yIG9jY3Vycy4gSW52b2tlZCB3aXRoIChlcnIpLlxuICogQGV4YW1wbGVcbiAqXG4gKiAvLyBhc3N1bWluZyBvcGVuRmlsZXMgaXMgYW4gYXJyYXkgb2YgZmlsZSBuYW1lcyBhbmQgc2F2ZUZpbGUgaXMgYSBmdW5jdGlvblxuICogLy8gdG8gc2F2ZSB0aGUgbW9kaWZpZWQgY29udGVudHMgb2YgdGhhdCBmaWxlOlxuICpcbiAqIGFzeW5jLmVhY2gob3BlbkZpbGVzLCBzYXZlRmlsZSwgZnVuY3Rpb24oZXJyKXtcbiAqICAgLy8gaWYgYW55IG9mIHRoZSBzYXZlcyBwcm9kdWNlZCBhbiBlcnJvciwgZXJyIHdvdWxkIGVxdWFsIHRoYXQgZXJyb3JcbiAqIH0pO1xuICpcbiAqIC8vIGFzc3VtaW5nIG9wZW5GaWxlcyBpcyBhbiBhcnJheSBvZiBmaWxlIG5hbWVzXG4gKiBhc3luYy5lYWNoKG9wZW5GaWxlcywgZnVuY3Rpb24oZmlsZSwgY2FsbGJhY2spIHtcbiAqXG4gKiAgICAgLy8gUGVyZm9ybSBvcGVyYXRpb24gb24gZmlsZSBoZXJlLlxuICogICAgIGNvbnNvbGUubG9nKCdQcm9jZXNzaW5nIGZpbGUgJyArIGZpbGUpO1xuICpcbiAqICAgICBpZiggZmlsZS5sZW5ndGggPiAzMiApIHtcbiAqICAgICAgIGNvbnNvbGUubG9nKCdUaGlzIGZpbGUgbmFtZSBpcyB0b28gbG9uZycpO1xuICogICAgICAgY2FsbGJhY2soJ0ZpbGUgbmFtZSB0b28gbG9uZycpO1xuICogICAgIH0gZWxzZSB7XG4gKiAgICAgICAvLyBEbyB3b3JrIHRvIHByb2Nlc3MgZmlsZSBoZXJlXG4gKiAgICAgICBjb25zb2xlLmxvZygnRmlsZSBwcm9jZXNzZWQnKTtcbiAqICAgICAgIGNhbGxiYWNrKCk7XG4gKiAgICAgfVxuICogfSwgZnVuY3Rpb24oZXJyKSB7XG4gKiAgICAgLy8gaWYgYW55IG9mIHRoZSBmaWxlIHByb2Nlc3NpbmcgcHJvZHVjZWQgYW4gZXJyb3IsIGVyciB3b3VsZCBlcXVhbCB0aGF0IGVycm9yXG4gKiAgICAgaWYoIGVyciApIHtcbiAqICAgICAgIC8vIE9uZSBvZiB0aGUgaXRlcmF0aW9ucyBwcm9kdWNlZCBhbiBlcnJvci5cbiAqICAgICAgIC8vIEFsbCBwcm9jZXNzaW5nIHdpbGwgbm93IHN0b3AuXG4gKiAgICAgICBjb25zb2xlLmxvZygnQSBmaWxlIGZhaWxlZCB0byBwcm9jZXNzJyk7XG4gKiAgICAgfSBlbHNlIHtcbiAqICAgICAgIGNvbnNvbGUubG9nKCdBbGwgZmlsZXMgaGF2ZSBiZWVuIHByb2Nlc3NlZCBzdWNjZXNzZnVsbHknKTtcbiAqICAgICB9XG4gKiB9KTtcbiAqL1xuZnVuY3Rpb24gZWFjaExpbWl0KGNvbGwsIGl0ZXJhdGVlLCBjYWxsYmFjaykge1xuICAgIGVhY2hPZihjb2xsLCBfd2l0aG91dEluZGV4KHdyYXBBc3luYyhpdGVyYXRlZSkpLCBjYWxsYmFjayk7XG59XG5cbi8qKlxuICogVGhlIHNhbWUgYXMgW2BlYWNoYF17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLmVhY2h9IGJ1dCBydW5zIGEgbWF4aW11bSBvZiBgbGltaXRgIGFzeW5jIG9wZXJhdGlvbnMgYXQgYSB0aW1lLlxuICpcbiAqIEBuYW1lIGVhY2hMaW1pdFxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpDb2xsZWN0aW9uc1xuICogQG1ldGhvZFxuICogQHNlZSBbYXN5bmMuZWFjaF17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLmVhY2h9XG4gKiBAYWxpYXMgZm9yRWFjaExpbWl0XG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxPYmplY3R9IGNvbGwgLSBBIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtudW1iZXJ9IGxpbWl0IC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIGFzeW5jIG9wZXJhdGlvbnMgYXQgYSB0aW1lLlxuICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEFuIGFzeW5jIGZ1bmN0aW9uIHRvIGFwcGx5IHRvIGVhY2ggaXRlbSBpblxuICogYGNvbGxgLlxuICogVGhlIGFycmF5IGluZGV4IGlzIG5vdCBwYXNzZWQgdG8gdGhlIGl0ZXJhdGVlLlxuICogSWYgeW91IG5lZWQgdGhlIGluZGV4LCB1c2UgYGVhY2hPZkxpbWl0YC5cbiAqIEludm9rZWQgd2l0aCAoaXRlbSwgY2FsbGJhY2spLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIHdoZW4gYWxsXG4gKiBgaXRlcmF0ZWVgIGZ1bmN0aW9ucyBoYXZlIGZpbmlzaGVkLCBvciBhbiBlcnJvciBvY2N1cnMuIEludm9rZWQgd2l0aCAoZXJyKS5cbiAqL1xuZnVuY3Rpb24gZWFjaExpbWl0JDEoY29sbCwgbGltaXQsIGl0ZXJhdGVlLCBjYWxsYmFjaykge1xuICAgIF9lYWNoT2ZMaW1pdChsaW1pdCkoY29sbCwgX3dpdGhvdXRJbmRleCh3cmFwQXN5bmMoaXRlcmF0ZWUpKSwgY2FsbGJhY2spO1xufVxuXG4vKipcbiAqIFRoZSBzYW1lIGFzIFtgZWFjaGBde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5lYWNofSBidXQgcnVucyBvbmx5IGEgc2luZ2xlIGFzeW5jIG9wZXJhdGlvbiBhdCBhIHRpbWUuXG4gKlxuICogQG5hbWUgZWFjaFNlcmllc1xuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpDb2xsZWN0aW9uc1xuICogQG1ldGhvZFxuICogQHNlZSBbYXN5bmMuZWFjaF17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLmVhY2h9XG4gKiBAYWxpYXMgZm9yRWFjaFNlcmllc1xuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8T2JqZWN0fSBjb2xsIC0gQSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gaXRlcmF0ZWUgLSBBbiBhc3luYyBmdW5jdGlvbiB0byBhcHBseSB0byBlYWNoXG4gKiBpdGVtIGluIGBjb2xsYC5cbiAqIFRoZSBhcnJheSBpbmRleCBpcyBub3QgcGFzc2VkIHRvIHRoZSBpdGVyYXRlZS5cbiAqIElmIHlvdSBuZWVkIHRoZSBpbmRleCwgdXNlIGBlYWNoT2ZTZXJpZXNgLlxuICogSW52b2tlZCB3aXRoIChpdGVtLCBjYWxsYmFjaykuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgd2hlbiBhbGxcbiAqIGBpdGVyYXRlZWAgZnVuY3Rpb25zIGhhdmUgZmluaXNoZWQsIG9yIGFuIGVycm9yIG9jY3Vycy4gSW52b2tlZCB3aXRoIChlcnIpLlxuICovXG52YXIgZWFjaFNlcmllcyA9IGRvTGltaXQoZWFjaExpbWl0JDEsIDEpO1xuXG4vKipcbiAqIFdyYXAgYW4gYXN5bmMgZnVuY3Rpb24gYW5kIGVuc3VyZSBpdCBjYWxscyBpdHMgY2FsbGJhY2sgb24gYSBsYXRlciB0aWNrIG9mXG4gKiB0aGUgZXZlbnQgbG9vcC4gIElmIHRoZSBmdW5jdGlvbiBhbHJlYWR5IGNhbGxzIGl0cyBjYWxsYmFjayBvbiBhIG5leHQgdGljayxcbiAqIG5vIGV4dHJhIGRlZmVycmFsIGlzIGFkZGVkLiBUaGlzIGlzIHVzZWZ1bCBmb3IgcHJldmVudGluZyBzdGFjayBvdmVyZmxvd3NcbiAqIChgUmFuZ2VFcnJvcjogTWF4aW11bSBjYWxsIHN0YWNrIHNpemUgZXhjZWVkZWRgKSBhbmQgZ2VuZXJhbGx5IGtlZXBpbmdcbiAqIFtaYWxnb10oaHR0cDovL2Jsb2cuaXpzLm1lL3Bvc3QvNTkxNDI3NDIxNDMvZGVzaWduaW5nLWFwaXMtZm9yLWFzeW5jaHJvbnkpXG4gKiBjb250YWluZWQuIEVTMjAxNyBgYXN5bmNgIGZ1bmN0aW9ucyBhcmUgcmV0dXJuZWQgYXMtaXMgLS0gdGhleSBhcmUgaW1tdW5lXG4gKiB0byBaYWxnbydzIGNvcnJ1cHRpbmcgaW5mbHVlbmNlcywgYXMgdGhleSBhbHdheXMgcmVzb2x2ZSBvbiBhIGxhdGVyIHRpY2suXG4gKlxuICogQG5hbWUgZW5zdXJlQXN5bmNcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6VXRpbHNcbiAqIEBtZXRob2RcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGZuIC0gYW4gYXN5bmMgZnVuY3Rpb24sIG9uZSB0aGF0IGV4cGVjdHMgYSBub2RlLXN0eWxlXG4gKiBjYWxsYmFjayBhcyBpdHMgbGFzdCBhcmd1bWVudC5cbiAqIEByZXR1cm5zIHtBc3luY0Z1bmN0aW9ufSBSZXR1cm5zIGEgd3JhcHBlZCBmdW5jdGlvbiB3aXRoIHRoZSBleGFjdCBzYW1lIGNhbGxcbiAqIHNpZ25hdHVyZSBhcyB0aGUgZnVuY3Rpb24gcGFzc2VkIGluLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBzb21ldGltZXNBc3luYyhhcmcsIGNhbGxiYWNrKSB7XG4gKiAgICAgaWYgKGNhY2hlW2FyZ10pIHtcbiAqICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIGNhY2hlW2FyZ10pOyAvLyB0aGlzIHdvdWxkIGJlIHN5bmNocm9ub3VzISFcbiAqICAgICB9IGVsc2Uge1xuICogICAgICAgICBkb1NvbWVJTyhhcmcsIGNhbGxiYWNrKTsgLy8gdGhpcyBJTyB3b3VsZCBiZSBhc3luY2hyb25vdXNcbiAqICAgICB9XG4gKiB9XG4gKlxuICogLy8gdGhpcyBoYXMgYSByaXNrIG9mIHN0YWNrIG92ZXJmbG93cyBpZiBtYW55IHJlc3VsdHMgYXJlIGNhY2hlZCBpbiBhIHJvd1xuICogYXN5bmMubWFwU2VyaWVzKGFyZ3MsIHNvbWV0aW1lc0FzeW5jLCBkb25lKTtcbiAqXG4gKiAvLyB0aGlzIHdpbGwgZGVmZXIgc29tZXRpbWVzQXN5bmMncyBjYWxsYmFjayBpZiBuZWNlc3NhcnksXG4gKiAvLyBwcmV2ZW50aW5nIHN0YWNrIG92ZXJmbG93c1xuICogYXN5bmMubWFwU2VyaWVzKGFyZ3MsIGFzeW5jLmVuc3VyZUFzeW5jKHNvbWV0aW1lc0FzeW5jKSwgZG9uZSk7XG4gKi9cbmZ1bmN0aW9uIGVuc3VyZUFzeW5jKGZuKSB7XG4gICAgaWYgKGlzQXN5bmMoZm4pKSByZXR1cm4gZm47XG4gICAgcmV0dXJuIGluaXRpYWxQYXJhbXMoZnVuY3Rpb24gKGFyZ3MsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBzeW5jID0gdHJ1ZTtcbiAgICAgICAgYXJncy5wdXNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBpbm5lckFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgICAgICBpZiAoc3luYykge1xuICAgICAgICAgICAgICAgIHNldEltbWVkaWF0ZSQxKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2suYXBwbHkobnVsbCwgaW5uZXJBcmdzKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2suYXBwbHkobnVsbCwgaW5uZXJBcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGZuLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICBzeW5jID0gZmFsc2U7XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIG5vdElkKHYpIHtcbiAgICByZXR1cm4gIXY7XG59XG5cbi8qKlxuICogUmV0dXJucyBgdHJ1ZWAgaWYgZXZlcnkgZWxlbWVudCBpbiBgY29sbGAgc2F0aXNmaWVzIGFuIGFzeW5jIHRlc3QuIElmIGFueVxuICogaXRlcmF0ZWUgY2FsbCByZXR1cm5zIGBmYWxzZWAsIHRoZSBtYWluIGBjYWxsYmFja2AgaXMgaW1tZWRpYXRlbHkgY2FsbGVkLlxuICpcbiAqIEBuYW1lIGV2ZXJ5XG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbGxlY3Rpb25zXG4gKiBAbWV0aG9kXG4gKiBAYWxpYXMgYWxsXG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxPYmplY3R9IGNvbGwgLSBBIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEFuIGFzeW5jIHRydXRoIHRlc3QgdG8gYXBwbHkgdG8gZWFjaCBpdGVtXG4gKiBpbiB0aGUgY29sbGVjdGlvbiBpbiBwYXJhbGxlbC5cbiAqIFRoZSBpdGVyYXRlZSBtdXN0IGNvbXBsZXRlIHdpdGggYSBib29sZWFuIHJlc3VsdCB2YWx1ZS5cbiAqIEludm9rZWQgd2l0aCAoaXRlbSwgY2FsbGJhY2spLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIGFmdGVyIGFsbCB0aGVcbiAqIGBpdGVyYXRlZWAgZnVuY3Rpb25zIGhhdmUgZmluaXNoZWQuIFJlc3VsdCB3aWxsIGJlIGVpdGhlciBgdHJ1ZWAgb3IgYGZhbHNlYFxuICogZGVwZW5kaW5nIG9uIHRoZSB2YWx1ZXMgb2YgdGhlIGFzeW5jIHRlc3RzLiBJbnZva2VkIHdpdGggKGVyciwgcmVzdWx0KS5cbiAqIEBleGFtcGxlXG4gKlxuICogYXN5bmMuZXZlcnkoWydmaWxlMScsJ2ZpbGUyJywnZmlsZTMnXSwgZnVuY3Rpb24oZmlsZVBhdGgsIGNhbGxiYWNrKSB7XG4gKiAgICAgZnMuYWNjZXNzKGZpbGVQYXRoLCBmdW5jdGlvbihlcnIpIHtcbiAqICAgICAgICAgY2FsbGJhY2sobnVsbCwgIWVycilcbiAqICAgICB9KTtcbiAqIH0sIGZ1bmN0aW9uKGVyciwgcmVzdWx0KSB7XG4gKiAgICAgLy8gaWYgcmVzdWx0IGlzIHRydWUgdGhlbiBldmVyeSBmaWxlIGV4aXN0c1xuICogfSk7XG4gKi9cbnZhciBldmVyeSA9IGRvUGFyYWxsZWwoX2NyZWF0ZVRlc3Rlcihub3RJZCwgbm90SWQpKTtcblxuLyoqXG4gKiBUaGUgc2FtZSBhcyBbYGV2ZXJ5YF17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLmV2ZXJ5fSBidXQgcnVucyBhIG1heGltdW0gb2YgYGxpbWl0YCBhc3luYyBvcGVyYXRpb25zIGF0IGEgdGltZS5cbiAqXG4gKiBAbmFtZSBldmVyeUxpbWl0XG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbGxlY3Rpb25zXG4gKiBAbWV0aG9kXG4gKiBAc2VlIFthc3luYy5ldmVyeV17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLmV2ZXJ5fVxuICogQGFsaWFzIGFsbExpbWl0XG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxPYmplY3R9IGNvbGwgLSBBIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtudW1iZXJ9IGxpbWl0IC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIGFzeW5jIG9wZXJhdGlvbnMgYXQgYSB0aW1lLlxuICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEFuIGFzeW5jIHRydXRoIHRlc3QgdG8gYXBwbHkgdG8gZWFjaCBpdGVtXG4gKiBpbiB0aGUgY29sbGVjdGlvbiBpbiBwYXJhbGxlbC5cbiAqIFRoZSBpdGVyYXRlZSBtdXN0IGNvbXBsZXRlIHdpdGggYSBib29sZWFuIHJlc3VsdCB2YWx1ZS5cbiAqIEludm9rZWQgd2l0aCAoaXRlbSwgY2FsbGJhY2spLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIGFmdGVyIGFsbCB0aGVcbiAqIGBpdGVyYXRlZWAgZnVuY3Rpb25zIGhhdmUgZmluaXNoZWQuIFJlc3VsdCB3aWxsIGJlIGVpdGhlciBgdHJ1ZWAgb3IgYGZhbHNlYFxuICogZGVwZW5kaW5nIG9uIHRoZSB2YWx1ZXMgb2YgdGhlIGFzeW5jIHRlc3RzLiBJbnZva2VkIHdpdGggKGVyciwgcmVzdWx0KS5cbiAqL1xudmFyIGV2ZXJ5TGltaXQgPSBkb1BhcmFsbGVsTGltaXQoX2NyZWF0ZVRlc3Rlcihub3RJZCwgbm90SWQpKTtcblxuLyoqXG4gKiBUaGUgc2FtZSBhcyBbYGV2ZXJ5YF17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLmV2ZXJ5fSBidXQgcnVucyBvbmx5IGEgc2luZ2xlIGFzeW5jIG9wZXJhdGlvbiBhdCBhIHRpbWUuXG4gKlxuICogQG5hbWUgZXZlcnlTZXJpZXNcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29sbGVjdGlvbnNcbiAqIEBtZXRob2RcbiAqIEBzZWUgW2FzeW5jLmV2ZXJ5XXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMuZXZlcnl9XG4gKiBAYWxpYXMgYWxsU2VyaWVzXG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxPYmplY3R9IGNvbGwgLSBBIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEFuIGFzeW5jIHRydXRoIHRlc3QgdG8gYXBwbHkgdG8gZWFjaCBpdGVtXG4gKiBpbiB0aGUgY29sbGVjdGlvbiBpbiBzZXJpZXMuXG4gKiBUaGUgaXRlcmF0ZWUgbXVzdCBjb21wbGV0ZSB3aXRoIGEgYm9vbGVhbiByZXN1bHQgdmFsdWUuXG4gKiBJbnZva2VkIHdpdGggKGl0ZW0sIGNhbGxiYWNrKS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCBhZnRlciBhbGwgdGhlXG4gKiBgaXRlcmF0ZWVgIGZ1bmN0aW9ucyBoYXZlIGZpbmlzaGVkLiBSZXN1bHQgd2lsbCBiZSBlaXRoZXIgYHRydWVgIG9yIGBmYWxzZWBcbiAqIGRlcGVuZGluZyBvbiB0aGUgdmFsdWVzIG9mIHRoZSBhc3luYyB0ZXN0cy4gSW52b2tlZCB3aXRoIChlcnIsIHJlc3VsdCkuXG4gKi9cbnZhciBldmVyeVNlcmllcyA9IGRvTGltaXQoZXZlcnlMaW1pdCwgMSk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucHJvcGVydHlgIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVlcCBwYXRocy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhY2Nlc3NvciBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVByb3BlcnR5KGtleSkge1xuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XG4gIH07XG59XG5cbmZ1bmN0aW9uIGZpbHRlckFycmF5KGVhY2hmbiwgYXJyLCBpdGVyYXRlZSwgY2FsbGJhY2spIHtcbiAgICB2YXIgdHJ1dGhWYWx1ZXMgPSBuZXcgQXJyYXkoYXJyLmxlbmd0aCk7XG4gICAgZWFjaGZuKGFyciwgZnVuY3Rpb24gKHgsIGluZGV4LCBjYWxsYmFjaykge1xuICAgICAgICBpdGVyYXRlZSh4LCBmdW5jdGlvbiAoZXJyLCB2KSB7XG4gICAgICAgICAgICB0cnV0aFZhbHVlc1tpbmRleF0gPSAhIXY7XG4gICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICB9KTtcbiAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHRydXRoVmFsdWVzW2ldKSByZXN1bHRzLnB1c2goYXJyW2ldKTtcbiAgICAgICAgfVxuICAgICAgICBjYWxsYmFjayhudWxsLCByZXN1bHRzKTtcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gZmlsdGVyR2VuZXJpYyhlYWNoZm4sIGNvbGwsIGl0ZXJhdGVlLCBjYWxsYmFjaykge1xuICAgIHZhciByZXN1bHRzID0gW107XG4gICAgZWFjaGZuKGNvbGwsIGZ1bmN0aW9uICh4LCBpbmRleCwgY2FsbGJhY2spIHtcbiAgICAgICAgaXRlcmF0ZWUoeCwgZnVuY3Rpb24gKGVyciwgdikge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh2KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaCh7aW5kZXg6IGluZGV4LCB2YWx1ZTogeH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWxsYmFjayhudWxsLCBhcnJheU1hcChyZXN1bHRzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYS5pbmRleCAtIGIuaW5kZXg7XG4gICAgICAgICAgICB9KSwgYmFzZVByb3BlcnR5KCd2YWx1ZScpKSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gX2ZpbHRlcihlYWNoZm4sIGNvbGwsIGl0ZXJhdGVlLCBjYWxsYmFjaykge1xuICAgIHZhciBmaWx0ZXIgPSBpc0FycmF5TGlrZShjb2xsKSA/IGZpbHRlckFycmF5IDogZmlsdGVyR2VuZXJpYztcbiAgICBmaWx0ZXIoZWFjaGZuLCBjb2xsLCB3cmFwQXN5bmMoaXRlcmF0ZWUpLCBjYWxsYmFjayB8fCBub29wKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgbmV3IGFycmF5IG9mIGFsbCB0aGUgdmFsdWVzIGluIGBjb2xsYCB3aGljaCBwYXNzIGFuIGFzeW5jIHRydXRoXG4gKiB0ZXN0LiBUaGlzIG9wZXJhdGlvbiBpcyBwZXJmb3JtZWQgaW4gcGFyYWxsZWwsIGJ1dCB0aGUgcmVzdWx0cyBhcnJheSB3aWxsIGJlXG4gKiBpbiB0aGUgc2FtZSBvcmRlciBhcyB0aGUgb3JpZ2luYWwuXG4gKlxuICogQG5hbWUgZmlsdGVyXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbGxlY3Rpb25zXG4gKiBAbWV0aG9kXG4gKiBAYWxpYXMgc2VsZWN0XG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxPYmplY3R9IGNvbGwgLSBBIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgLSBBIHRydXRoIHRlc3QgdG8gYXBwbHkgdG8gZWFjaCBpdGVtIGluIGBjb2xsYC5cbiAqIFRoZSBgaXRlcmF0ZWVgIGlzIHBhc3NlZCBhIGBjYWxsYmFjayhlcnIsIHRydXRoVmFsdWUpYCwgd2hpY2ggbXVzdCBiZSBjYWxsZWRcbiAqIHdpdGggYSBib29sZWFuIGFyZ3VtZW50IG9uY2UgaXQgaGFzIGNvbXBsZXRlZC4gSW52b2tlZCB3aXRoIChpdGVtLCBjYWxsYmFjaykuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgYWZ0ZXIgYWxsIHRoZVxuICogYGl0ZXJhdGVlYCBmdW5jdGlvbnMgaGF2ZSBmaW5pc2hlZC4gSW52b2tlZCB3aXRoIChlcnIsIHJlc3VsdHMpLlxuICogQGV4YW1wbGVcbiAqXG4gKiBhc3luYy5maWx0ZXIoWydmaWxlMScsJ2ZpbGUyJywnZmlsZTMnXSwgZnVuY3Rpb24oZmlsZVBhdGgsIGNhbGxiYWNrKSB7XG4gKiAgICAgZnMuYWNjZXNzKGZpbGVQYXRoLCBmdW5jdGlvbihlcnIpIHtcbiAqICAgICAgICAgY2FsbGJhY2sobnVsbCwgIWVycilcbiAqICAgICB9KTtcbiAqIH0sIGZ1bmN0aW9uKGVyciwgcmVzdWx0cykge1xuICogICAgIC8vIHJlc3VsdHMgbm93IGVxdWFscyBhbiBhcnJheSBvZiB0aGUgZXhpc3RpbmcgZmlsZXNcbiAqIH0pO1xuICovXG52YXIgZmlsdGVyID0gZG9QYXJhbGxlbChfZmlsdGVyKTtcblxuLyoqXG4gKiBUaGUgc2FtZSBhcyBbYGZpbHRlcmBde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5maWx0ZXJ9IGJ1dCBydW5zIGEgbWF4aW11bSBvZiBgbGltaXRgIGFzeW5jIG9wZXJhdGlvbnMgYXQgYVxuICogdGltZS5cbiAqXG4gKiBAbmFtZSBmaWx0ZXJMaW1pdFxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpDb2xsZWN0aW9uc1xuICogQG1ldGhvZFxuICogQHNlZSBbYXN5bmMuZmlsdGVyXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMuZmlsdGVyfVxuICogQGFsaWFzIHNlbGVjdExpbWl0XG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxPYmplY3R9IGNvbGwgLSBBIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtudW1iZXJ9IGxpbWl0IC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIGFzeW5jIG9wZXJhdGlvbnMgYXQgYSB0aW1lLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgLSBBIHRydXRoIHRlc3QgdG8gYXBwbHkgdG8gZWFjaCBpdGVtIGluIGBjb2xsYC5cbiAqIFRoZSBgaXRlcmF0ZWVgIGlzIHBhc3NlZCBhIGBjYWxsYmFjayhlcnIsIHRydXRoVmFsdWUpYCwgd2hpY2ggbXVzdCBiZSBjYWxsZWRcbiAqIHdpdGggYSBib29sZWFuIGFyZ3VtZW50IG9uY2UgaXQgaGFzIGNvbXBsZXRlZC4gSW52b2tlZCB3aXRoIChpdGVtLCBjYWxsYmFjaykuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgYWZ0ZXIgYWxsIHRoZVxuICogYGl0ZXJhdGVlYCBmdW5jdGlvbnMgaGF2ZSBmaW5pc2hlZC4gSW52b2tlZCB3aXRoIChlcnIsIHJlc3VsdHMpLlxuICovXG52YXIgZmlsdGVyTGltaXQgPSBkb1BhcmFsbGVsTGltaXQoX2ZpbHRlcik7XG5cbi8qKlxuICogVGhlIHNhbWUgYXMgW2BmaWx0ZXJgXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMuZmlsdGVyfSBidXQgcnVucyBvbmx5IGEgc2luZ2xlIGFzeW5jIG9wZXJhdGlvbiBhdCBhIHRpbWUuXG4gKlxuICogQG5hbWUgZmlsdGVyU2VyaWVzXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbGxlY3Rpb25zXG4gKiBAbWV0aG9kXG4gKiBAc2VlIFthc3luYy5maWx0ZXJde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5maWx0ZXJ9XG4gKiBAYWxpYXMgc2VsZWN0U2VyaWVzXG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxPYmplY3R9IGNvbGwgLSBBIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgLSBBIHRydXRoIHRlc3QgdG8gYXBwbHkgdG8gZWFjaCBpdGVtIGluIGBjb2xsYC5cbiAqIFRoZSBgaXRlcmF0ZWVgIGlzIHBhc3NlZCBhIGBjYWxsYmFjayhlcnIsIHRydXRoVmFsdWUpYCwgd2hpY2ggbXVzdCBiZSBjYWxsZWRcbiAqIHdpdGggYSBib29sZWFuIGFyZ3VtZW50IG9uY2UgaXQgaGFzIGNvbXBsZXRlZC4gSW52b2tlZCB3aXRoIChpdGVtLCBjYWxsYmFjaykuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgYWZ0ZXIgYWxsIHRoZVxuICogYGl0ZXJhdGVlYCBmdW5jdGlvbnMgaGF2ZSBmaW5pc2hlZC4gSW52b2tlZCB3aXRoIChlcnIsIHJlc3VsdHMpXG4gKi9cbnZhciBmaWx0ZXJTZXJpZXMgPSBkb0xpbWl0KGZpbHRlckxpbWl0LCAxKTtcblxuLyoqXG4gKiBDYWxscyB0aGUgYXN5bmNocm9ub3VzIGZ1bmN0aW9uIGBmbmAgd2l0aCBhIGNhbGxiYWNrIHBhcmFtZXRlciB0aGF0IGFsbG93cyBpdFxuICogdG8gY2FsbCBpdHNlbGYgYWdhaW4sIGluIHNlcmllcywgaW5kZWZpbml0ZWx5LlxuXG4gKiBJZiBhbiBlcnJvciBpcyBwYXNzZWQgdG8gdGhlIGNhbGxiYWNrIHRoZW4gYGVycmJhY2tgIGlzIGNhbGxlZCB3aXRoIHRoZVxuICogZXJyb3IsIGFuZCBleGVjdXRpb24gc3RvcHMsIG90aGVyd2lzZSBpdCB3aWxsIG5ldmVyIGJlIGNhbGxlZC5cbiAqXG4gKiBAbmFtZSBmb3JldmVyXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbnRyb2xGbG93XG4gKiBAbWV0aG9kXG4gKiBAY2F0ZWdvcnkgQ29udHJvbCBGbG93XG4gKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGZuIC0gYW4gYXN5bmMgZnVuY3Rpb24gdG8gY2FsbCByZXBlYXRlZGx5LlxuICogSW52b2tlZCB3aXRoIChuZXh0KS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtlcnJiYWNrXSAtIHdoZW4gYGZuYCBwYXNzZXMgYW4gZXJyb3IgdG8gaXQncyBjYWxsYmFjayxcbiAqIHRoaXMgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQsIGFuZCBleGVjdXRpb24gc3RvcHMuIEludm9rZWQgd2l0aCAoZXJyKS5cbiAqIEBleGFtcGxlXG4gKlxuICogYXN5bmMuZm9yZXZlcihcbiAqICAgICBmdW5jdGlvbihuZXh0KSB7XG4gKiAgICAgICAgIC8vIG5leHQgaXMgc3VpdGFibGUgZm9yIHBhc3NpbmcgdG8gdGhpbmdzIHRoYXQgbmVlZCBhIGNhbGxiYWNrKGVyciBbLCB3aGF0ZXZlcl0pO1xuICogICAgICAgICAvLyBpdCB3aWxsIHJlc3VsdCBpbiB0aGlzIGZ1bmN0aW9uIGJlaW5nIGNhbGxlZCBhZ2Fpbi5cbiAqICAgICB9LFxuICogICAgIGZ1bmN0aW9uKGVycikge1xuICogICAgICAgICAvLyBpZiBuZXh0IGlzIGNhbGxlZCB3aXRoIGEgdmFsdWUgaW4gaXRzIGZpcnN0IHBhcmFtZXRlciwgaXQgd2lsbCBhcHBlYXJcbiAqICAgICAgICAgLy8gaW4gaGVyZSBhcyAnZXJyJywgYW5kIGV4ZWN1dGlvbiB3aWxsIHN0b3AuXG4gKiAgICAgfVxuICogKTtcbiAqL1xuZnVuY3Rpb24gZm9yZXZlcihmbiwgZXJyYmFjaykge1xuICAgIHZhciBkb25lID0gb25seU9uY2UoZXJyYmFjayB8fCBub29wKTtcbiAgICB2YXIgdGFzayA9IHdyYXBBc3luYyhlbnN1cmVBc3luYyhmbikpO1xuXG4gICAgZnVuY3Rpb24gbmV4dChlcnIpIHtcbiAgICAgICAgaWYgKGVycikgcmV0dXJuIGRvbmUoZXJyKTtcbiAgICAgICAgdGFzayhuZXh0KTtcbiAgICB9XG4gICAgbmV4dCgpO1xufVxuXG4vKipcbiAqIFRoZSBzYW1lIGFzIFtgZ3JvdXBCeWBde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5ncm91cEJ5fSBidXQgcnVucyBhIG1heGltdW0gb2YgYGxpbWl0YCBhc3luYyBvcGVyYXRpb25zIGF0IGEgdGltZS5cbiAqXG4gKiBAbmFtZSBncm91cEJ5TGltaXRcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29sbGVjdGlvbnNcbiAqIEBtZXRob2RcbiAqIEBzZWUgW2FzeW5jLmdyb3VwQnlde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5ncm91cEJ5fVxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8T2JqZWN0fSBjb2xsIC0gQSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7bnVtYmVyfSBsaW1pdCAtIFRoZSBtYXhpbXVtIG51bWJlciBvZiBhc3luYyBvcGVyYXRpb25zIGF0IGEgdGltZS5cbiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gaXRlcmF0ZWUgLSBBbiBhc3luYyBmdW5jdGlvbiB0byBhcHBseSB0byBlYWNoIGl0ZW0gaW5cbiAqIGBjb2xsYC5cbiAqIFRoZSBpdGVyYXRlZSBzaG91bGQgY29tcGxldGUgd2l0aCBhIGBrZXlgIHRvIGdyb3VwIHRoZSB2YWx1ZSB1bmRlci5cbiAqIEludm9rZWQgd2l0aCAodmFsdWUsIGNhbGxiYWNrKS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCB3aGVuIGFsbCBgaXRlcmF0ZWVgXG4gKiBmdW5jdGlvbnMgaGF2ZSBmaW5pc2hlZCwgb3IgYW4gZXJyb3Igb2NjdXJzLiBSZXN1bHQgaXMgYW4gYE9iamVjdGAgd2hvc2VzXG4gKiBwcm9wZXJ0aWVzIGFyZSBhcnJheXMgb2YgdmFsdWVzIHdoaWNoIHJldHVybmVkIHRoZSBjb3JyZXNwb25kaW5nIGtleS5cbiAqL1xudmFyIGdyb3VwQnlMaW1pdCA9IGZ1bmN0aW9uKGNvbGwsIGxpbWl0LCBpdGVyYXRlZSwgY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjayA9IGNhbGxiYWNrIHx8IG5vb3A7XG4gICAgdmFyIF9pdGVyYXRlZSA9IHdyYXBBc3luYyhpdGVyYXRlZSk7XG4gICAgbWFwTGltaXQoY29sbCwgbGltaXQsIGZ1bmN0aW9uKHZhbCwgY2FsbGJhY2spIHtcbiAgICAgICAgX2l0ZXJhdGVlKHZhbCwgZnVuY3Rpb24oZXJyLCBrZXkpIHtcbiAgICAgICAgICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIHtrZXk6IGtleSwgdmFsOiB2YWx9KTtcbiAgICAgICAgfSk7XG4gICAgfSwgZnVuY3Rpb24oZXJyLCBtYXBSZXN1bHRzKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgICAgLy8gZnJvbSBNRE4sIGhhbmRsZSBvYmplY3QgaGF2aW5nIGFuIGBoYXNPd25Qcm9wZXJ0eWAgcHJvcFxuICAgICAgICB2YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWFwUmVzdWx0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKG1hcFJlc3VsdHNbaV0pIHtcbiAgICAgICAgICAgICAgICB2YXIga2V5ID0gbWFwUmVzdWx0c1tpXS5rZXk7XG4gICAgICAgICAgICAgICAgdmFyIHZhbCA9IG1hcFJlc3VsdHNbaV0udmFsO1xuXG4gICAgICAgICAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwocmVzdWx0LCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtrZXldLnB1c2godmFsKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRba2V5XSA9IFt2YWxdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIsIHJlc3VsdCk7XG4gICAgfSk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYSBuZXcgb2JqZWN0LCB3aGVyZSBlYWNoIHZhbHVlIGNvcnJlc3BvbmRzIHRvIGFuIGFycmF5IG9mIGl0ZW1zLCBmcm9tXG4gKiBgY29sbGAsIHRoYXQgcmV0dXJuZWQgdGhlIGNvcnJlc3BvbmRpbmcga2V5LiBUaGF0IGlzLCB0aGUga2V5cyBvZiB0aGUgb2JqZWN0XG4gKiBjb3JyZXNwb25kIHRvIHRoZSB2YWx1ZXMgcGFzc2VkIHRvIHRoZSBgaXRlcmF0ZWVgIGNhbGxiYWNrLlxuICpcbiAqIE5vdGU6IFNpbmNlIHRoaXMgZnVuY3Rpb24gYXBwbGllcyB0aGUgYGl0ZXJhdGVlYCB0byBlYWNoIGl0ZW0gaW4gcGFyYWxsZWwsXG4gKiB0aGVyZSBpcyBubyBndWFyYW50ZWUgdGhhdCB0aGUgYGl0ZXJhdGVlYCBmdW5jdGlvbnMgd2lsbCBjb21wbGV0ZSBpbiBvcmRlci5cbiAqIEhvd2V2ZXIsIHRoZSB2YWx1ZXMgZm9yIGVhY2gga2V5IGluIHRoZSBgcmVzdWx0YCB3aWxsIGJlIGluIHRoZSBzYW1lIG9yZGVyIGFzXG4gKiB0aGUgb3JpZ2luYWwgYGNvbGxgLiBGb3IgT2JqZWN0cywgdGhlIHZhbHVlcyB3aWxsIHJvdWdobHkgYmUgaW4gdGhlIG9yZGVyIG9mXG4gKiB0aGUgb3JpZ2luYWwgT2JqZWN0cycga2V5cyAoYnV0IHRoaXMgY2FuIHZhcnkgYWNyb3NzIEphdmFTY3JpcHQgZW5naW5lcykuXG4gKlxuICogQG5hbWUgZ3JvdXBCeVxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpDb2xsZWN0aW9uc1xuICogQG1ldGhvZFxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8T2JqZWN0fSBjb2xsIC0gQSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gaXRlcmF0ZWUgLSBBbiBhc3luYyBmdW5jdGlvbiB0byBhcHBseSB0byBlYWNoIGl0ZW0gaW5cbiAqIGBjb2xsYC5cbiAqIFRoZSBpdGVyYXRlZSBzaG91bGQgY29tcGxldGUgd2l0aCBhIGBrZXlgIHRvIGdyb3VwIHRoZSB2YWx1ZSB1bmRlci5cbiAqIEludm9rZWQgd2l0aCAodmFsdWUsIGNhbGxiYWNrKS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCB3aGVuIGFsbCBgaXRlcmF0ZWVgXG4gKiBmdW5jdGlvbnMgaGF2ZSBmaW5pc2hlZCwgb3IgYW4gZXJyb3Igb2NjdXJzLiBSZXN1bHQgaXMgYW4gYE9iamVjdGAgd2hvc2VzXG4gKiBwcm9wZXJ0aWVzIGFyZSBhcnJheXMgb2YgdmFsdWVzIHdoaWNoIHJldHVybmVkIHRoZSBjb3JyZXNwb25kaW5nIGtleS5cbiAqIEBleGFtcGxlXG4gKlxuICogYXN5bmMuZ3JvdXBCeShbJ3VzZXJJZDEnLCAndXNlcklkMicsICd1c2VySWQzJ10sIGZ1bmN0aW9uKHVzZXJJZCwgY2FsbGJhY2spIHtcbiAqICAgICBkYi5maW5kQnlJZCh1c2VySWQsIGZ1bmN0aW9uKGVyciwgdXNlcikge1xuICogICAgICAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAqICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIHVzZXIuYWdlKTtcbiAqICAgICB9KTtcbiAqIH0sIGZ1bmN0aW9uKGVyciwgcmVzdWx0KSB7XG4gKiAgICAgLy8gcmVzdWx0IGlzIG9iamVjdCBjb250YWluaW5nIHRoZSB1c2VySWRzIGdyb3VwZWQgYnkgYWdlXG4gKiAgICAgLy8gZS5nLiB7IDMwOiBbJ3VzZXJJZDEnLCAndXNlcklkMyddLCA0MjogWyd1c2VySWQyJ119O1xuICogfSk7XG4gKi9cbnZhciBncm91cEJ5ID0gZG9MaW1pdChncm91cEJ5TGltaXQsIEluZmluaXR5KTtcblxuLyoqXG4gKiBUaGUgc2FtZSBhcyBbYGdyb3VwQnlgXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMuZ3JvdXBCeX0gYnV0IHJ1bnMgb25seSBhIHNpbmdsZSBhc3luYyBvcGVyYXRpb24gYXQgYSB0aW1lLlxuICpcbiAqIEBuYW1lIGdyb3VwQnlTZXJpZXNcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29sbGVjdGlvbnNcbiAqIEBtZXRob2RcbiAqIEBzZWUgW2FzeW5jLmdyb3VwQnlde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5ncm91cEJ5fVxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8T2JqZWN0fSBjb2xsIC0gQSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7bnVtYmVyfSBsaW1pdCAtIFRoZSBtYXhpbXVtIG51bWJlciBvZiBhc3luYyBvcGVyYXRpb25zIGF0IGEgdGltZS5cbiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gaXRlcmF0ZWUgLSBBbiBhc3luYyBmdW5jdGlvbiB0byBhcHBseSB0byBlYWNoIGl0ZW0gaW5cbiAqIGBjb2xsYC5cbiAqIFRoZSBpdGVyYXRlZSBzaG91bGQgY29tcGxldGUgd2l0aCBhIGBrZXlgIHRvIGdyb3VwIHRoZSB2YWx1ZSB1bmRlci5cbiAqIEludm9rZWQgd2l0aCAodmFsdWUsIGNhbGxiYWNrKS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCB3aGVuIGFsbCBgaXRlcmF0ZWVgXG4gKiBmdW5jdGlvbnMgaGF2ZSBmaW5pc2hlZCwgb3IgYW4gZXJyb3Igb2NjdXJzLiBSZXN1bHQgaXMgYW4gYE9iamVjdGAgd2hvc2VzXG4gKiBwcm9wZXJ0aWVzIGFyZSBhcnJheXMgb2YgdmFsdWVzIHdoaWNoIHJldHVybmVkIHRoZSBjb3JyZXNwb25kaW5nIGtleS5cbiAqL1xudmFyIGdyb3VwQnlTZXJpZXMgPSBkb0xpbWl0KGdyb3VwQnlMaW1pdCwgMSk7XG5cbi8qKlxuICogTG9ncyB0aGUgcmVzdWx0IG9mIGFuIGBhc3luY2AgZnVuY3Rpb24gdG8gdGhlIGBjb25zb2xlYC4gT25seSB3b3JrcyBpblxuICogTm9kZS5qcyBvciBpbiBicm93c2VycyB0aGF0IHN1cHBvcnQgYGNvbnNvbGUubG9nYCBhbmQgYGNvbnNvbGUuZXJyb3JgIChzdWNoXG4gKiBhcyBGRiBhbmQgQ2hyb21lKS4gSWYgbXVsdGlwbGUgYXJndW1lbnRzIGFyZSByZXR1cm5lZCBmcm9tIHRoZSBhc3luY1xuICogZnVuY3Rpb24sIGBjb25zb2xlLmxvZ2AgaXMgY2FsbGVkIG9uIGVhY2ggYXJndW1lbnQgaW4gb3JkZXIuXG4gKlxuICogQG5hbWUgbG9nXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOlV0aWxzXG4gKiBAbWV0aG9kXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBmdW5jdGlvbiAtIFRoZSBmdW5jdGlvbiB5b3Ugd2FudCB0byBldmVudHVhbGx5IGFwcGx5XG4gKiBhbGwgYXJndW1lbnRzIHRvLlxuICogQHBhcmFtIHsuLi4qfSBhcmd1bWVudHMuLi4gLSBBbnkgbnVtYmVyIG9mIGFyZ3VtZW50cyB0byBhcHBseSB0byB0aGUgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIC8vIGluIGEgbW9kdWxlXG4gKiB2YXIgaGVsbG8gPSBmdW5jdGlvbihuYW1lLCBjYWxsYmFjaykge1xuICogICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gKiAgICAgICAgIGNhbGxiYWNrKG51bGwsICdoZWxsbyAnICsgbmFtZSk7XG4gKiAgICAgfSwgMTAwMCk7XG4gKiB9O1xuICpcbiAqIC8vIGluIHRoZSBub2RlIHJlcGxcbiAqIG5vZGU+IGFzeW5jLmxvZyhoZWxsbywgJ3dvcmxkJyk7XG4gKiAnaGVsbG8gd29ybGQnXG4gKi9cbnZhciBsb2cgPSBjb25zb2xlRnVuYygnbG9nJyk7XG5cbi8qKlxuICogVGhlIHNhbWUgYXMgW2BtYXBWYWx1ZXNgXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMubWFwVmFsdWVzfSBidXQgcnVucyBhIG1heGltdW0gb2YgYGxpbWl0YCBhc3luYyBvcGVyYXRpb25zIGF0IGFcbiAqIHRpbWUuXG4gKlxuICogQG5hbWUgbWFwVmFsdWVzTGltaXRcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29sbGVjdGlvbnNcbiAqIEBtZXRob2RcbiAqIEBzZWUgW2FzeW5jLm1hcFZhbHVlc117QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLm1hcFZhbHVlc31cbiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIC0gQSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7bnVtYmVyfSBsaW1pdCAtIFRoZSBtYXhpbXVtIG51bWJlciBvZiBhc3luYyBvcGVyYXRpb25zIGF0IGEgdGltZS5cbiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gaXRlcmF0ZWUgLSBBIGZ1bmN0aW9uIHRvIGFwcGx5IHRvIGVhY2ggdmFsdWUgYW5kIGtleVxuICogaW4gYGNvbGxgLlxuICogVGhlIGl0ZXJhdGVlIHNob3VsZCBjb21wbGV0ZSB3aXRoIHRoZSB0cmFuc2Zvcm1lZCB2YWx1ZSBhcyBpdHMgcmVzdWx0LlxuICogSW52b2tlZCB3aXRoICh2YWx1ZSwga2V5LCBjYWxsYmFjaykuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgd2hlbiBhbGwgYGl0ZXJhdGVlYFxuICogZnVuY3Rpb25zIGhhdmUgZmluaXNoZWQsIG9yIGFuIGVycm9yIG9jY3Vycy4gYHJlc3VsdGAgaXMgYSBuZXcgb2JqZWN0IGNvbnNpc3RpbmdcbiAqIG9mIGVhY2gga2V5IGZyb20gYG9iamAsIHdpdGggZWFjaCB0cmFuc2Zvcm1lZCB2YWx1ZSBvbiB0aGUgcmlnaHQtaGFuZCBzaWRlLlxuICogSW52b2tlZCB3aXRoIChlcnIsIHJlc3VsdCkuXG4gKi9cbmZ1bmN0aW9uIG1hcFZhbHVlc0xpbWl0KG9iaiwgbGltaXQsIGl0ZXJhdGVlLCBjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrID0gb25jZShjYWxsYmFjayB8fCBub29wKTtcbiAgICB2YXIgbmV3T2JqID0ge307XG4gICAgdmFyIF9pdGVyYXRlZSA9IHdyYXBBc3luYyhpdGVyYXRlZSk7XG4gICAgZWFjaE9mTGltaXQob2JqLCBsaW1pdCwgZnVuY3Rpb24odmFsLCBrZXksIG5leHQpIHtcbiAgICAgICAgX2l0ZXJhdGVlKHZhbCwga2V5LCBmdW5jdGlvbiAoZXJyLCByZXN1bHQpIHtcbiAgICAgICAgICAgIGlmIChlcnIpIHJldHVybiBuZXh0KGVycik7XG4gICAgICAgICAgICBuZXdPYmpba2V5XSA9IHJlc3VsdDtcbiAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgfSk7XG4gICAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICBjYWxsYmFjayhlcnIsIG5ld09iaik7XG4gICAgfSk7XG59XG5cbi8qKlxuICogQSByZWxhdGl2ZSBvZiBbYG1hcGBde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5tYXB9LCBkZXNpZ25lZCBmb3IgdXNlIHdpdGggb2JqZWN0cy5cbiAqXG4gKiBQcm9kdWNlcyBhIG5ldyBPYmplY3QgYnkgbWFwcGluZyBlYWNoIHZhbHVlIG9mIGBvYmpgIHRocm91Z2ggdGhlIGBpdGVyYXRlZWBcbiAqIGZ1bmN0aW9uLiBUaGUgYGl0ZXJhdGVlYCBpcyBjYWxsZWQgZWFjaCBgdmFsdWVgIGFuZCBga2V5YCBmcm9tIGBvYmpgIGFuZCBhXG4gKiBjYWxsYmFjayBmb3Igd2hlbiBpdCBoYXMgZmluaXNoZWQgcHJvY2Vzc2luZy4gRWFjaCBvZiB0aGVzZSBjYWxsYmFja3MgdGFrZXNcbiAqIHR3byBhcmd1bWVudHM6IGFuIGBlcnJvcmAsIGFuZCB0aGUgdHJhbnNmb3JtZWQgaXRlbSBmcm9tIGBvYmpgLiBJZiBgaXRlcmF0ZWVgXG4gKiBwYXNzZXMgYW4gZXJyb3IgdG8gaXRzIGNhbGxiYWNrLCB0aGUgbWFpbiBgY2FsbGJhY2tgIChmb3IgdGhlIGBtYXBWYWx1ZXNgXG4gKiBmdW5jdGlvbikgaXMgaW1tZWRpYXRlbHkgY2FsbGVkIHdpdGggdGhlIGVycm9yLlxuICpcbiAqIE5vdGUsIHRoZSBvcmRlciBvZiB0aGUga2V5cyBpbiB0aGUgcmVzdWx0IGlzIG5vdCBndWFyYW50ZWVkLiAgVGhlIGtleXMgd2lsbFxuICogYmUgcm91Z2hseSBpbiB0aGUgb3JkZXIgdGhleSBjb21wbGV0ZSwgKGJ1dCB0aGlzIGlzIHZlcnkgZW5naW5lLXNwZWNpZmljKVxuICpcbiAqIEBuYW1lIG1hcFZhbHVlc1xuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpDb2xsZWN0aW9uc1xuICogQG1ldGhvZFxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogLSBBIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEEgZnVuY3Rpb24gdG8gYXBwbHkgdG8gZWFjaCB2YWx1ZSBhbmQga2V5XG4gKiBpbiBgY29sbGAuXG4gKiBUaGUgaXRlcmF0ZWUgc2hvdWxkIGNvbXBsZXRlIHdpdGggdGhlIHRyYW5zZm9ybWVkIHZhbHVlIGFzIGl0cyByZXN1bHQuXG4gKiBJbnZva2VkIHdpdGggKHZhbHVlLCBrZXksIGNhbGxiYWNrKS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCB3aGVuIGFsbCBgaXRlcmF0ZWVgXG4gKiBmdW5jdGlvbnMgaGF2ZSBmaW5pc2hlZCwgb3IgYW4gZXJyb3Igb2NjdXJzLiBgcmVzdWx0YCBpcyBhIG5ldyBvYmplY3QgY29uc2lzdGluZ1xuICogb2YgZWFjaCBrZXkgZnJvbSBgb2JqYCwgd2l0aCBlYWNoIHRyYW5zZm9ybWVkIHZhbHVlIG9uIHRoZSByaWdodC1oYW5kIHNpZGUuXG4gKiBJbnZva2VkIHdpdGggKGVyciwgcmVzdWx0KS5cbiAqIEBleGFtcGxlXG4gKlxuICogYXN5bmMubWFwVmFsdWVzKHtcbiAqICAgICBmMTogJ2ZpbGUxJyxcbiAqICAgICBmMjogJ2ZpbGUyJyxcbiAqICAgICBmMzogJ2ZpbGUzJ1xuICogfSwgZnVuY3Rpb24gKGZpbGUsIGtleSwgY2FsbGJhY2spIHtcbiAqICAgZnMuc3RhdChmaWxlLCBjYWxsYmFjayk7XG4gKiB9LCBmdW5jdGlvbihlcnIsIHJlc3VsdCkge1xuICogICAgIC8vIHJlc3VsdCBpcyBub3cgYSBtYXAgb2Ygc3RhdHMgZm9yIGVhY2ggZmlsZSwgZS5nLlxuICogICAgIC8vIHtcbiAqICAgICAvLyAgICAgZjE6IFtzdGF0cyBmb3IgZmlsZTFdLFxuICogICAgIC8vICAgICBmMjogW3N0YXRzIGZvciBmaWxlMl0sXG4gKiAgICAgLy8gICAgIGYzOiBbc3RhdHMgZm9yIGZpbGUzXVxuICogICAgIC8vIH1cbiAqIH0pO1xuICovXG5cbnZhciBtYXBWYWx1ZXMgPSBkb0xpbWl0KG1hcFZhbHVlc0xpbWl0LCBJbmZpbml0eSk7XG5cbi8qKlxuICogVGhlIHNhbWUgYXMgW2BtYXBWYWx1ZXNgXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMubWFwVmFsdWVzfSBidXQgcnVucyBvbmx5IGEgc2luZ2xlIGFzeW5jIG9wZXJhdGlvbiBhdCBhIHRpbWUuXG4gKlxuICogQG5hbWUgbWFwVmFsdWVzU2VyaWVzXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbGxlY3Rpb25zXG4gKiBAbWV0aG9kXG4gKiBAc2VlIFthc3luYy5tYXBWYWx1ZXNde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5tYXBWYWx1ZXN9XG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtPYmplY3R9IG9iaiAtIEEgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGl0ZXJhdGVlIC0gQSBmdW5jdGlvbiB0byBhcHBseSB0byBlYWNoIHZhbHVlIGFuZCBrZXlcbiAqIGluIGBjb2xsYC5cbiAqIFRoZSBpdGVyYXRlZSBzaG91bGQgY29tcGxldGUgd2l0aCB0aGUgdHJhbnNmb3JtZWQgdmFsdWUgYXMgaXRzIHJlc3VsdC5cbiAqIEludm9rZWQgd2l0aCAodmFsdWUsIGtleSwgY2FsbGJhY2spLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIHdoZW4gYWxsIGBpdGVyYXRlZWBcbiAqIGZ1bmN0aW9ucyBoYXZlIGZpbmlzaGVkLCBvciBhbiBlcnJvciBvY2N1cnMuIGByZXN1bHRgIGlzIGEgbmV3IG9iamVjdCBjb25zaXN0aW5nXG4gKiBvZiBlYWNoIGtleSBmcm9tIGBvYmpgLCB3aXRoIGVhY2ggdHJhbnNmb3JtZWQgdmFsdWUgb24gdGhlIHJpZ2h0LWhhbmQgc2lkZS5cbiAqIEludm9rZWQgd2l0aCAoZXJyLCByZXN1bHQpLlxuICovXG52YXIgbWFwVmFsdWVzU2VyaWVzID0gZG9MaW1pdChtYXBWYWx1ZXNMaW1pdCwgMSk7XG5cbmZ1bmN0aW9uIGhhcyhvYmosIGtleSkge1xuICAgIHJldHVybiBrZXkgaW4gb2JqO1xufVxuXG4vKipcbiAqIENhY2hlcyB0aGUgcmVzdWx0cyBvZiBhbiBhc3luYyBmdW5jdGlvbi4gV2hlbiBjcmVhdGluZyBhIGhhc2ggdG8gc3RvcmVcbiAqIGZ1bmN0aW9uIHJlc3VsdHMgYWdhaW5zdCwgdGhlIGNhbGxiYWNrIGlzIG9taXR0ZWQgZnJvbSB0aGUgaGFzaCBhbmQgYW5cbiAqIG9wdGlvbmFsIGhhc2ggZnVuY3Rpb24gY2FuIGJlIHVzZWQuXG4gKlxuICogSWYgbm8gaGFzaCBmdW5jdGlvbiBpcyBzcGVjaWZpZWQsIHRoZSBmaXJzdCBhcmd1bWVudCBpcyB1c2VkIGFzIGEgaGFzaCBrZXksXG4gKiB3aGljaCBtYXkgd29yayByZWFzb25hYmx5IGlmIGl0IGlzIGEgc3RyaW5nIG9yIGEgZGF0YSB0eXBlIHRoYXQgY29udmVydHMgdG8gYVxuICogZGlzdGluY3Qgc3RyaW5nLiBOb3RlIHRoYXQgb2JqZWN0cyBhbmQgYXJyYXlzIHdpbGwgbm90IGJlaGF2ZSByZWFzb25hYmx5LlxuICogTmVpdGhlciB3aWxsIGNhc2VzIHdoZXJlIHRoZSBvdGhlciBhcmd1bWVudHMgYXJlIHNpZ25pZmljYW50LiBJbiBzdWNoIGNhc2VzLFxuICogc3BlY2lmeSB5b3VyIG93biBoYXNoIGZ1bmN0aW9uLlxuICpcbiAqIFRoZSBjYWNoZSBvZiByZXN1bHRzIGlzIGV4cG9zZWQgYXMgdGhlIGBtZW1vYCBwcm9wZXJ0eSBvZiB0aGUgZnVuY3Rpb25cbiAqIHJldHVybmVkIGJ5IGBtZW1vaXplYC5cbiAqXG4gKiBAbmFtZSBtZW1vaXplXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOlV0aWxzXG4gKiBAbWV0aG9kXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBmbiAtIFRoZSBhc3luYyBmdW5jdGlvbiB0byBwcm94eSBhbmQgY2FjaGUgcmVzdWx0cyBmcm9tLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaGFzaGVyIC0gQW4gb3B0aW9uYWwgZnVuY3Rpb24gZm9yIGdlbmVyYXRpbmcgYSBjdXN0b20gaGFzaFxuICogZm9yIHN0b3JpbmcgcmVzdWx0cy4gSXQgaGFzIGFsbCB0aGUgYXJndW1lbnRzIGFwcGxpZWQgdG8gaXQgYXBhcnQgZnJvbSB0aGVcbiAqIGNhbGxiYWNrLCBhbmQgbXVzdCBiZSBzeW5jaHJvbm91cy5cbiAqIEByZXR1cm5zIHtBc3luY0Z1bmN0aW9ufSBhIG1lbW9pemVkIHZlcnNpb24gb2YgYGZuYFxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgc2xvd19mbiA9IGZ1bmN0aW9uKG5hbWUsIGNhbGxiYWNrKSB7XG4gKiAgICAgLy8gZG8gc29tZXRoaW5nXG4gKiAgICAgY2FsbGJhY2sobnVsbCwgcmVzdWx0KTtcbiAqIH07XG4gKiB2YXIgZm4gPSBhc3luYy5tZW1vaXplKHNsb3dfZm4pO1xuICpcbiAqIC8vIGZuIGNhbiBub3cgYmUgdXNlZCBhcyBpZiBpdCB3ZXJlIHNsb3dfZm5cbiAqIGZuKCdzb21lIG5hbWUnLCBmdW5jdGlvbigpIHtcbiAqICAgICAvLyBjYWxsYmFja1xuICogfSk7XG4gKi9cbmZ1bmN0aW9uIG1lbW9pemUoZm4sIGhhc2hlcikge1xuICAgIHZhciBtZW1vID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB2YXIgcXVldWVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBoYXNoZXIgPSBoYXNoZXIgfHwgaWRlbnRpdHk7XG4gICAgdmFyIF9mbiA9IHdyYXBBc3luYyhmbik7XG4gICAgdmFyIG1lbW9pemVkID0gaW5pdGlhbFBhcmFtcyhmdW5jdGlvbiBtZW1vaXplZChhcmdzLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIga2V5ID0gaGFzaGVyLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgICBpZiAoaGFzKG1lbW8sIGtleSkpIHtcbiAgICAgICAgICAgIHNldEltbWVkaWF0ZSQxKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KG51bGwsIG1lbW9ba2V5XSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmIChoYXMocXVldWVzLCBrZXkpKSB7XG4gICAgICAgICAgICBxdWV1ZXNba2V5XS5wdXNoKGNhbGxiYWNrKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHF1ZXVlc1trZXldID0gW2NhbGxiYWNrXTtcbiAgICAgICAgICAgIF9mbi5hcHBseShudWxsLCBhcmdzLmNvbmNhdChmdW5jdGlvbigvKmFyZ3MqLykge1xuICAgICAgICAgICAgICAgIHZhciBhcmdzID0gc2xpY2UoYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICBtZW1vW2tleV0gPSBhcmdzO1xuICAgICAgICAgICAgICAgIHZhciBxID0gcXVldWVzW2tleV07XG4gICAgICAgICAgICAgICAgZGVsZXRlIHF1ZXVlc1trZXldO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gcS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgcVtpXS5hcHBseShudWxsLCBhcmdzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBtZW1vaXplZC5tZW1vID0gbWVtbztcbiAgICBtZW1vaXplZC51bm1lbW9pemVkID0gZm47XG4gICAgcmV0dXJuIG1lbW9pemVkO1xufVxuXG4vKipcbiAqIENhbGxzIGBjYWxsYmFja2Agb24gYSBsYXRlciBsb29wIGFyb3VuZCB0aGUgZXZlbnQgbG9vcC4gSW4gTm9kZS5qcyB0aGlzIGp1c3RcbiAqIGNhbGxzIGBwcm9jZXNzLm5leHRUaWNrYC4gIEluIHRoZSBicm93c2VyIGl0IHdpbGwgdXNlIGBzZXRJbW1lZGlhdGVgIGlmXG4gKiBhdmFpbGFibGUsIG90aGVyd2lzZSBgc2V0VGltZW91dChjYWxsYmFjaywgMClgLCB3aGljaCBtZWFucyBvdGhlciBoaWdoZXJcbiAqIHByaW9yaXR5IGV2ZW50cyBtYXkgcHJlY2VkZSB0aGUgZXhlY3V0aW9uIG9mIGBjYWxsYmFja2AuXG4gKlxuICogVGhpcyBpcyB1c2VkIGludGVybmFsbHkgZm9yIGJyb3dzZXItY29tcGF0aWJpbGl0eSBwdXJwb3Nlcy5cbiAqXG4gKiBAbmFtZSBuZXh0VGlja1xuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpVdGlsc1xuICogQG1ldGhvZFxuICogQHNlZSBbYXN5bmMuc2V0SW1tZWRpYXRlXXtAbGluayBtb2R1bGU6VXRpbHMuc2V0SW1tZWRpYXRlfVxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIC0gVGhlIGZ1bmN0aW9uIHRvIGNhbGwgb24gYSBsYXRlciBsb29wIGFyb3VuZFxuICogdGhlIGV2ZW50IGxvb3AuIEludm9rZWQgd2l0aCAoYXJncy4uLikuXG4gKiBAcGFyYW0gey4uLip9IGFyZ3MuLi4gLSBhbnkgbnVtYmVyIG9mIGFkZGl0aW9uYWwgYXJndW1lbnRzIHRvIHBhc3MgdG8gdGhlXG4gKiBjYWxsYmFjayBvbiB0aGUgbmV4dCB0aWNrLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgY2FsbF9vcmRlciA9IFtdO1xuICogYXN5bmMubmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gKiAgICAgY2FsbF9vcmRlci5wdXNoKCd0d28nKTtcbiAqICAgICAvLyBjYWxsX29yZGVyIG5vdyBlcXVhbHMgWydvbmUnLCd0d28nXVxuICogfSk7XG4gKiBjYWxsX29yZGVyLnB1c2goJ29uZScpO1xuICpcbiAqIGFzeW5jLnNldEltbWVkaWF0ZShmdW5jdGlvbiAoYSwgYiwgYykge1xuICogICAgIC8vIGEsIGIsIGFuZCBjIGVxdWFsIDEsIDIsIGFuZCAzXG4gKiB9LCAxLCAyLCAzKTtcbiAqL1xudmFyIF9kZWZlciQxO1xuXG5pZiAoaGFzTmV4dFRpY2spIHtcbiAgICBfZGVmZXIkMSA9IHByb2Nlc3MubmV4dFRpY2s7XG59IGVsc2UgaWYgKGhhc1NldEltbWVkaWF0ZSkge1xuICAgIF9kZWZlciQxID0gc2V0SW1tZWRpYXRlO1xufSBlbHNlIHtcbiAgICBfZGVmZXIkMSA9IGZhbGxiYWNrO1xufVxuXG52YXIgbmV4dFRpY2sgPSB3cmFwKF9kZWZlciQxKTtcblxuZnVuY3Rpb24gX3BhcmFsbGVsKGVhY2hmbiwgdGFza3MsIGNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2sgPSBjYWxsYmFjayB8fCBub29wO1xuICAgIHZhciByZXN1bHRzID0gaXNBcnJheUxpa2UodGFza3MpID8gW10gOiB7fTtcblxuICAgIGVhY2hmbih0YXNrcywgZnVuY3Rpb24gKHRhc2ssIGtleSwgY2FsbGJhY2spIHtcbiAgICAgICAgd3JhcEFzeW5jKHRhc2spKGZ1bmN0aW9uIChlcnIsIHJlc3VsdCkge1xuICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gc2xpY2UoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdHNba2V5XSA9IHJlc3VsdDtcbiAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgIH0pO1xuICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgY2FsbGJhY2soZXJyLCByZXN1bHRzKTtcbiAgICB9KTtcbn1cblxuLyoqXG4gKiBSdW4gdGhlIGB0YXNrc2AgY29sbGVjdGlvbiBvZiBmdW5jdGlvbnMgaW4gcGFyYWxsZWwsIHdpdGhvdXQgd2FpdGluZyB1bnRpbFxuICogdGhlIHByZXZpb3VzIGZ1bmN0aW9uIGhhcyBjb21wbGV0ZWQuIElmIGFueSBvZiB0aGUgZnVuY3Rpb25zIHBhc3MgYW4gZXJyb3IgdG9cbiAqIGl0cyBjYWxsYmFjaywgdGhlIG1haW4gYGNhbGxiYWNrYCBpcyBpbW1lZGlhdGVseSBjYWxsZWQgd2l0aCB0aGUgdmFsdWUgb2YgdGhlXG4gKiBlcnJvci4gT25jZSB0aGUgYHRhc2tzYCBoYXZlIGNvbXBsZXRlZCwgdGhlIHJlc3VsdHMgYXJlIHBhc3NlZCB0byB0aGUgZmluYWxcbiAqIGBjYWxsYmFja2AgYXMgYW4gYXJyYXkuXG4gKlxuICogKipOb3RlOioqIGBwYXJhbGxlbGAgaXMgYWJvdXQga2lja2luZy1vZmYgSS9PIHRhc2tzIGluIHBhcmFsbGVsLCBub3QgYWJvdXRcbiAqIHBhcmFsbGVsIGV4ZWN1dGlvbiBvZiBjb2RlLiAgSWYgeW91ciB0YXNrcyBkbyBub3QgdXNlIGFueSB0aW1lcnMgb3IgcGVyZm9ybVxuICogYW55IEkvTywgdGhleSB3aWxsIGFjdHVhbGx5IGJlIGV4ZWN1dGVkIGluIHNlcmllcy4gIEFueSBzeW5jaHJvbm91cyBzZXR1cFxuICogc2VjdGlvbnMgZm9yIGVhY2ggdGFzayB3aWxsIGhhcHBlbiBvbmUgYWZ0ZXIgdGhlIG90aGVyLiAgSmF2YVNjcmlwdCByZW1haW5zXG4gKiBzaW5nbGUtdGhyZWFkZWQuXG4gKlxuICogKipIaW50OioqIFVzZSBbYHJlZmxlY3RgXXtAbGluayBtb2R1bGU6VXRpbHMucmVmbGVjdH0gdG8gY29udGludWUgdGhlXG4gKiBleGVjdXRpb24gb2Ygb3RoZXIgdGFza3Mgd2hlbiBhIHRhc2sgZmFpbHMuXG4gKlxuICogSXQgaXMgYWxzbyBwb3NzaWJsZSB0byB1c2UgYW4gb2JqZWN0IGluc3RlYWQgb2YgYW4gYXJyYXkuIEVhY2ggcHJvcGVydHkgd2lsbFxuICogYmUgcnVuIGFzIGEgZnVuY3Rpb24gYW5kIHRoZSByZXN1bHRzIHdpbGwgYmUgcGFzc2VkIHRvIHRoZSBmaW5hbCBgY2FsbGJhY2tgXG4gKiBhcyBhbiBvYmplY3QgaW5zdGVhZCBvZiBhbiBhcnJheS4gVGhpcyBjYW4gYmUgYSBtb3JlIHJlYWRhYmxlIHdheSBvZiBoYW5kbGluZ1xuICogcmVzdWx0cyBmcm9tIHtAbGluayBhc3luYy5wYXJhbGxlbH0uXG4gKlxuICogQG5hbWUgcGFyYWxsZWxcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29udHJvbEZsb3dcbiAqIEBtZXRob2RcbiAqIEBjYXRlZ29yeSBDb250cm9sIEZsb3dcbiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8T2JqZWN0fSB0YXNrcyAtIEEgY29sbGVjdGlvbiBvZlxuICogW2FzeW5jIGZ1bmN0aW9uc117QGxpbmsgQXN5bmNGdW5jdGlvbn0gdG8gcnVuLlxuICogRWFjaCBhc3luYyBmdW5jdGlvbiBjYW4gY29tcGxldGUgd2l0aCBhbnkgbnVtYmVyIG9mIG9wdGlvbmFsIGByZXN1bHRgIHZhbHVlcy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBbiBvcHRpb25hbCBjYWxsYmFjayB0byBydW4gb25jZSBhbGwgdGhlXG4gKiBmdW5jdGlvbnMgaGF2ZSBjb21wbGV0ZWQgc3VjY2Vzc2Z1bGx5LiBUaGlzIGZ1bmN0aW9uIGdldHMgYSByZXN1bHRzIGFycmF5XG4gKiAob3Igb2JqZWN0KSBjb250YWluaW5nIGFsbCB0aGUgcmVzdWx0IGFyZ3VtZW50cyBwYXNzZWQgdG8gdGhlIHRhc2sgY2FsbGJhY2tzLlxuICogSW52b2tlZCB3aXRoIChlcnIsIHJlc3VsdHMpLlxuICpcbiAqIEBleGFtcGxlXG4gKiBhc3luYy5wYXJhbGxlbChbXG4gKiAgICAgZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAqICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAqICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsICdvbmUnKTtcbiAqICAgICAgICAgfSwgMjAwKTtcbiAqICAgICB9LFxuICogICAgIGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gKiAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gKiAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCAndHdvJyk7XG4gKiAgICAgICAgIH0sIDEwMCk7XG4gKiAgICAgfVxuICogXSxcbiAqIC8vIG9wdGlvbmFsIGNhbGxiYWNrXG4gKiBmdW5jdGlvbihlcnIsIHJlc3VsdHMpIHtcbiAqICAgICAvLyB0aGUgcmVzdWx0cyBhcnJheSB3aWxsIGVxdWFsIFsnb25lJywndHdvJ10gZXZlbiB0aG91Z2hcbiAqICAgICAvLyB0aGUgc2Vjb25kIGZ1bmN0aW9uIGhhZCBhIHNob3J0ZXIgdGltZW91dC5cbiAqIH0pO1xuICpcbiAqIC8vIGFuIGV4YW1wbGUgdXNpbmcgYW4gb2JqZWN0IGluc3RlYWQgb2YgYW4gYXJyYXlcbiAqIGFzeW5jLnBhcmFsbGVsKHtcbiAqICAgICBvbmU6IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gKiAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gKiAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCAxKTtcbiAqICAgICAgICAgfSwgMjAwKTtcbiAqICAgICB9LFxuICogICAgIHR3bzogZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAqICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAqICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIDIpO1xuICogICAgICAgICB9LCAxMDApO1xuICogICAgIH1cbiAqIH0sIGZ1bmN0aW9uKGVyciwgcmVzdWx0cykge1xuICogICAgIC8vIHJlc3VsdHMgaXMgbm93IGVxdWFscyB0bzoge29uZTogMSwgdHdvOiAyfVxuICogfSk7XG4gKi9cbmZ1bmN0aW9uIHBhcmFsbGVsTGltaXQodGFza3MsIGNhbGxiYWNrKSB7XG4gICAgX3BhcmFsbGVsKGVhY2hPZiwgdGFza3MsIGNhbGxiYWNrKTtcbn1cblxuLyoqXG4gKiBUaGUgc2FtZSBhcyBbYHBhcmFsbGVsYF17QGxpbmsgbW9kdWxlOkNvbnRyb2xGbG93LnBhcmFsbGVsfSBidXQgcnVucyBhIG1heGltdW0gb2YgYGxpbWl0YCBhc3luYyBvcGVyYXRpb25zIGF0IGFcbiAqIHRpbWUuXG4gKlxuICogQG5hbWUgcGFyYWxsZWxMaW1pdFxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpDb250cm9sRmxvd1xuICogQG1ldGhvZFxuICogQHNlZSBbYXN5bmMucGFyYWxsZWxde0BsaW5rIG1vZHVsZTpDb250cm9sRmxvdy5wYXJhbGxlbH1cbiAqIEBjYXRlZ29yeSBDb250cm9sIEZsb3dcbiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8T2JqZWN0fSB0YXNrcyAtIEEgY29sbGVjdGlvbiBvZlxuICogW2FzeW5jIGZ1bmN0aW9uc117QGxpbmsgQXN5bmNGdW5jdGlvbn0gdG8gcnVuLlxuICogRWFjaCBhc3luYyBmdW5jdGlvbiBjYW4gY29tcGxldGUgd2l0aCBhbnkgbnVtYmVyIG9mIG9wdGlvbmFsIGByZXN1bHRgIHZhbHVlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBsaW1pdCAtIFRoZSBtYXhpbXVtIG51bWJlciBvZiBhc3luYyBvcGVyYXRpb25zIGF0IGEgdGltZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBbiBvcHRpb25hbCBjYWxsYmFjayB0byBydW4gb25jZSBhbGwgdGhlXG4gKiBmdW5jdGlvbnMgaGF2ZSBjb21wbGV0ZWQgc3VjY2Vzc2Z1bGx5LiBUaGlzIGZ1bmN0aW9uIGdldHMgYSByZXN1bHRzIGFycmF5XG4gKiAob3Igb2JqZWN0KSBjb250YWluaW5nIGFsbCB0aGUgcmVzdWx0IGFyZ3VtZW50cyBwYXNzZWQgdG8gdGhlIHRhc2sgY2FsbGJhY2tzLlxuICogSW52b2tlZCB3aXRoIChlcnIsIHJlc3VsdHMpLlxuICovXG5mdW5jdGlvbiBwYXJhbGxlbExpbWl0JDEodGFza3MsIGxpbWl0LCBjYWxsYmFjaykge1xuICAgIF9wYXJhbGxlbChfZWFjaE9mTGltaXQobGltaXQpLCB0YXNrcywgY2FsbGJhY2spO1xufVxuXG4vKipcbiAqIEEgcXVldWUgb2YgdGFza3MgZm9yIHRoZSB3b3JrZXIgZnVuY3Rpb24gdG8gY29tcGxldGUuXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBRdWV1ZU9iamVjdFxuICogQG1lbWJlck9mIG1vZHVsZTpDb250cm9sRmxvd1xuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gbGVuZ3RoIC0gYSBmdW5jdGlvbiByZXR1cm5pbmcgdGhlIG51bWJlciBvZiBpdGVtc1xuICogd2FpdGluZyB0byBiZSBwcm9jZXNzZWQuIEludm9rZSB3aXRoIGBxdWV1ZS5sZW5ndGgoKWAuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IHN0YXJ0ZWQgLSBhIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIG9yIG5vdCBhbnlcbiAqIGl0ZW1zIGhhdmUgYmVlbiBwdXNoZWQgYW5kIHByb2Nlc3NlZCBieSB0aGUgcXVldWUuXG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBydW5uaW5nIC0gYSBmdW5jdGlvbiByZXR1cm5pbmcgdGhlIG51bWJlciBvZiBpdGVtc1xuICogY3VycmVudGx5IGJlaW5nIHByb2Nlc3NlZC4gSW52b2tlIHdpdGggYHF1ZXVlLnJ1bm5pbmcoKWAuXG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSB3b3JrZXJzTGlzdCAtIGEgZnVuY3Rpb24gcmV0dXJuaW5nIHRoZSBhcnJheSBvZiBpdGVtc1xuICogY3VycmVudGx5IGJlaW5nIHByb2Nlc3NlZC4gSW52b2tlIHdpdGggYHF1ZXVlLndvcmtlcnNMaXN0KClgLlxuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gaWRsZSAtIGEgZnVuY3Rpb24gcmV0dXJuaW5nIGZhbHNlIGlmIHRoZXJlIGFyZSBpdGVtc1xuICogd2FpdGluZyBvciBiZWluZyBwcm9jZXNzZWQsIG9yIHRydWUgaWYgbm90LiBJbnZva2Ugd2l0aCBgcXVldWUuaWRsZSgpYC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBjb25jdXJyZW5jeSAtIGFuIGludGVnZXIgZm9yIGRldGVybWluaW5nIGhvdyBtYW55IGB3b3JrZXJgXG4gKiBmdW5jdGlvbnMgc2hvdWxkIGJlIHJ1biBpbiBwYXJhbGxlbC4gVGhpcyBwcm9wZXJ0eSBjYW4gYmUgY2hhbmdlZCBhZnRlciBhXG4gKiBgcXVldWVgIGlzIGNyZWF0ZWQgdG8gYWx0ZXIgdGhlIGNvbmN1cnJlbmN5IG9uLXRoZS1mbHkuXG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBwdXNoIC0gYWRkIGEgbmV3IHRhc2sgdG8gdGhlIGBxdWV1ZWAuIENhbGxzIGBjYWxsYmFja2BcbiAqIG9uY2UgdGhlIGB3b3JrZXJgIGhhcyBmaW5pc2hlZCBwcm9jZXNzaW5nIHRoZSB0YXNrLiBJbnN0ZWFkIG9mIGEgc2luZ2xlIHRhc2ssXG4gKiBhIGB0YXNrc2AgYXJyYXkgY2FuIGJlIHN1Ym1pdHRlZC4gVGhlIHJlc3BlY3RpdmUgY2FsbGJhY2sgaXMgdXNlZCBmb3IgZXZlcnlcbiAqIHRhc2sgaW4gdGhlIGxpc3QuIEludm9rZSB3aXRoIGBxdWV1ZS5wdXNoKHRhc2ssIFtjYWxsYmFja10pYCxcbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IHVuc2hpZnQgLSBhZGQgYSBuZXcgdGFzayB0byB0aGUgZnJvbnQgb2YgdGhlIGBxdWV1ZWAuXG4gKiBJbnZva2Ugd2l0aCBgcXVldWUudW5zaGlmdCh0YXNrLCBbY2FsbGJhY2tdKWAuXG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSByZW1vdmUgLSByZW1vdmUgaXRlbXMgZnJvbSB0aGUgcXVldWUgdGhhdCBtYXRjaCBhIHRlc3RcbiAqIGZ1bmN0aW9uLiAgVGhlIHRlc3QgZnVuY3Rpb24gd2lsbCBiZSBwYXNzZWQgYW4gb2JqZWN0IHdpdGggYSBgZGF0YWAgcHJvcGVydHksXG4gKiBhbmQgYSBgcHJpb3JpdHlgIHByb3BlcnR5LCBpZiB0aGlzIGlzIGFcbiAqIFtwcmlvcml0eVF1ZXVlXXtAbGluayBtb2R1bGU6Q29udHJvbEZsb3cucHJpb3JpdHlRdWV1ZX0gb2JqZWN0LlxuICogSW52b2tlZCB3aXRoIGBxdWV1ZS5yZW1vdmUodGVzdEZuKWAsIHdoZXJlIGB0ZXN0Rm5gIGlzIG9mIHRoZSBmb3JtXG4gKiBgZnVuY3Rpb24gKHtkYXRhLCBwcmlvcml0eX0pIHt9YCBhbmQgcmV0dXJucyBhIEJvb2xlYW4uXG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBzYXR1cmF0ZWQgLSBhIGNhbGxiYWNrIHRoYXQgaXMgY2FsbGVkIHdoZW4gdGhlIG51bWJlciBvZlxuICogcnVubmluZyB3b3JrZXJzIGhpdHMgdGhlIGBjb25jdXJyZW5jeWAgbGltaXQsIGFuZCBmdXJ0aGVyIHRhc2tzIHdpbGwgYmVcbiAqIHF1ZXVlZC5cbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IHVuc2F0dXJhdGVkIC0gYSBjYWxsYmFjayB0aGF0IGlzIGNhbGxlZCB3aGVuIHRoZSBudW1iZXJcbiAqIG9mIHJ1bm5pbmcgd29ya2VycyBpcyBsZXNzIHRoYW4gdGhlIGBjb25jdXJyZW5jeWAgJiBgYnVmZmVyYCBsaW1pdHMsIGFuZFxuICogZnVydGhlciB0YXNrcyB3aWxsIG5vdCBiZSBxdWV1ZWQuXG4gKiBAcHJvcGVydHkge251bWJlcn0gYnVmZmVyIC0gQSBtaW5pbXVtIHRocmVzaG9sZCBidWZmZXIgaW4gb3JkZXIgdG8gc2F5IHRoYXRcbiAqIHRoZSBgcXVldWVgIGlzIGB1bnNhdHVyYXRlZGAuXG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBlbXB0eSAtIGEgY2FsbGJhY2sgdGhhdCBpcyBjYWxsZWQgd2hlbiB0aGUgbGFzdCBpdGVtXG4gKiBmcm9tIHRoZSBgcXVldWVgIGlzIGdpdmVuIHRvIGEgYHdvcmtlcmAuXG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBkcmFpbiAtIGEgY2FsbGJhY2sgdGhhdCBpcyBjYWxsZWQgd2hlbiB0aGUgbGFzdCBpdGVtXG4gKiBmcm9tIHRoZSBgcXVldWVgIGhhcyByZXR1cm5lZCBmcm9tIHRoZSBgd29ya2VyYC5cbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IGVycm9yIC0gYSBjYWxsYmFjayB0aGF0IGlzIGNhbGxlZCB3aGVuIGEgdGFzayBlcnJvcnMuXG4gKiBIYXMgdGhlIHNpZ25hdHVyZSBgZnVuY3Rpb24oZXJyb3IsIHRhc2spYC5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gcGF1c2VkIC0gYSBib29sZWFuIGZvciBkZXRlcm1pbmluZyB3aGV0aGVyIHRoZSBxdWV1ZSBpc1xuICogaW4gYSBwYXVzZWQgc3RhdGUuXG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBwYXVzZSAtIGEgZnVuY3Rpb24gdGhhdCBwYXVzZXMgdGhlIHByb2Nlc3Npbmcgb2YgdGFza3NcbiAqIHVudGlsIGByZXN1bWUoKWAgaXMgY2FsbGVkLiBJbnZva2Ugd2l0aCBgcXVldWUucGF1c2UoKWAuXG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSByZXN1bWUgLSBhIGZ1bmN0aW9uIHRoYXQgcmVzdW1lcyB0aGUgcHJvY2Vzc2luZyBvZlxuICogcXVldWVkIHRhc2tzIHdoZW4gdGhlIHF1ZXVlIGlzIHBhdXNlZC4gSW52b2tlIHdpdGggYHF1ZXVlLnJlc3VtZSgpYC5cbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IGtpbGwgLSBhIGZ1bmN0aW9uIHRoYXQgcmVtb3ZlcyB0aGUgYGRyYWluYCBjYWxsYmFjayBhbmRcbiAqIGVtcHRpZXMgcmVtYWluaW5nIHRhc2tzIGZyb20gdGhlIHF1ZXVlIGZvcmNpbmcgaXQgdG8gZ28gaWRsZS4gTm8gbW9yZSB0YXNrc1xuICogc2hvdWxkIGJlIHB1c2hlZCB0byB0aGUgcXVldWUgYWZ0ZXIgY2FsbGluZyB0aGlzIGZ1bmN0aW9uLiBJbnZva2Ugd2l0aCBgcXVldWUua2lsbCgpYC5cbiAqL1xuXG4vKipcbiAqIENyZWF0ZXMgYSBgcXVldWVgIG9iamVjdCB3aXRoIHRoZSBzcGVjaWZpZWQgYGNvbmN1cnJlbmN5YC4gVGFza3MgYWRkZWQgdG8gdGhlXG4gKiBgcXVldWVgIGFyZSBwcm9jZXNzZWQgaW4gcGFyYWxsZWwgKHVwIHRvIHRoZSBgY29uY3VycmVuY3lgIGxpbWl0KS4gSWYgYWxsXG4gKiBgd29ya2VyYHMgYXJlIGluIHByb2dyZXNzLCB0aGUgdGFzayBpcyBxdWV1ZWQgdW50aWwgb25lIGJlY29tZXMgYXZhaWxhYmxlLlxuICogT25jZSBhIGB3b3JrZXJgIGNvbXBsZXRlcyBhIGB0YXNrYCwgdGhhdCBgdGFza2AncyBjYWxsYmFjayBpcyBjYWxsZWQuXG4gKlxuICogQG5hbWUgcXVldWVcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29udHJvbEZsb3dcbiAqIEBtZXRob2RcbiAqIEBjYXRlZ29yeSBDb250cm9sIEZsb3dcbiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gd29ya2VyIC0gQW4gYXN5bmMgZnVuY3Rpb24gZm9yIHByb2Nlc3NpbmcgYSBxdWV1ZWQgdGFzay5cbiAqIElmIHlvdSB3YW50IHRvIGhhbmRsZSBlcnJvcnMgZnJvbSBhbiBpbmRpdmlkdWFsIHRhc2ssIHBhc3MgYSBjYWxsYmFjayB0b1xuICogYHEucHVzaCgpYC4gSW52b2tlZCB3aXRoICh0YXNrLCBjYWxsYmFjaykuXG4gKiBAcGFyYW0ge251bWJlcn0gW2NvbmN1cnJlbmN5PTFdIC0gQW4gYGludGVnZXJgIGZvciBkZXRlcm1pbmluZyBob3cgbWFueVxuICogYHdvcmtlcmAgZnVuY3Rpb25zIHNob3VsZCBiZSBydW4gaW4gcGFyYWxsZWwuICBJZiBvbWl0dGVkLCB0aGUgY29uY3VycmVuY3lcbiAqIGRlZmF1bHRzIHRvIGAxYC4gIElmIHRoZSBjb25jdXJyZW5jeSBpcyBgMGAsIGFuIGVycm9yIGlzIHRocm93bi5cbiAqIEByZXR1cm5zIHttb2R1bGU6Q29udHJvbEZsb3cuUXVldWVPYmplY3R9IEEgcXVldWUgb2JqZWN0IHRvIG1hbmFnZSB0aGUgdGFza3MuIENhbGxiYWNrcyBjYW5cbiAqIGF0dGFjaGVkIGFzIGNlcnRhaW4gcHJvcGVydGllcyB0byBsaXN0ZW4gZm9yIHNwZWNpZmljIGV2ZW50cyBkdXJpbmcgdGhlXG4gKiBsaWZlY3ljbGUgb2YgdGhlIHF1ZXVlLlxuICogQGV4YW1wbGVcbiAqXG4gKiAvLyBjcmVhdGUgYSBxdWV1ZSBvYmplY3Qgd2l0aCBjb25jdXJyZW5jeSAyXG4gKiB2YXIgcSA9IGFzeW5jLnF1ZXVlKGZ1bmN0aW9uKHRhc2ssIGNhbGxiYWNrKSB7XG4gKiAgICAgY29uc29sZS5sb2coJ2hlbGxvICcgKyB0YXNrLm5hbWUpO1xuICogICAgIGNhbGxiYWNrKCk7XG4gKiB9LCAyKTtcbiAqXG4gKiAvLyBhc3NpZ24gYSBjYWxsYmFja1xuICogcS5kcmFpbiA9IGZ1bmN0aW9uKCkge1xuICogICAgIGNvbnNvbGUubG9nKCdhbGwgaXRlbXMgaGF2ZSBiZWVuIHByb2Nlc3NlZCcpO1xuICogfTtcbiAqXG4gKiAvLyBhZGQgc29tZSBpdGVtcyB0byB0aGUgcXVldWVcbiAqIHEucHVzaCh7bmFtZTogJ2Zvbyd9LCBmdW5jdGlvbihlcnIpIHtcbiAqICAgICBjb25zb2xlLmxvZygnZmluaXNoZWQgcHJvY2Vzc2luZyBmb28nKTtcbiAqIH0pO1xuICogcS5wdXNoKHtuYW1lOiAnYmFyJ30sIGZ1bmN0aW9uIChlcnIpIHtcbiAqICAgICBjb25zb2xlLmxvZygnZmluaXNoZWQgcHJvY2Vzc2luZyBiYXInKTtcbiAqIH0pO1xuICpcbiAqIC8vIGFkZCBzb21lIGl0ZW1zIHRvIHRoZSBxdWV1ZSAoYmF0Y2gtd2lzZSlcbiAqIHEucHVzaChbe25hbWU6ICdiYXonfSx7bmFtZTogJ2JheSd9LHtuYW1lOiAnYmF4J31dLCBmdW5jdGlvbihlcnIpIHtcbiAqICAgICBjb25zb2xlLmxvZygnZmluaXNoZWQgcHJvY2Vzc2luZyBpdGVtJyk7XG4gKiB9KTtcbiAqXG4gKiAvLyBhZGQgc29tZSBpdGVtcyB0byB0aGUgZnJvbnQgb2YgdGhlIHF1ZXVlXG4gKiBxLnVuc2hpZnQoe25hbWU6ICdiYXInfSwgZnVuY3Rpb24gKGVycikge1xuICogICAgIGNvbnNvbGUubG9nKCdmaW5pc2hlZCBwcm9jZXNzaW5nIGJhcicpO1xuICogfSk7XG4gKi9cbnZhciBxdWV1ZSQxID0gZnVuY3Rpb24gKHdvcmtlciwgY29uY3VycmVuY3kpIHtcbiAgICB2YXIgX3dvcmtlciA9IHdyYXBBc3luYyh3b3JrZXIpO1xuICAgIHJldHVybiBxdWV1ZShmdW5jdGlvbiAoaXRlbXMsIGNiKSB7XG4gICAgICAgIF93b3JrZXIoaXRlbXNbMF0sIGNiKTtcbiAgICB9LCBjb25jdXJyZW5jeSwgMSk7XG59O1xuXG4vKipcbiAqIFRoZSBzYW1lIGFzIFthc3luYy5xdWV1ZV17QGxpbmsgbW9kdWxlOkNvbnRyb2xGbG93LnF1ZXVlfSBvbmx5IHRhc2tzIGFyZSBhc3NpZ25lZCBhIHByaW9yaXR5IGFuZFxuICogY29tcGxldGVkIGluIGFzY2VuZGluZyBwcmlvcml0eSBvcmRlci5cbiAqXG4gKiBAbmFtZSBwcmlvcml0eVF1ZXVlXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbnRyb2xGbG93XG4gKiBAbWV0aG9kXG4gKiBAc2VlIFthc3luYy5xdWV1ZV17QGxpbmsgbW9kdWxlOkNvbnRyb2xGbG93LnF1ZXVlfVxuICogQGNhdGVnb3J5IENvbnRyb2wgRmxvd1xuICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSB3b3JrZXIgLSBBbiBhc3luYyBmdW5jdGlvbiBmb3IgcHJvY2Vzc2luZyBhIHF1ZXVlZCB0YXNrLlxuICogSWYgeW91IHdhbnQgdG8gaGFuZGxlIGVycm9ycyBmcm9tIGFuIGluZGl2aWR1YWwgdGFzaywgcGFzcyBhIGNhbGxiYWNrIHRvXG4gKiBgcS5wdXNoKClgLlxuICogSW52b2tlZCB3aXRoICh0YXNrLCBjYWxsYmFjaykuXG4gKiBAcGFyYW0ge251bWJlcn0gY29uY3VycmVuY3kgLSBBbiBgaW50ZWdlcmAgZm9yIGRldGVybWluaW5nIGhvdyBtYW55IGB3b3JrZXJgXG4gKiBmdW5jdGlvbnMgc2hvdWxkIGJlIHJ1biBpbiBwYXJhbGxlbC4gIElmIG9taXR0ZWQsIHRoZSBjb25jdXJyZW5jeSBkZWZhdWx0cyB0b1xuICogYDFgLiAgSWYgdGhlIGNvbmN1cnJlbmN5IGlzIGAwYCwgYW4gZXJyb3IgaXMgdGhyb3duLlxuICogQHJldHVybnMge21vZHVsZTpDb250cm9sRmxvdy5RdWV1ZU9iamVjdH0gQSBwcmlvcml0eVF1ZXVlIG9iamVjdCB0byBtYW5hZ2UgdGhlIHRhc2tzLiBUaGVyZSBhcmUgdHdvXG4gKiBkaWZmZXJlbmNlcyBiZXR3ZWVuIGBxdWV1ZWAgYW5kIGBwcmlvcml0eVF1ZXVlYCBvYmplY3RzOlxuICogKiBgcHVzaCh0YXNrLCBwcmlvcml0eSwgW2NhbGxiYWNrXSlgIC0gYHByaW9yaXR5YCBzaG91bGQgYmUgYSBudW1iZXIuIElmIGFuXG4gKiAgIGFycmF5IG9mIGB0YXNrc2AgaXMgZ2l2ZW4sIGFsbCB0YXNrcyB3aWxsIGJlIGFzc2lnbmVkIHRoZSBzYW1lIHByaW9yaXR5LlxuICogKiBUaGUgYHVuc2hpZnRgIG1ldGhvZCB3YXMgcmVtb3ZlZC5cbiAqL1xudmFyIHByaW9yaXR5UXVldWUgPSBmdW5jdGlvbih3b3JrZXIsIGNvbmN1cnJlbmN5KSB7XG4gICAgLy8gU3RhcnQgd2l0aCBhIG5vcm1hbCBxdWV1ZVxuICAgIHZhciBxID0gcXVldWUkMSh3b3JrZXIsIGNvbmN1cnJlbmN5KTtcblxuICAgIC8vIE92ZXJyaWRlIHB1c2ggdG8gYWNjZXB0IHNlY29uZCBwYXJhbWV0ZXIgcmVwcmVzZW50aW5nIHByaW9yaXR5XG4gICAgcS5wdXNoID0gZnVuY3Rpb24oZGF0YSwgcHJpb3JpdHksIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmIChjYWxsYmFjayA9PSBudWxsKSBjYWxsYmFjayA9IG5vb3A7XG4gICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndGFzayBjYWxsYmFjayBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICAgICAgfVxuICAgICAgICBxLnN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICBpZiAoIWlzQXJyYXkoZGF0YSkpIHtcbiAgICAgICAgICAgIGRhdGEgPSBbZGF0YV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAvLyBjYWxsIGRyYWluIGltbWVkaWF0ZWx5IGlmIHRoZXJlIGFyZSBubyB0YXNrc1xuICAgICAgICAgICAgcmV0dXJuIHNldEltbWVkaWF0ZSQxKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHEuZHJhaW4oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcHJpb3JpdHkgPSBwcmlvcml0eSB8fCAwO1xuICAgICAgICB2YXIgbmV4dE5vZGUgPSBxLl90YXNrcy5oZWFkO1xuICAgICAgICB3aGlsZSAobmV4dE5vZGUgJiYgcHJpb3JpdHkgPj0gbmV4dE5vZGUucHJpb3JpdHkpIHtcbiAgICAgICAgICAgIG5leHROb2RlID0gbmV4dE5vZGUubmV4dDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gZGF0YS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBpdGVtID0ge1xuICAgICAgICAgICAgICAgIGRhdGE6IGRhdGFbaV0sXG4gICAgICAgICAgICAgICAgcHJpb3JpdHk6IHByaW9yaXR5LFxuICAgICAgICAgICAgICAgIGNhbGxiYWNrOiBjYWxsYmFja1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaWYgKG5leHROb2RlKSB7XG4gICAgICAgICAgICAgICAgcS5fdGFza3MuaW5zZXJ0QmVmb3JlKG5leHROb2RlLCBpdGVtKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcS5fdGFza3MucHVzaChpdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzZXRJbW1lZGlhdGUkMShxLnByb2Nlc3MpO1xuICAgIH07XG5cbiAgICAvLyBSZW1vdmUgdW5zaGlmdCBmdW5jdGlvblxuICAgIGRlbGV0ZSBxLnVuc2hpZnQ7XG5cbiAgICByZXR1cm4gcTtcbn07XG5cbi8qKlxuICogUnVucyB0aGUgYHRhc2tzYCBhcnJheSBvZiBmdW5jdGlvbnMgaW4gcGFyYWxsZWwsIHdpdGhvdXQgd2FpdGluZyB1bnRpbCB0aGVcbiAqIHByZXZpb3VzIGZ1bmN0aW9uIGhhcyBjb21wbGV0ZWQuIE9uY2UgYW55IG9mIHRoZSBgdGFza3NgIGNvbXBsZXRlIG9yIHBhc3MgYW5cbiAqIGVycm9yIHRvIGl0cyBjYWxsYmFjaywgdGhlIG1haW4gYGNhbGxiYWNrYCBpcyBpbW1lZGlhdGVseSBjYWxsZWQuIEl0J3NcbiAqIGVxdWl2YWxlbnQgdG8gYFByb21pc2UucmFjZSgpYC5cbiAqXG4gKiBAbmFtZSByYWNlXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbnRyb2xGbG93XG4gKiBAbWV0aG9kXG4gKiBAY2F0ZWdvcnkgQ29udHJvbCBGbG93XG4gKiBAcGFyYW0ge0FycmF5fSB0YXNrcyAtIEFuIGFycmF5IGNvbnRhaW5pbmcgW2FzeW5jIGZ1bmN0aW9uc117QGxpbmsgQXN5bmNGdW5jdGlvbn1cbiAqIHRvIHJ1bi4gRWFjaCBmdW5jdGlvbiBjYW4gY29tcGxldGUgd2l0aCBhbiBvcHRpb25hbCBgcmVzdWx0YCB2YWx1ZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIC0gQSBjYWxsYmFjayB0byBydW4gb25jZSBhbnkgb2YgdGhlIGZ1bmN0aW9ucyBoYXZlXG4gKiBjb21wbGV0ZWQuIFRoaXMgZnVuY3Rpb24gZ2V0cyBhbiBlcnJvciBvciByZXN1bHQgZnJvbSB0aGUgZmlyc3QgZnVuY3Rpb24gdGhhdFxuICogY29tcGxldGVkLiBJbnZva2VkIHdpdGggKGVyciwgcmVzdWx0KS5cbiAqIEByZXR1cm5zIHVuZGVmaW5lZFxuICogQGV4YW1wbGVcbiAqXG4gKiBhc3luYy5yYWNlKFtcbiAqICAgICBmdW5jdGlvbihjYWxsYmFjaykge1xuICogICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICogICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgJ29uZScpO1xuICogICAgICAgICB9LCAyMDApO1xuICogICAgIH0sXG4gKiAgICAgZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAqICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAqICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsICd0d28nKTtcbiAqICAgICAgICAgfSwgMTAwKTtcbiAqICAgICB9XG4gKiBdLFxuICogLy8gbWFpbiBjYWxsYmFja1xuICogZnVuY3Rpb24oZXJyLCByZXN1bHQpIHtcbiAqICAgICAvLyB0aGUgcmVzdWx0IHdpbGwgYmUgZXF1YWwgdG8gJ3R3bycgYXMgaXQgZmluaXNoZXMgZWFybGllclxuICogfSk7XG4gKi9cbmZ1bmN0aW9uIHJhY2UodGFza3MsIGNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2sgPSBvbmNlKGNhbGxiYWNrIHx8IG5vb3ApO1xuICAgIGlmICghaXNBcnJheSh0YXNrcykpIHJldHVybiBjYWxsYmFjayhuZXcgVHlwZUVycm9yKCdGaXJzdCBhcmd1bWVudCB0byByYWNlIG11c3QgYmUgYW4gYXJyYXkgb2YgZnVuY3Rpb25zJykpO1xuICAgIGlmICghdGFza3MubGVuZ3RoKSByZXR1cm4gY2FsbGJhY2soKTtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IHRhc2tzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB3cmFwQXN5bmModGFza3NbaV0pKGNhbGxiYWNrKTtcbiAgICB9XG59XG5cbi8qKlxuICogU2FtZSBhcyBbYHJlZHVjZWBde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5yZWR1Y2V9LCBvbmx5IG9wZXJhdGVzIG9uIGBhcnJheWAgaW4gcmV2ZXJzZSBvcmRlci5cbiAqXG4gKiBAbmFtZSByZWR1Y2VSaWdodFxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpDb2xsZWN0aW9uc1xuICogQG1ldGhvZFxuICogQHNlZSBbYXN5bmMucmVkdWNlXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMucmVkdWNlfVxuICogQGFsaWFzIGZvbGRyXG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgLSBBIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHsqfSBtZW1vIC0gVGhlIGluaXRpYWwgc3RhdGUgb2YgdGhlIHJlZHVjdGlvbi5cbiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gaXRlcmF0ZWUgLSBBIGZ1bmN0aW9uIGFwcGxpZWQgdG8gZWFjaCBpdGVtIGluIHRoZVxuICogYXJyYXkgdG8gcHJvZHVjZSB0aGUgbmV4dCBzdGVwIGluIHRoZSByZWR1Y3Rpb24uXG4gKiBUaGUgYGl0ZXJhdGVlYCBzaG91bGQgY29tcGxldGUgd2l0aCB0aGUgbmV4dCBzdGF0ZSBvZiB0aGUgcmVkdWN0aW9uLlxuICogSWYgdGhlIGl0ZXJhdGVlIGNvbXBsZXRlIHdpdGggYW4gZXJyb3IsIHRoZSByZWR1Y3Rpb24gaXMgc3RvcHBlZCBhbmQgdGhlXG4gKiBtYWluIGBjYWxsYmFja2AgaXMgaW1tZWRpYXRlbHkgY2FsbGVkIHdpdGggdGhlIGVycm9yLlxuICogSW52b2tlZCB3aXRoIChtZW1vLCBpdGVtLCBjYWxsYmFjaykuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgYWZ0ZXIgYWxsIHRoZVxuICogYGl0ZXJhdGVlYCBmdW5jdGlvbnMgaGF2ZSBmaW5pc2hlZC4gUmVzdWx0IGlzIHRoZSByZWR1Y2VkIHZhbHVlLiBJbnZva2VkIHdpdGhcbiAqIChlcnIsIHJlc3VsdCkuXG4gKi9cbmZ1bmN0aW9uIHJlZHVjZVJpZ2h0IChhcnJheSwgbWVtbywgaXRlcmF0ZWUsIGNhbGxiYWNrKSB7XG4gICAgdmFyIHJldmVyc2VkID0gc2xpY2UoYXJyYXkpLnJldmVyc2UoKTtcbiAgICByZWR1Y2UocmV2ZXJzZWQsIG1lbW8sIGl0ZXJhdGVlLCBjYWxsYmFjayk7XG59XG5cbi8qKlxuICogV3JhcHMgdGhlIGFzeW5jIGZ1bmN0aW9uIGluIGFub3RoZXIgZnVuY3Rpb24gdGhhdCBhbHdheXMgY29tcGxldGVzIHdpdGggYVxuICogcmVzdWx0IG9iamVjdCwgZXZlbiB3aGVuIGl0IGVycm9ycy5cbiAqXG4gKiBUaGUgcmVzdWx0IG9iamVjdCBoYXMgZWl0aGVyIHRoZSBwcm9wZXJ0eSBgZXJyb3JgIG9yIGB2YWx1ZWAuXG4gKlxuICogQG5hbWUgcmVmbGVjdFxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpVdGlsc1xuICogQG1ldGhvZFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gZm4gLSBUaGUgYXN5bmMgZnVuY3Rpb24geW91IHdhbnQgdG8gd3JhcFxuICogQHJldHVybnMge0Z1bmN0aW9ufSAtIEEgZnVuY3Rpb24gdGhhdCBhbHdheXMgcGFzc2VzIG51bGwgdG8gaXQncyBjYWxsYmFjayBhc1xuICogdGhlIGVycm9yLiBUaGUgc2Vjb25kIGFyZ3VtZW50IHRvIHRoZSBjYWxsYmFjayB3aWxsIGJlIGFuIGBvYmplY3RgIHdpdGhcbiAqIGVpdGhlciBhbiBgZXJyb3JgIG9yIGEgYHZhbHVlYCBwcm9wZXJ0eS5cbiAqIEBleGFtcGxlXG4gKlxuICogYXN5bmMucGFyYWxsZWwoW1xuICogICAgIGFzeW5jLnJlZmxlY3QoZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAqICAgICAgICAgLy8gZG8gc29tZSBzdHVmZiAuLi5cbiAqICAgICAgICAgY2FsbGJhY2sobnVsbCwgJ29uZScpO1xuICogICAgIH0pLFxuICogICAgIGFzeW5jLnJlZmxlY3QoZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAqICAgICAgICAgLy8gZG8gc29tZSBtb3JlIHN0dWZmIGJ1dCBlcnJvciAuLi5cbiAqICAgICAgICAgY2FsbGJhY2soJ2JhZCBzdHVmZiBoYXBwZW5lZCcpO1xuICogICAgIH0pLFxuICogICAgIGFzeW5jLnJlZmxlY3QoZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAqICAgICAgICAgLy8gZG8gc29tZSBtb3JlIHN0dWZmIC4uLlxuICogICAgICAgICBjYWxsYmFjayhudWxsLCAndHdvJyk7XG4gKiAgICAgfSlcbiAqIF0sXG4gKiAvLyBvcHRpb25hbCBjYWxsYmFja1xuICogZnVuY3Rpb24oZXJyLCByZXN1bHRzKSB7XG4gKiAgICAgLy8gdmFsdWVzXG4gKiAgICAgLy8gcmVzdWx0c1swXS52YWx1ZSA9ICdvbmUnXG4gKiAgICAgLy8gcmVzdWx0c1sxXS5lcnJvciA9ICdiYWQgc3R1ZmYgaGFwcGVuZWQnXG4gKiAgICAgLy8gcmVzdWx0c1syXS52YWx1ZSA9ICd0d28nXG4gKiB9KTtcbiAqL1xuZnVuY3Rpb24gcmVmbGVjdChmbikge1xuICAgIHZhciBfZm4gPSB3cmFwQXN5bmMoZm4pO1xuICAgIHJldHVybiBpbml0aWFsUGFyYW1zKGZ1bmN0aW9uIHJlZmxlY3RPbihhcmdzLCByZWZsZWN0Q2FsbGJhY2spIHtcbiAgICAgICAgYXJncy5wdXNoKGZ1bmN0aW9uIGNhbGxiYWNrKGVycm9yLCBjYkFyZykge1xuICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmVmbGVjdENhbGxiYWNrKG51bGwsIHsgZXJyb3I6IGVycm9yIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPD0gMikge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGNiQXJnO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gc2xpY2UoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVmbGVjdENhbGxiYWNrKG51bGwsIHsgdmFsdWU6IHZhbHVlIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gX2ZuLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH0pO1xufVxuXG4vKipcbiAqIEEgaGVscGVyIGZ1bmN0aW9uIHRoYXQgd3JhcHMgYW4gYXJyYXkgb3IgYW4gb2JqZWN0IG9mIGZ1bmN0aW9ucyB3aXRoIGByZWZsZWN0YC5cbiAqXG4gKiBAbmFtZSByZWZsZWN0QWxsXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOlV0aWxzXG4gKiBAbWV0aG9kXG4gKiBAc2VlIFthc3luYy5yZWZsZWN0XXtAbGluayBtb2R1bGU6VXRpbHMucmVmbGVjdH1cbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdHxJdGVyYWJsZX0gdGFza3MgLSBUaGUgY29sbGVjdGlvbiBvZlxuICogW2FzeW5jIGZ1bmN0aW9uc117QGxpbmsgQXN5bmNGdW5jdGlvbn0gdG8gd3JhcCBpbiBgYXN5bmMucmVmbGVjdGAuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYW4gYXJyYXkgb2YgYXN5bmMgZnVuY3Rpb25zLCBlYWNoIHdyYXBwZWQgaW5cbiAqIGBhc3luYy5yZWZsZWN0YFxuICogQGV4YW1wbGVcbiAqXG4gKiBsZXQgdGFza3MgPSBbXG4gKiAgICAgZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAqICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAqICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsICdvbmUnKTtcbiAqICAgICAgICAgfSwgMjAwKTtcbiAqICAgICB9LFxuICogICAgIGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gKiAgICAgICAgIC8vIGRvIHNvbWUgbW9yZSBzdHVmZiBidXQgZXJyb3IgLi4uXG4gKiAgICAgICAgIGNhbGxiYWNrKG5ldyBFcnJvcignYmFkIHN0dWZmIGhhcHBlbmVkJykpO1xuICogICAgIH0sXG4gKiAgICAgZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAqICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAqICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsICd0d28nKTtcbiAqICAgICAgICAgfSwgMTAwKTtcbiAqICAgICB9XG4gKiBdO1xuICpcbiAqIGFzeW5jLnBhcmFsbGVsKGFzeW5jLnJlZmxlY3RBbGwodGFza3MpLFxuICogLy8gb3B0aW9uYWwgY2FsbGJhY2tcbiAqIGZ1bmN0aW9uKGVyciwgcmVzdWx0cykge1xuICogICAgIC8vIHZhbHVlc1xuICogICAgIC8vIHJlc3VsdHNbMF0udmFsdWUgPSAnb25lJ1xuICogICAgIC8vIHJlc3VsdHNbMV0uZXJyb3IgPSBFcnJvcignYmFkIHN0dWZmIGhhcHBlbmVkJylcbiAqICAgICAvLyByZXN1bHRzWzJdLnZhbHVlID0gJ3R3bydcbiAqIH0pO1xuICpcbiAqIC8vIGFuIGV4YW1wbGUgdXNpbmcgYW4gb2JqZWN0IGluc3RlYWQgb2YgYW4gYXJyYXlcbiAqIGxldCB0YXNrcyA9IHtcbiAqICAgICBvbmU6IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gKiAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gKiAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCAnb25lJyk7XG4gKiAgICAgICAgIH0sIDIwMCk7XG4gKiAgICAgfSxcbiAqICAgICB0d286IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gKiAgICAgICAgIGNhbGxiYWNrKCd0d28nKTtcbiAqICAgICB9LFxuICogICAgIHRocmVlOiBmdW5jdGlvbihjYWxsYmFjaykge1xuICogICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICogICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgJ3RocmVlJyk7XG4gKiAgICAgICAgIH0sIDEwMCk7XG4gKiAgICAgfVxuICogfTtcbiAqXG4gKiBhc3luYy5wYXJhbGxlbChhc3luYy5yZWZsZWN0QWxsKHRhc2tzKSxcbiAqIC8vIG9wdGlvbmFsIGNhbGxiYWNrXG4gKiBmdW5jdGlvbihlcnIsIHJlc3VsdHMpIHtcbiAqICAgICAvLyB2YWx1ZXNcbiAqICAgICAvLyByZXN1bHRzLm9uZS52YWx1ZSA9ICdvbmUnXG4gKiAgICAgLy8gcmVzdWx0cy50d28uZXJyb3IgPSAndHdvJ1xuICogICAgIC8vIHJlc3VsdHMudGhyZWUudmFsdWUgPSAndGhyZWUnXG4gKiB9KTtcbiAqL1xuZnVuY3Rpb24gcmVmbGVjdEFsbCh0YXNrcykge1xuICAgIHZhciByZXN1bHRzO1xuICAgIGlmIChpc0FycmF5KHRhc2tzKSkge1xuICAgICAgICByZXN1bHRzID0gYXJyYXlNYXAodGFza3MsIHJlZmxlY3QpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdHMgPSB7fTtcbiAgICAgICAgYmFzZUZvck93bih0YXNrcywgZnVuY3Rpb24odGFzaywga2V5KSB7XG4gICAgICAgICAgICByZXN1bHRzW2tleV0gPSByZWZsZWN0LmNhbGwodGhpcywgdGFzayk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0cztcbn1cblxuZnVuY3Rpb24gcmVqZWN0JDEoZWFjaGZuLCBhcnIsIGl0ZXJhdGVlLCBjYWxsYmFjaykge1xuICAgIF9maWx0ZXIoZWFjaGZuLCBhcnIsIGZ1bmN0aW9uKHZhbHVlLCBjYikge1xuICAgICAgICBpdGVyYXRlZSh2YWx1ZSwgZnVuY3Rpb24oZXJyLCB2KSB7XG4gICAgICAgICAgICBjYihlcnIsICF2KTtcbiAgICAgICAgfSk7XG4gICAgfSwgY2FsbGJhY2spO1xufVxuXG4vKipcbiAqIFRoZSBvcHBvc2l0ZSBvZiBbYGZpbHRlcmBde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5maWx0ZXJ9LiBSZW1vdmVzIHZhbHVlcyB0aGF0IHBhc3MgYW4gYGFzeW5jYCB0cnV0aCB0ZXN0LlxuICpcbiAqIEBuYW1lIHJlamVjdFxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpDb2xsZWN0aW9uc1xuICogQG1ldGhvZFxuICogQHNlZSBbYXN5bmMuZmlsdGVyXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMuZmlsdGVyfVxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8T2JqZWN0fSBjb2xsIC0gQSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIC0gQW4gYXN5bmMgdHJ1dGggdGVzdCB0byBhcHBseSB0byBlYWNoIGl0ZW0gaW5cbiAqIGBjb2xsYC5cbiAqIFRoZSBzaG91bGQgY29tcGxldGUgd2l0aCBhIGJvb2xlYW4gdmFsdWUgYXMgaXRzIGByZXN1bHRgLlxuICogSW52b2tlZCB3aXRoIChpdGVtLCBjYWxsYmFjaykuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgYWZ0ZXIgYWxsIHRoZVxuICogYGl0ZXJhdGVlYCBmdW5jdGlvbnMgaGF2ZSBmaW5pc2hlZC4gSW52b2tlZCB3aXRoIChlcnIsIHJlc3VsdHMpLlxuICogQGV4YW1wbGVcbiAqXG4gKiBhc3luYy5yZWplY3QoWydmaWxlMScsJ2ZpbGUyJywnZmlsZTMnXSwgZnVuY3Rpb24oZmlsZVBhdGgsIGNhbGxiYWNrKSB7XG4gKiAgICAgZnMuYWNjZXNzKGZpbGVQYXRoLCBmdW5jdGlvbihlcnIpIHtcbiAqICAgICAgICAgY2FsbGJhY2sobnVsbCwgIWVycilcbiAqICAgICB9KTtcbiAqIH0sIGZ1bmN0aW9uKGVyciwgcmVzdWx0cykge1xuICogICAgIC8vIHJlc3VsdHMgbm93IGVxdWFscyBhbiBhcnJheSBvZiBtaXNzaW5nIGZpbGVzXG4gKiAgICAgY3JlYXRlRmlsZXMocmVzdWx0cyk7XG4gKiB9KTtcbiAqL1xudmFyIHJlamVjdCA9IGRvUGFyYWxsZWwocmVqZWN0JDEpO1xuXG4vKipcbiAqIFRoZSBzYW1lIGFzIFtgcmVqZWN0YF17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLnJlamVjdH0gYnV0IHJ1bnMgYSBtYXhpbXVtIG9mIGBsaW1pdGAgYXN5bmMgb3BlcmF0aW9ucyBhdCBhXG4gKiB0aW1lLlxuICpcbiAqIEBuYW1lIHJlamVjdExpbWl0XG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbGxlY3Rpb25zXG4gKiBAbWV0aG9kXG4gKiBAc2VlIFthc3luYy5yZWplY3Rde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5yZWplY3R9XG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxPYmplY3R9IGNvbGwgLSBBIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtudW1iZXJ9IGxpbWl0IC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIGFzeW5jIG9wZXJhdGlvbnMgYXQgYSB0aW1lLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgLSBBbiBhc3luYyB0cnV0aCB0ZXN0IHRvIGFwcGx5IHRvIGVhY2ggaXRlbSBpblxuICogYGNvbGxgLlxuICogVGhlIHNob3VsZCBjb21wbGV0ZSB3aXRoIGEgYm9vbGVhbiB2YWx1ZSBhcyBpdHMgYHJlc3VsdGAuXG4gKiBJbnZva2VkIHdpdGggKGl0ZW0sIGNhbGxiYWNrKS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCBhZnRlciBhbGwgdGhlXG4gKiBgaXRlcmF0ZWVgIGZ1bmN0aW9ucyBoYXZlIGZpbmlzaGVkLiBJbnZva2VkIHdpdGggKGVyciwgcmVzdWx0cykuXG4gKi9cbnZhciByZWplY3RMaW1pdCA9IGRvUGFyYWxsZWxMaW1pdChyZWplY3QkMSk7XG5cbi8qKlxuICogVGhlIHNhbWUgYXMgW2ByZWplY3RgXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMucmVqZWN0fSBidXQgcnVucyBvbmx5IGEgc2luZ2xlIGFzeW5jIG9wZXJhdGlvbiBhdCBhIHRpbWUuXG4gKlxuICogQG5hbWUgcmVqZWN0U2VyaWVzXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbGxlY3Rpb25zXG4gKiBAbWV0aG9kXG4gKiBAc2VlIFthc3luYy5yZWplY3Rde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5yZWplY3R9XG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxPYmplY3R9IGNvbGwgLSBBIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgLSBBbiBhc3luYyB0cnV0aCB0ZXN0IHRvIGFwcGx5IHRvIGVhY2ggaXRlbSBpblxuICogYGNvbGxgLlxuICogVGhlIHNob3VsZCBjb21wbGV0ZSB3aXRoIGEgYm9vbGVhbiB2YWx1ZSBhcyBpdHMgYHJlc3VsdGAuXG4gKiBJbnZva2VkIHdpdGggKGl0ZW0sIGNhbGxiYWNrKS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCBhZnRlciBhbGwgdGhlXG4gKiBgaXRlcmF0ZWVgIGZ1bmN0aW9ucyBoYXZlIGZpbmlzaGVkLiBJbnZva2VkIHdpdGggKGVyciwgcmVzdWx0cykuXG4gKi9cbnZhciByZWplY3RTZXJpZXMgPSBkb0xpbWl0KHJlamVjdExpbWl0LCAxKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGB2YWx1ZWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAyLjQuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHJldHVybiBmcm9tIHRoZSBuZXcgZnVuY3Rpb24uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjb25zdGFudCBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdHMgPSBfLnRpbWVzKDIsIF8uY29uc3RhbnQoeyAnYSc6IDEgfSkpO1xuICpcbiAqIGNvbnNvbGUubG9nKG9iamVjdHMpO1xuICogLy8gPT4gW3sgJ2EnOiAxIH0sIHsgJ2EnOiAxIH1dXG4gKlxuICogY29uc29sZS5sb2cob2JqZWN0c1swXSA9PT0gb2JqZWN0c1sxXSk7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGNvbnN0YW50JDEodmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcbn1cblxuLyoqXG4gKiBBdHRlbXB0cyB0byBnZXQgYSBzdWNjZXNzZnVsIHJlc3BvbnNlIGZyb20gYHRhc2tgIG5vIG1vcmUgdGhhbiBgdGltZXNgIHRpbWVzXG4gKiBiZWZvcmUgcmV0dXJuaW5nIGFuIGVycm9yLiBJZiB0aGUgdGFzayBpcyBzdWNjZXNzZnVsLCB0aGUgYGNhbGxiYWNrYCB3aWxsIGJlXG4gKiBwYXNzZWQgdGhlIHJlc3VsdCBvZiB0aGUgc3VjY2Vzc2Z1bCB0YXNrLiBJZiBhbGwgYXR0ZW1wdHMgZmFpbCwgdGhlIGNhbGxiYWNrXG4gKiB3aWxsIGJlIHBhc3NlZCB0aGUgZXJyb3IgYW5kIHJlc3VsdCAoaWYgYW55KSBvZiB0aGUgZmluYWwgYXR0ZW1wdC5cbiAqXG4gKiBAbmFtZSByZXRyeVxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpDb250cm9sRmxvd1xuICogQG1ldGhvZFxuICogQGNhdGVnb3J5IENvbnRyb2wgRmxvd1xuICogQHNlZSBbYXN5bmMucmV0cnlhYmxlXXtAbGluayBtb2R1bGU6Q29udHJvbEZsb3cucmV0cnlhYmxlfVxuICogQHBhcmFtIHtPYmplY3R8bnVtYmVyfSBbb3B0cyA9IHt0aW1lczogNSwgaW50ZXJ2YWw6IDB9fCA1XSAtIENhbiBiZSBlaXRoZXIgYW5cbiAqIG9iamVjdCB3aXRoIGB0aW1lc2AgYW5kIGBpbnRlcnZhbGAgb3IgYSBudW1iZXIuXG4gKiAqIGB0aW1lc2AgLSBUaGUgbnVtYmVyIG9mIGF0dGVtcHRzIHRvIG1ha2UgYmVmb3JlIGdpdmluZyB1cC4gIFRoZSBkZWZhdWx0XG4gKiAgIGlzIGA1YC5cbiAqICogYGludGVydmFsYCAtIFRoZSB0aW1lIHRvIHdhaXQgYmV0d2VlbiByZXRyaWVzLCBpbiBtaWxsaXNlY29uZHMuICBUaGVcbiAqICAgZGVmYXVsdCBpcyBgMGAuIFRoZSBpbnRlcnZhbCBtYXkgYWxzbyBiZSBzcGVjaWZpZWQgYXMgYSBmdW5jdGlvbiBvZiB0aGVcbiAqICAgcmV0cnkgY291bnQgKHNlZSBleGFtcGxlKS5cbiAqICogYGVycm9yRmlsdGVyYCAtIEFuIG9wdGlvbmFsIHN5bmNocm9ub3VzIGZ1bmN0aW9uIHRoYXQgaXMgaW52b2tlZCBvblxuICogICBlcnJvbmVvdXMgcmVzdWx0LiBJZiBpdCByZXR1cm5zIGB0cnVlYCB0aGUgcmV0cnkgYXR0ZW1wdHMgd2lsbCBjb250aW51ZTtcbiAqICAgaWYgdGhlIGZ1bmN0aW9uIHJldHVybnMgYGZhbHNlYCB0aGUgcmV0cnkgZmxvdyBpcyBhYm9ydGVkIHdpdGggdGhlIGN1cnJlbnRcbiAqICAgYXR0ZW1wdCdzIGVycm9yIGFuZCByZXN1bHQgYmVpbmcgcmV0dXJuZWQgdG8gdGhlIGZpbmFsIGNhbGxiYWNrLlxuICogICBJbnZva2VkIHdpdGggKGVycikuXG4gKiAqIElmIGBvcHRzYCBpcyBhIG51bWJlciwgdGhlIG51bWJlciBzcGVjaWZpZXMgdGhlIG51bWJlciBvZiB0aW1lcyB0byByZXRyeSxcbiAqICAgd2l0aCB0aGUgZGVmYXVsdCBpbnRlcnZhbCBvZiBgMGAuXG4gKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IHRhc2sgLSBBbiBhc3luYyBmdW5jdGlvbiB0byByZXRyeS5cbiAqIEludm9rZWQgd2l0aCAoY2FsbGJhY2spLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEFuIG9wdGlvbmFsIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCB3aGVuIHRoZVxuICogdGFzayBoYXMgc3VjY2VlZGVkLCBvciBhZnRlciB0aGUgZmluYWwgZmFpbGVkIGF0dGVtcHQuIEl0IHJlY2VpdmVzIHRoZSBgZXJyYFxuICogYW5kIGByZXN1bHRgIGFyZ3VtZW50cyBvZiB0aGUgbGFzdCBhdHRlbXB0IGF0IGNvbXBsZXRpbmcgdGhlIGB0YXNrYC4gSW52b2tlZFxuICogd2l0aCAoZXJyLCByZXN1bHRzKS5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIC8vIFRoZSBgcmV0cnlgIGZ1bmN0aW9uIGNhbiBiZSB1c2VkIGFzIGEgc3RhbmQtYWxvbmUgY29udHJvbCBmbG93IGJ5IHBhc3NpbmdcbiAqIC8vIGEgY2FsbGJhY2ssIGFzIHNob3duIGJlbG93OlxuICpcbiAqIC8vIHRyeSBjYWxsaW5nIGFwaU1ldGhvZCAzIHRpbWVzXG4gKiBhc3luYy5yZXRyeSgzLCBhcGlNZXRob2QsIGZ1bmN0aW9uKGVyciwgcmVzdWx0KSB7XG4gKiAgICAgLy8gZG8gc29tZXRoaW5nIHdpdGggdGhlIHJlc3VsdFxuICogfSk7XG4gKlxuICogLy8gdHJ5IGNhbGxpbmcgYXBpTWV0aG9kIDMgdGltZXMsIHdhaXRpbmcgMjAwIG1zIGJldHdlZW4gZWFjaCByZXRyeVxuICogYXN5bmMucmV0cnkoe3RpbWVzOiAzLCBpbnRlcnZhbDogMjAwfSwgYXBpTWV0aG9kLCBmdW5jdGlvbihlcnIsIHJlc3VsdCkge1xuICogICAgIC8vIGRvIHNvbWV0aGluZyB3aXRoIHRoZSByZXN1bHRcbiAqIH0pO1xuICpcbiAqIC8vIHRyeSBjYWxsaW5nIGFwaU1ldGhvZCAxMCB0aW1lcyB3aXRoIGV4cG9uZW50aWFsIGJhY2tvZmZcbiAqIC8vIChpLmUuIGludGVydmFscyBvZiAxMDAsIDIwMCwgNDAwLCA4MDAsIDE2MDAsIC4uLiBtaWxsaXNlY29uZHMpXG4gKiBhc3luYy5yZXRyeSh7XG4gKiAgIHRpbWVzOiAxMCxcbiAqICAgaW50ZXJ2YWw6IGZ1bmN0aW9uKHJldHJ5Q291bnQpIHtcbiAqICAgICByZXR1cm4gNTAgKiBNYXRoLnBvdygyLCByZXRyeUNvdW50KTtcbiAqICAgfVxuICogfSwgYXBpTWV0aG9kLCBmdW5jdGlvbihlcnIsIHJlc3VsdCkge1xuICogICAgIC8vIGRvIHNvbWV0aGluZyB3aXRoIHRoZSByZXN1bHRcbiAqIH0pO1xuICpcbiAqIC8vIHRyeSBjYWxsaW5nIGFwaU1ldGhvZCB0aGUgZGVmYXVsdCA1IHRpbWVzIG5vIGRlbGF5IGJldHdlZW4gZWFjaCByZXRyeVxuICogYXN5bmMucmV0cnkoYXBpTWV0aG9kLCBmdW5jdGlvbihlcnIsIHJlc3VsdCkge1xuICogICAgIC8vIGRvIHNvbWV0aGluZyB3aXRoIHRoZSByZXN1bHRcbiAqIH0pO1xuICpcbiAqIC8vIHRyeSBjYWxsaW5nIGFwaU1ldGhvZCBvbmx5IHdoZW4gZXJyb3IgY29uZGl0aW9uIHNhdGlzZmllcywgYWxsIG90aGVyXG4gKiAvLyBlcnJvcnMgd2lsbCBhYm9ydCB0aGUgcmV0cnkgY29udHJvbCBmbG93IGFuZCByZXR1cm4gdG8gZmluYWwgY2FsbGJhY2tcbiAqIGFzeW5jLnJldHJ5KHtcbiAqICAgZXJyb3JGaWx0ZXI6IGZ1bmN0aW9uKGVycikge1xuICogICAgIHJldHVybiBlcnIubWVzc2FnZSA9PT0gJ1RlbXBvcmFyeSBlcnJvcic7IC8vIG9ubHkgcmV0cnkgb24gYSBzcGVjaWZpYyBlcnJvclxuICogICB9XG4gKiB9LCBhcGlNZXRob2QsIGZ1bmN0aW9uKGVyciwgcmVzdWx0KSB7XG4gKiAgICAgLy8gZG8gc29tZXRoaW5nIHdpdGggdGhlIHJlc3VsdFxuICogfSk7XG4gKlxuICogLy8gdG8gcmV0cnkgaW5kaXZpZHVhbCBtZXRob2RzIHRoYXQgYXJlIG5vdCBhcyByZWxpYWJsZSB3aXRoaW4gb3RoZXJcbiAqIC8vIGNvbnRyb2wgZmxvdyBmdW5jdGlvbnMsIHVzZSB0aGUgYHJldHJ5YWJsZWAgd3JhcHBlcjpcbiAqIGFzeW5jLmF1dG8oe1xuICogICAgIHVzZXJzOiBhcGkuZ2V0VXNlcnMuYmluZChhcGkpLFxuICogICAgIHBheW1lbnRzOiBhc3luYy5yZXRyeWFibGUoMywgYXBpLmdldFBheW1lbnRzLmJpbmQoYXBpKSlcbiAqIH0sIGZ1bmN0aW9uKGVyciwgcmVzdWx0cykge1xuICogICAgIC8vIGRvIHNvbWV0aGluZyB3aXRoIHRoZSByZXN1bHRzXG4gKiB9KTtcbiAqXG4gKi9cbmZ1bmN0aW9uIHJldHJ5KG9wdHMsIHRhc2ssIGNhbGxiYWNrKSB7XG4gICAgdmFyIERFRkFVTFRfVElNRVMgPSA1O1xuICAgIHZhciBERUZBVUxUX0lOVEVSVkFMID0gMDtcblxuICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICB0aW1lczogREVGQVVMVF9USU1FUyxcbiAgICAgICAgaW50ZXJ2YWxGdW5jOiBjb25zdGFudCQxKERFRkFVTFRfSU5URVJWQUwpXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHBhcnNlVGltZXMoYWNjLCB0KSB7XG4gICAgICAgIGlmICh0eXBlb2YgdCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGFjYy50aW1lcyA9ICt0LnRpbWVzIHx8IERFRkFVTFRfVElNRVM7XG5cbiAgICAgICAgICAgIGFjYy5pbnRlcnZhbEZ1bmMgPSB0eXBlb2YgdC5pbnRlcnZhbCA9PT0gJ2Z1bmN0aW9uJyA/XG4gICAgICAgICAgICAgICAgdC5pbnRlcnZhbCA6XG4gICAgICAgICAgICAgICAgY29uc3RhbnQkMSgrdC5pbnRlcnZhbCB8fCBERUZBVUxUX0lOVEVSVkFMKTtcblxuICAgICAgICAgICAgYWNjLmVycm9yRmlsdGVyID0gdC5lcnJvckZpbHRlcjtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdCA9PT0gJ251bWJlcicgfHwgdHlwZW9mIHQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBhY2MudGltZXMgPSArdCB8fCBERUZBVUxUX1RJTUVTO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBhcmd1bWVudHMgZm9yIGFzeW5jLnJldHJ5XCIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAzICYmIHR5cGVvZiBvcHRzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNhbGxiYWNrID0gdGFzayB8fCBub29wO1xuICAgICAgICB0YXNrID0gb3B0cztcbiAgICB9IGVsc2Uge1xuICAgICAgICBwYXJzZVRpbWVzKG9wdGlvbnMsIG9wdHMpO1xuICAgICAgICBjYWxsYmFjayA9IGNhbGxiYWNrIHx8IG5vb3A7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB0YXNrICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgYXJndW1lbnRzIGZvciBhc3luYy5yZXRyeVwiKTtcbiAgICB9XG5cbiAgICB2YXIgX3Rhc2sgPSB3cmFwQXN5bmModGFzayk7XG5cbiAgICB2YXIgYXR0ZW1wdCA9IDE7XG4gICAgZnVuY3Rpb24gcmV0cnlBdHRlbXB0KCkge1xuICAgICAgICBfdGFzayhmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgIGlmIChlcnIgJiYgYXR0ZW1wdCsrIDwgb3B0aW9ucy50aW1lcyAmJlxuICAgICAgICAgICAgICAgICh0eXBlb2Ygb3B0aW9ucy5lcnJvckZpbHRlciAhPSAnZnVuY3Rpb24nIHx8XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZXJyb3JGaWx0ZXIoZXJyKSkpIHtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KHJldHJ5QXR0ZW1wdCwgb3B0aW9ucy5pbnRlcnZhbEZ1bmMoYXR0ZW1wdCkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjay5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICByZXRyeUF0dGVtcHQoKTtcbn1cblxuLyoqXG4gKiBBIGNsb3NlIHJlbGF0aXZlIG9mIFtgcmV0cnlgXXtAbGluayBtb2R1bGU6Q29udHJvbEZsb3cucmV0cnl9LiAgVGhpcyBtZXRob2RcbiAqIHdyYXBzIGEgdGFzayBhbmQgbWFrZXMgaXQgcmV0cnlhYmxlLCByYXRoZXIgdGhhbiBpbW1lZGlhdGVseSBjYWxsaW5nIGl0XG4gKiB3aXRoIHJldHJpZXMuXG4gKlxuICogQG5hbWUgcmV0cnlhYmxlXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbnRyb2xGbG93XG4gKiBAbWV0aG9kXG4gKiBAc2VlIFthc3luYy5yZXRyeV17QGxpbmsgbW9kdWxlOkNvbnRyb2xGbG93LnJldHJ5fVxuICogQGNhdGVnb3J5IENvbnRyb2wgRmxvd1xuICogQHBhcmFtIHtPYmplY3R8bnVtYmVyfSBbb3B0cyA9IHt0aW1lczogNSwgaW50ZXJ2YWw6IDB9fCA1XSAtIG9wdGlvbmFsXG4gKiBvcHRpb25zLCBleGFjdGx5IHRoZSBzYW1lIGFzIGZyb20gYHJldHJ5YFxuICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSB0YXNrIC0gdGhlIGFzeW5jaHJvbm91cyBmdW5jdGlvbiB0byB3cmFwLlxuICogVGhpcyBmdW5jdGlvbiB3aWxsIGJlIHBhc3NlZCBhbnkgYXJndW1lbnRzIHBhc3NlZCB0byB0aGUgcmV0dXJuZWQgd3JhcHBlci5cbiAqIEludm9rZWQgd2l0aCAoLi4uYXJncywgY2FsbGJhY2spLlxuICogQHJldHVybnMge0FzeW5jRnVuY3Rpb259IFRoZSB3cmFwcGVkIGZ1bmN0aW9uLCB3aGljaCB3aGVuIGludm9rZWQsIHdpbGxcbiAqIHJldHJ5IG9uIGFuIGVycm9yLCBiYXNlZCBvbiB0aGUgcGFyYW1ldGVycyBzcGVjaWZpZWQgaW4gYG9wdHNgLlxuICogVGhpcyBmdW5jdGlvbiB3aWxsIGFjY2VwdCB0aGUgc2FtZSBwYXJhbWV0ZXJzIGFzIGB0YXNrYC5cbiAqIEBleGFtcGxlXG4gKlxuICogYXN5bmMuYXV0byh7XG4gKiAgICAgZGVwMTogYXN5bmMucmV0cnlhYmxlKDMsIGdldEZyb21GbGFreVNlcnZpY2UpLFxuICogICAgIHByb2Nlc3M6IFtcImRlcDFcIiwgYXN5bmMucmV0cnlhYmxlKDMsIGZ1bmN0aW9uIChyZXN1bHRzLCBjYikge1xuICogICAgICAgICBtYXliZVByb2Nlc3NEYXRhKHJlc3VsdHMuZGVwMSwgY2IpO1xuICogICAgIH0pXVxuICogfSwgY2FsbGJhY2spO1xuICovXG52YXIgcmV0cnlhYmxlID0gZnVuY3Rpb24gKG9wdHMsIHRhc2spIHtcbiAgICBpZiAoIXRhc2spIHtcbiAgICAgICAgdGFzayA9IG9wdHM7XG4gICAgICAgIG9wdHMgPSBudWxsO1xuICAgIH1cbiAgICB2YXIgX3Rhc2sgPSB3cmFwQXN5bmModGFzayk7XG4gICAgcmV0dXJuIGluaXRpYWxQYXJhbXMoZnVuY3Rpb24gKGFyZ3MsIGNhbGxiYWNrKSB7XG4gICAgICAgIGZ1bmN0aW9uIHRhc2tGbihjYikge1xuICAgICAgICAgICAgX3Rhc2suYXBwbHkobnVsbCwgYXJncy5jb25jYXQoY2IpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRzKSByZXRyeShvcHRzLCB0YXNrRm4sIGNhbGxiYWNrKTtcbiAgICAgICAgZWxzZSByZXRyeSh0YXNrRm4sIGNhbGxiYWNrKTtcblxuICAgIH0pO1xufTtcblxuLyoqXG4gKiBSdW4gdGhlIGZ1bmN0aW9ucyBpbiB0aGUgYHRhc2tzYCBjb2xsZWN0aW9uIGluIHNlcmllcywgZWFjaCBvbmUgcnVubmluZyBvbmNlXG4gKiB0aGUgcHJldmlvdXMgZnVuY3Rpb24gaGFzIGNvbXBsZXRlZC4gSWYgYW55IGZ1bmN0aW9ucyBpbiB0aGUgc2VyaWVzIHBhc3MgYW5cbiAqIGVycm9yIHRvIGl0cyBjYWxsYmFjaywgbm8gbW9yZSBmdW5jdGlvbnMgYXJlIHJ1biwgYW5kIGBjYWxsYmFja2AgaXNcbiAqIGltbWVkaWF0ZWx5IGNhbGxlZCB3aXRoIHRoZSB2YWx1ZSBvZiB0aGUgZXJyb3IuIE90aGVyd2lzZSwgYGNhbGxiYWNrYFxuICogcmVjZWl2ZXMgYW4gYXJyYXkgb2YgcmVzdWx0cyB3aGVuIGB0YXNrc2AgaGF2ZSBjb21wbGV0ZWQuXG4gKlxuICogSXQgaXMgYWxzbyBwb3NzaWJsZSB0byB1c2UgYW4gb2JqZWN0IGluc3RlYWQgb2YgYW4gYXJyYXkuIEVhY2ggcHJvcGVydHkgd2lsbFxuICogYmUgcnVuIGFzIGEgZnVuY3Rpb24sIGFuZCB0aGUgcmVzdWx0cyB3aWxsIGJlIHBhc3NlZCB0byB0aGUgZmluYWwgYGNhbGxiYWNrYFxuICogYXMgYW4gb2JqZWN0IGluc3RlYWQgb2YgYW4gYXJyYXkuIFRoaXMgY2FuIGJlIGEgbW9yZSByZWFkYWJsZSB3YXkgb2YgaGFuZGxpbmdcbiAqICByZXN1bHRzIGZyb20ge0BsaW5rIGFzeW5jLnNlcmllc30uXG4gKlxuICogKipOb3RlKiogdGhhdCB3aGlsZSBtYW55IGltcGxlbWVudGF0aW9ucyBwcmVzZXJ2ZSB0aGUgb3JkZXIgb2Ygb2JqZWN0XG4gKiBwcm9wZXJ0aWVzLCB0aGUgW0VDTUFTY3JpcHQgTGFuZ3VhZ2UgU3BlY2lmaWNhdGlvbl0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzUuMS8jc2VjLTguNilcbiAqIGV4cGxpY2l0bHkgc3RhdGVzIHRoYXRcbiAqXG4gKiA+IFRoZSBtZWNoYW5pY3MgYW5kIG9yZGVyIG9mIGVudW1lcmF0aW5nIHRoZSBwcm9wZXJ0aWVzIGlzIG5vdCBzcGVjaWZpZWQuXG4gKlxuICogU28gaWYgeW91IHJlbHkgb24gdGhlIG9yZGVyIGluIHdoaWNoIHlvdXIgc2VyaWVzIG9mIGZ1bmN0aW9ucyBhcmUgZXhlY3V0ZWQsXG4gKiBhbmQgd2FudCB0aGlzIHRvIHdvcmsgb24gYWxsIHBsYXRmb3JtcywgY29uc2lkZXIgdXNpbmcgYW4gYXJyYXkuXG4gKlxuICogQG5hbWUgc2VyaWVzXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbnRyb2xGbG93XG4gKiBAbWV0aG9kXG4gKiBAY2F0ZWdvcnkgQ29udHJvbCBGbG93XG4gKiBAcGFyYW0ge0FycmF5fEl0ZXJhYmxlfE9iamVjdH0gdGFza3MgLSBBIGNvbGxlY3Rpb24gY29udGFpbmluZ1xuICogW2FzeW5jIGZ1bmN0aW9uc117QGxpbmsgQXN5bmNGdW5jdGlvbn0gdG8gcnVuIGluIHNlcmllcy5cbiAqIEVhY2ggZnVuY3Rpb24gY2FuIGNvbXBsZXRlIHdpdGggYW55IG51bWJlciBvZiBvcHRpb25hbCBgcmVzdWx0YCB2YWx1ZXMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQW4gb3B0aW9uYWwgY2FsbGJhY2sgdG8gcnVuIG9uY2UgYWxsIHRoZVxuICogZnVuY3Rpb25zIGhhdmUgY29tcGxldGVkLiBUaGlzIGZ1bmN0aW9uIGdldHMgYSByZXN1bHRzIGFycmF5IChvciBvYmplY3QpXG4gKiBjb250YWluaW5nIGFsbCB0aGUgcmVzdWx0IGFyZ3VtZW50cyBwYXNzZWQgdG8gdGhlIGB0YXNrYCBjYWxsYmFja3MuIEludm9rZWRcbiAqIHdpdGggKGVyciwgcmVzdWx0KS5cbiAqIEBleGFtcGxlXG4gKiBhc3luYy5zZXJpZXMoW1xuICogICAgIGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gKiAgICAgICAgIC8vIGRvIHNvbWUgc3R1ZmYgLi4uXG4gKiAgICAgICAgIGNhbGxiYWNrKG51bGwsICdvbmUnKTtcbiAqICAgICB9LFxuICogICAgIGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gKiAgICAgICAgIC8vIGRvIHNvbWUgbW9yZSBzdHVmZiAuLi5cbiAqICAgICAgICAgY2FsbGJhY2sobnVsbCwgJ3R3bycpO1xuICogICAgIH1cbiAqIF0sXG4gKiAvLyBvcHRpb25hbCBjYWxsYmFja1xuICogZnVuY3Rpb24oZXJyLCByZXN1bHRzKSB7XG4gKiAgICAgLy8gcmVzdWx0cyBpcyBub3cgZXF1YWwgdG8gWydvbmUnLCAndHdvJ11cbiAqIH0pO1xuICpcbiAqIGFzeW5jLnNlcmllcyh7XG4gKiAgICAgb25lOiBmdW5jdGlvbihjYWxsYmFjaykge1xuICogICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICogICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgMSk7XG4gKiAgICAgICAgIH0sIDIwMCk7XG4gKiAgICAgfSxcbiAqICAgICB0d286IGZ1bmN0aW9uKGNhbGxiYWNrKXtcbiAqICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAqICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIDIpO1xuICogICAgICAgICB9LCAxMDApO1xuICogICAgIH1cbiAqIH0sIGZ1bmN0aW9uKGVyciwgcmVzdWx0cykge1xuICogICAgIC8vIHJlc3VsdHMgaXMgbm93IGVxdWFsIHRvOiB7b25lOiAxLCB0d286IDJ9XG4gKiB9KTtcbiAqL1xuZnVuY3Rpb24gc2VyaWVzKHRhc2tzLCBjYWxsYmFjaykge1xuICAgIF9wYXJhbGxlbChlYWNoT2ZTZXJpZXMsIHRhc2tzLCBjYWxsYmFjayk7XG59XG5cbi8qKlxuICogUmV0dXJucyBgdHJ1ZWAgaWYgYXQgbGVhc3Qgb25lIGVsZW1lbnQgaW4gdGhlIGBjb2xsYCBzYXRpc2ZpZXMgYW4gYXN5bmMgdGVzdC5cbiAqIElmIGFueSBpdGVyYXRlZSBjYWxsIHJldHVybnMgYHRydWVgLCB0aGUgbWFpbiBgY2FsbGJhY2tgIGlzIGltbWVkaWF0ZWx5XG4gKiBjYWxsZWQuXG4gKlxuICogQG5hbWUgc29tZVxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpDb2xsZWN0aW9uc1xuICogQG1ldGhvZFxuICogQGFsaWFzIGFueVxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8T2JqZWN0fSBjb2xsIC0gQSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gaXRlcmF0ZWUgLSBBbiBhc3luYyB0cnV0aCB0ZXN0IHRvIGFwcGx5IHRvIGVhY2ggaXRlbVxuICogaW4gdGhlIGNvbGxlY3Rpb25zIGluIHBhcmFsbGVsLlxuICogVGhlIGl0ZXJhdGVlIHNob3VsZCBjb21wbGV0ZSB3aXRoIGEgYm9vbGVhbiBgcmVzdWx0YCB2YWx1ZS5cbiAqIEludm9rZWQgd2l0aCAoaXRlbSwgY2FsbGJhY2spLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIGFzIHNvb24gYXMgYW55XG4gKiBpdGVyYXRlZSByZXR1cm5zIGB0cnVlYCwgb3IgYWZ0ZXIgYWxsIHRoZSBpdGVyYXRlZSBmdW5jdGlvbnMgaGF2ZSBmaW5pc2hlZC5cbiAqIFJlc3VsdCB3aWxsIGJlIGVpdGhlciBgdHJ1ZWAgb3IgYGZhbHNlYCBkZXBlbmRpbmcgb24gdGhlIHZhbHVlcyBvZiB0aGUgYXN5bmNcbiAqIHRlc3RzLiBJbnZva2VkIHdpdGggKGVyciwgcmVzdWx0KS5cbiAqIEBleGFtcGxlXG4gKlxuICogYXN5bmMuc29tZShbJ2ZpbGUxJywnZmlsZTInLCdmaWxlMyddLCBmdW5jdGlvbihmaWxlUGF0aCwgY2FsbGJhY2spIHtcbiAqICAgICBmcy5hY2Nlc3MoZmlsZVBhdGgsIGZ1bmN0aW9uKGVycikge1xuICogICAgICAgICBjYWxsYmFjayhudWxsLCAhZXJyKVxuICogICAgIH0pO1xuICogfSwgZnVuY3Rpb24oZXJyLCByZXN1bHQpIHtcbiAqICAgICAvLyBpZiByZXN1bHQgaXMgdHJ1ZSB0aGVuIGF0IGxlYXN0IG9uZSBvZiB0aGUgZmlsZXMgZXhpc3RzXG4gKiB9KTtcbiAqL1xudmFyIHNvbWUgPSBkb1BhcmFsbGVsKF9jcmVhdGVUZXN0ZXIoQm9vbGVhbiwgaWRlbnRpdHkpKTtcblxuLyoqXG4gKiBUaGUgc2FtZSBhcyBbYHNvbWVgXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMuc29tZX0gYnV0IHJ1bnMgYSBtYXhpbXVtIG9mIGBsaW1pdGAgYXN5bmMgb3BlcmF0aW9ucyBhdCBhIHRpbWUuXG4gKlxuICogQG5hbWUgc29tZUxpbWl0XG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbGxlY3Rpb25zXG4gKiBAbWV0aG9kXG4gKiBAc2VlIFthc3luYy5zb21lXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMuc29tZX1cbiAqIEBhbGlhcyBhbnlMaW1pdFxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8T2JqZWN0fSBjb2xsIC0gQSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7bnVtYmVyfSBsaW1pdCAtIFRoZSBtYXhpbXVtIG51bWJlciBvZiBhc3luYyBvcGVyYXRpb25zIGF0IGEgdGltZS5cbiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gaXRlcmF0ZWUgLSBBbiBhc3luYyB0cnV0aCB0ZXN0IHRvIGFwcGx5IHRvIGVhY2ggaXRlbVxuICogaW4gdGhlIGNvbGxlY3Rpb25zIGluIHBhcmFsbGVsLlxuICogVGhlIGl0ZXJhdGVlIHNob3VsZCBjb21wbGV0ZSB3aXRoIGEgYm9vbGVhbiBgcmVzdWx0YCB2YWx1ZS5cbiAqIEludm9rZWQgd2l0aCAoaXRlbSwgY2FsbGJhY2spLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIGFzIHNvb24gYXMgYW55XG4gKiBpdGVyYXRlZSByZXR1cm5zIGB0cnVlYCwgb3IgYWZ0ZXIgYWxsIHRoZSBpdGVyYXRlZSBmdW5jdGlvbnMgaGF2ZSBmaW5pc2hlZC5cbiAqIFJlc3VsdCB3aWxsIGJlIGVpdGhlciBgdHJ1ZWAgb3IgYGZhbHNlYCBkZXBlbmRpbmcgb24gdGhlIHZhbHVlcyBvZiB0aGUgYXN5bmNcbiAqIHRlc3RzLiBJbnZva2VkIHdpdGggKGVyciwgcmVzdWx0KS5cbiAqL1xudmFyIHNvbWVMaW1pdCA9IGRvUGFyYWxsZWxMaW1pdChfY3JlYXRlVGVzdGVyKEJvb2xlYW4sIGlkZW50aXR5KSk7XG5cbi8qKlxuICogVGhlIHNhbWUgYXMgW2Bzb21lYF17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLnNvbWV9IGJ1dCBydW5zIG9ubHkgYSBzaW5nbGUgYXN5bmMgb3BlcmF0aW9uIGF0IGEgdGltZS5cbiAqXG4gKiBAbmFtZSBzb21lU2VyaWVzXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbGxlY3Rpb25zXG4gKiBAbWV0aG9kXG4gKiBAc2VlIFthc3luYy5zb21lXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMuc29tZX1cbiAqIEBhbGlhcyBhbnlTZXJpZXNcbiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gKiBAcGFyYW0ge0FycmF5fEl0ZXJhYmxlfE9iamVjdH0gY29sbCAtIEEgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGl0ZXJhdGVlIC0gQW4gYXN5bmMgdHJ1dGggdGVzdCB0byBhcHBseSB0byBlYWNoIGl0ZW1cbiAqIGluIHRoZSBjb2xsZWN0aW9ucyBpbiBzZXJpZXMuXG4gKiBUaGUgaXRlcmF0ZWUgc2hvdWxkIGNvbXBsZXRlIHdpdGggYSBib29sZWFuIGByZXN1bHRgIHZhbHVlLlxuICogSW52b2tlZCB3aXRoIChpdGVtLCBjYWxsYmFjaykuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgYXMgc29vbiBhcyBhbnlcbiAqIGl0ZXJhdGVlIHJldHVybnMgYHRydWVgLCBvciBhZnRlciBhbGwgdGhlIGl0ZXJhdGVlIGZ1bmN0aW9ucyBoYXZlIGZpbmlzaGVkLlxuICogUmVzdWx0IHdpbGwgYmUgZWl0aGVyIGB0cnVlYCBvciBgZmFsc2VgIGRlcGVuZGluZyBvbiB0aGUgdmFsdWVzIG9mIHRoZSBhc3luY1xuICogdGVzdHMuIEludm9rZWQgd2l0aCAoZXJyLCByZXN1bHQpLlxuICovXG52YXIgc29tZVNlcmllcyA9IGRvTGltaXQoc29tZUxpbWl0LCAxKTtcblxuLyoqXG4gKiBTb3J0cyBhIGxpc3QgYnkgdGhlIHJlc3VsdHMgb2YgcnVubmluZyBlYWNoIGBjb2xsYCB2YWx1ZSB0aHJvdWdoIGFuIGFzeW5jXG4gKiBgaXRlcmF0ZWVgLlxuICpcbiAqIEBuYW1lIHNvcnRCeVxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpDb2xsZWN0aW9uc1xuICogQG1ldGhvZFxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8T2JqZWN0fSBjb2xsIC0gQSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gaXRlcmF0ZWUgLSBBbiBhc3luYyBmdW5jdGlvbiB0byBhcHBseSB0byBlYWNoIGl0ZW0gaW5cbiAqIGBjb2xsYC5cbiAqIFRoZSBpdGVyYXRlZSBzaG91bGQgY29tcGxldGUgd2l0aCBhIHZhbHVlIHRvIHVzZSBhcyB0aGUgc29ydCBjcml0ZXJpYSBhc1xuICogaXRzIGByZXN1bHRgLlxuICogSW52b2tlZCB3aXRoIChpdGVtLCBjYWxsYmFjaykuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayAtIEEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIGFmdGVyIGFsbCB0aGVcbiAqIGBpdGVyYXRlZWAgZnVuY3Rpb25zIGhhdmUgZmluaXNoZWQsIG9yIGFuIGVycm9yIG9jY3Vycy4gUmVzdWx0cyBpcyB0aGUgaXRlbXNcbiAqIGZyb20gdGhlIG9yaWdpbmFsIGBjb2xsYCBzb3J0ZWQgYnkgdGhlIHZhbHVlcyByZXR1cm5lZCBieSB0aGUgYGl0ZXJhdGVlYFxuICogY2FsbHMuIEludm9rZWQgd2l0aCAoZXJyLCByZXN1bHRzKS5cbiAqIEBleGFtcGxlXG4gKlxuICogYXN5bmMuc29ydEJ5KFsnZmlsZTEnLCdmaWxlMicsJ2ZpbGUzJ10sIGZ1bmN0aW9uKGZpbGUsIGNhbGxiYWNrKSB7XG4gKiAgICAgZnMuc3RhdChmaWxlLCBmdW5jdGlvbihlcnIsIHN0YXRzKSB7XG4gKiAgICAgICAgIGNhbGxiYWNrKGVyciwgc3RhdHMubXRpbWUpO1xuICogICAgIH0pO1xuICogfSwgZnVuY3Rpb24oZXJyLCByZXN1bHRzKSB7XG4gKiAgICAgLy8gcmVzdWx0cyBpcyBub3cgdGhlIG9yaWdpbmFsIGFycmF5IG9mIGZpbGVzIHNvcnRlZCBieVxuICogICAgIC8vIG1vZGlmaWVkIGRhdGVcbiAqIH0pO1xuICpcbiAqIC8vIEJ5IG1vZGlmeWluZyB0aGUgY2FsbGJhY2sgcGFyYW1ldGVyIHRoZVxuICogLy8gc29ydGluZyBvcmRlciBjYW4gYmUgaW5mbHVlbmNlZDpcbiAqXG4gKiAvLyBhc2NlbmRpbmcgb3JkZXJcbiAqIGFzeW5jLnNvcnRCeShbMSw5LDMsNV0sIGZ1bmN0aW9uKHgsIGNhbGxiYWNrKSB7XG4gKiAgICAgY2FsbGJhY2sobnVsbCwgeCk7XG4gKiB9LCBmdW5jdGlvbihlcnIscmVzdWx0KSB7XG4gKiAgICAgLy8gcmVzdWx0IGNhbGxiYWNrXG4gKiB9KTtcbiAqXG4gKiAvLyBkZXNjZW5kaW5nIG9yZGVyXG4gKiBhc3luYy5zb3J0QnkoWzEsOSwzLDVdLCBmdW5jdGlvbih4LCBjYWxsYmFjaykge1xuICogICAgIGNhbGxiYWNrKG51bGwsIHgqLTEpOyAgICAvLzwtIHgqLTEgaW5zdGVhZCBvZiB4LCB0dXJucyB0aGUgb3JkZXIgYXJvdW5kXG4gKiB9LCBmdW5jdGlvbihlcnIscmVzdWx0KSB7XG4gKiAgICAgLy8gcmVzdWx0IGNhbGxiYWNrXG4gKiB9KTtcbiAqL1xuZnVuY3Rpb24gc29ydEJ5IChjb2xsLCBpdGVyYXRlZSwgY2FsbGJhY2spIHtcbiAgICB2YXIgX2l0ZXJhdGVlID0gd3JhcEFzeW5jKGl0ZXJhdGVlKTtcbiAgICBtYXAoY29sbCwgZnVuY3Rpb24gKHgsIGNhbGxiYWNrKSB7XG4gICAgICAgIF9pdGVyYXRlZSh4LCBmdW5jdGlvbiAoZXJyLCBjcml0ZXJpYSkge1xuICAgICAgICAgICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICBjYWxsYmFjayhudWxsLCB7dmFsdWU6IHgsIGNyaXRlcmlhOiBjcml0ZXJpYX0pO1xuICAgICAgICB9KTtcbiAgICB9LCBmdW5jdGlvbiAoZXJyLCByZXN1bHRzKSB7XG4gICAgICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICBjYWxsYmFjayhudWxsLCBhcnJheU1hcChyZXN1bHRzLnNvcnQoY29tcGFyYXRvciksIGJhc2VQcm9wZXJ0eSgndmFsdWUnKSkpO1xuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gY29tcGFyYXRvcihsZWZ0LCByaWdodCkge1xuICAgICAgICB2YXIgYSA9IGxlZnQuY3JpdGVyaWEsIGIgPSByaWdodC5jcml0ZXJpYTtcbiAgICAgICAgcmV0dXJuIGEgPCBiID8gLTEgOiBhID4gYiA/IDEgOiAwO1xuICAgIH1cbn1cblxuLyoqXG4gKiBTZXRzIGEgdGltZSBsaW1pdCBvbiBhbiBhc3luY2hyb25vdXMgZnVuY3Rpb24uIElmIHRoZSBmdW5jdGlvbiBkb2VzIG5vdCBjYWxsXG4gKiBpdHMgY2FsbGJhY2sgd2l0aGluIHRoZSBzcGVjaWZpZWQgbWlsbGlzZWNvbmRzLCBpdCB3aWxsIGJlIGNhbGxlZCB3aXRoIGFcbiAqIHRpbWVvdXQgZXJyb3IuIFRoZSBjb2RlIHByb3BlcnR5IGZvciB0aGUgZXJyb3Igb2JqZWN0IHdpbGwgYmUgYCdFVElNRURPVVQnYC5cbiAqXG4gKiBAbmFtZSB0aW1lb3V0XG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOlV0aWxzXG4gKiBAbWV0aG9kXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBhc3luY0ZuIC0gVGhlIGFzeW5jIGZ1bmN0aW9uIHRvIGxpbWl0IGluIHRpbWUuXG4gKiBAcGFyYW0ge251bWJlcn0gbWlsbGlzZWNvbmRzIC0gVGhlIHNwZWNpZmllZCB0aW1lIGxpbWl0LlxuICogQHBhcmFtIHsqfSBbaW5mb10gLSBBbnkgdmFyaWFibGUgeW91IHdhbnQgYXR0YWNoZWQgKGBzdHJpbmdgLCBgb2JqZWN0YCwgZXRjKVxuICogdG8gdGltZW91dCBFcnJvciBmb3IgbW9yZSBpbmZvcm1hdGlvbi4uXG4gKiBAcmV0dXJucyB7QXN5bmNGdW5jdGlvbn0gUmV0dXJucyBhIHdyYXBwZWQgZnVuY3Rpb24gdGhhdCBjYW4gYmUgdXNlZCB3aXRoIGFueVxuICogb2YgdGhlIGNvbnRyb2wgZmxvdyBmdW5jdGlvbnMuXG4gKiBJbnZva2UgdGhpcyBmdW5jdGlvbiB3aXRoIHRoZSBzYW1lIHBhcmFtZXRlcnMgYXMgeW91IHdvdWxkIGBhc3luY0Z1bmNgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBteUZ1bmN0aW9uKGZvbywgY2FsbGJhY2spIHtcbiAqICAgICBkb0FzeW5jVGFzayhmb28sIGZ1bmN0aW9uKGVyciwgZGF0YSkge1xuICogICAgICAgICAvLyBoYW5kbGUgZXJyb3JzXG4gKiAgICAgICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICpcbiAqICAgICAgICAgLy8gZG8gc29tZSBzdHVmZiAuLi5cbiAqXG4gKiAgICAgICAgIC8vIHJldHVybiBwcm9jZXNzZWQgZGF0YVxuICogICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgZGF0YSk7XG4gKiAgICAgfSk7XG4gKiB9XG4gKlxuICogdmFyIHdyYXBwZWQgPSBhc3luYy50aW1lb3V0KG15RnVuY3Rpb24sIDEwMDApO1xuICpcbiAqIC8vIGNhbGwgYHdyYXBwZWRgIGFzIHlvdSB3b3VsZCBgbXlGdW5jdGlvbmBcbiAqIHdyYXBwZWQoeyBiYXI6ICdiYXInIH0sIGZ1bmN0aW9uKGVyciwgZGF0YSkge1xuICogICAgIC8vIGlmIGBteUZ1bmN0aW9uYCB0YWtlcyA8IDEwMDAgbXMgdG8gZXhlY3V0ZSwgYGVycmBcbiAqICAgICAvLyBhbmQgYGRhdGFgIHdpbGwgaGF2ZSB0aGVpciBleHBlY3RlZCB2YWx1ZXNcbiAqXG4gKiAgICAgLy8gZWxzZSBgZXJyYCB3aWxsIGJlIGFuIEVycm9yIHdpdGggdGhlIGNvZGUgJ0VUSU1FRE9VVCdcbiAqIH0pO1xuICovXG5mdW5jdGlvbiB0aW1lb3V0KGFzeW5jRm4sIG1pbGxpc2Vjb25kcywgaW5mbykge1xuICAgIHZhciBmbiA9IHdyYXBBc3luYyhhc3luY0ZuKTtcblxuICAgIHJldHVybiBpbml0aWFsUGFyYW1zKGZ1bmN0aW9uIChhcmdzLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgdGltZWRPdXQgPSBmYWxzZTtcbiAgICAgICAgdmFyIHRpbWVyO1xuXG4gICAgICAgIGZ1bmN0aW9uIHRpbWVvdXRDYWxsYmFjaygpIHtcbiAgICAgICAgICAgIHZhciBuYW1lID0gYXN5bmNGbi5uYW1lIHx8ICdhbm9ueW1vdXMnO1xuICAgICAgICAgICAgdmFyIGVycm9yICA9IG5ldyBFcnJvcignQ2FsbGJhY2sgZnVuY3Rpb24gXCInICsgbmFtZSArICdcIiB0aW1lZCBvdXQuJyk7XG4gICAgICAgICAgICBlcnJvci5jb2RlID0gJ0VUSU1FRE9VVCc7XG4gICAgICAgICAgICBpZiAoaW5mbykge1xuICAgICAgICAgICAgICAgIGVycm9yLmluZm8gPSBpbmZvO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGltZWRPdXQgPSB0cnVlO1xuICAgICAgICAgICAgY2FsbGJhY2soZXJyb3IpO1xuICAgICAgICB9XG5cbiAgICAgICAgYXJncy5wdXNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghdGltZWRPdXQpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjay5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIHNldHVwIHRpbWVyIGFuZCBjYWxsIG9yaWdpbmFsIGZ1bmN0aW9uXG4gICAgICAgIHRpbWVyID0gc2V0VGltZW91dCh0aW1lb3V0Q2FsbGJhY2ssIG1pbGxpc2Vjb25kcyk7XG4gICAgICAgIGZuLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgIH0pO1xufVxuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlQ2VpbCA9IE1hdGguY2VpbDtcbnZhciBuYXRpdmVNYXggPSBNYXRoLm1heDtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5yYW5nZWAgYW5kIGBfLnJhbmdlUmlnaHRgIHdoaWNoIGRvZXNuJ3RcbiAqIGNvZXJjZSBhcmd1bWVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCBUaGUgc3RhcnQgb2YgdGhlIHJhbmdlLlxuICogQHBhcmFtIHtudW1iZXJ9IGVuZCBUaGUgZW5kIG9mIHRoZSByYW5nZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdGVwIFRoZSB2YWx1ZSB0byBpbmNyZW1lbnQgb3IgZGVjcmVtZW50IGJ5LlxuICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHJhbmdlIG9mIG51bWJlcnMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VSYW5nZShzdGFydCwgZW5kLCBzdGVwLCBmcm9tUmlnaHQpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBuYXRpdmVNYXgobmF0aXZlQ2VpbCgoZW5kIC0gc3RhcnQpIC8gKHN0ZXAgfHwgMSkpLCAwKSxcbiAgICAgIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG5cbiAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgcmVzdWx0W2Zyb21SaWdodCA/IGxlbmd0aCA6ICsraW5kZXhdID0gc3RhcnQ7XG4gICAgc3RhcnQgKz0gc3RlcDtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIFRoZSBzYW1lIGFzIFt0aW1lc117QGxpbmsgbW9kdWxlOkNvbnRyb2xGbG93LnRpbWVzfSBidXQgcnVucyBhIG1heGltdW0gb2YgYGxpbWl0YCBhc3luYyBvcGVyYXRpb25zIGF0IGFcbiAqIHRpbWUuXG4gKlxuICogQG5hbWUgdGltZXNMaW1pdFxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpDb250cm9sRmxvd1xuICogQG1ldGhvZFxuICogQHNlZSBbYXN5bmMudGltZXNde0BsaW5rIG1vZHVsZTpDb250cm9sRmxvdy50aW1lc31cbiAqIEBjYXRlZ29yeSBDb250cm9sIEZsb3dcbiAqIEBwYXJhbSB7bnVtYmVyfSBjb3VudCAtIFRoZSBudW1iZXIgb2YgdGltZXMgdG8gcnVuIHRoZSBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBsaW1pdCAtIFRoZSBtYXhpbXVtIG51bWJlciBvZiBhc3luYyBvcGVyYXRpb25zIGF0IGEgdGltZS5cbiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gaXRlcmF0ZWUgLSBUaGUgYXN5bmMgZnVuY3Rpb24gdG8gY2FsbCBgbmAgdGltZXMuXG4gKiBJbnZva2VkIHdpdGggdGhlIGl0ZXJhdGlvbiBpbmRleCBhbmQgYSBjYWxsYmFjazogKG4sIG5leHQpLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgLSBzZWUgW2FzeW5jLm1hcF17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLm1hcH0uXG4gKi9cbmZ1bmN0aW9uIHRpbWVMaW1pdChjb3VudCwgbGltaXQsIGl0ZXJhdGVlLCBjYWxsYmFjaykge1xuICAgIHZhciBfaXRlcmF0ZWUgPSB3cmFwQXN5bmMoaXRlcmF0ZWUpO1xuICAgIG1hcExpbWl0KGJhc2VSYW5nZSgwLCBjb3VudCwgMSksIGxpbWl0LCBfaXRlcmF0ZWUsIGNhbGxiYWNrKTtcbn1cblxuLyoqXG4gKiBDYWxscyB0aGUgYGl0ZXJhdGVlYCBmdW5jdGlvbiBgbmAgdGltZXMsIGFuZCBhY2N1bXVsYXRlcyByZXN1bHRzIGluIHRoZSBzYW1lXG4gKiBtYW5uZXIgeW91IHdvdWxkIHVzZSB3aXRoIFttYXBde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5tYXB9LlxuICpcbiAqIEBuYW1lIHRpbWVzXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbnRyb2xGbG93XG4gKiBAbWV0aG9kXG4gKiBAc2VlIFthc3luYy5tYXBde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5tYXB9XG4gKiBAY2F0ZWdvcnkgQ29udHJvbCBGbG93XG4gKiBAcGFyYW0ge251bWJlcn0gbiAtIFRoZSBudW1iZXIgb2YgdGltZXMgdG8gcnVuIHRoZSBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gaXRlcmF0ZWUgLSBUaGUgYXN5bmMgZnVuY3Rpb24gdG8gY2FsbCBgbmAgdGltZXMuXG4gKiBJbnZva2VkIHdpdGggdGhlIGl0ZXJhdGlvbiBpbmRleCBhbmQgYSBjYWxsYmFjazogKG4sIG5leHQpLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgLSBzZWUge0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5tYXB9LlxuICogQGV4YW1wbGVcbiAqXG4gKiAvLyBQcmV0ZW5kIHRoaXMgaXMgc29tZSBjb21wbGljYXRlZCBhc3luYyBmYWN0b3J5XG4gKiB2YXIgY3JlYXRlVXNlciA9IGZ1bmN0aW9uKGlkLCBjYWxsYmFjaykge1xuICogICAgIGNhbGxiYWNrKG51bGwsIHtcbiAqICAgICAgICAgaWQ6ICd1c2VyJyArIGlkXG4gKiAgICAgfSk7XG4gKiB9O1xuICpcbiAqIC8vIGdlbmVyYXRlIDUgdXNlcnNcbiAqIGFzeW5jLnRpbWVzKDUsIGZ1bmN0aW9uKG4sIG5leHQpIHtcbiAqICAgICBjcmVhdGVVc2VyKG4sIGZ1bmN0aW9uKGVyciwgdXNlcikge1xuICogICAgICAgICBuZXh0KGVyciwgdXNlcik7XG4gKiAgICAgfSk7XG4gKiB9LCBmdW5jdGlvbihlcnIsIHVzZXJzKSB7XG4gKiAgICAgLy8gd2Ugc2hvdWxkIG5vdyBoYXZlIDUgdXNlcnNcbiAqIH0pO1xuICovXG52YXIgdGltZXMgPSBkb0xpbWl0KHRpbWVMaW1pdCwgSW5maW5pdHkpO1xuXG4vKipcbiAqIFRoZSBzYW1lIGFzIFt0aW1lc117QGxpbmsgbW9kdWxlOkNvbnRyb2xGbG93LnRpbWVzfSBidXQgcnVucyBvbmx5IGEgc2luZ2xlIGFzeW5jIG9wZXJhdGlvbiBhdCBhIHRpbWUuXG4gKlxuICogQG5hbWUgdGltZXNTZXJpZXNcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29udHJvbEZsb3dcbiAqIEBtZXRob2RcbiAqIEBzZWUgW2FzeW5jLnRpbWVzXXtAbGluayBtb2R1bGU6Q29udHJvbEZsb3cudGltZXN9XG4gKiBAY2F0ZWdvcnkgQ29udHJvbCBGbG93XG4gKiBAcGFyYW0ge251bWJlcn0gbiAtIFRoZSBudW1iZXIgb2YgdGltZXMgdG8gcnVuIHRoZSBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gaXRlcmF0ZWUgLSBUaGUgYXN5bmMgZnVuY3Rpb24gdG8gY2FsbCBgbmAgdGltZXMuXG4gKiBJbnZva2VkIHdpdGggdGhlIGl0ZXJhdGlvbiBpbmRleCBhbmQgYSBjYWxsYmFjazogKG4sIG5leHQpLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgLSBzZWUge0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5tYXB9LlxuICovXG52YXIgdGltZXNTZXJpZXMgPSBkb0xpbWl0KHRpbWVMaW1pdCwgMSk7XG5cbi8qKlxuICogQSByZWxhdGl2ZSBvZiBgcmVkdWNlYC4gIFRha2VzIGFuIE9iamVjdCBvciBBcnJheSwgYW5kIGl0ZXJhdGVzIG92ZXIgZWFjaFxuICogZWxlbWVudCBpbiBzZXJpZXMsIGVhY2ggc3RlcCBwb3RlbnRpYWxseSBtdXRhdGluZyBhbiBgYWNjdW11bGF0b3JgIHZhbHVlLlxuICogVGhlIHR5cGUgb2YgdGhlIGFjY3VtdWxhdG9yIGRlZmF1bHRzIHRvIHRoZSB0eXBlIG9mIGNvbGxlY3Rpb24gcGFzc2VkIGluLlxuICpcbiAqIEBuYW1lIHRyYW5zZm9ybVxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpDb2xsZWN0aW9uc1xuICogQG1ldGhvZFxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8T2JqZWN0fSBjb2xsIC0gQSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7Kn0gW2FjY3VtdWxhdG9yXSAtIFRoZSBpbml0aWFsIHN0YXRlIG9mIHRoZSB0cmFuc2Zvcm0uICBJZiBvbWl0dGVkLFxuICogaXQgd2lsbCBkZWZhdWx0IHRvIGFuIGVtcHR5IE9iamVjdCBvciBBcnJheSwgZGVwZW5kaW5nIG9uIHRoZSB0eXBlIG9mIGBjb2xsYFxuICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEEgZnVuY3Rpb24gYXBwbGllZCB0byBlYWNoIGl0ZW0gaW4gdGhlXG4gKiBjb2xsZWN0aW9uIHRoYXQgcG90ZW50aWFsbHkgbW9kaWZpZXMgdGhlIGFjY3VtdWxhdG9yLlxuICogSW52b2tlZCB3aXRoIChhY2N1bXVsYXRvciwgaXRlbSwga2V5LCBjYWxsYmFjaykuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgYWZ0ZXIgYWxsIHRoZVxuICogYGl0ZXJhdGVlYCBmdW5jdGlvbnMgaGF2ZSBmaW5pc2hlZC4gUmVzdWx0IGlzIHRoZSB0cmFuc2Zvcm1lZCBhY2N1bXVsYXRvci5cbiAqIEludm9rZWQgd2l0aCAoZXJyLCByZXN1bHQpLlxuICogQGV4YW1wbGVcbiAqXG4gKiBhc3luYy50cmFuc2Zvcm0oWzEsMiwzXSwgZnVuY3Rpb24oYWNjLCBpdGVtLCBpbmRleCwgY2FsbGJhY2spIHtcbiAqICAgICAvLyBwb2ludGxlc3MgYXN5bmM6XG4gKiAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpIHtcbiAqICAgICAgICAgYWNjLnB1c2goaXRlbSAqIDIpXG4gKiAgICAgICAgIGNhbGxiYWNrKG51bGwpXG4gKiAgICAgfSk7XG4gKiB9LCBmdW5jdGlvbihlcnIsIHJlc3VsdCkge1xuICogICAgIC8vIHJlc3VsdCBpcyBub3cgZXF1YWwgdG8gWzIsIDQsIDZdXG4gKiB9KTtcbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGFzeW5jLnRyYW5zZm9ybSh7YTogMSwgYjogMiwgYzogM30sIGZ1bmN0aW9uIChvYmosIHZhbCwga2V5LCBjYWxsYmFjaykge1xuICogICAgIHNldEltbWVkaWF0ZShmdW5jdGlvbiAoKSB7XG4gKiAgICAgICAgIG9ialtrZXldID0gdmFsICogMjtcbiAqICAgICAgICAgY2FsbGJhY2soKTtcbiAqICAgICB9KVxuICogfSwgZnVuY3Rpb24gKGVyciwgcmVzdWx0KSB7XG4gKiAgICAgLy8gcmVzdWx0IGlzIGVxdWFsIHRvIHthOiAyLCBiOiA0LCBjOiA2fVxuICogfSlcbiAqL1xuZnVuY3Rpb24gdHJhbnNmb3JtIChjb2xsLCBhY2N1bXVsYXRvciwgaXRlcmF0ZWUsIGNhbGxiYWNrKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPD0gMykge1xuICAgICAgICBjYWxsYmFjayA9IGl0ZXJhdGVlO1xuICAgICAgICBpdGVyYXRlZSA9IGFjY3VtdWxhdG9yO1xuICAgICAgICBhY2N1bXVsYXRvciA9IGlzQXJyYXkoY29sbCkgPyBbXSA6IHt9O1xuICAgIH1cbiAgICBjYWxsYmFjayA9IG9uY2UoY2FsbGJhY2sgfHwgbm9vcCk7XG4gICAgdmFyIF9pdGVyYXRlZSA9IHdyYXBBc3luYyhpdGVyYXRlZSk7XG5cbiAgICBlYWNoT2YoY29sbCwgZnVuY3Rpb24odiwgaywgY2IpIHtcbiAgICAgICAgX2l0ZXJhdGVlKGFjY3VtdWxhdG9yLCB2LCBrLCBjYik7XG4gICAgfSwgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgIGNhbGxiYWNrKGVyciwgYWNjdW11bGF0b3IpO1xuICAgIH0pO1xufVxuXG4vKipcbiAqIEl0IHJ1bnMgZWFjaCB0YXNrIGluIHNlcmllcyBidXQgc3RvcHMgd2hlbmV2ZXIgYW55IG9mIHRoZSBmdW5jdGlvbnMgd2VyZVxuICogc3VjY2Vzc2Z1bC4gSWYgb25lIG9mIHRoZSB0YXNrcyB3ZXJlIHN1Y2Nlc3NmdWwsIHRoZSBgY2FsbGJhY2tgIHdpbGwgYmVcbiAqIHBhc3NlZCB0aGUgcmVzdWx0IG9mIHRoZSBzdWNjZXNzZnVsIHRhc2suIElmIGFsbCB0YXNrcyBmYWlsLCB0aGUgY2FsbGJhY2tcbiAqIHdpbGwgYmUgcGFzc2VkIHRoZSBlcnJvciBhbmQgcmVzdWx0IChpZiBhbnkpIG9mIHRoZSBmaW5hbCBhdHRlbXB0LlxuICpcbiAqIEBuYW1lIHRyeUVhY2hcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29udHJvbEZsb3dcbiAqIEBtZXRob2RcbiAqIEBjYXRlZ29yeSBDb250cm9sIEZsb3dcbiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8T2JqZWN0fSB0YXNrcyAtIEEgY29sbGVjdGlvbiBjb250YWluaW5nIGZ1bmN0aW9ucyB0b1xuICogcnVuLCBlYWNoIGZ1bmN0aW9uIGlzIHBhc3NlZCBhIGBjYWxsYmFjayhlcnIsIHJlc3VsdClgIGl0IG11c3QgY2FsbCBvblxuICogY29tcGxldGlvbiB3aXRoIGFuIGVycm9yIGBlcnJgICh3aGljaCBjYW4gYmUgYG51bGxgKSBhbmQgYW4gb3B0aW9uYWwgYHJlc3VsdGBcbiAqIHZhbHVlLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEFuIG9wdGlvbmFsIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCB3aGVuIG9uZVxuICogb2YgdGhlIHRhc2tzIGhhcyBzdWNjZWVkZWQsIG9yIGFsbCBoYXZlIGZhaWxlZC4gSXQgcmVjZWl2ZXMgdGhlIGBlcnJgIGFuZFxuICogYHJlc3VsdGAgYXJndW1lbnRzIG9mIHRoZSBsYXN0IGF0dGVtcHQgYXQgY29tcGxldGluZyB0aGUgYHRhc2tgLiBJbnZva2VkIHdpdGhcbiAqIChlcnIsIHJlc3VsdHMpLlxuICogQGV4YW1wbGVcbiAqIGFzeW5jLnRyeUVhY2goW1xuICogICAgIGZ1bmN0aW9uIGdldERhdGFGcm9tRmlyc3RXZWJzaXRlKGNhbGxiYWNrKSB7XG4gKiAgICAgICAgIC8vIFRyeSBnZXR0aW5nIHRoZSBkYXRhIGZyb20gdGhlIGZpcnN0IHdlYnNpdGVcbiAqICAgICAgICAgY2FsbGJhY2soZXJyLCBkYXRhKTtcbiAqICAgICB9LFxuICogICAgIGZ1bmN0aW9uIGdldERhdGFGcm9tU2Vjb25kV2Vic2l0ZShjYWxsYmFjaykge1xuICogICAgICAgICAvLyBGaXJzdCB3ZWJzaXRlIGZhaWxlZCxcbiAqICAgICAgICAgLy8gVHJ5IGdldHRpbmcgdGhlIGRhdGEgZnJvbSB0aGUgYmFja3VwIHdlYnNpdGVcbiAqICAgICAgICAgY2FsbGJhY2soZXJyLCBkYXRhKTtcbiAqICAgICB9XG4gKiBdLFxuICogLy8gb3B0aW9uYWwgY2FsbGJhY2tcbiAqIGZ1bmN0aW9uKGVyciwgcmVzdWx0cykge1xuICogICAgIE5vdyBkbyBzb21ldGhpbmcgd2l0aCB0aGUgZGF0YS5cbiAqIH0pO1xuICpcbiAqL1xuZnVuY3Rpb24gdHJ5RWFjaCh0YXNrcywgY2FsbGJhY2spIHtcbiAgICB2YXIgZXJyb3IgPSBudWxsO1xuICAgIHZhciByZXN1bHQ7XG4gICAgY2FsbGJhY2sgPSBjYWxsYmFjayB8fCBub29wO1xuICAgIGVhY2hTZXJpZXModGFza3MsIGZ1bmN0aW9uKHRhc2ssIGNhbGxiYWNrKSB7XG4gICAgICAgIHdyYXBBc3luYyh0YXNrKShmdW5jdGlvbiAoZXJyLCByZXMvKiwgLi4uYXJncyovKSB7XG4gICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBzbGljZShhcmd1bWVudHMsIDEpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSByZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlcnJvciA9IGVycjtcbiAgICAgICAgICAgIGNhbGxiYWNrKCFlcnIpO1xuICAgICAgICB9KTtcbiAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNhbGxiYWNrKGVycm9yLCByZXN1bHQpO1xuICAgIH0pO1xufVxuXG4vKipcbiAqIFVuZG9lcyBhIFttZW1vaXplXXtAbGluayBtb2R1bGU6VXRpbHMubWVtb2l6ZX1kIGZ1bmN0aW9uLCByZXZlcnRpbmcgaXQgdG8gdGhlIG9yaWdpbmFsLFxuICogdW5tZW1vaXplZCBmb3JtLiBIYW5keSBmb3IgdGVzdGluZy5cbiAqXG4gKiBAbmFtZSB1bm1lbW9pemVcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6VXRpbHNcbiAqIEBtZXRob2RcbiAqIEBzZWUgW2FzeW5jLm1lbW9pemVde0BsaW5rIG1vZHVsZTpVdGlscy5tZW1vaXplfVxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gZm4gLSB0aGUgbWVtb2l6ZWQgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtBc3luY0Z1bmN0aW9ufSBhIGZ1bmN0aW9uIHRoYXQgY2FsbHMgdGhlIG9yaWdpbmFsIHVubWVtb2l6ZWQgZnVuY3Rpb25cbiAqL1xuZnVuY3Rpb24gdW5tZW1vaXplKGZuKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIChmbi51bm1lbW9pemVkIHx8IGZuKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH07XG59XG5cbi8qKlxuICogUmVwZWF0ZWRseSBjYWxsIGBpdGVyYXRlZWAsIHdoaWxlIGB0ZXN0YCByZXR1cm5zIGB0cnVlYC4gQ2FsbHMgYGNhbGxiYWNrYCB3aGVuXG4gKiBzdG9wcGVkLCBvciBhbiBlcnJvciBvY2N1cnMuXG4gKlxuICogQG5hbWUgd2hpbHN0XG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbnRyb2xGbG93XG4gKiBAbWV0aG9kXG4gKiBAY2F0ZWdvcnkgQ29udHJvbCBGbG93XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSB0ZXN0IC0gc3luY2hyb25vdXMgdHJ1dGggdGVzdCB0byBwZXJmb3JtIGJlZm9yZSBlYWNoXG4gKiBleGVjdXRpb24gb2YgYGl0ZXJhdGVlYC4gSW52b2tlZCB3aXRoICgpLlxuICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEFuIGFzeW5jIGZ1bmN0aW9uIHdoaWNoIGlzIGNhbGxlZCBlYWNoIHRpbWVcbiAqIGB0ZXN0YCBwYXNzZXMuIEludm9rZWQgd2l0aCAoY2FsbGJhY2spLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIGFmdGVyIHRoZSB0ZXN0XG4gKiBmdW5jdGlvbiBoYXMgZmFpbGVkIGFuZCByZXBlYXRlZCBleGVjdXRpb24gb2YgYGl0ZXJhdGVlYCBoYXMgc3RvcHBlZC4gYGNhbGxiYWNrYFxuICogd2lsbCBiZSBwYXNzZWQgYW4gZXJyb3IgYW5kIGFueSBhcmd1bWVudHMgcGFzc2VkIHRvIHRoZSBmaW5hbCBgaXRlcmF0ZWVgJ3NcbiAqIGNhbGxiYWNrLiBJbnZva2VkIHdpdGggKGVyciwgW3Jlc3VsdHNdKTtcbiAqIEByZXR1cm5zIHVuZGVmaW5lZFxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgY291bnQgPSAwO1xuICogYXN5bmMud2hpbHN0KFxuICogICAgIGZ1bmN0aW9uKCkgeyByZXR1cm4gY291bnQgPCA1OyB9LFxuICogICAgIGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gKiAgICAgICAgIGNvdW50Kys7XG4gKiAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gKiAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCBjb3VudCk7XG4gKiAgICAgICAgIH0sIDEwMDApO1xuICogICAgIH0sXG4gKiAgICAgZnVuY3Rpb24gKGVyciwgbikge1xuICogICAgICAgICAvLyA1IHNlY29uZHMgaGF2ZSBwYXNzZWQsIG4gPSA1XG4gKiAgICAgfVxuICogKTtcbiAqL1xuZnVuY3Rpb24gd2hpbHN0KHRlc3QsIGl0ZXJhdGVlLCBjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrID0gb25seU9uY2UoY2FsbGJhY2sgfHwgbm9vcCk7XG4gICAgdmFyIF9pdGVyYXRlZSA9IHdyYXBBc3luYyhpdGVyYXRlZSk7XG4gICAgaWYgKCF0ZXN0KCkpIHJldHVybiBjYWxsYmFjayhudWxsKTtcbiAgICB2YXIgbmV4dCA9IGZ1bmN0aW9uKGVyci8qLCAuLi5hcmdzKi8pIHtcbiAgICAgICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgIGlmICh0ZXN0KCkpIHJldHVybiBfaXRlcmF0ZWUobmV4dCk7XG4gICAgICAgIHZhciBhcmdzID0gc2xpY2UoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgY2FsbGJhY2suYXBwbHkobnVsbCwgW251bGxdLmNvbmNhdChhcmdzKSk7XG4gICAgfTtcbiAgICBfaXRlcmF0ZWUobmV4dCk7XG59XG5cbi8qKlxuICogUmVwZWF0ZWRseSBjYWxsIGBpdGVyYXRlZWAgdW50aWwgYHRlc3RgIHJldHVybnMgYHRydWVgLiBDYWxscyBgY2FsbGJhY2tgIHdoZW5cbiAqIHN0b3BwZWQsIG9yIGFuIGVycm9yIG9jY3Vycy4gYGNhbGxiYWNrYCB3aWxsIGJlIHBhc3NlZCBhbiBlcnJvciBhbmQgYW55XG4gKiBhcmd1bWVudHMgcGFzc2VkIHRvIHRoZSBmaW5hbCBgaXRlcmF0ZWVgJ3MgY2FsbGJhY2suXG4gKlxuICogVGhlIGludmVyc2Ugb2YgW3doaWxzdF17QGxpbmsgbW9kdWxlOkNvbnRyb2xGbG93LndoaWxzdH0uXG4gKlxuICogQG5hbWUgdW50aWxcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29udHJvbEZsb3dcbiAqIEBtZXRob2RcbiAqIEBzZWUgW2FzeW5jLndoaWxzdF17QGxpbmsgbW9kdWxlOkNvbnRyb2xGbG93LndoaWxzdH1cbiAqIEBjYXRlZ29yeSBDb250cm9sIEZsb3dcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHRlc3QgLSBzeW5jaHJvbm91cyB0cnV0aCB0ZXN0IHRvIHBlcmZvcm0gYmVmb3JlIGVhY2hcbiAqIGV4ZWN1dGlvbiBvZiBgaXRlcmF0ZWVgLiBJbnZva2VkIHdpdGggKCkuXG4gKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGl0ZXJhdGVlIC0gQW4gYXN5bmMgZnVuY3Rpb24gd2hpY2ggaXMgY2FsbGVkIGVhY2ggdGltZVxuICogYHRlc3RgIGZhaWxzLiBJbnZva2VkIHdpdGggKGNhbGxiYWNrKS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCBhZnRlciB0aGUgdGVzdFxuICogZnVuY3Rpb24gaGFzIHBhc3NlZCBhbmQgcmVwZWF0ZWQgZXhlY3V0aW9uIG9mIGBpdGVyYXRlZWAgaGFzIHN0b3BwZWQuIGBjYWxsYmFja2BcbiAqIHdpbGwgYmUgcGFzc2VkIGFuIGVycm9yIGFuZCBhbnkgYXJndW1lbnRzIHBhc3NlZCB0byB0aGUgZmluYWwgYGl0ZXJhdGVlYCdzXG4gKiBjYWxsYmFjay4gSW52b2tlZCB3aXRoIChlcnIsIFtyZXN1bHRzXSk7XG4gKi9cbmZ1bmN0aW9uIHVudGlsKHRlc3QsIGl0ZXJhdGVlLCBjYWxsYmFjaykge1xuICAgIHdoaWxzdChmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICF0ZXN0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfSwgaXRlcmF0ZWUsIGNhbGxiYWNrKTtcbn1cblxuLyoqXG4gKiBSdW5zIHRoZSBgdGFza3NgIGFycmF5IG9mIGZ1bmN0aW9ucyBpbiBzZXJpZXMsIGVhY2ggcGFzc2luZyB0aGVpciByZXN1bHRzIHRvXG4gKiB0aGUgbmV4dCBpbiB0aGUgYXJyYXkuIEhvd2V2ZXIsIGlmIGFueSBvZiB0aGUgYHRhc2tzYCBwYXNzIGFuIGVycm9yIHRvIHRoZWlyXG4gKiBvd24gY2FsbGJhY2ssIHRoZSBuZXh0IGZ1bmN0aW9uIGlzIG5vdCBleGVjdXRlZCwgYW5kIHRoZSBtYWluIGBjYWxsYmFja2AgaXNcbiAqIGltbWVkaWF0ZWx5IGNhbGxlZCB3aXRoIHRoZSBlcnJvci5cbiAqXG4gKiBAbmFtZSB3YXRlcmZhbGxcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29udHJvbEZsb3dcbiAqIEBtZXRob2RcbiAqIEBjYXRlZ29yeSBDb250cm9sIEZsb3dcbiAqIEBwYXJhbSB7QXJyYXl9IHRhc2tzIC0gQW4gYXJyYXkgb2YgW2FzeW5jIGZ1bmN0aW9uc117QGxpbmsgQXN5bmNGdW5jdGlvbn1cbiAqIHRvIHJ1bi5cbiAqIEVhY2ggZnVuY3Rpb24gc2hvdWxkIGNvbXBsZXRlIHdpdGggYW55IG51bWJlciBvZiBgcmVzdWx0YCB2YWx1ZXMuXG4gKiBUaGUgYHJlc3VsdGAgdmFsdWVzIHdpbGwgYmUgcGFzc2VkIGFzIGFyZ3VtZW50cywgaW4gb3JkZXIsIHRvIHRoZSBuZXh0IHRhc2suXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQW4gb3B0aW9uYWwgY2FsbGJhY2sgdG8gcnVuIG9uY2UgYWxsIHRoZVxuICogZnVuY3Rpb25zIGhhdmUgY29tcGxldGVkLiBUaGlzIHdpbGwgYmUgcGFzc2VkIHRoZSByZXN1bHRzIG9mIHRoZSBsYXN0IHRhc2snc1xuICogY2FsbGJhY2suIEludm9rZWQgd2l0aCAoZXJyLCBbcmVzdWx0c10pLlxuICogQHJldHVybnMgdW5kZWZpbmVkXG4gKiBAZXhhbXBsZVxuICpcbiAqIGFzeW5jLndhdGVyZmFsbChbXG4gKiAgICAgZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAqICAgICAgICAgY2FsbGJhY2sobnVsbCwgJ29uZScsICd0d28nKTtcbiAqICAgICB9LFxuICogICAgIGZ1bmN0aW9uKGFyZzEsIGFyZzIsIGNhbGxiYWNrKSB7XG4gKiAgICAgICAgIC8vIGFyZzEgbm93IGVxdWFscyAnb25lJyBhbmQgYXJnMiBub3cgZXF1YWxzICd0d28nXG4gKiAgICAgICAgIGNhbGxiYWNrKG51bGwsICd0aHJlZScpO1xuICogICAgIH0sXG4gKiAgICAgZnVuY3Rpb24oYXJnMSwgY2FsbGJhY2spIHtcbiAqICAgICAgICAgLy8gYXJnMSBub3cgZXF1YWxzICd0aHJlZSdcbiAqICAgICAgICAgY2FsbGJhY2sobnVsbCwgJ2RvbmUnKTtcbiAqICAgICB9XG4gKiBdLCBmdW5jdGlvbiAoZXJyLCByZXN1bHQpIHtcbiAqICAgICAvLyByZXN1bHQgbm93IGVxdWFscyAnZG9uZSdcbiAqIH0pO1xuICpcbiAqIC8vIE9yLCB3aXRoIG5hbWVkIGZ1bmN0aW9uczpcbiAqIGFzeW5jLndhdGVyZmFsbChbXG4gKiAgICAgbXlGaXJzdEZ1bmN0aW9uLFxuICogICAgIG15U2Vjb25kRnVuY3Rpb24sXG4gKiAgICAgbXlMYXN0RnVuY3Rpb24sXG4gKiBdLCBmdW5jdGlvbiAoZXJyLCByZXN1bHQpIHtcbiAqICAgICAvLyByZXN1bHQgbm93IGVxdWFscyAnZG9uZSdcbiAqIH0pO1xuICogZnVuY3Rpb24gbXlGaXJzdEZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gKiAgICAgY2FsbGJhY2sobnVsbCwgJ29uZScsICd0d28nKTtcbiAqIH1cbiAqIGZ1bmN0aW9uIG15U2Vjb25kRnVuY3Rpb24oYXJnMSwgYXJnMiwgY2FsbGJhY2spIHtcbiAqICAgICAvLyBhcmcxIG5vdyBlcXVhbHMgJ29uZScgYW5kIGFyZzIgbm93IGVxdWFscyAndHdvJ1xuICogICAgIGNhbGxiYWNrKG51bGwsICd0aHJlZScpO1xuICogfVxuICogZnVuY3Rpb24gbXlMYXN0RnVuY3Rpb24oYXJnMSwgY2FsbGJhY2spIHtcbiAqICAgICAvLyBhcmcxIG5vdyBlcXVhbHMgJ3RocmVlJ1xuICogICAgIGNhbGxiYWNrKG51bGwsICdkb25lJyk7XG4gKiB9XG4gKi9cbnZhciB3YXRlcmZhbGwgPSBmdW5jdGlvbih0YXNrcywgY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjayA9IG9uY2UoY2FsbGJhY2sgfHwgbm9vcCk7XG4gICAgaWYgKCFpc0FycmF5KHRhc2tzKSkgcmV0dXJuIGNhbGxiYWNrKG5ldyBFcnJvcignRmlyc3QgYXJndW1lbnQgdG8gd2F0ZXJmYWxsIG11c3QgYmUgYW4gYXJyYXkgb2YgZnVuY3Rpb25zJykpO1xuICAgIGlmICghdGFza3MubGVuZ3RoKSByZXR1cm4gY2FsbGJhY2soKTtcbiAgICB2YXIgdGFza0luZGV4ID0gMDtcblxuICAgIGZ1bmN0aW9uIG5leHRUYXNrKGFyZ3MpIHtcbiAgICAgICAgdmFyIHRhc2sgPSB3cmFwQXN5bmModGFza3NbdGFza0luZGV4KytdKTtcbiAgICAgICAgYXJncy5wdXNoKG9ubHlPbmNlKG5leHQpKTtcbiAgICAgICAgdGFzay5hcHBseShudWxsLCBhcmdzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBuZXh0KGVyci8qLCAuLi5hcmdzKi8pIHtcbiAgICAgICAgaWYgKGVyciB8fCB0YXNrSW5kZXggPT09IHRhc2tzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgbmV4dFRhc2soc2xpY2UoYXJndW1lbnRzLCAxKSk7XG4gICAgfVxuXG4gICAgbmV4dFRhc2soW10pO1xufTtcblxuLyoqXG4gKiBBbiBcImFzeW5jIGZ1bmN0aW9uXCIgaW4gdGhlIGNvbnRleHQgb2YgQXN5bmMgaXMgYW4gYXN5bmNocm9ub3VzIGZ1bmN0aW9uIHdpdGhcbiAqIGEgdmFyaWFibGUgbnVtYmVyIG9mIHBhcmFtZXRlcnMsIHdpdGggdGhlIGZpbmFsIHBhcmFtZXRlciBiZWluZyBhIGNhbGxiYWNrLlxuICogKGBmdW5jdGlvbiAoYXJnMSwgYXJnMiwgLi4uLCBjYWxsYmFjaykge31gKVxuICogVGhlIGZpbmFsIGNhbGxiYWNrIGlzIG9mIHRoZSBmb3JtIGBjYWxsYmFjayhlcnIsIHJlc3VsdHMuLi4pYCwgd2hpY2ggbXVzdCBiZVxuICogY2FsbGVkIG9uY2UgdGhlIGZ1bmN0aW9uIGlzIGNvbXBsZXRlZC4gIFRoZSBjYWxsYmFjayBzaG91bGQgYmUgY2FsbGVkIHdpdGggYVxuICogRXJyb3IgYXMgaXRzIGZpcnN0IGFyZ3VtZW50IHRvIHNpZ25hbCB0aGF0IGFuIGVycm9yIG9jY3VycmVkLlxuICogT3RoZXJ3aXNlLCBpZiBubyBlcnJvciBvY2N1cnJlZCwgaXQgc2hvdWxkIGJlIGNhbGxlZCB3aXRoIGBudWxsYCBhcyB0aGUgZmlyc3RcbiAqIGFyZ3VtZW50LCBhbmQgYW55IGFkZGl0aW9uYWwgYHJlc3VsdGAgYXJndW1lbnRzIHRoYXQgbWF5IGFwcGx5LCB0byBzaWduYWxcbiAqIHN1Y2Nlc3NmdWwgY29tcGxldGlvbi5cbiAqIFRoZSBjYWxsYmFjayBtdXN0IGJlIGNhbGxlZCBleGFjdGx5IG9uY2UsIGlkZWFsbHkgb24gYSBsYXRlciB0aWNrIG9mIHRoZVxuICogSmF2YVNjcmlwdCBldmVudCBsb29wLlxuICpcbiAqIFRoaXMgdHlwZSBvZiBmdW5jdGlvbiBpcyBhbHNvIHJlZmVycmVkIHRvIGFzIGEgXCJOb2RlLXN0eWxlIGFzeW5jIGZ1bmN0aW9uXCIsXG4gKiBvciBhIFwiY29udGludWF0aW9uIHBhc3Npbmctc3R5bGUgZnVuY3Rpb25cIiAoQ1BTKS4gTW9zdCBvZiB0aGUgbWV0aG9kcyBvZiB0aGlzXG4gKiBsaWJyYXJ5IGFyZSB0aGVtc2VsdmVzIENQUy9Ob2RlLXN0eWxlIGFzeW5jIGZ1bmN0aW9ucywgb3IgZnVuY3Rpb25zIHRoYXRcbiAqIHJldHVybiBDUFMvTm9kZS1zdHlsZSBhc3luYyBmdW5jdGlvbnMuXG4gKlxuICogV2hlcmV2ZXIgd2UgYWNjZXB0IGEgTm9kZS1zdHlsZSBhc3luYyBmdW5jdGlvbiwgd2UgYWxzbyBkaXJlY3RseSBhY2NlcHQgYW5cbiAqIFtFUzIwMTcgYGFzeW5jYCBmdW5jdGlvbl17QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvU3RhdGVtZW50cy9hc3luY19mdW5jdGlvbn0uXG4gKiBJbiB0aGlzIGNhc2UsIHRoZSBgYXN5bmNgIGZ1bmN0aW9uIHdpbGwgbm90IGJlIHBhc3NlZCBhIGZpbmFsIGNhbGxiYWNrXG4gKiBhcmd1bWVudCwgYW5kIGFueSB0aHJvd24gZXJyb3Igd2lsbCBiZSB1c2VkIGFzIHRoZSBgZXJyYCBhcmd1bWVudCBvZiB0aGVcbiAqIGltcGxpY2l0IGNhbGxiYWNrLCBhbmQgdGhlIHJldHVybiB2YWx1ZSB3aWxsIGJlIHVzZWQgYXMgdGhlIGByZXN1bHRgIHZhbHVlLlxuICogKGkuZS4gYSBgcmVqZWN0ZWRgIG9mIHRoZSByZXR1cm5lZCBQcm9taXNlIGJlY29tZXMgdGhlIGBlcnJgIGNhbGxiYWNrXG4gKiBhcmd1bWVudCwgYW5kIGEgYHJlc29sdmVkYCB2YWx1ZSBiZWNvbWVzIHRoZSBgcmVzdWx0YC4pXG4gKlxuICogTm90ZSwgZHVlIHRvIEphdmFTY3JpcHQgbGltaXRhdGlvbnMsIHdlIGNhbiBvbmx5IGRldGVjdCBuYXRpdmUgYGFzeW5jYFxuICogZnVuY3Rpb25zIGFuZCBub3QgdHJhbnNwaWxpZWQgaW1wbGVtZW50YXRpb25zLlxuICogWW91ciBlbnZpcm9ubWVudCBtdXN0IGhhdmUgYGFzeW5jYC9gYXdhaXRgIHN1cHBvcnQgZm9yIHRoaXMgdG8gd29yay5cbiAqIChlLmcuIE5vZGUgPiB2Ny42LCBvciBhIHJlY2VudCB2ZXJzaW9uIG9mIGEgbW9kZXJuIGJyb3dzZXIpLlxuICogSWYgeW91IGFyZSB1c2luZyBgYXN5bmNgIGZ1bmN0aW9ucyB0aHJvdWdoIGEgdHJhbnNwaWxlciAoZS5nLiBCYWJlbCksIHlvdVxuICogbXVzdCBzdGlsbCB3cmFwIHRoZSBmdW5jdGlvbiB3aXRoIFthc3luY2lmeV17QGxpbmsgbW9kdWxlOlV0aWxzLmFzeW5jaWZ5fSxcbiAqIGJlY2F1c2UgdGhlIGBhc3luYyBmdW5jdGlvbmAgd2lsbCBiZSBjb21waWxlZCB0byBhbiBvcmRpbmFyeSBmdW5jdGlvbiB0aGF0XG4gKiByZXR1cm5zIGEgcHJvbWlzZS5cbiAqXG4gKiBAdHlwZWRlZiB7RnVuY3Rpb259IEFzeW5jRnVuY3Rpb25cbiAqIEBzdGF0aWNcbiAqL1xuXG4vKipcbiAqIEFzeW5jIGlzIGEgdXRpbGl0eSBtb2R1bGUgd2hpY2ggcHJvdmlkZXMgc3RyYWlnaHQtZm9yd2FyZCwgcG93ZXJmdWwgZnVuY3Rpb25zXG4gKiBmb3Igd29ya2luZyB3aXRoIGFzeW5jaHJvbm91cyBKYXZhU2NyaXB0LiBBbHRob3VnaCBvcmlnaW5hbGx5IGRlc2lnbmVkIGZvclxuICogdXNlIHdpdGggW05vZGUuanNdKGh0dHA6Ly9ub2RlanMub3JnKSBhbmQgaW5zdGFsbGFibGUgdmlhXG4gKiBgbnBtIGluc3RhbGwgLS1zYXZlIGFzeW5jYCwgaXQgY2FuIGFsc28gYmUgdXNlZCBkaXJlY3RseSBpbiB0aGUgYnJvd3Nlci5cbiAqIEBtb2R1bGUgYXN5bmNcbiAqIEBzZWUgQXN5bmNGdW5jdGlvblxuICovXG5cblxuLyoqXG4gKiBBIGNvbGxlY3Rpb24gb2YgYGFzeW5jYCBmdW5jdGlvbnMgZm9yIG1hbmlwdWxhdGluZyBjb2xsZWN0aW9ucywgc3VjaCBhc1xuICogYXJyYXlzIGFuZCBvYmplY3RzLlxuICogQG1vZHVsZSBDb2xsZWN0aW9uc1xuICovXG5cbi8qKlxuICogQSBjb2xsZWN0aW9uIG9mIGBhc3luY2AgZnVuY3Rpb25zIGZvciBjb250cm9sbGluZyB0aGUgZmxvdyB0aHJvdWdoIGEgc2NyaXB0LlxuICogQG1vZHVsZSBDb250cm9sRmxvd1xuICovXG5cbi8qKlxuICogQSBjb2xsZWN0aW9uIG9mIGBhc3luY2AgdXRpbGl0eSBmdW5jdGlvbnMuXG4gKiBAbW9kdWxlIFV0aWxzXG4gKi9cblxudmFyIGluZGV4ID0ge1xuICAgIGFwcGx5OiBhcHBseSxcbiAgICBhcHBseUVhY2g6IGFwcGx5RWFjaCxcbiAgICBhcHBseUVhY2hTZXJpZXM6IGFwcGx5RWFjaFNlcmllcyxcbiAgICBhc3luY2lmeTogYXN5bmNpZnksXG4gICAgYXV0bzogYXV0byxcbiAgICBhdXRvSW5qZWN0OiBhdXRvSW5qZWN0LFxuICAgIGNhcmdvOiBjYXJnbyxcbiAgICBjb21wb3NlOiBjb21wb3NlLFxuICAgIGNvbmNhdDogY29uY2F0LFxuICAgIGNvbmNhdExpbWl0OiBjb25jYXRMaW1pdCxcbiAgICBjb25jYXRTZXJpZXM6IGNvbmNhdFNlcmllcyxcbiAgICBjb25zdGFudDogY29uc3RhbnQsXG4gICAgZGV0ZWN0OiBkZXRlY3QsXG4gICAgZGV0ZWN0TGltaXQ6IGRldGVjdExpbWl0LFxuICAgIGRldGVjdFNlcmllczogZGV0ZWN0U2VyaWVzLFxuICAgIGRpcjogZGlyLFxuICAgIGRvRHVyaW5nOiBkb0R1cmluZyxcbiAgICBkb1VudGlsOiBkb1VudGlsLFxuICAgIGRvV2hpbHN0OiBkb1doaWxzdCxcbiAgICBkdXJpbmc6IGR1cmluZyxcbiAgICBlYWNoOiBlYWNoTGltaXQsXG4gICAgZWFjaExpbWl0OiBlYWNoTGltaXQkMSxcbiAgICBlYWNoT2Y6IGVhY2hPZixcbiAgICBlYWNoT2ZMaW1pdDogZWFjaE9mTGltaXQsXG4gICAgZWFjaE9mU2VyaWVzOiBlYWNoT2ZTZXJpZXMsXG4gICAgZWFjaFNlcmllczogZWFjaFNlcmllcyxcbiAgICBlbnN1cmVBc3luYzogZW5zdXJlQXN5bmMsXG4gICAgZXZlcnk6IGV2ZXJ5LFxuICAgIGV2ZXJ5TGltaXQ6IGV2ZXJ5TGltaXQsXG4gICAgZXZlcnlTZXJpZXM6IGV2ZXJ5U2VyaWVzLFxuICAgIGZpbHRlcjogZmlsdGVyLFxuICAgIGZpbHRlckxpbWl0OiBmaWx0ZXJMaW1pdCxcbiAgICBmaWx0ZXJTZXJpZXM6IGZpbHRlclNlcmllcyxcbiAgICBmb3JldmVyOiBmb3JldmVyLFxuICAgIGdyb3VwQnk6IGdyb3VwQnksXG4gICAgZ3JvdXBCeUxpbWl0OiBncm91cEJ5TGltaXQsXG4gICAgZ3JvdXBCeVNlcmllczogZ3JvdXBCeVNlcmllcyxcbiAgICBsb2c6IGxvZyxcbiAgICBtYXA6IG1hcCxcbiAgICBtYXBMaW1pdDogbWFwTGltaXQsXG4gICAgbWFwU2VyaWVzOiBtYXBTZXJpZXMsXG4gICAgbWFwVmFsdWVzOiBtYXBWYWx1ZXMsXG4gICAgbWFwVmFsdWVzTGltaXQ6IG1hcFZhbHVlc0xpbWl0LFxuICAgIG1hcFZhbHVlc1NlcmllczogbWFwVmFsdWVzU2VyaWVzLFxuICAgIG1lbW9pemU6IG1lbW9pemUsXG4gICAgbmV4dFRpY2s6IG5leHRUaWNrLFxuICAgIHBhcmFsbGVsOiBwYXJhbGxlbExpbWl0LFxuICAgIHBhcmFsbGVsTGltaXQ6IHBhcmFsbGVsTGltaXQkMSxcbiAgICBwcmlvcml0eVF1ZXVlOiBwcmlvcml0eVF1ZXVlLFxuICAgIHF1ZXVlOiBxdWV1ZSQxLFxuICAgIHJhY2U6IHJhY2UsXG4gICAgcmVkdWNlOiByZWR1Y2UsXG4gICAgcmVkdWNlUmlnaHQ6IHJlZHVjZVJpZ2h0LFxuICAgIHJlZmxlY3Q6IHJlZmxlY3QsXG4gICAgcmVmbGVjdEFsbDogcmVmbGVjdEFsbCxcbiAgICByZWplY3Q6IHJlamVjdCxcbiAgICByZWplY3RMaW1pdDogcmVqZWN0TGltaXQsXG4gICAgcmVqZWN0U2VyaWVzOiByZWplY3RTZXJpZXMsXG4gICAgcmV0cnk6IHJldHJ5LFxuICAgIHJldHJ5YWJsZTogcmV0cnlhYmxlLFxuICAgIHNlcTogc2VxLFxuICAgIHNlcmllczogc2VyaWVzLFxuICAgIHNldEltbWVkaWF0ZTogc2V0SW1tZWRpYXRlJDEsXG4gICAgc29tZTogc29tZSxcbiAgICBzb21lTGltaXQ6IHNvbWVMaW1pdCxcbiAgICBzb21lU2VyaWVzOiBzb21lU2VyaWVzLFxuICAgIHNvcnRCeTogc29ydEJ5LFxuICAgIHRpbWVvdXQ6IHRpbWVvdXQsXG4gICAgdGltZXM6IHRpbWVzLFxuICAgIHRpbWVzTGltaXQ6IHRpbWVMaW1pdCxcbiAgICB0aW1lc1NlcmllczogdGltZXNTZXJpZXMsXG4gICAgdHJhbnNmb3JtOiB0cmFuc2Zvcm0sXG4gICAgdHJ5RWFjaDogdHJ5RWFjaCxcbiAgICB1bm1lbW9pemU6IHVubWVtb2l6ZSxcbiAgICB1bnRpbDogdW50aWwsXG4gICAgd2F0ZXJmYWxsOiB3YXRlcmZhbGwsXG4gICAgd2hpbHN0OiB3aGlsc3QsXG5cbiAgICAvLyBhbGlhc2VzXG4gICAgYWxsOiBldmVyeSxcbiAgICBhbGxMaW1pdDogZXZlcnlMaW1pdCxcbiAgICBhbGxTZXJpZXM6IGV2ZXJ5U2VyaWVzLFxuICAgIGFueTogc29tZSxcbiAgICBhbnlMaW1pdDogc29tZUxpbWl0LFxuICAgIGFueVNlcmllczogc29tZVNlcmllcyxcbiAgICBmaW5kOiBkZXRlY3QsXG4gICAgZmluZExpbWl0OiBkZXRlY3RMaW1pdCxcbiAgICBmaW5kU2VyaWVzOiBkZXRlY3RTZXJpZXMsXG4gICAgZm9yRWFjaDogZWFjaExpbWl0LFxuICAgIGZvckVhY2hTZXJpZXM6IGVhY2hTZXJpZXMsXG4gICAgZm9yRWFjaExpbWl0OiBlYWNoTGltaXQkMSxcbiAgICBmb3JFYWNoT2Y6IGVhY2hPZixcbiAgICBmb3JFYWNoT2ZTZXJpZXM6IGVhY2hPZlNlcmllcyxcbiAgICBmb3JFYWNoT2ZMaW1pdDogZWFjaE9mTGltaXQsXG4gICAgaW5qZWN0OiByZWR1Y2UsXG4gICAgZm9sZGw6IHJlZHVjZSxcbiAgICBmb2xkcjogcmVkdWNlUmlnaHQsXG4gICAgc2VsZWN0OiBmaWx0ZXIsXG4gICAgc2VsZWN0TGltaXQ6IGZpbHRlckxpbWl0LFxuICAgIHNlbGVjdFNlcmllczogZmlsdGVyU2VyaWVzLFxuICAgIHdyYXBTeW5jOiBhc3luY2lmeVxufTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gaW5kZXg7XG5leHBvcnRzLmFwcGx5ID0gYXBwbHk7XG5leHBvcnRzLmFwcGx5RWFjaCA9IGFwcGx5RWFjaDtcbmV4cG9ydHMuYXBwbHlFYWNoU2VyaWVzID0gYXBwbHlFYWNoU2VyaWVzO1xuZXhwb3J0cy5hc3luY2lmeSA9IGFzeW5jaWZ5O1xuZXhwb3J0cy5hdXRvID0gYXV0bztcbmV4cG9ydHMuYXV0b0luamVjdCA9IGF1dG9JbmplY3Q7XG5leHBvcnRzLmNhcmdvID0gY2FyZ287XG5leHBvcnRzLmNvbXBvc2UgPSBjb21wb3NlO1xuZXhwb3J0cy5jb25jYXQgPSBjb25jYXQ7XG5leHBvcnRzLmNvbmNhdExpbWl0ID0gY29uY2F0TGltaXQ7XG5leHBvcnRzLmNvbmNhdFNlcmllcyA9IGNvbmNhdFNlcmllcztcbmV4cG9ydHMuY29uc3RhbnQgPSBjb25zdGFudDtcbmV4cG9ydHMuZGV0ZWN0ID0gZGV0ZWN0O1xuZXhwb3J0cy5kZXRlY3RMaW1pdCA9IGRldGVjdExpbWl0O1xuZXhwb3J0cy5kZXRlY3RTZXJpZXMgPSBkZXRlY3RTZXJpZXM7XG5leHBvcnRzLmRpciA9IGRpcjtcbmV4cG9ydHMuZG9EdXJpbmcgPSBkb0R1cmluZztcbmV4cG9ydHMuZG9VbnRpbCA9IGRvVW50aWw7XG5leHBvcnRzLmRvV2hpbHN0ID0gZG9XaGlsc3Q7XG5leHBvcnRzLmR1cmluZyA9IGR1cmluZztcbmV4cG9ydHMuZWFjaCA9IGVhY2hMaW1pdDtcbmV4cG9ydHMuZWFjaExpbWl0ID0gZWFjaExpbWl0JDE7XG5leHBvcnRzLmVhY2hPZiA9IGVhY2hPZjtcbmV4cG9ydHMuZWFjaE9mTGltaXQgPSBlYWNoT2ZMaW1pdDtcbmV4cG9ydHMuZWFjaE9mU2VyaWVzID0gZWFjaE9mU2VyaWVzO1xuZXhwb3J0cy5lYWNoU2VyaWVzID0gZWFjaFNlcmllcztcbmV4cG9ydHMuZW5zdXJlQXN5bmMgPSBlbnN1cmVBc3luYztcbmV4cG9ydHMuZXZlcnkgPSBldmVyeTtcbmV4cG9ydHMuZXZlcnlMaW1pdCA9IGV2ZXJ5TGltaXQ7XG5leHBvcnRzLmV2ZXJ5U2VyaWVzID0gZXZlcnlTZXJpZXM7XG5leHBvcnRzLmZpbHRlciA9IGZpbHRlcjtcbmV4cG9ydHMuZmlsdGVyTGltaXQgPSBmaWx0ZXJMaW1pdDtcbmV4cG9ydHMuZmlsdGVyU2VyaWVzID0gZmlsdGVyU2VyaWVzO1xuZXhwb3J0cy5mb3JldmVyID0gZm9yZXZlcjtcbmV4cG9ydHMuZ3JvdXBCeSA9IGdyb3VwQnk7XG5leHBvcnRzLmdyb3VwQnlMaW1pdCA9IGdyb3VwQnlMaW1pdDtcbmV4cG9ydHMuZ3JvdXBCeVNlcmllcyA9IGdyb3VwQnlTZXJpZXM7XG5leHBvcnRzLmxvZyA9IGxvZztcbmV4cG9ydHMubWFwID0gbWFwO1xuZXhwb3J0cy5tYXBMaW1pdCA9IG1hcExpbWl0O1xuZXhwb3J0cy5tYXBTZXJpZXMgPSBtYXBTZXJpZXM7XG5leHBvcnRzLm1hcFZhbHVlcyA9IG1hcFZhbHVlcztcbmV4cG9ydHMubWFwVmFsdWVzTGltaXQgPSBtYXBWYWx1ZXNMaW1pdDtcbmV4cG9ydHMubWFwVmFsdWVzU2VyaWVzID0gbWFwVmFsdWVzU2VyaWVzO1xuZXhwb3J0cy5tZW1vaXplID0gbWVtb2l6ZTtcbmV4cG9ydHMubmV4dFRpY2sgPSBuZXh0VGljaztcbmV4cG9ydHMucGFyYWxsZWwgPSBwYXJhbGxlbExpbWl0O1xuZXhwb3J0cy5wYXJhbGxlbExpbWl0ID0gcGFyYWxsZWxMaW1pdCQxO1xuZXhwb3J0cy5wcmlvcml0eVF1ZXVlID0gcHJpb3JpdHlRdWV1ZTtcbmV4cG9ydHMucXVldWUgPSBxdWV1ZSQxO1xuZXhwb3J0cy5yYWNlID0gcmFjZTtcbmV4cG9ydHMucmVkdWNlID0gcmVkdWNlO1xuZXhwb3J0cy5yZWR1Y2VSaWdodCA9IHJlZHVjZVJpZ2h0O1xuZXhwb3J0cy5yZWZsZWN0ID0gcmVmbGVjdDtcbmV4cG9ydHMucmVmbGVjdEFsbCA9IHJlZmxlY3RBbGw7XG5leHBvcnRzLnJlamVjdCA9IHJlamVjdDtcbmV4cG9ydHMucmVqZWN0TGltaXQgPSByZWplY3RMaW1pdDtcbmV4cG9ydHMucmVqZWN0U2VyaWVzID0gcmVqZWN0U2VyaWVzO1xuZXhwb3J0cy5yZXRyeSA9IHJldHJ5O1xuZXhwb3J0cy5yZXRyeWFibGUgPSByZXRyeWFibGU7XG5leHBvcnRzLnNlcSA9IHNlcTtcbmV4cG9ydHMuc2VyaWVzID0gc2VyaWVzO1xuZXhwb3J0cy5zZXRJbW1lZGlhdGUgPSBzZXRJbW1lZGlhdGUkMTtcbmV4cG9ydHMuc29tZSA9IHNvbWU7XG5leHBvcnRzLnNvbWVMaW1pdCA9IHNvbWVMaW1pdDtcbmV4cG9ydHMuc29tZVNlcmllcyA9IHNvbWVTZXJpZXM7XG5leHBvcnRzLnNvcnRCeSA9IHNvcnRCeTtcbmV4cG9ydHMudGltZW91dCA9IHRpbWVvdXQ7XG5leHBvcnRzLnRpbWVzID0gdGltZXM7XG5leHBvcnRzLnRpbWVzTGltaXQgPSB0aW1lTGltaXQ7XG5leHBvcnRzLnRpbWVzU2VyaWVzID0gdGltZXNTZXJpZXM7XG5leHBvcnRzLnRyYW5zZm9ybSA9IHRyYW5zZm9ybTtcbmV4cG9ydHMudHJ5RWFjaCA9IHRyeUVhY2g7XG5leHBvcnRzLnVubWVtb2l6ZSA9IHVubWVtb2l6ZTtcbmV4cG9ydHMudW50aWwgPSB1bnRpbDtcbmV4cG9ydHMud2F0ZXJmYWxsID0gd2F0ZXJmYWxsO1xuZXhwb3J0cy53aGlsc3QgPSB3aGlsc3Q7XG5leHBvcnRzLmFsbCA9IGV2ZXJ5O1xuZXhwb3J0cy5hbGxMaW1pdCA9IGV2ZXJ5TGltaXQ7XG5leHBvcnRzLmFsbFNlcmllcyA9IGV2ZXJ5U2VyaWVzO1xuZXhwb3J0cy5hbnkgPSBzb21lO1xuZXhwb3J0cy5hbnlMaW1pdCA9IHNvbWVMaW1pdDtcbmV4cG9ydHMuYW55U2VyaWVzID0gc29tZVNlcmllcztcbmV4cG9ydHMuZmluZCA9IGRldGVjdDtcbmV4cG9ydHMuZmluZExpbWl0ID0gZGV0ZWN0TGltaXQ7XG5leHBvcnRzLmZpbmRTZXJpZXMgPSBkZXRlY3RTZXJpZXM7XG5leHBvcnRzLmZvckVhY2ggPSBlYWNoTGltaXQ7XG5leHBvcnRzLmZvckVhY2hTZXJpZXMgPSBlYWNoU2VyaWVzO1xuZXhwb3J0cy5mb3JFYWNoTGltaXQgPSBlYWNoTGltaXQkMTtcbmV4cG9ydHMuZm9yRWFjaE9mID0gZWFjaE9mO1xuZXhwb3J0cy5mb3JFYWNoT2ZTZXJpZXMgPSBlYWNoT2ZTZXJpZXM7XG5leHBvcnRzLmZvckVhY2hPZkxpbWl0ID0gZWFjaE9mTGltaXQ7XG5leHBvcnRzLmluamVjdCA9IHJlZHVjZTtcbmV4cG9ydHMuZm9sZGwgPSByZWR1Y2U7XG5leHBvcnRzLmZvbGRyID0gcmVkdWNlUmlnaHQ7XG5leHBvcnRzLnNlbGVjdCA9IGZpbHRlcjtcbmV4cG9ydHMuc2VsZWN0TGltaXQgPSBmaWx0ZXJMaW1pdDtcbmV4cG9ydHMuc2VsZWN0U2VyaWVzID0gZmlsdGVyU2VyaWVzO1xuZXhwb3J0cy53cmFwU3luYyA9IGFzeW5jaWZ5O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG59KSkpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/async/dist/async.js\n");

/***/ }),

/***/ "./node_modules/balanced-match/index.js":
/*!**********************************************!*\
  !*** ./node_modules/balanced-match/index.js ***!
  \**********************************************/
/***/ ((module) => {

"use strict";
eval("\nmodule.exports = balanced;\nfunction balanced(a, b, str) {\n  if (a instanceof RegExp) a = maybeMatch(a, str);\n  if (b instanceof RegExp) b = maybeMatch(b, str);\n\n  var r = range(a, b, str);\n\n  return r && {\n    start: r[0],\n    end: r[1],\n    pre: str.slice(0, r[0]),\n    body: str.slice(r[0] + a.length, r[1]),\n    post: str.slice(r[1] + b.length)\n  };\n}\n\nfunction maybeMatch(reg, str) {\n  var m = str.match(reg);\n  return m ? m[0] : null;\n}\n\nbalanced.range = range;\nfunction range(a, b, str) {\n  var begs, beg, left, right, result;\n  var ai = str.indexOf(a);\n  var bi = str.indexOf(b, ai + 1);\n  var i = ai;\n\n  if (ai >= 0 && bi > 0) {\n    if(a===b) {\n      return [ai, bi];\n    }\n    begs = [];\n    left = str.length;\n\n    while (i >= 0 && !result) {\n      if (i == ai) {\n        begs.push(i);\n        ai = str.indexOf(a, i + 1);\n      } else if (begs.length == 1) {\n        result = [ begs.pop(), bi ];\n      } else {\n        beg = begs.pop();\n        if (beg < left) {\n          left = beg;\n          right = bi;\n        }\n\n        bi = str.indexOf(b, i + 1);\n      }\n\n      i = ai < bi && ai >= 0 ? ai : bi;\n    }\n\n    if (begs.length) {\n      result = [ left, right ];\n    }\n  }\n\n  return result;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYmFsYW5jZWQtbWF0Y2gvaW5kZXguanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3RvZG8tbGlzdC8uL25vZGVfbW9kdWxlcy9iYWxhbmNlZC1tYXRjaC9pbmRleC5qcz85MWIwIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0Jztcbm1vZHVsZS5leHBvcnRzID0gYmFsYW5jZWQ7XG5mdW5jdGlvbiBiYWxhbmNlZChhLCBiLCBzdHIpIHtcbiAgaWYgKGEgaW5zdGFuY2VvZiBSZWdFeHApIGEgPSBtYXliZU1hdGNoKGEsIHN0cik7XG4gIGlmIChiIGluc3RhbmNlb2YgUmVnRXhwKSBiID0gbWF5YmVNYXRjaChiLCBzdHIpO1xuXG4gIHZhciByID0gcmFuZ2UoYSwgYiwgc3RyKTtcblxuICByZXR1cm4gciAmJiB7XG4gICAgc3RhcnQ6IHJbMF0sXG4gICAgZW5kOiByWzFdLFxuICAgIHByZTogc3RyLnNsaWNlKDAsIHJbMF0pLFxuICAgIGJvZHk6IHN0ci5zbGljZShyWzBdICsgYS5sZW5ndGgsIHJbMV0pLFxuICAgIHBvc3Q6IHN0ci5zbGljZShyWzFdICsgYi5sZW5ndGgpXG4gIH07XG59XG5cbmZ1bmN0aW9uIG1heWJlTWF0Y2gocmVnLCBzdHIpIHtcbiAgdmFyIG0gPSBzdHIubWF0Y2gocmVnKTtcbiAgcmV0dXJuIG0gPyBtWzBdIDogbnVsbDtcbn1cblxuYmFsYW5jZWQucmFuZ2UgPSByYW5nZTtcbmZ1bmN0aW9uIHJhbmdlKGEsIGIsIHN0cikge1xuICB2YXIgYmVncywgYmVnLCBsZWZ0LCByaWdodCwgcmVzdWx0O1xuICB2YXIgYWkgPSBzdHIuaW5kZXhPZihhKTtcbiAgdmFyIGJpID0gc3RyLmluZGV4T2YoYiwgYWkgKyAxKTtcbiAgdmFyIGkgPSBhaTtcblxuICBpZiAoYWkgPj0gMCAmJiBiaSA+IDApIHtcbiAgICBpZihhPT09Yikge1xuICAgICAgcmV0dXJuIFthaSwgYmldO1xuICAgIH1cbiAgICBiZWdzID0gW107XG4gICAgbGVmdCA9IHN0ci5sZW5ndGg7XG5cbiAgICB3aGlsZSAoaSA+PSAwICYmICFyZXN1bHQpIHtcbiAgICAgIGlmIChpID09IGFpKSB7XG4gICAgICAgIGJlZ3MucHVzaChpKTtcbiAgICAgICAgYWkgPSBzdHIuaW5kZXhPZihhLCBpICsgMSk7XG4gICAgICB9IGVsc2UgaWYgKGJlZ3MubGVuZ3RoID09IDEpIHtcbiAgICAgICAgcmVzdWx0ID0gWyBiZWdzLnBvcCgpLCBiaSBdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYmVnID0gYmVncy5wb3AoKTtcbiAgICAgICAgaWYgKGJlZyA8IGxlZnQpIHtcbiAgICAgICAgICBsZWZ0ID0gYmVnO1xuICAgICAgICAgIHJpZ2h0ID0gYmk7XG4gICAgICAgIH1cblxuICAgICAgICBiaSA9IHN0ci5pbmRleE9mKGIsIGkgKyAxKTtcbiAgICAgIH1cblxuICAgICAgaSA9IGFpIDwgYmkgJiYgYWkgPj0gMCA/IGFpIDogYmk7XG4gICAgfVxuXG4gICAgaWYgKGJlZ3MubGVuZ3RoKSB7XG4gICAgICByZXN1bHQgPSBbIGxlZnQsIHJpZ2h0IF07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/balanced-match/index.js\n");

/***/ }),

/***/ "./node_modules/brace-expansion/index.js":
/*!***********************************************!*\
  !*** ./node_modules/brace-expansion/index.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var concatMap = __webpack_require__(/*! concat-map */ \"./node_modules/concat-map/index.js\");\nvar balanced = __webpack_require__(/*! balanced-match */ \"./node_modules/balanced-match/index.js\");\n\nmodule.exports = expandTop;\n\nvar escSlash = '\\0SLASH'+Math.random()+'\\0';\nvar escOpen = '\\0OPEN'+Math.random()+'\\0';\nvar escClose = '\\0CLOSE'+Math.random()+'\\0';\nvar escComma = '\\0COMMA'+Math.random()+'\\0';\nvar escPeriod = '\\0PERIOD'+Math.random()+'\\0';\n\nfunction numeric(str) {\n  return parseInt(str, 10) == str\n    ? parseInt(str, 10)\n    : str.charCodeAt(0);\n}\n\nfunction escapeBraces(str) {\n  return str.split('\\\\\\\\').join(escSlash)\n            .split('\\\\{').join(escOpen)\n            .split('\\\\}').join(escClose)\n            .split('\\\\,').join(escComma)\n            .split('\\\\.').join(escPeriod);\n}\n\nfunction unescapeBraces(str) {\n  return str.split(escSlash).join('\\\\')\n            .split(escOpen).join('{')\n            .split(escClose).join('}')\n            .split(escComma).join(',')\n            .split(escPeriod).join('.');\n}\n\n\n// Basically just str.split(\",\"), but handling cases\n// where we have nested braced sections, which should be\n// treated as individual members, like {a,{b,c},d}\nfunction parseCommaParts(str) {\n  if (!str)\n    return [''];\n\n  var parts = [];\n  var m = balanced('{', '}', str);\n\n  if (!m)\n    return str.split(',');\n\n  var pre = m.pre;\n  var body = m.body;\n  var post = m.post;\n  var p = pre.split(',');\n\n  p[p.length-1] += '{' + body + '}';\n  var postParts = parseCommaParts(post);\n  if (post.length) {\n    p[p.length-1] += postParts.shift();\n    p.push.apply(p, postParts);\n  }\n\n  parts.push.apply(parts, p);\n\n  return parts;\n}\n\nfunction expandTop(str) {\n  if (!str)\n    return [];\n\n  // I don't know why Bash 4.3 does this, but it does.\n  // Anything starting with {} will have the first two bytes preserved\n  // but *only* at the top level, so {},a}b will not expand to anything,\n  // but a{},b}c will be expanded to [a}c,abc].\n  // One could argue that this is a bug in Bash, but since the goal of\n  // this module is to match Bash's rules, we escape a leading {}\n  if (str.substr(0, 2) === '{}') {\n    str = '\\\\{\\\\}' + str.substr(2);\n  }\n\n  return expand(escapeBraces(str), true).map(unescapeBraces);\n}\n\nfunction identity(e) {\n  return e;\n}\n\nfunction embrace(str) {\n  return '{' + str + '}';\n}\nfunction isPadded(el) {\n  return /^-?0\\d/.test(el);\n}\n\nfunction lte(i, y) {\n  return i <= y;\n}\nfunction gte(i, y) {\n  return i >= y;\n}\n\nfunction expand(str, isTop) {\n  var expansions = [];\n\n  var m = balanced('{', '}', str);\n  if (!m || /\\$$/.test(m.pre)) return [str];\n\n  var isNumericSequence = /^-?\\d+\\.\\.-?\\d+(?:\\.\\.-?\\d+)?$/.test(m.body);\n  var isAlphaSequence = /^[a-zA-Z]\\.\\.[a-zA-Z](?:\\.\\.-?\\d+)?$/.test(m.body);\n  var isSequence = isNumericSequence || isAlphaSequence;\n  var isOptions = m.body.indexOf(',') >= 0;\n  if (!isSequence && !isOptions) {\n    // {a},b}\n    if (m.post.match(/,.*\\}/)) {\n      str = m.pre + '{' + m.body + escClose + m.post;\n      return expand(str);\n    }\n    return [str];\n  }\n\n  var n;\n  if (isSequence) {\n    n = m.body.split(/\\.\\./);\n  } else {\n    n = parseCommaParts(m.body);\n    if (n.length === 1) {\n      // x{{a,b}}y ==> x{a}y x{b}y\n      n = expand(n[0], false).map(embrace);\n      if (n.length === 1) {\n        var post = m.post.length\n          ? expand(m.post, false)\n          : [''];\n        return post.map(function(p) {\n          return m.pre + n[0] + p;\n        });\n      }\n    }\n  }\n\n  // at this point, n is the parts, and we know it's not a comma set\n  // with a single entry.\n\n  // no need to expand pre, since it is guaranteed to be free of brace-sets\n  var pre = m.pre;\n  var post = m.post.length\n    ? expand(m.post, false)\n    : [''];\n\n  var N;\n\n  if (isSequence) {\n    var x = numeric(n[0]);\n    var y = numeric(n[1]);\n    var width = Math.max(n[0].length, n[1].length)\n    var incr = n.length == 3\n      ? Math.abs(numeric(n[2]))\n      : 1;\n    var test = lte;\n    var reverse = y < x;\n    if (reverse) {\n      incr *= -1;\n      test = gte;\n    }\n    var pad = n.some(isPadded);\n\n    N = [];\n\n    for (var i = x; test(i, y); i += incr) {\n      var c;\n      if (isAlphaSequence) {\n        c = String.fromCharCode(i);\n        if (c === '\\\\')\n          c = '';\n      } else {\n        c = String(i);\n        if (pad) {\n          var need = width - c.length;\n          if (need > 0) {\n            var z = new Array(need + 1).join('0');\n            if (i < 0)\n              c = '-' + z + c.slice(1);\n            else\n              c = z + c;\n          }\n        }\n      }\n      N.push(c);\n    }\n  } else {\n    N = concatMap(n, function(el) { return expand(el, false) });\n  }\n\n  for (var j = 0; j < N.length; j++) {\n    for (var k = 0; k < post.length; k++) {\n      var expansion = pre + N[j] + post[k];\n      if (!isTop || isSequence || expansion)\n        expansions.push(expansion);\n    }\n  }\n\n  return expansions;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYnJhY2UtZXhwYW5zaW9uL2luZGV4LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBLGdCQUFnQixtQkFBTyxDQUFDLHNEQUFZO0FBQ3BDLGVBQWUsbUJBQU8sQ0FBQyw4REFBZ0I7O0FBRXZDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1DQUFtQztBQUNuQyxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0Esd0NBQXdDLEdBQUcsSUFBSTtBQUMvQztBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUIsS0FBSzs7QUFFMUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIsYUFBYTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsK0JBQStCO0FBQy9CLHVDQUF1QyxHQUFHO0FBQzFDLFlBQVksR0FBRyx5QkFBeUI7QUFDeEM7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QixjQUFjLEdBQUc7QUFDakI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLFlBQVk7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEscUJBQXFCLEtBQUs7QUFDMUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsRUFBRTtBQUNWLDJCQUEyQjtBQUMzQixzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxZQUFZLEtBQUssUUFBUSxFQUFFLElBQUksRUFBRTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsb0JBQW9CLFlBQVk7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLG9DQUFvQywwQkFBMEI7QUFDOUQ7O0FBRUEsa0JBQWtCLGNBQWM7QUFDaEMsb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90b2RvLWxpc3QvLi9ub2RlX21vZHVsZXMvYnJhY2UtZXhwYW5zaW9uL2luZGV4LmpzPzRlZTAiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGNvbmNhdE1hcCA9IHJlcXVpcmUoJ2NvbmNhdC1tYXAnKTtcbnZhciBiYWxhbmNlZCA9IHJlcXVpcmUoJ2JhbGFuY2VkLW1hdGNoJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwYW5kVG9wO1xuXG52YXIgZXNjU2xhc2ggPSAnXFwwU0xBU0gnK01hdGgucmFuZG9tKCkrJ1xcMCc7XG52YXIgZXNjT3BlbiA9ICdcXDBPUEVOJytNYXRoLnJhbmRvbSgpKydcXDAnO1xudmFyIGVzY0Nsb3NlID0gJ1xcMENMT1NFJytNYXRoLnJhbmRvbSgpKydcXDAnO1xudmFyIGVzY0NvbW1hID0gJ1xcMENPTU1BJytNYXRoLnJhbmRvbSgpKydcXDAnO1xudmFyIGVzY1BlcmlvZCA9ICdcXDBQRVJJT0QnK01hdGgucmFuZG9tKCkrJ1xcMCc7XG5cbmZ1bmN0aW9uIG51bWVyaWMoc3RyKSB7XG4gIHJldHVybiBwYXJzZUludChzdHIsIDEwKSA9PSBzdHJcbiAgICA/IHBhcnNlSW50KHN0ciwgMTApXG4gICAgOiBzdHIuY2hhckNvZGVBdCgwKTtcbn1cblxuZnVuY3Rpb24gZXNjYXBlQnJhY2VzKHN0cikge1xuICByZXR1cm4gc3RyLnNwbGl0KCdcXFxcXFxcXCcpLmpvaW4oZXNjU2xhc2gpXG4gICAgICAgICAgICAuc3BsaXQoJ1xcXFx7Jykuam9pbihlc2NPcGVuKVxuICAgICAgICAgICAgLnNwbGl0KCdcXFxcfScpLmpvaW4oZXNjQ2xvc2UpXG4gICAgICAgICAgICAuc3BsaXQoJ1xcXFwsJykuam9pbihlc2NDb21tYSlcbiAgICAgICAgICAgIC5zcGxpdCgnXFxcXC4nKS5qb2luKGVzY1BlcmlvZCk7XG59XG5cbmZ1bmN0aW9uIHVuZXNjYXBlQnJhY2VzKHN0cikge1xuICByZXR1cm4gc3RyLnNwbGl0KGVzY1NsYXNoKS5qb2luKCdcXFxcJylcbiAgICAgICAgICAgIC5zcGxpdChlc2NPcGVuKS5qb2luKCd7JylcbiAgICAgICAgICAgIC5zcGxpdChlc2NDbG9zZSkuam9pbignfScpXG4gICAgICAgICAgICAuc3BsaXQoZXNjQ29tbWEpLmpvaW4oJywnKVxuICAgICAgICAgICAgLnNwbGl0KGVzY1BlcmlvZCkuam9pbignLicpO1xufVxuXG5cbi8vIEJhc2ljYWxseSBqdXN0IHN0ci5zcGxpdChcIixcIiksIGJ1dCBoYW5kbGluZyBjYXNlc1xuLy8gd2hlcmUgd2UgaGF2ZSBuZXN0ZWQgYnJhY2VkIHNlY3Rpb25zLCB3aGljaCBzaG91bGQgYmVcbi8vIHRyZWF0ZWQgYXMgaW5kaXZpZHVhbCBtZW1iZXJzLCBsaWtlIHthLHtiLGN9LGR9XG5mdW5jdGlvbiBwYXJzZUNvbW1hUGFydHMoc3RyKSB7XG4gIGlmICghc3RyKVxuICAgIHJldHVybiBbJyddO1xuXG4gIHZhciBwYXJ0cyA9IFtdO1xuICB2YXIgbSA9IGJhbGFuY2VkKCd7JywgJ30nLCBzdHIpO1xuXG4gIGlmICghbSlcbiAgICByZXR1cm4gc3RyLnNwbGl0KCcsJyk7XG5cbiAgdmFyIHByZSA9IG0ucHJlO1xuICB2YXIgYm9keSA9IG0uYm9keTtcbiAgdmFyIHBvc3QgPSBtLnBvc3Q7XG4gIHZhciBwID0gcHJlLnNwbGl0KCcsJyk7XG5cbiAgcFtwLmxlbmd0aC0xXSArPSAneycgKyBib2R5ICsgJ30nO1xuICB2YXIgcG9zdFBhcnRzID0gcGFyc2VDb21tYVBhcnRzKHBvc3QpO1xuICBpZiAocG9zdC5sZW5ndGgpIHtcbiAgICBwW3AubGVuZ3RoLTFdICs9IHBvc3RQYXJ0cy5zaGlmdCgpO1xuICAgIHAucHVzaC5hcHBseShwLCBwb3N0UGFydHMpO1xuICB9XG5cbiAgcGFydHMucHVzaC5hcHBseShwYXJ0cywgcCk7XG5cbiAgcmV0dXJuIHBhcnRzO1xufVxuXG5mdW5jdGlvbiBleHBhbmRUb3Aoc3RyKSB7XG4gIGlmICghc3RyKVxuICAgIHJldHVybiBbXTtcblxuICAvLyBJIGRvbid0IGtub3cgd2h5IEJhc2ggNC4zIGRvZXMgdGhpcywgYnV0IGl0IGRvZXMuXG4gIC8vIEFueXRoaW5nIHN0YXJ0aW5nIHdpdGgge30gd2lsbCBoYXZlIHRoZSBmaXJzdCB0d28gYnl0ZXMgcHJlc2VydmVkXG4gIC8vIGJ1dCAqb25seSogYXQgdGhlIHRvcCBsZXZlbCwgc28ge30sYX1iIHdpbGwgbm90IGV4cGFuZCB0byBhbnl0aGluZyxcbiAgLy8gYnV0IGF7fSxifWMgd2lsbCBiZSBleHBhbmRlZCB0byBbYX1jLGFiY10uXG4gIC8vIE9uZSBjb3VsZCBhcmd1ZSB0aGF0IHRoaXMgaXMgYSBidWcgaW4gQmFzaCwgYnV0IHNpbmNlIHRoZSBnb2FsIG9mXG4gIC8vIHRoaXMgbW9kdWxlIGlzIHRvIG1hdGNoIEJhc2gncyBydWxlcywgd2UgZXNjYXBlIGEgbGVhZGluZyB7fVxuICBpZiAoc3RyLnN1YnN0cigwLCAyKSA9PT0gJ3t9Jykge1xuICAgIHN0ciA9ICdcXFxce1xcXFx9JyArIHN0ci5zdWJzdHIoMik7XG4gIH1cblxuICByZXR1cm4gZXhwYW5kKGVzY2FwZUJyYWNlcyhzdHIpLCB0cnVlKS5tYXAodW5lc2NhcGVCcmFjZXMpO1xufVxuXG5mdW5jdGlvbiBpZGVudGl0eShlKSB7XG4gIHJldHVybiBlO1xufVxuXG5mdW5jdGlvbiBlbWJyYWNlKHN0cikge1xuICByZXR1cm4gJ3snICsgc3RyICsgJ30nO1xufVxuZnVuY3Rpb24gaXNQYWRkZWQoZWwpIHtcbiAgcmV0dXJuIC9eLT8wXFxkLy50ZXN0KGVsKTtcbn1cblxuZnVuY3Rpb24gbHRlKGksIHkpIHtcbiAgcmV0dXJuIGkgPD0geTtcbn1cbmZ1bmN0aW9uIGd0ZShpLCB5KSB7XG4gIHJldHVybiBpID49IHk7XG59XG5cbmZ1bmN0aW9uIGV4cGFuZChzdHIsIGlzVG9wKSB7XG4gIHZhciBleHBhbnNpb25zID0gW107XG5cbiAgdmFyIG0gPSBiYWxhbmNlZCgneycsICd9Jywgc3RyKTtcbiAgaWYgKCFtIHx8IC9cXCQkLy50ZXN0KG0ucHJlKSkgcmV0dXJuIFtzdHJdO1xuXG4gIHZhciBpc051bWVyaWNTZXF1ZW5jZSA9IC9eLT9cXGQrXFwuXFwuLT9cXGQrKD86XFwuXFwuLT9cXGQrKT8kLy50ZXN0KG0uYm9keSk7XG4gIHZhciBpc0FscGhhU2VxdWVuY2UgPSAvXlthLXpBLVpdXFwuXFwuW2EtekEtWl0oPzpcXC5cXC4tP1xcZCspPyQvLnRlc3QobS5ib2R5KTtcbiAgdmFyIGlzU2VxdWVuY2UgPSBpc051bWVyaWNTZXF1ZW5jZSB8fCBpc0FscGhhU2VxdWVuY2U7XG4gIHZhciBpc09wdGlvbnMgPSBtLmJvZHkuaW5kZXhPZignLCcpID49IDA7XG4gIGlmICghaXNTZXF1ZW5jZSAmJiAhaXNPcHRpb25zKSB7XG4gICAgLy8ge2F9LGJ9XG4gICAgaWYgKG0ucG9zdC5tYXRjaCgvLC4qXFx9LykpIHtcbiAgICAgIHN0ciA9IG0ucHJlICsgJ3snICsgbS5ib2R5ICsgZXNjQ2xvc2UgKyBtLnBvc3Q7XG4gICAgICByZXR1cm4gZXhwYW5kKHN0cik7XG4gICAgfVxuICAgIHJldHVybiBbc3RyXTtcbiAgfVxuXG4gIHZhciBuO1xuICBpZiAoaXNTZXF1ZW5jZSkge1xuICAgIG4gPSBtLmJvZHkuc3BsaXQoL1xcLlxcLi8pO1xuICB9IGVsc2Uge1xuICAgIG4gPSBwYXJzZUNvbW1hUGFydHMobS5ib2R5KTtcbiAgICBpZiAobi5sZW5ndGggPT09IDEpIHtcbiAgICAgIC8vIHh7e2EsYn19eSA9PT4geHthfXkgeHtifXlcbiAgICAgIG4gPSBleHBhbmQoblswXSwgZmFsc2UpLm1hcChlbWJyYWNlKTtcbiAgICAgIGlmIChuLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICB2YXIgcG9zdCA9IG0ucG9zdC5sZW5ndGhcbiAgICAgICAgICA/IGV4cGFuZChtLnBvc3QsIGZhbHNlKVxuICAgICAgICAgIDogWycnXTtcbiAgICAgICAgcmV0dXJuIHBvc3QubWFwKGZ1bmN0aW9uKHApIHtcbiAgICAgICAgICByZXR1cm4gbS5wcmUgKyBuWzBdICsgcDtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gYXQgdGhpcyBwb2ludCwgbiBpcyB0aGUgcGFydHMsIGFuZCB3ZSBrbm93IGl0J3Mgbm90IGEgY29tbWEgc2V0XG4gIC8vIHdpdGggYSBzaW5nbGUgZW50cnkuXG5cbiAgLy8gbm8gbmVlZCB0byBleHBhbmQgcHJlLCBzaW5jZSBpdCBpcyBndWFyYW50ZWVkIHRvIGJlIGZyZWUgb2YgYnJhY2Utc2V0c1xuICB2YXIgcHJlID0gbS5wcmU7XG4gIHZhciBwb3N0ID0gbS5wb3N0Lmxlbmd0aFxuICAgID8gZXhwYW5kKG0ucG9zdCwgZmFsc2UpXG4gICAgOiBbJyddO1xuXG4gIHZhciBOO1xuXG4gIGlmIChpc1NlcXVlbmNlKSB7XG4gICAgdmFyIHggPSBudW1lcmljKG5bMF0pO1xuICAgIHZhciB5ID0gbnVtZXJpYyhuWzFdKTtcbiAgICB2YXIgd2lkdGggPSBNYXRoLm1heChuWzBdLmxlbmd0aCwgblsxXS5sZW5ndGgpXG4gICAgdmFyIGluY3IgPSBuLmxlbmd0aCA9PSAzXG4gICAgICA/IE1hdGguYWJzKG51bWVyaWMoblsyXSkpXG4gICAgICA6IDE7XG4gICAgdmFyIHRlc3QgPSBsdGU7XG4gICAgdmFyIHJldmVyc2UgPSB5IDwgeDtcbiAgICBpZiAocmV2ZXJzZSkge1xuICAgICAgaW5jciAqPSAtMTtcbiAgICAgIHRlc3QgPSBndGU7XG4gICAgfVxuICAgIHZhciBwYWQgPSBuLnNvbWUoaXNQYWRkZWQpO1xuXG4gICAgTiA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IHg7IHRlc3QoaSwgeSk7IGkgKz0gaW5jcikge1xuICAgICAgdmFyIGM7XG4gICAgICBpZiAoaXNBbHBoYVNlcXVlbmNlKSB7XG4gICAgICAgIGMgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGkpO1xuICAgICAgICBpZiAoYyA9PT0gJ1xcXFwnKVxuICAgICAgICAgIGMgPSAnJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGMgPSBTdHJpbmcoaSk7XG4gICAgICAgIGlmIChwYWQpIHtcbiAgICAgICAgICB2YXIgbmVlZCA9IHdpZHRoIC0gYy5sZW5ndGg7XG4gICAgICAgICAgaWYgKG5lZWQgPiAwKSB7XG4gICAgICAgICAgICB2YXIgeiA9IG5ldyBBcnJheShuZWVkICsgMSkuam9pbignMCcpO1xuICAgICAgICAgICAgaWYgKGkgPCAwKVxuICAgICAgICAgICAgICBjID0gJy0nICsgeiArIGMuc2xpY2UoMSk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIGMgPSB6ICsgYztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIE4ucHVzaChjKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgTiA9IGNvbmNhdE1hcChuLCBmdW5jdGlvbihlbCkgeyByZXR1cm4gZXhwYW5kKGVsLCBmYWxzZSkgfSk7XG4gIH1cblxuICBmb3IgKHZhciBqID0gMDsgaiA8IE4ubGVuZ3RoOyBqKyspIHtcbiAgICBmb3IgKHZhciBrID0gMDsgayA8IHBvc3QubGVuZ3RoOyBrKyspIHtcbiAgICAgIHZhciBleHBhbnNpb24gPSBwcmUgKyBOW2pdICsgcG9zdFtrXTtcbiAgICAgIGlmICghaXNUb3AgfHwgaXNTZXF1ZW5jZSB8fCBleHBhbnNpb24pXG4gICAgICAgIGV4cGFuc2lvbnMucHVzaChleHBhbnNpb24pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBleHBhbnNpb25zO1xufVxuXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/brace-expansion/index.js\n");

/***/ }),

/***/ "./node_modules/commondir/index.js":
/*!*****************************************!*\
  !*** ./node_modules/commondir/index.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var path = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'path'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\n\nmodule.exports = function (basedir, relfiles) {\n    if (relfiles) {\n        var files = relfiles.map(function (r) {\n            return path.resolve(basedir, r);\n        });\n    }\n    else {\n        var files = basedir;\n    }\n    \n    var res = files.slice(1).reduce(function (ps, file) {\n        if (!file.match(/^([A-Za-z]:)?\\/|\\\\/)) {\n            throw new Error('relative path without a basedir');\n        }\n        \n        var xs = file.split(/\\/+|\\\\+/);\n        for (\n            var i = 0;\n            ps[i] === xs[i] && i < Math.min(ps.length, xs.length);\n            i++\n        );\n        return ps.slice(0, i);\n    }, files[0].split(/\\/+|\\\\+/));\n    \n    // Windows correctly handles paths with forward-slashes\n    return res.length > 1 ? res.join('/') : '/'\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY29tbW9uZGlyL2luZGV4LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBLFdBQVcsbUJBQU8sQ0FBQyxtSUFBTTs7QUFFekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3RvZG8tbGlzdC8uL25vZGVfbW9kdWxlcy9jb21tb25kaXIvaW5kZXguanM/NDFhNSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYmFzZWRpciwgcmVsZmlsZXMpIHtcbiAgICBpZiAocmVsZmlsZXMpIHtcbiAgICAgICAgdmFyIGZpbGVzID0gcmVsZmlsZXMubWFwKGZ1bmN0aW9uIChyKSB7XG4gICAgICAgICAgICByZXR1cm4gcGF0aC5yZXNvbHZlKGJhc2VkaXIsIHIpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZhciBmaWxlcyA9IGJhc2VkaXI7XG4gICAgfVxuICAgIFxuICAgIHZhciByZXMgPSBmaWxlcy5zbGljZSgxKS5yZWR1Y2UoZnVuY3Rpb24gKHBzLCBmaWxlKSB7XG4gICAgICAgIGlmICghZmlsZS5tYXRjaCgvXihbQS1aYS16XTopP1xcL3xcXFxcLykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncmVsYXRpdmUgcGF0aCB3aXRob3V0IGEgYmFzZWRpcicpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICB2YXIgeHMgPSBmaWxlLnNwbGl0KC9cXC8rfFxcXFwrLyk7XG4gICAgICAgIGZvciAoXG4gICAgICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgICAgICBwc1tpXSA9PT0geHNbaV0gJiYgaSA8IE1hdGgubWluKHBzLmxlbmd0aCwgeHMubGVuZ3RoKTtcbiAgICAgICAgICAgIGkrK1xuICAgICAgICApO1xuICAgICAgICByZXR1cm4gcHMuc2xpY2UoMCwgaSk7XG4gICAgfSwgZmlsZXNbMF0uc3BsaXQoL1xcLyt8XFxcXCsvKSk7XG4gICAgXG4gICAgLy8gV2luZG93cyBjb3JyZWN0bHkgaGFuZGxlcyBwYXRocyB3aXRoIGZvcndhcmQtc2xhc2hlc1xuICAgIHJldHVybiByZXMubGVuZ3RoID4gMSA/IHJlcy5qb2luKCcvJykgOiAnLydcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/commondir/index.js\n");

/***/ }),

/***/ "./node_modules/concat-map/index.js":
/*!******************************************!*\
  !*** ./node_modules/concat-map/index.js ***!
  \******************************************/
/***/ ((module) => {

eval("module.exports = function (xs, fn) {\n    var res = [];\n    for (var i = 0; i < xs.length; i++) {\n        var x = fn(xs[i], i);\n        if (isArray(x)) res.push.apply(res, x);\n        else res.push(x);\n    }\n    return res;\n};\n\nvar isArray = Array.isArray || function (xs) {\n    return Object.prototype.toString.call(xs) === '[object Array]';\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY29uY2F0LW1hcC9pbmRleC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0Esb0JBQW9CLGVBQWU7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3RvZG8tbGlzdC8uL25vZGVfbW9kdWxlcy9jb25jYXQtbWFwL2luZGV4LmpzPzg5YzAiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoeHMsIGZuKSB7XG4gICAgdmFyIHJlcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgeHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHggPSBmbih4c1tpXSwgaSk7XG4gICAgICAgIGlmIChpc0FycmF5KHgpKSByZXMucHVzaC5hcHBseShyZXMsIHgpO1xuICAgICAgICBlbHNlIHJlcy5wdXNoKHgpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufTtcblxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uICh4cykge1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoeHMpID09PSAnW29iamVjdCBBcnJheV0nO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/concat-map/index.js\n");

/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./node_modules/sass-loader/dist/cjs.js!./src/style.scss":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./node_modules/sass-loader/dist/cjs.js!./src/style.scss ***!
  \*****************************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../node_modules/css-loader/dist/runtime/sourceMaps.js */ \"./node_modules/css-loader/dist/runtime/sourceMaps.js\");\n/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../node_modules/css-loader/dist/runtime/api.js */ \"./node_modules/css-loader/dist/runtime/api.js\");\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);\n// Imports\n\n\nvar ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \"* {\\n  padding: 0;\\n  margin: 0;\\n  box-sizing: border-box;\\n}\\n\\nbody {\\n  font-family: \\\"Coming Soon\\\", cursive;\\n  height: 100vh;\\n  width: 100vw;\\n  display: flex;\\n  flex-direction: column;\\n}\\n\\n#header {\\n  display: flex;\\n  justify-content: center;\\n  align-items: center;\\n  justify-content: flex-start;\\n  background-color: rgba(255, 72, 0, 0.7);\\n  color: white;\\n  font-size: 1.8rem;\\n  font-weight: 900;\\n  gap: 1rem;\\n  width: 100%;\\n}\\n#header .logo {\\n  max-height: 4rem;\\n  padding: 5px;\\n}\\n\\n#content {\\n  display: grid;\\n  grid-template-columns: 1fr 6fr;\\n  height: 100vh;\\n}\\n#content .sidebar {\\n  font-size: 1.5rem;\\n  padding: 10px;\\n  background-color: rgba(255, 72, 0, 0.3);\\n}\\n#content .sidebar ul {\\n  text-align: center;\\n  list-style-type: none;\\n}\\n#content .sidebar ul .link {\\n  padding: 10px;\\n  text-decoration: none;\\n  color: black;\\n  text-shadow: 1px 1px white;\\n}\\n#content .sidebar ul .today, #content .sidebar ul .week {\\n  cursor: pointer;\\n}\\n#content .sidebar li.projectsLi {\\n  background-color: #80f0e4;\\n  border-radius: 15px;\\n}\\n#content .sidebar li.projectsLi ul {\\n  padding: 10px;\\n  display: flex;\\n  flex-direction: column;\\n  gap: 10px;\\n  justify-content: center;\\n  align-items: center;\\n  margin: 0 auto;\\n}\\n#content .sidebar li.projectsLi ul li.project {\\n  font-size: 1.3rem;\\n  width: 220px;\\n  background-color: white;\\n  display: flex;\\n  gap: 10px;\\n  justify-content: center;\\n  align-items: center;\\n  padding: 10px;\\n  border: 1px solid;\\n  font-family: \\\"rock salt\\\", cursive;\\n}\\n#content .sidebar li.projectsLi ul li.project:hover {\\n  cursor: pointer;\\n}\\n#content .todoList {\\n  display: flex;\\n  flex-direction: column;\\n  justify-content: flex-start;\\n  align-items: center;\\n  gap: 10px;\\n  background-color: rgba(255, 72, 0, 0.1);\\n}\\n#content .todoList table {\\n  margin-top: 10px;\\n  min-width: 800px;\\n  max-width: 1200px;\\n  border-radius: 20px;\\n}\\n#content .todoList table .titles {\\n  font-size: 1.5rem;\\n  font-family: \\\"Times New Roman\\\", Times, serif;\\n}\\n#content .todoList table .titles:hover {\\n  box-shadow: none;\\n}\\n#content .todoList table .titles .dueDate {\\n  text-align: right;\\n}\\n#content .todoList table .titles .projName {\\n  text-align: left;\\n}\\n#content .todoList table .titles th {\\n  padding: 10px 0;\\n}\\n#content .todoList table tr.createdRow:hover {\\n  box-shadow: 0 0 5px 5px;\\n}\\n#content .todoList table tr.createdRow td {\\n  vertical-align: middle;\\n  max-width: 600px;\\n  padding: 10px 0 10px 10px;\\n}\\n#content .todoList table tr.createdRow .column1 {\\n  font-size: 1.5rem;\\n}\\n#content .todoList table tr.createdRow .column2 {\\n  display: flex;\\n  justify-content: flex-end;\\n  align-items: center;\\n  gap: 10px;\\n  font-size: 1.3rem;\\n}\\n#content .todoList table .viewOnly td {\\n  vertical-align: middle;\\n  max-width: 600px;\\n  padding: 10px 0 10px 10px;\\n}\\n#content .todoList table .viewOnly .column1 {\\n  font-size: 1.5rem;\\n}\\n#content .todoList table .viewOnly .column2 {\\n  display: flex;\\n  justify-content: flex-end;\\n  align-items: center;\\n  gap: 10px;\\n  font-size: 1.5rem;\\n}\\n\\ni, .addToDoBtn, .addProjectBtn {\\n  cursor: pointer;\\n}\\n\\n.fa-calendar-day, .fa-bars-progress {\\n  cursor: default;\\n}\\n\\n.fa-bars-progress, .fa-calendar, .fa-exclamation, .fa-calendar-day {\\n  margin-left: 10px;\\n}\\n\\n.completed {\\n  opacity: 0.5;\\n  text-decoration: line-through;\\n}\\n\\n#modal, #editModal, #projectModal {\\n  margin: auto auto;\\n  max-width: 100ch;\\n  padding: 10px;\\n  border: 0;\\n  border-radius: 10px;\\n  box-shadow: 0 0 1em rgba(0, 0, 0, 0.3);\\n  background-color: salmon;\\n}\\n#modal h2, #editModal h2, #projectModal h2 {\\n  letter-spacing: 5px;\\n  text-align: center;\\n  font-size: 1.2rem;\\n}\\n#modal .editForm, #modal .projectForm, #modal .form, #editModal .editForm, #editModal .projectForm, #editModal .form, #projectModal .editForm, #projectModal .projectForm, #projectModal .form {\\n  display: flex;\\n  flex-direction: column;\\n  justify-content: center;\\n  align-items: center;\\n  height: 400px;\\n  width: 350px;\\n  gap: 20px;\\n  font-size: 1.2rem;\\n  font-weight: bold;\\n}\\n#modal .editForm label, #modal .editForm textarea, #modal .editForm input[type=text],\\n#modal .editForm input[type=datetime-local], #modal .editForm .btns, #modal .projectForm label, #modal .projectForm textarea, #modal .projectForm input[type=text],\\n#modal .projectForm input[type=datetime-local], #modal .projectForm .btns, #modal .form label, #modal .form textarea, #modal .form input[type=text],\\n#modal .form input[type=datetime-local], #modal .form .btns, #editModal .editForm label, #editModal .editForm textarea, #editModal .editForm input[type=text],\\n#editModal .editForm input[type=datetime-local], #editModal .editForm .btns, #editModal .projectForm label, #editModal .projectForm textarea, #editModal .projectForm input[type=text],\\n#editModal .projectForm input[type=datetime-local], #editModal .projectForm .btns, #editModal .form label, #editModal .form textarea, #editModal .form input[type=text],\\n#editModal .form input[type=datetime-local], #editModal .form .btns, #projectModal .editForm label, #projectModal .editForm textarea, #projectModal .editForm input[type=text],\\n#projectModal .editForm input[type=datetime-local], #projectModal .editForm .btns, #projectModal .projectForm label, #projectModal .projectForm textarea, #projectModal .projectForm input[type=text],\\n#projectModal .projectForm input[type=datetime-local], #projectModal .projectForm .btns, #projectModal .form label, #projectModal .form textarea, #projectModal .form input[type=text],\\n#projectModal .form input[type=datetime-local], #projectModal .form .btns {\\n  letter-spacing: 1px;\\n  width: 200px;\\n  font-family: Roboto, Oxygen, Ubuntu, Cantarell, \\\"Open Sans\\\", \\\"Helvetica Neue\\\", sans-serif;\\n}\\n#modal .editForm input, #modal .editForm textarea, #modal .editForm select, #modal .projectForm input, #modal .projectForm textarea, #modal .projectForm select, #modal .form input, #modal .form textarea, #modal .form select, #editModal .editForm input, #editModal .editForm textarea, #editModal .editForm select, #editModal .projectForm input, #editModal .projectForm textarea, #editModal .projectForm select, #editModal .form input, #editModal .form textarea, #editModal .form select, #projectModal .editForm input, #projectModal .editForm textarea, #projectModal .editForm select, #projectModal .projectForm input, #projectModal .projectForm textarea, #projectModal .projectForm select, #projectModal .form input, #projectModal .form textarea, #projectModal .form select {\\n  background-color: white;\\n}\\n#modal .editForm textarea, #modal .projectForm textarea, #modal .form textarea, #editModal .editForm textarea, #editModal .projectForm textarea, #editModal .form textarea, #projectModal .editForm textarea, #projectModal .projectForm textarea, #projectModal .form textarea {\\n  padding: 10px;\\n  max-width: 100%;\\n  line-height: 1.5;\\n  border-radius: 5px;\\n  border: 1px solid #ccc;\\n  box-shadow: 1px 1px 1px #999;\\n}\\n#modal .editForm label, #modal .projectForm label, #modal .form label, #editModal .editForm label, #editModal .projectForm label, #editModal .form label, #projectModal .editForm label, #projectModal .projectForm label, #projectModal .form label {\\n  display: block;\\n  margin-bottom: 5px;\\n}\\n#modal .editForm input[type=text], #modal .projectForm input[type=text], #modal .form input[type=text], #editModal .editForm input[type=text], #editModal .projectForm input[type=text], #editModal .form input[type=text], #projectModal .editForm input[type=text], #projectModal .projectForm input[type=text], #projectModal .form input[type=text] {\\n  padding: 5px;\\n}\\n#modal .editForm .btns, #modal .projectForm .btns, #modal .form .btns, #editModal .editForm .btns, #editModal .projectForm .btns, #editModal .form .btns, #projectModal .editForm .btns, #projectModal .projectForm .btns, #projectModal .form .btns {\\n  display: flex;\\n  justify-content: center;\\n  align-items: center;\\n  gap: 5px;\\n}\\n#modal .editForm .btns .submitProjectBtn, #modal .editForm .btns .cancelProjectBtn,\\n#modal .editForm .btns .createModalSubmitBtn, #modal .editForm .btns .createModalCancelBtn,\\n#modal .editForm .btns .cancelEditBtn, #modal .editForm .btns .submitEditBtn, #modal .projectForm .btns .submitProjectBtn, #modal .projectForm .btns .cancelProjectBtn,\\n#modal .projectForm .btns .createModalSubmitBtn, #modal .projectForm .btns .createModalCancelBtn,\\n#modal .projectForm .btns .cancelEditBtn, #modal .projectForm .btns .submitEditBtn, #modal .form .btns .submitProjectBtn, #modal .form .btns .cancelProjectBtn,\\n#modal .form .btns .createModalSubmitBtn, #modal .form .btns .createModalCancelBtn,\\n#modal .form .btns .cancelEditBtn, #modal .form .btns .submitEditBtn, #editModal .editForm .btns .submitProjectBtn, #editModal .editForm .btns .cancelProjectBtn,\\n#editModal .editForm .btns .createModalSubmitBtn, #editModal .editForm .btns .createModalCancelBtn,\\n#editModal .editForm .btns .cancelEditBtn, #editModal .editForm .btns .submitEditBtn, #editModal .projectForm .btns .submitProjectBtn, #editModal .projectForm .btns .cancelProjectBtn,\\n#editModal .projectForm .btns .createModalSubmitBtn, #editModal .projectForm .btns .createModalCancelBtn,\\n#editModal .projectForm .btns .cancelEditBtn, #editModal .projectForm .btns .submitEditBtn, #editModal .form .btns .submitProjectBtn, #editModal .form .btns .cancelProjectBtn,\\n#editModal .form .btns .createModalSubmitBtn, #editModal .form .btns .createModalCancelBtn,\\n#editModal .form .btns .cancelEditBtn, #editModal .form .btns .submitEditBtn, #projectModal .editForm .btns .submitProjectBtn, #projectModal .editForm .btns .cancelProjectBtn,\\n#projectModal .editForm .btns .createModalSubmitBtn, #projectModal .editForm .btns .createModalCancelBtn,\\n#projectModal .editForm .btns .cancelEditBtn, #projectModal .editForm .btns .submitEditBtn, #projectModal .projectForm .btns .submitProjectBtn, #projectModal .projectForm .btns .cancelProjectBtn,\\n#projectModal .projectForm .btns .createModalSubmitBtn, #projectModal .projectForm .btns .createModalCancelBtn,\\n#projectModal .projectForm .btns .cancelEditBtn, #projectModal .projectForm .btns .submitEditBtn, #projectModal .form .btns .submitProjectBtn, #projectModal .form .btns .cancelProjectBtn,\\n#projectModal .form .btns .createModalSubmitBtn, #projectModal .form .btns .createModalCancelBtn,\\n#projectModal .form .btns .cancelEditBtn, #projectModal .form .btns .submitEditBtn {\\n  background-color: greenyellow;\\n  max-width: 50px;\\n  padding: 10px;\\n}\\n#modal .editForm .btns .submitProjectBtn:hover, #modal .editForm .btns .cancelProjectBtn:hover,\\n#modal .editForm .btns .createModalSubmitBtn:hover, #modal .editForm .btns .createModalCancelBtn:hover,\\n#modal .editForm .btns .cancelEditBtn:hover, #modal .editForm .btns .submitEditBtn:hover, #modal .projectForm .btns .submitProjectBtn:hover, #modal .projectForm .btns .cancelProjectBtn:hover,\\n#modal .projectForm .btns .createModalSubmitBtn:hover, #modal .projectForm .btns .createModalCancelBtn:hover,\\n#modal .projectForm .btns .cancelEditBtn:hover, #modal .projectForm .btns .submitEditBtn:hover, #modal .form .btns .submitProjectBtn:hover, #modal .form .btns .cancelProjectBtn:hover,\\n#modal .form .btns .createModalSubmitBtn:hover, #modal .form .btns .createModalCancelBtn:hover,\\n#modal .form .btns .cancelEditBtn:hover, #modal .form .btns .submitEditBtn:hover, #editModal .editForm .btns .submitProjectBtn:hover, #editModal .editForm .btns .cancelProjectBtn:hover,\\n#editModal .editForm .btns .createModalSubmitBtn:hover, #editModal .editForm .btns .createModalCancelBtn:hover,\\n#editModal .editForm .btns .cancelEditBtn:hover, #editModal .editForm .btns .submitEditBtn:hover, #editModal .projectForm .btns .submitProjectBtn:hover, #editModal .projectForm .btns .cancelProjectBtn:hover,\\n#editModal .projectForm .btns .createModalSubmitBtn:hover, #editModal .projectForm .btns .createModalCancelBtn:hover,\\n#editModal .projectForm .btns .cancelEditBtn:hover, #editModal .projectForm .btns .submitEditBtn:hover, #editModal .form .btns .submitProjectBtn:hover, #editModal .form .btns .cancelProjectBtn:hover,\\n#editModal .form .btns .createModalSubmitBtn:hover, #editModal .form .btns .createModalCancelBtn:hover,\\n#editModal .form .btns .cancelEditBtn:hover, #editModal .form .btns .submitEditBtn:hover, #projectModal .editForm .btns .submitProjectBtn:hover, #projectModal .editForm .btns .cancelProjectBtn:hover,\\n#projectModal .editForm .btns .createModalSubmitBtn:hover, #projectModal .editForm .btns .createModalCancelBtn:hover,\\n#projectModal .editForm .btns .cancelEditBtn:hover, #projectModal .editForm .btns .submitEditBtn:hover, #projectModal .projectForm .btns .submitProjectBtn:hover, #projectModal .projectForm .btns .cancelProjectBtn:hover,\\n#projectModal .projectForm .btns .createModalSubmitBtn:hover, #projectModal .projectForm .btns .createModalCancelBtn:hover,\\n#projectModal .projectForm .btns .cancelEditBtn:hover, #projectModal .projectForm .btns .submitEditBtn:hover, #projectModal .form .btns .submitProjectBtn:hover, #projectModal .form .btns .cancelProjectBtn:hover,\\n#projectModal .form .btns .createModalSubmitBtn:hover, #projectModal .form .btns .createModalCancelBtn:hover,\\n#projectModal .form .btns .cancelEditBtn:hover, #projectModal .form .btns .submitEditBtn:hover {\\n  cursor: pointer;\\n  background-color: white;\\n}\\n#modal .editForm .btns .cancelEditBtn, #modal .editForm .btns .createModalCancelBtn, #modal .editForm .btns .cancelProjectBtn, #modal .projectForm .btns .cancelEditBtn, #modal .projectForm .btns .createModalCancelBtn, #modal .projectForm .btns .cancelProjectBtn, #modal .form .btns .cancelEditBtn, #modal .form .btns .createModalCancelBtn, #modal .form .btns .cancelProjectBtn, #editModal .editForm .btns .cancelEditBtn, #editModal .editForm .btns .createModalCancelBtn, #editModal .editForm .btns .cancelProjectBtn, #editModal .projectForm .btns .cancelEditBtn, #editModal .projectForm .btns .createModalCancelBtn, #editModal .projectForm .btns .cancelProjectBtn, #editModal .form .btns .cancelEditBtn, #editModal .form .btns .createModalCancelBtn, #editModal .form .btns .cancelProjectBtn, #projectModal .editForm .btns .cancelEditBtn, #projectModal .editForm .btns .createModalCancelBtn, #projectModal .editForm .btns .cancelProjectBtn, #projectModal .projectForm .btns .cancelEditBtn, #projectModal .projectForm .btns .createModalCancelBtn, #projectModal .projectForm .btns .cancelProjectBtn, #projectModal .form .btns .cancelEditBtn, #projectModal .form .btns .createModalCancelBtn, #projectModal .form .btns .cancelProjectBtn {\\n  background-color: red;\\n}\\n#modal > *, #editModal > *, #projectModal > * {\\n  margin: 0 0 0.5rem 0;\\n}\\n#modal::backdrop, #editModal::backdrop, #projectModal::backdrop {\\n  background: rgba(0, 0, 0, 0.4);\\n}\\n\\n#projectModal .projectForm {\\n  height: 120px;\\n  width: 250px;\\n}\\n\\n.footer {\\n  font-size: 1rem;\\n  font-family: Roboto, Oxygen, Ubuntu, Cantarell, \\\"Open Sans\\\", \\\"Helvetica Neue\\\", sans-serif;\\n  padding: 10px;\\n  background-color: #80f0e4;\\n  text-align: center;\\n}\\n\\n.fa-circle-plus,\\n.fa-github,\\n.fa-linkedin,\\n.svg {\\n  transition-duration: 0.75s;\\n  transform: rotate(720deg) scale(1.5);\\n  cursor: pointer;\\n}\", \"\",{\"version\":3,\"sources\":[\"webpack://./src/style.scss\",\"webpack://./src/scss/_globals.scss\"],\"names\":[],\"mappings\":\"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\",\"sourcesContent\":[\"@import './scss/globals';\\n\\n@mixin center {\\n    display: flex;\\n    justify-content: center;\\n    align-items: center;\\n}\\n\\n*{\\n    padding: 0;\\n    margin: 0;\\n    box-sizing: border-box;\\n}\\n\\nbody{\\n    font-family: 'Coming Soon', cursive;\\n    height: 100vh;\\n    width: 100vw;\\n    display: flex;\\n    flex-direction: column;\\n}\\n\\n#header{\\n    @include center;\\n    justify-content: flex-start;\\n    background-color: $HEADER;\\n    color: $FONT;\\n    font-size: 1.8rem;\\n    font-weight: 900;\\n    gap: 1rem;\\n    width: 100%;\\n    .logo{\\n        max-height: 4rem;\\n        padding: 5px;\\n    }\\n}\\n\\n#content{\\n    display: grid;\\n    grid-template-columns: 1fr 6fr;\\n    height: 100vh;\\n    .sidebar{\\n        font-size: 1.5rem;\\n        padding: 10px;\\n        background-color: $SIDEBAR;\\n        ul{\\n            text-align: center;\\n            list-style-type: none;\\n            .link{\\n                padding: 10px;\\n                text-decoration: none;\\n                color: $SIDEBAR_TEXT;\\n                text-shadow: 1px 1px white;\\n            }\\n            .today, .week{\\n                cursor: pointer;\\n            }\\n        }\\n        li.projectsLi{\\n            background-color: $LOGO-COLOR;\\n            border-radius: 15px;\\n        }\\n        li.projectsLi ul{\\n            padding: 10px;\\n            display: flex;\\n            flex-direction: column;\\n            gap: 10px;\\n            justify-content: center;\\n            align-items: center;\\n            margin: 0 auto;\\n            li.project{\\n                font-size: 1.3rem;\\n                width: 220px;\\n                background-color: white;\\n                display: flex;\\n                gap: 10px;\\n                justify-content: center;\\n                align-items: center;\\n                padding: 10px;\\n                border: 1px solid;\\n                font-family: 'rock salt', cursive;\\n                &:hover{\\n                    cursor: pointer;\\n                }\\n            }\\n        }\\n    }\\n    .todoList{\\n        display: flex;\\n        flex-direction: column;\\n        justify-content: flex-start;\\n        align-items: center;\\n        gap: 10px;\\n        background-color: $TODOLIST;\\n        table{\\n            margin-top: 10px;\\n            min-width: clamp(320px, 800px, 1000px);\\n            max-width: clamp(400px, 1200px, 1600px);\\n            border-radius: 20px;\\n            .titles{\\n                &:hover{\\n                    box-shadow: none;\\n                }\\n                font-size: 1.5rem;\\n                font-family: 'Times New Roman', Times, serif;\\n                .dueDate{\\n                    text-align: right;\\n                }\\n                .projName{\\n                    text-align: left;\\n                }\\n                th{\\n                    padding: 10px 0;\\n                }\\n            }\\n\\n            tr.createdRow{\\n                &:hover{\\n                    box-shadow: 0 0 5px 5px;\\n                }\\n                td{\\n                    vertical-align: middle;\\n                    max-width: 600px;\\n                    padding: 10px 0 10px 10px;\\n                }\\n                .column1{\\n                    font-size: 1.5rem;\\n                }\\n                .column2{\\n                    display: flex;\\n                    justify-content: flex-end;\\n                    align-items: center;\\n                    gap: 10px;\\n                    font-size: 1.3rem;\\n                }\\n            }\\n\\n            .viewOnly{\\n                td{\\n                    vertical-align: middle;\\n                    max-width: 600px;\\n                    padding: 10px 0 10px 10px;\\n                }\\n                .column1{\\n                    font-size: 1.5rem;\\n                }\\n                .column2{\\n                    display: flex;\\n                    justify-content: flex-end;\\n                    align-items: center;\\n                    gap: 10px;\\n                    font-size: 1.5rem;\\n                }\\n            }\\n        }\\n    }\\n}\\n\\ni, .addToDoBtn, .addProjectBtn{\\n    cursor: pointer;\\n}\\n.fa-calendar-day, .fa-bars-progress{\\n    cursor: default;\\n}\\n.fa-bars-progress, .fa-calendar, .fa-exclamation, .fa-calendar-day{\\n    margin-left: 10px;\\n}\\n\\n.completed{\\n    opacity: 0.5;\\n    text-decoration: line-through;\\n}\\n\\n\\n#modal, #editModal, #projectModal{\\n\\n    margin: auto auto;\\n    max-width: 100ch;\\n    padding: 10px;\\n    border: 0;\\n    border-radius: 10px;\\n    box-shadow: 0 0 1em rgb(0 0 0 / .3);\\n    background-color: salmon;\\n\\n    h2{\\n        letter-spacing: 5px;\\n        text-align: center;\\n        font-size: 1.2rem;\\n    }\\n\\n    .editForm, .projectForm, .form{\\n        \\n        display: flex;\\n        flex-direction: column;\\n        justify-content: center;\\n        align-items: center;\\n        height: 400px;\\n        width: 350px;\\n        gap: 20px;\\n        font-size: 1.2rem;\\n        font-weight: bold;\\n\\n        label, textarea, input[type=\\\"text\\\"],\\n        input[type=\\\"datetime-local\\\"], .btns{\\n            letter-spacing: 1px;\\n            width: 200px;\\n            font-family: Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;\\n        }\\n        \\n        input, textarea, select{\\n            background-color: white;\\n        }\\n    \\n        textarea {\\n            padding: 10px;\\n            max-width: 100%;\\n            line-height: 1.5;\\n            border-radius: 5px;\\n            border: 1px solid #ccc;\\n            box-shadow: 1px 1px 1px #999;\\n        }\\n    \\n        label {\\n            display: block;\\n            margin-bottom: 5px;\\n        }\\n    \\n        input[type=\\\"text\\\"]{\\n            padding: 5px;\\n        }\\n    \\n        .btns{\\n            @include center;\\n            gap: 5px;\\n            .submitProjectBtn, .cancelProjectBtn, \\n            .createModalSubmitBtn, .createModalCancelBtn,\\n            .cancelEditBtn, .submitEditBtn\\n            {\\n                background-color: greenyellow;\\n                max-width: 50px;\\n                padding: 10px;\\n                &:hover{\\n                    cursor: pointer;\\n                    background-color: white;\\n                }\\n            }\\n            .cancelEditBtn, .createModalCancelBtn, .cancelProjectBtn{\\n                background-color: red;\\n            }\\n        }\\n    }\\n\\n    & > * {\\n    margin: 0 0 0.5rem 0;\\n    }\\n    &::backdrop{\\n    background: rgb(0 0 0 / 0.4);\\n    }\\n\\n}\\n\\n#projectModal{\\n    .projectForm{\\n        height: 120px;\\n        width: 250px;\\n    }\\n}\\n\\n.footer{\\n    font-size: 1rem;\\n    font-family: Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;\\n    padding: 10px;\\n    background-color: #80f0e4;\\n    text-align: center;\\n}\\n\\n\\n// animation\\n\\n.fa-circle-plus, \\n.fa-github, \\n.fa-linkedin,\\n.svg{\\n    transition-duration: 0.75s;\\n    transform: rotate(720deg) scale(1.5);\\n    cursor: pointer;\\n}\\n\\n\",\"$BODY: #3f3f3f;\\n$FONT: white;\\n$HEADER: rgba(255, 72, 0, .7);\\n$SIDEBAR: rgba(255, 72, 0, .3);\\n$SIDEBAR_TEXT: black;\\n$TODOLIST: rgba(255, 72, 0, .1);\\n$TODO_INFO_FORM: white;\\n$LOGO-COLOR: #80f0e4;\"],\"sourceRoot\":\"\"}]);\n// Exports\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL3NyYy9zdHlsZS5zY3NzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7QUFDMEc7QUFDakI7QUFDekYsOEJBQThCLG1GQUEyQixDQUFDLDRGQUFxQztBQUMvRjtBQUNBLDZDQUE2QyxlQUFlLGNBQWMsMkJBQTJCLEdBQUcsVUFBVSwwQ0FBMEMsa0JBQWtCLGlCQUFpQixrQkFBa0IsMkJBQTJCLEdBQUcsYUFBYSxrQkFBa0IsNEJBQTRCLHdCQUF3QixnQ0FBZ0MsNENBQTRDLGlCQUFpQixzQkFBc0IscUJBQXFCLGNBQWMsZ0JBQWdCLEdBQUcsaUJBQWlCLHFCQUFxQixpQkFBaUIsR0FBRyxjQUFjLGtCQUFrQixtQ0FBbUMsa0JBQWtCLEdBQUcscUJBQXFCLHNCQUFzQixrQkFBa0IsNENBQTRDLEdBQUcsd0JBQXdCLHVCQUF1QiwwQkFBMEIsR0FBRyw4QkFBOEIsa0JBQWtCLDBCQUEwQixpQkFBaUIsK0JBQStCLEdBQUcsMkRBQTJELG9CQUFvQixHQUFHLG1DQUFtQyw4QkFBOEIsd0JBQXdCLEdBQUcsc0NBQXNDLGtCQUFrQixrQkFBa0IsMkJBQTJCLGNBQWMsNEJBQTRCLHdCQUF3QixtQkFBbUIsR0FBRyxpREFBaUQsc0JBQXNCLGlCQUFpQiw0QkFBNEIsa0JBQWtCLGNBQWMsNEJBQTRCLHdCQUF3QixrQkFBa0Isc0JBQXNCLHdDQUF3QyxHQUFHLHVEQUF1RCxvQkFBb0IsR0FBRyxzQkFBc0Isa0JBQWtCLDJCQUEyQixnQ0FBZ0Msd0JBQXdCLGNBQWMsNENBQTRDLEdBQUcsNEJBQTRCLHFCQUFxQixxQkFBcUIsc0JBQXNCLHdCQUF3QixHQUFHLG9DQUFvQyxzQkFBc0IsbURBQW1ELEdBQUcsMENBQTBDLHFCQUFxQixHQUFHLDZDQUE2QyxzQkFBc0IsR0FBRyw4Q0FBOEMscUJBQXFCLEdBQUcsdUNBQXVDLG9CQUFvQixHQUFHLGdEQUFnRCw0QkFBNEIsR0FBRyw2Q0FBNkMsMkJBQTJCLHFCQUFxQiw4QkFBOEIsR0FBRyxtREFBbUQsc0JBQXNCLEdBQUcsbURBQW1ELGtCQUFrQiw4QkFBOEIsd0JBQXdCLGNBQWMsc0JBQXNCLEdBQUcseUNBQXlDLDJCQUEyQixxQkFBcUIsOEJBQThCLEdBQUcsK0NBQStDLHNCQUFzQixHQUFHLCtDQUErQyxrQkFBa0IsOEJBQThCLHdCQUF3QixjQUFjLHNCQUFzQixHQUFHLG9DQUFvQyxvQkFBb0IsR0FBRyx5Q0FBeUMsb0JBQW9CLEdBQUcsd0VBQXdFLHNCQUFzQixHQUFHLGdCQUFnQixpQkFBaUIsa0NBQWtDLEdBQUcsdUNBQXVDLHNCQUFzQixxQkFBcUIsa0JBQWtCLGNBQWMsd0JBQXdCLDJDQUEyQyw2QkFBNkIsR0FBRyw4Q0FBOEMsd0JBQXdCLHVCQUF1QixzQkFBc0IsR0FBRyxrTUFBa00sa0JBQWtCLDJCQUEyQiw0QkFBNEIsd0JBQXdCLGtCQUFrQixpQkFBaUIsY0FBYyxzQkFBc0Isc0JBQXNCLEdBQUcsb2hEQUFvaEQsd0JBQXdCLGlCQUFpQixrR0FBa0csR0FBRyx3d0JBQXd3Qiw0QkFBNEIsR0FBRyxtUkFBbVIsa0JBQWtCLG9CQUFvQixxQkFBcUIsdUJBQXVCLDJCQUEyQixpQ0FBaUMsR0FBRyx3UEFBd1AsbUJBQW1CLHVCQUF1QixHQUFHLDJWQUEyVixpQkFBaUIsR0FBRyx3UEFBd1Asa0JBQWtCLDRCQUE0Qix3QkFBd0IsYUFBYSxHQUFHLHM3RUFBczdFLGtDQUFrQyxvQkFBb0Isa0JBQWtCLEdBQUcsMHZGQUEwdkYsb0JBQW9CLDRCQUE0QixHQUFHLG10Q0FBbXRDLDBCQUEwQixHQUFHLGlEQUFpRCx5QkFBeUIsR0FBRyxtRUFBbUUsbUNBQW1DLEdBQUcsZ0NBQWdDLGtCQUFrQixpQkFBaUIsR0FBRyxhQUFhLG9CQUFvQixrR0FBa0csa0JBQWtCLDhCQUE4Qix1QkFBdUIsR0FBRyx3REFBd0QsK0JBQStCLHlDQUF5QyxvQkFBb0IsR0FBRyxPQUFPLHNIQUFzSCxVQUFVLFVBQVUsV0FBVyxNQUFNLEtBQUssV0FBVyxVQUFVLFVBQVUsVUFBVSxXQUFXLE1BQU0sS0FBSyxXQUFXLFdBQVcsV0FBVyxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVcsVUFBVSxVQUFVLEtBQUssS0FBSyxXQUFXLFVBQVUsTUFBTSxLQUFLLFVBQVUsV0FBVyxVQUFVLEtBQUssS0FBSyxXQUFXLFVBQVUsWUFBWSxNQUFNLEtBQUssV0FBVyxXQUFXLEtBQUssS0FBSyxVQUFVLFdBQVcsV0FBVyxZQUFZLE1BQU0sS0FBSyxVQUFVLE1BQU0sS0FBSyxZQUFZLFlBQVksS0FBSyxLQUFLLFVBQVUsVUFBVSxXQUFXLFVBQVUsV0FBVyxXQUFXLFVBQVUsS0FBSyxLQUFLLFdBQVcsVUFBVSxXQUFXLFVBQVUsVUFBVSxXQUFXLFdBQVcsVUFBVSxXQUFXLFdBQVcsTUFBTSxNQUFNLFVBQVUsTUFBTSxLQUFLLFVBQVUsV0FBVyxXQUFXLFdBQVcsVUFBVSxZQUFZLE1BQU0sS0FBSyxXQUFXLFdBQVcsV0FBVyxXQUFXLEtBQUssS0FBSyxXQUFXLFdBQVcsTUFBTSxNQUFNLFdBQVcsTUFBTSxNQUFNLFdBQVcsTUFBTSxNQUFNLFdBQVcsTUFBTSxNQUFNLFVBQVUsTUFBTSxNQUFNLFdBQVcsTUFBTSxNQUFNLFdBQVcsV0FBVyxXQUFXLE1BQU0sTUFBTSxXQUFXLE1BQU0sTUFBTSxVQUFVLFdBQVcsV0FBVyxVQUFVLFdBQVcsTUFBTSxNQUFNLFdBQVcsV0FBVyxXQUFXLE1BQU0sTUFBTSxXQUFXLE1BQU0sTUFBTSxVQUFVLFdBQVcsV0FBVyxVQUFVLFdBQVcsT0FBTyxLQUFLLFVBQVUsTUFBTSxLQUFLLFVBQVUsTUFBTSxLQUFLLFdBQVcsTUFBTSxLQUFLLFVBQVUsV0FBVyxNQUFNLEtBQUssV0FBVyxXQUFXLFVBQVUsVUFBVSxXQUFXLFdBQVcsV0FBVyxLQUFLLEtBQUssV0FBVyxXQUFXLFdBQVcsS0FBSyxLQUFLLFVBQVUsV0FBVyxXQUFXLFdBQVcsVUFBVSxVQUFVLFVBQVUsV0FBVyxXQUFXLEtBQUssY0FBYyxXQUFX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T0FBTyxlQUFlLDJCQUEyQixPQUFPLGtCQUFrQixtQ0FBbUMsT0FBTyxLQUFLLGtCQUFrQixtQkFBbUIsd0JBQXdCLHVCQUF1QixPQUFPLEdBQUcsWUFBWSxzQkFBc0IsZ0dBQWdHLG9CQUFvQixnQ0FBZ0MseUJBQXlCLEdBQUcsMkVBQTJFLGlDQUFpQywyQ0FBMkMsc0JBQXNCLEdBQUcsc0JBQXNCLGVBQWUsZ0NBQWdDLGlDQUFpQyx1QkFBdUIsa0NBQWtDLHlCQUF5Qix1QkFBdUIsbUJBQW1CO0FBQ3Ixd0I7QUFDQSxpRUFBZSx1QkFBdUIsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3RvZG8tbGlzdC8uL3NyYy9zdHlsZS5zY3NzPzg3NmMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gSW1wb3J0c1xuaW1wb3J0IF9fX0NTU19MT0FERVJfQVBJX1NPVVJDRU1BUF9JTVBPUlRfX18gZnJvbSBcIi4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9zb3VyY2VNYXBzLmpzXCI7XG5pbXBvcnQgX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fIGZyb20gXCIuLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzXCI7XG52YXIgX19fQ1NTX0xPQURFUl9FWFBPUlRfX18gPSBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18oX19fQ1NTX0xPQURFUl9BUElfU09VUkNFTUFQX0lNUE9SVF9fXyk7XG4vLyBNb2R1bGVcbl9fX0NTU19MT0FERVJfRVhQT1JUX19fLnB1c2goW21vZHVsZS5pZCwgXCIqIHtcXG4gIHBhZGRpbmc6IDA7XFxuICBtYXJnaW46IDA7XFxuICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xcbn1cXG5cXG5ib2R5IHtcXG4gIGZvbnQtZmFtaWx5OiBcXFwiQ29taW5nIFNvb25cXFwiLCBjdXJzaXZlO1xcbiAgaGVpZ2h0OiAxMDB2aDtcXG4gIHdpZHRoOiAxMDB2dztcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xcbn1cXG5cXG4jaGVhZGVyIHtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICBqdXN0aWZ5LWNvbnRlbnQ6IGZsZXgtc3RhcnQ7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDI1NSwgNzIsIDAsIDAuNyk7XFxuICBjb2xvcjogd2hpdGU7XFxuICBmb250LXNpemU6IDEuOHJlbTtcXG4gIGZvbnQtd2VpZ2h0OiA5MDA7XFxuICBnYXA6IDFyZW07XFxuICB3aWR0aDogMTAwJTtcXG59XFxuI2hlYWRlciAubG9nbyB7XFxuICBtYXgtaGVpZ2h0OiA0cmVtO1xcbiAgcGFkZGluZzogNXB4O1xcbn1cXG5cXG4jY29udGVudCB7XFxuICBkaXNwbGF5OiBncmlkO1xcbiAgZ3JpZC10ZW1wbGF0ZS1jb2x1bW5zOiAxZnIgNmZyO1xcbiAgaGVpZ2h0OiAxMDB2aDtcXG59XFxuI2NvbnRlbnQgLnNpZGViYXIge1xcbiAgZm9udC1zaXplOiAxLjVyZW07XFxuICBwYWRkaW5nOiAxMHB4O1xcbiAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgyNTUsIDcyLCAwLCAwLjMpO1xcbn1cXG4jY29udGVudCAuc2lkZWJhciB1bCB7XFxuICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxuICBsaXN0LXN0eWxlLXR5cGU6IG5vbmU7XFxufVxcbiNjb250ZW50IC5zaWRlYmFyIHVsIC5saW5rIHtcXG4gIHBhZGRpbmc6IDEwcHg7XFxuICB0ZXh0LWRlY29yYXRpb246IG5vbmU7XFxuICBjb2xvcjogYmxhY2s7XFxuICB0ZXh0LXNoYWRvdzogMXB4IDFweCB3aGl0ZTtcXG59XFxuI2NvbnRlbnQgLnNpZGViYXIgdWwgLnRvZGF5LCAjY29udGVudCAuc2lkZWJhciB1bCAud2VlayB7XFxuICBjdXJzb3I6IHBvaW50ZXI7XFxufVxcbiNjb250ZW50IC5zaWRlYmFyIGxpLnByb2plY3RzTGkge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogIzgwZjBlNDtcXG4gIGJvcmRlci1yYWRpdXM6IDE1cHg7XFxufVxcbiNjb250ZW50IC5zaWRlYmFyIGxpLnByb2plY3RzTGkgdWwge1xcbiAgcGFkZGluZzogMTBweDtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xcbiAgZ2FwOiAxMHB4O1xcbiAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxuICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgbWFyZ2luOiAwIGF1dG87XFxufVxcbiNjb250ZW50IC5zaWRlYmFyIGxpLnByb2plY3RzTGkgdWwgbGkucHJvamVjdCB7XFxuICBmb250LXNpemU6IDEuM3JlbTtcXG4gIHdpZHRoOiAyMjBweDtcXG4gIGJhY2tncm91bmQtY29sb3I6IHdoaXRlO1xcbiAgZGlzcGxheTogZmxleDtcXG4gIGdhcDogMTBweDtcXG4gIGp1c3RpZnktY29udGVudDogY2VudGVyO1xcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gIHBhZGRpbmc6IDEwcHg7XFxuICBib3JkZXI6IDFweCBzb2xpZDtcXG4gIGZvbnQtZmFtaWx5OiBcXFwicm9jayBzYWx0XFxcIiwgY3Vyc2l2ZTtcXG59XFxuI2NvbnRlbnQgLnNpZGViYXIgbGkucHJvamVjdHNMaSB1bCBsaS5wcm9qZWN0OmhvdmVyIHtcXG4gIGN1cnNvcjogcG9pbnRlcjtcXG59XFxuI2NvbnRlbnQgLnRvZG9MaXN0IHtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xcbiAganVzdGlmeS1jb250ZW50OiBmbGV4LXN0YXJ0O1xcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gIGdhcDogMTBweDtcXG4gIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMjU1LCA3MiwgMCwgMC4xKTtcXG59XFxuI2NvbnRlbnQgLnRvZG9MaXN0IHRhYmxlIHtcXG4gIG1hcmdpbi10b3A6IDEwcHg7XFxuICBtaW4td2lkdGg6IDgwMHB4O1xcbiAgbWF4LXdpZHRoOiAxMjAwcHg7XFxuICBib3JkZXItcmFkaXVzOiAyMHB4O1xcbn1cXG4jY29udGVudCAudG9kb0xpc3QgdGFibGUgLnRpdGxlcyB7XFxuICBmb250LXNpemU6IDEuNXJlbTtcXG4gIGZvbnQtZmFtaWx5OiBcXFwiVGltZXMgTmV3IFJvbWFuXFxcIiwgVGltZXMsIHNlcmlmO1xcbn1cXG4jY29udGVudCAudG9kb0xpc3QgdGFibGUgLnRpdGxlczpob3ZlciB7XFxuICBib3gtc2hhZG93OiBub25lO1xcbn1cXG4jY29udGVudCAudG9kb0xpc3QgdGFibGUgLnRpdGxlcyAuZHVlRGF0ZSB7XFxuICB0ZXh0LWFsaWduOiByaWdodDtcXG59XFxuI2NvbnRlbnQgLnRvZG9MaXN0IHRhYmxlIC50aXRsZXMgLnByb2pOYW1lIHtcXG4gIHRleHQtYWxpZ246IGxlZnQ7XFxufVxcbiNjb250ZW50IC50b2RvTGlzdCB0YWJsZSAudGl0bGVzIHRoIHtcXG4gIHBhZGRpbmc6IDEwcHggMDtcXG59XFxuI2NvbnRlbnQgLnRvZG9MaXN0IHRhYmxlIHRyLmNyZWF0ZWRSb3c6aG92ZXIge1xcbiAgYm94LXNoYWRvdzogMCAwIDVweCA1cHg7XFxufVxcbiNjb250ZW50IC50b2RvTGlzdCB0YWJsZSB0ci5jcmVhdGVkUm93IHRkIHtcXG4gIHZlcnRpY2FsLWFsaWduOiBtaWRkbGU7XFxuICBtYXgtd2lkdGg6IDYwMHB4O1xcbiAgcGFkZGluZzogMTBweCAwIDEwcHggMTBweDtcXG59XFxuI2NvbnRlbnQgLnRvZG9MaXN0IHRhYmxlIHRyLmNyZWF0ZWRSb3cgLmNvbHVtbjEge1xcbiAgZm9udC1zaXplOiAxLjVyZW07XFxufVxcbiNjb250ZW50IC50b2RvTGlzdCB0YWJsZSB0ci5jcmVhdGVkUm93IC5jb2x1bW4yIHtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBqdXN0aWZ5LWNvbnRlbnQ6IGZsZXgtZW5kO1xcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gIGdhcDogMTBweDtcXG4gIGZvbnQtc2l6ZTogMS4zcmVtO1xcbn1cXG4jY29udGVudCAudG9kb0xpc3QgdGFibGUgLnZpZXdPbmx5IHRkIHtcXG4gIHZlcnRpY2FsLWFsaWduOiBtaWRkbGU7XFxuICBtYXgtd2lkdGg6IDYwMHB4O1xcbiAgcGFkZGluZzogMTBweCAwIDEwcHggMTBweDtcXG59XFxuI2NvbnRlbnQgLnRvZG9MaXN0IHRhYmxlIC52aWV3T25seSAuY29sdW1uMSB7XFxuICBmb250LXNpemU6IDEuNXJlbTtcXG59XFxuI2NvbnRlbnQgLnRvZG9MaXN0IHRhYmxlIC52aWV3T25seSAuY29sdW1uMiB7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAganVzdGlmeS1jb250ZW50OiBmbGV4LWVuZDtcXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICBnYXA6IDEwcHg7XFxuICBmb250LXNpemU6IDEuNXJlbTtcXG59XFxuXFxuaSwgLmFkZFRvRG9CdG4sIC5hZGRQcm9qZWN0QnRuIHtcXG4gIGN1cnNvcjogcG9pbnRlcjtcXG59XFxuXFxuLmZhLWNhbGVuZGFyLWRheSwgLmZhLWJhcnMtcHJvZ3Jlc3Mge1xcbiAgY3Vyc29yOiBkZWZhdWx0O1xcbn1cXG5cXG4uZmEtYmFycy1wcm9ncmVzcywgLmZhLWNhbGVuZGFyLCAuZmEtZXhjbGFtYXRpb24sIC5mYS1jYWxlbmRhci1kYXkge1xcbiAgbWFyZ2luLWxlZnQ6IDEwcHg7XFxufVxcblxcbi5jb21wbGV0ZWQge1xcbiAgb3BhY2l0eTogMC41O1xcbiAgdGV4dC1kZWNvcmF0aW9uOiBsaW5lLXRocm91Z2g7XFxufVxcblxcbiNtb2RhbCwgI2VkaXRNb2RhbCwgI3Byb2plY3RNb2RhbCB7XFxuICBtYXJnaW46IGF1dG8gYXV0bztcXG4gIG1heC13aWR0aDogMTAwY2g7XFxuICBwYWRkaW5nOiAxMHB4O1xcbiAgYm9yZGVyOiAwO1xcbiAgYm9yZGVyLXJhZGl1czogMTBweDtcXG4gIGJveC1zaGFkb3c6IDAgMCAxZW0gcmdiYSgwLCAwLCAwLCAwLjMpO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogc2FsbW9uO1xcbn1cXG4jbW9kYWwgaDIsICNlZGl0TW9kYWwgaDIsICNwcm9qZWN0TW9kYWwgaDIge1xcbiAgbGV0dGVyLXNwYWNpbmc6IDVweDtcXG4gIHRleHQtYWxpZ246IGNlbnRlcjtcXG4gIGZvbnQtc2l6ZTogMS4ycmVtO1xcbn1cXG4jbW9kYWwgLmVkaXRGb3JtLCAjbW9kYWwgLnByb2plY3RGb3JtLCAjbW9kYWwgLmZvcm0sICNlZGl0TW9kYWwgLmVkaXRGb3JtLCAjZWRpdE1vZGFsIC5wcm9qZWN0Rm9ybSwgI2VkaXRNb2RhbCAuZm9ybSwgI3Byb2plY3RNb2RhbCAuZWRpdEZvcm0sICNwcm9qZWN0TW9kYWwgLnByb2plY3RGb3JtLCAjcHJvamVjdE1vZGFsIC5mb3JtIHtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xcbiAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxuICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgaGVpZ2h0OiA0MDBweDtcXG4gIHdpZHRoOiAzNTBweDtcXG4gIGdhcDogMjBweDtcXG4gIGZvbnQtc2l6ZTogMS4ycmVtO1xcbiAgZm9udC13ZWlnaHQ6IGJvbGQ7XFxufVxcbiNtb2RhbCAuZWRpdEZvcm0gbGFiZWwsICNtb2RhbCAuZWRpdEZvcm0gdGV4dGFyZWEsICNtb2RhbCAuZWRpdEZvcm0gaW5wdXRbdHlwZT10ZXh0XSxcXG4jbW9kYWwgLmVkaXRGb3JtIGlucHV0W3R5cGU9ZGF0ZXRpbWUtbG9jYWxdLCAjbW9kYWwgLmVkaXRGb3JtIC5idG5zLCAjbW9kYWwgLnByb2plY3RGb3JtIGxhYmVsLCAjbW9kYWwgLnByb2plY3RGb3JtIHRleHRhcmVhLCAjbW9kYWwgLnByb2plY3RGb3JtIGlucHV0W3R5cGU9dGV4dF0sXFxuI21vZGFsIC5wcm9qZWN0Rm9ybSBpbnB1dFt0eXBlPWRhdGV0aW1lLWxvY2FsXSwgI21vZGFsIC5wcm9qZWN0Rm9ybSAuYnRucywgI21vZGFsIC5mb3JtIGxhYmVsLCAjbW9kYWwgLmZvcm0gdGV4dGFyZWEsICNtb2RhbCAuZm9ybSBpbnB1dFt0eXBlPXRleHRdLFxcbiNtb2RhbCAuZm9ybSBpbnB1dFt0eXBlPWRhdGV0aW1lLWxvY2FsXSwgI21vZGFsIC5mb3JtIC5idG5zLCAjZWRpdE1vZGFsIC5lZGl0Rm9ybSBsYWJlbCwgI2VkaXRNb2RhbCAuZWRpdEZvcm0gdGV4dGFyZWEsICNlZGl0TW9kYWwgLmVkaXRGb3JtIGlucHV0W3R5cGU9dGV4dF0sXFxuI2VkaXRNb2RhbCAuZWRpdEZvcm0gaW5wdXRbdHlwZT1kYXRldGltZS1sb2NhbF0sICNlZGl0TW9kYWwgLmVkaXRGb3JtIC5idG5zLCAjZWRpdE1vZGFsIC5wcm9qZWN0Rm9ybSBsYWJlbCwgI2VkaXRNb2RhbCAucHJvamVjdEZvcm0gdGV4dGFyZWEsICNlZGl0TW9kYWwgLnByb2plY3RGb3JtIGlucHV0W3R5cGU9dGV4dF0sXFxuI2VkaXRNb2RhbCAucHJvamVjdEZvcm0gaW5wdXRbdHlwZT1kYXRldGltZS1sb2NhbF0sICNlZGl0TW9kYWwgLnByb2plY3RGb3JtIC5idG5zLCAjZWRpdE1vZGFsIC5mb3JtIGxhYmVsLCAjZWRpdE1vZGFsIC5mb3JtIHRleHRhcmVhLCAjZWRpdE1vZGFsIC5mb3JtIGlucHV0W3R5cGU9dGV4dF0sXFxuI2VkaXRNb2RhbCAuZm9ybSBpbnB1dFt0eXBlPWRhdGV0aW1lLWxvY2FsXSwgI2VkaXRNb2RhbCAuZm9ybSAuYnRucywgI3Byb2plY3RNb2RhbCAuZWRpdEZvcm0gbGFiZWwsICNwcm9qZWN0TW9kYWwgLmVkaXRGb3JtIHRleHRhcmVhLCAjcHJvamVjdE1vZGFsIC5lZGl0Rm9ybSBpbnB1dFt0eXBlPXRleHRdLFxcbiNwcm9qZWN0TW9kYWwgLmVkaXRGb3JtIGlucHV0W3R5cGU9ZGF0ZXRpbWUtbG9jYWxdLCAjcHJvamVjdE1vZGFsIC5lZGl0Rm9ybSAuYnRucywgI3Byb2plY3RNb2RhbCAucHJvamVjdEZvcm0gbGFiZWwsICNwcm9qZWN0TW9kYWwgLnByb2plY3RGb3JtIHRleHRhcmVhLCAjcHJvamVjdE1vZGFsIC5wcm9qZWN0Rm9ybSBpbnB1dFt0eXBlPXRleHRdLFxcbiNwcm9qZWN0TW9kYWwgLnByb2plY3RGb3JtIGlucHV0W3R5cGU9ZGF0ZXRpbWUtbG9jYWxdLCAjcHJvamVjdE1vZGFsIC5wcm9qZWN0Rm9ybSAuYnRucywgI3Byb2plY3RNb2RhbCAuZm9ybSBsYWJlbCwgI3Byb2plY3RNb2RhbCAuZm9ybSB0ZXh0YXJlYSwgI3Byb2plY3RNb2RhbCAuZm9ybSBpbnB1dFt0eXBlPXRleHRdLFxcbiNwcm9qZWN0TW9kYWwgLmZvcm0gaW5wdXRbdHlwZT1kYXRldGltZS1sb2NhbF0sICNwcm9qZWN0TW9kYWwgLmZvcm0gLmJ0bnMge1xcbiAgbGV0dGVyLXNwYWNpbmc6IDFweDtcXG4gIHdpZHRoOiAyMDBweDtcXG4gIGZvbnQtZmFtaWx5OiBSb2JvdG8sIE94eWdlbiwgVWJ1bnR1LCBDYW50YXJlbGwsIFxcXCJPcGVuIFNhbnNcXFwiLCBcXFwiSGVsdmV0aWNhIE5ldWVcXFwiLCBzYW5zLXNlcmlmO1xcbn1cXG4jbW9kYWwgLmVkaXRGb3JtIGlucHV0LCAjbW9kYWwgLmVkaXRGb3JtIHRleHRhcmVhLCAjbW9kYWwgLmVkaXRGb3JtIHNlbGVjdCwgI21vZGFsIC5wcm9qZWN0Rm9ybSBpbnB1dCwgI21vZGFsIC5wcm9qZWN0Rm9ybSB0ZXh0YXJlYSwgI21vZGFsIC5wcm9qZWN0Rm9ybSBzZWxlY3QsICNtb2RhbCAuZm9ybSBpbnB1dCwgI21vZGFsIC5mb3JtIHRleHRhcmVhLCAjbW9kYWwgLmZvcm0gc2VsZWN0LCAjZWRpdE1vZGFsIC5lZGl0Rm9ybSBpbnB1dCwgI2VkaXRNb2RhbCAuZWRpdEZvcm0gdGV4dGFyZWEsICNlZGl0TW9kYWwgLmVkaXRGb3JtIHNlbGVjdCwgI2VkaXRNb2RhbCAucHJvamVjdEZvcm0gaW5wdXQsICNlZGl0TW9kYWwgLnByb2plY3RGb3JtIHRleHRhcmVhLCAjZWRpdE1vZGFsIC5wcm9qZWN0Rm9ybSBzZWxlY3QsICNlZGl0TW9kYWwgLmZvcm0gaW5wdXQsICNlZGl0TW9kYWwgLmZvcm0gdGV4dGFyZWEsICNlZGl0TW9kYWwgLmZvcm0gc2VsZWN0LCAjcHJvamVjdE1vZGFsIC5lZGl0Rm9ybSBpbnB1dCwgI3Byb2plY3RNb2RhbCAuZWRpdEZvcm0gdGV4dGFyZWEsICNwcm9qZWN0TW9kYWwgLmVkaXRGb3JtIHNlbGVjdCwgI3Byb2plY3RNb2RhbCAucHJvamVjdEZvcm0gaW5wdXQsICNwcm9qZWN0TW9kYWwgLnByb2plY3RGb3JtIHRleHRhcmVhLCAjcHJvamVjdE1vZGFsIC5wcm9qZWN0Rm9ybSBzZWxlY3QsICNwcm9qZWN0TW9kYWwgLmZvcm0gaW5wdXQsICNwcm9qZWN0TW9kYWwgLmZvcm0gdGV4dGFyZWEsICNwcm9qZWN0TW9kYWwgLmZvcm0gc2VsZWN0IHtcXG4gIGJhY2tncm91bmQtY29sb3I6IHdoaXRlO1xcbn1cXG4jbW9kYWwgLmVkaXRGb3JtIHRleHRhcmVhLCAjbW9kYWwgLnByb2plY3RGb3JtIHRleHRhcmVhLCAjbW9kYWwgLmZvcm0gdGV4dGFyZWEsICNlZGl0TW9kYWwgLmVkaXRGb3JtIHRleHRhcmVhLCAjZWRpdE1vZGFsIC5wcm9qZWN0Rm9ybSB0ZXh0YXJlYSwgI2VkaXRNb2RhbCAuZm9ybSB0ZXh0YXJlYSwgI3Byb2plY3RNb2RhbCAuZWRpdEZvcm0gdGV4dGFyZWEsICNwcm9qZWN0TW9kYWwgLnByb2plY3RGb3JtIHRleHRhcmVhLCAjcHJvamVjdE1vZGFsIC5mb3JtIHRleHRhcmVhIHtcXG4gIHBhZGRpbmc6IDEwcHg7XFxuICBtYXgtd2lkdGg6IDEwMCU7XFxuICBsaW5lLWhlaWdodDogMS41O1xcbiAgYm9yZGVyLXJhZGl1czogNXB4O1xcbiAgYm9yZGVyOiAxcHggc29saWQgI2NjYztcXG4gIGJveC1zaGFkb3c6IDFweCAxcHggMXB4ICM5OTk7XFxufVxcbiNtb2RhbCAuZWRpdEZvcm0gbGFiZWwsICNtb2RhbCAucHJvamVjdEZvcm0gbGFiZWwsICNtb2RhbCAuZm9ybSBsYWJlbCwgI2VkaXRNb2RhbCAuZWRpdEZvcm0gbGFiZWwsICNlZGl0TW9kYWwgLnByb2plY3RGb3JtIGxhYmVsLCAjZWRpdE1vZGFsIC5mb3JtIGxhYmVsLCAjcHJvamVjdE1vZGFsIC5lZGl0Rm9ybSBsYWJlbCwgI3Byb2plY3RNb2RhbCAucHJvamVjdEZvcm0gbGFiZWwsICNwcm9qZWN0TW9kYWwgLmZvcm0gbGFiZWwge1xcbiAgZGlzcGxheTogYmxvY2s7XFxuICBtYXJnaW4tYm90dG9tOiA1cHg7XFxufVxcbiNtb2RhbCAuZWRpdEZvcm0gaW5wdXRbdHlwZT10ZXh0XSwgI21vZGFsIC5wcm9qZWN0Rm9ybSBpbnB1dFt0eXBlPXRleHRdLCAjbW9kYWwgLmZvcm0gaW5wdXRbdHlwZT10ZXh0XSwgI2VkaXRNb2RhbCAuZWRpdEZvcm0gaW5wdXRbdHlwZT10ZXh0XSwgI2VkaXRNb2RhbCAucHJvamVjdEZvcm0gaW5wdXRbdHlwZT10ZXh0XSwgI2VkaXRNb2RhbCAuZm9ybSBpbnB1dFt0eXBlPXRleHRdLCAjcHJvamVjdE1vZGFsIC5lZGl0Rm9ybSBpbnB1dFt0eXBlPXRleHRdLCAjcHJvamVjdE1vZGFsIC5wcm9qZWN0Rm9ybSBpbnB1dFt0eXBlPXRleHRdLCAjcHJvamVjdE1vZGFsIC5mb3JtIGlucHV0W3R5cGU9dGV4dF0ge1xcbiAgcGFkZGluZzogNXB4O1xcbn1cXG4jbW9kYWwgLmVkaXRGb3JtIC5idG5zLCAjbW9kYWwgLnByb2plY3RGb3JtIC5idG5zLCAjbW9kYWwgLmZvcm0gLmJ0bnMsICNlZGl0TW9kYWwgLmVkaXRGb3JtIC5idG5zLCAjZWRpdE1vZGFsIC5wcm9qZWN0Rm9ybSAuYnRucywgI2VkaXRNb2RhbCAuZm9ybSAuYnRucywgI3Byb2plY3RNb2RhbCAuZWRpdEZvcm0gLmJ0bnMsICNwcm9qZWN0TW9kYWwgLnByb2plY3RGb3JtIC5idG5zLCAjcHJvamVjdE1vZGFsIC5mb3JtIC5idG5zIHtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICBnYXA6IDVweDtcXG59XFxuI21vZGFsIC5lZGl0Rm9ybSAuYnRucyAuc3VibWl0UHJvamVjdEJ0biwgI21vZGFsIC5lZGl0Rm9ybSAuYnRucyAuY2FuY2VsUHJvamVjdEJ0bixcXG4jbW9kYWwgLmVkaXRGb3JtIC5idG5zIC5jcmVhdGVNb2RhbFN1Ym1pdEJ0biwgI21vZGFsIC5lZGl0Rm9ybSAuYnRucyAuY3JlYXRlTW9kYWxDYW5jZWxCdG4sXFxuI21vZGFsIC5lZGl0Rm9ybSAuYnRucyAuY2FuY2VsRWRpdEJ0biwgI21vZGFsIC5lZGl0Rm9ybSAuYnRucyAuc3VibWl0RWRpdEJ0biwgI21vZGFsIC5wcm9qZWN0Rm9ybSAuYnRucyAuc3VibWl0UHJvamVjdEJ0biwgI21vZGFsIC5wcm9qZWN0Rm9ybSAuYnRucyAuY2FuY2VsUHJvamVjdEJ0bixcXG4jbW9kYWwgLnByb2plY3RGb3JtIC5idG5zIC5jcmVhdGVNb2RhbFN1Ym1pdEJ0biwgI21vZGFsIC5wcm9qZWN0Rm9ybSAuYnRucyAuY3JlYXRlTW9kYWxDYW5jZWxCdG4sXFxuI21vZGFsIC5wcm9qZWN0Rm9ybSAuYnRucyAuY2FuY2VsRWRpdEJ0biwgI21vZGFsIC5wcm9qZWN0Rm9ybSAuYnRucyAuc3VibWl0RWRpdEJ0biwgI21vZGFsIC5mb3JtIC5idG5zIC5zdWJtaXRQcm9qZWN0QnRuLCAjbW9kYWwgLmZvcm0gLmJ0bnMgLmNhbmNlbFByb2plY3RCdG4sXFxuI21vZGFsIC5mb3JtIC5idG5zIC5jcmVhdGVNb2RhbFN1Ym1pdEJ0biwgI21vZGFsIC5mb3JtIC5idG5zIC5jcmVhdGVNb2RhbENhbmNlbEJ0bixcXG4jbW9kYWwgLmZvcm0gLmJ0bnMgLmNhbmNlbEVkaXRCdG4sICNtb2RhbCAuZm9ybSAuYnRucyAuc3VibWl0RWRpdEJ0biwgI2VkaXRNb2RhbCAuZWRpdEZvcm0gLmJ0bnMgLnN1Ym1pdFByb2plY3RCdG4sICNlZGl0TW9kYWwgLmVkaXRGb3JtIC5idG5zIC5jYW5jZWxQcm9qZWN0QnRuLFxcbiNlZGl0TW9kYWwgLmVkaXRGb3JtIC5idG5zIC5jcmVhdGVNb2RhbFN1Ym1pdEJ0biwgI2VkaXRNb2RhbCAuZWRpdEZvcm0gLmJ0bnMgLmNyZWF0ZU1vZGFsQ2FuY2VsQnRuLFxcbiNlZGl0TW9kYWwgLmVkaXRGb3JtIC5idG5zIC5jYW5jZWxFZGl0QnRuLCAjZWRpdE1vZGFsIC5lZGl0Rm9ybSAuYnRucyAuc3VibWl0RWRpdEJ0biwgI2VkaXRNb2RhbCAucHJvamVjdEZvcm0gLmJ0bnMgLnN1Ym1pdFByb2plY3RCdG4sICNlZGl0TW9kYWwgLnByb2plY3RGb3JtIC5idG5zIC5jYW5jZWxQcm9qZWN0QnRuLFxcbiNlZGl0TW9kYWwgLnByb2plY3RGb3JtIC5idG5zIC5jcmVhdGVNb2RhbFN1Ym1pdEJ0biwgI2VkaXRNb2RhbCAucHJvamVjdEZvcm0gLmJ0bnMgLmNyZWF0ZU1vZGFsQ2FuY2VsQnRuLFxcbiNlZGl0TW9kYWwgLnByb2plY3RGb3JtIC5idG5zIC5jYW5jZWxFZGl0QnRuLCAjZWRpdE1vZGFsIC5wcm9qZWN0Rm9ybSAuYnRucyAuc3VibWl0RWRpdEJ0biwgI2VkaXRNb2RhbCAuZm9ybSAuYnRucyAuc3VibWl0UHJvamVjdEJ0biwgI2VkaXRNb2RhbCAuZm9ybSAuYnRucyAuY2FuY2VsUHJvamVjdEJ0bixcXG4jZWRpdE1vZGFsIC5mb3JtIC5idG5zIC5jcmVhdGVNb2RhbFN1Ym1pdEJ0biwgI2VkaXRNb2RhbCAuZm9ybSAuYnRucyAuY3JlYXRlTW9kYWxDYW5jZWxCdG4sXFxuI2VkaXRNb2RhbCAuZm9ybSAuYnRucyAuY2FuY2VsRWRpdEJ0biwgI2VkaXRNb2RhbCAuZm9ybSAuYnRucyAuc3VibWl0RWRpdEJ0biwgI3Byb2plY3RNb2RhbCAuZWRpdEZvcm0gLmJ0bnMgLnN1Ym1pdFByb2plY3RCdG4sICNwcm9qZWN0TW9kYWwgLmVkaXRGb3JtIC5idG5zIC5jYW5jZWxQcm9qZWN0QnRuLFxcbiNwcm9qZWN0TW9kYWwgLmVkaXRGb3JtIC5idG5zIC5jcmVhdGVNb2RhbFN1Ym1pdEJ0biwgI3Byb2plY3RNb2RhbCAuZWRpdEZvcm0gLmJ0bnMgLmNyZWF0ZU1vZGFsQ2FuY2VsQnRuLFxcbiNwcm9qZWN0TW9kYWwgLmVkaXRGb3JtIC5idG5zIC5jYW5jZWxFZGl0QnRuLCAjcHJvamVjdE1vZGFsIC5lZGl0Rm9ybSAuYnRucyAuc3VibWl0RWRpdEJ0biwgI3Byb2plY3RNb2RhbCAucHJvamVjdEZvcm0gLmJ0bnMgLnN1Ym1pdFByb2plY3RCdG4sICNwcm9qZWN0TW9kYWwgLnByb2plY3RGb3JtIC5idG5zIC5jYW5jZWxQcm9qZWN0QnRuLFxcbiNwcm9qZWN0TW9kYWwgLnByb2plY3RGb3JtIC5idG5zIC5jcmVhdGVNb2RhbFN1Ym1pdEJ0biwgI3Byb2plY3RNb2RhbCAucHJvamVjdEZvcm0gLmJ0bnMgLmNyZWF0ZU1vZGFsQ2FuY2VsQnRuLFxcbiNwcm9qZWN0TW9kYWwgLnByb2plY3RGb3JtIC5idG5zIC5jYW5jZWxFZGl0QnRuLCAjcHJvamVjdE1vZGFsIC5wcm9qZWN0Rm9ybSAuYnRucyAuc3VibWl0RWRpdEJ0biwgI3Byb2plY3RNb2RhbCAuZm9ybSAuYnRucyAuc3VibWl0UHJvamVjdEJ0biwgI3Byb2plY3RNb2RhbCAuZm9ybSAuYnRucyAuY2FuY2VsUHJvamVjdEJ0bixcXG4jcHJvamVjdE1vZGFsIC5mb3JtIC5idG5zIC5jcmVhdGVNb2RhbFN1Ym1pdEJ0biwgI3Byb2plY3RNb2RhbCAuZm9ybSAuYnRucyAuY3JlYXRlTW9kYWxDYW5jZWxCdG4sXFxuI3Byb2plY3RNb2RhbCAuZm9ybSAuYnRucyAuY2FuY2VsRWRpdEJ0biwgI3Byb2plY3RNb2RhbCAuZm9ybSAuYnRucyAuc3VibWl0RWRpdEJ0biB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiBncmVlbnllbGxvdztcXG4gIG1heC13aWR0aDogNTBweDtcXG4gIHBhZGRpbmc6IDEwcHg7XFxufVxcbiNtb2RhbCAuZWRpdEZvcm0gLmJ0bnMgLnN1Ym1pdFByb2plY3RCdG46aG92ZXIsICNtb2RhbCAuZWRpdEZvcm0gLmJ0bnMgLmNhbmNlbFByb2plY3RCdG46aG92ZXIsXFxuI21vZGFsIC5lZGl0Rm9ybSAuYnRucyAuY3JlYXRlTW9kYWxTdWJtaXRCdG46aG92ZXIsICNtb2RhbCAuZWRpdEZvcm0gLmJ0bnMgLmNyZWF0ZU1vZGFsQ2FuY2VsQnRuOmhvdmVyLFxcbiNtb2RhbCAuZWRpdEZvcm0gLmJ0bnMgLmNhbmNlbEVkaXRCdG46aG92ZXIsICNtb2RhbCAuZWRpdEZvcm0gLmJ0bnMgLnN1Ym1pdEVkaXRCdG46aG92ZXIsICNtb2RhbCAucHJvamVjdEZvcm0gLmJ0bnMgLnN1Ym1pdFByb2plY3RCdG46aG92ZXIsICNtb2RhbCAucHJvamVjdEZvcm0gLmJ0bnMgLmNhbmNlbFByb2plY3RCdG46aG92ZXIsXFxuI21vZGFsIC5wcm9qZWN0Rm9ybSAuYnRucyAuY3JlYXRlTW9kYWxTdWJtaXRCdG46aG92ZXIsICNtb2RhbCAucHJvamVjdEZvcm0gLmJ0bnMgLmNyZWF0ZU1vZGFsQ2FuY2VsQnRuOmhvdmVyLFxcbiNtb2RhbCAucHJvamVjdEZvcm0gLmJ0bnMgLmNhbmNlbEVkaXRCdG46aG92ZXIsICNtb2RhbCAucHJvamVjdEZvcm0gLmJ0bnMgLnN1Ym1pdEVkaXRCdG46aG92ZXIsICNtb2RhbCAuZm9ybSAuYnRucyAuc3VibWl0UHJvamVjdEJ0bjpob3ZlciwgI21vZGFsIC5mb3JtIC5idG5zIC5jYW5jZWxQcm9qZWN0QnRuOmhvdmVyLFxcbiNtb2RhbCAuZm9ybSAuYnRucyAuY3JlYXRlTW9kYWxTdWJtaXRCdG46aG92ZXIsICNtb2RhbCAuZm9ybSAuYnRucyAuY3JlYXRlTW9kYWxDYW5jZWxCdG46aG92ZXIsXFxuI21vZGFsIC5mb3JtIC5idG5zIC5jYW5jZWxFZGl0QnRuOmhvdmVyLCAjbW9kYWwgLmZvcm0gLmJ0bnMgLnN1Ym1pdEVkaXRCdG46aG92ZXIsICNlZGl0TW9kYWwgLmVkaXRGb3JtIC5idG5zIC5zdWJtaXRQcm9qZWN0QnRuOmhvdmVyLCAjZWRpdE1vZGFsIC5lZGl0Rm9ybSAuYnRucyAuY2FuY2VsUHJvamVjdEJ0bjpob3ZlcixcXG4jZWRpdE1vZGFsIC5lZGl0Rm9ybSAuYnRucyAuY3JlYXRlTW9kYWxTdWJtaXRCdG46aG92ZXIsICNlZGl0TW9kYWwgLmVkaXRGb3JtIC5idG5zIC5jcmVhdGVNb2RhbENhbmNlbEJ0bjpob3ZlcixcXG4jZWRpdE1vZGFsIC5lZGl0Rm9ybSAuYnRucyAuY2FuY2VsRWRpdEJ0bjpob3ZlciwgI2VkaXRNb2RhbCAuZWRpdEZvcm0gLmJ0bnMgLnN1Ym1pdEVkaXRCdG46aG92ZXIsICNlZGl0TW9kYWwgLnByb2plY3RGb3JtIC5idG5zIC5zdWJtaXRQcm9qZWN0QnRuOmhvdmVyLCAjZWRpdE1vZGFsIC5wcm9qZWN0Rm9ybSAuYnRucyAuY2FuY2VsUHJvamVjdEJ0bjpob3ZlcixcXG4jZWRpdE1vZGFsIC5wcm9qZWN0Rm9ybSAuYnRucyAuY3JlYXRlTW9kYWxTdWJtaXRCdG46aG92ZXIsICNlZGl0TW9kYWwgLnByb2plY3RGb3JtIC5idG5zIC5jcmVhdGVNb2RhbENhbmNlbEJ0bjpob3ZlcixcXG4jZWRpdE1vZGFsIC5wcm9qZWN0Rm9ybSAuYnRucyAuY2FuY2VsRWRpdEJ0bjpob3ZlciwgI2VkaXRNb2RhbCAucHJvamVjdEZvcm0gLmJ0bnMgLnN1Ym1pdEVkaXRCdG46aG92ZXIsICNlZGl0TW9kYWwgLmZvcm0gLmJ0bnMgLnN1Ym1pdFByb2plY3RCdG46aG92ZXIsICNlZGl0TW9kYWwgLmZvcm0gLmJ0bnMgLmNhbmNlbFByb2plY3RCdG46aG92ZXIsXFxuI2VkaXRNb2RhbCAuZm9ybSAuYnRucyAuY3JlYXRlTW9kYWxTdWJtaXRCdG46aG92ZXIsICNlZGl0TW9kYWwgLmZvcm0gLmJ0bnMgLmNyZWF0ZU1vZGFsQ2FuY2VsQnRuOmhvdmVyLFxcbiNlZGl0TW9kYWwgLmZvcm0gLmJ0bnMgLmNhbmNlbEVkaXRCdG46aG92ZXIsICNlZGl0TW9kYWwgLmZvcm0gLmJ0bnMgLnN1Ym1pdEVkaXRCdG46aG92ZXIsICNwcm9qZWN0TW9kYWwgLmVkaXRGb3JtIC5idG5zIC5zdWJtaXRQcm9qZWN0QnRuOmhvdmVyLCAjcHJvamVjdE1vZGFsIC5lZGl0Rm9ybSAuYnRucyAuY2FuY2VsUHJvamVjdEJ0bjpob3ZlcixcXG4jcHJvamVjdE1vZGFsIC5lZGl0Rm9ybSAuYnRucyAuY3JlYXRlTW9kYWxTdWJtaXRCdG46aG92ZXIsICNwcm9qZWN0TW9kYWwgLmVkaXRGb3JtIC5idG5zIC5jcmVhdGVNb2RhbENhbmNlbEJ0bjpob3ZlcixcXG4jcHJvamVjdE1vZGFsIC5lZGl0Rm9ybSAuYnRucyAuY2FuY2VsRWRpdEJ0bjpob3ZlciwgI3Byb2plY3RNb2RhbCAuZWRpdEZvcm0gLmJ0bnMgLnN1Ym1pdEVkaXRCdG46aG92ZXIsICNwcm9qZWN0TW9kYWwgLnByb2plY3RGb3JtIC5idG5zIC5zdWJtaXRQcm9qZWN0QnRuOmhvdmVyLCAjcHJvamVjdE1vZGFsIC5wcm9qZWN0Rm9ybSAuYnRucyAuY2FuY2VsUHJvamVjdEJ0bjpob3ZlcixcXG4jcHJvamVjdE1vZGFsIC5wcm9qZWN0Rm9ybSAuYnRucyAuY3JlYXRlTW9kYWxTdWJtaXRCdG46aG92ZXIsICNwcm9qZWN0TW9kYWwgLnByb2plY3RGb3JtIC5idG5zIC5jcmVhdGVNb2RhbENhbmNlbEJ0bjpob3ZlcixcXG4jcHJvamVjdE1vZGFsIC5wcm9qZWN0Rm9ybSAuYnRucyAuY2FuY2VsRWRpdEJ0bjpob3ZlciwgI3Byb2plY3RNb2RhbCAucHJvamVjdEZvcm0gLmJ0bnMgLnN1Ym1pdEVkaXRCdG46aG92ZXIsICNwcm9qZWN0TW9kYWwgLmZvcm0gLmJ0bnMgLnN1Ym1pdFByb2plY3RCdG46aG92ZXIsICNwcm9qZWN0TW9kYWwgLmZvcm0gLmJ0bnMgLmNhbmNlbFByb2plY3RCdG46aG92ZXIsXFxuI3Byb2plY3RNb2RhbCAuZm9ybSAuYnRucyAuY3JlYXRlTW9kYWxTdWJtaXRCdG46aG92ZXIsICNwcm9qZWN0TW9kYWwgLmZvcm0gLmJ0bnMgLmNyZWF0ZU1vZGFsQ2FuY2VsQnRuOmhvdmVyLFxcbiNwcm9qZWN0TW9kYWwgLmZvcm0gLmJ0bnMgLmNhbmNlbEVkaXRCdG46aG92ZXIsICNwcm9qZWN0TW9kYWwgLmZvcm0gLmJ0bnMgLnN1Ym1pdEVkaXRCdG46aG92ZXIge1xcbiAgY3Vyc29yOiBwb2ludGVyO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogd2hpdGU7XFxufVxcbiNtb2RhbCAuZWRpdEZvcm0gLmJ0bnMgLmNhbmNlbEVkaXRCdG4sICNtb2RhbCAuZWRpdEZvcm0gLmJ0bnMgLmNyZWF0ZU1vZGFsQ2FuY2VsQnRuLCAjbW9kYWwgLmVkaXRGb3JtIC5idG5zIC5jYW5jZWxQcm9qZWN0QnRuLCAjbW9kYWwgLnByb2plY3RGb3JtIC5idG5zIC5jYW5jZWxFZGl0QnRuLCAjbW9kYWwgLnByb2plY3RGb3JtIC5idG5zIC5jcmVhdGVNb2RhbENhbmNlbEJ0biwgI21vZGFsIC5wcm9qZWN0Rm9ybSAuYnRucyAuY2FuY2VsUHJvamVjdEJ0biwgI21vZGFsIC5mb3JtIC5idG5zIC5jYW5jZWxFZGl0QnRuLCAjbW9kYWwgLmZvcm0gLmJ0bnMgLmNyZWF0ZU1vZGFsQ2FuY2VsQnRuLCAjbW9kYWwgLmZvcm0gLmJ0bnMgLmNhbmNlbFByb2plY3RCdG4sICNlZGl0TW9kYWwgLmVkaXRGb3JtIC5idG5zIC5jYW5jZWxFZGl0QnRuLCAjZWRpdE1vZGFsIC5lZGl0Rm9ybSAuYnRucyAuY3JlYXRlTW9kYWxDYW5jZWxCdG4sICNlZGl0TW9kYWwgLmVkaXRGb3JtIC5idG5zIC5jYW5jZWxQcm9qZWN0QnRuLCAjZWRpdE1vZGFsIC5wcm9qZWN0Rm9ybSAuYnRucyAuY2FuY2VsRWRpdEJ0biwgI2VkaXRNb2RhbCAucHJvamVjdEZvcm0gLmJ0bnMgLmNyZWF0ZU1vZGFsQ2FuY2VsQnRuLCAjZWRpdE1vZGFsIC5wcm9qZWN0Rm9ybSAuYnRucyAuY2FuY2VsUHJvamVjdEJ0biwgI2VkaXRNb2RhbCAuZm9ybSAuYnRucyAuY2FuY2VsRWRpdEJ0biwgI2VkaXRNb2RhbCAuZm9ybSAuYnRucyAuY3JlYXRlTW9kYWxDYW5jZWxCdG4sICNlZGl0TW9kYWwgLmZvcm0gLmJ0bnMgLmNhbmNlbFByb2plY3RCdG4sICNwcm9qZWN0TW9kYWwgLmVkaXRGb3JtIC5idG5zIC5jYW5jZWxFZGl0QnRuLCAjcHJvamVjdE1vZGFsIC5lZGl0Rm9ybSAuYnRucyAuY3JlYXRlTW9kYWxDYW5jZWxCdG4sICNwcm9qZWN0TW9kYWwgLmVkaXRGb3JtIC5idG5zIC5jYW5jZWxQcm9qZWN0QnRuLCAjcHJvamVjdE1vZGFsIC5wcm9qZWN0Rm9ybSAuYnRucyAuY2FuY2VsRWRpdEJ0biwgI3Byb2plY3RNb2RhbCAucHJvamVjdEZvcm0gLmJ0bnMgLmNyZWF0ZU1vZGFsQ2FuY2VsQnRuLCAjcHJvamVjdE1vZGFsIC5wcm9qZWN0Rm9ybSAuYnRucyAuY2FuY2VsUHJvamVjdEJ0biwgI3Byb2plY3RNb2RhbCAuZm9ybSAuYnRucyAuY2FuY2VsRWRpdEJ0biwgI3Byb2plY3RNb2RhbCAuZm9ybSAuYnRucyAuY3JlYXRlTW9kYWxDYW5jZWxCdG4sICNwcm9qZWN0TW9kYWwgLmZvcm0gLmJ0bnMgLmNhbmNlbFByb2plY3RCdG4ge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogcmVkO1xcbn1cXG4jbW9kYWwgPiAqLCAjZWRpdE1vZGFsID4gKiwgI3Byb2plY3RNb2RhbCA+ICoge1xcbiAgbWFyZ2luOiAwIDAgMC41cmVtIDA7XFxufVxcbiNtb2RhbDo6YmFja2Ryb3AsICNlZGl0TW9kYWw6OmJhY2tkcm9wLCAjcHJvamVjdE1vZGFsOjpiYWNrZHJvcCB7XFxuICBiYWNrZ3JvdW5kOiByZ2JhKDAsIDAsIDAsIDAuNCk7XFxufVxcblxcbiNwcm9qZWN0TW9kYWwgLnByb2plY3RGb3JtIHtcXG4gIGhlaWdodDogMTIwcHg7XFxuICB3aWR0aDogMjUwcHg7XFxufVxcblxcbi5mb290ZXIge1xcbiAgZm9udC1zaXplOiAxcmVtO1xcbiAgZm9udC1mYW1pbHk6IFJvYm90bywgT3h5Z2VuLCBVYnVudHUsIENhbnRhcmVsbCwgXFxcIk9wZW4gU2Fuc1xcXCIsIFxcXCJIZWx2ZXRpY2EgTmV1ZVxcXCIsIHNhbnMtc2VyaWY7XFxuICBwYWRkaW5nOiAxMHB4O1xcbiAgYmFja2dyb3VuZC1jb2xvcjogIzgwZjBlNDtcXG4gIHRleHQtYWxpZ246IGNlbnRlcjtcXG59XFxuXFxuLmZhLWNpcmNsZS1wbHVzLFxcbi5mYS1naXRodWIsXFxuLmZhLWxpbmtlZGluLFxcbi5zdmcge1xcbiAgdHJhbnNpdGlvbi1kdXJhdGlvbjogMC43NXM7XFxuICB0cmFuc2Zvcm06IHJvdGF0ZSg3MjBkZWcpIHNjYWxlKDEuNSk7XFxuICBjdXJzb3I6IHBvaW50ZXI7XFxufVwiLCBcIlwiLHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIndlYnBhY2s6Ly8uL3NyYy9zdHlsZS5zY3NzXCIsXCJ3ZWJwYWNrOi8vLi9zcmMvc2Nzcy9fZ2xvYmFscy5zY3NzXCJdLFwibmFtZXNcIjpbXSxcIm1hcHBpbmdzXCI6XCJBQVFBO0VBQ0ksVUFBQTtFQUNBLFNBQUE7RUFDQSxzQkFBQTtBQVBKOztBQVVBO0VBQ0ksbUNBQUE7RUFDQSxhQUFBO0VBQ0EsWUFBQTtFQUNBLGFBQUE7RUFDQSxzQkFBQTtBQVBKOztBQVVBO0VBbkJJLGFBQUE7RUFDQSx1QkFBQTtFQUNBLG1CQUFBO0VBbUJBLDJCQUFBO0VBQ0EsdUNDdkJLO0VEd0JMLFlDekJHO0VEMEJILGlCQUFBO0VBQ0EsZ0JBQUE7RUFDQSxTQUFBO0VBQ0EsV0FBQTtBQUxKO0FBTUk7RUFDSSxnQkFBQTtFQUNBLFlBQUE7QUFKUjs7QUFRQTtFQUNJLGFBQUE7RUFDQSw4QkFBQTtFQUNBLGFBQUE7QUFMSjtBQU1JO0VBQ0ksaUJBQUE7RUFDQSxhQUFBO0VBQ0EsdUNDekNFO0FEcUNWO0FBS1E7RUFDSSxrQkFBQTtFQUNBLHFCQUFBO0FBSFo7QUFJWTtFQUNJLGFBQUE7RUFDQSxxQkFBQTtFQUNBLFlDL0NEO0VEZ0RDLDBCQUFBO0FBRmhCO0FBSVk7RUFDSSxlQUFBO0FBRmhCO0FBS1E7RUFDSSx5QkNwREM7RURxREQsbUJBQUE7QUFIWjtBQUtRO0VBQ0ksYUFBQTtFQUNBLGFBQUE7RUFDQSxzQkFBQTtFQUNBLFNBQUE7RUFDQSx1QkFBQTtFQUNBLG1CQUFBO0VBQ0EsY0FBQTtBQUhaO0FBSVk7RUFDSSxpQkFBQTtFQUNBLFlBQUE7RUFDQSx1QkFBQTtFQUNBLGFBQUE7RUFDQSxTQUFBO0VBQ0EsdUJBQUE7RUFDQSxtQkFBQTtFQUNBLGFBQUE7RUFDQSxpQkFBQTtFQUNBLGlDQUFBO0FBRmhCO0FBR2dCO0VBQ0ksZUFBQTtBQURwQjtBQU1JO0VBQ0ksYUFBQTtFQUNBLHNCQUFBO0VBQ0EsMkJBQUE7RUFDQSxtQkFBQTtFQUNBLFNBQUE7RUFDQSx1Q0N4Rkc7QURvRlg7QUFLUTtFQUNJLGdCQUFBO0VBQ0EsZ0JBQUE7RUFDQSxpQkFBQTtFQUNBLG1CQUFBO0FBSFo7QUFJWTtFQUlJLGlCQUFBO0VBQ0EsNENBQUE7QUFMaEI7QUFDZ0I7RUFDSSxnQkFBQTtBQUNwQjtBQUdnQjtFQUNJLGlCQUFBO0FBRHBCO0FBR2dCO0VBQ0ksZ0JBQUE7QUFEcEI7QUFHZ0I7RUFDSSxlQUFBO0FBRHBCO0FBTWdCO0VBQ0ksdUJBQUE7QUFKcEI7QUFNZ0I7RUFDSSxzQkFBQTtFQUNBLGdCQUFBO0VBQ0EseUJBQUE7QUFKcEI7QUFNZ0I7RUFDSSxpQkFBQTtBQUpwQjtBQU1nQjtFQUNJLGFBQUE7RUFDQSx5QkFBQTtFQUNBLG1CQUFBO0VBQ0EsU0FBQTtFQUNBLGlCQUFBO0FBSnBCO0FBU2dCO0VBQ0ksc0JBQUE7RUFDQSxnQkFBQTtFQUNBLHlCQUFBO0FBUHBCO0FBU2dCO0VBQ0ksaUJBQUE7QUFQcEI7QUFTZ0I7RUFDSSxhQUFBO0VBQ0EseUJBQUE7RUFDQSxtQkFBQTtFQUNBLFNBQUE7RUFDQSxpQkFBQTtBQVBwQjs7QUFjQTtFQUNJLGVBQUE7QUFYSjs7QUFhQTtFQUNJLGVBQUE7QUFWSjs7QUFZQTtFQUNJLGlCQUFBO0FBVEo7O0FBWUE7RUFDSSxZQUFBO0VBQ0EsNkJBQUE7QUFUSjs7QUFhQTtFQUVJLGlCQUFBO0VBQ0EsZ0JBQUE7RUFDQSxhQUFBO0VBQ0EsU0FBQTtFQUNBLG1CQUFBO0VBQ0Esc0NBQUE7RUFDQSx3QkFBQTtBQVhKO0FBYUk7RUFDSSxtQkFBQTtFQUNBLGtCQUFBO0VBQ0EsaUJBQUE7QUFYUjtBQWNJO0VBRUksYUFBQTtFQUNBLHNCQUFBO0VBQ0EsdUJBQUE7RUFDQSxtQkFBQTtFQUNBLGFBQUE7RUFDQSxZQUFBO0VBQ0EsU0FBQTtFQUNBLGlCQUFBO0VBQ0EsaUJBQUE7QUFiUjtBQWVROzs7Ozs7Ozs7O0VBRUksbUJBQUE7RUFDQSxZQUFBO0VBQ0EseUZBQUE7QUFMWjtBQVFRO0VBQ0ksdUJBQUE7QUFOWjtBQVNRO0VBQ0ksYUFBQTtFQUNBLGVBQUE7RUFDQSxnQkFBQTtFQUNBLGtCQUFBO0VBQ0Esc0JBQUE7RUFDQSw0QkFBQTtBQVBaO0FBVVE7RUFDSSxjQUFBO0VBQ0Esa0JBQUE7QUFSWjtBQVdRO0VBQ0ksWUFBQTtBQVRaO0FBWVE7RUFwT0osYUFBQTtFQUNBLHVCQUFBO0VBQ0EsbUJBQUE7RUFvT1EsUUFBQTtBQVJaO0FBU1k7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7RUFJSSw2QkFBQTtFQUNBLGVBQUE7RUFDQSxhQUFBO0FBUWhCO0FBUGdCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0VBQ0ksZUFBQTtFQUNBLHVCQUFBO0FBMkJwQjtBQXhCWTtFQUNJLHFCQUFBO0FBMEJoQjtBQXJCSTtFQUNBLG9CQUFBO0FBdUJKO0FBckJJO0VBQ0EsOEJBQUE7QUF1Qko7O0FBakJJO0VBQ0ksYUFBQTtFQUNBLFlBQUE7QUFvQlI7O0FBaEJBO0VBQ0ksZUFBQTtFQUNBLHlGQUFBO0VBQ0EsYUFBQTtFQUNBLHlCQUFBO0VBQ0Esa0JBQUE7QUFtQko7O0FBYkE7Ozs7RUFJSSwwQkFBQTtFQUNBLG9DQUFBO0VBQ0EsZUFBQTtBQWdCSlwiLFwic291cmNlc0NvbnRlbnRcIjpbXCJAaW1wb3J0ICcuL3Njc3MvZ2xvYmFscyc7XFxuXFxuQG1peGluIGNlbnRlciB7XFxuICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xcbn1cXG5cXG4qe1xcbiAgICBwYWRkaW5nOiAwO1xcbiAgICBtYXJnaW46IDA7XFxuICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxufVxcblxcbmJvZHl7XFxuICAgIGZvbnQtZmFtaWx5OiAnQ29taW5nIFNvb24nLCBjdXJzaXZlO1xcbiAgICBoZWlnaHQ6IDEwMHZoO1xcbiAgICB3aWR0aDogMTAwdnc7XFxuICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XFxufVxcblxcbiNoZWFkZXJ7XFxuICAgIEBpbmNsdWRlIGNlbnRlcjtcXG4gICAganVzdGlmeS1jb250ZW50OiBmbGV4LXN0YXJ0O1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAkSEVBREVSO1xcbiAgICBjb2xvcjogJEZPTlQ7XFxuICAgIGZvbnQtc2l6ZTogMS44cmVtO1xcbiAgICBmb250LXdlaWdodDogOTAwO1xcbiAgICBnYXA6IDFyZW07XFxuICAgIHdpZHRoOiAxMDAlO1xcbiAgICAubG9nb3tcXG4gICAgICAgIG1heC1oZWlnaHQ6IDRyZW07XFxuICAgICAgICBwYWRkaW5nOiA1cHg7XFxuICAgIH1cXG59XFxuXFxuI2NvbnRlbnR7XFxuICAgIGRpc3BsYXk6IGdyaWQ7XFxuICAgIGdyaWQtdGVtcGxhdGUtY29sdW1uczogMWZyIDZmcjtcXG4gICAgaGVpZ2h0OiAxMDB2aDtcXG4gICAgLnNpZGViYXJ7XFxuICAgICAgICBmb250LXNpemU6IDEuNXJlbTtcXG4gICAgICAgIHBhZGRpbmc6IDEwcHg7XFxuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAkU0lERUJBUjtcXG4gICAgICAgIHVse1xcbiAgICAgICAgICAgIHRleHQtYWxpZ246IGNlbnRlcjtcXG4gICAgICAgICAgICBsaXN0LXN0eWxlLXR5cGU6IG5vbmU7XFxuICAgICAgICAgICAgLmxpbmt7XFxuICAgICAgICAgICAgICAgIHBhZGRpbmc6IDEwcHg7XFxuICAgICAgICAgICAgICAgIHRleHQtZGVjb3JhdGlvbjogbm9uZTtcXG4gICAgICAgICAgICAgICAgY29sb3I6ICRTSURFQkFSX1RFWFQ7XFxuICAgICAgICAgICAgICAgIHRleHQtc2hhZG93OiAxcHggMXB4IHdoaXRlO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAudG9kYXksIC53ZWVre1xcbiAgICAgICAgICAgICAgICBjdXJzb3I6IHBvaW50ZXI7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgbGkucHJvamVjdHNMaXtcXG4gICAgICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAkTE9HTy1DT0xPUjtcXG4gICAgICAgICAgICBib3JkZXItcmFkaXVzOiAxNXB4O1xcbiAgICAgICAgfVxcbiAgICAgICAgbGkucHJvamVjdHNMaSB1bHtcXG4gICAgICAgICAgICBwYWRkaW5nOiAxMHB4O1xcbiAgICAgICAgICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgICAgICAgICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXG4gICAgICAgICAgICBnYXA6IDEwcHg7XFxuICAgICAgICAgICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxuICAgICAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gICAgICAgICAgICBtYXJnaW46IDAgYXV0bztcXG4gICAgICAgICAgICBsaS5wcm9qZWN0e1xcbiAgICAgICAgICAgICAgICBmb250LXNpemU6IDEuM3JlbTtcXG4gICAgICAgICAgICAgICAgd2lkdGg6IDIyMHB4O1xcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB3aGl0ZTtcXG4gICAgICAgICAgICAgICAgZGlzcGxheTogZmxleDtcXG4gICAgICAgICAgICAgICAgZ2FwOiAxMHB4O1xcbiAgICAgICAgICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXG4gICAgICAgICAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gICAgICAgICAgICAgICAgcGFkZGluZzogMTBweDtcXG4gICAgICAgICAgICAgICAgYm9yZGVyOiAxcHggc29saWQ7XFxuICAgICAgICAgICAgICAgIGZvbnQtZmFtaWx5OiAncm9jayBzYWx0JywgY3Vyc2l2ZTtcXG4gICAgICAgICAgICAgICAgJjpob3ZlcntcXG4gICAgICAgICAgICAgICAgICAgIGN1cnNvcjogcG9pbnRlcjtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgfVxcbiAgICAudG9kb0xpc3R7XFxuICAgICAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICAgICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXG4gICAgICAgIGp1c3RpZnktY29udGVudDogZmxleC1zdGFydDtcXG4gICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICAgICAgICBnYXA6IDEwcHg7XFxuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAkVE9ET0xJU1Q7XFxuICAgICAgICB0YWJsZXtcXG4gICAgICAgICAgICBtYXJnaW4tdG9wOiAxMHB4O1xcbiAgICAgICAgICAgIG1pbi13aWR0aDogY2xhbXAoMzIwcHgsIDgwMHB4LCAxMDAwcHgpO1xcbiAgICAgICAgICAgIG1heC13aWR0aDogY2xhbXAoNDAwcHgsIDEyMDBweCwgMTYwMHB4KTtcXG4gICAgICAgICAgICBib3JkZXItcmFkaXVzOiAyMHB4O1xcbiAgICAgICAgICAgIC50aXRsZXN7XFxuICAgICAgICAgICAgICAgICY6aG92ZXJ7XFxuICAgICAgICAgICAgICAgICAgICBib3gtc2hhZG93OiBub25lO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIGZvbnQtc2l6ZTogMS41cmVtO1xcbiAgICAgICAgICAgICAgICBmb250LWZhbWlseTogJ1RpbWVzIE5ldyBSb21hbicsIFRpbWVzLCBzZXJpZjtcXG4gICAgICAgICAgICAgICAgLmR1ZURhdGV7XFxuICAgICAgICAgICAgICAgICAgICB0ZXh0LWFsaWduOiByaWdodDtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAucHJvak5hbWV7XFxuICAgICAgICAgICAgICAgICAgICB0ZXh0LWFsaWduOiBsZWZ0O1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIHRoe1xcbiAgICAgICAgICAgICAgICAgICAgcGFkZGluZzogMTBweCAwO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIHRyLmNyZWF0ZWRSb3d7XFxuICAgICAgICAgICAgICAgICY6aG92ZXJ7XFxuICAgICAgICAgICAgICAgICAgICBib3gtc2hhZG93OiAwIDAgNXB4IDVweDtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICB0ZHtcXG4gICAgICAgICAgICAgICAgICAgIHZlcnRpY2FsLWFsaWduOiBtaWRkbGU7XFxuICAgICAgICAgICAgICAgICAgICBtYXgtd2lkdGg6IDYwMHB4O1xcbiAgICAgICAgICAgICAgICAgICAgcGFkZGluZzogMTBweCAwIDEwcHggMTBweDtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAuY29sdW1uMXtcXG4gICAgICAgICAgICAgICAgICAgIGZvbnQtc2l6ZTogMS41cmVtO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIC5jb2x1bW4ye1xcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheTogZmxleDtcXG4gICAgICAgICAgICAgICAgICAgIGp1c3RpZnktY29udGVudDogZmxleC1lbmQ7XFxuICAgICAgICAgICAgICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgICAgICAgICAgICAgICAgICAgZ2FwOiAxMHB4O1xcbiAgICAgICAgICAgICAgICAgICAgZm9udC1zaXplOiAxLjNyZW07XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgLnZpZXdPbmx5e1xcbiAgICAgICAgICAgICAgICB0ZHtcXG4gICAgICAgICAgICAgICAgICAgIHZlcnRpY2FsLWFsaWduOiBtaWRkbGU7XFxuICAgICAgICAgICAgICAgICAgICBtYXgtd2lkdGg6IDYwMHB4O1xcbiAgICAgICAgICAgICAgICAgICAgcGFkZGluZzogMTBweCAwIDEwcHggMTBweDtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAuY29sdW1uMXtcXG4gICAgICAgICAgICAgICAgICAgIGZvbnQtc2l6ZTogMS41cmVtO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIC5jb2x1bW4ye1xcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheTogZmxleDtcXG4gICAgICAgICAgICAgICAgICAgIGp1c3RpZnktY29udGVudDogZmxleC1lbmQ7XFxuICAgICAgICAgICAgICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgICAgICAgICAgICAgICAgICAgZ2FwOiAxMHB4O1xcbiAgICAgICAgICAgICAgICAgICAgZm9udC1zaXplOiAxLjVyZW07XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgIH1cXG59XFxuXFxuaSwgLmFkZFRvRG9CdG4sIC5hZGRQcm9qZWN0QnRue1xcbiAgICBjdXJzb3I6IHBvaW50ZXI7XFxufVxcbi5mYS1jYWxlbmRhci1kYXksIC5mYS1iYXJzLXByb2dyZXNze1xcbiAgICBjdXJzb3I6IGRlZmF1bHQ7XFxufVxcbi5mYS1iYXJzLXByb2dyZXNzLCAuZmEtY2FsZW5kYXIsIC5mYS1leGNsYW1hdGlvbiwgLmZhLWNhbGVuZGFyLWRheXtcXG4gICAgbWFyZ2luLWxlZnQ6IDEwcHg7XFxufVxcblxcbi5jb21wbGV0ZWR7XFxuICAgIG9wYWNpdHk6IDAuNTtcXG4gICAgdGV4dC1kZWNvcmF0aW9uOiBsaW5lLXRocm91Z2g7XFxufVxcblxcblxcbiNtb2RhbCwgI2VkaXRNb2RhbCwgI3Byb2plY3RNb2RhbHtcXG5cXG4gICAgbWFyZ2luOiBhdXRvIGF1dG87XFxuICAgIG1heC13aWR0aDogMTAwY2g7XFxuICAgIHBhZGRpbmc6IDEwcHg7XFxuICAgIGJvcmRlcjogMDtcXG4gICAgYm9yZGVyLXJhZGl1czogMTBweDtcXG4gICAgYm94LXNoYWRvdzogMCAwIDFlbSByZ2IoMCAwIDAgLyAuMyk7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHNhbG1vbjtcXG5cXG4gICAgaDJ7XFxuICAgICAgICBsZXR0ZXItc3BhY2luZzogNXB4O1xcbiAgICAgICAgdGV4dC1hbGlnbjogY2VudGVyO1xcbiAgICAgICAgZm9udC1zaXplOiAxLjJyZW07XFxuICAgIH1cXG5cXG4gICAgLmVkaXRGb3JtLCAucHJvamVjdEZvcm0sIC5mb3Jte1xcbiAgICAgICAgXFxuICAgICAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICAgICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXG4gICAgICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xcbiAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gICAgICAgIGhlaWdodDogNDAwcHg7XFxuICAgICAgICB3aWR0aDogMzUwcHg7XFxuICAgICAgICBnYXA6IDIwcHg7XFxuICAgICAgICBmb250LXNpemU6IDEuMnJlbTtcXG4gICAgICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xcblxcbiAgICAgICAgbGFiZWwsIHRleHRhcmVhLCBpbnB1dFt0eXBlPVxcXCJ0ZXh0XFxcIl0sXFxuICAgICAgICBpbnB1dFt0eXBlPVxcXCJkYXRldGltZS1sb2NhbFxcXCJdLCAuYnRuc3tcXG4gICAgICAgICAgICBsZXR0ZXItc3BhY2luZzogMXB4O1xcbiAgICAgICAgICAgIHdpZHRoOiAyMDBweDtcXG4gICAgICAgICAgICBmb250LWZhbWlseTogUm9ib3RvLCBPeHlnZW4sIFVidW50dSwgQ2FudGFyZWxsLCAnT3BlbiBTYW5zJywgJ0hlbHZldGljYSBOZXVlJywgc2Fucy1zZXJpZjtcXG4gICAgICAgIH1cXG4gICAgICAgIFxcbiAgICAgICAgaW5wdXQsIHRleHRhcmVhLCBzZWxlY3R7XFxuICAgICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogd2hpdGU7XFxuICAgICAgICB9XFxuICAgIFxcbiAgICAgICAgdGV4dGFyZWEge1xcbiAgICAgICAgICAgIHBhZGRpbmc6IDEwcHg7XFxuICAgICAgICAgICAgbWF4LXdpZHRoOiAxMDAlO1xcbiAgICAgICAgICAgIGxpbmUtaGVpZ2h0OiAxLjU7XFxuICAgICAgICAgICAgYm9yZGVyLXJhZGl1czogNXB4O1xcbiAgICAgICAgICAgIGJvcmRlcjogMXB4IHNvbGlkICNjY2M7XFxuICAgICAgICAgICAgYm94LXNoYWRvdzogMXB4IDFweCAxcHggIzk5OTtcXG4gICAgICAgIH1cXG4gICAgXFxuICAgICAgICBsYWJlbCB7XFxuICAgICAgICAgICAgZGlzcGxheTogYmxvY2s7XFxuICAgICAgICAgICAgbWFyZ2luLWJvdHRvbTogNXB4O1xcbiAgICAgICAgfVxcbiAgICBcXG4gICAgICAgIGlucHV0W3R5cGU9XFxcInRleHRcXFwiXXtcXG4gICAgICAgICAgICBwYWRkaW5nOiA1cHg7XFxuICAgICAgICB9XFxuICAgIFxcbiAgICAgICAgLmJ0bnN7XFxuICAgICAgICAgICAgQGluY2x1ZGUgY2VudGVyO1xcbiAgICAgICAgICAgIGdhcDogNXB4O1xcbiAgICAgICAgICAgIC5zdWJtaXRQcm9qZWN0QnRuLCAuY2FuY2VsUHJvamVjdEJ0biwgXFxuICAgICAgICAgICAgLmNyZWF0ZU1vZGFsU3VibWl0QnRuLCAuY3JlYXRlTW9kYWxDYW5jZWxCdG4sXFxuICAgICAgICAgICAgLmNhbmNlbEVkaXRCdG4sIC5zdWJtaXRFZGl0QnRuXFxuICAgICAgICAgICAge1xcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiBncmVlbnllbGxvdztcXG4gICAgICAgICAgICAgICAgbWF4LXdpZHRoOiA1MHB4O1xcbiAgICAgICAgICAgICAgICBwYWRkaW5nOiAxMHB4O1xcbiAgICAgICAgICAgICAgICAmOmhvdmVye1xcbiAgICAgICAgICAgICAgICAgICAgY3Vyc29yOiBwb2ludGVyO1xcbiAgICAgICAgICAgICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogd2hpdGU7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgLmNhbmNlbEVkaXRCdG4sIC5jcmVhdGVNb2RhbENhbmNlbEJ0biwgLmNhbmNlbFByb2plY3RCdG57XFxuICAgICAgICAgICAgICAgIGJhY2tncm91bmQtY29sb3I6IHJlZDtcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgIH1cXG5cXG4gICAgJiA+ICoge1xcbiAgICBtYXJnaW46IDAgMCAwLjVyZW0gMDtcXG4gICAgfVxcbiAgICAmOjpiYWNrZHJvcHtcXG4gICAgYmFja2dyb3VuZDogcmdiKDAgMCAwIC8gMC40KTtcXG4gICAgfVxcblxcbn1cXG5cXG4jcHJvamVjdE1vZGFse1xcbiAgICAucHJvamVjdEZvcm17XFxuICAgICAgICBoZWlnaHQ6IDEyMHB4O1xcbiAgICAgICAgd2lkdGg6IDI1MHB4O1xcbiAgICB9XFxufVxcblxcbi5mb290ZXJ7XFxuICAgIGZvbnQtc2l6ZTogMXJlbTtcXG4gICAgZm9udC1mYW1pbHk6IFJvYm90bywgT3h5Z2VuLCBVYnVudHUsIENhbnRhcmVsbCwgJ09wZW4gU2FucycsICdIZWx2ZXRpY2EgTmV1ZScsIHNhbnMtc2VyaWY7XFxuICAgIHBhZGRpbmc6IDEwcHg7XFxuICAgIGJhY2tncm91bmQtY29sb3I6ICM4MGYwZTQ7XFxuICAgIHRleHQtYWxpZ246IGNlbnRlcjtcXG59XFxuXFxuXFxuLy8gYW5pbWF0aW9uXFxuXFxuLmZhLWNpcmNsZS1wbHVzLCBcXG4uZmEtZ2l0aHViLCBcXG4uZmEtbGlua2VkaW4sXFxuLnN2Z3tcXG4gICAgdHJhbnNpdGlvbi1kdXJhdGlvbjogMC43NXM7XFxuICAgIHRyYW5zZm9ybTogcm90YXRlKDcyMGRlZykgc2NhbGUoMS41KTtcXG4gICAgY3Vyc29yOiBwb2ludGVyO1xcbn1cXG5cXG5cIixcIiRCT0RZOiAjM2YzZjNmO1xcbiRGT05UOiB3aGl0ZTtcXG4kSEVBREVSOiByZ2JhKDI1NSwgNzIsIDAsIC43KTtcXG4kU0lERUJBUjogcmdiYSgyNTUsIDcyLCAwLCAuMyk7XFxuJFNJREVCQVJfVEVYVDogYmxhY2s7XFxuJFRPRE9MSVNUOiByZ2JhKDI1NSwgNzIsIDAsIC4xKTtcXG4kVE9ET19JTkZPX0ZPUk06IHdoaXRlO1xcbiRMT0dPLUNPTE9SOiAjODBmMGU0O1wiXSxcInNvdXJjZVJvb3RcIjpcIlwifV0pO1xuLy8gRXhwb3J0c1xuZXhwb3J0IGRlZmF1bHQgX19fQ1NTX0xPQURFUl9FWFBPUlRfX187XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/css-loader/dist/cjs.js!./node_modules/sass-loader/dist/cjs.js!./src/style.scss\n");

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/api.js":
/*!*****************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/api.js ***!
  \*****************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n*/\nmodule.exports = function (cssWithMappingToString) {\n  var list = []; // return the list of modules as css string\n\n  list.toString = function toString() {\n    return this.map(function (item) {\n      var content = \"\";\n      var needLayer = typeof item[5] !== \"undefined\";\n\n      if (item[4]) {\n        content += \"@supports (\".concat(item[4], \") {\");\n      }\n\n      if (item[2]) {\n        content += \"@media \".concat(item[2], \" {\");\n      }\n\n      if (needLayer) {\n        content += \"@layer\".concat(item[5].length > 0 ? \" \".concat(item[5]) : \"\", \" {\");\n      }\n\n      content += cssWithMappingToString(item);\n\n      if (needLayer) {\n        content += \"}\";\n      }\n\n      if (item[2]) {\n        content += \"}\";\n      }\n\n      if (item[4]) {\n        content += \"}\";\n      }\n\n      return content;\n    }).join(\"\");\n  }; // import a list of modules into the list\n\n\n  list.i = function i(modules, media, dedupe, supports, layer) {\n    if (typeof modules === \"string\") {\n      modules = [[null, modules, undefined]];\n    }\n\n    var alreadyImportedModules = {};\n\n    if (dedupe) {\n      for (var k = 0; k < this.length; k++) {\n        var id = this[k][0];\n\n        if (id != null) {\n          alreadyImportedModules[id] = true;\n        }\n      }\n    }\n\n    for (var _k = 0; _k < modules.length; _k++) {\n      var item = [].concat(modules[_k]);\n\n      if (dedupe && alreadyImportedModules[item[0]]) {\n        continue;\n      }\n\n      if (typeof layer !== \"undefined\") {\n        if (typeof item[5] === \"undefined\") {\n          item[5] = layer;\n        } else {\n          item[1] = \"@layer\".concat(item[5].length > 0 ? \" \".concat(item[5]) : \"\", \" {\").concat(item[1], \"}\");\n          item[5] = layer;\n        }\n      }\n\n      if (media) {\n        if (!item[2]) {\n          item[2] = media;\n        } else {\n          item[1] = \"@media \".concat(item[2], \" {\").concat(item[1], \"}\");\n          item[2] = media;\n        }\n      }\n\n      if (supports) {\n        if (!item[4]) {\n          item[4] = \"\".concat(supports);\n        } else {\n          item[1] = \"@supports (\".concat(item[4], \") {\").concat(item[1], \"}\");\n          item[4] = supports;\n        }\n      }\n\n      list.push(item);\n    }\n  };\n\n  return list;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscURBQXFEO0FBQ3JEOztBQUVBO0FBQ0EsZ0RBQWdEO0FBQ2hEOztBQUVBO0FBQ0EscUZBQXFGO0FBQ3JGOztBQUVBOztBQUVBO0FBQ0EscUJBQXFCO0FBQ3JCOztBQUVBO0FBQ0EscUJBQXFCO0FBQ3JCOztBQUVBO0FBQ0EscUJBQXFCO0FBQ3JCOztBQUVBO0FBQ0EsS0FBSztBQUNMLEtBQUs7OztBQUdMO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0Esc0JBQXNCLGlCQUFpQjtBQUN2Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFCQUFxQixxQkFBcUI7QUFDMUM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixzRkFBc0YscUJBQXFCO0FBQzNHO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsaURBQWlELHFCQUFxQjtBQUN0RTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLHNEQUFzRCxxQkFBcUI7QUFDM0U7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdG9kby1saXN0Ly4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2FwaS5qcz8yNGZiIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG4vKlxuICBNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuICBBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4qL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoY3NzV2l0aE1hcHBpbmdUb1N0cmluZykge1xuICB2YXIgbGlzdCA9IFtdOyAvLyByZXR1cm4gdGhlIGxpc3Qgb2YgbW9kdWxlcyBhcyBjc3Mgc3RyaW5nXG5cbiAgbGlzdC50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgdmFyIGNvbnRlbnQgPSBcIlwiO1xuICAgICAgdmFyIG5lZWRMYXllciA9IHR5cGVvZiBpdGVtWzVdICE9PSBcInVuZGVmaW5lZFwiO1xuXG4gICAgICBpZiAoaXRlbVs0XSkge1xuICAgICAgICBjb250ZW50ICs9IFwiQHN1cHBvcnRzIChcIi5jb25jYXQoaXRlbVs0XSwgXCIpIHtcIik7XG4gICAgICB9XG5cbiAgICAgIGlmIChpdGVtWzJdKSB7XG4gICAgICAgIGNvbnRlbnQgKz0gXCJAbWVkaWEgXCIuY29uY2F0KGl0ZW1bMl0sIFwiIHtcIik7XG4gICAgICB9XG5cbiAgICAgIGlmIChuZWVkTGF5ZXIpIHtcbiAgICAgICAgY29udGVudCArPSBcIkBsYXllclwiLmNvbmNhdChpdGVtWzVdLmxlbmd0aCA+IDAgPyBcIiBcIi5jb25jYXQoaXRlbVs1XSkgOiBcIlwiLCBcIiB7XCIpO1xuICAgICAgfVxuXG4gICAgICBjb250ZW50ICs9IGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSk7XG5cbiAgICAgIGlmIChuZWVkTGF5ZXIpIHtcbiAgICAgICAgY29udGVudCArPSBcIn1cIjtcbiAgICAgIH1cblxuICAgICAgaWYgKGl0ZW1bMl0pIHtcbiAgICAgICAgY29udGVudCArPSBcIn1cIjtcbiAgICAgIH1cblxuICAgICAgaWYgKGl0ZW1bNF0pIHtcbiAgICAgICAgY29udGVudCArPSBcIn1cIjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgfSkuam9pbihcIlwiKTtcbiAgfTsgLy8gaW1wb3J0IGEgbGlzdCBvZiBtb2R1bGVzIGludG8gdGhlIGxpc3RcblxuXG4gIGxpc3QuaSA9IGZ1bmN0aW9uIGkobW9kdWxlcywgbWVkaWEsIGRlZHVwZSwgc3VwcG9ydHMsIGxheWVyKSB7XG4gICAgaWYgKHR5cGVvZiBtb2R1bGVzID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBtb2R1bGVzID0gW1tudWxsLCBtb2R1bGVzLCB1bmRlZmluZWRdXTtcbiAgICB9XG5cbiAgICB2YXIgYWxyZWFkeUltcG9ydGVkTW9kdWxlcyA9IHt9O1xuXG4gICAgaWYgKGRlZHVwZSkge1xuICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCB0aGlzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgIHZhciBpZCA9IHRoaXNba11bMF07XG5cbiAgICAgICAgaWYgKGlkICE9IG51bGwpIHtcbiAgICAgICAgICBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2lkXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKHZhciBfayA9IDA7IF9rIDwgbW9kdWxlcy5sZW5ndGg7IF9rKyspIHtcbiAgICAgIHZhciBpdGVtID0gW10uY29uY2F0KG1vZHVsZXNbX2tdKTtcblxuICAgICAgaWYgKGRlZHVwZSAmJiBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2l0ZW1bMF1dKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGxheWVyICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaXRlbVs1XSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgIGl0ZW1bNV0gPSBsYXllcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpdGVtWzFdID0gXCJAbGF5ZXJcIi5jb25jYXQoaXRlbVs1XS5sZW5ndGggPiAwID8gXCIgXCIuY29uY2F0KGl0ZW1bNV0pIDogXCJcIiwgXCIge1wiKS5jb25jYXQoaXRlbVsxXSwgXCJ9XCIpO1xuICAgICAgICAgIGl0ZW1bNV0gPSBsYXllcjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAobWVkaWEpIHtcbiAgICAgICAgaWYgKCFpdGVtWzJdKSB7XG4gICAgICAgICAgaXRlbVsyXSA9IG1lZGlhO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGl0ZW1bMV0gPSBcIkBtZWRpYSBcIi5jb25jYXQoaXRlbVsyXSwgXCIge1wiKS5jb25jYXQoaXRlbVsxXSwgXCJ9XCIpO1xuICAgICAgICAgIGl0ZW1bMl0gPSBtZWRpYTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoc3VwcG9ydHMpIHtcbiAgICAgICAgaWYgKCFpdGVtWzRdKSB7XG4gICAgICAgICAgaXRlbVs0XSA9IFwiXCIuY29uY2F0KHN1cHBvcnRzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpdGVtWzFdID0gXCJAc3VwcG9ydHMgKFwiLmNvbmNhdChpdGVtWzRdLCBcIikge1wiKS5jb25jYXQoaXRlbVsxXSwgXCJ9XCIpO1xuICAgICAgICAgIGl0ZW1bNF0gPSBzdXBwb3J0cztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBsaXN0LnB1c2goaXRlbSk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBsaXN0O1xufTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/css-loader/dist/runtime/api.js\n");

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/sourceMaps.js":
/*!************************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/sourceMaps.js ***!
  \************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = function (item) {\n  var content = item[1];\n  var cssMapping = item[3];\n\n  if (!cssMapping) {\n    return content;\n  }\n\n  if (typeof btoa === \"function\") {\n    var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(cssMapping))));\n    var data = \"sourceMappingURL=data:application/json;charset=utf-8;base64,\".concat(base64);\n    var sourceMapping = \"/*# \".concat(data, \" */\");\n    var sourceURLs = cssMapping.sources.map(function (source) {\n      return \"/*# sourceURL=\".concat(cssMapping.sourceRoot || \"\").concat(source, \" */\");\n    });\n    return [content].concat(sourceURLs).concat([sourceMapping]).join(\"\\n\");\n  }\n\n  return [content].join(\"\\n\");\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvc291cmNlTWFwcy5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1REFBdUQsY0FBYztBQUNyRTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdG9kby1saXN0Ly4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL3NvdXJjZU1hcHMuanM/YWYxMiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXRlbSkge1xuICB2YXIgY29udGVudCA9IGl0ZW1bMV07XG4gIHZhciBjc3NNYXBwaW5nID0gaXRlbVszXTtcblxuICBpZiAoIWNzc01hcHBpbmcpIHtcbiAgICByZXR1cm4gY29udGVudDtcbiAgfVxuXG4gIGlmICh0eXBlb2YgYnRvYSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgdmFyIGJhc2U2NCA9IGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KGNzc01hcHBpbmcpKSkpO1xuICAgIHZhciBkYXRhID0gXCJzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxcIi5jb25jYXQoYmFzZTY0KTtcbiAgICB2YXIgc291cmNlTWFwcGluZyA9IFwiLyojIFwiLmNvbmNhdChkYXRhLCBcIiAqL1wiKTtcbiAgICB2YXIgc291cmNlVVJMcyA9IGNzc01hcHBpbmcuc291cmNlcy5tYXAoZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgICAgcmV0dXJuIFwiLyojIHNvdXJjZVVSTD1cIi5jb25jYXQoY3NzTWFwcGluZy5zb3VyY2VSb290IHx8IFwiXCIpLmNvbmNhdChzb3VyY2UsIFwiICovXCIpO1xuICAgIH0pO1xuICAgIHJldHVybiBbY29udGVudF0uY29uY2F0KHNvdXJjZVVSTHMpLmNvbmNhdChbc291cmNlTWFwcGluZ10pLmpvaW4oXCJcXG5cIik7XG4gIH1cblxuICByZXR1cm4gW2NvbnRlbnRdLmpvaW4oXCJcXG5cIik7XG59OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/css-loader/dist/runtime/sourceMaps.js\n");

/***/ }),

/***/ "./node_modules/escape-string-regexp/index.js":
/*!****************************************************!*\
  !*** ./node_modules/escape-string-regexp/index.js ***!
  \****************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nvar matchOperatorsRe = /[|\\\\{}()[\\]^$+*?.]/g;\n\nmodule.exports = function (str) {\n\tif (typeof str !== 'string') {\n\t\tthrow new TypeError('Expected a string');\n\t}\n\n\treturn str.replace(matchOperatorsRe, '\\\\$&');\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZXNjYXBlLXN0cmluZy1yZWdleHAvaW5kZXguanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOEJBQThCOztBQUU5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdG9kby1saXN0Ly4vbm9kZV9tb2R1bGVzL2VzY2FwZS1zdHJpbmctcmVnZXhwL2luZGV4LmpzP2EzMTgiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgbWF0Y2hPcGVyYXRvcnNSZSA9IC9bfFxcXFx7fSgpW1xcXV4kKyo/Ll0vZztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc3RyKSB7XG5cdGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJykge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIGEgc3RyaW5nJyk7XG5cdH1cblxuXHRyZXR1cm4gc3RyLnJlcGxhY2UobWF0Y2hPcGVyYXRvcnNSZSwgJ1xcXFwkJicpO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/escape-string-regexp/index.js\n");

/***/ }),

/***/ "./node_modules/events/events.js":
/*!***************************************!*\
  !*** ./node_modules/events/events.js ***!
  \***************************************/
/***/ ((module) => {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\nvar R = typeof Reflect === 'object' ? Reflect : null\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  }\n\nvar ReflectOwnKeys\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target)\n      .concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n}\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\nmodule.exports.once = once;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nfunction checkListener(listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n}\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  checkListener(listener);\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = _getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\n                          existing.length + ' ' + String(type) + ' listeners ' +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0)\n      return this.listener.call(this.target);\n    return this.listener.apply(this.target, arguments);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  checkListener(listener);\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      checkListener(listener);\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      checkListener(listener);\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\nfunction once(emitter, name) {\n  return new Promise(function (resolve, reject) {\n    function errorListener(err) {\n      emitter.removeListener(name, resolver);\n      reject(err);\n    }\n\n    function resolver() {\n      if (typeof emitter.removeListener === 'function') {\n        emitter.removeListener('error', errorListener);\n      }\n      resolve([].slice.call(arguments));\n    };\n\n    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });\n    if (name !== 'error') {\n      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });\n    }\n  });\n}\n\nfunction addErrorHandlerIfEventEmitter(emitter, handler, flags) {\n  if (typeof emitter.on === 'function') {\n    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);\n  }\n}\n\nfunction eventTargetAgnosticAddListener(emitter, name, listener, flags) {\n  if (typeof emitter.on === 'function') {\n    if (flags.once) {\n      emitter.once(name, listener);\n    } else {\n      emitter.on(name, listener);\n    }\n  } else if (typeof emitter.addEventListener === 'function') {\n    // EventTarget does not have `error` event semantics like Node\n    // EventEmitters, we do not listen for `error` events here.\n    emitter.addEventListener(name, function wrapListener(arg) {\n      // IE does not have builtin `{ once: true }` support so we\n      // have to do it manually.\n      if (flags.once) {\n        emitter.removeEventListener(name, wrapListener);\n      }\n      listener(arg);\n    });\n  } else {\n    throw new TypeError('The \"emitter\" argument must be of type EventEmitter. Received type ' + typeof emitter);\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZXZlbnRzL2V2ZW50cy5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjs7QUFFbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0Isc0JBQXNCO0FBQ3hDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7O0FBRUEsa0NBQWtDLFFBQVE7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSx1Q0FBdUMsUUFBUTtBQUMvQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLE9BQU87QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUyx5QkFBeUI7QUFDbEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0IsZ0JBQWdCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOERBQThELFlBQVk7QUFDMUU7QUFDQSw4REFBOEQsWUFBWTtBQUMxRTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLFlBQVk7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdG9kby1saXN0Ly4vbm9kZV9tb2R1bGVzL2V2ZW50cy9ldmVudHMuanM/ZmFhMSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUiA9IHR5cGVvZiBSZWZsZWN0ID09PSAnb2JqZWN0JyA/IFJlZmxlY3QgOiBudWxsXG52YXIgUmVmbGVjdEFwcGx5ID0gUiAmJiB0eXBlb2YgUi5hcHBseSA9PT0gJ2Z1bmN0aW9uJ1xuICA/IFIuYXBwbHlcbiAgOiBmdW5jdGlvbiBSZWZsZWN0QXBwbHkodGFyZ2V0LCByZWNlaXZlciwgYXJncykge1xuICAgIHJldHVybiBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbCh0YXJnZXQsIHJlY2VpdmVyLCBhcmdzKTtcbiAgfVxuXG52YXIgUmVmbGVjdE93bktleXNcbmlmIChSICYmIHR5cGVvZiBSLm93bktleXMgPT09ICdmdW5jdGlvbicpIHtcbiAgUmVmbGVjdE93bktleXMgPSBSLm93bktleXNcbn0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICBSZWZsZWN0T3duS2V5cyA9IGZ1bmN0aW9uIFJlZmxlY3RPd25LZXlzKHRhcmdldCkge1xuICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0YXJnZXQpXG4gICAgICAuY29uY2F0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHModGFyZ2V0KSk7XG4gIH07XG59IGVsc2Uge1xuICBSZWZsZWN0T3duS2V5cyA9IGZ1bmN0aW9uIFJlZmxlY3RPd25LZXlzKHRhcmdldCkge1xuICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0YXJnZXQpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBQcm9jZXNzRW1pdFdhcm5pbmcod2FybmluZykge1xuICBpZiAoY29uc29sZSAmJiBjb25zb2xlLndhcm4pIGNvbnNvbGUud2Fybih3YXJuaW5nKTtcbn1cblxudmFyIE51bWJlcklzTmFOID0gTnVtYmVyLmlzTmFOIHx8IGZ1bmN0aW9uIE51bWJlcklzTmFOKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPT0gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcbiAgRXZlbnRFbWl0dGVyLmluaXQuY2FsbCh0aGlzKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRFbWl0dGVyO1xubW9kdWxlLmV4cG9ydHMub25jZSA9IG9uY2U7XG5cbi8vIEJhY2t3YXJkcy1jb21wYXQgd2l0aCBub2RlIDAuMTAueFxuRXZlbnRFbWl0dGVyLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fZXZlbnRzID0gdW5kZWZpbmVkO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fZXZlbnRzQ291bnQgPSAwO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fbWF4TGlzdGVuZXJzID0gdW5kZWZpbmVkO1xuXG4vLyBCeSBkZWZhdWx0IEV2ZW50RW1pdHRlcnMgd2lsbCBwcmludCBhIHdhcm5pbmcgaWYgbW9yZSB0aGFuIDEwIGxpc3RlbmVycyBhcmVcbi8vIGFkZGVkIHRvIGl0LiBUaGlzIGlzIGEgdXNlZnVsIGRlZmF1bHQgd2hpY2ggaGVscHMgZmluZGluZyBtZW1vcnkgbGVha3MuXG52YXIgZGVmYXVsdE1heExpc3RlbmVycyA9IDEwO1xuXG5mdW5jdGlvbiBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKSB7XG4gIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJsaXN0ZW5lclwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbi4gUmVjZWl2ZWQgdHlwZSAnICsgdHlwZW9mIGxpc3RlbmVyKTtcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRXZlbnRFbWl0dGVyLCAnZGVmYXVsdE1heExpc3RlbmVycycsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZGVmYXVsdE1heExpc3RlbmVycztcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbihhcmcpIHtcbiAgICBpZiAodHlwZW9mIGFyZyAhPT0gJ251bWJlcicgfHwgYXJnIDwgMCB8fCBOdW1iZXJJc05hTihhcmcpKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIG9mIFwiZGVmYXVsdE1heExpc3RlbmVyc1wiIGlzIG91dCBvZiByYW5nZS4gSXQgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXIuIFJlY2VpdmVkICcgKyBhcmcgKyAnLicpO1xuICAgIH1cbiAgICBkZWZhdWx0TWF4TGlzdGVuZXJzID0gYXJnO1xuICB9XG59KTtcblxuRXZlbnRFbWl0dGVyLmluaXQgPSBmdW5jdGlvbigpIHtcblxuICBpZiAodGhpcy5fZXZlbnRzID09PSB1bmRlZmluZWQgfHxcbiAgICAgIHRoaXMuX2V2ZW50cyA9PT0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpLl9ldmVudHMpIHtcbiAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgfVxuXG4gIHRoaXMuX21heExpc3RlbmVycyA9IHRoaXMuX21heExpc3RlbmVycyB8fCB1bmRlZmluZWQ7XG59O1xuXG4vLyBPYnZpb3VzbHkgbm90IGFsbCBFbWl0dGVycyBzaG91bGQgYmUgbGltaXRlZCB0byAxMC4gVGhpcyBmdW5jdGlvbiBhbGxvd3Ncbi8vIHRoYXQgdG8gYmUgaW5jcmVhc2VkLiBTZXQgdG8gemVybyBmb3IgdW5saW1pdGVkLlxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5zZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbiBzZXRNYXhMaXN0ZW5lcnMobikge1xuICBpZiAodHlwZW9mIG4gIT09ICdudW1iZXInIHx8IG4gPCAwIHx8IE51bWJlcklzTmFOKG4pKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBvZiBcIm5cIiBpcyBvdXQgb2YgcmFuZ2UuIEl0IG11c3QgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyLiBSZWNlaXZlZCAnICsgbiArICcuJyk7XG4gIH1cbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gbjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiBfZ2V0TWF4TGlzdGVuZXJzKHRoYXQpIHtcbiAgaWYgKHRoYXQuX21heExpc3RlbmVycyA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBFdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycztcbiAgcmV0dXJuIHRoYXQuX21heExpc3RlbmVycztcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5nZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbiBnZXRNYXhMaXN0ZW5lcnMoKSB7XG4gIHJldHVybiBfZ2V0TWF4TGlzdGVuZXJzKHRoaXMpO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24gZW1pdCh0eXBlKSB7XG4gIHZhciBhcmdzID0gW107XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSBhcmdzLnB1c2goYXJndW1lbnRzW2ldKTtcbiAgdmFyIGRvRXJyb3IgPSAodHlwZSA9PT0gJ2Vycm9yJyk7XG5cbiAgdmFyIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgaWYgKGV2ZW50cyAhPT0gdW5kZWZpbmVkKVxuICAgIGRvRXJyb3IgPSAoZG9FcnJvciAmJiBldmVudHMuZXJyb3IgPT09IHVuZGVmaW5lZCk7XG4gIGVsc2UgaWYgKCFkb0Vycm9yKVxuICAgIHJldHVybiBmYWxzZTtcblxuICAvLyBJZiB0aGVyZSBpcyBubyAnZXJyb3InIGV2ZW50IGxpc3RlbmVyIHRoZW4gdGhyb3cuXG4gIGlmIChkb0Vycm9yKSB7XG4gICAgdmFyIGVyO1xuICAgIGlmIChhcmdzLmxlbmd0aCA+IDApXG4gICAgICBlciA9IGFyZ3NbMF07XG4gICAgaWYgKGVyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIC8vIE5vdGU6IFRoZSBjb21tZW50cyBvbiB0aGUgYHRocm93YCBsaW5lcyBhcmUgaW50ZW50aW9uYWwsIHRoZXkgc2hvd1xuICAgICAgLy8gdXAgaW4gTm9kZSdzIG91dHB1dCBpZiB0aGlzIHJlc3VsdHMgaW4gYW4gdW5oYW5kbGVkIGV4Y2VwdGlvbi5cbiAgICAgIHRocm93IGVyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICAgIH1cbiAgICAvLyBBdCBsZWFzdCBnaXZlIHNvbWUga2luZCBvZiBjb250ZXh0IHRvIHRoZSB1c2VyXG4gICAgdmFyIGVyciA9IG5ldyBFcnJvcignVW5oYW5kbGVkIGVycm9yLicgKyAoZXIgPyAnICgnICsgZXIubWVzc2FnZSArICcpJyA6ICcnKSk7XG4gICAgZXJyLmNvbnRleHQgPSBlcjtcbiAgICB0aHJvdyBlcnI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gIH1cblxuICB2YXIgaGFuZGxlciA9IGV2ZW50c1t0eXBlXTtcblxuICBpZiAoaGFuZGxlciA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBmYWxzZTtcblxuICBpZiAodHlwZW9mIGhhbmRsZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICBSZWZsZWN0QXBwbHkoaGFuZGxlciwgdGhpcywgYXJncyk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGxlbiA9IGhhbmRsZXIubGVuZ3RoO1xuICAgIHZhciBsaXN0ZW5lcnMgPSBhcnJheUNsb25lKGhhbmRsZXIsIGxlbik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSlcbiAgICAgIFJlZmxlY3RBcHBseShsaXN0ZW5lcnNbaV0sIHRoaXMsIGFyZ3MpO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5mdW5jdGlvbiBfYWRkTGlzdGVuZXIodGFyZ2V0LCB0eXBlLCBsaXN0ZW5lciwgcHJlcGVuZCkge1xuICB2YXIgbTtcbiAgdmFyIGV2ZW50cztcbiAgdmFyIGV4aXN0aW5nO1xuXG4gIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpO1xuXG4gIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xuICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpIHtcbiAgICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGFyZ2V0Ll9ldmVudHNDb3VudCA9IDA7XG4gIH0gZWxzZSB7XG4gICAgLy8gVG8gYXZvaWQgcmVjdXJzaW9uIGluIHRoZSBjYXNlIHRoYXQgdHlwZSA9PT0gXCJuZXdMaXN0ZW5lclwiISBCZWZvcmVcbiAgICAvLyBhZGRpbmcgaXQgdG8gdGhlIGxpc3RlbmVycywgZmlyc3QgZW1pdCBcIm5ld0xpc3RlbmVyXCIuXG4gICAgaWYgKGV2ZW50cy5uZXdMaXN0ZW5lciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0YXJnZXQuZW1pdCgnbmV3TGlzdGVuZXInLCB0eXBlLFxuICAgICAgICAgICAgICAgICAgbGlzdGVuZXIubGlzdGVuZXIgPyBsaXN0ZW5lci5saXN0ZW5lciA6IGxpc3RlbmVyKTtcblxuICAgICAgLy8gUmUtYXNzaWduIGBldmVudHNgIGJlY2F1c2UgYSBuZXdMaXN0ZW5lciBoYW5kbGVyIGNvdWxkIGhhdmUgY2F1c2VkIHRoZVxuICAgICAgLy8gdGhpcy5fZXZlbnRzIHRvIGJlIGFzc2lnbmVkIHRvIGEgbmV3IG9iamVjdFxuICAgICAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHM7XG4gICAgfVxuICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdO1xuICB9XG5cbiAgaWYgKGV4aXN0aW5nID09PSB1bmRlZmluZWQpIHtcbiAgICAvLyBPcHRpbWl6ZSB0aGUgY2FzZSBvZiBvbmUgbGlzdGVuZXIuIERvbid0IG5lZWQgdGhlIGV4dHJhIGFycmF5IG9iamVjdC5cbiAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXSA9IGxpc3RlbmVyO1xuICAgICsrdGFyZ2V0Ll9ldmVudHNDb3VudDtcbiAgfSBlbHNlIHtcbiAgICBpZiAodHlwZW9mIGV4aXN0aW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBBZGRpbmcgdGhlIHNlY29uZCBlbGVtZW50LCBuZWVkIHRvIGNoYW5nZSB0byBhcnJheS5cbiAgICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdID1cbiAgICAgICAgcHJlcGVuZCA/IFtsaXN0ZW5lciwgZXhpc3RpbmddIDogW2V4aXN0aW5nLCBsaXN0ZW5lcl07XG4gICAgICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IGdvdCBhbiBhcnJheSwganVzdCBhcHBlbmQuXG4gICAgfSBlbHNlIGlmIChwcmVwZW5kKSB7XG4gICAgICBleGlzdGluZy51bnNoaWZ0KGxpc3RlbmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXhpc3RpbmcucHVzaChsaXN0ZW5lcik7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgZm9yIGxpc3RlbmVyIGxlYWtcbiAgICBtID0gX2dldE1heExpc3RlbmVycyh0YXJnZXQpO1xuICAgIGlmIChtID4gMCAmJiBleGlzdGluZy5sZW5ndGggPiBtICYmICFleGlzdGluZy53YXJuZWQpIHtcbiAgICAgIGV4aXN0aW5nLndhcm5lZCA9IHRydWU7XG4gICAgICAvLyBObyBlcnJvciBjb2RlIGZvciB0aGlzIHNpbmNlIGl0IGlzIGEgV2FybmluZ1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4XG4gICAgICB2YXIgdyA9IG5ldyBFcnJvcignUG9zc2libGUgRXZlbnRFbWl0dGVyIG1lbW9yeSBsZWFrIGRldGVjdGVkLiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZXhpc3RpbmcubGVuZ3RoICsgJyAnICsgU3RyaW5nKHR5cGUpICsgJyBsaXN0ZW5lcnMgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICdhZGRlZC4gVXNlIGVtaXR0ZXIuc2V0TWF4TGlzdGVuZXJzKCkgdG8gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICdpbmNyZWFzZSBsaW1pdCcpO1xuICAgICAgdy5uYW1lID0gJ01heExpc3RlbmVyc0V4Y2VlZGVkV2FybmluZyc7XG4gICAgICB3LmVtaXR0ZXIgPSB0YXJnZXQ7XG4gICAgICB3LnR5cGUgPSB0eXBlO1xuICAgICAgdy5jb3VudCA9IGV4aXN0aW5nLmxlbmd0aDtcbiAgICAgIFByb2Nlc3NFbWl0V2FybmluZyh3KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gZnVuY3Rpb24gYWRkTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgcmV0dXJuIF9hZGRMaXN0ZW5lcih0aGlzLCB0eXBlLCBsaXN0ZW5lciwgZmFsc2UpO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucHJlcGVuZExpc3RlbmVyID1cbiAgICBmdW5jdGlvbiBwcmVwZW5kTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgIHJldHVybiBfYWRkTGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIsIHRydWUpO1xuICAgIH07XG5cbmZ1bmN0aW9uIG9uY2VXcmFwcGVyKCkge1xuICBpZiAoIXRoaXMuZmlyZWQpIHtcbiAgICB0aGlzLnRhcmdldC5yZW1vdmVMaXN0ZW5lcih0aGlzLnR5cGUsIHRoaXMud3JhcEZuKTtcbiAgICB0aGlzLmZpcmVkID0gdHJ1ZTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMClcbiAgICAgIHJldHVybiB0aGlzLmxpc3RlbmVyLmNhbGwodGhpcy50YXJnZXQpO1xuICAgIHJldHVybiB0aGlzLmxpc3RlbmVyLmFwcGx5KHRoaXMudGFyZ2V0LCBhcmd1bWVudHMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9vbmNlV3JhcCh0YXJnZXQsIHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBzdGF0ZSA9IHsgZmlyZWQ6IGZhbHNlLCB3cmFwRm46IHVuZGVmaW5lZCwgdGFyZ2V0OiB0YXJnZXQsIHR5cGU6IHR5cGUsIGxpc3RlbmVyOiBsaXN0ZW5lciB9O1xuICB2YXIgd3JhcHBlZCA9IG9uY2VXcmFwcGVyLmJpbmQoc3RhdGUpO1xuICB3cmFwcGVkLmxpc3RlbmVyID0gbGlzdGVuZXI7XG4gIHN0YXRlLndyYXBGbiA9IHdyYXBwZWQ7XG4gIHJldHVybiB3cmFwcGVkO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbiBvbmNlKHR5cGUsIGxpc3RlbmVyKSB7XG4gIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpO1xuICB0aGlzLm9uKHR5cGUsIF9vbmNlV3JhcCh0aGlzLCB0eXBlLCBsaXN0ZW5lcikpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucHJlcGVuZE9uY2VMaXN0ZW5lciA9XG4gICAgZnVuY3Rpb24gcHJlcGVuZE9uY2VMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcik7XG4gICAgICB0aGlzLnByZXBlbmRMaXN0ZW5lcih0eXBlLCBfb25jZVdyYXAodGhpcywgdHlwZSwgbGlzdGVuZXIpKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbi8vIEVtaXRzIGEgJ3JlbW92ZUxpc3RlbmVyJyBldmVudCBpZiBhbmQgb25seSBpZiB0aGUgbGlzdGVuZXIgd2FzIHJlbW92ZWQuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID1cbiAgICBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgdmFyIGxpc3QsIGV2ZW50cywgcG9zaXRpb24sIGksIG9yaWdpbmFsTGlzdGVuZXI7XG5cbiAgICAgIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpO1xuXG4gICAgICBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gICAgICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICBsaXN0ID0gZXZlbnRzW3R5cGVdO1xuICAgICAgaWYgKGxpc3QgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgIGlmIChsaXN0ID09PSBsaXN0ZW5lciB8fCBsaXN0Lmxpc3RlbmVyID09PSBsaXN0ZW5lcikge1xuICAgICAgICBpZiAoLS10aGlzLl9ldmVudHNDb3VudCA9PT0gMClcbiAgICAgICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBkZWxldGUgZXZlbnRzW3R5cGVdO1xuICAgICAgICAgIGlmIChldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdC5saXN0ZW5lciB8fCBsaXN0ZW5lcik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGxpc3QgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcG9zaXRpb24gPSAtMTtcblxuICAgICAgICBmb3IgKGkgPSBsaXN0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgaWYgKGxpc3RbaV0gPT09IGxpc3RlbmVyIHx8IGxpc3RbaV0ubGlzdGVuZXIgPT09IGxpc3RlbmVyKSB7XG4gICAgICAgICAgICBvcmlnaW5hbExpc3RlbmVyID0gbGlzdFtpXS5saXN0ZW5lcjtcbiAgICAgICAgICAgIHBvc2l0aW9uID0gaTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwb3NpdGlvbiA8IDApXG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgaWYgKHBvc2l0aW9uID09PSAwKVxuICAgICAgICAgIGxpc3Quc2hpZnQoKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgc3BsaWNlT25lKGxpc3QsIHBvc2l0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSlcbiAgICAgICAgICBldmVudHNbdHlwZV0gPSBsaXN0WzBdO1xuXG4gICAgICAgIGlmIChldmVudHMucmVtb3ZlTGlzdGVuZXIgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgb3JpZ2luYWxMaXN0ZW5lciB8fCBsaXN0ZW5lcik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub2ZmID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPVxuICAgIGZ1bmN0aW9uIHJlbW92ZUFsbExpc3RlbmVycyh0eXBlKSB7XG4gICAgICB2YXIgbGlzdGVuZXJzLCBldmVudHMsIGk7XG5cbiAgICAgIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgICAgIGlmIChldmVudHMgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgIC8vIG5vdCBsaXN0ZW5pbmcgZm9yIHJlbW92ZUxpc3RlbmVyLCBubyBuZWVkIHRvIGVtaXRcbiAgICAgIGlmIChldmVudHMucmVtb3ZlTGlzdGVuZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICAgICAgICB9IGVsc2UgaWYgKGV2ZW50c1t0eXBlXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKC0tdGhpcy5fZXZlbnRzQ291bnQgPT09IDApXG4gICAgICAgICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGRlbGV0ZSBldmVudHNbdHlwZV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIC8vIGVtaXQgcmVtb3ZlTGlzdGVuZXIgZm9yIGFsbCBsaXN0ZW5lcnMgb24gYWxsIGV2ZW50c1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhldmVudHMpO1xuICAgICAgICB2YXIga2V5O1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgaWYgKGtleSA9PT0gJ3JlbW92ZUxpc3RlbmVyJykgY29udGludWU7XG4gICAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoa2V5KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygncmVtb3ZlTGlzdGVuZXInKTtcbiAgICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgbGlzdGVuZXJzID0gZXZlbnRzW3R5cGVdO1xuXG4gICAgICBpZiAodHlwZW9mIGxpc3RlbmVycyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVycyk7XG4gICAgICB9IGVsc2UgaWYgKGxpc3RlbmVycyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIExJRk8gb3JkZXJcbiAgICAgICAgZm9yIChpID0gbGlzdGVuZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnNbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbmZ1bmN0aW9uIF9saXN0ZW5lcnModGFyZ2V0LCB0eXBlLCB1bndyYXApIHtcbiAgdmFyIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xuXG4gIGlmIChldmVudHMgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gW107XG5cbiAgdmFyIGV2bGlzdGVuZXIgPSBldmVudHNbdHlwZV07XG4gIGlmIChldmxpc3RlbmVyID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIFtdO1xuXG4gIGlmICh0eXBlb2YgZXZsaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJylcbiAgICByZXR1cm4gdW53cmFwID8gW2V2bGlzdGVuZXIubGlzdGVuZXIgfHwgZXZsaXN0ZW5lcl0gOiBbZXZsaXN0ZW5lcl07XG5cbiAgcmV0dXJuIHVud3JhcCA/XG4gICAgdW53cmFwTGlzdGVuZXJzKGV2bGlzdGVuZXIpIDogYXJyYXlDbG9uZShldmxpc3RlbmVyLCBldmxpc3RlbmVyLmxlbmd0aCk7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24gbGlzdGVuZXJzKHR5cGUpIHtcbiAgcmV0dXJuIF9saXN0ZW5lcnModGhpcywgdHlwZSwgdHJ1ZSk7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJhd0xpc3RlbmVycyA9IGZ1bmN0aW9uIHJhd0xpc3RlbmVycyh0eXBlKSB7XG4gIHJldHVybiBfbGlzdGVuZXJzKHRoaXMsIHR5cGUsIGZhbHNlKTtcbn07XG5cbkV2ZW50RW1pdHRlci5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24oZW1pdHRlciwgdHlwZSkge1xuICBpZiAodHlwZW9mIGVtaXR0ZXIubGlzdGVuZXJDb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBlbWl0dGVyLmxpc3RlbmVyQ291bnQodHlwZSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGxpc3RlbmVyQ291bnQuY2FsbChlbWl0dGVyLCB0eXBlKTtcbiAgfVxufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lckNvdW50ID0gbGlzdGVuZXJDb3VudDtcbmZ1bmN0aW9uIGxpc3RlbmVyQ291bnQodHlwZSkge1xuICB2YXIgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuXG4gIGlmIChldmVudHMgIT09IHVuZGVmaW5lZCkge1xuICAgIHZhciBldmxpc3RlbmVyID0gZXZlbnRzW3R5cGVdO1xuXG4gICAgaWYgKHR5cGVvZiBldmxpc3RlbmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9IGVsc2UgaWYgKGV2bGlzdGVuZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGV2bGlzdGVuZXIubGVuZ3RoO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiAwO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmV2ZW50TmFtZXMgPSBmdW5jdGlvbiBldmVudE5hbWVzKCkge1xuICByZXR1cm4gdGhpcy5fZXZlbnRzQ291bnQgPiAwID8gUmVmbGVjdE93bktleXModGhpcy5fZXZlbnRzKSA6IFtdO1xufTtcblxuZnVuY3Rpb24gYXJyYXlDbG9uZShhcnIsIG4pIHtcbiAgdmFyIGNvcHkgPSBuZXcgQXJyYXkobik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgKytpKVxuICAgIGNvcHlbaV0gPSBhcnJbaV07XG4gIHJldHVybiBjb3B5O1xufVxuXG5mdW5jdGlvbiBzcGxpY2VPbmUobGlzdCwgaW5kZXgpIHtcbiAgZm9yICg7IGluZGV4ICsgMSA8IGxpc3QubGVuZ3RoOyBpbmRleCsrKVxuICAgIGxpc3RbaW5kZXhdID0gbGlzdFtpbmRleCArIDFdO1xuICBsaXN0LnBvcCgpO1xufVxuXG5mdW5jdGlvbiB1bndyYXBMaXN0ZW5lcnMoYXJyKSB7XG4gIHZhciByZXQgPSBuZXcgQXJyYXkoYXJyLmxlbmd0aCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcmV0Lmxlbmd0aDsgKytpKSB7XG4gICAgcmV0W2ldID0gYXJyW2ldLmxpc3RlbmVyIHx8IGFycltpXTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBvbmNlKGVtaXR0ZXIsIG5hbWUpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICBmdW5jdGlvbiBlcnJvckxpc3RlbmVyKGVycikge1xuICAgICAgZW1pdHRlci5yZW1vdmVMaXN0ZW5lcihuYW1lLCByZXNvbHZlcik7XG4gICAgICByZWplY3QoZXJyKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZXNvbHZlcigpIHtcbiAgICAgIGlmICh0eXBlb2YgZW1pdHRlci5yZW1vdmVMaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBlbWl0dGVyLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIGVycm9yTGlzdGVuZXIpO1xuICAgICAgfVxuICAgICAgcmVzb2x2ZShbXS5zbGljZS5jYWxsKGFyZ3VtZW50cykpO1xuICAgIH07XG5cbiAgICBldmVudFRhcmdldEFnbm9zdGljQWRkTGlzdGVuZXIoZW1pdHRlciwgbmFtZSwgcmVzb2x2ZXIsIHsgb25jZTogdHJ1ZSB9KTtcbiAgICBpZiAobmFtZSAhPT0gJ2Vycm9yJykge1xuICAgICAgYWRkRXJyb3JIYW5kbGVySWZFdmVudEVtaXR0ZXIoZW1pdHRlciwgZXJyb3JMaXN0ZW5lciwgeyBvbmNlOiB0cnVlIH0pO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGFkZEVycm9ySGFuZGxlcklmRXZlbnRFbWl0dGVyKGVtaXR0ZXIsIGhhbmRsZXIsIGZsYWdzKSB7XG4gIGlmICh0eXBlb2YgZW1pdHRlci5vbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGV2ZW50VGFyZ2V0QWdub3N0aWNBZGRMaXN0ZW5lcihlbWl0dGVyLCAnZXJyb3InLCBoYW5kbGVyLCBmbGFncyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZXZlbnRUYXJnZXRBZ25vc3RpY0FkZExpc3RlbmVyKGVtaXR0ZXIsIG5hbWUsIGxpc3RlbmVyLCBmbGFncykge1xuICBpZiAodHlwZW9mIGVtaXR0ZXIub24gPT09ICdmdW5jdGlvbicpIHtcbiAgICBpZiAoZmxhZ3Mub25jZSkge1xuICAgICAgZW1pdHRlci5vbmNlKG5hbWUsIGxpc3RlbmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZW1pdHRlci5vbihuYW1lLCBsaXN0ZW5lcik7XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiBlbWl0dGVyLmFkZEV2ZW50TGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBFdmVudFRhcmdldCBkb2VzIG5vdCBoYXZlIGBlcnJvcmAgZXZlbnQgc2VtYW50aWNzIGxpa2UgTm9kZVxuICAgIC8vIEV2ZW50RW1pdHRlcnMsIHdlIGRvIG5vdCBsaXN0ZW4gZm9yIGBlcnJvcmAgZXZlbnRzIGhlcmUuXG4gICAgZW1pdHRlci5hZGRFdmVudExpc3RlbmVyKG5hbWUsIGZ1bmN0aW9uIHdyYXBMaXN0ZW5lcihhcmcpIHtcbiAgICAgIC8vIElFIGRvZXMgbm90IGhhdmUgYnVpbHRpbiBgeyBvbmNlOiB0cnVlIH1gIHN1cHBvcnQgc28gd2VcbiAgICAgIC8vIGhhdmUgdG8gZG8gaXQgbWFudWFsbHkuXG4gICAgICBpZiAoZmxhZ3Mub25jZSkge1xuICAgICAgICBlbWl0dGVyLnJlbW92ZUV2ZW50TGlzdGVuZXIobmFtZSwgd3JhcExpc3RlbmVyKTtcbiAgICAgIH1cbiAgICAgIGxpc3RlbmVyKGFyZyk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwiZW1pdHRlclwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBFdmVudEVtaXR0ZXIuIFJlY2VpdmVkIHR5cGUgJyArIHR5cGVvZiBlbWl0dGVyKTtcbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/events/events.js\n");

/***/ }),

/***/ "./node_modules/filename-reserved-regex/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/filename-reserved-regex/index.js ***!
  \*******************************************************/
/***/ ((module) => {

"use strict";
eval("\n/* eslint-disable no-control-regex */\n// TODO: remove parens when Node.js 6 is targeted. Node.js 4 barfs at it.\nmodule.exports = () => (/[<>:\"\\/\\\\|?*\\x00-\\x1F]/g);\nmodule.exports.windowsNames = () => (/^(con|prn|aux|nul|com[0-9]|lpt[0-9])$/i);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZmlsZW5hbWUtcmVzZXJ2ZWQtcmVnZXgvaW5kZXguanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90b2RvLWxpc3QvLi9ub2RlX21vZHVsZXMvZmlsZW5hbWUtcmVzZXJ2ZWQtcmVnZXgvaW5kZXguanM/ZDQwZiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG4vKiBlc2xpbnQtZGlzYWJsZSBuby1jb250cm9sLXJlZ2V4ICovXG4vLyBUT0RPOiByZW1vdmUgcGFyZW5zIHdoZW4gTm9kZS5qcyA2IGlzIHRhcmdldGVkLiBOb2RlLmpzIDQgYmFyZnMgYXQgaXQuXG5tb2R1bGUuZXhwb3J0cyA9ICgpID0+ICgvWzw+OlwiXFwvXFxcXHw/KlxceDAwLVxceDFGXS9nKTtcbm1vZHVsZS5leHBvcnRzLndpbmRvd3NOYW1lcyA9ICgpID0+ICgvXihjb258cHJufGF1eHxudWx8Y29tWzAtOV18bHB0WzAtOV0pJC9pKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/filename-reserved-regex/index.js\n");

/***/ }),

/***/ "./node_modules/filenamify/filenamify-path.js":
/*!****************************************************!*\
  !*** ./node_modules/filenamify/filenamify-path.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst path = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'path'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\nconst filenamify = __webpack_require__(/*! ./filenamify */ \"./node_modules/filenamify/filenamify.js\");\n\nconst filenamifyPath = (filePath, options) => {\n\tfilePath = path.resolve(filePath);\n\treturn path.join(path.dirname(filePath), filenamify(path.basename(filePath), options));\n};\n\nmodule.exports = filenamifyPath;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZmlsZW5hbWlmeS9maWxlbmFtaWZ5LXBhdGguanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixhQUFhLG1CQUFPLENBQUMsbUlBQU07QUFDM0IsbUJBQW1CLG1CQUFPLENBQUMsNkRBQWM7O0FBRXpDO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdG9kby1saXN0Ly4vbm9kZV9tb2R1bGVzL2ZpbGVuYW1pZnkvZmlsZW5hbWlmeS1wYXRoLmpzPzhmN2MiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcbmNvbnN0IGZpbGVuYW1pZnkgPSByZXF1aXJlKCcuL2ZpbGVuYW1pZnknKTtcblxuY29uc3QgZmlsZW5hbWlmeVBhdGggPSAoZmlsZVBhdGgsIG9wdGlvbnMpID0+IHtcblx0ZmlsZVBhdGggPSBwYXRoLnJlc29sdmUoZmlsZVBhdGgpO1xuXHRyZXR1cm4gcGF0aC5qb2luKHBhdGguZGlybmFtZShmaWxlUGF0aCksIGZpbGVuYW1pZnkocGF0aC5iYXNlbmFtZShmaWxlUGF0aCksIG9wdGlvbnMpKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZmlsZW5hbWlmeVBhdGg7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/filenamify/filenamify-path.js\n");

/***/ }),

/***/ "./node_modules/filenamify/filenamify.js":
/*!***********************************************!*\
  !*** ./node_modules/filenamify/filenamify.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst trimRepeated = __webpack_require__(/*! trim-repeated */ \"./node_modules/trim-repeated/index.js\");\nconst filenameReservedRegex = __webpack_require__(/*! filename-reserved-regex */ \"./node_modules/filename-reserved-regex/index.js\");\nconst stripOuter = __webpack_require__(/*! strip-outer */ \"./node_modules/strip-outer/index.js\");\n\n// Doesn't make sense to have longer filenames\nconst MAX_FILENAME_LENGTH = 100;\n\nconst reControlChars = /[\\u0000-\\u001f\\u0080-\\u009f]/g; // eslint-disable-line no-control-regex\nconst reRelativePath = /^\\.+/;\nconst reTrailingPeriods = /\\.+$/;\n\nconst filenamify = (string, options = {}) => {\n\tif (typeof string !== 'string') {\n\t\tthrow new TypeError('Expected a string');\n\t}\n\n\tconst replacement = options.replacement === undefined ? '!' : options.replacement;\n\n\tif (filenameReservedRegex().test(replacement) && reControlChars.test(replacement)) {\n\t\tthrow new Error('Replacement string cannot contain reserved filename characters');\n\t}\n\n\tstring = string.replace(filenameReservedRegex(), replacement);\n\tstring = string.replace(reControlChars, replacement);\n\tstring = string.replace(reRelativePath, replacement);\n\tstring = string.replace(reTrailingPeriods, '');\n\n\tif (replacement.length > 0) {\n\t\tstring = trimRepeated(string, replacement);\n\t\tstring = string.length > 1 ? stripOuter(string, replacement) : string;\n\t}\n\n\tstring = filenameReservedRegex.windowsNames().test(string) ? string + replacement : string;\n\tstring = string.slice(0, typeof options.maxLength === 'number' ? options.maxLength : MAX_FILENAME_LENGTH);\n\n\treturn string;\n};\n\nmodule.exports = filenamify;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZmlsZW5hbWlmeS9maWxlbmFtaWZ5LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IscUJBQXFCLG1CQUFPLENBQUMsNERBQWU7QUFDNUMsOEJBQThCLG1CQUFPLENBQUMsZ0ZBQXlCO0FBQy9ELG1CQUFtQixtQkFBTyxDQUFDLHdEQUFhOztBQUV4QztBQUNBOztBQUVBLHdEQUF3RDtBQUN4RDtBQUNBOztBQUVBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3RvZG8tbGlzdC8uL25vZGVfbW9kdWxlcy9maWxlbmFtaWZ5L2ZpbGVuYW1pZnkuanM/OTk1NCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5jb25zdCB0cmltUmVwZWF0ZWQgPSByZXF1aXJlKCd0cmltLXJlcGVhdGVkJyk7XG5jb25zdCBmaWxlbmFtZVJlc2VydmVkUmVnZXggPSByZXF1aXJlKCdmaWxlbmFtZS1yZXNlcnZlZC1yZWdleCcpO1xuY29uc3Qgc3RyaXBPdXRlciA9IHJlcXVpcmUoJ3N0cmlwLW91dGVyJyk7XG5cbi8vIERvZXNuJ3QgbWFrZSBzZW5zZSB0byBoYXZlIGxvbmdlciBmaWxlbmFtZXNcbmNvbnN0IE1BWF9GSUxFTkFNRV9MRU5HVEggPSAxMDA7XG5cbmNvbnN0IHJlQ29udHJvbENoYXJzID0gL1tcXHUwMDAwLVxcdTAwMWZcXHUwMDgwLVxcdTAwOWZdL2c7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29udHJvbC1yZWdleFxuY29uc3QgcmVSZWxhdGl2ZVBhdGggPSAvXlxcLisvO1xuY29uc3QgcmVUcmFpbGluZ1BlcmlvZHMgPSAvXFwuKyQvO1xuXG5jb25zdCBmaWxlbmFtaWZ5ID0gKHN0cmluZywgb3B0aW9ucyA9IHt9KSA9PiB7XG5cdGlmICh0eXBlb2Ygc3RyaW5nICE9PSAnc3RyaW5nJykge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIGEgc3RyaW5nJyk7XG5cdH1cblxuXHRjb25zdCByZXBsYWNlbWVudCA9IG9wdGlvbnMucmVwbGFjZW1lbnQgPT09IHVuZGVmaW5lZCA/ICchJyA6IG9wdGlvbnMucmVwbGFjZW1lbnQ7XG5cblx0aWYgKGZpbGVuYW1lUmVzZXJ2ZWRSZWdleCgpLnRlc3QocmVwbGFjZW1lbnQpICYmIHJlQ29udHJvbENoYXJzLnRlc3QocmVwbGFjZW1lbnQpKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCdSZXBsYWNlbWVudCBzdHJpbmcgY2Fubm90IGNvbnRhaW4gcmVzZXJ2ZWQgZmlsZW5hbWUgY2hhcmFjdGVycycpO1xuXHR9XG5cblx0c3RyaW5nID0gc3RyaW5nLnJlcGxhY2UoZmlsZW5hbWVSZXNlcnZlZFJlZ2V4KCksIHJlcGxhY2VtZW50KTtcblx0c3RyaW5nID0gc3RyaW5nLnJlcGxhY2UocmVDb250cm9sQ2hhcnMsIHJlcGxhY2VtZW50KTtcblx0c3RyaW5nID0gc3RyaW5nLnJlcGxhY2UocmVSZWxhdGl2ZVBhdGgsIHJlcGxhY2VtZW50KTtcblx0c3RyaW5nID0gc3RyaW5nLnJlcGxhY2UocmVUcmFpbGluZ1BlcmlvZHMsICcnKTtcblxuXHRpZiAocmVwbGFjZW1lbnQubGVuZ3RoID4gMCkge1xuXHRcdHN0cmluZyA9IHRyaW1SZXBlYXRlZChzdHJpbmcsIHJlcGxhY2VtZW50KTtcblx0XHRzdHJpbmcgPSBzdHJpbmcubGVuZ3RoID4gMSA/IHN0cmlwT3V0ZXIoc3RyaW5nLCByZXBsYWNlbWVudCkgOiBzdHJpbmc7XG5cdH1cblxuXHRzdHJpbmcgPSBmaWxlbmFtZVJlc2VydmVkUmVnZXgud2luZG93c05hbWVzKCkudGVzdChzdHJpbmcpID8gc3RyaW5nICsgcmVwbGFjZW1lbnQgOiBzdHJpbmc7XG5cdHN0cmluZyA9IHN0cmluZy5zbGljZSgwLCB0eXBlb2Ygb3B0aW9ucy5tYXhMZW5ndGggPT09ICdudW1iZXInID8gb3B0aW9ucy5tYXhMZW5ndGggOiBNQVhfRklMRU5BTUVfTEVOR1RIKTtcblxuXHRyZXR1cm4gc3RyaW5nO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmaWxlbmFtaWZ5O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/filenamify/filenamify.js\n");

/***/ }),

/***/ "./node_modules/filenamify/index.js":
/*!******************************************!*\
  !*** ./node_modules/filenamify/index.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst filenamify = __webpack_require__(/*! ./filenamify */ \"./node_modules/filenamify/filenamify.js\");\nconst filenamifyPath = __webpack_require__(/*! ./filenamify-path */ \"./node_modules/filenamify/filenamify-path.js\");\n\nconst filenamifyCombined = filenamify;\nfilenamifyCombined.path = filenamifyPath;\n\nmodule.exports = filenamify;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZmlsZW5hbWlmeS9pbmRleC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLG1CQUFtQixtQkFBTyxDQUFDLDZEQUFjO0FBQ3pDLHVCQUF1QixtQkFBTyxDQUFDLHVFQUFtQjs7QUFFbEQ7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3RvZG8tbGlzdC8uL25vZGVfbW9kdWxlcy9maWxlbmFtaWZ5L2luZGV4LmpzPzBiYWEiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuY29uc3QgZmlsZW5hbWlmeSA9IHJlcXVpcmUoJy4vZmlsZW5hbWlmeScpO1xuY29uc3QgZmlsZW5hbWlmeVBhdGggPSByZXF1aXJlKCcuL2ZpbGVuYW1pZnktcGF0aCcpO1xuXG5jb25zdCBmaWxlbmFtaWZ5Q29tYmluZWQgPSBmaWxlbmFtaWZ5O1xuZmlsZW5hbWlmeUNvbWJpbmVkLnBhdGggPSBmaWxlbmFtaWZ5UGF0aDtcblxubW9kdWxlLmV4cG9ydHMgPSBmaWxlbmFtaWZ5O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/filenamify/index.js\n");

/***/ }),

/***/ "./node_modules/find-cache-dir/index.js":
/*!**********************************************!*\
  !*** ./node_modules/find-cache-dir/index.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst path = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'path'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\nconst fs = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'fs'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\nconst commonDir = __webpack_require__(/*! commondir */ \"./node_modules/commondir/index.js\");\nconst pkgDir = __webpack_require__(/*! pkg-dir */ \"./node_modules/pkg-dir/index.js\");\nconst makeDir = __webpack_require__(/*! make-dir */ \"./node_modules/make-dir/index.js\");\n\nconst {env, cwd} = process;\n\nconst isWritable = path => {\n\ttry {\n\t\tfs.accessSync(path, fs.constants.W_OK);\n\t\treturn true;\n\t} catch (_) {\n\t\treturn false;\n\t}\n};\n\nfunction useDirectory(directory, options) {\n\tif (options.create) {\n\t\tmakeDir.sync(directory);\n\t}\n\n\tif (options.thunk) {\n\t\treturn (...arguments_) => path.join(directory, ...arguments_);\n\t}\n\n\treturn directory;\n}\n\nfunction getNodeModuleDirectory(directory) {\n\tconst nodeModules = path.join(directory, 'node_modules');\n\n\tif (\n\t\t!isWritable(nodeModules) &&\n\t\t(fs.existsSync(nodeModules) || !isWritable(path.join(directory)))\n\t) {\n\t\treturn;\n\t}\n\n\treturn nodeModules;\n}\n\nmodule.exports = (options = {}) => {\n\tif (env.CACHE_DIR && !['true', 'false', '1', '0'].includes(env.CACHE_DIR)) {\n\t\treturn useDirectory(path.join(env.CACHE_DIR, options.name), options);\n\t}\n\n\tlet {cwd: directory = cwd()} = options;\n\n\tif (options.files) {\n\t\tdirectory = commonDir(directory, options.files);\n\t}\n\n\tdirectory = pkgDir.sync(directory);\n\n\tif (!directory) {\n\t\treturn;\n\t}\n\n\tconst nodeModules = getNodeModuleDirectory(directory);\n\tif (!nodeModules) {\n\t\treturn undefined;\n\t}\n\n\treturn useDirectory(path.join(directory, 'node_modules', '.cache', options.name), options);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZmluZC1jYWNoZS1kaXIvaW5kZXguanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixhQUFhLG1CQUFPLENBQUMsbUlBQU07QUFDM0IsV0FBVyxtQkFBTyxDQUFDLGlJQUFJO0FBQ3ZCLGtCQUFrQixtQkFBTyxDQUFDLG9EQUFXO0FBQ3JDLGVBQWUsbUJBQU8sQ0FBQyxnREFBUztBQUNoQyxnQkFBZ0IsbUJBQU8sQ0FBQyxrREFBVTs7QUFFbEMsT0FBTyxVQUFVOztBQUVqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBOztBQUVBLE1BQU0sd0JBQXdCOztBQUU5QjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90b2RvLWxpc3QvLi9ub2RlX21vZHVsZXMvZmluZC1jYWNoZS1kaXIvaW5kZXguanM/MjBkOSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xuY29uc3QgZnMgPSByZXF1aXJlKCdmcycpO1xuY29uc3QgY29tbW9uRGlyID0gcmVxdWlyZSgnY29tbW9uZGlyJyk7XG5jb25zdCBwa2dEaXIgPSByZXF1aXJlKCdwa2ctZGlyJyk7XG5jb25zdCBtYWtlRGlyID0gcmVxdWlyZSgnbWFrZS1kaXInKTtcblxuY29uc3Qge2VudiwgY3dkfSA9IHByb2Nlc3M7XG5cbmNvbnN0IGlzV3JpdGFibGUgPSBwYXRoID0+IHtcblx0dHJ5IHtcblx0XHRmcy5hY2Nlc3NTeW5jKHBhdGgsIGZzLmNvbnN0YW50cy5XX09LKTtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSBjYXRjaCAoXykge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufTtcblxuZnVuY3Rpb24gdXNlRGlyZWN0b3J5KGRpcmVjdG9yeSwgb3B0aW9ucykge1xuXHRpZiAob3B0aW9ucy5jcmVhdGUpIHtcblx0XHRtYWtlRGlyLnN5bmMoZGlyZWN0b3J5KTtcblx0fVxuXG5cdGlmIChvcHRpb25zLnRodW5rKSB7XG5cdFx0cmV0dXJuICguLi5hcmd1bWVudHNfKSA9PiBwYXRoLmpvaW4oZGlyZWN0b3J5LCAuLi5hcmd1bWVudHNfKTtcblx0fVxuXG5cdHJldHVybiBkaXJlY3Rvcnk7XG59XG5cbmZ1bmN0aW9uIGdldE5vZGVNb2R1bGVEaXJlY3RvcnkoZGlyZWN0b3J5KSB7XG5cdGNvbnN0IG5vZGVNb2R1bGVzID0gcGF0aC5qb2luKGRpcmVjdG9yeSwgJ25vZGVfbW9kdWxlcycpO1xuXG5cdGlmIChcblx0XHQhaXNXcml0YWJsZShub2RlTW9kdWxlcykgJiZcblx0XHQoZnMuZXhpc3RzU3luYyhub2RlTW9kdWxlcykgfHwgIWlzV3JpdGFibGUocGF0aC5qb2luKGRpcmVjdG9yeSkpKVxuXHQpIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHRyZXR1cm4gbm9kZU1vZHVsZXM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gKG9wdGlvbnMgPSB7fSkgPT4ge1xuXHRpZiAoZW52LkNBQ0hFX0RJUiAmJiAhWyd0cnVlJywgJ2ZhbHNlJywgJzEnLCAnMCddLmluY2x1ZGVzKGVudi5DQUNIRV9ESVIpKSB7XG5cdFx0cmV0dXJuIHVzZURpcmVjdG9yeShwYXRoLmpvaW4oZW52LkNBQ0hFX0RJUiwgb3B0aW9ucy5uYW1lKSwgb3B0aW9ucyk7XG5cdH1cblxuXHRsZXQge2N3ZDogZGlyZWN0b3J5ID0gY3dkKCl9ID0gb3B0aW9ucztcblxuXHRpZiAob3B0aW9ucy5maWxlcykge1xuXHRcdGRpcmVjdG9yeSA9IGNvbW1vbkRpcihkaXJlY3RvcnksIG9wdGlvbnMuZmlsZXMpO1xuXHR9XG5cblx0ZGlyZWN0b3J5ID0gcGtnRGlyLnN5bmMoZGlyZWN0b3J5KTtcblxuXHRpZiAoIWRpcmVjdG9yeSkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdGNvbnN0IG5vZGVNb2R1bGVzID0gZ2V0Tm9kZU1vZHVsZURpcmVjdG9yeShkaXJlY3RvcnkpO1xuXHRpZiAoIW5vZGVNb2R1bGVzKSB7XG5cdFx0cmV0dXJuIHVuZGVmaW5lZDtcblx0fVxuXG5cdHJldHVybiB1c2VEaXJlY3RvcnkocGF0aC5qb2luKGRpcmVjdG9yeSwgJ25vZGVfbW9kdWxlcycsICcuY2FjaGUnLCBvcHRpb25zLm5hbWUpLCBvcHRpb25zKTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/find-cache-dir/index.js\n");

/***/ }),

/***/ "./node_modules/find-up/index.js":
/*!***************************************!*\
  !*** ./node_modules/find-up/index.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst path = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'path'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\nconst locatePath = __webpack_require__(/*! locate-path */ \"./node_modules/locate-path/index.js\");\nconst pathExists = __webpack_require__(/*! path-exists */ \"./node_modules/path-exists/index.js\");\n\nconst stop = Symbol('findUp.stop');\n\nmodule.exports = async (name, options = {}) => {\n\tlet directory = path.resolve(options.cwd || '');\n\tconst {root} = path.parse(directory);\n\tconst paths = [].concat(name);\n\n\tconst runMatcher = async locateOptions => {\n\t\tif (typeof name !== 'function') {\n\t\t\treturn locatePath(paths, locateOptions);\n\t\t}\n\n\t\tconst foundPath = await name(locateOptions.cwd);\n\t\tif (typeof foundPath === 'string') {\n\t\t\treturn locatePath([foundPath], locateOptions);\n\t\t}\n\n\t\treturn foundPath;\n\t};\n\n\t// eslint-disable-next-line no-constant-condition\n\twhile (true) {\n\t\t// eslint-disable-next-line no-await-in-loop\n\t\tconst foundPath = await runMatcher({...options, cwd: directory});\n\n\t\tif (foundPath === stop) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (foundPath) {\n\t\t\treturn path.resolve(directory, foundPath);\n\t\t}\n\n\t\tif (directory === root) {\n\t\t\treturn;\n\t\t}\n\n\t\tdirectory = path.dirname(directory);\n\t}\n};\n\nmodule.exports.sync = (name, options = {}) => {\n\tlet directory = path.resolve(options.cwd || '');\n\tconst {root} = path.parse(directory);\n\tconst paths = [].concat(name);\n\n\tconst runMatcher = locateOptions => {\n\t\tif (typeof name !== 'function') {\n\t\t\treturn locatePath.sync(paths, locateOptions);\n\t\t}\n\n\t\tconst foundPath = name(locateOptions.cwd);\n\t\tif (typeof foundPath === 'string') {\n\t\t\treturn locatePath.sync([foundPath], locateOptions);\n\t\t}\n\n\t\treturn foundPath;\n\t};\n\n\t// eslint-disable-next-line no-constant-condition\n\twhile (true) {\n\t\tconst foundPath = runMatcher({...options, cwd: directory});\n\n\t\tif (foundPath === stop) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (foundPath) {\n\t\t\treturn path.resolve(directory, foundPath);\n\t\t}\n\n\t\tif (directory === root) {\n\t\t\treturn;\n\t\t}\n\n\t\tdirectory = path.dirname(directory);\n\t}\n};\n\nmodule.exports.exists = pathExists;\n\nmodule.exports.sync.exists = pathExists.sync;\n\nmodule.exports.stop = stop;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZmluZC11cC9pbmRleC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLGFBQWEsbUJBQU8sQ0FBQyxtSUFBTTtBQUMzQixtQkFBbUIsbUJBQU8sQ0FBQyx3REFBYTtBQUN4QyxtQkFBbUIsbUJBQU8sQ0FBQyx3REFBYTs7QUFFeEM7O0FBRUEsMENBQTBDO0FBQzFDO0FBQ0EsUUFBUSxNQUFNO0FBQ2Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsMkJBQTJCOztBQUVqRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLHNCQUFzQjtBQUN6QztBQUNBLFFBQVEsTUFBTTtBQUNkOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdDQUFnQywyQkFBMkI7O0FBRTNEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUI7O0FBRXJCLDBCQUEwQjs7QUFFMUIsbUJBQW1CIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdG9kby1saXN0Ly4vbm9kZV9tb2R1bGVzL2ZpbmQtdXAvaW5kZXguanM/MzExYSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xuY29uc3QgbG9jYXRlUGF0aCA9IHJlcXVpcmUoJ2xvY2F0ZS1wYXRoJyk7XG5jb25zdCBwYXRoRXhpc3RzID0gcmVxdWlyZSgncGF0aC1leGlzdHMnKTtcblxuY29uc3Qgc3RvcCA9IFN5bWJvbCgnZmluZFVwLnN0b3AnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBhc3luYyAobmFtZSwgb3B0aW9ucyA9IHt9KSA9PiB7XG5cdGxldCBkaXJlY3RvcnkgPSBwYXRoLnJlc29sdmUob3B0aW9ucy5jd2QgfHwgJycpO1xuXHRjb25zdCB7cm9vdH0gPSBwYXRoLnBhcnNlKGRpcmVjdG9yeSk7XG5cdGNvbnN0IHBhdGhzID0gW10uY29uY2F0KG5hbWUpO1xuXG5cdGNvbnN0IHJ1bk1hdGNoZXIgPSBhc3luYyBsb2NhdGVPcHRpb25zID0+IHtcblx0XHRpZiAodHlwZW9mIG5hbWUgIT09ICdmdW5jdGlvbicpIHtcblx0XHRcdHJldHVybiBsb2NhdGVQYXRoKHBhdGhzLCBsb2NhdGVPcHRpb25zKTtcblx0XHR9XG5cblx0XHRjb25zdCBmb3VuZFBhdGggPSBhd2FpdCBuYW1lKGxvY2F0ZU9wdGlvbnMuY3dkKTtcblx0XHRpZiAodHlwZW9mIGZvdW5kUGF0aCA9PT0gJ3N0cmluZycpIHtcblx0XHRcdHJldHVybiBsb2NhdGVQYXRoKFtmb3VuZFBhdGhdLCBsb2NhdGVPcHRpb25zKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZm91bmRQYXRoO1xuXHR9O1xuXG5cdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zdGFudC1jb25kaXRpb25cblx0d2hpbGUgKHRydWUpIHtcblx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYXdhaXQtaW4tbG9vcFxuXHRcdGNvbnN0IGZvdW5kUGF0aCA9IGF3YWl0IHJ1bk1hdGNoZXIoey4uLm9wdGlvbnMsIGN3ZDogZGlyZWN0b3J5fSk7XG5cblx0XHRpZiAoZm91bmRQYXRoID09PSBzdG9wKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKGZvdW5kUGF0aCkge1xuXHRcdFx0cmV0dXJuIHBhdGgucmVzb2x2ZShkaXJlY3RvcnksIGZvdW5kUGF0aCk7XG5cdFx0fVxuXG5cdFx0aWYgKGRpcmVjdG9yeSA9PT0gcm9vdCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGRpcmVjdG9yeSA9IHBhdGguZGlybmFtZShkaXJlY3RvcnkpO1xuXHR9XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5zeW5jID0gKG5hbWUsIG9wdGlvbnMgPSB7fSkgPT4ge1xuXHRsZXQgZGlyZWN0b3J5ID0gcGF0aC5yZXNvbHZlKG9wdGlvbnMuY3dkIHx8ICcnKTtcblx0Y29uc3Qge3Jvb3R9ID0gcGF0aC5wYXJzZShkaXJlY3RvcnkpO1xuXHRjb25zdCBwYXRocyA9IFtdLmNvbmNhdChuYW1lKTtcblxuXHRjb25zdCBydW5NYXRjaGVyID0gbG9jYXRlT3B0aW9ucyA9PiB7XG5cdFx0aWYgKHR5cGVvZiBuYW1lICE9PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRyZXR1cm4gbG9jYXRlUGF0aC5zeW5jKHBhdGhzLCBsb2NhdGVPcHRpb25zKTtcblx0XHR9XG5cblx0XHRjb25zdCBmb3VuZFBhdGggPSBuYW1lKGxvY2F0ZU9wdGlvbnMuY3dkKTtcblx0XHRpZiAodHlwZW9mIGZvdW5kUGF0aCA9PT0gJ3N0cmluZycpIHtcblx0XHRcdHJldHVybiBsb2NhdGVQYXRoLnN5bmMoW2ZvdW5kUGF0aF0sIGxvY2F0ZU9wdGlvbnMpO1xuXHRcdH1cblxuXHRcdHJldHVybiBmb3VuZFBhdGg7XG5cdH07XG5cblx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnN0YW50LWNvbmRpdGlvblxuXHR3aGlsZSAodHJ1ZSkge1xuXHRcdGNvbnN0IGZvdW5kUGF0aCA9IHJ1bk1hdGNoZXIoey4uLm9wdGlvbnMsIGN3ZDogZGlyZWN0b3J5fSk7XG5cblx0XHRpZiAoZm91bmRQYXRoID09PSBzdG9wKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKGZvdW5kUGF0aCkge1xuXHRcdFx0cmV0dXJuIHBhdGgucmVzb2x2ZShkaXJlY3RvcnksIGZvdW5kUGF0aCk7XG5cdFx0fVxuXG5cdFx0aWYgKGRpcmVjdG9yeSA9PT0gcm9vdCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGRpcmVjdG9yeSA9IHBhdGguZGlybmFtZShkaXJlY3RvcnkpO1xuXHR9XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5leGlzdHMgPSBwYXRoRXhpc3RzO1xuXG5tb2R1bGUuZXhwb3J0cy5zeW5jLmV4aXN0cyA9IHBhdGhFeGlzdHMuc3luYztcblxubW9kdWxlLmV4cG9ydHMuc3RvcCA9IHN0b3A7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/find-up/index.js\n");

/***/ }),

/***/ "./node_modules/fs-extra/lib/copy-sync/copy-sync.js":
/*!**********************************************************!*\
  !*** ./node_modules/fs-extra/lib/copy-sync/copy-sync.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst fs = __webpack_require__(/*! graceful-fs */ \"./node_modules/graceful-fs/graceful-fs.js\")\nconst path = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'path'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()))\nconst mkdirpSync = (__webpack_require__(/*! ../mkdirs */ \"./node_modules/fs-extra/lib/mkdirs/index.js\").mkdirsSync)\nconst utimesSync = (__webpack_require__(/*! ../util/utimes.js */ \"./node_modules/fs-extra/lib/util/utimes.js\").utimesMillisSync)\nconst stat = __webpack_require__(/*! ../util/stat */ \"./node_modules/fs-extra/lib/util/stat.js\")\n\nfunction copySync (src, dest, opts) {\n  if (typeof opts === 'function') {\n    opts = { filter: opts }\n  }\n\n  opts = opts || {}\n  opts.clobber = 'clobber' in opts ? !!opts.clobber : true // default to true for now\n  opts.overwrite = 'overwrite' in opts ? !!opts.overwrite : opts.clobber // overwrite falls back to clobber\n\n  // Warn about using preserveTimestamps on 32-bit node\n  if (opts.preserveTimestamps && process.arch === 'ia32') {\n    console.warn(`fs-extra: Using the preserveTimestamps option in 32-bit node is not recommended;\\n\n    see https://github.com/jprichardson/node-fs-extra/issues/269`)\n  }\n\n  const { srcStat, destStat } = stat.checkPathsSync(src, dest, 'copy')\n  stat.checkParentPathsSync(src, srcStat, dest, 'copy')\n  return handleFilterAndCopy(destStat, src, dest, opts)\n}\n\nfunction handleFilterAndCopy (destStat, src, dest, opts) {\n  if (opts.filter && !opts.filter(src, dest)) return\n  const destParent = path.dirname(dest)\n  if (!fs.existsSync(destParent)) mkdirpSync(destParent)\n  return startCopy(destStat, src, dest, opts)\n}\n\nfunction startCopy (destStat, src, dest, opts) {\n  if (opts.filter && !opts.filter(src, dest)) return\n  return getStats(destStat, src, dest, opts)\n}\n\nfunction getStats (destStat, src, dest, opts) {\n  const statSync = opts.dereference ? fs.statSync : fs.lstatSync\n  const srcStat = statSync(src)\n\n  if (srcStat.isDirectory()) return onDir(srcStat, destStat, src, dest, opts)\n  else if (srcStat.isFile() ||\n           srcStat.isCharacterDevice() ||\n           srcStat.isBlockDevice()) return onFile(srcStat, destStat, src, dest, opts)\n  else if (srcStat.isSymbolicLink()) return onLink(destStat, src, dest, opts)\n}\n\nfunction onFile (srcStat, destStat, src, dest, opts) {\n  if (!destStat) return copyFile(srcStat, src, dest, opts)\n  return mayCopyFile(srcStat, src, dest, opts)\n}\n\nfunction mayCopyFile (srcStat, src, dest, opts) {\n  if (opts.overwrite) {\n    fs.unlinkSync(dest)\n    return copyFile(srcStat, src, dest, opts)\n  } else if (opts.errorOnExist) {\n    throw new Error(`'${dest}' already exists`)\n  }\n}\n\nfunction copyFile (srcStat, src, dest, opts) {\n  if (typeof fs.copyFileSync === 'function') {\n    fs.copyFileSync(src, dest)\n    fs.chmodSync(dest, srcStat.mode)\n    if (opts.preserveTimestamps) {\n      return utimesSync(dest, srcStat.atime, srcStat.mtime)\n    }\n    return\n  }\n  return copyFileFallback(srcStat, src, dest, opts)\n}\n\nfunction copyFileFallback (srcStat, src, dest, opts) {\n  const BUF_LENGTH = 64 * 1024\n  const _buff = __webpack_require__(/*! ../util/buffer */ \"./node_modules/fs-extra/lib/util/buffer.js\")(BUF_LENGTH)\n\n  const fdr = fs.openSync(src, 'r')\n  const fdw = fs.openSync(dest, 'w', srcStat.mode)\n  let pos = 0\n\n  while (pos < srcStat.size) {\n    const bytesRead = fs.readSync(fdr, _buff, 0, BUF_LENGTH, pos)\n    fs.writeSync(fdw, _buff, 0, bytesRead)\n    pos += bytesRead\n  }\n\n  if (opts.preserveTimestamps) fs.futimesSync(fdw, srcStat.atime, srcStat.mtime)\n\n  fs.closeSync(fdr)\n  fs.closeSync(fdw)\n}\n\nfunction onDir (srcStat, destStat, src, dest, opts) {\n  if (!destStat) return mkDirAndCopy(srcStat, src, dest, opts)\n  if (destStat && !destStat.isDirectory()) {\n    throw new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`)\n  }\n  return copyDir(src, dest, opts)\n}\n\nfunction mkDirAndCopy (srcStat, src, dest, opts) {\n  fs.mkdirSync(dest)\n  copyDir(src, dest, opts)\n  return fs.chmodSync(dest, srcStat.mode)\n}\n\nfunction copyDir (src, dest, opts) {\n  fs.readdirSync(src).forEach(item => copyDirItem(item, src, dest, opts))\n}\n\nfunction copyDirItem (item, src, dest, opts) {\n  const srcItem = path.join(src, item)\n  const destItem = path.join(dest, item)\n  const { destStat } = stat.checkPathsSync(srcItem, destItem, 'copy')\n  return startCopy(destStat, srcItem, destItem, opts)\n}\n\nfunction onLink (destStat, src, dest, opts) {\n  let resolvedSrc = fs.readlinkSync(src)\n  if (opts.dereference) {\n    resolvedSrc = path.resolve(process.cwd(), resolvedSrc)\n  }\n\n  if (!destStat) {\n    return fs.symlinkSync(resolvedSrc, dest)\n  } else {\n    let resolvedDest\n    try {\n      resolvedDest = fs.readlinkSync(dest)\n    } catch (err) {\n      // dest exists and is a regular file or directory,\n      // Windows may throw UNKNOWN error. If dest already exists,\n      // fs throws error anyway, so no need to guard against it here.\n      if (err.code === 'EINVAL' || err.code === 'UNKNOWN') return fs.symlinkSync(resolvedSrc, dest)\n      throw err\n    }\n    if (opts.dereference) {\n      resolvedDest = path.resolve(process.cwd(), resolvedDest)\n    }\n    if (stat.isSrcSubdir(resolvedSrc, resolvedDest)) {\n      throw new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`)\n    }\n\n    // prevent copy if src is a subdir of dest since unlinking\n    // dest in this case would result in removing src contents\n    // and therefore a broken symlink would be created.\n    if (fs.statSync(dest).isDirectory() && stat.isSrcSubdir(resolvedDest, resolvedSrc)) {\n      throw new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`)\n    }\n    return copyLink(resolvedSrc, dest)\n  }\n}\n\nfunction copyLink (resolvedSrc, dest) {\n  fs.unlinkSync(dest)\n  return fs.symlinkSync(resolvedSrc, dest)\n}\n\nmodule.exports = copySync\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL2NvcHktc3luYy9jb3B5LXN5bmMuanMuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosV0FBVyxtQkFBTyxDQUFDLDhEQUFhO0FBQ2hDLGFBQWEsbUJBQU8sQ0FBQyxtSUFBTTtBQUMzQixtQkFBbUIsZ0dBQStCO0FBQ2xELG1CQUFtQiw2R0FBNkM7QUFDaEUsYUFBYSxtQkFBTyxDQUFDLDhEQUFjOztBQUVuQztBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0dBQWtHO0FBQ2xHO0FBQ0E7O0FBRUEsVUFBVSxvQkFBb0I7QUFDOUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLHdCQUF3QixLQUFLO0FBQzdCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLG1CQUFPLENBQUMsa0VBQWdCOztBQUV4QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdURBQXVELEtBQUssb0JBQW9CLElBQUk7QUFDcEY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsV0FBVztBQUNyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsWUFBWSxrQ0FBa0MsYUFBYTtBQUNqRzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxhQUFhLFVBQVUsWUFBWTtBQUM5RTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3RvZG8tbGlzdC8uL25vZGVfbW9kdWxlcy9mcy1leHRyYS9saWIvY29weS1zeW5jL2NvcHktc3luYy5qcz84NjNlIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBmcyA9IHJlcXVpcmUoJ2dyYWNlZnVsLWZzJylcbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJylcbmNvbnN0IG1rZGlycFN5bmMgPSByZXF1aXJlKCcuLi9ta2RpcnMnKS5ta2RpcnNTeW5jXG5jb25zdCB1dGltZXNTeW5jID0gcmVxdWlyZSgnLi4vdXRpbC91dGltZXMuanMnKS51dGltZXNNaWxsaXNTeW5jXG5jb25zdCBzdGF0ID0gcmVxdWlyZSgnLi4vdXRpbC9zdGF0JylcblxuZnVuY3Rpb24gY29weVN5bmMgKHNyYywgZGVzdCwgb3B0cykge1xuICBpZiAodHlwZW9mIG9wdHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBvcHRzID0geyBmaWx0ZXI6IG9wdHMgfVxuICB9XG5cbiAgb3B0cyA9IG9wdHMgfHwge31cbiAgb3B0cy5jbG9iYmVyID0gJ2Nsb2JiZXInIGluIG9wdHMgPyAhIW9wdHMuY2xvYmJlciA6IHRydWUgLy8gZGVmYXVsdCB0byB0cnVlIGZvciBub3dcbiAgb3B0cy5vdmVyd3JpdGUgPSAnb3ZlcndyaXRlJyBpbiBvcHRzID8gISFvcHRzLm92ZXJ3cml0ZSA6IG9wdHMuY2xvYmJlciAvLyBvdmVyd3JpdGUgZmFsbHMgYmFjayB0byBjbG9iYmVyXG5cbiAgLy8gV2FybiBhYm91dCB1c2luZyBwcmVzZXJ2ZVRpbWVzdGFtcHMgb24gMzItYml0IG5vZGVcbiAgaWYgKG9wdHMucHJlc2VydmVUaW1lc3RhbXBzICYmIHByb2Nlc3MuYXJjaCA9PT0gJ2lhMzInKSB7XG4gICAgY29uc29sZS53YXJuKGBmcy1leHRyYTogVXNpbmcgdGhlIHByZXNlcnZlVGltZXN0YW1wcyBvcHRpb24gaW4gMzItYml0IG5vZGUgaXMgbm90IHJlY29tbWVuZGVkO1xcblxuICAgIHNlZSBodHRwczovL2dpdGh1Yi5jb20vanByaWNoYXJkc29uL25vZGUtZnMtZXh0cmEvaXNzdWVzLzI2OWApXG4gIH1cblxuICBjb25zdCB7IHNyY1N0YXQsIGRlc3RTdGF0IH0gPSBzdGF0LmNoZWNrUGF0aHNTeW5jKHNyYywgZGVzdCwgJ2NvcHknKVxuICBzdGF0LmNoZWNrUGFyZW50UGF0aHNTeW5jKHNyYywgc3JjU3RhdCwgZGVzdCwgJ2NvcHknKVxuICByZXR1cm4gaGFuZGxlRmlsdGVyQW5kQ29weShkZXN0U3RhdCwgc3JjLCBkZXN0LCBvcHRzKVxufVxuXG5mdW5jdGlvbiBoYW5kbGVGaWx0ZXJBbmRDb3B5IChkZXN0U3RhdCwgc3JjLCBkZXN0LCBvcHRzKSB7XG4gIGlmIChvcHRzLmZpbHRlciAmJiAhb3B0cy5maWx0ZXIoc3JjLCBkZXN0KSkgcmV0dXJuXG4gIGNvbnN0IGRlc3RQYXJlbnQgPSBwYXRoLmRpcm5hbWUoZGVzdClcbiAgaWYgKCFmcy5leGlzdHNTeW5jKGRlc3RQYXJlbnQpKSBta2RpcnBTeW5jKGRlc3RQYXJlbnQpXG4gIHJldHVybiBzdGFydENvcHkoZGVzdFN0YXQsIHNyYywgZGVzdCwgb3B0cylcbn1cblxuZnVuY3Rpb24gc3RhcnRDb3B5IChkZXN0U3RhdCwgc3JjLCBkZXN0LCBvcHRzKSB7XG4gIGlmIChvcHRzLmZpbHRlciAmJiAhb3B0cy5maWx0ZXIoc3JjLCBkZXN0KSkgcmV0dXJuXG4gIHJldHVybiBnZXRTdGF0cyhkZXN0U3RhdCwgc3JjLCBkZXN0LCBvcHRzKVxufVxuXG5mdW5jdGlvbiBnZXRTdGF0cyAoZGVzdFN0YXQsIHNyYywgZGVzdCwgb3B0cykge1xuICBjb25zdCBzdGF0U3luYyA9IG9wdHMuZGVyZWZlcmVuY2UgPyBmcy5zdGF0U3luYyA6IGZzLmxzdGF0U3luY1xuICBjb25zdCBzcmNTdGF0ID0gc3RhdFN5bmMoc3JjKVxuXG4gIGlmIChzcmNTdGF0LmlzRGlyZWN0b3J5KCkpIHJldHVybiBvbkRpcihzcmNTdGF0LCBkZXN0U3RhdCwgc3JjLCBkZXN0LCBvcHRzKVxuICBlbHNlIGlmIChzcmNTdGF0LmlzRmlsZSgpIHx8XG4gICAgICAgICAgIHNyY1N0YXQuaXNDaGFyYWN0ZXJEZXZpY2UoKSB8fFxuICAgICAgICAgICBzcmNTdGF0LmlzQmxvY2tEZXZpY2UoKSkgcmV0dXJuIG9uRmlsZShzcmNTdGF0LCBkZXN0U3RhdCwgc3JjLCBkZXN0LCBvcHRzKVxuICBlbHNlIGlmIChzcmNTdGF0LmlzU3ltYm9saWNMaW5rKCkpIHJldHVybiBvbkxpbmsoZGVzdFN0YXQsIHNyYywgZGVzdCwgb3B0cylcbn1cblxuZnVuY3Rpb24gb25GaWxlIChzcmNTdGF0LCBkZXN0U3RhdCwgc3JjLCBkZXN0LCBvcHRzKSB7XG4gIGlmICghZGVzdFN0YXQpIHJldHVybiBjb3B5RmlsZShzcmNTdGF0LCBzcmMsIGRlc3QsIG9wdHMpXG4gIHJldHVybiBtYXlDb3B5RmlsZShzcmNTdGF0LCBzcmMsIGRlc3QsIG9wdHMpXG59XG5cbmZ1bmN0aW9uIG1heUNvcHlGaWxlIChzcmNTdGF0LCBzcmMsIGRlc3QsIG9wdHMpIHtcbiAgaWYgKG9wdHMub3ZlcndyaXRlKSB7XG4gICAgZnMudW5saW5rU3luYyhkZXN0KVxuICAgIHJldHVybiBjb3B5RmlsZShzcmNTdGF0LCBzcmMsIGRlc3QsIG9wdHMpXG4gIH0gZWxzZSBpZiAob3B0cy5lcnJvck9uRXhpc3QpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYCcke2Rlc3R9JyBhbHJlYWR5IGV4aXN0c2ApXG4gIH1cbn1cblxuZnVuY3Rpb24gY29weUZpbGUgKHNyY1N0YXQsIHNyYywgZGVzdCwgb3B0cykge1xuICBpZiAodHlwZW9mIGZzLmNvcHlGaWxlU3luYyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGZzLmNvcHlGaWxlU3luYyhzcmMsIGRlc3QpXG4gICAgZnMuY2htb2RTeW5jKGRlc3QsIHNyY1N0YXQubW9kZSlcbiAgICBpZiAob3B0cy5wcmVzZXJ2ZVRpbWVzdGFtcHMpIHtcbiAgICAgIHJldHVybiB1dGltZXNTeW5jKGRlc3QsIHNyY1N0YXQuYXRpbWUsIHNyY1N0YXQubXRpbWUpXG4gICAgfVxuICAgIHJldHVyblxuICB9XG4gIHJldHVybiBjb3B5RmlsZUZhbGxiYWNrKHNyY1N0YXQsIHNyYywgZGVzdCwgb3B0cylcbn1cblxuZnVuY3Rpb24gY29weUZpbGVGYWxsYmFjayAoc3JjU3RhdCwgc3JjLCBkZXN0LCBvcHRzKSB7XG4gIGNvbnN0IEJVRl9MRU5HVEggPSA2NCAqIDEwMjRcbiAgY29uc3QgX2J1ZmYgPSByZXF1aXJlKCcuLi91dGlsL2J1ZmZlcicpKEJVRl9MRU5HVEgpXG5cbiAgY29uc3QgZmRyID0gZnMub3BlblN5bmMoc3JjLCAncicpXG4gIGNvbnN0IGZkdyA9IGZzLm9wZW5TeW5jKGRlc3QsICd3Jywgc3JjU3RhdC5tb2RlKVxuICBsZXQgcG9zID0gMFxuXG4gIHdoaWxlIChwb3MgPCBzcmNTdGF0LnNpemUpIHtcbiAgICBjb25zdCBieXRlc1JlYWQgPSBmcy5yZWFkU3luYyhmZHIsIF9idWZmLCAwLCBCVUZfTEVOR1RILCBwb3MpXG4gICAgZnMud3JpdGVTeW5jKGZkdywgX2J1ZmYsIDAsIGJ5dGVzUmVhZClcbiAgICBwb3MgKz0gYnl0ZXNSZWFkXG4gIH1cblxuICBpZiAob3B0cy5wcmVzZXJ2ZVRpbWVzdGFtcHMpIGZzLmZ1dGltZXNTeW5jKGZkdywgc3JjU3RhdC5hdGltZSwgc3JjU3RhdC5tdGltZSlcblxuICBmcy5jbG9zZVN5bmMoZmRyKVxuICBmcy5jbG9zZVN5bmMoZmR3KVxufVxuXG5mdW5jdGlvbiBvbkRpciAoc3JjU3RhdCwgZGVzdFN0YXQsIHNyYywgZGVzdCwgb3B0cykge1xuICBpZiAoIWRlc3RTdGF0KSByZXR1cm4gbWtEaXJBbmRDb3B5KHNyY1N0YXQsIHNyYywgZGVzdCwgb3B0cylcbiAgaWYgKGRlc3RTdGF0ICYmICFkZXN0U3RhdC5pc0RpcmVjdG9yeSgpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3Qgb3ZlcndyaXRlIG5vbi1kaXJlY3RvcnkgJyR7ZGVzdH0nIHdpdGggZGlyZWN0b3J5ICcke3NyY30nLmApXG4gIH1cbiAgcmV0dXJuIGNvcHlEaXIoc3JjLCBkZXN0LCBvcHRzKVxufVxuXG5mdW5jdGlvbiBta0RpckFuZENvcHkgKHNyY1N0YXQsIHNyYywgZGVzdCwgb3B0cykge1xuICBmcy5ta2RpclN5bmMoZGVzdClcbiAgY29weURpcihzcmMsIGRlc3QsIG9wdHMpXG4gIHJldHVybiBmcy5jaG1vZFN5bmMoZGVzdCwgc3JjU3RhdC5tb2RlKVxufVxuXG5mdW5jdGlvbiBjb3B5RGlyIChzcmMsIGRlc3QsIG9wdHMpIHtcbiAgZnMucmVhZGRpclN5bmMoc3JjKS5mb3JFYWNoKGl0ZW0gPT4gY29weURpckl0ZW0oaXRlbSwgc3JjLCBkZXN0LCBvcHRzKSlcbn1cblxuZnVuY3Rpb24gY29weURpckl0ZW0gKGl0ZW0sIHNyYywgZGVzdCwgb3B0cykge1xuICBjb25zdCBzcmNJdGVtID0gcGF0aC5qb2luKHNyYywgaXRlbSlcbiAgY29uc3QgZGVzdEl0ZW0gPSBwYXRoLmpvaW4oZGVzdCwgaXRlbSlcbiAgY29uc3QgeyBkZXN0U3RhdCB9ID0gc3RhdC5jaGVja1BhdGhzU3luYyhzcmNJdGVtLCBkZXN0SXRlbSwgJ2NvcHknKVxuICByZXR1cm4gc3RhcnRDb3B5KGRlc3RTdGF0LCBzcmNJdGVtLCBkZXN0SXRlbSwgb3B0cylcbn1cblxuZnVuY3Rpb24gb25MaW5rIChkZXN0U3RhdCwgc3JjLCBkZXN0LCBvcHRzKSB7XG4gIGxldCByZXNvbHZlZFNyYyA9IGZzLnJlYWRsaW5rU3luYyhzcmMpXG4gIGlmIChvcHRzLmRlcmVmZXJlbmNlKSB7XG4gICAgcmVzb2x2ZWRTcmMgPSBwYXRoLnJlc29sdmUocHJvY2Vzcy5jd2QoKSwgcmVzb2x2ZWRTcmMpXG4gIH1cblxuICBpZiAoIWRlc3RTdGF0KSB7XG4gICAgcmV0dXJuIGZzLnN5bWxpbmtTeW5jKHJlc29sdmVkU3JjLCBkZXN0KVxuICB9IGVsc2Uge1xuICAgIGxldCByZXNvbHZlZERlc3RcbiAgICB0cnkge1xuICAgICAgcmVzb2x2ZWREZXN0ID0gZnMucmVhZGxpbmtTeW5jKGRlc3QpXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAvLyBkZXN0IGV4aXN0cyBhbmQgaXMgYSByZWd1bGFyIGZpbGUgb3IgZGlyZWN0b3J5LFxuICAgICAgLy8gV2luZG93cyBtYXkgdGhyb3cgVU5LTk9XTiBlcnJvci4gSWYgZGVzdCBhbHJlYWR5IGV4aXN0cyxcbiAgICAgIC8vIGZzIHRocm93cyBlcnJvciBhbnl3YXksIHNvIG5vIG5lZWQgdG8gZ3VhcmQgYWdhaW5zdCBpdCBoZXJlLlxuICAgICAgaWYgKGVyci5jb2RlID09PSAnRUlOVkFMJyB8fCBlcnIuY29kZSA9PT0gJ1VOS05PV04nKSByZXR1cm4gZnMuc3ltbGlua1N5bmMocmVzb2x2ZWRTcmMsIGRlc3QpXG4gICAgICB0aHJvdyBlcnJcbiAgICB9XG4gICAgaWYgKG9wdHMuZGVyZWZlcmVuY2UpIHtcbiAgICAgIHJlc29sdmVkRGVzdCA9IHBhdGgucmVzb2x2ZShwcm9jZXNzLmN3ZCgpLCByZXNvbHZlZERlc3QpXG4gICAgfVxuICAgIGlmIChzdGF0LmlzU3JjU3ViZGlyKHJlc29sdmVkU3JjLCByZXNvbHZlZERlc3QpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBjb3B5ICcke3Jlc29sdmVkU3JjfScgdG8gYSBzdWJkaXJlY3Rvcnkgb2YgaXRzZWxmLCAnJHtyZXNvbHZlZERlc3R9Jy5gKVxuICAgIH1cblxuICAgIC8vIHByZXZlbnQgY29weSBpZiBzcmMgaXMgYSBzdWJkaXIgb2YgZGVzdCBzaW5jZSB1bmxpbmtpbmdcbiAgICAvLyBkZXN0IGluIHRoaXMgY2FzZSB3b3VsZCByZXN1bHQgaW4gcmVtb3Zpbmcgc3JjIGNvbnRlbnRzXG4gICAgLy8gYW5kIHRoZXJlZm9yZSBhIGJyb2tlbiBzeW1saW5rIHdvdWxkIGJlIGNyZWF0ZWQuXG4gICAgaWYgKGZzLnN0YXRTeW5jKGRlc3QpLmlzRGlyZWN0b3J5KCkgJiYgc3RhdC5pc1NyY1N1YmRpcihyZXNvbHZlZERlc3QsIHJlc29sdmVkU3JjKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3Qgb3ZlcndyaXRlICcke3Jlc29sdmVkRGVzdH0nIHdpdGggJyR7cmVzb2x2ZWRTcmN9Jy5gKVxuICAgIH1cbiAgICByZXR1cm4gY29weUxpbmsocmVzb2x2ZWRTcmMsIGRlc3QpXG4gIH1cbn1cblxuZnVuY3Rpb24gY29weUxpbmsgKHJlc29sdmVkU3JjLCBkZXN0KSB7XG4gIGZzLnVubGlua1N5bmMoZGVzdClcbiAgcmV0dXJuIGZzLnN5bWxpbmtTeW5jKHJlc29sdmVkU3JjLCBkZXN0KVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvcHlTeW5jXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/fs-extra/lib/copy-sync/copy-sync.js\n");

/***/ }),

/***/ "./node_modules/fs-extra/lib/copy-sync/index.js":
/*!******************************************************!*\
  !*** ./node_modules/fs-extra/lib/copy-sync/index.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nmodule.exports = {\n  copySync: __webpack_require__(/*! ./copy-sync */ \"./node_modules/fs-extra/lib/copy-sync/copy-sync.js\")\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL2NvcHktc3luYy9pbmRleC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWjtBQUNBLFlBQVksbUJBQU8sQ0FBQyx1RUFBYTtBQUNqQyIsInNvdXJjZXMiOlsid2VicGFjazovL3RvZG8tbGlzdC8uL25vZGVfbW9kdWxlcy9mcy1leHRyYS9saWIvY29weS1zeW5jL2luZGV4LmpzP2RhNTQiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBjb3B5U3luYzogcmVxdWlyZSgnLi9jb3B5LXN5bmMnKVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/fs-extra/lib/copy-sync/index.js\n");

/***/ }),

/***/ "./node_modules/fs-extra/lib/copy/copy.js":
/*!************************************************!*\
  !*** ./node_modules/fs-extra/lib/copy/copy.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst fs = __webpack_require__(/*! graceful-fs */ \"./node_modules/graceful-fs/graceful-fs.js\")\nconst path = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'path'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()))\nconst mkdirp = (__webpack_require__(/*! ../mkdirs */ \"./node_modules/fs-extra/lib/mkdirs/index.js\").mkdirs)\nconst pathExists = (__webpack_require__(/*! ../path-exists */ \"./node_modules/fs-extra/lib/path-exists/index.js\").pathExists)\nconst utimes = (__webpack_require__(/*! ../util/utimes */ \"./node_modules/fs-extra/lib/util/utimes.js\").utimesMillis)\nconst stat = __webpack_require__(/*! ../util/stat */ \"./node_modules/fs-extra/lib/util/stat.js\")\n\nfunction copy (src, dest, opts, cb) {\n  if (typeof opts === 'function' && !cb) {\n    cb = opts\n    opts = {}\n  } else if (typeof opts === 'function') {\n    opts = { filter: opts }\n  }\n\n  cb = cb || function () {}\n  opts = opts || {}\n\n  opts.clobber = 'clobber' in opts ? !!opts.clobber : true // default to true for now\n  opts.overwrite = 'overwrite' in opts ? !!opts.overwrite : opts.clobber // overwrite falls back to clobber\n\n  // Warn about using preserveTimestamps on 32-bit node\n  if (opts.preserveTimestamps && process.arch === 'ia32') {\n    console.warn(`fs-extra: Using the preserveTimestamps option in 32-bit node is not recommended;\\n\n    see https://github.com/jprichardson/node-fs-extra/issues/269`)\n  }\n\n  stat.checkPaths(src, dest, 'copy', (err, stats) => {\n    if (err) return cb(err)\n    const { srcStat, destStat } = stats\n    stat.checkParentPaths(src, srcStat, dest, 'copy', err => {\n      if (err) return cb(err)\n      if (opts.filter) return handleFilter(checkParentDir, destStat, src, dest, opts, cb)\n      return checkParentDir(destStat, src, dest, opts, cb)\n    })\n  })\n}\n\nfunction checkParentDir (destStat, src, dest, opts, cb) {\n  const destParent = path.dirname(dest)\n  pathExists(destParent, (err, dirExists) => {\n    if (err) return cb(err)\n    if (dirExists) return startCopy(destStat, src, dest, opts, cb)\n    mkdirp(destParent, err => {\n      if (err) return cb(err)\n      return startCopy(destStat, src, dest, opts, cb)\n    })\n  })\n}\n\nfunction handleFilter (onInclude, destStat, src, dest, opts, cb) {\n  Promise.resolve(opts.filter(src, dest)).then(include => {\n    if (include) return onInclude(destStat, src, dest, opts, cb)\n    return cb()\n  }, error => cb(error))\n}\n\nfunction startCopy (destStat, src, dest, opts, cb) {\n  if (opts.filter) return handleFilter(getStats, destStat, src, dest, opts, cb)\n  return getStats(destStat, src, dest, opts, cb)\n}\n\nfunction getStats (destStat, src, dest, opts, cb) {\n  const stat = opts.dereference ? fs.stat : fs.lstat\n  stat(src, (err, srcStat) => {\n    if (err) return cb(err)\n\n    if (srcStat.isDirectory()) return onDir(srcStat, destStat, src, dest, opts, cb)\n    else if (srcStat.isFile() ||\n             srcStat.isCharacterDevice() ||\n             srcStat.isBlockDevice()) return onFile(srcStat, destStat, src, dest, opts, cb)\n    else if (srcStat.isSymbolicLink()) return onLink(destStat, src, dest, opts, cb)\n  })\n}\n\nfunction onFile (srcStat, destStat, src, dest, opts, cb) {\n  if (!destStat) return copyFile(srcStat, src, dest, opts, cb)\n  return mayCopyFile(srcStat, src, dest, opts, cb)\n}\n\nfunction mayCopyFile (srcStat, src, dest, opts, cb) {\n  if (opts.overwrite) {\n    fs.unlink(dest, err => {\n      if (err) return cb(err)\n      return copyFile(srcStat, src, dest, opts, cb)\n    })\n  } else if (opts.errorOnExist) {\n    return cb(new Error(`'${dest}' already exists`))\n  } else return cb()\n}\n\nfunction copyFile (srcStat, src, dest, opts, cb) {\n  if (typeof fs.copyFile === 'function') {\n    return fs.copyFile(src, dest, err => {\n      if (err) return cb(err)\n      return setDestModeAndTimestamps(srcStat, dest, opts, cb)\n    })\n  }\n  return copyFileFallback(srcStat, src, dest, opts, cb)\n}\n\nfunction copyFileFallback (srcStat, src, dest, opts, cb) {\n  const rs = fs.createReadStream(src)\n  rs.on('error', err => cb(err)).once('open', () => {\n    const ws = fs.createWriteStream(dest, { mode: srcStat.mode })\n    ws.on('error', err => cb(err))\n      .on('open', () => rs.pipe(ws))\n      .once('close', () => setDestModeAndTimestamps(srcStat, dest, opts, cb))\n  })\n}\n\nfunction setDestModeAndTimestamps (srcStat, dest, opts, cb) {\n  fs.chmod(dest, srcStat.mode, err => {\n    if (err) return cb(err)\n    if (opts.preserveTimestamps) {\n      return utimes(dest, srcStat.atime, srcStat.mtime, cb)\n    }\n    return cb()\n  })\n}\n\nfunction onDir (srcStat, destStat, src, dest, opts, cb) {\n  if (!destStat) return mkDirAndCopy(srcStat, src, dest, opts, cb)\n  if (destStat && !destStat.isDirectory()) {\n    return cb(new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`))\n  }\n  return copyDir(src, dest, opts, cb)\n}\n\nfunction mkDirAndCopy (srcStat, src, dest, opts, cb) {\n  fs.mkdir(dest, err => {\n    if (err) return cb(err)\n    copyDir(src, dest, opts, err => {\n      if (err) return cb(err)\n      return fs.chmod(dest, srcStat.mode, cb)\n    })\n  })\n}\n\nfunction copyDir (src, dest, opts, cb) {\n  fs.readdir(src, (err, items) => {\n    if (err) return cb(err)\n    return copyDirItems(items, src, dest, opts, cb)\n  })\n}\n\nfunction copyDirItems (items, src, dest, opts, cb) {\n  const item = items.pop()\n  if (!item) return cb()\n  return copyDirItem(items, item, src, dest, opts, cb)\n}\n\nfunction copyDirItem (items, item, src, dest, opts, cb) {\n  const srcItem = path.join(src, item)\n  const destItem = path.join(dest, item)\n  stat.checkPaths(srcItem, destItem, 'copy', (err, stats) => {\n    if (err) return cb(err)\n    const { destStat } = stats\n    startCopy(destStat, srcItem, destItem, opts, err => {\n      if (err) return cb(err)\n      return copyDirItems(items, src, dest, opts, cb)\n    })\n  })\n}\n\nfunction onLink (destStat, src, dest, opts, cb) {\n  fs.readlink(src, (err, resolvedSrc) => {\n    if (err) return cb(err)\n    if (opts.dereference) {\n      resolvedSrc = path.resolve(process.cwd(), resolvedSrc)\n    }\n\n    if (!destStat) {\n      return fs.symlink(resolvedSrc, dest, cb)\n    } else {\n      fs.readlink(dest, (err, resolvedDest) => {\n        if (err) {\n          // dest exists and is a regular file or directory,\n          // Windows may throw UNKNOWN error. If dest already exists,\n          // fs throws error anyway, so no need to guard against it here.\n          if (err.code === 'EINVAL' || err.code === 'UNKNOWN') return fs.symlink(resolvedSrc, dest, cb)\n          return cb(err)\n        }\n        if (opts.dereference) {\n          resolvedDest = path.resolve(process.cwd(), resolvedDest)\n        }\n        if (stat.isSrcSubdir(resolvedSrc, resolvedDest)) {\n          return cb(new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`))\n        }\n\n        // do not copy if src is a subdir of dest since unlinking\n        // dest in this case would result in removing src contents\n        // and therefore a broken symlink would be created.\n        if (destStat.isDirectory() && stat.isSrcSubdir(resolvedDest, resolvedSrc)) {\n          return cb(new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`))\n        }\n        return copyLink(resolvedSrc, dest, cb)\n      })\n    }\n  })\n}\n\nfunction copyLink (resolvedSrc, dest, cb) {\n  fs.unlink(dest, err => {\n    if (err) return cb(err)\n    return fs.symlink(resolvedSrc, dest, cb)\n  })\n}\n\nmodule.exports = copy\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL2NvcHkvY29weS5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixXQUFXLG1CQUFPLENBQUMsOERBQWE7QUFDaEMsYUFBYSxtQkFBTyxDQUFDLG1JQUFNO0FBQzNCLGVBQWUsNEZBQTJCO0FBQzFDLG1CQUFtQiwwR0FBb0M7QUFDdkQsZUFBZSxzR0FBc0M7QUFDckQsYUFBYSxtQkFBTyxDQUFDLDhEQUFjOztBQUVuQztBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixhQUFhO0FBQ2I7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrR0FBa0c7QUFDbEc7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxvQkFBb0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0osNEJBQTRCLEtBQUs7QUFDakMsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxvQkFBb0I7QUFDaEU7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxLQUFLLG9CQUFvQixJQUFJO0FBQ3hGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksV0FBVztBQUN2QjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxZQUFZLGtDQUFrQyxhQUFhO0FBQ3pHOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELGFBQWEsVUFBVSxZQUFZO0FBQ3RGO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90b2RvLWxpc3QvLi9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL2NvcHkvY29weS5qcz80Mjk5Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBmcyA9IHJlcXVpcmUoJ2dyYWNlZnVsLWZzJylcbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJylcbmNvbnN0IG1rZGlycCA9IHJlcXVpcmUoJy4uL21rZGlycycpLm1rZGlyc1xuY29uc3QgcGF0aEV4aXN0cyA9IHJlcXVpcmUoJy4uL3BhdGgtZXhpc3RzJykucGF0aEV4aXN0c1xuY29uc3QgdXRpbWVzID0gcmVxdWlyZSgnLi4vdXRpbC91dGltZXMnKS51dGltZXNNaWxsaXNcbmNvbnN0IHN0YXQgPSByZXF1aXJlKCcuLi91dGlsL3N0YXQnKVxuXG5mdW5jdGlvbiBjb3B5IChzcmMsIGRlc3QsIG9wdHMsIGNiKSB7XG4gIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ2Z1bmN0aW9uJyAmJiAhY2IpIHtcbiAgICBjYiA9IG9wdHNcbiAgICBvcHRzID0ge31cbiAgfSBlbHNlIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIG9wdHMgPSB7IGZpbHRlcjogb3B0cyB9XG4gIH1cblxuICBjYiA9IGNiIHx8IGZ1bmN0aW9uICgpIHt9XG4gIG9wdHMgPSBvcHRzIHx8IHt9XG5cbiAgb3B0cy5jbG9iYmVyID0gJ2Nsb2JiZXInIGluIG9wdHMgPyAhIW9wdHMuY2xvYmJlciA6IHRydWUgLy8gZGVmYXVsdCB0byB0cnVlIGZvciBub3dcbiAgb3B0cy5vdmVyd3JpdGUgPSAnb3ZlcndyaXRlJyBpbiBvcHRzID8gISFvcHRzLm92ZXJ3cml0ZSA6IG9wdHMuY2xvYmJlciAvLyBvdmVyd3JpdGUgZmFsbHMgYmFjayB0byBjbG9iYmVyXG5cbiAgLy8gV2FybiBhYm91dCB1c2luZyBwcmVzZXJ2ZVRpbWVzdGFtcHMgb24gMzItYml0IG5vZGVcbiAgaWYgKG9wdHMucHJlc2VydmVUaW1lc3RhbXBzICYmIHByb2Nlc3MuYXJjaCA9PT0gJ2lhMzInKSB7XG4gICAgY29uc29sZS53YXJuKGBmcy1leHRyYTogVXNpbmcgdGhlIHByZXNlcnZlVGltZXN0YW1wcyBvcHRpb24gaW4gMzItYml0IG5vZGUgaXMgbm90IHJlY29tbWVuZGVkO1xcblxuICAgIHNlZSBodHRwczovL2dpdGh1Yi5jb20vanByaWNoYXJkc29uL25vZGUtZnMtZXh0cmEvaXNzdWVzLzI2OWApXG4gIH1cblxuICBzdGF0LmNoZWNrUGF0aHMoc3JjLCBkZXN0LCAnY29weScsIChlcnIsIHN0YXRzKSA9PiB7XG4gICAgaWYgKGVycikgcmV0dXJuIGNiKGVycilcbiAgICBjb25zdCB7IHNyY1N0YXQsIGRlc3RTdGF0IH0gPSBzdGF0c1xuICAgIHN0YXQuY2hlY2tQYXJlbnRQYXRocyhzcmMsIHNyY1N0YXQsIGRlc3QsICdjb3B5JywgZXJyID0+IHtcbiAgICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpXG4gICAgICBpZiAob3B0cy5maWx0ZXIpIHJldHVybiBoYW5kbGVGaWx0ZXIoY2hlY2tQYXJlbnREaXIsIGRlc3RTdGF0LCBzcmMsIGRlc3QsIG9wdHMsIGNiKVxuICAgICAgcmV0dXJuIGNoZWNrUGFyZW50RGlyKGRlc3RTdGF0LCBzcmMsIGRlc3QsIG9wdHMsIGNiKVxuICAgIH0pXG4gIH0pXG59XG5cbmZ1bmN0aW9uIGNoZWNrUGFyZW50RGlyIChkZXN0U3RhdCwgc3JjLCBkZXN0LCBvcHRzLCBjYikge1xuICBjb25zdCBkZXN0UGFyZW50ID0gcGF0aC5kaXJuYW1lKGRlc3QpXG4gIHBhdGhFeGlzdHMoZGVzdFBhcmVudCwgKGVyciwgZGlyRXhpc3RzKSA9PiB7XG4gICAgaWYgKGVycikgcmV0dXJuIGNiKGVycilcbiAgICBpZiAoZGlyRXhpc3RzKSByZXR1cm4gc3RhcnRDb3B5KGRlc3RTdGF0LCBzcmMsIGRlc3QsIG9wdHMsIGNiKVxuICAgIG1rZGlycChkZXN0UGFyZW50LCBlcnIgPT4ge1xuICAgICAgaWYgKGVycikgcmV0dXJuIGNiKGVycilcbiAgICAgIHJldHVybiBzdGFydENvcHkoZGVzdFN0YXQsIHNyYywgZGVzdCwgb3B0cywgY2IpXG4gICAgfSlcbiAgfSlcbn1cblxuZnVuY3Rpb24gaGFuZGxlRmlsdGVyIChvbkluY2x1ZGUsIGRlc3RTdGF0LCBzcmMsIGRlc3QsIG9wdHMsIGNiKSB7XG4gIFByb21pc2UucmVzb2x2ZShvcHRzLmZpbHRlcihzcmMsIGRlc3QpKS50aGVuKGluY2x1ZGUgPT4ge1xuICAgIGlmIChpbmNsdWRlKSByZXR1cm4gb25JbmNsdWRlKGRlc3RTdGF0LCBzcmMsIGRlc3QsIG9wdHMsIGNiKVxuICAgIHJldHVybiBjYigpXG4gIH0sIGVycm9yID0+IGNiKGVycm9yKSlcbn1cblxuZnVuY3Rpb24gc3RhcnRDb3B5IChkZXN0U3RhdCwgc3JjLCBkZXN0LCBvcHRzLCBjYikge1xuICBpZiAob3B0cy5maWx0ZXIpIHJldHVybiBoYW5kbGVGaWx0ZXIoZ2V0U3RhdHMsIGRlc3RTdGF0LCBzcmMsIGRlc3QsIG9wdHMsIGNiKVxuICByZXR1cm4gZ2V0U3RhdHMoZGVzdFN0YXQsIHNyYywgZGVzdCwgb3B0cywgY2IpXG59XG5cbmZ1bmN0aW9uIGdldFN0YXRzIChkZXN0U3RhdCwgc3JjLCBkZXN0LCBvcHRzLCBjYikge1xuICBjb25zdCBzdGF0ID0gb3B0cy5kZXJlZmVyZW5jZSA/IGZzLnN0YXQgOiBmcy5sc3RhdFxuICBzdGF0KHNyYywgKGVyciwgc3JjU3RhdCkgPT4ge1xuICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpXG5cbiAgICBpZiAoc3JjU3RhdC5pc0RpcmVjdG9yeSgpKSByZXR1cm4gb25EaXIoc3JjU3RhdCwgZGVzdFN0YXQsIHNyYywgZGVzdCwgb3B0cywgY2IpXG4gICAgZWxzZSBpZiAoc3JjU3RhdC5pc0ZpbGUoKSB8fFxuICAgICAgICAgICAgIHNyY1N0YXQuaXNDaGFyYWN0ZXJEZXZpY2UoKSB8fFxuICAgICAgICAgICAgIHNyY1N0YXQuaXNCbG9ja0RldmljZSgpKSByZXR1cm4gb25GaWxlKHNyY1N0YXQsIGRlc3RTdGF0LCBzcmMsIGRlc3QsIG9wdHMsIGNiKVxuICAgIGVsc2UgaWYgKHNyY1N0YXQuaXNTeW1ib2xpY0xpbmsoKSkgcmV0dXJuIG9uTGluayhkZXN0U3RhdCwgc3JjLCBkZXN0LCBvcHRzLCBjYilcbiAgfSlcbn1cblxuZnVuY3Rpb24gb25GaWxlIChzcmNTdGF0LCBkZXN0U3RhdCwgc3JjLCBkZXN0LCBvcHRzLCBjYikge1xuICBpZiAoIWRlc3RTdGF0KSByZXR1cm4gY29weUZpbGUoc3JjU3RhdCwgc3JjLCBkZXN0LCBvcHRzLCBjYilcbiAgcmV0dXJuIG1heUNvcHlGaWxlKHNyY1N0YXQsIHNyYywgZGVzdCwgb3B0cywgY2IpXG59XG5cbmZ1bmN0aW9uIG1heUNvcHlGaWxlIChzcmNTdGF0LCBzcmMsIGRlc3QsIG9wdHMsIGNiKSB7XG4gIGlmIChvcHRzLm92ZXJ3cml0ZSkge1xuICAgIGZzLnVubGluayhkZXN0LCBlcnIgPT4ge1xuICAgICAgaWYgKGVycikgcmV0dXJuIGNiKGVycilcbiAgICAgIHJldHVybiBjb3B5RmlsZShzcmNTdGF0LCBzcmMsIGRlc3QsIG9wdHMsIGNiKVxuICAgIH0pXG4gIH0gZWxzZSBpZiAob3B0cy5lcnJvck9uRXhpc3QpIHtcbiAgICByZXR1cm4gY2IobmV3IEVycm9yKGAnJHtkZXN0fScgYWxyZWFkeSBleGlzdHNgKSlcbiAgfSBlbHNlIHJldHVybiBjYigpXG59XG5cbmZ1bmN0aW9uIGNvcHlGaWxlIChzcmNTdGF0LCBzcmMsIGRlc3QsIG9wdHMsIGNiKSB7XG4gIGlmICh0eXBlb2YgZnMuY29weUZpbGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZnMuY29weUZpbGUoc3JjLCBkZXN0LCBlcnIgPT4ge1xuICAgICAgaWYgKGVycikgcmV0dXJuIGNiKGVycilcbiAgICAgIHJldHVybiBzZXREZXN0TW9kZUFuZFRpbWVzdGFtcHMoc3JjU3RhdCwgZGVzdCwgb3B0cywgY2IpXG4gICAgfSlcbiAgfVxuICByZXR1cm4gY29weUZpbGVGYWxsYmFjayhzcmNTdGF0LCBzcmMsIGRlc3QsIG9wdHMsIGNiKVxufVxuXG5mdW5jdGlvbiBjb3B5RmlsZUZhbGxiYWNrIChzcmNTdGF0LCBzcmMsIGRlc3QsIG9wdHMsIGNiKSB7XG4gIGNvbnN0IHJzID0gZnMuY3JlYXRlUmVhZFN0cmVhbShzcmMpXG4gIHJzLm9uKCdlcnJvcicsIGVyciA9PiBjYihlcnIpKS5vbmNlKCdvcGVuJywgKCkgPT4ge1xuICAgIGNvbnN0IHdzID0gZnMuY3JlYXRlV3JpdGVTdHJlYW0oZGVzdCwgeyBtb2RlOiBzcmNTdGF0Lm1vZGUgfSlcbiAgICB3cy5vbignZXJyb3InLCBlcnIgPT4gY2IoZXJyKSlcbiAgICAgIC5vbignb3BlbicsICgpID0+IHJzLnBpcGUod3MpKVxuICAgICAgLm9uY2UoJ2Nsb3NlJywgKCkgPT4gc2V0RGVzdE1vZGVBbmRUaW1lc3RhbXBzKHNyY1N0YXQsIGRlc3QsIG9wdHMsIGNiKSlcbiAgfSlcbn1cblxuZnVuY3Rpb24gc2V0RGVzdE1vZGVBbmRUaW1lc3RhbXBzIChzcmNTdGF0LCBkZXN0LCBvcHRzLCBjYikge1xuICBmcy5jaG1vZChkZXN0LCBzcmNTdGF0Lm1vZGUsIGVyciA9PiB7XG4gICAgaWYgKGVycikgcmV0dXJuIGNiKGVycilcbiAgICBpZiAob3B0cy5wcmVzZXJ2ZVRpbWVzdGFtcHMpIHtcbiAgICAgIHJldHVybiB1dGltZXMoZGVzdCwgc3JjU3RhdC5hdGltZSwgc3JjU3RhdC5tdGltZSwgY2IpXG4gICAgfVxuICAgIHJldHVybiBjYigpXG4gIH0pXG59XG5cbmZ1bmN0aW9uIG9uRGlyIChzcmNTdGF0LCBkZXN0U3RhdCwgc3JjLCBkZXN0LCBvcHRzLCBjYikge1xuICBpZiAoIWRlc3RTdGF0KSByZXR1cm4gbWtEaXJBbmRDb3B5KHNyY1N0YXQsIHNyYywgZGVzdCwgb3B0cywgY2IpXG4gIGlmIChkZXN0U3RhdCAmJiAhZGVzdFN0YXQuaXNEaXJlY3RvcnkoKSkge1xuICAgIHJldHVybiBjYihuZXcgRXJyb3IoYENhbm5vdCBvdmVyd3JpdGUgbm9uLWRpcmVjdG9yeSAnJHtkZXN0fScgd2l0aCBkaXJlY3RvcnkgJyR7c3JjfScuYCkpXG4gIH1cbiAgcmV0dXJuIGNvcHlEaXIoc3JjLCBkZXN0LCBvcHRzLCBjYilcbn1cblxuZnVuY3Rpb24gbWtEaXJBbmRDb3B5IChzcmNTdGF0LCBzcmMsIGRlc3QsIG9wdHMsIGNiKSB7XG4gIGZzLm1rZGlyKGRlc3QsIGVyciA9PiB7XG4gICAgaWYgKGVycikgcmV0dXJuIGNiKGVycilcbiAgICBjb3B5RGlyKHNyYywgZGVzdCwgb3B0cywgZXJyID0+IHtcbiAgICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpXG4gICAgICByZXR1cm4gZnMuY2htb2QoZGVzdCwgc3JjU3RhdC5tb2RlLCBjYilcbiAgICB9KVxuICB9KVxufVxuXG5mdW5jdGlvbiBjb3B5RGlyIChzcmMsIGRlc3QsIG9wdHMsIGNiKSB7XG4gIGZzLnJlYWRkaXIoc3JjLCAoZXJyLCBpdGVtcykgPT4ge1xuICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpXG4gICAgcmV0dXJuIGNvcHlEaXJJdGVtcyhpdGVtcywgc3JjLCBkZXN0LCBvcHRzLCBjYilcbiAgfSlcbn1cblxuZnVuY3Rpb24gY29weURpckl0ZW1zIChpdGVtcywgc3JjLCBkZXN0LCBvcHRzLCBjYikge1xuICBjb25zdCBpdGVtID0gaXRlbXMucG9wKClcbiAgaWYgKCFpdGVtKSByZXR1cm4gY2IoKVxuICByZXR1cm4gY29weURpckl0ZW0oaXRlbXMsIGl0ZW0sIHNyYywgZGVzdCwgb3B0cywgY2IpXG59XG5cbmZ1bmN0aW9uIGNvcHlEaXJJdGVtIChpdGVtcywgaXRlbSwgc3JjLCBkZXN0LCBvcHRzLCBjYikge1xuICBjb25zdCBzcmNJdGVtID0gcGF0aC5qb2luKHNyYywgaXRlbSlcbiAgY29uc3QgZGVzdEl0ZW0gPSBwYXRoLmpvaW4oZGVzdCwgaXRlbSlcbiAgc3RhdC5jaGVja1BhdGhzKHNyY0l0ZW0sIGRlc3RJdGVtLCAnY29weScsIChlcnIsIHN0YXRzKSA9PiB7XG4gICAgaWYgKGVycikgcmV0dXJuIGNiKGVycilcbiAgICBjb25zdCB7IGRlc3RTdGF0IH0gPSBzdGF0c1xuICAgIHN0YXJ0Q29weShkZXN0U3RhdCwgc3JjSXRlbSwgZGVzdEl0ZW0sIG9wdHMsIGVyciA9PiB7XG4gICAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKVxuICAgICAgcmV0dXJuIGNvcHlEaXJJdGVtcyhpdGVtcywgc3JjLCBkZXN0LCBvcHRzLCBjYilcbiAgICB9KVxuICB9KVxufVxuXG5mdW5jdGlvbiBvbkxpbmsgKGRlc3RTdGF0LCBzcmMsIGRlc3QsIG9wdHMsIGNiKSB7XG4gIGZzLnJlYWRsaW5rKHNyYywgKGVyciwgcmVzb2x2ZWRTcmMpID0+IHtcbiAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKVxuICAgIGlmIChvcHRzLmRlcmVmZXJlbmNlKSB7XG4gICAgICByZXNvbHZlZFNyYyA9IHBhdGgucmVzb2x2ZShwcm9jZXNzLmN3ZCgpLCByZXNvbHZlZFNyYylcbiAgICB9XG5cbiAgICBpZiAoIWRlc3RTdGF0KSB7XG4gICAgICByZXR1cm4gZnMuc3ltbGluayhyZXNvbHZlZFNyYywgZGVzdCwgY2IpXG4gICAgfSBlbHNlIHtcbiAgICAgIGZzLnJlYWRsaW5rKGRlc3QsIChlcnIsIHJlc29sdmVkRGVzdCkgPT4ge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgLy8gZGVzdCBleGlzdHMgYW5kIGlzIGEgcmVndWxhciBmaWxlIG9yIGRpcmVjdG9yeSxcbiAgICAgICAgICAvLyBXaW5kb3dzIG1heSB0aHJvdyBVTktOT1dOIGVycm9yLiBJZiBkZXN0IGFscmVhZHkgZXhpc3RzLFxuICAgICAgICAgIC8vIGZzIHRocm93cyBlcnJvciBhbnl3YXksIHNvIG5vIG5lZWQgdG8gZ3VhcmQgYWdhaW5zdCBpdCBoZXJlLlxuICAgICAgICAgIGlmIChlcnIuY29kZSA9PT0gJ0VJTlZBTCcgfHwgZXJyLmNvZGUgPT09ICdVTktOT1dOJykgcmV0dXJuIGZzLnN5bWxpbmsocmVzb2x2ZWRTcmMsIGRlc3QsIGNiKVxuICAgICAgICAgIHJldHVybiBjYihlcnIpXG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdHMuZGVyZWZlcmVuY2UpIHtcbiAgICAgICAgICByZXNvbHZlZERlc3QgPSBwYXRoLnJlc29sdmUocHJvY2Vzcy5jd2QoKSwgcmVzb2x2ZWREZXN0KVxuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0LmlzU3JjU3ViZGlyKHJlc29sdmVkU3JjLCByZXNvbHZlZERlc3QpKSB7XG4gICAgICAgICAgcmV0dXJuIGNiKG5ldyBFcnJvcihgQ2Fubm90IGNvcHkgJyR7cmVzb2x2ZWRTcmN9JyB0byBhIHN1YmRpcmVjdG9yeSBvZiBpdHNlbGYsICcke3Jlc29sdmVkRGVzdH0nLmApKVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gZG8gbm90IGNvcHkgaWYgc3JjIGlzIGEgc3ViZGlyIG9mIGRlc3Qgc2luY2UgdW5saW5raW5nXG4gICAgICAgIC8vIGRlc3QgaW4gdGhpcyBjYXNlIHdvdWxkIHJlc3VsdCBpbiByZW1vdmluZyBzcmMgY29udGVudHNcbiAgICAgICAgLy8gYW5kIHRoZXJlZm9yZSBhIGJyb2tlbiBzeW1saW5rIHdvdWxkIGJlIGNyZWF0ZWQuXG4gICAgICAgIGlmIChkZXN0U3RhdC5pc0RpcmVjdG9yeSgpICYmIHN0YXQuaXNTcmNTdWJkaXIocmVzb2x2ZWREZXN0LCByZXNvbHZlZFNyYykpIHtcbiAgICAgICAgICByZXR1cm4gY2IobmV3IEVycm9yKGBDYW5ub3Qgb3ZlcndyaXRlICcke3Jlc29sdmVkRGVzdH0nIHdpdGggJyR7cmVzb2x2ZWRTcmN9Jy5gKSlcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29weUxpbmsocmVzb2x2ZWRTcmMsIGRlc3QsIGNiKVxuICAgICAgfSlcbiAgICB9XG4gIH0pXG59XG5cbmZ1bmN0aW9uIGNvcHlMaW5rIChyZXNvbHZlZFNyYywgZGVzdCwgY2IpIHtcbiAgZnMudW5saW5rKGRlc3QsIGVyciA9PiB7XG4gICAgaWYgKGVycikgcmV0dXJuIGNiKGVycilcbiAgICByZXR1cm4gZnMuc3ltbGluayhyZXNvbHZlZFNyYywgZGVzdCwgY2IpXG4gIH0pXG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29weVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/fs-extra/lib/copy/copy.js\n");

/***/ }),

/***/ "./node_modules/fs-extra/lib/copy/index.js":
/*!*************************************************!*\
  !*** ./node_modules/fs-extra/lib/copy/index.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst u = (__webpack_require__(/*! universalify */ \"./node_modules/universalify/index.js\").fromCallback)\nmodule.exports = {\n  copy: u(__webpack_require__(/*! ./copy */ \"./node_modules/fs-extra/lib/copy/copy.js\"))\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL2NvcHkvaW5kZXguanMuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosVUFBVSw4RkFBb0M7QUFDOUM7QUFDQSxVQUFVLG1CQUFPLENBQUMsd0RBQVE7QUFDMUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90b2RvLWxpc3QvLi9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL2NvcHkvaW5kZXguanM/NzA4NiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgdSA9IHJlcXVpcmUoJ3VuaXZlcnNhbGlmeScpLmZyb21DYWxsYmFja1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGNvcHk6IHUocmVxdWlyZSgnLi9jb3B5JykpXG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/fs-extra/lib/copy/index.js\n");

/***/ }),

/***/ "./node_modules/fs-extra/lib/empty/index.js":
/*!**************************************************!*\
  !*** ./node_modules/fs-extra/lib/empty/index.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst u = (__webpack_require__(/*! universalify */ \"./node_modules/universalify/index.js\").fromCallback)\nconst fs = __webpack_require__(/*! graceful-fs */ \"./node_modules/graceful-fs/graceful-fs.js\")\nconst path = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'path'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()))\nconst mkdir = __webpack_require__(/*! ../mkdirs */ \"./node_modules/fs-extra/lib/mkdirs/index.js\")\nconst remove = __webpack_require__(/*! ../remove */ \"./node_modules/fs-extra/lib/remove/index.js\")\n\nconst emptyDir = u(function emptyDir (dir, callback) {\n  callback = callback || function () {}\n  fs.readdir(dir, (err, items) => {\n    if (err) return mkdir.mkdirs(dir, callback)\n\n    items = items.map(item => path.join(dir, item))\n\n    deleteItem()\n\n    function deleteItem () {\n      const item = items.pop()\n      if (!item) return callback()\n      remove.remove(item, err => {\n        if (err) return callback(err)\n        deleteItem()\n      })\n    }\n  })\n})\n\nfunction emptyDirSync (dir) {\n  let items\n  try {\n    items = fs.readdirSync(dir)\n  } catch (err) {\n    return mkdir.mkdirsSync(dir)\n  }\n\n  items.forEach(item => {\n    item = path.join(dir, item)\n    remove.removeSync(item)\n  })\n}\n\nmodule.exports = {\n  emptyDirSync,\n  emptydirSync: emptyDirSync,\n  emptyDir,\n  emptydir: emptyDir\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL2VtcHR5L2luZGV4LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLFVBQVUsOEZBQW9DO0FBQzlDLFdBQVcsbUJBQU8sQ0FBQyw4REFBYTtBQUNoQyxhQUFhLG1CQUFPLENBQUMsbUlBQU07QUFDM0IsY0FBYyxtQkFBTyxDQUFDLDhEQUFXO0FBQ2pDLGVBQWUsbUJBQU8sQ0FBQyw4REFBVzs7QUFFbEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNILENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdG9kby1saXN0Ly4vbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi9lbXB0eS9pbmRleC5qcz85YWI3Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB1ID0gcmVxdWlyZSgndW5pdmVyc2FsaWZ5JykuZnJvbUNhbGxiYWNrXG5jb25zdCBmcyA9IHJlcXVpcmUoJ2dyYWNlZnVsLWZzJylcbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJylcbmNvbnN0IG1rZGlyID0gcmVxdWlyZSgnLi4vbWtkaXJzJylcbmNvbnN0IHJlbW92ZSA9IHJlcXVpcmUoJy4uL3JlbW92ZScpXG5cbmNvbnN0IGVtcHR5RGlyID0gdShmdW5jdGlvbiBlbXB0eURpciAoZGlyLCBjYWxsYmFjaykge1xuICBjYWxsYmFjayA9IGNhbGxiYWNrIHx8IGZ1bmN0aW9uICgpIHt9XG4gIGZzLnJlYWRkaXIoZGlyLCAoZXJyLCBpdGVtcykgPT4ge1xuICAgIGlmIChlcnIpIHJldHVybiBta2Rpci5ta2RpcnMoZGlyLCBjYWxsYmFjaylcblxuICAgIGl0ZW1zID0gaXRlbXMubWFwKGl0ZW0gPT4gcGF0aC5qb2luKGRpciwgaXRlbSkpXG5cbiAgICBkZWxldGVJdGVtKClcblxuICAgIGZ1bmN0aW9uIGRlbGV0ZUl0ZW0gKCkge1xuICAgICAgY29uc3QgaXRlbSA9IGl0ZW1zLnBvcCgpXG4gICAgICBpZiAoIWl0ZW0pIHJldHVybiBjYWxsYmFjaygpXG4gICAgICByZW1vdmUucmVtb3ZlKGl0ZW0sIGVyciA9PiB7XG4gICAgICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgICAgIGRlbGV0ZUl0ZW0oKVxuICAgICAgfSlcbiAgICB9XG4gIH0pXG59KVxuXG5mdW5jdGlvbiBlbXB0eURpclN5bmMgKGRpcikge1xuICBsZXQgaXRlbXNcbiAgdHJ5IHtcbiAgICBpdGVtcyA9IGZzLnJlYWRkaXJTeW5jKGRpcilcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIG1rZGlyLm1rZGlyc1N5bmMoZGlyKVxuICB9XG5cbiAgaXRlbXMuZm9yRWFjaChpdGVtID0+IHtcbiAgICBpdGVtID0gcGF0aC5qb2luKGRpciwgaXRlbSlcbiAgICByZW1vdmUucmVtb3ZlU3luYyhpdGVtKVxuICB9KVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZW1wdHlEaXJTeW5jLFxuICBlbXB0eWRpclN5bmM6IGVtcHR5RGlyU3luYyxcbiAgZW1wdHlEaXIsXG4gIGVtcHR5ZGlyOiBlbXB0eURpclxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/fs-extra/lib/empty/index.js\n");

/***/ }),

/***/ "./node_modules/fs-extra/lib/ensure/file.js":
/*!**************************************************!*\
  !*** ./node_modules/fs-extra/lib/ensure/file.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst u = (__webpack_require__(/*! universalify */ \"./node_modules/universalify/index.js\").fromCallback)\nconst path = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'path'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()))\nconst fs = __webpack_require__(/*! graceful-fs */ \"./node_modules/graceful-fs/graceful-fs.js\")\nconst mkdir = __webpack_require__(/*! ../mkdirs */ \"./node_modules/fs-extra/lib/mkdirs/index.js\")\nconst pathExists = (__webpack_require__(/*! ../path-exists */ \"./node_modules/fs-extra/lib/path-exists/index.js\").pathExists)\n\nfunction createFile (file, callback) {\n  function makeFile () {\n    fs.writeFile(file, '', err => {\n      if (err) return callback(err)\n      callback()\n    })\n  }\n\n  fs.stat(file, (err, stats) => { // eslint-disable-line handle-callback-err\n    if (!err && stats.isFile()) return callback()\n    const dir = path.dirname(file)\n    pathExists(dir, (err, dirExists) => {\n      if (err) return callback(err)\n      if (dirExists) return makeFile()\n      mkdir.mkdirs(dir, err => {\n        if (err) return callback(err)\n        makeFile()\n      })\n    })\n  })\n}\n\nfunction createFileSync (file) {\n  let stats\n  try {\n    stats = fs.statSync(file)\n  } catch (e) {}\n  if (stats && stats.isFile()) return\n\n  const dir = path.dirname(file)\n  if (!fs.existsSync(dir)) {\n    mkdir.mkdirsSync(dir)\n  }\n\n  fs.writeFileSync(file, '')\n}\n\nmodule.exports = {\n  createFile: u(createFile),\n  createFileSync\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL2Vuc3VyZS9maWxlLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLFVBQVUsOEZBQW9DO0FBQzlDLGFBQWEsbUJBQU8sQ0FBQyxtSUFBTTtBQUMzQixXQUFXLG1CQUFPLENBQUMsOERBQWE7QUFDaEMsY0FBYyxtQkFBTyxDQUFDLDhEQUFXO0FBQ2pDLG1CQUFtQiwwR0FBb0M7O0FBRXZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUEsa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdG9kby1saXN0Ly4vbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi9lbnN1cmUvZmlsZS5qcz85OTQzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB1ID0gcmVxdWlyZSgndW5pdmVyc2FsaWZ5JykuZnJvbUNhbGxiYWNrXG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpXG5jb25zdCBmcyA9IHJlcXVpcmUoJ2dyYWNlZnVsLWZzJylcbmNvbnN0IG1rZGlyID0gcmVxdWlyZSgnLi4vbWtkaXJzJylcbmNvbnN0IHBhdGhFeGlzdHMgPSByZXF1aXJlKCcuLi9wYXRoLWV4aXN0cycpLnBhdGhFeGlzdHNcblxuZnVuY3Rpb24gY3JlYXRlRmlsZSAoZmlsZSwgY2FsbGJhY2spIHtcbiAgZnVuY3Rpb24gbWFrZUZpbGUgKCkge1xuICAgIGZzLndyaXRlRmlsZShmaWxlLCAnJywgZXJyID0+IHtcbiAgICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgICBjYWxsYmFjaygpXG4gICAgfSlcbiAgfVxuXG4gIGZzLnN0YXQoZmlsZSwgKGVyciwgc3RhdHMpID0+IHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBoYW5kbGUtY2FsbGJhY2stZXJyXG4gICAgaWYgKCFlcnIgJiYgc3RhdHMuaXNGaWxlKCkpIHJldHVybiBjYWxsYmFjaygpXG4gICAgY29uc3QgZGlyID0gcGF0aC5kaXJuYW1lKGZpbGUpXG4gICAgcGF0aEV4aXN0cyhkaXIsIChlcnIsIGRpckV4aXN0cykgPT4ge1xuICAgICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycilcbiAgICAgIGlmIChkaXJFeGlzdHMpIHJldHVybiBtYWtlRmlsZSgpXG4gICAgICBta2Rpci5ta2RpcnMoZGlyLCBlcnIgPT4ge1xuICAgICAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKVxuICAgICAgICBtYWtlRmlsZSgpXG4gICAgICB9KVxuICAgIH0pXG4gIH0pXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUZpbGVTeW5jIChmaWxlKSB7XG4gIGxldCBzdGF0c1xuICB0cnkge1xuICAgIHN0YXRzID0gZnMuc3RhdFN5bmMoZmlsZSlcbiAgfSBjYXRjaCAoZSkge31cbiAgaWYgKHN0YXRzICYmIHN0YXRzLmlzRmlsZSgpKSByZXR1cm5cblxuICBjb25zdCBkaXIgPSBwYXRoLmRpcm5hbWUoZmlsZSlcbiAgaWYgKCFmcy5leGlzdHNTeW5jKGRpcikpIHtcbiAgICBta2Rpci5ta2RpcnNTeW5jKGRpcilcbiAgfVxuXG4gIGZzLndyaXRlRmlsZVN5bmMoZmlsZSwgJycpXG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBjcmVhdGVGaWxlOiB1KGNyZWF0ZUZpbGUpLFxuICBjcmVhdGVGaWxlU3luY1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/fs-extra/lib/ensure/file.js\n");

/***/ }),

/***/ "./node_modules/fs-extra/lib/ensure/index.js":
/*!***************************************************!*\
  !*** ./node_modules/fs-extra/lib/ensure/index.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst file = __webpack_require__(/*! ./file */ \"./node_modules/fs-extra/lib/ensure/file.js\")\nconst link = __webpack_require__(/*! ./link */ \"./node_modules/fs-extra/lib/ensure/link.js\")\nconst symlink = __webpack_require__(/*! ./symlink */ \"./node_modules/fs-extra/lib/ensure/symlink.js\")\n\nmodule.exports = {\n  // file\n  createFile: file.createFile,\n  createFileSync: file.createFileSync,\n  ensureFile: file.createFile,\n  ensureFileSync: file.createFileSync,\n  // link\n  createLink: link.createLink,\n  createLinkSync: link.createLinkSync,\n  ensureLink: link.createLink,\n  ensureLinkSync: link.createLinkSync,\n  // symlink\n  createSymlink: symlink.createSymlink,\n  createSymlinkSync: symlink.createSymlinkSync,\n  ensureSymlink: symlink.createSymlink,\n  ensureSymlinkSync: symlink.createSymlinkSync\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL2Vuc3VyZS9pbmRleC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixhQUFhLG1CQUFPLENBQUMsMERBQVE7QUFDN0IsYUFBYSxtQkFBTyxDQUFDLDBEQUFRO0FBQzdCLGdCQUFnQixtQkFBTyxDQUFDLGdFQUFXOztBQUVuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdG9kby1saXN0Ly4vbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi9lbnN1cmUvaW5kZXguanM/MmEzNiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgZmlsZSA9IHJlcXVpcmUoJy4vZmlsZScpXG5jb25zdCBsaW5rID0gcmVxdWlyZSgnLi9saW5rJylcbmNvbnN0IHN5bWxpbmsgPSByZXF1aXJlKCcuL3N5bWxpbmsnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgLy8gZmlsZVxuICBjcmVhdGVGaWxlOiBmaWxlLmNyZWF0ZUZpbGUsXG4gIGNyZWF0ZUZpbGVTeW5jOiBmaWxlLmNyZWF0ZUZpbGVTeW5jLFxuICBlbnN1cmVGaWxlOiBmaWxlLmNyZWF0ZUZpbGUsXG4gIGVuc3VyZUZpbGVTeW5jOiBmaWxlLmNyZWF0ZUZpbGVTeW5jLFxuICAvLyBsaW5rXG4gIGNyZWF0ZUxpbms6IGxpbmsuY3JlYXRlTGluayxcbiAgY3JlYXRlTGlua1N5bmM6IGxpbmsuY3JlYXRlTGlua1N5bmMsXG4gIGVuc3VyZUxpbms6IGxpbmsuY3JlYXRlTGluayxcbiAgZW5zdXJlTGlua1N5bmM6IGxpbmsuY3JlYXRlTGlua1N5bmMsXG4gIC8vIHN5bWxpbmtcbiAgY3JlYXRlU3ltbGluazogc3ltbGluay5jcmVhdGVTeW1saW5rLFxuICBjcmVhdGVTeW1saW5rU3luYzogc3ltbGluay5jcmVhdGVTeW1saW5rU3luYyxcbiAgZW5zdXJlU3ltbGluazogc3ltbGluay5jcmVhdGVTeW1saW5rLFxuICBlbnN1cmVTeW1saW5rU3luYzogc3ltbGluay5jcmVhdGVTeW1saW5rU3luY1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/fs-extra/lib/ensure/index.js\n");

/***/ }),

/***/ "./node_modules/fs-extra/lib/ensure/link.js":
/*!**************************************************!*\
  !*** ./node_modules/fs-extra/lib/ensure/link.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst u = (__webpack_require__(/*! universalify */ \"./node_modules/universalify/index.js\").fromCallback)\nconst path = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'path'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()))\nconst fs = __webpack_require__(/*! graceful-fs */ \"./node_modules/graceful-fs/graceful-fs.js\")\nconst mkdir = __webpack_require__(/*! ../mkdirs */ \"./node_modules/fs-extra/lib/mkdirs/index.js\")\nconst pathExists = (__webpack_require__(/*! ../path-exists */ \"./node_modules/fs-extra/lib/path-exists/index.js\").pathExists)\n\nfunction createLink (srcpath, dstpath, callback) {\n  function makeLink (srcpath, dstpath) {\n    fs.link(srcpath, dstpath, err => {\n      if (err) return callback(err)\n      callback(null)\n    })\n  }\n\n  pathExists(dstpath, (err, destinationExists) => {\n    if (err) return callback(err)\n    if (destinationExists) return callback(null)\n    fs.lstat(srcpath, (err) => {\n      if (err) {\n        err.message = err.message.replace('lstat', 'ensureLink')\n        return callback(err)\n      }\n\n      const dir = path.dirname(dstpath)\n      pathExists(dir, (err, dirExists) => {\n        if (err) return callback(err)\n        if (dirExists) return makeLink(srcpath, dstpath)\n        mkdir.mkdirs(dir, err => {\n          if (err) return callback(err)\n          makeLink(srcpath, dstpath)\n        })\n      })\n    })\n  })\n}\n\nfunction createLinkSync (srcpath, dstpath) {\n  const destinationExists = fs.existsSync(dstpath)\n  if (destinationExists) return undefined\n\n  try {\n    fs.lstatSync(srcpath)\n  } catch (err) {\n    err.message = err.message.replace('lstat', 'ensureLink')\n    throw err\n  }\n\n  const dir = path.dirname(dstpath)\n  const dirExists = fs.existsSync(dir)\n  if (dirExists) return fs.linkSync(srcpath, dstpath)\n  mkdir.mkdirsSync(dir)\n\n  return fs.linkSync(srcpath, dstpath)\n}\n\nmodule.exports = {\n  createLink: u(createLink),\n  createLinkSync\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL2Vuc3VyZS9saW5rLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLFVBQVUsOEZBQW9DO0FBQzlDLGFBQWEsbUJBQU8sQ0FBQyxtSUFBTTtBQUMzQixXQUFXLG1CQUFPLENBQUMsOERBQWE7QUFDaEMsY0FBYyxtQkFBTyxDQUFDLDhEQUFXO0FBQ2pDLG1CQUFtQiwwR0FBb0M7O0FBRXZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1AsS0FBSztBQUNMLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3RvZG8tbGlzdC8uL25vZGVfbW9kdWxlcy9mcy1leHRyYS9saWIvZW5zdXJlL2xpbmsuanM/Y2YwMCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgdSA9IHJlcXVpcmUoJ3VuaXZlcnNhbGlmeScpLmZyb21DYWxsYmFja1xuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKVxuY29uc3QgZnMgPSByZXF1aXJlKCdncmFjZWZ1bC1mcycpXG5jb25zdCBta2RpciA9IHJlcXVpcmUoJy4uL21rZGlycycpXG5jb25zdCBwYXRoRXhpc3RzID0gcmVxdWlyZSgnLi4vcGF0aC1leGlzdHMnKS5wYXRoRXhpc3RzXG5cbmZ1bmN0aW9uIGNyZWF0ZUxpbmsgKHNyY3BhdGgsIGRzdHBhdGgsIGNhbGxiYWNrKSB7XG4gIGZ1bmN0aW9uIG1ha2VMaW5rIChzcmNwYXRoLCBkc3RwYXRoKSB7XG4gICAgZnMubGluayhzcmNwYXRoLCBkc3RwYXRoLCBlcnIgPT4ge1xuICAgICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycilcbiAgICAgIGNhbGxiYWNrKG51bGwpXG4gICAgfSlcbiAgfVxuXG4gIHBhdGhFeGlzdHMoZHN0cGF0aCwgKGVyciwgZGVzdGluYXRpb25FeGlzdHMpID0+IHtcbiAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKVxuICAgIGlmIChkZXN0aW5hdGlvbkV4aXN0cykgcmV0dXJuIGNhbGxiYWNrKG51bGwpXG4gICAgZnMubHN0YXQoc3JjcGF0aCwgKGVycikgPT4ge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICBlcnIubWVzc2FnZSA9IGVyci5tZXNzYWdlLnJlcGxhY2UoJ2xzdGF0JywgJ2Vuc3VyZUxpbmsnKVxuICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKVxuICAgICAgfVxuXG4gICAgICBjb25zdCBkaXIgPSBwYXRoLmRpcm5hbWUoZHN0cGF0aClcbiAgICAgIHBhdGhFeGlzdHMoZGlyLCAoZXJyLCBkaXJFeGlzdHMpID0+IHtcbiAgICAgICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycilcbiAgICAgICAgaWYgKGRpckV4aXN0cykgcmV0dXJuIG1ha2VMaW5rKHNyY3BhdGgsIGRzdHBhdGgpXG4gICAgICAgIG1rZGlyLm1rZGlycyhkaXIsIGVyciA9PiB7XG4gICAgICAgICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycilcbiAgICAgICAgICBtYWtlTGluayhzcmNwYXRoLCBkc3RwYXRoKVxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICB9KVxuICB9KVxufVxuXG5mdW5jdGlvbiBjcmVhdGVMaW5rU3luYyAoc3JjcGF0aCwgZHN0cGF0aCkge1xuICBjb25zdCBkZXN0aW5hdGlvbkV4aXN0cyA9IGZzLmV4aXN0c1N5bmMoZHN0cGF0aClcbiAgaWYgKGRlc3RpbmF0aW9uRXhpc3RzKSByZXR1cm4gdW5kZWZpbmVkXG5cbiAgdHJ5IHtcbiAgICBmcy5sc3RhdFN5bmMoc3JjcGF0aClcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgZXJyLm1lc3NhZ2UgPSBlcnIubWVzc2FnZS5yZXBsYWNlKCdsc3RhdCcsICdlbnN1cmVMaW5rJylcbiAgICB0aHJvdyBlcnJcbiAgfVxuXG4gIGNvbnN0IGRpciA9IHBhdGguZGlybmFtZShkc3RwYXRoKVxuICBjb25zdCBkaXJFeGlzdHMgPSBmcy5leGlzdHNTeW5jKGRpcilcbiAgaWYgKGRpckV4aXN0cykgcmV0dXJuIGZzLmxpbmtTeW5jKHNyY3BhdGgsIGRzdHBhdGgpXG4gIG1rZGlyLm1rZGlyc1N5bmMoZGlyKVxuXG4gIHJldHVybiBmcy5saW5rU3luYyhzcmNwYXRoLCBkc3RwYXRoKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgY3JlYXRlTGluazogdShjcmVhdGVMaW5rKSxcbiAgY3JlYXRlTGlua1N5bmNcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/fs-extra/lib/ensure/link.js\n");

/***/ }),

/***/ "./node_modules/fs-extra/lib/ensure/symlink-paths.js":
/*!***********************************************************!*\
  !*** ./node_modules/fs-extra/lib/ensure/symlink-paths.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst path = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'path'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()))\nconst fs = __webpack_require__(/*! graceful-fs */ \"./node_modules/graceful-fs/graceful-fs.js\")\nconst pathExists = (__webpack_require__(/*! ../path-exists */ \"./node_modules/fs-extra/lib/path-exists/index.js\").pathExists)\n\n/**\n * Function that returns two types of paths, one relative to symlink, and one\n * relative to the current working directory. Checks if path is absolute or\n * relative. If the path is relative, this function checks if the path is\n * relative to symlink or relative to current working directory. This is an\n * initiative to find a smarter `srcpath` to supply when building symlinks.\n * This allows you to determine which path to use out of one of three possible\n * types of source paths. The first is an absolute path. This is detected by\n * `path.isAbsolute()`. When an absolute path is provided, it is checked to\n * see if it exists. If it does it's used, if not an error is returned\n * (callback)/ thrown (sync). The other two options for `srcpath` are a\n * relative url. By default Node's `fs.symlink` works by creating a symlink\n * using `dstpath` and expects the `srcpath` to be relative to the newly\n * created symlink. If you provide a `srcpath` that does not exist on the file\n * system it results in a broken symlink. To minimize this, the function\n * checks to see if the 'relative to symlink' source file exists, and if it\n * does it will use it. If it does not, it checks if there's a file that\n * exists that is relative to the current working directory, if does its used.\n * This preserves the expectations of the original fs.symlink spec and adds\n * the ability to pass in `relative to current working direcotry` paths.\n */\n\nfunction symlinkPaths (srcpath, dstpath, callback) {\n  if (path.isAbsolute(srcpath)) {\n    return fs.lstat(srcpath, (err) => {\n      if (err) {\n        err.message = err.message.replace('lstat', 'ensureSymlink')\n        return callback(err)\n      }\n      return callback(null, {\n        'toCwd': srcpath,\n        'toDst': srcpath\n      })\n    })\n  } else {\n    const dstdir = path.dirname(dstpath)\n    const relativeToDst = path.join(dstdir, srcpath)\n    return pathExists(relativeToDst, (err, exists) => {\n      if (err) return callback(err)\n      if (exists) {\n        return callback(null, {\n          'toCwd': relativeToDst,\n          'toDst': srcpath\n        })\n      } else {\n        return fs.lstat(srcpath, (err) => {\n          if (err) {\n            err.message = err.message.replace('lstat', 'ensureSymlink')\n            return callback(err)\n          }\n          return callback(null, {\n            'toCwd': srcpath,\n            'toDst': path.relative(dstdir, srcpath)\n          })\n        })\n      }\n    })\n  }\n}\n\nfunction symlinkPathsSync (srcpath, dstpath) {\n  let exists\n  if (path.isAbsolute(srcpath)) {\n    exists = fs.existsSync(srcpath)\n    if (!exists) throw new Error('absolute srcpath does not exist')\n    return {\n      'toCwd': srcpath,\n      'toDst': srcpath\n    }\n  } else {\n    const dstdir = path.dirname(dstpath)\n    const relativeToDst = path.join(dstdir, srcpath)\n    exists = fs.existsSync(relativeToDst)\n    if (exists) {\n      return {\n        'toCwd': relativeToDst,\n        'toDst': srcpath\n      }\n    } else {\n      exists = fs.existsSync(srcpath)\n      if (!exists) throw new Error('relative srcpath does not exist')\n      return {\n        'toCwd': srcpath,\n        'toDst': path.relative(dstdir, srcpath)\n      }\n    }\n  }\n}\n\nmodule.exports = {\n  symlinkPaths,\n  symlinkPathsSync\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL2Vuc3VyZS9zeW1saW5rLXBhdGhzLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLGFBQWEsbUJBQU8sQ0FBQyxtSUFBTTtBQUMzQixXQUFXLG1CQUFPLENBQUMsOERBQWE7QUFDaEMsbUJBQW1CLDBHQUFvQzs7QUFFdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90b2RvLWxpc3QvLi9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL2Vuc3VyZS9zeW1saW5rLXBhdGhzLmpzP2Q5OGQiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJylcbmNvbnN0IGZzID0gcmVxdWlyZSgnZ3JhY2VmdWwtZnMnKVxuY29uc3QgcGF0aEV4aXN0cyA9IHJlcXVpcmUoJy4uL3BhdGgtZXhpc3RzJykucGF0aEV4aXN0c1xuXG4vKipcbiAqIEZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0d28gdHlwZXMgb2YgcGF0aHMsIG9uZSByZWxhdGl2ZSB0byBzeW1saW5rLCBhbmQgb25lXG4gKiByZWxhdGl2ZSB0byB0aGUgY3VycmVudCB3b3JraW5nIGRpcmVjdG9yeS4gQ2hlY2tzIGlmIHBhdGggaXMgYWJzb2x1dGUgb3JcbiAqIHJlbGF0aXZlLiBJZiB0aGUgcGF0aCBpcyByZWxhdGl2ZSwgdGhpcyBmdW5jdGlvbiBjaGVja3MgaWYgdGhlIHBhdGggaXNcbiAqIHJlbGF0aXZlIHRvIHN5bWxpbmsgb3IgcmVsYXRpdmUgdG8gY3VycmVudCB3b3JraW5nIGRpcmVjdG9yeS4gVGhpcyBpcyBhblxuICogaW5pdGlhdGl2ZSB0byBmaW5kIGEgc21hcnRlciBgc3JjcGF0aGAgdG8gc3VwcGx5IHdoZW4gYnVpbGRpbmcgc3ltbGlua3MuXG4gKiBUaGlzIGFsbG93cyB5b3UgdG8gZGV0ZXJtaW5lIHdoaWNoIHBhdGggdG8gdXNlIG91dCBvZiBvbmUgb2YgdGhyZWUgcG9zc2libGVcbiAqIHR5cGVzIG9mIHNvdXJjZSBwYXRocy4gVGhlIGZpcnN0IGlzIGFuIGFic29sdXRlIHBhdGguIFRoaXMgaXMgZGV0ZWN0ZWQgYnlcbiAqIGBwYXRoLmlzQWJzb2x1dGUoKWAuIFdoZW4gYW4gYWJzb2x1dGUgcGF0aCBpcyBwcm92aWRlZCwgaXQgaXMgY2hlY2tlZCB0b1xuICogc2VlIGlmIGl0IGV4aXN0cy4gSWYgaXQgZG9lcyBpdCdzIHVzZWQsIGlmIG5vdCBhbiBlcnJvciBpcyByZXR1cm5lZFxuICogKGNhbGxiYWNrKS8gdGhyb3duIChzeW5jKS4gVGhlIG90aGVyIHR3byBvcHRpb25zIGZvciBgc3JjcGF0aGAgYXJlIGFcbiAqIHJlbGF0aXZlIHVybC4gQnkgZGVmYXVsdCBOb2RlJ3MgYGZzLnN5bWxpbmtgIHdvcmtzIGJ5IGNyZWF0aW5nIGEgc3ltbGlua1xuICogdXNpbmcgYGRzdHBhdGhgIGFuZCBleHBlY3RzIHRoZSBgc3JjcGF0aGAgdG8gYmUgcmVsYXRpdmUgdG8gdGhlIG5ld2x5XG4gKiBjcmVhdGVkIHN5bWxpbmsuIElmIHlvdSBwcm92aWRlIGEgYHNyY3BhdGhgIHRoYXQgZG9lcyBub3QgZXhpc3Qgb24gdGhlIGZpbGVcbiAqIHN5c3RlbSBpdCByZXN1bHRzIGluIGEgYnJva2VuIHN5bWxpbmsuIFRvIG1pbmltaXplIHRoaXMsIHRoZSBmdW5jdGlvblxuICogY2hlY2tzIHRvIHNlZSBpZiB0aGUgJ3JlbGF0aXZlIHRvIHN5bWxpbmsnIHNvdXJjZSBmaWxlIGV4aXN0cywgYW5kIGlmIGl0XG4gKiBkb2VzIGl0IHdpbGwgdXNlIGl0LiBJZiBpdCBkb2VzIG5vdCwgaXQgY2hlY2tzIGlmIHRoZXJlJ3MgYSBmaWxlIHRoYXRcbiAqIGV4aXN0cyB0aGF0IGlzIHJlbGF0aXZlIHRvIHRoZSBjdXJyZW50IHdvcmtpbmcgZGlyZWN0b3J5LCBpZiBkb2VzIGl0cyB1c2VkLlxuICogVGhpcyBwcmVzZXJ2ZXMgdGhlIGV4cGVjdGF0aW9ucyBvZiB0aGUgb3JpZ2luYWwgZnMuc3ltbGluayBzcGVjIGFuZCBhZGRzXG4gKiB0aGUgYWJpbGl0eSB0byBwYXNzIGluIGByZWxhdGl2ZSB0byBjdXJyZW50IHdvcmtpbmcgZGlyZWNvdHJ5YCBwYXRocy5cbiAqL1xuXG5mdW5jdGlvbiBzeW1saW5rUGF0aHMgKHNyY3BhdGgsIGRzdHBhdGgsIGNhbGxiYWNrKSB7XG4gIGlmIChwYXRoLmlzQWJzb2x1dGUoc3JjcGF0aCkpIHtcbiAgICByZXR1cm4gZnMubHN0YXQoc3JjcGF0aCwgKGVycikgPT4ge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICBlcnIubWVzc2FnZSA9IGVyci5tZXNzYWdlLnJlcGxhY2UoJ2xzdGF0JywgJ2Vuc3VyZVN5bWxpbmsnKVxuICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKVxuICAgICAgfVxuICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIHtcbiAgICAgICAgJ3RvQ3dkJzogc3JjcGF0aCxcbiAgICAgICAgJ3RvRHN0Jzogc3JjcGF0aFxuICAgICAgfSlcbiAgICB9KVxuICB9IGVsc2Uge1xuICAgIGNvbnN0IGRzdGRpciA9IHBhdGguZGlybmFtZShkc3RwYXRoKVxuICAgIGNvbnN0IHJlbGF0aXZlVG9Ec3QgPSBwYXRoLmpvaW4oZHN0ZGlyLCBzcmNwYXRoKVxuICAgIHJldHVybiBwYXRoRXhpc3RzKHJlbGF0aXZlVG9Ec3QsIChlcnIsIGV4aXN0cykgPT4ge1xuICAgICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycilcbiAgICAgIGlmIChleGlzdHMpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIHtcbiAgICAgICAgICAndG9Dd2QnOiByZWxhdGl2ZVRvRHN0LFxuICAgICAgICAgICd0b0RzdCc6IHNyY3BhdGhcbiAgICAgICAgfSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmcy5sc3RhdChzcmNwYXRoLCAoZXJyKSA9PiB7XG4gICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgZXJyLm1lc3NhZ2UgPSBlcnIubWVzc2FnZS5yZXBsYWNlKCdsc3RhdCcsICdlbnN1cmVTeW1saW5rJylcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCB7XG4gICAgICAgICAgICAndG9Dd2QnOiBzcmNwYXRoLFxuICAgICAgICAgICAgJ3RvRHN0JzogcGF0aC5yZWxhdGl2ZShkc3RkaXIsIHNyY3BhdGgpXG4gICAgICAgICAgfSlcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9KVxuICB9XG59XG5cbmZ1bmN0aW9uIHN5bWxpbmtQYXRoc1N5bmMgKHNyY3BhdGgsIGRzdHBhdGgpIHtcbiAgbGV0IGV4aXN0c1xuICBpZiAocGF0aC5pc0Fic29sdXRlKHNyY3BhdGgpKSB7XG4gICAgZXhpc3RzID0gZnMuZXhpc3RzU3luYyhzcmNwYXRoKVxuICAgIGlmICghZXhpc3RzKSB0aHJvdyBuZXcgRXJyb3IoJ2Fic29sdXRlIHNyY3BhdGggZG9lcyBub3QgZXhpc3QnKVxuICAgIHJldHVybiB7XG4gICAgICAndG9Dd2QnOiBzcmNwYXRoLFxuICAgICAgJ3RvRHN0Jzogc3JjcGF0aFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBjb25zdCBkc3RkaXIgPSBwYXRoLmRpcm5hbWUoZHN0cGF0aClcbiAgICBjb25zdCByZWxhdGl2ZVRvRHN0ID0gcGF0aC5qb2luKGRzdGRpciwgc3JjcGF0aClcbiAgICBleGlzdHMgPSBmcy5leGlzdHNTeW5jKHJlbGF0aXZlVG9Ec3QpXG4gICAgaWYgKGV4aXN0cykge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgJ3RvQ3dkJzogcmVsYXRpdmVUb0RzdCxcbiAgICAgICAgJ3RvRHN0Jzogc3JjcGF0aFxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBleGlzdHMgPSBmcy5leGlzdHNTeW5jKHNyY3BhdGgpXG4gICAgICBpZiAoIWV4aXN0cykgdGhyb3cgbmV3IEVycm9yKCdyZWxhdGl2ZSBzcmNwYXRoIGRvZXMgbm90IGV4aXN0JylcbiAgICAgIHJldHVybiB7XG4gICAgICAgICd0b0N3ZCc6IHNyY3BhdGgsXG4gICAgICAgICd0b0RzdCc6IHBhdGgucmVsYXRpdmUoZHN0ZGlyLCBzcmNwYXRoKVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc3ltbGlua1BhdGhzLFxuICBzeW1saW5rUGF0aHNTeW5jXG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/fs-extra/lib/ensure/symlink-paths.js\n");

/***/ }),

/***/ "./node_modules/fs-extra/lib/ensure/symlink-type.js":
/*!**********************************************************!*\
  !*** ./node_modules/fs-extra/lib/ensure/symlink-type.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst fs = __webpack_require__(/*! graceful-fs */ \"./node_modules/graceful-fs/graceful-fs.js\")\n\nfunction symlinkType (srcpath, type, callback) {\n  callback = (typeof type === 'function') ? type : callback\n  type = (typeof type === 'function') ? false : type\n  if (type) return callback(null, type)\n  fs.lstat(srcpath, (err, stats) => {\n    if (err) return callback(null, 'file')\n    type = (stats && stats.isDirectory()) ? 'dir' : 'file'\n    callback(null, type)\n  })\n}\n\nfunction symlinkTypeSync (srcpath, type) {\n  let stats\n\n  if (type) return type\n  try {\n    stats = fs.lstatSync(srcpath)\n  } catch (e) {\n    return 'file'\n  }\n  return (stats && stats.isDirectory()) ? 'dir' : 'file'\n}\n\nmodule.exports = {\n  symlinkType,\n  symlinkTypeSync\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL2Vuc3VyZS9zeW1saW5rLXR5cGUuanMuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosV0FBVyxtQkFBTyxDQUFDLDhEQUFhOztBQUVoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdG9kby1saXN0Ly4vbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi9lbnN1cmUvc3ltbGluay10eXBlLmpzPzNhNTEiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGZzID0gcmVxdWlyZSgnZ3JhY2VmdWwtZnMnKVxuXG5mdW5jdGlvbiBzeW1saW5rVHlwZSAoc3JjcGF0aCwgdHlwZSwgY2FsbGJhY2spIHtcbiAgY2FsbGJhY2sgPSAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpID8gdHlwZSA6IGNhbGxiYWNrXG4gIHR5cGUgPSAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpID8gZmFsc2UgOiB0eXBlXG4gIGlmICh0eXBlKSByZXR1cm4gY2FsbGJhY2sobnVsbCwgdHlwZSlcbiAgZnMubHN0YXQoc3JjcGF0aCwgKGVyciwgc3RhdHMpID0+IHtcbiAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2sobnVsbCwgJ2ZpbGUnKVxuICAgIHR5cGUgPSAoc3RhdHMgJiYgc3RhdHMuaXNEaXJlY3RvcnkoKSkgPyAnZGlyJyA6ICdmaWxlJ1xuICAgIGNhbGxiYWNrKG51bGwsIHR5cGUpXG4gIH0pXG59XG5cbmZ1bmN0aW9uIHN5bWxpbmtUeXBlU3luYyAoc3JjcGF0aCwgdHlwZSkge1xuICBsZXQgc3RhdHNcblxuICBpZiAodHlwZSkgcmV0dXJuIHR5cGVcbiAgdHJ5IHtcbiAgICBzdGF0cyA9IGZzLmxzdGF0U3luYyhzcmNwYXRoKVxuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuICdmaWxlJ1xuICB9XG4gIHJldHVybiAoc3RhdHMgJiYgc3RhdHMuaXNEaXJlY3RvcnkoKSkgPyAnZGlyJyA6ICdmaWxlJ1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc3ltbGlua1R5cGUsXG4gIHN5bWxpbmtUeXBlU3luY1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/fs-extra/lib/ensure/symlink-type.js\n");

/***/ }),

/***/ "./node_modules/fs-extra/lib/ensure/symlink.js":
/*!*****************************************************!*\
  !*** ./node_modules/fs-extra/lib/ensure/symlink.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst u = (__webpack_require__(/*! universalify */ \"./node_modules/universalify/index.js\").fromCallback)\nconst path = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'path'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()))\nconst fs = __webpack_require__(/*! graceful-fs */ \"./node_modules/graceful-fs/graceful-fs.js\")\nconst _mkdirs = __webpack_require__(/*! ../mkdirs */ \"./node_modules/fs-extra/lib/mkdirs/index.js\")\nconst mkdirs = _mkdirs.mkdirs\nconst mkdirsSync = _mkdirs.mkdirsSync\n\nconst _symlinkPaths = __webpack_require__(/*! ./symlink-paths */ \"./node_modules/fs-extra/lib/ensure/symlink-paths.js\")\nconst symlinkPaths = _symlinkPaths.symlinkPaths\nconst symlinkPathsSync = _symlinkPaths.symlinkPathsSync\n\nconst _symlinkType = __webpack_require__(/*! ./symlink-type */ \"./node_modules/fs-extra/lib/ensure/symlink-type.js\")\nconst symlinkType = _symlinkType.symlinkType\nconst symlinkTypeSync = _symlinkType.symlinkTypeSync\n\nconst pathExists = (__webpack_require__(/*! ../path-exists */ \"./node_modules/fs-extra/lib/path-exists/index.js\").pathExists)\n\nfunction createSymlink (srcpath, dstpath, type, callback) {\n  callback = (typeof type === 'function') ? type : callback\n  type = (typeof type === 'function') ? false : type\n\n  pathExists(dstpath, (err, destinationExists) => {\n    if (err) return callback(err)\n    if (destinationExists) return callback(null)\n    symlinkPaths(srcpath, dstpath, (err, relative) => {\n      if (err) return callback(err)\n      srcpath = relative.toDst\n      symlinkType(relative.toCwd, type, (err, type) => {\n        if (err) return callback(err)\n        const dir = path.dirname(dstpath)\n        pathExists(dir, (err, dirExists) => {\n          if (err) return callback(err)\n          if (dirExists) return fs.symlink(srcpath, dstpath, type, callback)\n          mkdirs(dir, err => {\n            if (err) return callback(err)\n            fs.symlink(srcpath, dstpath, type, callback)\n          })\n        })\n      })\n    })\n  })\n}\n\nfunction createSymlinkSync (srcpath, dstpath, type) {\n  const destinationExists = fs.existsSync(dstpath)\n  if (destinationExists) return undefined\n\n  const relative = symlinkPathsSync(srcpath, dstpath)\n  srcpath = relative.toDst\n  type = symlinkTypeSync(relative.toCwd, type)\n  const dir = path.dirname(dstpath)\n  const exists = fs.existsSync(dir)\n  if (exists) return fs.symlinkSync(srcpath, dstpath, type)\n  mkdirsSync(dir)\n  return fs.symlinkSync(srcpath, dstpath, type)\n}\n\nmodule.exports = {\n  createSymlink: u(createSymlink),\n  createSymlinkSync\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL2Vuc3VyZS9zeW1saW5rLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLFVBQVUsOEZBQW9DO0FBQzlDLGFBQWEsbUJBQU8sQ0FBQyxtSUFBTTtBQUMzQixXQUFXLG1CQUFPLENBQUMsOERBQWE7QUFDaEMsZ0JBQWdCLG1CQUFPLENBQUMsOERBQVc7QUFDbkM7QUFDQTs7QUFFQSxzQkFBc0IsbUJBQU8sQ0FBQyw0RUFBaUI7QUFDL0M7QUFDQTs7QUFFQSxxQkFBcUIsbUJBQU8sQ0FBQywwRUFBZ0I7QUFDN0M7QUFDQTs7QUFFQSxtQkFBbUIsMEdBQW9DOztBQUV2RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVCxPQUFPO0FBQ1AsS0FBSztBQUNMLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdG9kby1saXN0Ly4vbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi9lbnN1cmUvc3ltbGluay5qcz9jY2Q2Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB1ID0gcmVxdWlyZSgndW5pdmVyc2FsaWZ5JykuZnJvbUNhbGxiYWNrXG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpXG5jb25zdCBmcyA9IHJlcXVpcmUoJ2dyYWNlZnVsLWZzJylcbmNvbnN0IF9ta2RpcnMgPSByZXF1aXJlKCcuLi9ta2RpcnMnKVxuY29uc3QgbWtkaXJzID0gX21rZGlycy5ta2RpcnNcbmNvbnN0IG1rZGlyc1N5bmMgPSBfbWtkaXJzLm1rZGlyc1N5bmNcblxuY29uc3QgX3N5bWxpbmtQYXRocyA9IHJlcXVpcmUoJy4vc3ltbGluay1wYXRocycpXG5jb25zdCBzeW1saW5rUGF0aHMgPSBfc3ltbGlua1BhdGhzLnN5bWxpbmtQYXRoc1xuY29uc3Qgc3ltbGlua1BhdGhzU3luYyA9IF9zeW1saW5rUGF0aHMuc3ltbGlua1BhdGhzU3luY1xuXG5jb25zdCBfc3ltbGlua1R5cGUgPSByZXF1aXJlKCcuL3N5bWxpbmstdHlwZScpXG5jb25zdCBzeW1saW5rVHlwZSA9IF9zeW1saW5rVHlwZS5zeW1saW5rVHlwZVxuY29uc3Qgc3ltbGlua1R5cGVTeW5jID0gX3N5bWxpbmtUeXBlLnN5bWxpbmtUeXBlU3luY1xuXG5jb25zdCBwYXRoRXhpc3RzID0gcmVxdWlyZSgnLi4vcGF0aC1leGlzdHMnKS5wYXRoRXhpc3RzXG5cbmZ1bmN0aW9uIGNyZWF0ZVN5bWxpbmsgKHNyY3BhdGgsIGRzdHBhdGgsIHR5cGUsIGNhbGxiYWNrKSB7XG4gIGNhbGxiYWNrID0gKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSA/IHR5cGUgOiBjYWxsYmFja1xuICB0eXBlID0gKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSA/IGZhbHNlIDogdHlwZVxuXG4gIHBhdGhFeGlzdHMoZHN0cGF0aCwgKGVyciwgZGVzdGluYXRpb25FeGlzdHMpID0+IHtcbiAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKVxuICAgIGlmIChkZXN0aW5hdGlvbkV4aXN0cykgcmV0dXJuIGNhbGxiYWNrKG51bGwpXG4gICAgc3ltbGlua1BhdGhzKHNyY3BhdGgsIGRzdHBhdGgsIChlcnIsIHJlbGF0aXZlKSA9PiB7XG4gICAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKVxuICAgICAgc3JjcGF0aCA9IHJlbGF0aXZlLnRvRHN0XG4gICAgICBzeW1saW5rVHlwZShyZWxhdGl2ZS50b0N3ZCwgdHlwZSwgKGVyciwgdHlwZSkgPT4ge1xuICAgICAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKVxuICAgICAgICBjb25zdCBkaXIgPSBwYXRoLmRpcm5hbWUoZHN0cGF0aClcbiAgICAgICAgcGF0aEV4aXN0cyhkaXIsIChlcnIsIGRpckV4aXN0cykgPT4ge1xuICAgICAgICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgICAgICAgaWYgKGRpckV4aXN0cykgcmV0dXJuIGZzLnN5bWxpbmsoc3JjcGF0aCwgZHN0cGF0aCwgdHlwZSwgY2FsbGJhY2spXG4gICAgICAgICAgbWtkaXJzKGRpciwgZXJyID0+IHtcbiAgICAgICAgICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgICAgICAgICBmcy5zeW1saW5rKHNyY3BhdGgsIGRzdHBhdGgsIHR5cGUsIGNhbGxiYWNrKVxuICAgICAgICAgIH0pXG4gICAgICAgIH0pXG4gICAgICB9KVxuICAgIH0pXG4gIH0pXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVN5bWxpbmtTeW5jIChzcmNwYXRoLCBkc3RwYXRoLCB0eXBlKSB7XG4gIGNvbnN0IGRlc3RpbmF0aW9uRXhpc3RzID0gZnMuZXhpc3RzU3luYyhkc3RwYXRoKVxuICBpZiAoZGVzdGluYXRpb25FeGlzdHMpIHJldHVybiB1bmRlZmluZWRcblxuICBjb25zdCByZWxhdGl2ZSA9IHN5bWxpbmtQYXRoc1N5bmMoc3JjcGF0aCwgZHN0cGF0aClcbiAgc3JjcGF0aCA9IHJlbGF0aXZlLnRvRHN0XG4gIHR5cGUgPSBzeW1saW5rVHlwZVN5bmMocmVsYXRpdmUudG9Dd2QsIHR5cGUpXG4gIGNvbnN0IGRpciA9IHBhdGguZGlybmFtZShkc3RwYXRoKVxuICBjb25zdCBleGlzdHMgPSBmcy5leGlzdHNTeW5jKGRpcilcbiAgaWYgKGV4aXN0cykgcmV0dXJuIGZzLnN5bWxpbmtTeW5jKHNyY3BhdGgsIGRzdHBhdGgsIHR5cGUpXG4gIG1rZGlyc1N5bmMoZGlyKVxuICByZXR1cm4gZnMuc3ltbGlua1N5bmMoc3JjcGF0aCwgZHN0cGF0aCwgdHlwZSlcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGNyZWF0ZVN5bWxpbms6IHUoY3JlYXRlU3ltbGluayksXG4gIGNyZWF0ZVN5bWxpbmtTeW5jXG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/fs-extra/lib/ensure/symlink.js\n");

/***/ }),

/***/ "./node_modules/fs-extra/lib/fs/index.js":
/*!***********************************************!*\
  !*** ./node_modules/fs-extra/lib/fs/index.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n// This is adapted from https://github.com/normalize/mz\n// Copyright (c) 2014-2016 Jonathan Ong me@jongleberry.com and Contributors\nconst u = (__webpack_require__(/*! universalify */ \"./node_modules/universalify/index.js\").fromCallback)\nconst fs = __webpack_require__(/*! graceful-fs */ \"./node_modules/graceful-fs/graceful-fs.js\")\n\nconst api = [\n  'access',\n  'appendFile',\n  'chmod',\n  'chown',\n  'close',\n  'copyFile',\n  'fchmod',\n  'fchown',\n  'fdatasync',\n  'fstat',\n  'fsync',\n  'ftruncate',\n  'futimes',\n  'lchown',\n  'lchmod',\n  'link',\n  'lstat',\n  'mkdir',\n  'mkdtemp',\n  'open',\n  'readFile',\n  'readdir',\n  'readlink',\n  'realpath',\n  'rename',\n  'rmdir',\n  'stat',\n  'symlink',\n  'truncate',\n  'unlink',\n  'utimes',\n  'writeFile'\n].filter(key => {\n  // Some commands are not available on some systems. Ex:\n  // fs.copyFile was added in Node.js v8.5.0\n  // fs.mkdtemp was added in Node.js v5.10.0\n  // fs.lchown is not available on at least some Linux\n  return typeof fs[key] === 'function'\n})\n\n// Export all keys:\nObject.keys(fs).forEach(key => {\n  if (key === 'promises') {\n    // fs.promises is a getter property that triggers ExperimentalWarning\n    // Don't re-export it here, the getter is defined in \"lib/index.js\"\n    return\n  }\n  exports[key] = fs[key]\n})\n\n// Universalify async methods:\napi.forEach(method => {\n  exports[method] = u(fs[method])\n})\n\n// We differ from mz/fs in that we still ship the old, broken, fs.exists()\n// since we are a drop-in replacement for the native module\nexports.exists = function (filename, callback) {\n  if (typeof callback === 'function') {\n    return fs.exists(filename, callback)\n  }\n  return new Promise(resolve => {\n    return fs.exists(filename, resolve)\n  })\n}\n\n// fs.read() & fs.write need special treatment due to multiple callback args\n\nexports.read = function (fd, buffer, offset, length, position, callback) {\n  if (typeof callback === 'function') {\n    return fs.read(fd, buffer, offset, length, position, callback)\n  }\n  return new Promise((resolve, reject) => {\n    fs.read(fd, buffer, offset, length, position, (err, bytesRead, buffer) => {\n      if (err) return reject(err)\n      resolve({ bytesRead, buffer })\n    })\n  })\n}\n\n// Function signature can be\n// fs.write(fd, buffer[, offset[, length[, position]]], callback)\n// OR\n// fs.write(fd, string[, position[, encoding]], callback)\n// We need to handle both cases, so we use ...args\nexports.write = function (fd, buffer, ...args) {\n  if (typeof args[args.length - 1] === 'function') {\n    return fs.write(fd, buffer, ...args)\n  }\n\n  return new Promise((resolve, reject) => {\n    fs.write(fd, buffer, ...args, (err, bytesWritten, buffer) => {\n      if (err) return reject(err)\n      resolve({ bytesWritten, buffer })\n    })\n  })\n}\n\n// fs.realpath.native only available in Node v9.2+\nif (typeof fs.realpath.native === 'function') {\n  exports.realpath.native = u(fs.realpath.native)\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL2ZzL2luZGV4LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFZO0FBQ1o7QUFDQTtBQUNBLFVBQVUsOEZBQW9DO0FBQzlDLFdBQVcsbUJBQU8sQ0FBQyw4REFBYTs7QUFFaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTs7QUFFQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG1CQUFtQjtBQUNuQyxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixzQkFBc0I7QUFDdEMsS0FBSztBQUNMLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0EsRUFBRSx1QkFBdUI7QUFDekIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90b2RvLWxpc3QvLi9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL2ZzL2luZGV4LmpzP2VjMmYiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG4vLyBUaGlzIGlzIGFkYXB0ZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vbm9ybWFsaXplL216XG4vLyBDb3B5cmlnaHQgKGMpIDIwMTQtMjAxNiBKb25hdGhhbiBPbmcgbWVAam9uZ2xlYmVycnkuY29tIGFuZCBDb250cmlidXRvcnNcbmNvbnN0IHUgPSByZXF1aXJlKCd1bml2ZXJzYWxpZnknKS5mcm9tQ2FsbGJhY2tcbmNvbnN0IGZzID0gcmVxdWlyZSgnZ3JhY2VmdWwtZnMnKVxuXG5jb25zdCBhcGkgPSBbXG4gICdhY2Nlc3MnLFxuICAnYXBwZW5kRmlsZScsXG4gICdjaG1vZCcsXG4gICdjaG93bicsXG4gICdjbG9zZScsXG4gICdjb3B5RmlsZScsXG4gICdmY2htb2QnLFxuICAnZmNob3duJyxcbiAgJ2ZkYXRhc3luYycsXG4gICdmc3RhdCcsXG4gICdmc3luYycsXG4gICdmdHJ1bmNhdGUnLFxuICAnZnV0aW1lcycsXG4gICdsY2hvd24nLFxuICAnbGNobW9kJyxcbiAgJ2xpbmsnLFxuICAnbHN0YXQnLFxuICAnbWtkaXInLFxuICAnbWtkdGVtcCcsXG4gICdvcGVuJyxcbiAgJ3JlYWRGaWxlJyxcbiAgJ3JlYWRkaXInLFxuICAncmVhZGxpbmsnLFxuICAncmVhbHBhdGgnLFxuICAncmVuYW1lJyxcbiAgJ3JtZGlyJyxcbiAgJ3N0YXQnLFxuICAnc3ltbGluaycsXG4gICd0cnVuY2F0ZScsXG4gICd1bmxpbmsnLFxuICAndXRpbWVzJyxcbiAgJ3dyaXRlRmlsZSdcbl0uZmlsdGVyKGtleSA9PiB7XG4gIC8vIFNvbWUgY29tbWFuZHMgYXJlIG5vdCBhdmFpbGFibGUgb24gc29tZSBzeXN0ZW1zLiBFeDpcbiAgLy8gZnMuY29weUZpbGUgd2FzIGFkZGVkIGluIE5vZGUuanMgdjguNS4wXG4gIC8vIGZzLm1rZHRlbXAgd2FzIGFkZGVkIGluIE5vZGUuanMgdjUuMTAuMFxuICAvLyBmcy5sY2hvd24gaXMgbm90IGF2YWlsYWJsZSBvbiBhdCBsZWFzdCBzb21lIExpbnV4XG4gIHJldHVybiB0eXBlb2YgZnNba2V5XSA9PT0gJ2Z1bmN0aW9uJ1xufSlcblxuLy8gRXhwb3J0IGFsbCBrZXlzOlxuT2JqZWN0LmtleXMoZnMpLmZvckVhY2goa2V5ID0+IHtcbiAgaWYgKGtleSA9PT0gJ3Byb21pc2VzJykge1xuICAgIC8vIGZzLnByb21pc2VzIGlzIGEgZ2V0dGVyIHByb3BlcnR5IHRoYXQgdHJpZ2dlcnMgRXhwZXJpbWVudGFsV2FybmluZ1xuICAgIC8vIERvbid0IHJlLWV4cG9ydCBpdCBoZXJlLCB0aGUgZ2V0dGVyIGlzIGRlZmluZWQgaW4gXCJsaWIvaW5kZXguanNcIlxuICAgIHJldHVyblxuICB9XG4gIGV4cG9ydHNba2V5XSA9IGZzW2tleV1cbn0pXG5cbi8vIFVuaXZlcnNhbGlmeSBhc3luYyBtZXRob2RzOlxuYXBpLmZvckVhY2gobWV0aG9kID0+IHtcbiAgZXhwb3J0c1ttZXRob2RdID0gdShmc1ttZXRob2RdKVxufSlcblxuLy8gV2UgZGlmZmVyIGZyb20gbXovZnMgaW4gdGhhdCB3ZSBzdGlsbCBzaGlwIHRoZSBvbGQsIGJyb2tlbiwgZnMuZXhpc3RzKClcbi8vIHNpbmNlIHdlIGFyZSBhIGRyb3AtaW4gcmVwbGFjZW1lbnQgZm9yIHRoZSBuYXRpdmUgbW9kdWxlXG5leHBvcnRzLmV4aXN0cyA9IGZ1bmN0aW9uIChmaWxlbmFtZSwgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBmcy5leGlzdHMoZmlsZW5hbWUsIGNhbGxiYWNrKVxuICB9XG4gIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICByZXR1cm4gZnMuZXhpc3RzKGZpbGVuYW1lLCByZXNvbHZlKVxuICB9KVxufVxuXG4vLyBmcy5yZWFkKCkgJiBmcy53cml0ZSBuZWVkIHNwZWNpYWwgdHJlYXRtZW50IGR1ZSB0byBtdWx0aXBsZSBjYWxsYmFjayBhcmdzXG5cbmV4cG9ydHMucmVhZCA9IGZ1bmN0aW9uIChmZCwgYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCwgcG9zaXRpb24sIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZnMucmVhZChmZCwgYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCwgcG9zaXRpb24sIGNhbGxiYWNrKVxuICB9XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgZnMucmVhZChmZCwgYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCwgcG9zaXRpb24sIChlcnIsIGJ5dGVzUmVhZCwgYnVmZmVyKSA9PiB7XG4gICAgICBpZiAoZXJyKSByZXR1cm4gcmVqZWN0KGVycilcbiAgICAgIHJlc29sdmUoeyBieXRlc1JlYWQsIGJ1ZmZlciB9KVxuICAgIH0pXG4gIH0pXG59XG5cbi8vIEZ1bmN0aW9uIHNpZ25hdHVyZSBjYW4gYmVcbi8vIGZzLndyaXRlKGZkLCBidWZmZXJbLCBvZmZzZXRbLCBsZW5ndGhbLCBwb3NpdGlvbl1dXSwgY2FsbGJhY2spXG4vLyBPUlxuLy8gZnMud3JpdGUoZmQsIHN0cmluZ1ssIHBvc2l0aW9uWywgZW5jb2RpbmddXSwgY2FsbGJhY2spXG4vLyBXZSBuZWVkIHRvIGhhbmRsZSBib3RoIGNhc2VzLCBzbyB3ZSB1c2UgLi4uYXJnc1xuZXhwb3J0cy53cml0ZSA9IGZ1bmN0aW9uIChmZCwgYnVmZmVyLCAuLi5hcmdzKSB7XG4gIGlmICh0eXBlb2YgYXJnc1thcmdzLmxlbmd0aCAtIDFdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGZzLndyaXRlKGZkLCBidWZmZXIsIC4uLmFyZ3MpXG4gIH1cblxuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGZzLndyaXRlKGZkLCBidWZmZXIsIC4uLmFyZ3MsIChlcnIsIGJ5dGVzV3JpdHRlbiwgYnVmZmVyKSA9PiB7XG4gICAgICBpZiAoZXJyKSByZXR1cm4gcmVqZWN0KGVycilcbiAgICAgIHJlc29sdmUoeyBieXRlc1dyaXR0ZW4sIGJ1ZmZlciB9KVxuICAgIH0pXG4gIH0pXG59XG5cbi8vIGZzLnJlYWxwYXRoLm5hdGl2ZSBvbmx5IGF2YWlsYWJsZSBpbiBOb2RlIHY5LjIrXG5pZiAodHlwZW9mIGZzLnJlYWxwYXRoLm5hdGl2ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICBleHBvcnRzLnJlYWxwYXRoLm5hdGl2ZSA9IHUoZnMucmVhbHBhdGgubmF0aXZlKVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/fs-extra/lib/fs/index.js\n");

/***/ }),

/***/ "./node_modules/fs-extra/lib/index.js":
/*!********************************************!*\
  !*** ./node_modules/fs-extra/lib/index.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nmodule.exports = Object.assign(\n  {},\n  // Export promiseified graceful-fs:\n  __webpack_require__(/*! ./fs */ \"./node_modules/fs-extra/lib/fs/index.js\"),\n  // Export extra methods:\n  __webpack_require__(/*! ./copy-sync */ \"./node_modules/fs-extra/lib/copy-sync/index.js\"),\n  __webpack_require__(/*! ./copy */ \"./node_modules/fs-extra/lib/copy/index.js\"),\n  __webpack_require__(/*! ./empty */ \"./node_modules/fs-extra/lib/empty/index.js\"),\n  __webpack_require__(/*! ./ensure */ \"./node_modules/fs-extra/lib/ensure/index.js\"),\n  __webpack_require__(/*! ./json */ \"./node_modules/fs-extra/lib/json/index.js\"),\n  __webpack_require__(/*! ./mkdirs */ \"./node_modules/fs-extra/lib/mkdirs/index.js\"),\n  __webpack_require__(/*! ./move-sync */ \"./node_modules/fs-extra/lib/move-sync/index.js\"),\n  __webpack_require__(/*! ./move */ \"./node_modules/fs-extra/lib/move/index.js\"),\n  __webpack_require__(/*! ./output */ \"./node_modules/fs-extra/lib/output/index.js\"),\n  __webpack_require__(/*! ./path-exists */ \"./node_modules/fs-extra/lib/path-exists/index.js\"),\n  __webpack_require__(/*! ./remove */ \"./node_modules/fs-extra/lib/remove/index.js\")\n)\n\n// Export fs.promises as a getter property so that we don't trigger\n// ExperimentalWarning before fs.promises is actually accessed.\nconst fs = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'fs'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()))\nif (Object.getOwnPropertyDescriptor(fs, 'promises')) {\n  Object.defineProperty(module.exports, \"promises\", ({\n    get () { return fs.promises }\n  }))\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL2luZGV4LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsRUFBRSxtQkFBTyxDQUFDLHFEQUFNO0FBQ2hCO0FBQ0EsRUFBRSxtQkFBTyxDQUFDLG1FQUFhO0FBQ3ZCLEVBQUUsbUJBQU8sQ0FBQyx5REFBUTtBQUNsQixFQUFFLG1CQUFPLENBQUMsMkRBQVM7QUFDbkIsRUFBRSxtQkFBTyxDQUFDLDZEQUFVO0FBQ3BCLEVBQUUsbUJBQU8sQ0FBQyx5REFBUTtBQUNsQixFQUFFLG1CQUFPLENBQUMsNkRBQVU7QUFDcEIsRUFBRSxtQkFBTyxDQUFDLG1FQUFhO0FBQ3ZCLEVBQUUsbUJBQU8sQ0FBQyx5REFBUTtBQUNsQixFQUFFLG1CQUFPLENBQUMsNkRBQVU7QUFDcEIsRUFBRSxtQkFBTyxDQUFDLHVFQUFlO0FBQ3pCLEVBQUUsbUJBQU8sQ0FBQyw2REFBVTtBQUNwQjs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxtQkFBTyxDQUFDLGlJQUFJO0FBQ3ZCO0FBQ0EsRUFBRSxtREFBa0Q7QUFDcEQsYUFBYTtBQUNiLEdBQUcsRUFBQztBQUNKIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdG9kby1saXN0Ly4vbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi9pbmRleC5qcz84M2VmIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5hc3NpZ24oXG4gIHt9LFxuICAvLyBFeHBvcnQgcHJvbWlzZWlmaWVkIGdyYWNlZnVsLWZzOlxuICByZXF1aXJlKCcuL2ZzJyksXG4gIC8vIEV4cG9ydCBleHRyYSBtZXRob2RzOlxuICByZXF1aXJlKCcuL2NvcHktc3luYycpLFxuICByZXF1aXJlKCcuL2NvcHknKSxcbiAgcmVxdWlyZSgnLi9lbXB0eScpLFxuICByZXF1aXJlKCcuL2Vuc3VyZScpLFxuICByZXF1aXJlKCcuL2pzb24nKSxcbiAgcmVxdWlyZSgnLi9ta2RpcnMnKSxcbiAgcmVxdWlyZSgnLi9tb3ZlLXN5bmMnKSxcbiAgcmVxdWlyZSgnLi9tb3ZlJyksXG4gIHJlcXVpcmUoJy4vb3V0cHV0JyksXG4gIHJlcXVpcmUoJy4vcGF0aC1leGlzdHMnKSxcbiAgcmVxdWlyZSgnLi9yZW1vdmUnKVxuKVxuXG4vLyBFeHBvcnQgZnMucHJvbWlzZXMgYXMgYSBnZXR0ZXIgcHJvcGVydHkgc28gdGhhdCB3ZSBkb24ndCB0cmlnZ2VyXG4vLyBFeHBlcmltZW50YWxXYXJuaW5nIGJlZm9yZSBmcy5wcm9taXNlcyBpcyBhY3R1YWxseSBhY2Nlc3NlZC5cbmNvbnN0IGZzID0gcmVxdWlyZSgnZnMnKVxuaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZnMsICdwcm9taXNlcycpKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUuZXhwb3J0cywgJ3Byb21pc2VzJywge1xuICAgIGdldCAoKSB7IHJldHVybiBmcy5wcm9taXNlcyB9XG4gIH0pXG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/fs-extra/lib/index.js\n");

/***/ }),

/***/ "./node_modules/fs-extra/lib/json/index.js":
/*!*************************************************!*\
  !*** ./node_modules/fs-extra/lib/json/index.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst u = (__webpack_require__(/*! universalify */ \"./node_modules/universalify/index.js\").fromCallback)\nconst jsonFile = __webpack_require__(/*! ./jsonfile */ \"./node_modules/fs-extra/lib/json/jsonfile.js\")\n\njsonFile.outputJson = u(__webpack_require__(/*! ./output-json */ \"./node_modules/fs-extra/lib/json/output-json.js\"))\njsonFile.outputJsonSync = __webpack_require__(/*! ./output-json-sync */ \"./node_modules/fs-extra/lib/json/output-json-sync.js\")\n// aliases\njsonFile.outputJSON = jsonFile.outputJson\njsonFile.outputJSONSync = jsonFile.outputJsonSync\njsonFile.writeJSON = jsonFile.writeJson\njsonFile.writeJSONSync = jsonFile.writeJsonSync\njsonFile.readJSON = jsonFile.readJson\njsonFile.readJSONSync = jsonFile.readJsonSync\n\nmodule.exports = jsonFile\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL2pzb24vaW5kZXguanMuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosVUFBVSw4RkFBb0M7QUFDOUMsaUJBQWlCLG1CQUFPLENBQUMsZ0VBQVk7O0FBRXJDLHdCQUF3QixtQkFBTyxDQUFDLHNFQUFlO0FBQy9DLDBCQUEwQixtQkFBTyxDQUFDLGdGQUFvQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3RvZG8tbGlzdC8uL25vZGVfbW9kdWxlcy9mcy1leHRyYS9saWIvanNvbi9pbmRleC5qcz8wOTNmIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB1ID0gcmVxdWlyZSgndW5pdmVyc2FsaWZ5JykuZnJvbUNhbGxiYWNrXG5jb25zdCBqc29uRmlsZSA9IHJlcXVpcmUoJy4vanNvbmZpbGUnKVxuXG5qc29uRmlsZS5vdXRwdXRKc29uID0gdShyZXF1aXJlKCcuL291dHB1dC1qc29uJykpXG5qc29uRmlsZS5vdXRwdXRKc29uU3luYyA9IHJlcXVpcmUoJy4vb3V0cHV0LWpzb24tc3luYycpXG4vLyBhbGlhc2VzXG5qc29uRmlsZS5vdXRwdXRKU09OID0ganNvbkZpbGUub3V0cHV0SnNvblxuanNvbkZpbGUub3V0cHV0SlNPTlN5bmMgPSBqc29uRmlsZS5vdXRwdXRKc29uU3luY1xuanNvbkZpbGUud3JpdGVKU09OID0ganNvbkZpbGUud3JpdGVKc29uXG5qc29uRmlsZS53cml0ZUpTT05TeW5jID0ganNvbkZpbGUud3JpdGVKc29uU3luY1xuanNvbkZpbGUucmVhZEpTT04gPSBqc29uRmlsZS5yZWFkSnNvblxuanNvbkZpbGUucmVhZEpTT05TeW5jID0ganNvbkZpbGUucmVhZEpzb25TeW5jXG5cbm1vZHVsZS5leHBvcnRzID0ganNvbkZpbGVcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/fs-extra/lib/json/index.js\n");

/***/ }),

/***/ "./node_modules/fs-extra/lib/json/jsonfile.js":
/*!****************************************************!*\
  !*** ./node_modules/fs-extra/lib/json/jsonfile.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst u = (__webpack_require__(/*! universalify */ \"./node_modules/universalify/index.js\").fromCallback)\nconst jsonFile = __webpack_require__(/*! jsonfile */ \"./node_modules/jsonfile/index.js\")\n\nmodule.exports = {\n  // jsonfile exports\n  readJson: u(jsonFile.readFile),\n  readJsonSync: jsonFile.readFileSync,\n  writeJson: u(jsonFile.writeFile),\n  writeJsonSync: jsonFile.writeFileSync\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL2pzb24vanNvbmZpbGUuanMuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosVUFBVSw4RkFBb0M7QUFDOUMsaUJBQWlCLG1CQUFPLENBQUMsa0RBQVU7O0FBRW5DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdG9kby1saXN0Ly4vbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi9qc29uL2pzb25maWxlLmpzPzhjNjMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHUgPSByZXF1aXJlKCd1bml2ZXJzYWxpZnknKS5mcm9tQ2FsbGJhY2tcbmNvbnN0IGpzb25GaWxlID0gcmVxdWlyZSgnanNvbmZpbGUnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgLy8ganNvbmZpbGUgZXhwb3J0c1xuICByZWFkSnNvbjogdShqc29uRmlsZS5yZWFkRmlsZSksXG4gIHJlYWRKc29uU3luYzoganNvbkZpbGUucmVhZEZpbGVTeW5jLFxuICB3cml0ZUpzb246IHUoanNvbkZpbGUud3JpdGVGaWxlKSxcbiAgd3JpdGVKc29uU3luYzoganNvbkZpbGUud3JpdGVGaWxlU3luY1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/fs-extra/lib/json/jsonfile.js\n");

/***/ }),

/***/ "./node_modules/fs-extra/lib/json/output-json-sync.js":
/*!************************************************************!*\
  !*** ./node_modules/fs-extra/lib/json/output-json-sync.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst fs = __webpack_require__(/*! graceful-fs */ \"./node_modules/graceful-fs/graceful-fs.js\")\nconst path = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'path'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()))\nconst mkdir = __webpack_require__(/*! ../mkdirs */ \"./node_modules/fs-extra/lib/mkdirs/index.js\")\nconst jsonFile = __webpack_require__(/*! ./jsonfile */ \"./node_modules/fs-extra/lib/json/jsonfile.js\")\n\nfunction outputJsonSync (file, data, options) {\n  const dir = path.dirname(file)\n\n  if (!fs.existsSync(dir)) {\n    mkdir.mkdirsSync(dir)\n  }\n\n  jsonFile.writeJsonSync(file, data, options)\n}\n\nmodule.exports = outputJsonSync\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL2pzb24vb3V0cHV0LWpzb24tc3luYy5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixXQUFXLG1CQUFPLENBQUMsOERBQWE7QUFDaEMsYUFBYSxtQkFBTyxDQUFDLG1JQUFNO0FBQzNCLGNBQWMsbUJBQU8sQ0FBQyw4REFBVztBQUNqQyxpQkFBaUIsbUJBQU8sQ0FBQyxnRUFBWTs7QUFFckM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3RvZG8tbGlzdC8uL25vZGVfbW9kdWxlcy9mcy1leHRyYS9saWIvanNvbi9vdXRwdXQtanNvbi1zeW5jLmpzPzMwYjMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGZzID0gcmVxdWlyZSgnZ3JhY2VmdWwtZnMnKVxuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKVxuY29uc3QgbWtkaXIgPSByZXF1aXJlKCcuLi9ta2RpcnMnKVxuY29uc3QganNvbkZpbGUgPSByZXF1aXJlKCcuL2pzb25maWxlJylcblxuZnVuY3Rpb24gb3V0cHV0SnNvblN5bmMgKGZpbGUsIGRhdGEsIG9wdGlvbnMpIHtcbiAgY29uc3QgZGlyID0gcGF0aC5kaXJuYW1lKGZpbGUpXG5cbiAgaWYgKCFmcy5leGlzdHNTeW5jKGRpcikpIHtcbiAgICBta2Rpci5ta2RpcnNTeW5jKGRpcilcbiAgfVxuXG4gIGpzb25GaWxlLndyaXRlSnNvblN5bmMoZmlsZSwgZGF0YSwgb3B0aW9ucylcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBvdXRwdXRKc29uU3luY1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/fs-extra/lib/json/output-json-sync.js\n");

/***/ }),

/***/ "./node_modules/fs-extra/lib/json/output-json.js":
/*!*******************************************************!*\
  !*** ./node_modules/fs-extra/lib/json/output-json.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst path = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'path'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()))\nconst mkdir = __webpack_require__(/*! ../mkdirs */ \"./node_modules/fs-extra/lib/mkdirs/index.js\")\nconst pathExists = (__webpack_require__(/*! ../path-exists */ \"./node_modules/fs-extra/lib/path-exists/index.js\").pathExists)\nconst jsonFile = __webpack_require__(/*! ./jsonfile */ \"./node_modules/fs-extra/lib/json/jsonfile.js\")\n\nfunction outputJson (file, data, options, callback) {\n  if (typeof options === 'function') {\n    callback = options\n    options = {}\n  }\n\n  const dir = path.dirname(file)\n\n  pathExists(dir, (err, itDoes) => {\n    if (err) return callback(err)\n    if (itDoes) return jsonFile.writeJson(file, data, options, callback)\n\n    mkdir.mkdirs(dir, err => {\n      if (err) return callback(err)\n      jsonFile.writeJson(file, data, options, callback)\n    })\n  })\n}\n\nmodule.exports = outputJson\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL2pzb24vb3V0cHV0LWpzb24uanMuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosYUFBYSxtQkFBTyxDQUFDLG1JQUFNO0FBQzNCLGNBQWMsbUJBQU8sQ0FBQyw4REFBVztBQUNqQyxtQkFBbUIsMEdBQW9DO0FBQ3ZELGlCQUFpQixtQkFBTyxDQUFDLGdFQUFZOztBQUVyQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdG9kby1saXN0Ly4vbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi9qc29uL291dHB1dC1qc29uLmpzP2JkY2EiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJylcbmNvbnN0IG1rZGlyID0gcmVxdWlyZSgnLi4vbWtkaXJzJylcbmNvbnN0IHBhdGhFeGlzdHMgPSByZXF1aXJlKCcuLi9wYXRoLWV4aXN0cycpLnBhdGhFeGlzdHNcbmNvbnN0IGpzb25GaWxlID0gcmVxdWlyZSgnLi9qc29uZmlsZScpXG5cbmZ1bmN0aW9uIG91dHB1dEpzb24gKGZpbGUsIGRhdGEsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gb3B0aW9uc1xuICAgIG9wdGlvbnMgPSB7fVxuICB9XG5cbiAgY29uc3QgZGlyID0gcGF0aC5kaXJuYW1lKGZpbGUpXG5cbiAgcGF0aEV4aXN0cyhkaXIsIChlcnIsIGl0RG9lcykgPT4ge1xuICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgaWYgKGl0RG9lcykgcmV0dXJuIGpzb25GaWxlLndyaXRlSnNvbihmaWxlLCBkYXRhLCBvcHRpb25zLCBjYWxsYmFjaylcblxuICAgIG1rZGlyLm1rZGlycyhkaXIsIGVyciA9PiB7XG4gICAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKVxuICAgICAganNvbkZpbGUud3JpdGVKc29uKGZpbGUsIGRhdGEsIG9wdGlvbnMsIGNhbGxiYWNrKVxuICAgIH0pXG4gIH0pXG59XG5cbm1vZHVsZS5leHBvcnRzID0gb3V0cHV0SnNvblxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/fs-extra/lib/json/output-json.js\n");

/***/ }),

/***/ "./node_modules/fs-extra/lib/mkdirs/index.js":
/*!***************************************************!*\
  !*** ./node_modules/fs-extra/lib/mkdirs/index.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst u = (__webpack_require__(/*! universalify */ \"./node_modules/universalify/index.js\").fromCallback)\nconst mkdirs = u(__webpack_require__(/*! ./mkdirs */ \"./node_modules/fs-extra/lib/mkdirs/mkdirs.js\"))\nconst mkdirsSync = __webpack_require__(/*! ./mkdirs-sync */ \"./node_modules/fs-extra/lib/mkdirs/mkdirs-sync.js\")\n\nmodule.exports = {\n  mkdirs,\n  mkdirsSync,\n  // alias\n  mkdirp: mkdirs,\n  mkdirpSync: mkdirsSync,\n  ensureDir: mkdirs,\n  ensureDirSync: mkdirsSync\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL21rZGlycy9pbmRleC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBWTtBQUNaLFVBQVUsOEZBQW9DO0FBQzlDLGlCQUFpQixtQkFBTyxDQUFDLDhEQUFVO0FBQ25DLG1CQUFtQixtQkFBTyxDQUFDLHdFQUFlOztBQUUxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90b2RvLWxpc3QvLi9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL21rZGlycy9pbmRleC5qcz9jZjIwIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuY29uc3QgdSA9IHJlcXVpcmUoJ3VuaXZlcnNhbGlmeScpLmZyb21DYWxsYmFja1xuY29uc3QgbWtkaXJzID0gdShyZXF1aXJlKCcuL21rZGlycycpKVxuY29uc3QgbWtkaXJzU3luYyA9IHJlcXVpcmUoJy4vbWtkaXJzLXN5bmMnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgbWtkaXJzLFxuICBta2RpcnNTeW5jLFxuICAvLyBhbGlhc1xuICBta2RpcnA6IG1rZGlycyxcbiAgbWtkaXJwU3luYzogbWtkaXJzU3luYyxcbiAgZW5zdXJlRGlyOiBta2RpcnMsXG4gIGVuc3VyZURpclN5bmM6IG1rZGlyc1N5bmNcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/fs-extra/lib/mkdirs/index.js\n");

/***/ }),

/***/ "./node_modules/fs-extra/lib/mkdirs/mkdirs-sync.js":
/*!*********************************************************!*\
  !*** ./node_modules/fs-extra/lib/mkdirs/mkdirs-sync.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst fs = __webpack_require__(/*! graceful-fs */ \"./node_modules/graceful-fs/graceful-fs.js\")\nconst path = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'path'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()))\nconst invalidWin32Path = (__webpack_require__(/*! ./win32 */ \"./node_modules/fs-extra/lib/mkdirs/win32.js\").invalidWin32Path)\n\nconst o777 = parseInt('0777', 8)\n\nfunction mkdirsSync (p, opts, made) {\n  if (!opts || typeof opts !== 'object') {\n    opts = { mode: opts }\n  }\n\n  let mode = opts.mode\n  const xfs = opts.fs || fs\n\n  if (process.platform === 'win32' && invalidWin32Path(p)) {\n    const errInval = new Error(p + ' contains invalid WIN32 path characters.')\n    errInval.code = 'EINVAL'\n    throw errInval\n  }\n\n  if (mode === undefined) {\n    mode = o777 & (~process.umask())\n  }\n  if (!made) made = null\n\n  p = path.resolve(p)\n\n  try {\n    xfs.mkdirSync(p, mode)\n    made = made || p\n  } catch (err0) {\n    if (err0.code === 'ENOENT') {\n      if (path.dirname(p) === p) throw err0\n      made = mkdirsSync(path.dirname(p), opts, made)\n      mkdirsSync(p, opts, made)\n    } else {\n      // In the case of any other error, just see if there's a dir there\n      // already. If so, then hooray!  If not, then something is borked.\n      let stat\n      try {\n        stat = xfs.statSync(p)\n      } catch (err1) {\n        throw err0\n      }\n      if (!stat.isDirectory()) throw err0\n    }\n  }\n\n  return made\n}\n\nmodule.exports = mkdirsSync\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL21rZGlycy9ta2RpcnMtc3luYy5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixXQUFXLG1CQUFPLENBQUMsOERBQWE7QUFDaEMsYUFBYSxtQkFBTyxDQUFDLG1JQUFNO0FBQzNCLHlCQUF5QixvR0FBbUM7O0FBRTVEOztBQUVBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3RvZG8tbGlzdC8uL25vZGVfbW9kdWxlcy9mcy1leHRyYS9saWIvbWtkaXJzL21rZGlycy1zeW5jLmpzP2ExNzgiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGZzID0gcmVxdWlyZSgnZ3JhY2VmdWwtZnMnKVxuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKVxuY29uc3QgaW52YWxpZFdpbjMyUGF0aCA9IHJlcXVpcmUoJy4vd2luMzInKS5pbnZhbGlkV2luMzJQYXRoXG5cbmNvbnN0IG83NzcgPSBwYXJzZUludCgnMDc3NycsIDgpXG5cbmZ1bmN0aW9uIG1rZGlyc1N5bmMgKHAsIG9wdHMsIG1hZGUpIHtcbiAgaWYgKCFvcHRzIHx8IHR5cGVvZiBvcHRzICE9PSAnb2JqZWN0Jykge1xuICAgIG9wdHMgPSB7IG1vZGU6IG9wdHMgfVxuICB9XG5cbiAgbGV0IG1vZGUgPSBvcHRzLm1vZGVcbiAgY29uc3QgeGZzID0gb3B0cy5mcyB8fCBmc1xuXG4gIGlmIChwcm9jZXNzLnBsYXRmb3JtID09PSAnd2luMzInICYmIGludmFsaWRXaW4zMlBhdGgocCkpIHtcbiAgICBjb25zdCBlcnJJbnZhbCA9IG5ldyBFcnJvcihwICsgJyBjb250YWlucyBpbnZhbGlkIFdJTjMyIHBhdGggY2hhcmFjdGVycy4nKVxuICAgIGVyckludmFsLmNvZGUgPSAnRUlOVkFMJ1xuICAgIHRocm93IGVyckludmFsXG4gIH1cblxuICBpZiAobW9kZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbW9kZSA9IG83NzcgJiAofnByb2Nlc3MudW1hc2soKSlcbiAgfVxuICBpZiAoIW1hZGUpIG1hZGUgPSBudWxsXG5cbiAgcCA9IHBhdGgucmVzb2x2ZShwKVxuXG4gIHRyeSB7XG4gICAgeGZzLm1rZGlyU3luYyhwLCBtb2RlKVxuICAgIG1hZGUgPSBtYWRlIHx8IHBcbiAgfSBjYXRjaCAoZXJyMCkge1xuICAgIGlmIChlcnIwLmNvZGUgPT09ICdFTk9FTlQnKSB7XG4gICAgICBpZiAocGF0aC5kaXJuYW1lKHApID09PSBwKSB0aHJvdyBlcnIwXG4gICAgICBtYWRlID0gbWtkaXJzU3luYyhwYXRoLmRpcm5hbWUocCksIG9wdHMsIG1hZGUpXG4gICAgICBta2RpcnNTeW5jKHAsIG9wdHMsIG1hZGUpXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEluIHRoZSBjYXNlIG9mIGFueSBvdGhlciBlcnJvciwganVzdCBzZWUgaWYgdGhlcmUncyBhIGRpciB0aGVyZVxuICAgICAgLy8gYWxyZWFkeS4gSWYgc28sIHRoZW4gaG9vcmF5ISAgSWYgbm90LCB0aGVuIHNvbWV0aGluZyBpcyBib3JrZWQuXG4gICAgICBsZXQgc3RhdFxuICAgICAgdHJ5IHtcbiAgICAgICAgc3RhdCA9IHhmcy5zdGF0U3luYyhwKVxuICAgICAgfSBjYXRjaCAoZXJyMSkge1xuICAgICAgICB0aHJvdyBlcnIwXG4gICAgICB9XG4gICAgICBpZiAoIXN0YXQuaXNEaXJlY3RvcnkoKSkgdGhyb3cgZXJyMFxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBtYWRlXG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWtkaXJzU3luY1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/fs-extra/lib/mkdirs/mkdirs-sync.js\n");

/***/ }),

/***/ "./node_modules/fs-extra/lib/mkdirs/mkdirs.js":
/*!****************************************************!*\
  !*** ./node_modules/fs-extra/lib/mkdirs/mkdirs.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst fs = __webpack_require__(/*! graceful-fs */ \"./node_modules/graceful-fs/graceful-fs.js\")\nconst path = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'path'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()))\nconst invalidWin32Path = (__webpack_require__(/*! ./win32 */ \"./node_modules/fs-extra/lib/mkdirs/win32.js\").invalidWin32Path)\n\nconst o777 = parseInt('0777', 8)\n\nfunction mkdirs (p, opts, callback, made) {\n  if (typeof opts === 'function') {\n    callback = opts\n    opts = {}\n  } else if (!opts || typeof opts !== 'object') {\n    opts = { mode: opts }\n  }\n\n  if (process.platform === 'win32' && invalidWin32Path(p)) {\n    const errInval = new Error(p + ' contains invalid WIN32 path characters.')\n    errInval.code = 'EINVAL'\n    return callback(errInval)\n  }\n\n  let mode = opts.mode\n  const xfs = opts.fs || fs\n\n  if (mode === undefined) {\n    mode = o777 & (~process.umask())\n  }\n  if (!made) made = null\n\n  callback = callback || function () {}\n  p = path.resolve(p)\n\n  xfs.mkdir(p, mode, er => {\n    if (!er) {\n      made = made || p\n      return callback(null, made)\n    }\n    switch (er.code) {\n      case 'ENOENT':\n        if (path.dirname(p) === p) return callback(er)\n        mkdirs(path.dirname(p), opts, (er, made) => {\n          if (er) callback(er, made)\n          else mkdirs(p, opts, callback, made)\n        })\n        break\n\n      // In the case of any other error, just see if there's a dir\n      // there already.  If so, then hooray!  If not, then something\n      // is borked.\n      default:\n        xfs.stat(p, (er2, stat) => {\n          // if the stat fails, then that's super weird.\n          // let the original error be the failure reason.\n          if (er2 || !stat.isDirectory()) callback(er, made)\n          else callback(null, made)\n        })\n        break\n    }\n  })\n}\n\nmodule.exports = mkdirs\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL21rZGlycy9ta2RpcnMuanMuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosV0FBVyxtQkFBTyxDQUFDLDhEQUFhO0FBQ2hDLGFBQWEsbUJBQU8sQ0FBQyxtSUFBTTtBQUMzQix5QkFBeUIsb0dBQW1DOztBQUU1RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3RvZG8tbGlzdC8uL25vZGVfbW9kdWxlcy9mcy1leHRyYS9saWIvbWtkaXJzL21rZGlycy5qcz82ODMzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBmcyA9IHJlcXVpcmUoJ2dyYWNlZnVsLWZzJylcbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJylcbmNvbnN0IGludmFsaWRXaW4zMlBhdGggPSByZXF1aXJlKCcuL3dpbjMyJykuaW52YWxpZFdpbjMyUGF0aFxuXG5jb25zdCBvNzc3ID0gcGFyc2VJbnQoJzA3NzcnLCA4KVxuXG5mdW5jdGlvbiBta2RpcnMgKHAsIG9wdHMsIGNhbGxiYWNrLCBtYWRlKSB7XG4gIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gb3B0c1xuICAgIG9wdHMgPSB7fVxuICB9IGVsc2UgaWYgKCFvcHRzIHx8IHR5cGVvZiBvcHRzICE9PSAnb2JqZWN0Jykge1xuICAgIG9wdHMgPSB7IG1vZGU6IG9wdHMgfVxuICB9XG5cbiAgaWYgKHByb2Nlc3MucGxhdGZvcm0gPT09ICd3aW4zMicgJiYgaW52YWxpZFdpbjMyUGF0aChwKSkge1xuICAgIGNvbnN0IGVyckludmFsID0gbmV3IEVycm9yKHAgKyAnIGNvbnRhaW5zIGludmFsaWQgV0lOMzIgcGF0aCBjaGFyYWN0ZXJzLicpXG4gICAgZXJySW52YWwuY29kZSA9ICdFSU5WQUwnXG4gICAgcmV0dXJuIGNhbGxiYWNrKGVyckludmFsKVxuICB9XG5cbiAgbGV0IG1vZGUgPSBvcHRzLm1vZGVcbiAgY29uc3QgeGZzID0gb3B0cy5mcyB8fCBmc1xuXG4gIGlmIChtb2RlID09PSB1bmRlZmluZWQpIHtcbiAgICBtb2RlID0gbzc3NyAmICh+cHJvY2Vzcy51bWFzaygpKVxuICB9XG4gIGlmICghbWFkZSkgbWFkZSA9IG51bGxcblxuICBjYWxsYmFjayA9IGNhbGxiYWNrIHx8IGZ1bmN0aW9uICgpIHt9XG4gIHAgPSBwYXRoLnJlc29sdmUocClcblxuICB4ZnMubWtkaXIocCwgbW9kZSwgZXIgPT4ge1xuICAgIGlmICghZXIpIHtcbiAgICAgIG1hZGUgPSBtYWRlIHx8IHBcbiAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCBtYWRlKVxuICAgIH1cbiAgICBzd2l0Y2ggKGVyLmNvZGUpIHtcbiAgICAgIGNhc2UgJ0VOT0VOVCc6XG4gICAgICAgIGlmIChwYXRoLmRpcm5hbWUocCkgPT09IHApIHJldHVybiBjYWxsYmFjayhlcilcbiAgICAgICAgbWtkaXJzKHBhdGguZGlybmFtZShwKSwgb3B0cywgKGVyLCBtYWRlKSA9PiB7XG4gICAgICAgICAgaWYgKGVyKSBjYWxsYmFjayhlciwgbWFkZSlcbiAgICAgICAgICBlbHNlIG1rZGlycyhwLCBvcHRzLCBjYWxsYmFjaywgbWFkZSlcbiAgICAgICAgfSlcbiAgICAgICAgYnJlYWtcblxuICAgICAgLy8gSW4gdGhlIGNhc2Ugb2YgYW55IG90aGVyIGVycm9yLCBqdXN0IHNlZSBpZiB0aGVyZSdzIGEgZGlyXG4gICAgICAvLyB0aGVyZSBhbHJlYWR5LiAgSWYgc28sIHRoZW4gaG9vcmF5ISAgSWYgbm90LCB0aGVuIHNvbWV0aGluZ1xuICAgICAgLy8gaXMgYm9ya2VkLlxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgeGZzLnN0YXQocCwgKGVyMiwgc3RhdCkgPT4ge1xuICAgICAgICAgIC8vIGlmIHRoZSBzdGF0IGZhaWxzLCB0aGVuIHRoYXQncyBzdXBlciB3ZWlyZC5cbiAgICAgICAgICAvLyBsZXQgdGhlIG9yaWdpbmFsIGVycm9yIGJlIHRoZSBmYWlsdXJlIHJlYXNvbi5cbiAgICAgICAgICBpZiAoZXIyIHx8ICFzdGF0LmlzRGlyZWN0b3J5KCkpIGNhbGxiYWNrKGVyLCBtYWRlKVxuICAgICAgICAgIGVsc2UgY2FsbGJhY2sobnVsbCwgbWFkZSlcbiAgICAgICAgfSlcbiAgICAgICAgYnJlYWtcbiAgICB9XG4gIH0pXG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWtkaXJzXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/fs-extra/lib/mkdirs/mkdirs.js\n");

/***/ }),

/***/ "./node_modules/fs-extra/lib/mkdirs/win32.js":
/*!***************************************************!*\
  !*** ./node_modules/fs-extra/lib/mkdirs/win32.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst path = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'path'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()))\n\n// get drive on windows\nfunction getRootPath (p) {\n  p = path.normalize(path.resolve(p)).split(path.sep)\n  if (p.length > 0) return p[0]\n  return null\n}\n\n// http://stackoverflow.com/a/62888/10333 contains more accurate\n// TODO: expand to include the rest\nconst INVALID_PATH_CHARS = /[<>:\"|?*]/\n\nfunction invalidWin32Path (p) {\n  const rp = getRootPath(p)\n  p = p.replace(rp, '')\n  return INVALID_PATH_CHARS.test(p)\n}\n\nmodule.exports = {\n  getRootPath,\n  invalidWin32Path\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL21rZGlycy93aW4zMi5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixhQUFhLG1CQUFPLENBQUMsbUlBQU07O0FBRTNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3RvZG8tbGlzdC8uL25vZGVfbW9kdWxlcy9mcy1leHRyYS9saWIvbWtkaXJzL3dpbjMyLmpzP2EyZGYiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJylcblxuLy8gZ2V0IGRyaXZlIG9uIHdpbmRvd3NcbmZ1bmN0aW9uIGdldFJvb3RQYXRoIChwKSB7XG4gIHAgPSBwYXRoLm5vcm1hbGl6ZShwYXRoLnJlc29sdmUocCkpLnNwbGl0KHBhdGguc2VwKVxuICBpZiAocC5sZW5ndGggPiAwKSByZXR1cm4gcFswXVxuICByZXR1cm4gbnVsbFxufVxuXG4vLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS82Mjg4OC8xMDMzMyBjb250YWlucyBtb3JlIGFjY3VyYXRlXG4vLyBUT0RPOiBleHBhbmQgdG8gaW5jbHVkZSB0aGUgcmVzdFxuY29uc3QgSU5WQUxJRF9QQVRIX0NIQVJTID0gL1s8PjpcInw/Kl0vXG5cbmZ1bmN0aW9uIGludmFsaWRXaW4zMlBhdGggKHApIHtcbiAgY29uc3QgcnAgPSBnZXRSb290UGF0aChwKVxuICBwID0gcC5yZXBsYWNlKHJwLCAnJylcbiAgcmV0dXJuIElOVkFMSURfUEFUSF9DSEFSUy50ZXN0KHApXG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBnZXRSb290UGF0aCxcbiAgaW52YWxpZFdpbjMyUGF0aFxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/fs-extra/lib/mkdirs/win32.js\n");

/***/ }),

/***/ "./node_modules/fs-extra/lib/move-sync/index.js":
/*!******************************************************!*\
  !*** ./node_modules/fs-extra/lib/move-sync/index.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nmodule.exports = {\n  moveSync: __webpack_require__(/*! ./move-sync */ \"./node_modules/fs-extra/lib/move-sync/move-sync.js\")\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL21vdmUtc3luYy9pbmRleC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWjtBQUNBLFlBQVksbUJBQU8sQ0FBQyx1RUFBYTtBQUNqQyIsInNvdXJjZXMiOlsid2VicGFjazovL3RvZG8tbGlzdC8uL25vZGVfbW9kdWxlcy9mcy1leHRyYS9saWIvbW92ZS1zeW5jL2luZGV4LmpzPzRlZTkiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBtb3ZlU3luYzogcmVxdWlyZSgnLi9tb3ZlLXN5bmMnKVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/fs-extra/lib/move-sync/index.js\n");

/***/ }),

/***/ "./node_modules/fs-extra/lib/move-sync/move-sync.js":
/*!**********************************************************!*\
  !*** ./node_modules/fs-extra/lib/move-sync/move-sync.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst fs = __webpack_require__(/*! graceful-fs */ \"./node_modules/graceful-fs/graceful-fs.js\")\nconst path = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'path'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()))\nconst copySync = (__webpack_require__(/*! ../copy-sync */ \"./node_modules/fs-extra/lib/copy-sync/index.js\").copySync)\nconst removeSync = (__webpack_require__(/*! ../remove */ \"./node_modules/fs-extra/lib/remove/index.js\").removeSync)\nconst mkdirpSync = (__webpack_require__(/*! ../mkdirs */ \"./node_modules/fs-extra/lib/mkdirs/index.js\").mkdirpSync)\nconst stat = __webpack_require__(/*! ../util/stat */ \"./node_modules/fs-extra/lib/util/stat.js\")\n\nfunction moveSync (src, dest, opts) {\n  opts = opts || {}\n  const overwrite = opts.overwrite || opts.clobber || false\n\n  const { srcStat } = stat.checkPathsSync(src, dest, 'move')\n  stat.checkParentPathsSync(src, srcStat, dest, 'move')\n  mkdirpSync(path.dirname(dest))\n  return doRename(src, dest, overwrite)\n}\n\nfunction doRename (src, dest, overwrite) {\n  if (overwrite) {\n    removeSync(dest)\n    return rename(src, dest, overwrite)\n  }\n  if (fs.existsSync(dest)) throw new Error('dest already exists.')\n  return rename(src, dest, overwrite)\n}\n\nfunction rename (src, dest, overwrite) {\n  try {\n    fs.renameSync(src, dest)\n  } catch (err) {\n    if (err.code !== 'EXDEV') throw err\n    return moveAcrossDevice(src, dest, overwrite)\n  }\n}\n\nfunction moveAcrossDevice (src, dest, overwrite) {\n  const opts = {\n    overwrite,\n    errorOnExist: true\n  }\n  copySync(src, dest, opts)\n  return removeSync(src)\n}\n\nmodule.exports = moveSync\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL21vdmUtc3luYy9tb3ZlLXN5bmMuanMuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosV0FBVyxtQkFBTyxDQUFDLDhEQUFhO0FBQ2hDLGFBQWEsbUJBQU8sQ0FBQyxtSUFBTTtBQUMzQixpQkFBaUIsb0dBQWdDO0FBQ2pELG1CQUFtQixnR0FBK0I7QUFDbEQsbUJBQW1CLGdHQUErQjtBQUNsRCxhQUFhLG1CQUFPLENBQUMsOERBQWM7O0FBRW5DO0FBQ0E7QUFDQTs7QUFFQSxVQUFVLFVBQVU7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3RvZG8tbGlzdC8uL25vZGVfbW9kdWxlcy9mcy1leHRyYS9saWIvbW92ZS1zeW5jL21vdmUtc3luYy5qcz9kMzg5Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBmcyA9IHJlcXVpcmUoJ2dyYWNlZnVsLWZzJylcbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJylcbmNvbnN0IGNvcHlTeW5jID0gcmVxdWlyZSgnLi4vY29weS1zeW5jJykuY29weVN5bmNcbmNvbnN0IHJlbW92ZVN5bmMgPSByZXF1aXJlKCcuLi9yZW1vdmUnKS5yZW1vdmVTeW5jXG5jb25zdCBta2RpcnBTeW5jID0gcmVxdWlyZSgnLi4vbWtkaXJzJykubWtkaXJwU3luY1xuY29uc3Qgc3RhdCA9IHJlcXVpcmUoJy4uL3V0aWwvc3RhdCcpXG5cbmZ1bmN0aW9uIG1vdmVTeW5jIChzcmMsIGRlc3QsIG9wdHMpIHtcbiAgb3B0cyA9IG9wdHMgfHwge31cbiAgY29uc3Qgb3ZlcndyaXRlID0gb3B0cy5vdmVyd3JpdGUgfHwgb3B0cy5jbG9iYmVyIHx8IGZhbHNlXG5cbiAgY29uc3QgeyBzcmNTdGF0IH0gPSBzdGF0LmNoZWNrUGF0aHNTeW5jKHNyYywgZGVzdCwgJ21vdmUnKVxuICBzdGF0LmNoZWNrUGFyZW50UGF0aHNTeW5jKHNyYywgc3JjU3RhdCwgZGVzdCwgJ21vdmUnKVxuICBta2RpcnBTeW5jKHBhdGguZGlybmFtZShkZXN0KSlcbiAgcmV0dXJuIGRvUmVuYW1lKHNyYywgZGVzdCwgb3ZlcndyaXRlKVxufVxuXG5mdW5jdGlvbiBkb1JlbmFtZSAoc3JjLCBkZXN0LCBvdmVyd3JpdGUpIHtcbiAgaWYgKG92ZXJ3cml0ZSkge1xuICAgIHJlbW92ZVN5bmMoZGVzdClcbiAgICByZXR1cm4gcmVuYW1lKHNyYywgZGVzdCwgb3ZlcndyaXRlKVxuICB9XG4gIGlmIChmcy5leGlzdHNTeW5jKGRlc3QpKSB0aHJvdyBuZXcgRXJyb3IoJ2Rlc3QgYWxyZWFkeSBleGlzdHMuJylcbiAgcmV0dXJuIHJlbmFtZShzcmMsIGRlc3QsIG92ZXJ3cml0ZSlcbn1cblxuZnVuY3Rpb24gcmVuYW1lIChzcmMsIGRlc3QsIG92ZXJ3cml0ZSkge1xuICB0cnkge1xuICAgIGZzLnJlbmFtZVN5bmMoc3JjLCBkZXN0KVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBpZiAoZXJyLmNvZGUgIT09ICdFWERFVicpIHRocm93IGVyclxuICAgIHJldHVybiBtb3ZlQWNyb3NzRGV2aWNlKHNyYywgZGVzdCwgb3ZlcndyaXRlKVxuICB9XG59XG5cbmZ1bmN0aW9uIG1vdmVBY3Jvc3NEZXZpY2UgKHNyYywgZGVzdCwgb3ZlcndyaXRlKSB7XG4gIGNvbnN0IG9wdHMgPSB7XG4gICAgb3ZlcndyaXRlLFxuICAgIGVycm9yT25FeGlzdDogdHJ1ZVxuICB9XG4gIGNvcHlTeW5jKHNyYywgZGVzdCwgb3B0cylcbiAgcmV0dXJuIHJlbW92ZVN5bmMoc3JjKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1vdmVTeW5jXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/fs-extra/lib/move-sync/move-sync.js\n");

/***/ }),

/***/ "./node_modules/fs-extra/lib/move/index.js":
/*!*************************************************!*\
  !*** ./node_modules/fs-extra/lib/move/index.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst u = (__webpack_require__(/*! universalify */ \"./node_modules/universalify/index.js\").fromCallback)\nmodule.exports = {\n  move: u(__webpack_require__(/*! ./move */ \"./node_modules/fs-extra/lib/move/move.js\"))\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL21vdmUvaW5kZXguanMuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosVUFBVSw4RkFBb0M7QUFDOUM7QUFDQSxVQUFVLG1CQUFPLENBQUMsd0RBQVE7QUFDMUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90b2RvLWxpc3QvLi9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL21vdmUvaW5kZXguanM/MDhjMyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgdSA9IHJlcXVpcmUoJ3VuaXZlcnNhbGlmeScpLmZyb21DYWxsYmFja1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gIG1vdmU6IHUocmVxdWlyZSgnLi9tb3ZlJykpXG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/fs-extra/lib/move/index.js\n");

/***/ }),

/***/ "./node_modules/fs-extra/lib/move/move.js":
/*!************************************************!*\
  !*** ./node_modules/fs-extra/lib/move/move.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst fs = __webpack_require__(/*! graceful-fs */ \"./node_modules/graceful-fs/graceful-fs.js\")\nconst path = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'path'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()))\nconst copy = (__webpack_require__(/*! ../copy */ \"./node_modules/fs-extra/lib/copy/index.js\").copy)\nconst remove = (__webpack_require__(/*! ../remove */ \"./node_modules/fs-extra/lib/remove/index.js\").remove)\nconst mkdirp = (__webpack_require__(/*! ../mkdirs */ \"./node_modules/fs-extra/lib/mkdirs/index.js\").mkdirp)\nconst pathExists = (__webpack_require__(/*! ../path-exists */ \"./node_modules/fs-extra/lib/path-exists/index.js\").pathExists)\nconst stat = __webpack_require__(/*! ../util/stat */ \"./node_modules/fs-extra/lib/util/stat.js\")\n\nfunction move (src, dest, opts, cb) {\n  if (typeof opts === 'function') {\n    cb = opts\n    opts = {}\n  }\n\n  const overwrite = opts.overwrite || opts.clobber || false\n\n  stat.checkPaths(src, dest, 'move', (err, stats) => {\n    if (err) return cb(err)\n    const { srcStat } = stats\n    stat.checkParentPaths(src, srcStat, dest, 'move', err => {\n      if (err) return cb(err)\n      mkdirp(path.dirname(dest), err => {\n        if (err) return cb(err)\n        return doRename(src, dest, overwrite, cb)\n      })\n    })\n  })\n}\n\nfunction doRename (src, dest, overwrite, cb) {\n  if (overwrite) {\n    return remove(dest, err => {\n      if (err) return cb(err)\n      return rename(src, dest, overwrite, cb)\n    })\n  }\n  pathExists(dest, (err, destExists) => {\n    if (err) return cb(err)\n    if (destExists) return cb(new Error('dest already exists.'))\n    return rename(src, dest, overwrite, cb)\n  })\n}\n\nfunction rename (src, dest, overwrite, cb) {\n  fs.rename(src, dest, err => {\n    if (!err) return cb()\n    if (err.code !== 'EXDEV') return cb(err)\n    return moveAcrossDevice(src, dest, overwrite, cb)\n  })\n}\n\nfunction moveAcrossDevice (src, dest, overwrite, cb) {\n  const opts = {\n    overwrite,\n    errorOnExist: true\n  }\n  copy(src, dest, opts, err => {\n    if (err) return cb(err)\n    return remove(src, cb)\n  })\n}\n\nmodule.exports = move\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL21vdmUvbW92ZS5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixXQUFXLG1CQUFPLENBQUMsOERBQWE7QUFDaEMsYUFBYSxtQkFBTyxDQUFDLG1JQUFNO0FBQzNCLGFBQWEsc0ZBQXVCO0FBQ3BDLGVBQWUsNEZBQTJCO0FBQzFDLGVBQWUsNEZBQTJCO0FBQzFDLG1CQUFtQiwwR0FBb0M7QUFDdkQsYUFBYSxtQkFBTyxDQUFDLDhEQUFjOztBQUVuQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLFVBQVU7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90b2RvLWxpc3QvLi9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL21vdmUvbW92ZS5qcz81MWNlIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBmcyA9IHJlcXVpcmUoJ2dyYWNlZnVsLWZzJylcbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJylcbmNvbnN0IGNvcHkgPSByZXF1aXJlKCcuLi9jb3B5JykuY29weVxuY29uc3QgcmVtb3ZlID0gcmVxdWlyZSgnLi4vcmVtb3ZlJykucmVtb3ZlXG5jb25zdCBta2RpcnAgPSByZXF1aXJlKCcuLi9ta2RpcnMnKS5ta2RpcnBcbmNvbnN0IHBhdGhFeGlzdHMgPSByZXF1aXJlKCcuLi9wYXRoLWV4aXN0cycpLnBhdGhFeGlzdHNcbmNvbnN0IHN0YXQgPSByZXF1aXJlKCcuLi91dGlsL3N0YXQnKVxuXG5mdW5jdGlvbiBtb3ZlIChzcmMsIGRlc3QsIG9wdHMsIGNiKSB7XG4gIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gb3B0c1xuICAgIG9wdHMgPSB7fVxuICB9XG5cbiAgY29uc3Qgb3ZlcndyaXRlID0gb3B0cy5vdmVyd3JpdGUgfHwgb3B0cy5jbG9iYmVyIHx8IGZhbHNlXG5cbiAgc3RhdC5jaGVja1BhdGhzKHNyYywgZGVzdCwgJ21vdmUnLCAoZXJyLCBzdGF0cykgPT4ge1xuICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpXG4gICAgY29uc3QgeyBzcmNTdGF0IH0gPSBzdGF0c1xuICAgIHN0YXQuY2hlY2tQYXJlbnRQYXRocyhzcmMsIHNyY1N0YXQsIGRlc3QsICdtb3ZlJywgZXJyID0+IHtcbiAgICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpXG4gICAgICBta2RpcnAocGF0aC5kaXJuYW1lKGRlc3QpLCBlcnIgPT4ge1xuICAgICAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKVxuICAgICAgICByZXR1cm4gZG9SZW5hbWUoc3JjLCBkZXN0LCBvdmVyd3JpdGUsIGNiKVxuICAgICAgfSlcbiAgICB9KVxuICB9KVxufVxuXG5mdW5jdGlvbiBkb1JlbmFtZSAoc3JjLCBkZXN0LCBvdmVyd3JpdGUsIGNiKSB7XG4gIGlmIChvdmVyd3JpdGUpIHtcbiAgICByZXR1cm4gcmVtb3ZlKGRlc3QsIGVyciA9PiB7XG4gICAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKVxuICAgICAgcmV0dXJuIHJlbmFtZShzcmMsIGRlc3QsIG92ZXJ3cml0ZSwgY2IpXG4gICAgfSlcbiAgfVxuICBwYXRoRXhpc3RzKGRlc3QsIChlcnIsIGRlc3RFeGlzdHMpID0+IHtcbiAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKVxuICAgIGlmIChkZXN0RXhpc3RzKSByZXR1cm4gY2IobmV3IEVycm9yKCdkZXN0IGFscmVhZHkgZXhpc3RzLicpKVxuICAgIHJldHVybiByZW5hbWUoc3JjLCBkZXN0LCBvdmVyd3JpdGUsIGNiKVxuICB9KVxufVxuXG5mdW5jdGlvbiByZW5hbWUgKHNyYywgZGVzdCwgb3ZlcndyaXRlLCBjYikge1xuICBmcy5yZW5hbWUoc3JjLCBkZXN0LCBlcnIgPT4ge1xuICAgIGlmICghZXJyKSByZXR1cm4gY2IoKVxuICAgIGlmIChlcnIuY29kZSAhPT0gJ0VYREVWJykgcmV0dXJuIGNiKGVycilcbiAgICByZXR1cm4gbW92ZUFjcm9zc0RldmljZShzcmMsIGRlc3QsIG92ZXJ3cml0ZSwgY2IpXG4gIH0pXG59XG5cbmZ1bmN0aW9uIG1vdmVBY3Jvc3NEZXZpY2UgKHNyYywgZGVzdCwgb3ZlcndyaXRlLCBjYikge1xuICBjb25zdCBvcHRzID0ge1xuICAgIG92ZXJ3cml0ZSxcbiAgICBlcnJvck9uRXhpc3Q6IHRydWVcbiAgfVxuICBjb3B5KHNyYywgZGVzdCwgb3B0cywgZXJyID0+IHtcbiAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKVxuICAgIHJldHVybiByZW1vdmUoc3JjLCBjYilcbiAgfSlcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtb3ZlXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/fs-extra/lib/move/move.js\n");

/***/ }),

/***/ "./node_modules/fs-extra/lib/output/index.js":
/*!***************************************************!*\
  !*** ./node_modules/fs-extra/lib/output/index.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst u = (__webpack_require__(/*! universalify */ \"./node_modules/universalify/index.js\").fromCallback)\nconst fs = __webpack_require__(/*! graceful-fs */ \"./node_modules/graceful-fs/graceful-fs.js\")\nconst path = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'path'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()))\nconst mkdir = __webpack_require__(/*! ../mkdirs */ \"./node_modules/fs-extra/lib/mkdirs/index.js\")\nconst pathExists = (__webpack_require__(/*! ../path-exists */ \"./node_modules/fs-extra/lib/path-exists/index.js\").pathExists)\n\nfunction outputFile (file, data, encoding, callback) {\n  if (typeof encoding === 'function') {\n    callback = encoding\n    encoding = 'utf8'\n  }\n\n  const dir = path.dirname(file)\n  pathExists(dir, (err, itDoes) => {\n    if (err) return callback(err)\n    if (itDoes) return fs.writeFile(file, data, encoding, callback)\n\n    mkdir.mkdirs(dir, err => {\n      if (err) return callback(err)\n\n      fs.writeFile(file, data, encoding, callback)\n    })\n  })\n}\n\nfunction outputFileSync (file, ...args) {\n  const dir = path.dirname(file)\n  if (fs.existsSync(dir)) {\n    return fs.writeFileSync(file, ...args)\n  }\n  mkdir.mkdirsSync(dir)\n  fs.writeFileSync(file, ...args)\n}\n\nmodule.exports = {\n  outputFile: u(outputFile),\n  outputFileSync\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL291dHB1dC9pbmRleC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixVQUFVLDhGQUFvQztBQUM5QyxXQUFXLG1CQUFPLENBQUMsOERBQWE7QUFDaEMsYUFBYSxtQkFBTyxDQUFDLG1JQUFNO0FBQzNCLGNBQWMsbUJBQU8sQ0FBQyw4REFBVztBQUNqQyxtQkFBbUIsMEdBQW9DOztBQUV2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90b2RvLWxpc3QvLi9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL291dHB1dC9pbmRleC5qcz83Zjc5Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB1ID0gcmVxdWlyZSgndW5pdmVyc2FsaWZ5JykuZnJvbUNhbGxiYWNrXG5jb25zdCBmcyA9IHJlcXVpcmUoJ2dyYWNlZnVsLWZzJylcbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJylcbmNvbnN0IG1rZGlyID0gcmVxdWlyZSgnLi4vbWtkaXJzJylcbmNvbnN0IHBhdGhFeGlzdHMgPSByZXF1aXJlKCcuLi9wYXRoLWV4aXN0cycpLnBhdGhFeGlzdHNcblxuZnVuY3Rpb24gb3V0cHV0RmlsZSAoZmlsZSwgZGF0YSwgZW5jb2RpbmcsIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IGVuY29kaW5nXG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgfVxuXG4gIGNvbnN0IGRpciA9IHBhdGguZGlybmFtZShmaWxlKVxuICBwYXRoRXhpc3RzKGRpciwgKGVyciwgaXREb2VzKSA9PiB7XG4gICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycilcbiAgICBpZiAoaXREb2VzKSByZXR1cm4gZnMud3JpdGVGaWxlKGZpbGUsIGRhdGEsIGVuY29kaW5nLCBjYWxsYmFjaylcblxuICAgIG1rZGlyLm1rZGlycyhkaXIsIGVyciA9PiB7XG4gICAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKVxuXG4gICAgICBmcy53cml0ZUZpbGUoZmlsZSwgZGF0YSwgZW5jb2RpbmcsIGNhbGxiYWNrKVxuICAgIH0pXG4gIH0pXG59XG5cbmZ1bmN0aW9uIG91dHB1dEZpbGVTeW5jIChmaWxlLCAuLi5hcmdzKSB7XG4gIGNvbnN0IGRpciA9IHBhdGguZGlybmFtZShmaWxlKVxuICBpZiAoZnMuZXhpc3RzU3luYyhkaXIpKSB7XG4gICAgcmV0dXJuIGZzLndyaXRlRmlsZVN5bmMoZmlsZSwgLi4uYXJncylcbiAgfVxuICBta2Rpci5ta2RpcnNTeW5jKGRpcilcbiAgZnMud3JpdGVGaWxlU3luYyhmaWxlLCAuLi5hcmdzKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgb3V0cHV0RmlsZTogdShvdXRwdXRGaWxlKSxcbiAgb3V0cHV0RmlsZVN5bmNcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/fs-extra/lib/output/index.js\n");

/***/ }),

/***/ "./node_modules/fs-extra/lib/path-exists/index.js":
/*!********************************************************!*\
  !*** ./node_modules/fs-extra/lib/path-exists/index.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst u = (__webpack_require__(/*! universalify */ \"./node_modules/universalify/index.js\").fromPromise)\nconst fs = __webpack_require__(/*! ../fs */ \"./node_modules/fs-extra/lib/fs/index.js\")\n\nfunction pathExists (path) {\n  return fs.access(path).then(() => true).catch(() => false)\n}\n\nmodule.exports = {\n  pathExists: u(pathExists),\n  pathExistsSync: fs.existsSync\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL3BhdGgtZXhpc3RzL2luZGV4LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFZO0FBQ1osVUFBVSw2RkFBbUM7QUFDN0MsV0FBVyxtQkFBTyxDQUFDLHNEQUFPOztBQUUxQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90b2RvLWxpc3QvLi9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL3BhdGgtZXhpc3RzL2luZGV4LmpzP2M1MDAiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5jb25zdCB1ID0gcmVxdWlyZSgndW5pdmVyc2FsaWZ5JykuZnJvbVByb21pc2VcbmNvbnN0IGZzID0gcmVxdWlyZSgnLi4vZnMnKVxuXG5mdW5jdGlvbiBwYXRoRXhpc3RzIChwYXRoKSB7XG4gIHJldHVybiBmcy5hY2Nlc3MocGF0aCkudGhlbigoKSA9PiB0cnVlKS5jYXRjaCgoKSA9PiBmYWxzZSlcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHBhdGhFeGlzdHM6IHUocGF0aEV4aXN0cyksXG4gIHBhdGhFeGlzdHNTeW5jOiBmcy5leGlzdHNTeW5jXG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/fs-extra/lib/path-exists/index.js\n");

/***/ }),

/***/ "./node_modules/fs-extra/lib/remove/index.js":
/*!***************************************************!*\
  !*** ./node_modules/fs-extra/lib/remove/index.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst u = (__webpack_require__(/*! universalify */ \"./node_modules/universalify/index.js\").fromCallback)\nconst rimraf = __webpack_require__(/*! ./rimraf */ \"./node_modules/fs-extra/lib/remove/rimraf.js\")\n\nmodule.exports = {\n  remove: u(rimraf),\n  removeSync: rimraf.sync\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL3JlbW92ZS9pbmRleC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixVQUFVLDhGQUFvQztBQUM5QyxlQUFlLG1CQUFPLENBQUMsOERBQVU7O0FBRWpDO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdG9kby1saXN0Ly4vbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi9yZW1vdmUvaW5kZXguanM/YjQxZCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgdSA9IHJlcXVpcmUoJ3VuaXZlcnNhbGlmeScpLmZyb21DYWxsYmFja1xuY29uc3QgcmltcmFmID0gcmVxdWlyZSgnLi9yaW1yYWYnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgcmVtb3ZlOiB1KHJpbXJhZiksXG4gIHJlbW92ZVN5bmM6IHJpbXJhZi5zeW5jXG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/fs-extra/lib/remove/index.js\n");

/***/ }),

/***/ "./node_modules/fs-extra/lib/remove/rimraf.js":
/*!****************************************************!*\
  !*** ./node_modules/fs-extra/lib/remove/rimraf.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst fs = __webpack_require__(/*! graceful-fs */ \"./node_modules/graceful-fs/graceful-fs.js\")\nconst path = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'path'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()))\nconst assert = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'assert'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()))\n\nconst isWindows = (process.platform === 'win32')\n\nfunction defaults (options) {\n  const methods = [\n    'unlink',\n    'chmod',\n    'stat',\n    'lstat',\n    'rmdir',\n    'readdir'\n  ]\n  methods.forEach(m => {\n    options[m] = options[m] || fs[m]\n    m = m + 'Sync'\n    options[m] = options[m] || fs[m]\n  })\n\n  options.maxBusyTries = options.maxBusyTries || 3\n}\n\nfunction rimraf (p, options, cb) {\n  let busyTries = 0\n\n  if (typeof options === 'function') {\n    cb = options\n    options = {}\n  }\n\n  assert(p, 'rimraf: missing path')\n  assert.strictEqual(typeof p, 'string', 'rimraf: path should be a string')\n  assert.strictEqual(typeof cb, 'function', 'rimraf: callback function required')\n  assert(options, 'rimraf: invalid options argument provided')\n  assert.strictEqual(typeof options, 'object', 'rimraf: options should be object')\n\n  defaults(options)\n\n  rimraf_(p, options, function CB (er) {\n    if (er) {\n      if ((er.code === 'EBUSY' || er.code === 'ENOTEMPTY' || er.code === 'EPERM') &&\n          busyTries < options.maxBusyTries) {\n        busyTries++\n        const time = busyTries * 100\n        // try again, with the same exact callback as this one.\n        return setTimeout(() => rimraf_(p, options, CB), time)\n      }\n\n      // already gone\n      if (er.code === 'ENOENT') er = null\n    }\n\n    cb(er)\n  })\n}\n\n// Two possible strategies.\n// 1. Assume it's a file.  unlink it, then do the dir stuff on EPERM or EISDIR\n// 2. Assume it's a directory.  readdir, then do the file stuff on ENOTDIR\n//\n// Both result in an extra syscall when you guess wrong.  However, there\n// are likely far more normal files in the world than directories.  This\n// is based on the assumption that a the average number of files per\n// directory is >= 1.\n//\n// If anyone ever complains about this, then I guess the strategy could\n// be made configurable somehow.  But until then, YAGNI.\nfunction rimraf_ (p, options, cb) {\n  assert(p)\n  assert(options)\n  assert(typeof cb === 'function')\n\n  // sunos lets the root user unlink directories, which is... weird.\n  // so we have to lstat here and make sure it's not a dir.\n  options.lstat(p, (er, st) => {\n    if (er && er.code === 'ENOENT') {\n      return cb(null)\n    }\n\n    // Windows can EPERM on stat.  Life is suffering.\n    if (er && er.code === 'EPERM' && isWindows) {\n      return fixWinEPERM(p, options, er, cb)\n    }\n\n    if (st && st.isDirectory()) {\n      return rmdir(p, options, er, cb)\n    }\n\n    options.unlink(p, er => {\n      if (er) {\n        if (er.code === 'ENOENT') {\n          return cb(null)\n        }\n        if (er.code === 'EPERM') {\n          return (isWindows)\n            ? fixWinEPERM(p, options, er, cb)\n            : rmdir(p, options, er, cb)\n        }\n        if (er.code === 'EISDIR') {\n          return rmdir(p, options, er, cb)\n        }\n      }\n      return cb(er)\n    })\n  })\n}\n\nfunction fixWinEPERM (p, options, er, cb) {\n  assert(p)\n  assert(options)\n  assert(typeof cb === 'function')\n  if (er) {\n    assert(er instanceof Error)\n  }\n\n  options.chmod(p, 0o666, er2 => {\n    if (er2) {\n      cb(er2.code === 'ENOENT' ? null : er)\n    } else {\n      options.stat(p, (er3, stats) => {\n        if (er3) {\n          cb(er3.code === 'ENOENT' ? null : er)\n        } else if (stats.isDirectory()) {\n          rmdir(p, options, er, cb)\n        } else {\n          options.unlink(p, cb)\n        }\n      })\n    }\n  })\n}\n\nfunction fixWinEPERMSync (p, options, er) {\n  let stats\n\n  assert(p)\n  assert(options)\n  if (er) {\n    assert(er instanceof Error)\n  }\n\n  try {\n    options.chmodSync(p, 0o666)\n  } catch (er2) {\n    if (er2.code === 'ENOENT') {\n      return\n    } else {\n      throw er\n    }\n  }\n\n  try {\n    stats = options.statSync(p)\n  } catch (er3) {\n    if (er3.code === 'ENOENT') {\n      return\n    } else {\n      throw er\n    }\n  }\n\n  if (stats.isDirectory()) {\n    rmdirSync(p, options, er)\n  } else {\n    options.unlinkSync(p)\n  }\n}\n\nfunction rmdir (p, options, originalEr, cb) {\n  assert(p)\n  assert(options)\n  if (originalEr) {\n    assert(originalEr instanceof Error)\n  }\n  assert(typeof cb === 'function')\n\n  // try to rmdir first, and only readdir on ENOTEMPTY or EEXIST (SunOS)\n  // if we guessed wrong, and it's not a directory, then\n  // raise the original error.\n  options.rmdir(p, er => {\n    if (er && (er.code === 'ENOTEMPTY' || er.code === 'EEXIST' || er.code === 'EPERM')) {\n      rmkids(p, options, cb)\n    } else if (er && er.code === 'ENOTDIR') {\n      cb(originalEr)\n    } else {\n      cb(er)\n    }\n  })\n}\n\nfunction rmkids (p, options, cb) {\n  assert(p)\n  assert(options)\n  assert(typeof cb === 'function')\n\n  options.readdir(p, (er, files) => {\n    if (er) return cb(er)\n\n    let n = files.length\n    let errState\n\n    if (n === 0) return options.rmdir(p, cb)\n\n    files.forEach(f => {\n      rimraf(path.join(p, f), options, er => {\n        if (errState) {\n          return\n        }\n        if (er) return cb(errState = er)\n        if (--n === 0) {\n          options.rmdir(p, cb)\n        }\n      })\n    })\n  })\n}\n\n// this looks simpler, and is strictly *faster*, but will\n// tie up the JavaScript thread and fail on excessively\n// deep directory trees.\nfunction rimrafSync (p, options) {\n  let st\n\n  options = options || {}\n  defaults(options)\n\n  assert(p, 'rimraf: missing path')\n  assert.strictEqual(typeof p, 'string', 'rimraf: path should be a string')\n  assert(options, 'rimraf: missing options')\n  assert.strictEqual(typeof options, 'object', 'rimraf: options should be object')\n\n  try {\n    st = options.lstatSync(p)\n  } catch (er) {\n    if (er.code === 'ENOENT') {\n      return\n    }\n\n    // Windows can EPERM on stat.  Life is suffering.\n    if (er.code === 'EPERM' && isWindows) {\n      fixWinEPERMSync(p, options, er)\n    }\n  }\n\n  try {\n    // sunos lets the root user unlink directories, which is... weird.\n    if (st && st.isDirectory()) {\n      rmdirSync(p, options, null)\n    } else {\n      options.unlinkSync(p)\n    }\n  } catch (er) {\n    if (er.code === 'ENOENT') {\n      return\n    } else if (er.code === 'EPERM') {\n      return isWindows ? fixWinEPERMSync(p, options, er) : rmdirSync(p, options, er)\n    } else if (er.code !== 'EISDIR') {\n      throw er\n    }\n    rmdirSync(p, options, er)\n  }\n}\n\nfunction rmdirSync (p, options, originalEr) {\n  assert(p)\n  assert(options)\n  if (originalEr) {\n    assert(originalEr instanceof Error)\n  }\n\n  try {\n    options.rmdirSync(p)\n  } catch (er) {\n    if (er.code === 'ENOTDIR') {\n      throw originalEr\n    } else if (er.code === 'ENOTEMPTY' || er.code === 'EEXIST' || er.code === 'EPERM') {\n      rmkidsSync(p, options)\n    } else if (er.code !== 'ENOENT') {\n      throw er\n    }\n  }\n}\n\nfunction rmkidsSync (p, options) {\n  assert(p)\n  assert(options)\n  options.readdirSync(p).forEach(f => rimrafSync(path.join(p, f), options))\n\n  if (isWindows) {\n    // We only end up here once we got ENOTEMPTY at least once, and\n    // at this point, we are guaranteed to have removed all the kids.\n    // So, we know that it won't be ENOENT or ENOTDIR or anything else.\n    // try really hard to delete stuff on windows, because it has a\n    // PROFOUNDLY annoying habit of not closing handles promptly when\n    // files are deleted, resulting in spurious ENOTEMPTY errors.\n    const startTime = Date.now()\n    do {\n      try {\n        const ret = options.rmdirSync(p, options)\n        return ret\n      } catch (er) { }\n    } while (Date.now() - startTime < 500) // give up after 500ms\n  } else {\n    const ret = options.rmdirSync(p, options)\n    return ret\n  }\n}\n\nmodule.exports = rimraf\nrimraf.sync = rimrafSync\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL3JlbW92ZS9yaW1yYWYuanMuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosV0FBVyxtQkFBTyxDQUFDLDhEQUFhO0FBQ2hDLGFBQWEsbUJBQU8sQ0FBQyxtSUFBTTtBQUMzQixlQUFlLG1CQUFPLENBQUMscUlBQVE7O0FBRS9COztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLE1BQU07QUFDTixJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3RvZG8tbGlzdC8uL25vZGVfbW9kdWxlcy9mcy1leHRyYS9saWIvcmVtb3ZlL3JpbXJhZi5qcz9mYjJhIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBmcyA9IHJlcXVpcmUoJ2dyYWNlZnVsLWZzJylcbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJylcbmNvbnN0IGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpXG5cbmNvbnN0IGlzV2luZG93cyA9IChwcm9jZXNzLnBsYXRmb3JtID09PSAnd2luMzInKVxuXG5mdW5jdGlvbiBkZWZhdWx0cyAob3B0aW9ucykge1xuICBjb25zdCBtZXRob2RzID0gW1xuICAgICd1bmxpbmsnLFxuICAgICdjaG1vZCcsXG4gICAgJ3N0YXQnLFxuICAgICdsc3RhdCcsXG4gICAgJ3JtZGlyJyxcbiAgICAncmVhZGRpcidcbiAgXVxuICBtZXRob2RzLmZvckVhY2gobSA9PiB7XG4gICAgb3B0aW9uc1ttXSA9IG9wdGlvbnNbbV0gfHwgZnNbbV1cbiAgICBtID0gbSArICdTeW5jJ1xuICAgIG9wdGlvbnNbbV0gPSBvcHRpb25zW21dIHx8IGZzW21dXG4gIH0pXG5cbiAgb3B0aW9ucy5tYXhCdXN5VHJpZXMgPSBvcHRpb25zLm1heEJ1c3lUcmllcyB8fCAzXG59XG5cbmZ1bmN0aW9uIHJpbXJhZiAocCwgb3B0aW9ucywgY2IpIHtcbiAgbGV0IGJ1c3lUcmllcyA9IDBcblxuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IG9wdGlvbnNcbiAgICBvcHRpb25zID0ge31cbiAgfVxuXG4gIGFzc2VydChwLCAncmltcmFmOiBtaXNzaW5nIHBhdGgnKVxuICBhc3NlcnQuc3RyaWN0RXF1YWwodHlwZW9mIHAsICdzdHJpbmcnLCAncmltcmFmOiBwYXRoIHNob3VsZCBiZSBhIHN0cmluZycpXG4gIGFzc2VydC5zdHJpY3RFcXVhbCh0eXBlb2YgY2IsICdmdW5jdGlvbicsICdyaW1yYWY6IGNhbGxiYWNrIGZ1bmN0aW9uIHJlcXVpcmVkJylcbiAgYXNzZXJ0KG9wdGlvbnMsICdyaW1yYWY6IGludmFsaWQgb3B0aW9ucyBhcmd1bWVudCBwcm92aWRlZCcpXG4gIGFzc2VydC5zdHJpY3RFcXVhbCh0eXBlb2Ygb3B0aW9ucywgJ29iamVjdCcsICdyaW1yYWY6IG9wdGlvbnMgc2hvdWxkIGJlIG9iamVjdCcpXG5cbiAgZGVmYXVsdHMob3B0aW9ucylcblxuICByaW1yYWZfKHAsIG9wdGlvbnMsIGZ1bmN0aW9uIENCIChlcikge1xuICAgIGlmIChlcikge1xuICAgICAgaWYgKChlci5jb2RlID09PSAnRUJVU1knIHx8IGVyLmNvZGUgPT09ICdFTk9URU1QVFknIHx8IGVyLmNvZGUgPT09ICdFUEVSTScpICYmXG4gICAgICAgICAgYnVzeVRyaWVzIDwgb3B0aW9ucy5tYXhCdXN5VHJpZXMpIHtcbiAgICAgICAgYnVzeVRyaWVzKytcbiAgICAgICAgY29uc3QgdGltZSA9IGJ1c3lUcmllcyAqIDEwMFxuICAgICAgICAvLyB0cnkgYWdhaW4sIHdpdGggdGhlIHNhbWUgZXhhY3QgY2FsbGJhY2sgYXMgdGhpcyBvbmUuXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KCgpID0+IHJpbXJhZl8ocCwgb3B0aW9ucywgQ0IpLCB0aW1lKVxuICAgICAgfVxuXG4gICAgICAvLyBhbHJlYWR5IGdvbmVcbiAgICAgIGlmIChlci5jb2RlID09PSAnRU5PRU5UJykgZXIgPSBudWxsXG4gICAgfVxuXG4gICAgY2IoZXIpXG4gIH0pXG59XG5cbi8vIFR3byBwb3NzaWJsZSBzdHJhdGVnaWVzLlxuLy8gMS4gQXNzdW1lIGl0J3MgYSBmaWxlLiAgdW5saW5rIGl0LCB0aGVuIGRvIHRoZSBkaXIgc3R1ZmYgb24gRVBFUk0gb3IgRUlTRElSXG4vLyAyLiBBc3N1bWUgaXQncyBhIGRpcmVjdG9yeS4gIHJlYWRkaXIsIHRoZW4gZG8gdGhlIGZpbGUgc3R1ZmYgb24gRU5PVERJUlxuLy9cbi8vIEJvdGggcmVzdWx0IGluIGFuIGV4dHJhIHN5c2NhbGwgd2hlbiB5b3UgZ3Vlc3Mgd3JvbmcuICBIb3dldmVyLCB0aGVyZVxuLy8gYXJlIGxpa2VseSBmYXIgbW9yZSBub3JtYWwgZmlsZXMgaW4gdGhlIHdvcmxkIHRoYW4gZGlyZWN0b3JpZXMuICBUaGlzXG4vLyBpcyBiYXNlZCBvbiB0aGUgYXNzdW1wdGlvbiB0aGF0IGEgdGhlIGF2ZXJhZ2UgbnVtYmVyIG9mIGZpbGVzIHBlclxuLy8gZGlyZWN0b3J5IGlzID49IDEuXG4vL1xuLy8gSWYgYW55b25lIGV2ZXIgY29tcGxhaW5zIGFib3V0IHRoaXMsIHRoZW4gSSBndWVzcyB0aGUgc3RyYXRlZ3kgY291bGRcbi8vIGJlIG1hZGUgY29uZmlndXJhYmxlIHNvbWVob3cuICBCdXQgdW50aWwgdGhlbiwgWUFHTkkuXG5mdW5jdGlvbiByaW1yYWZfIChwLCBvcHRpb25zLCBjYikge1xuICBhc3NlcnQocClcbiAgYXNzZXJ0KG9wdGlvbnMpXG4gIGFzc2VydCh0eXBlb2YgY2IgPT09ICdmdW5jdGlvbicpXG5cbiAgLy8gc3Vub3MgbGV0cyB0aGUgcm9vdCB1c2VyIHVubGluayBkaXJlY3Rvcmllcywgd2hpY2ggaXMuLi4gd2VpcmQuXG4gIC8vIHNvIHdlIGhhdmUgdG8gbHN0YXQgaGVyZSBhbmQgbWFrZSBzdXJlIGl0J3Mgbm90IGEgZGlyLlxuICBvcHRpb25zLmxzdGF0KHAsIChlciwgc3QpID0+IHtcbiAgICBpZiAoZXIgJiYgZXIuY29kZSA9PT0gJ0VOT0VOVCcpIHtcbiAgICAgIHJldHVybiBjYihudWxsKVxuICAgIH1cblxuICAgIC8vIFdpbmRvd3MgY2FuIEVQRVJNIG9uIHN0YXQuICBMaWZlIGlzIHN1ZmZlcmluZy5cbiAgICBpZiAoZXIgJiYgZXIuY29kZSA9PT0gJ0VQRVJNJyAmJiBpc1dpbmRvd3MpIHtcbiAgICAgIHJldHVybiBmaXhXaW5FUEVSTShwLCBvcHRpb25zLCBlciwgY2IpXG4gICAgfVxuXG4gICAgaWYgKHN0ICYmIHN0LmlzRGlyZWN0b3J5KCkpIHtcbiAgICAgIHJldHVybiBybWRpcihwLCBvcHRpb25zLCBlciwgY2IpXG4gICAgfVxuXG4gICAgb3B0aW9ucy51bmxpbmsocCwgZXIgPT4ge1xuICAgICAgaWYgKGVyKSB7XG4gICAgICAgIGlmIChlci5jb2RlID09PSAnRU5PRU5UJykge1xuICAgICAgICAgIHJldHVybiBjYihudWxsKVxuICAgICAgICB9XG4gICAgICAgIGlmIChlci5jb2RlID09PSAnRVBFUk0nKSB7XG4gICAgICAgICAgcmV0dXJuIChpc1dpbmRvd3MpXG4gICAgICAgICAgICA/IGZpeFdpbkVQRVJNKHAsIG9wdGlvbnMsIGVyLCBjYilcbiAgICAgICAgICAgIDogcm1kaXIocCwgb3B0aW9ucywgZXIsIGNiKVxuICAgICAgICB9XG4gICAgICAgIGlmIChlci5jb2RlID09PSAnRUlTRElSJykge1xuICAgICAgICAgIHJldHVybiBybWRpcihwLCBvcHRpb25zLCBlciwgY2IpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBjYihlcilcbiAgICB9KVxuICB9KVxufVxuXG5mdW5jdGlvbiBmaXhXaW5FUEVSTSAocCwgb3B0aW9ucywgZXIsIGNiKSB7XG4gIGFzc2VydChwKVxuICBhc3NlcnQob3B0aW9ucylcbiAgYXNzZXJ0KHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJylcbiAgaWYgKGVyKSB7XG4gICAgYXNzZXJ0KGVyIGluc3RhbmNlb2YgRXJyb3IpXG4gIH1cblxuICBvcHRpb25zLmNobW9kKHAsIDBvNjY2LCBlcjIgPT4ge1xuICAgIGlmIChlcjIpIHtcbiAgICAgIGNiKGVyMi5jb2RlID09PSAnRU5PRU5UJyA/IG51bGwgOiBlcilcbiAgICB9IGVsc2Uge1xuICAgICAgb3B0aW9ucy5zdGF0KHAsIChlcjMsIHN0YXRzKSA9PiB7XG4gICAgICAgIGlmIChlcjMpIHtcbiAgICAgICAgICBjYihlcjMuY29kZSA9PT0gJ0VOT0VOVCcgPyBudWxsIDogZXIpXG4gICAgICAgIH0gZWxzZSBpZiAoc3RhdHMuaXNEaXJlY3RvcnkoKSkge1xuICAgICAgICAgIHJtZGlyKHAsIG9wdGlvbnMsIGVyLCBjYilcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvcHRpb25zLnVubGluayhwLCBjYilcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG4gIH0pXG59XG5cbmZ1bmN0aW9uIGZpeFdpbkVQRVJNU3luYyAocCwgb3B0aW9ucywgZXIpIHtcbiAgbGV0IHN0YXRzXG5cbiAgYXNzZXJ0KHApXG4gIGFzc2VydChvcHRpb25zKVxuICBpZiAoZXIpIHtcbiAgICBhc3NlcnQoZXIgaW5zdGFuY2VvZiBFcnJvcilcbiAgfVxuXG4gIHRyeSB7XG4gICAgb3B0aW9ucy5jaG1vZFN5bmMocCwgMG82NjYpXG4gIH0gY2F0Y2ggKGVyMikge1xuICAgIGlmIChlcjIuY29kZSA9PT0gJ0VOT0VOVCcpIHtcbiAgICAgIHJldHVyblxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBlclxuICAgIH1cbiAgfVxuXG4gIHRyeSB7XG4gICAgc3RhdHMgPSBvcHRpb25zLnN0YXRTeW5jKHApXG4gIH0gY2F0Y2ggKGVyMykge1xuICAgIGlmIChlcjMuY29kZSA9PT0gJ0VOT0VOVCcpIHtcbiAgICAgIHJldHVyblxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBlclxuICAgIH1cbiAgfVxuXG4gIGlmIChzdGF0cy5pc0RpcmVjdG9yeSgpKSB7XG4gICAgcm1kaXJTeW5jKHAsIG9wdGlvbnMsIGVyKVxuICB9IGVsc2Uge1xuICAgIG9wdGlvbnMudW5saW5rU3luYyhwKVxuICB9XG59XG5cbmZ1bmN0aW9uIHJtZGlyIChwLCBvcHRpb25zLCBvcmlnaW5hbEVyLCBjYikge1xuICBhc3NlcnQocClcbiAgYXNzZXJ0KG9wdGlvbnMpXG4gIGlmIChvcmlnaW5hbEVyKSB7XG4gICAgYXNzZXJ0KG9yaWdpbmFsRXIgaW5zdGFuY2VvZiBFcnJvcilcbiAgfVxuICBhc3NlcnQodHlwZW9mIGNiID09PSAnZnVuY3Rpb24nKVxuXG4gIC8vIHRyeSB0byBybWRpciBmaXJzdCwgYW5kIG9ubHkgcmVhZGRpciBvbiBFTk9URU1QVFkgb3IgRUVYSVNUIChTdW5PUylcbiAgLy8gaWYgd2UgZ3Vlc3NlZCB3cm9uZywgYW5kIGl0J3Mgbm90IGEgZGlyZWN0b3J5LCB0aGVuXG4gIC8vIHJhaXNlIHRoZSBvcmlnaW5hbCBlcnJvci5cbiAgb3B0aW9ucy5ybWRpcihwLCBlciA9PiB7XG4gICAgaWYgKGVyICYmIChlci5jb2RlID09PSAnRU5PVEVNUFRZJyB8fCBlci5jb2RlID09PSAnRUVYSVNUJyB8fCBlci5jb2RlID09PSAnRVBFUk0nKSkge1xuICAgICAgcm1raWRzKHAsIG9wdGlvbnMsIGNiKVxuICAgIH0gZWxzZSBpZiAoZXIgJiYgZXIuY29kZSA9PT0gJ0VOT1RESVInKSB7XG4gICAgICBjYihvcmlnaW5hbEVyKVxuICAgIH0gZWxzZSB7XG4gICAgICBjYihlcilcbiAgICB9XG4gIH0pXG59XG5cbmZ1bmN0aW9uIHJta2lkcyAocCwgb3B0aW9ucywgY2IpIHtcbiAgYXNzZXJ0KHApXG4gIGFzc2VydChvcHRpb25zKVxuICBhc3NlcnQodHlwZW9mIGNiID09PSAnZnVuY3Rpb24nKVxuXG4gIG9wdGlvbnMucmVhZGRpcihwLCAoZXIsIGZpbGVzKSA9PiB7XG4gICAgaWYgKGVyKSByZXR1cm4gY2IoZXIpXG5cbiAgICBsZXQgbiA9IGZpbGVzLmxlbmd0aFxuICAgIGxldCBlcnJTdGF0ZVxuXG4gICAgaWYgKG4gPT09IDApIHJldHVybiBvcHRpb25zLnJtZGlyKHAsIGNiKVxuXG4gICAgZmlsZXMuZm9yRWFjaChmID0+IHtcbiAgICAgIHJpbXJhZihwYXRoLmpvaW4ocCwgZiksIG9wdGlvbnMsIGVyID0+IHtcbiAgICAgICAgaWYgKGVyclN0YXRlKSB7XG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVyKSByZXR1cm4gY2IoZXJyU3RhdGUgPSBlcilcbiAgICAgICAgaWYgKC0tbiA9PT0gMCkge1xuICAgICAgICAgIG9wdGlvbnMucm1kaXIocCwgY2IpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfSlcbiAgfSlcbn1cblxuLy8gdGhpcyBsb29rcyBzaW1wbGVyLCBhbmQgaXMgc3RyaWN0bHkgKmZhc3RlciosIGJ1dCB3aWxsXG4vLyB0aWUgdXAgdGhlIEphdmFTY3JpcHQgdGhyZWFkIGFuZCBmYWlsIG9uIGV4Y2Vzc2l2ZWx5XG4vLyBkZWVwIGRpcmVjdG9yeSB0cmVlcy5cbmZ1bmN0aW9uIHJpbXJhZlN5bmMgKHAsIG9wdGlvbnMpIHtcbiAgbGV0IHN0XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge31cbiAgZGVmYXVsdHMob3B0aW9ucylcblxuICBhc3NlcnQocCwgJ3JpbXJhZjogbWlzc2luZyBwYXRoJylcbiAgYXNzZXJ0LnN0cmljdEVxdWFsKHR5cGVvZiBwLCAnc3RyaW5nJywgJ3JpbXJhZjogcGF0aCBzaG91bGQgYmUgYSBzdHJpbmcnKVxuICBhc3NlcnQob3B0aW9ucywgJ3JpbXJhZjogbWlzc2luZyBvcHRpb25zJylcbiAgYXNzZXJ0LnN0cmljdEVxdWFsKHR5cGVvZiBvcHRpb25zLCAnb2JqZWN0JywgJ3JpbXJhZjogb3B0aW9ucyBzaG91bGQgYmUgb2JqZWN0JylcblxuICB0cnkge1xuICAgIHN0ID0gb3B0aW9ucy5sc3RhdFN5bmMocClcbiAgfSBjYXRjaCAoZXIpIHtcbiAgICBpZiAoZXIuY29kZSA9PT0gJ0VOT0VOVCcpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIFdpbmRvd3MgY2FuIEVQRVJNIG9uIHN0YXQuICBMaWZlIGlzIHN1ZmZlcmluZy5cbiAgICBpZiAoZXIuY29kZSA9PT0gJ0VQRVJNJyAmJiBpc1dpbmRvd3MpIHtcbiAgICAgIGZpeFdpbkVQRVJNU3luYyhwLCBvcHRpb25zLCBlcilcbiAgICB9XG4gIH1cblxuICB0cnkge1xuICAgIC8vIHN1bm9zIGxldHMgdGhlIHJvb3QgdXNlciB1bmxpbmsgZGlyZWN0b3JpZXMsIHdoaWNoIGlzLi4uIHdlaXJkLlxuICAgIGlmIChzdCAmJiBzdC5pc0RpcmVjdG9yeSgpKSB7XG4gICAgICBybWRpclN5bmMocCwgb3B0aW9ucywgbnVsbClcbiAgICB9IGVsc2Uge1xuICAgICAgb3B0aW9ucy51bmxpbmtTeW5jKHApXG4gICAgfVxuICB9IGNhdGNoIChlcikge1xuICAgIGlmIChlci5jb2RlID09PSAnRU5PRU5UJykge1xuICAgICAgcmV0dXJuXG4gICAgfSBlbHNlIGlmIChlci5jb2RlID09PSAnRVBFUk0nKSB7XG4gICAgICByZXR1cm4gaXNXaW5kb3dzID8gZml4V2luRVBFUk1TeW5jKHAsIG9wdGlvbnMsIGVyKSA6IHJtZGlyU3luYyhwLCBvcHRpb25zLCBlcilcbiAgICB9IGVsc2UgaWYgKGVyLmNvZGUgIT09ICdFSVNESVInKSB7XG4gICAgICB0aHJvdyBlclxuICAgIH1cbiAgICBybWRpclN5bmMocCwgb3B0aW9ucywgZXIpXG4gIH1cbn1cblxuZnVuY3Rpb24gcm1kaXJTeW5jIChwLCBvcHRpb25zLCBvcmlnaW5hbEVyKSB7XG4gIGFzc2VydChwKVxuICBhc3NlcnQob3B0aW9ucylcbiAgaWYgKG9yaWdpbmFsRXIpIHtcbiAgICBhc3NlcnQob3JpZ2luYWxFciBpbnN0YW5jZW9mIEVycm9yKVxuICB9XG5cbiAgdHJ5IHtcbiAgICBvcHRpb25zLnJtZGlyU3luYyhwKVxuICB9IGNhdGNoIChlcikge1xuICAgIGlmIChlci5jb2RlID09PSAnRU5PVERJUicpIHtcbiAgICAgIHRocm93IG9yaWdpbmFsRXJcbiAgICB9IGVsc2UgaWYgKGVyLmNvZGUgPT09ICdFTk9URU1QVFknIHx8IGVyLmNvZGUgPT09ICdFRVhJU1QnIHx8IGVyLmNvZGUgPT09ICdFUEVSTScpIHtcbiAgICAgIHJta2lkc1N5bmMocCwgb3B0aW9ucylcbiAgICB9IGVsc2UgaWYgKGVyLmNvZGUgIT09ICdFTk9FTlQnKSB7XG4gICAgICB0aHJvdyBlclxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBybWtpZHNTeW5jIChwLCBvcHRpb25zKSB7XG4gIGFzc2VydChwKVxuICBhc3NlcnQob3B0aW9ucylcbiAgb3B0aW9ucy5yZWFkZGlyU3luYyhwKS5mb3JFYWNoKGYgPT4gcmltcmFmU3luYyhwYXRoLmpvaW4ocCwgZiksIG9wdGlvbnMpKVxuXG4gIGlmIChpc1dpbmRvd3MpIHtcbiAgICAvLyBXZSBvbmx5IGVuZCB1cCBoZXJlIG9uY2Ugd2UgZ290IEVOT1RFTVBUWSBhdCBsZWFzdCBvbmNlLCBhbmRcbiAgICAvLyBhdCB0aGlzIHBvaW50LCB3ZSBhcmUgZ3VhcmFudGVlZCB0byBoYXZlIHJlbW92ZWQgYWxsIHRoZSBraWRzLlxuICAgIC8vIFNvLCB3ZSBrbm93IHRoYXQgaXQgd29uJ3QgYmUgRU5PRU5UIG9yIEVOT1RESVIgb3IgYW55dGhpbmcgZWxzZS5cbiAgICAvLyB0cnkgcmVhbGx5IGhhcmQgdG8gZGVsZXRlIHN0dWZmIG9uIHdpbmRvd3MsIGJlY2F1c2UgaXQgaGFzIGFcbiAgICAvLyBQUk9GT1VORExZIGFubm95aW5nIGhhYml0IG9mIG5vdCBjbG9zaW5nIGhhbmRsZXMgcHJvbXB0bHkgd2hlblxuICAgIC8vIGZpbGVzIGFyZSBkZWxldGVkLCByZXN1bHRpbmcgaW4gc3B1cmlvdXMgRU5PVEVNUFRZIGVycm9ycy5cbiAgICBjb25zdCBzdGFydFRpbWUgPSBEYXRlLm5vdygpXG4gICAgZG8ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmV0ID0gb3B0aW9ucy5ybWRpclN5bmMocCwgb3B0aW9ucylcbiAgICAgICAgcmV0dXJuIHJldFxuICAgICAgfSBjYXRjaCAoZXIpIHsgfVxuICAgIH0gd2hpbGUgKERhdGUubm93KCkgLSBzdGFydFRpbWUgPCA1MDApIC8vIGdpdmUgdXAgYWZ0ZXIgNTAwbXNcbiAgfSBlbHNlIHtcbiAgICBjb25zdCByZXQgPSBvcHRpb25zLnJtZGlyU3luYyhwLCBvcHRpb25zKVxuICAgIHJldHVybiByZXRcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHJpbXJhZlxucmltcmFmLnN5bmMgPSByaW1yYWZTeW5jXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/fs-extra/lib/remove/rimraf.js\n");

/***/ }),

/***/ "./node_modules/fs-extra/lib/util/buffer.js":
/*!**************************************************!*\
  !*** ./node_modules/fs-extra/lib/util/buffer.js ***!
  \**************************************************/
/***/ ((module) => {

"use strict";
eval("\n/* eslint-disable node/no-deprecated-api */\nmodule.exports = function (size) {\n  if (typeof Buffer.allocUnsafe === 'function') {\n    try {\n      return Buffer.allocUnsafe(size)\n    } catch (e) {\n      return new Buffer(size)\n    }\n  }\n  return new Buffer(size)\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL3V0aWwvYnVmZmVyLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdG9kby1saXN0Ly4vbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi91dGlsL2J1ZmZlci5qcz81Y2NiIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuLyogZXNsaW50LWRpc2FibGUgbm9kZS9uby1kZXByZWNhdGVkLWFwaSAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICBpZiAodHlwZW9mIEJ1ZmZlci5hbGxvY1Vuc2FmZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gQnVmZmVyLmFsbG9jVW5zYWZlKHNpemUpXG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIG5ldyBCdWZmZXIoc2l6ZSlcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5ldyBCdWZmZXIoc2l6ZSlcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/fs-extra/lib/util/buffer.js\n");

/***/ }),

/***/ "./node_modules/fs-extra/lib/util/stat.js":
/*!************************************************!*\
  !*** ./node_modules/fs-extra/lib/util/stat.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst fs = __webpack_require__(/*! graceful-fs */ \"./node_modules/graceful-fs/graceful-fs.js\")\nconst path = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'path'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()))\n\nconst NODE_VERSION_MAJOR_WITH_BIGINT = 10\nconst NODE_VERSION_MINOR_WITH_BIGINT = 5\nconst NODE_VERSION_PATCH_WITH_BIGINT = 0\nconst nodeVersion = process.versions.node.split('.')\nconst nodeVersionMajor = Number.parseInt(nodeVersion[0], 10)\nconst nodeVersionMinor = Number.parseInt(nodeVersion[1], 10)\nconst nodeVersionPatch = Number.parseInt(nodeVersion[2], 10)\n\nfunction nodeSupportsBigInt () {\n  if (nodeVersionMajor > NODE_VERSION_MAJOR_WITH_BIGINT) {\n    return true\n  } else if (nodeVersionMajor === NODE_VERSION_MAJOR_WITH_BIGINT) {\n    if (nodeVersionMinor > NODE_VERSION_MINOR_WITH_BIGINT) {\n      return true\n    } else if (nodeVersionMinor === NODE_VERSION_MINOR_WITH_BIGINT) {\n      if (nodeVersionPatch >= NODE_VERSION_PATCH_WITH_BIGINT) {\n        return true\n      }\n    }\n  }\n  return false\n}\n\nfunction getStats (src, dest, cb) {\n  if (nodeSupportsBigInt()) {\n    fs.stat(src, { bigint: true }, (err, srcStat) => {\n      if (err) return cb(err)\n      fs.stat(dest, { bigint: true }, (err, destStat) => {\n        if (err) {\n          if (err.code === 'ENOENT') return cb(null, { srcStat, destStat: null })\n          return cb(err)\n        }\n        return cb(null, { srcStat, destStat })\n      })\n    })\n  } else {\n    fs.stat(src, (err, srcStat) => {\n      if (err) return cb(err)\n      fs.stat(dest, (err, destStat) => {\n        if (err) {\n          if (err.code === 'ENOENT') return cb(null, { srcStat, destStat: null })\n          return cb(err)\n        }\n        return cb(null, { srcStat, destStat })\n      })\n    })\n  }\n}\n\nfunction getStatsSync (src, dest) {\n  let srcStat, destStat\n  if (nodeSupportsBigInt()) {\n    srcStat = fs.statSync(src, { bigint: true })\n  } else {\n    srcStat = fs.statSync(src)\n  }\n  try {\n    if (nodeSupportsBigInt()) {\n      destStat = fs.statSync(dest, { bigint: true })\n    } else {\n      destStat = fs.statSync(dest)\n    }\n  } catch (err) {\n    if (err.code === 'ENOENT') return { srcStat, destStat: null }\n    throw err\n  }\n  return { srcStat, destStat }\n}\n\nfunction checkPaths (src, dest, funcName, cb) {\n  getStats(src, dest, (err, stats) => {\n    if (err) return cb(err)\n    const { srcStat, destStat } = stats\n    if (destStat && destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev) {\n      return cb(new Error('Source and destination must not be the same.'))\n    }\n    if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {\n      return cb(new Error(errMsg(src, dest, funcName)))\n    }\n    return cb(null, { srcStat, destStat })\n  })\n}\n\nfunction checkPathsSync (src, dest, funcName) {\n  const { srcStat, destStat } = getStatsSync(src, dest)\n  if (destStat && destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev) {\n    throw new Error('Source and destination must not be the same.')\n  }\n  if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {\n    throw new Error(errMsg(src, dest, funcName))\n  }\n  return { srcStat, destStat }\n}\n\n// recursively check if dest parent is a subdirectory of src.\n// It works for all file types including symlinks since it\n// checks the src and dest inodes. It starts from the deepest\n// parent and stops once it reaches the src parent or the root path.\nfunction checkParentPaths (src, srcStat, dest, funcName, cb) {\n  const srcParent = path.resolve(path.dirname(src))\n  const destParent = path.resolve(path.dirname(dest))\n  if (destParent === srcParent || destParent === path.parse(destParent).root) return cb()\n  if (nodeSupportsBigInt()) {\n    fs.stat(destParent, { bigint: true }, (err, destStat) => {\n      if (err) {\n        if (err.code === 'ENOENT') return cb()\n        return cb(err)\n      }\n      if (destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev) {\n        return cb(new Error(errMsg(src, dest, funcName)))\n      }\n      return checkParentPaths(src, srcStat, destParent, funcName, cb)\n    })\n  } else {\n    fs.stat(destParent, (err, destStat) => {\n      if (err) {\n        if (err.code === 'ENOENT') return cb()\n        return cb(err)\n      }\n      if (destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev) {\n        return cb(new Error(errMsg(src, dest, funcName)))\n      }\n      return checkParentPaths(src, srcStat, destParent, funcName, cb)\n    })\n  }\n}\n\nfunction checkParentPathsSync (src, srcStat, dest, funcName) {\n  const srcParent = path.resolve(path.dirname(src))\n  const destParent = path.resolve(path.dirname(dest))\n  if (destParent === srcParent || destParent === path.parse(destParent).root) return\n  let destStat\n  try {\n    if (nodeSupportsBigInt()) {\n      destStat = fs.statSync(destParent, { bigint: true })\n    } else {\n      destStat = fs.statSync(destParent)\n    }\n  } catch (err) {\n    if (err.code === 'ENOENT') return\n    throw err\n  }\n  if (destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev) {\n    throw new Error(errMsg(src, dest, funcName))\n  }\n  return checkParentPathsSync(src, srcStat, destParent, funcName)\n}\n\n// return true if dest is a subdir of src, otherwise false.\n// It only checks the path strings.\nfunction isSrcSubdir (src, dest) {\n  const srcArr = path.resolve(src).split(path.sep).filter(i => i)\n  const destArr = path.resolve(dest).split(path.sep).filter(i => i)\n  return srcArr.reduce((acc, cur, i) => acc && destArr[i] === cur, true)\n}\n\nfunction errMsg (src, dest, funcName) {\n  return `Cannot ${funcName} '${src}' to a subdirectory of itself, '${dest}'.`\n}\n\nmodule.exports = {\n  checkPaths,\n  checkPathsSync,\n  checkParentPaths,\n  checkParentPathsSync,\n  isSrcSubdir\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL3V0aWwvc3RhdC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixXQUFXLG1CQUFPLENBQUMsOERBQWE7QUFDaEMsYUFBYSxtQkFBTyxDQUFDLG1JQUFNOztBQUUzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLGNBQWM7QUFDakM7QUFDQSxzQkFBc0IsY0FBYztBQUNwQztBQUNBLHVEQUF1RCx5QkFBeUI7QUFDaEY7QUFDQTtBQUNBLDBCQUEwQixtQkFBbUI7QUFDN0MsT0FBTztBQUNQLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQseUJBQXlCO0FBQ2hGO0FBQ0E7QUFDQSwwQkFBMEIsbUJBQW1CO0FBQzdDLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsY0FBYztBQUMvQyxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsY0FBYztBQUNuRCxNQUFNO0FBQ047QUFDQTtBQUNBLElBQUk7QUFDSix3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG9CQUFvQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsbUJBQW1CO0FBQ3pDLEdBQUc7QUFDSDs7QUFFQTtBQUNBLFVBQVUsb0JBQW9CO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsY0FBYztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxjQUFjO0FBQ3pELE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsVUFBVSxHQUFHLElBQUksa0NBQWtDLEtBQUs7QUFDM0U7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90b2RvLWxpc3QvLi9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL3V0aWwvc3RhdC5qcz9mMTU1Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBmcyA9IHJlcXVpcmUoJ2dyYWNlZnVsLWZzJylcbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJylcblxuY29uc3QgTk9ERV9WRVJTSU9OX01BSk9SX1dJVEhfQklHSU5UID0gMTBcbmNvbnN0IE5PREVfVkVSU0lPTl9NSU5PUl9XSVRIX0JJR0lOVCA9IDVcbmNvbnN0IE5PREVfVkVSU0lPTl9QQVRDSF9XSVRIX0JJR0lOVCA9IDBcbmNvbnN0IG5vZGVWZXJzaW9uID0gcHJvY2Vzcy52ZXJzaW9ucy5ub2RlLnNwbGl0KCcuJylcbmNvbnN0IG5vZGVWZXJzaW9uTWFqb3IgPSBOdW1iZXIucGFyc2VJbnQobm9kZVZlcnNpb25bMF0sIDEwKVxuY29uc3Qgbm9kZVZlcnNpb25NaW5vciA9IE51bWJlci5wYXJzZUludChub2RlVmVyc2lvblsxXSwgMTApXG5jb25zdCBub2RlVmVyc2lvblBhdGNoID0gTnVtYmVyLnBhcnNlSW50KG5vZGVWZXJzaW9uWzJdLCAxMClcblxuZnVuY3Rpb24gbm9kZVN1cHBvcnRzQmlnSW50ICgpIHtcbiAgaWYgKG5vZGVWZXJzaW9uTWFqb3IgPiBOT0RFX1ZFUlNJT05fTUFKT1JfV0lUSF9CSUdJTlQpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9IGVsc2UgaWYgKG5vZGVWZXJzaW9uTWFqb3IgPT09IE5PREVfVkVSU0lPTl9NQUpPUl9XSVRIX0JJR0lOVCkge1xuICAgIGlmIChub2RlVmVyc2lvbk1pbm9yID4gTk9ERV9WRVJTSU9OX01JTk9SX1dJVEhfQklHSU5UKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH0gZWxzZSBpZiAobm9kZVZlcnNpb25NaW5vciA9PT0gTk9ERV9WRVJTSU9OX01JTk9SX1dJVEhfQklHSU5UKSB7XG4gICAgICBpZiAobm9kZVZlcnNpb25QYXRjaCA+PSBOT0RFX1ZFUlNJT05fUEFUQ0hfV0lUSF9CSUdJTlQpIHtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbmZ1bmN0aW9uIGdldFN0YXRzIChzcmMsIGRlc3QsIGNiKSB7XG4gIGlmIChub2RlU3VwcG9ydHNCaWdJbnQoKSkge1xuICAgIGZzLnN0YXQoc3JjLCB7IGJpZ2ludDogdHJ1ZSB9LCAoZXJyLCBzcmNTdGF0KSA9PiB7XG4gICAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKVxuICAgICAgZnMuc3RhdChkZXN0LCB7IGJpZ2ludDogdHJ1ZSB9LCAoZXJyLCBkZXN0U3RhdCkgPT4ge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgaWYgKGVyci5jb2RlID09PSAnRU5PRU5UJykgcmV0dXJuIGNiKG51bGwsIHsgc3JjU3RhdCwgZGVzdFN0YXQ6IG51bGwgfSlcbiAgICAgICAgICByZXR1cm4gY2IoZXJyKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjYihudWxsLCB7IHNyY1N0YXQsIGRlc3RTdGF0IH0pXG4gICAgICB9KVxuICAgIH0pXG4gIH0gZWxzZSB7XG4gICAgZnMuc3RhdChzcmMsIChlcnIsIHNyY1N0YXQpID0+IHtcbiAgICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpXG4gICAgICBmcy5zdGF0KGRlc3QsIChlcnIsIGRlc3RTdGF0KSA9PiB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICBpZiAoZXJyLmNvZGUgPT09ICdFTk9FTlQnKSByZXR1cm4gY2IobnVsbCwgeyBzcmNTdGF0LCBkZXN0U3RhdDogbnVsbCB9KVxuICAgICAgICAgIHJldHVybiBjYihlcnIpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNiKG51bGwsIHsgc3JjU3RhdCwgZGVzdFN0YXQgfSlcbiAgICAgIH0pXG4gICAgfSlcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRTdGF0c1N5bmMgKHNyYywgZGVzdCkge1xuICBsZXQgc3JjU3RhdCwgZGVzdFN0YXRcbiAgaWYgKG5vZGVTdXBwb3J0c0JpZ0ludCgpKSB7XG4gICAgc3JjU3RhdCA9IGZzLnN0YXRTeW5jKHNyYywgeyBiaWdpbnQ6IHRydWUgfSlcbiAgfSBlbHNlIHtcbiAgICBzcmNTdGF0ID0gZnMuc3RhdFN5bmMoc3JjKVxuICB9XG4gIHRyeSB7XG4gICAgaWYgKG5vZGVTdXBwb3J0c0JpZ0ludCgpKSB7XG4gICAgICBkZXN0U3RhdCA9IGZzLnN0YXRTeW5jKGRlc3QsIHsgYmlnaW50OiB0cnVlIH0pXG4gICAgfSBlbHNlIHtcbiAgICAgIGRlc3RTdGF0ID0gZnMuc3RhdFN5bmMoZGVzdClcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGlmIChlcnIuY29kZSA9PT0gJ0VOT0VOVCcpIHJldHVybiB7IHNyY1N0YXQsIGRlc3RTdGF0OiBudWxsIH1cbiAgICB0aHJvdyBlcnJcbiAgfVxuICByZXR1cm4geyBzcmNTdGF0LCBkZXN0U3RhdCB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrUGF0aHMgKHNyYywgZGVzdCwgZnVuY05hbWUsIGNiKSB7XG4gIGdldFN0YXRzKHNyYywgZGVzdCwgKGVyciwgc3RhdHMpID0+IHtcbiAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKVxuICAgIGNvbnN0IHsgc3JjU3RhdCwgZGVzdFN0YXQgfSA9IHN0YXRzXG4gICAgaWYgKGRlc3RTdGF0ICYmIGRlc3RTdGF0LmlubyAmJiBkZXN0U3RhdC5kZXYgJiYgZGVzdFN0YXQuaW5vID09PSBzcmNTdGF0LmlubyAmJiBkZXN0U3RhdC5kZXYgPT09IHNyY1N0YXQuZGV2KSB7XG4gICAgICByZXR1cm4gY2IobmV3IEVycm9yKCdTb3VyY2UgYW5kIGRlc3RpbmF0aW9uIG11c3Qgbm90IGJlIHRoZSBzYW1lLicpKVxuICAgIH1cbiAgICBpZiAoc3JjU3RhdC5pc0RpcmVjdG9yeSgpICYmIGlzU3JjU3ViZGlyKHNyYywgZGVzdCkpIHtcbiAgICAgIHJldHVybiBjYihuZXcgRXJyb3IoZXJyTXNnKHNyYywgZGVzdCwgZnVuY05hbWUpKSlcbiAgICB9XG4gICAgcmV0dXJuIGNiKG51bGwsIHsgc3JjU3RhdCwgZGVzdFN0YXQgfSlcbiAgfSlcbn1cblxuZnVuY3Rpb24gY2hlY2tQYXRoc1N5bmMgKHNyYywgZGVzdCwgZnVuY05hbWUpIHtcbiAgY29uc3QgeyBzcmNTdGF0LCBkZXN0U3RhdCB9ID0gZ2V0U3RhdHNTeW5jKHNyYywgZGVzdClcbiAgaWYgKGRlc3RTdGF0ICYmIGRlc3RTdGF0LmlubyAmJiBkZXN0U3RhdC5kZXYgJiYgZGVzdFN0YXQuaW5vID09PSBzcmNTdGF0LmlubyAmJiBkZXN0U3RhdC5kZXYgPT09IHNyY1N0YXQuZGV2KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdTb3VyY2UgYW5kIGRlc3RpbmF0aW9uIG11c3Qgbm90IGJlIHRoZSBzYW1lLicpXG4gIH1cbiAgaWYgKHNyY1N0YXQuaXNEaXJlY3RvcnkoKSAmJiBpc1NyY1N1YmRpcihzcmMsIGRlc3QpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGVyck1zZyhzcmMsIGRlc3QsIGZ1bmNOYW1lKSlcbiAgfVxuICByZXR1cm4geyBzcmNTdGF0LCBkZXN0U3RhdCB9XG59XG5cbi8vIHJlY3Vyc2l2ZWx5IGNoZWNrIGlmIGRlc3QgcGFyZW50IGlzIGEgc3ViZGlyZWN0b3J5IG9mIHNyYy5cbi8vIEl0IHdvcmtzIGZvciBhbGwgZmlsZSB0eXBlcyBpbmNsdWRpbmcgc3ltbGlua3Mgc2luY2UgaXRcbi8vIGNoZWNrcyB0aGUgc3JjIGFuZCBkZXN0IGlub2Rlcy4gSXQgc3RhcnRzIGZyb20gdGhlIGRlZXBlc3Rcbi8vIHBhcmVudCBhbmQgc3RvcHMgb25jZSBpdCByZWFjaGVzIHRoZSBzcmMgcGFyZW50IG9yIHRoZSByb290IHBhdGguXG5mdW5jdGlvbiBjaGVja1BhcmVudFBhdGhzIChzcmMsIHNyY1N0YXQsIGRlc3QsIGZ1bmNOYW1lLCBjYikge1xuICBjb25zdCBzcmNQYXJlbnQgPSBwYXRoLnJlc29sdmUocGF0aC5kaXJuYW1lKHNyYykpXG4gIGNvbnN0IGRlc3RQYXJlbnQgPSBwYXRoLnJlc29sdmUocGF0aC5kaXJuYW1lKGRlc3QpKVxuICBpZiAoZGVzdFBhcmVudCA9PT0gc3JjUGFyZW50IHx8IGRlc3RQYXJlbnQgPT09IHBhdGgucGFyc2UoZGVzdFBhcmVudCkucm9vdCkgcmV0dXJuIGNiKClcbiAgaWYgKG5vZGVTdXBwb3J0c0JpZ0ludCgpKSB7XG4gICAgZnMuc3RhdChkZXN0UGFyZW50LCB7IGJpZ2ludDogdHJ1ZSB9LCAoZXJyLCBkZXN0U3RhdCkgPT4ge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICBpZiAoZXJyLmNvZGUgPT09ICdFTk9FTlQnKSByZXR1cm4gY2IoKVxuICAgICAgICByZXR1cm4gY2IoZXJyKVxuICAgICAgfVxuICAgICAgaWYgKGRlc3RTdGF0LmlubyAmJiBkZXN0U3RhdC5kZXYgJiYgZGVzdFN0YXQuaW5vID09PSBzcmNTdGF0LmlubyAmJiBkZXN0U3RhdC5kZXYgPT09IHNyY1N0YXQuZGV2KSB7XG4gICAgICAgIHJldHVybiBjYihuZXcgRXJyb3IoZXJyTXNnKHNyYywgZGVzdCwgZnVuY05hbWUpKSlcbiAgICAgIH1cbiAgICAgIHJldHVybiBjaGVja1BhcmVudFBhdGhzKHNyYywgc3JjU3RhdCwgZGVzdFBhcmVudCwgZnVuY05hbWUsIGNiKVxuICAgIH0pXG4gIH0gZWxzZSB7XG4gICAgZnMuc3RhdChkZXN0UGFyZW50LCAoZXJyLCBkZXN0U3RhdCkgPT4ge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICBpZiAoZXJyLmNvZGUgPT09ICdFTk9FTlQnKSByZXR1cm4gY2IoKVxuICAgICAgICByZXR1cm4gY2IoZXJyKVxuICAgICAgfVxuICAgICAgaWYgKGRlc3RTdGF0LmlubyAmJiBkZXN0U3RhdC5kZXYgJiYgZGVzdFN0YXQuaW5vID09PSBzcmNTdGF0LmlubyAmJiBkZXN0U3RhdC5kZXYgPT09IHNyY1N0YXQuZGV2KSB7XG4gICAgICAgIHJldHVybiBjYihuZXcgRXJyb3IoZXJyTXNnKHNyYywgZGVzdCwgZnVuY05hbWUpKSlcbiAgICAgIH1cbiAgICAgIHJldHVybiBjaGVja1BhcmVudFBhdGhzKHNyYywgc3JjU3RhdCwgZGVzdFBhcmVudCwgZnVuY05hbWUsIGNiKVxuICAgIH0pXG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tQYXJlbnRQYXRoc1N5bmMgKHNyYywgc3JjU3RhdCwgZGVzdCwgZnVuY05hbWUpIHtcbiAgY29uc3Qgc3JjUGFyZW50ID0gcGF0aC5yZXNvbHZlKHBhdGguZGlybmFtZShzcmMpKVxuICBjb25zdCBkZXN0UGFyZW50ID0gcGF0aC5yZXNvbHZlKHBhdGguZGlybmFtZShkZXN0KSlcbiAgaWYgKGRlc3RQYXJlbnQgPT09IHNyY1BhcmVudCB8fCBkZXN0UGFyZW50ID09PSBwYXRoLnBhcnNlKGRlc3RQYXJlbnQpLnJvb3QpIHJldHVyblxuICBsZXQgZGVzdFN0YXRcbiAgdHJ5IHtcbiAgICBpZiAobm9kZVN1cHBvcnRzQmlnSW50KCkpIHtcbiAgICAgIGRlc3RTdGF0ID0gZnMuc3RhdFN5bmMoZGVzdFBhcmVudCwgeyBiaWdpbnQ6IHRydWUgfSlcbiAgICB9IGVsc2Uge1xuICAgICAgZGVzdFN0YXQgPSBmcy5zdGF0U3luYyhkZXN0UGFyZW50KVxuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgaWYgKGVyci5jb2RlID09PSAnRU5PRU5UJykgcmV0dXJuXG4gICAgdGhyb3cgZXJyXG4gIH1cbiAgaWYgKGRlc3RTdGF0LmlubyAmJiBkZXN0U3RhdC5kZXYgJiYgZGVzdFN0YXQuaW5vID09PSBzcmNTdGF0LmlubyAmJiBkZXN0U3RhdC5kZXYgPT09IHNyY1N0YXQuZGV2KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGVyck1zZyhzcmMsIGRlc3QsIGZ1bmNOYW1lKSlcbiAgfVxuICByZXR1cm4gY2hlY2tQYXJlbnRQYXRoc1N5bmMoc3JjLCBzcmNTdGF0LCBkZXN0UGFyZW50LCBmdW5jTmFtZSlcbn1cblxuLy8gcmV0dXJuIHRydWUgaWYgZGVzdCBpcyBhIHN1YmRpciBvZiBzcmMsIG90aGVyd2lzZSBmYWxzZS5cbi8vIEl0IG9ubHkgY2hlY2tzIHRoZSBwYXRoIHN0cmluZ3MuXG5mdW5jdGlvbiBpc1NyY1N1YmRpciAoc3JjLCBkZXN0KSB7XG4gIGNvbnN0IHNyY0FyciA9IHBhdGgucmVzb2x2ZShzcmMpLnNwbGl0KHBhdGguc2VwKS5maWx0ZXIoaSA9PiBpKVxuICBjb25zdCBkZXN0QXJyID0gcGF0aC5yZXNvbHZlKGRlc3QpLnNwbGl0KHBhdGguc2VwKS5maWx0ZXIoaSA9PiBpKVxuICByZXR1cm4gc3JjQXJyLnJlZHVjZSgoYWNjLCBjdXIsIGkpID0+IGFjYyAmJiBkZXN0QXJyW2ldID09PSBjdXIsIHRydWUpXG59XG5cbmZ1bmN0aW9uIGVyck1zZyAoc3JjLCBkZXN0LCBmdW5jTmFtZSkge1xuICByZXR1cm4gYENhbm5vdCAke2Z1bmNOYW1lfSAnJHtzcmN9JyB0byBhIHN1YmRpcmVjdG9yeSBvZiBpdHNlbGYsICcke2Rlc3R9Jy5gXG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBjaGVja1BhdGhzLFxuICBjaGVja1BhdGhzU3luYyxcbiAgY2hlY2tQYXJlbnRQYXRocyxcbiAgY2hlY2tQYXJlbnRQYXRoc1N5bmMsXG4gIGlzU3JjU3ViZGlyXG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/fs-extra/lib/util/stat.js\n");

/***/ }),

/***/ "./node_modules/fs-extra/lib/util/utimes.js":
/*!**************************************************!*\
  !*** ./node_modules/fs-extra/lib/util/utimes.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst fs = __webpack_require__(/*! graceful-fs */ \"./node_modules/graceful-fs/graceful-fs.js\")\nconst os = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'os'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()))\nconst path = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'path'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()))\n\n// HFS, ext{2,3}, FAT do not, Node.js v0.10 does not\nfunction hasMillisResSync () {\n  let tmpfile = path.join('millis-test-sync' + Date.now().toString() + Math.random().toString().slice(2))\n  tmpfile = path.join(os.tmpdir(), tmpfile)\n\n  // 550 millis past UNIX epoch\n  const d = new Date(1435410243862)\n  fs.writeFileSync(tmpfile, 'https://github.com/jprichardson/node-fs-extra/pull/141')\n  const fd = fs.openSync(tmpfile, 'r+')\n  fs.futimesSync(fd, d, d)\n  fs.closeSync(fd)\n  return fs.statSync(tmpfile).mtime > 1435410243000\n}\n\nfunction hasMillisRes (callback) {\n  let tmpfile = path.join('millis-test' + Date.now().toString() + Math.random().toString().slice(2))\n  tmpfile = path.join(os.tmpdir(), tmpfile)\n\n  // 550 millis past UNIX epoch\n  const d = new Date(1435410243862)\n  fs.writeFile(tmpfile, 'https://github.com/jprichardson/node-fs-extra/pull/141', err => {\n    if (err) return callback(err)\n    fs.open(tmpfile, 'r+', (err, fd) => {\n      if (err) return callback(err)\n      fs.futimes(fd, d, d, err => {\n        if (err) return callback(err)\n        fs.close(fd, err => {\n          if (err) return callback(err)\n          fs.stat(tmpfile, (err, stats) => {\n            if (err) return callback(err)\n            callback(null, stats.mtime > 1435410243000)\n          })\n        })\n      })\n    })\n  })\n}\n\nfunction timeRemoveMillis (timestamp) {\n  if (typeof timestamp === 'number') {\n    return Math.floor(timestamp / 1000) * 1000\n  } else if (timestamp instanceof Date) {\n    return new Date(Math.floor(timestamp.getTime() / 1000) * 1000)\n  } else {\n    throw new Error('fs-extra: timeRemoveMillis() unknown parameter type')\n  }\n}\n\nfunction utimesMillis (path, atime, mtime, callback) {\n  // if (!HAS_MILLIS_RES) return fs.utimes(path, atime, mtime, callback)\n  fs.open(path, 'r+', (err, fd) => {\n    if (err) return callback(err)\n    fs.futimes(fd, atime, mtime, futimesErr => {\n      fs.close(fd, closeErr => {\n        if (callback) callback(futimesErr || closeErr)\n      })\n    })\n  })\n}\n\nfunction utimesMillisSync (path, atime, mtime) {\n  const fd = fs.openSync(path, 'r+')\n  fs.futimesSync(fd, atime, mtime)\n  return fs.closeSync(fd)\n}\n\nmodule.exports = {\n  hasMillisRes,\n  hasMillisResSync,\n  timeRemoveMillis,\n  utimesMillis,\n  utimesMillisSync\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL3V0aWwvdXRpbWVzLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLFdBQVcsbUJBQU8sQ0FBQyw4REFBYTtBQUNoQyxXQUFXLG1CQUFPLENBQUMsaUlBQUk7QUFDdkIsYUFBYSxtQkFBTyxDQUFDLG1JQUFNOztBQUUzQixZQUFZLElBQUk7QUFDaEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVCxPQUFPO0FBQ1AsS0FBSztBQUNMLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTCxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3RvZG8tbGlzdC8uL25vZGVfbW9kdWxlcy9mcy1leHRyYS9saWIvdXRpbC91dGltZXMuanM/OWIxZSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgZnMgPSByZXF1aXJlKCdncmFjZWZ1bC1mcycpXG5jb25zdCBvcyA9IHJlcXVpcmUoJ29zJylcbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJylcblxuLy8gSEZTLCBleHR7MiwzfSwgRkFUIGRvIG5vdCwgTm9kZS5qcyB2MC4xMCBkb2VzIG5vdFxuZnVuY3Rpb24gaGFzTWlsbGlzUmVzU3luYyAoKSB7XG4gIGxldCB0bXBmaWxlID0gcGF0aC5qb2luKCdtaWxsaXMtdGVzdC1zeW5jJyArIERhdGUubm93KCkudG9TdHJpbmcoKSArIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoKS5zbGljZSgyKSlcbiAgdG1wZmlsZSA9IHBhdGguam9pbihvcy50bXBkaXIoKSwgdG1wZmlsZSlcblxuICAvLyA1NTAgbWlsbGlzIHBhc3QgVU5JWCBlcG9jaFxuICBjb25zdCBkID0gbmV3IERhdGUoMTQzNTQxMDI0Mzg2MilcbiAgZnMud3JpdGVGaWxlU3luYyh0bXBmaWxlLCAnaHR0cHM6Ly9naXRodWIuY29tL2pwcmljaGFyZHNvbi9ub2RlLWZzLWV4dHJhL3B1bGwvMTQxJylcbiAgY29uc3QgZmQgPSBmcy5vcGVuU3luYyh0bXBmaWxlLCAncisnKVxuICBmcy5mdXRpbWVzU3luYyhmZCwgZCwgZClcbiAgZnMuY2xvc2VTeW5jKGZkKVxuICByZXR1cm4gZnMuc3RhdFN5bmModG1wZmlsZSkubXRpbWUgPiAxNDM1NDEwMjQzMDAwXG59XG5cbmZ1bmN0aW9uIGhhc01pbGxpc1JlcyAoY2FsbGJhY2spIHtcbiAgbGV0IHRtcGZpbGUgPSBwYXRoLmpvaW4oJ21pbGxpcy10ZXN0JyArIERhdGUubm93KCkudG9TdHJpbmcoKSArIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoKS5zbGljZSgyKSlcbiAgdG1wZmlsZSA9IHBhdGguam9pbihvcy50bXBkaXIoKSwgdG1wZmlsZSlcblxuICAvLyA1NTAgbWlsbGlzIHBhc3QgVU5JWCBlcG9jaFxuICBjb25zdCBkID0gbmV3IERhdGUoMTQzNTQxMDI0Mzg2MilcbiAgZnMud3JpdGVGaWxlKHRtcGZpbGUsICdodHRwczovL2dpdGh1Yi5jb20vanByaWNoYXJkc29uL25vZGUtZnMtZXh0cmEvcHVsbC8xNDEnLCBlcnIgPT4ge1xuICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgZnMub3Blbih0bXBmaWxlLCAncisnLCAoZXJyLCBmZCkgPT4ge1xuICAgICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycilcbiAgICAgIGZzLmZ1dGltZXMoZmQsIGQsIGQsIGVyciA9PiB7XG4gICAgICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgICAgIGZzLmNsb3NlKGZkLCBlcnIgPT4ge1xuICAgICAgICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgICAgICAgZnMuc3RhdCh0bXBmaWxlLCAoZXJyLCBzdGF0cykgPT4ge1xuICAgICAgICAgICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycilcbiAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHN0YXRzLm10aW1lID4gMTQzNTQxMDI0MzAwMClcbiAgICAgICAgICB9KVxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICB9KVxuICB9KVxufVxuXG5mdW5jdGlvbiB0aW1lUmVtb3ZlTWlsbGlzICh0aW1lc3RhbXApIHtcbiAgaWYgKHR5cGVvZiB0aW1lc3RhbXAgPT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIE1hdGguZmxvb3IodGltZXN0YW1wIC8gMTAwMCkgKiAxMDAwXG4gIH0gZWxzZSBpZiAodGltZXN0YW1wIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgIHJldHVybiBuZXcgRGF0ZShNYXRoLmZsb29yKHRpbWVzdGFtcC5nZXRUaW1lKCkgLyAxMDAwKSAqIDEwMDApXG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdmcy1leHRyYTogdGltZVJlbW92ZU1pbGxpcygpIHVua25vd24gcGFyYW1ldGVyIHR5cGUnKVxuICB9XG59XG5cbmZ1bmN0aW9uIHV0aW1lc01pbGxpcyAocGF0aCwgYXRpbWUsIG10aW1lLCBjYWxsYmFjaykge1xuICAvLyBpZiAoIUhBU19NSUxMSVNfUkVTKSByZXR1cm4gZnMudXRpbWVzKHBhdGgsIGF0aW1lLCBtdGltZSwgY2FsbGJhY2spXG4gIGZzLm9wZW4ocGF0aCwgJ3IrJywgKGVyciwgZmQpID0+IHtcbiAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKVxuICAgIGZzLmZ1dGltZXMoZmQsIGF0aW1lLCBtdGltZSwgZnV0aW1lc0VyciA9PiB7XG4gICAgICBmcy5jbG9zZShmZCwgY2xvc2VFcnIgPT4ge1xuICAgICAgICBpZiAoY2FsbGJhY2spIGNhbGxiYWNrKGZ1dGltZXNFcnIgfHwgY2xvc2VFcnIpXG4gICAgICB9KVxuICAgIH0pXG4gIH0pXG59XG5cbmZ1bmN0aW9uIHV0aW1lc01pbGxpc1N5bmMgKHBhdGgsIGF0aW1lLCBtdGltZSkge1xuICBjb25zdCBmZCA9IGZzLm9wZW5TeW5jKHBhdGgsICdyKycpXG4gIGZzLmZ1dGltZXNTeW5jKGZkLCBhdGltZSwgbXRpbWUpXG4gIHJldHVybiBmcy5jbG9zZVN5bmMoZmQpXG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBoYXNNaWxsaXNSZXMsXG4gIGhhc01pbGxpc1Jlc1N5bmMsXG4gIHRpbWVSZW1vdmVNaWxsaXMsXG4gIHV0aW1lc01pbGxpcyxcbiAgdXRpbWVzTWlsbGlzU3luY1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/fs-extra/lib/util/utimes.js\n");

/***/ }),

/***/ "./node_modules/fs.realpath/index.js":
/*!*******************************************!*\
  !*** ./node_modules/fs.realpath/index.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = realpath\nrealpath.realpath = realpath\nrealpath.sync = realpathSync\nrealpath.realpathSync = realpathSync\nrealpath.monkeypatch = monkeypatch\nrealpath.unmonkeypatch = unmonkeypatch\n\nvar fs = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'fs'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()))\nvar origRealpath = fs.realpath\nvar origRealpathSync = fs.realpathSync\n\nvar version = process.version\nvar ok = /^v[0-5]\\./.test(version)\nvar old = __webpack_require__(/*! ./old.js */ \"./node_modules/fs.realpath/old.js\")\n\nfunction newError (er) {\n  return er && er.syscall === 'realpath' && (\n    er.code === 'ELOOP' ||\n    er.code === 'ENOMEM' ||\n    er.code === 'ENAMETOOLONG'\n  )\n}\n\nfunction realpath (p, cache, cb) {\n  if (ok) {\n    return origRealpath(p, cache, cb)\n  }\n\n  if (typeof cache === 'function') {\n    cb = cache\n    cache = null\n  }\n  origRealpath(p, cache, function (er, result) {\n    if (newError(er)) {\n      old.realpath(p, cache, cb)\n    } else {\n      cb(er, result)\n    }\n  })\n}\n\nfunction realpathSync (p, cache) {\n  if (ok) {\n    return origRealpathSync(p, cache)\n  }\n\n  try {\n    return origRealpathSync(p, cache)\n  } catch (er) {\n    if (newError(er)) {\n      return old.realpathSync(p, cache)\n    } else {\n      throw er\n    }\n  }\n}\n\nfunction monkeypatch () {\n  fs.realpath = realpath\n  fs.realpathSync = realpathSync\n}\n\nfunction unmonkeypatch () {\n  fs.realpath = origRealpath\n  fs.realpathSync = origRealpathSync\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZnMucmVhbHBhdGgvaW5kZXguanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVMsbUJBQU8sQ0FBQyxpSUFBSTtBQUNyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVLG1CQUFPLENBQUMsbURBQVU7O0FBRTVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdG9kby1saXN0Ly4vbm9kZV9tb2R1bGVzL2ZzLnJlYWxwYXRoL2luZGV4LmpzPzY5MzIiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSByZWFscGF0aFxucmVhbHBhdGgucmVhbHBhdGggPSByZWFscGF0aFxucmVhbHBhdGguc3luYyA9IHJlYWxwYXRoU3luY1xucmVhbHBhdGgucmVhbHBhdGhTeW5jID0gcmVhbHBhdGhTeW5jXG5yZWFscGF0aC5tb25rZXlwYXRjaCA9IG1vbmtleXBhdGNoXG5yZWFscGF0aC51bm1vbmtleXBhdGNoID0gdW5tb25rZXlwYXRjaFxuXG52YXIgZnMgPSByZXF1aXJlKCdmcycpXG52YXIgb3JpZ1JlYWxwYXRoID0gZnMucmVhbHBhdGhcbnZhciBvcmlnUmVhbHBhdGhTeW5jID0gZnMucmVhbHBhdGhTeW5jXG5cbnZhciB2ZXJzaW9uID0gcHJvY2Vzcy52ZXJzaW9uXG52YXIgb2sgPSAvXnZbMC01XVxcLi8udGVzdCh2ZXJzaW9uKVxudmFyIG9sZCA9IHJlcXVpcmUoJy4vb2xkLmpzJylcblxuZnVuY3Rpb24gbmV3RXJyb3IgKGVyKSB7XG4gIHJldHVybiBlciAmJiBlci5zeXNjYWxsID09PSAncmVhbHBhdGgnICYmIChcbiAgICBlci5jb2RlID09PSAnRUxPT1AnIHx8XG4gICAgZXIuY29kZSA9PT0gJ0VOT01FTScgfHxcbiAgICBlci5jb2RlID09PSAnRU5BTUVUT09MT05HJ1xuICApXG59XG5cbmZ1bmN0aW9uIHJlYWxwYXRoIChwLCBjYWNoZSwgY2IpIHtcbiAgaWYgKG9rKSB7XG4gICAgcmV0dXJuIG9yaWdSZWFscGF0aChwLCBjYWNoZSwgY2IpXG4gIH1cblxuICBpZiAodHlwZW9mIGNhY2hlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBjYWNoZVxuICAgIGNhY2hlID0gbnVsbFxuICB9XG4gIG9yaWdSZWFscGF0aChwLCBjYWNoZSwgZnVuY3Rpb24gKGVyLCByZXN1bHQpIHtcbiAgICBpZiAobmV3RXJyb3IoZXIpKSB7XG4gICAgICBvbGQucmVhbHBhdGgocCwgY2FjaGUsIGNiKVxuICAgIH0gZWxzZSB7XG4gICAgICBjYihlciwgcmVzdWx0KVxuICAgIH1cbiAgfSlcbn1cblxuZnVuY3Rpb24gcmVhbHBhdGhTeW5jIChwLCBjYWNoZSkge1xuICBpZiAob2spIHtcbiAgICByZXR1cm4gb3JpZ1JlYWxwYXRoU3luYyhwLCBjYWNoZSlcbiAgfVxuXG4gIHRyeSB7XG4gICAgcmV0dXJuIG9yaWdSZWFscGF0aFN5bmMocCwgY2FjaGUpXG4gIH0gY2F0Y2ggKGVyKSB7XG4gICAgaWYgKG5ld0Vycm9yKGVyKSkge1xuICAgICAgcmV0dXJuIG9sZC5yZWFscGF0aFN5bmMocCwgY2FjaGUpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IGVyXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIG1vbmtleXBhdGNoICgpIHtcbiAgZnMucmVhbHBhdGggPSByZWFscGF0aFxuICBmcy5yZWFscGF0aFN5bmMgPSByZWFscGF0aFN5bmNcbn1cblxuZnVuY3Rpb24gdW5tb25rZXlwYXRjaCAoKSB7XG4gIGZzLnJlYWxwYXRoID0gb3JpZ1JlYWxwYXRoXG4gIGZzLnJlYWxwYXRoU3luYyA9IG9yaWdSZWFscGF0aFN5bmNcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/fs.realpath/index.js\n");

/***/ }),

/***/ "./node_modules/fs.realpath/old.js":
/*!*****************************************!*\
  !*** ./node_modules/fs.realpath/old.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar pathModule = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'path'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\nvar isWindows = process.platform === 'win32';\nvar fs = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'fs'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\n\n// JavaScript implementation of realpath, ported from node pre-v6\n\nvar DEBUG = process.env.NODE_DEBUG && /fs/.test(process.env.NODE_DEBUG);\n\nfunction rethrow() {\n  // Only enable in debug mode. A backtrace uses ~1000 bytes of heap space and\n  // is fairly slow to generate.\n  var callback;\n  if (DEBUG) {\n    var backtrace = new Error;\n    callback = debugCallback;\n  } else\n    callback = missingCallback;\n\n  return callback;\n\n  function debugCallback(err) {\n    if (err) {\n      backtrace.message = err.message;\n      err = backtrace;\n      missingCallback(err);\n    }\n  }\n\n  function missingCallback(err) {\n    if (err) {\n      if (process.throwDeprecation)\n        throw err;  // Forgot a callback but don't know where? Use NODE_DEBUG=fs\n      else if (!process.noDeprecation) {\n        var msg = 'fs: missing callback ' + (err.stack || err.message);\n        if (process.traceDeprecation)\n          console.trace(msg);\n        else\n          console.error(msg);\n      }\n    }\n  }\n}\n\nfunction maybeCallback(cb) {\n  return typeof cb === 'function' ? cb : rethrow();\n}\n\nvar normalize = pathModule.normalize;\n\n// Regexp that finds the next partion of a (partial) path\n// result is [base_with_slash, base], e.g. ['somedir/', 'somedir']\nif (isWindows) {\n  var nextPartRe = /(.*?)(?:[\\/\\\\]+|$)/g;\n} else {\n  var nextPartRe = /(.*?)(?:[\\/]+|$)/g;\n}\n\n// Regex to find the device root, including trailing slash. E.g. 'c:\\\\'.\nif (isWindows) {\n  var splitRootRe = /^(?:[a-zA-Z]:|[\\\\\\/]{2}[^\\\\\\/]+[\\\\\\/][^\\\\\\/]+)?[\\\\\\/]*/;\n} else {\n  var splitRootRe = /^[\\/]*/;\n}\n\nexports.realpathSync = function realpathSync(p, cache) {\n  // make p is absolute\n  p = pathModule.resolve(p);\n\n  if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {\n    return cache[p];\n  }\n\n  var original = p,\n      seenLinks = {},\n      knownHard = {};\n\n  // current character position in p\n  var pos;\n  // the partial path so far, including a trailing slash if any\n  var current;\n  // the partial path without a trailing slash (except when pointing at a root)\n  var base;\n  // the partial path scanned in the previous round, with slash\n  var previous;\n\n  start();\n\n  function start() {\n    // Skip over roots\n    var m = splitRootRe.exec(p);\n    pos = m[0].length;\n    current = m[0];\n    base = m[0];\n    previous = '';\n\n    // On windows, check that the root exists. On unix there is no need.\n    if (isWindows && !knownHard[base]) {\n      fs.lstatSync(base);\n      knownHard[base] = true;\n    }\n  }\n\n  // walk down the path, swapping out linked pathparts for their real\n  // values\n  // NB: p.length changes.\n  while (pos < p.length) {\n    // find the next part\n    nextPartRe.lastIndex = pos;\n    var result = nextPartRe.exec(p);\n    previous = current;\n    current += result[0];\n    base = previous + result[1];\n    pos = nextPartRe.lastIndex;\n\n    // continue if not a symlink\n    if (knownHard[base] || (cache && cache[base] === base)) {\n      continue;\n    }\n\n    var resolvedLink;\n    if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {\n      // some known symbolic link.  no need to stat again.\n      resolvedLink = cache[base];\n    } else {\n      var stat = fs.lstatSync(base);\n      if (!stat.isSymbolicLink()) {\n        knownHard[base] = true;\n        if (cache) cache[base] = base;\n        continue;\n      }\n\n      // read the link if it wasn't read before\n      // dev/ino always return 0 on windows, so skip the check.\n      var linkTarget = null;\n      if (!isWindows) {\n        var id = stat.dev.toString(32) + ':' + stat.ino.toString(32);\n        if (seenLinks.hasOwnProperty(id)) {\n          linkTarget = seenLinks[id];\n        }\n      }\n      if (linkTarget === null) {\n        fs.statSync(base);\n        linkTarget = fs.readlinkSync(base);\n      }\n      resolvedLink = pathModule.resolve(previous, linkTarget);\n      // track this, if given a cache.\n      if (cache) cache[base] = resolvedLink;\n      if (!isWindows) seenLinks[id] = linkTarget;\n    }\n\n    // resolve the link, then start over\n    p = pathModule.resolve(resolvedLink, p.slice(pos));\n    start();\n  }\n\n  if (cache) cache[original] = p;\n\n  return p;\n};\n\n\nexports.realpath = function realpath(p, cache, cb) {\n  if (typeof cb !== 'function') {\n    cb = maybeCallback(cache);\n    cache = null;\n  }\n\n  // make p is absolute\n  p = pathModule.resolve(p);\n\n  if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {\n    return process.nextTick(cb.bind(null, null, cache[p]));\n  }\n\n  var original = p,\n      seenLinks = {},\n      knownHard = {};\n\n  // current character position in p\n  var pos;\n  // the partial path so far, including a trailing slash if any\n  var current;\n  // the partial path without a trailing slash (except when pointing at a root)\n  var base;\n  // the partial path scanned in the previous round, with slash\n  var previous;\n\n  start();\n\n  function start() {\n    // Skip over roots\n    var m = splitRootRe.exec(p);\n    pos = m[0].length;\n    current = m[0];\n    base = m[0];\n    previous = '';\n\n    // On windows, check that the root exists. On unix there is no need.\n    if (isWindows && !knownHard[base]) {\n      fs.lstat(base, function(err) {\n        if (err) return cb(err);\n        knownHard[base] = true;\n        LOOP();\n      });\n    } else {\n      process.nextTick(LOOP);\n    }\n  }\n\n  // walk down the path, swapping out linked pathparts for their real\n  // values\n  function LOOP() {\n    // stop if scanned past end of path\n    if (pos >= p.length) {\n      if (cache) cache[original] = p;\n      return cb(null, p);\n    }\n\n    // find the next part\n    nextPartRe.lastIndex = pos;\n    var result = nextPartRe.exec(p);\n    previous = current;\n    current += result[0];\n    base = previous + result[1];\n    pos = nextPartRe.lastIndex;\n\n    // continue if not a symlink\n    if (knownHard[base] || (cache && cache[base] === base)) {\n      return process.nextTick(LOOP);\n    }\n\n    if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {\n      // known symbolic link.  no need to stat again.\n      return gotResolvedLink(cache[base]);\n    }\n\n    return fs.lstat(base, gotStat);\n  }\n\n  function gotStat(err, stat) {\n    if (err) return cb(err);\n\n    // if not a symlink, skip to the next path part\n    if (!stat.isSymbolicLink()) {\n      knownHard[base] = true;\n      if (cache) cache[base] = base;\n      return process.nextTick(LOOP);\n    }\n\n    // stat & read the link if not read before\n    // call gotTarget as soon as the link target is known\n    // dev/ino always return 0 on windows, so skip the check.\n    if (!isWindows) {\n      var id = stat.dev.toString(32) + ':' + stat.ino.toString(32);\n      if (seenLinks.hasOwnProperty(id)) {\n        return gotTarget(null, seenLinks[id], base);\n      }\n    }\n    fs.stat(base, function(err) {\n      if (err) return cb(err);\n\n      fs.readlink(base, function(err, target) {\n        if (!isWindows) seenLinks[id] = target;\n        gotTarget(err, target);\n      });\n    });\n  }\n\n  function gotTarget(err, target, base) {\n    if (err) return cb(err);\n\n    var resolvedLink = pathModule.resolve(previous, target);\n    if (cache) cache[base] = resolvedLink;\n    gotResolvedLink(resolvedLink);\n  }\n\n  function gotResolvedLink(resolvedLink) {\n    // resolve the link, then start over\n    p = pathModule.resolve(resolvedLink, p.slice(pos));\n    start();\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZnMucmVhbHBhdGgvb2xkLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLG1CQUFPLENBQUMsbUlBQU07QUFDL0I7QUFDQSxTQUFTLG1CQUFPLENBQUMsaUlBQUk7O0FBRXJCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMENBQTBDLEVBQUU7QUFDNUMsRUFBRTtBQUNGO0FBQ0E7O0FBRUEsb0JBQW9CO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CO0FBQ3BCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOzs7QUFHQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0I7QUFDcEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdG9kby1saXN0Ly4vbm9kZV9tb2R1bGVzL2ZzLnJlYWxwYXRoL29sZC5qcz83MGIzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG52YXIgcGF0aE1vZHVsZSA9IHJlcXVpcmUoJ3BhdGgnKTtcbnZhciBpc1dpbmRvd3MgPSBwcm9jZXNzLnBsYXRmb3JtID09PSAnd2luMzInO1xudmFyIGZzID0gcmVxdWlyZSgnZnMnKTtcblxuLy8gSmF2YVNjcmlwdCBpbXBsZW1lbnRhdGlvbiBvZiByZWFscGF0aCwgcG9ydGVkIGZyb20gbm9kZSBwcmUtdjZcblxudmFyIERFQlVHID0gcHJvY2Vzcy5lbnYuTk9ERV9ERUJVRyAmJiAvZnMvLnRlc3QocHJvY2Vzcy5lbnYuTk9ERV9ERUJVRyk7XG5cbmZ1bmN0aW9uIHJldGhyb3coKSB7XG4gIC8vIE9ubHkgZW5hYmxlIGluIGRlYnVnIG1vZGUuIEEgYmFja3RyYWNlIHVzZXMgfjEwMDAgYnl0ZXMgb2YgaGVhcCBzcGFjZSBhbmRcbiAgLy8gaXMgZmFpcmx5IHNsb3cgdG8gZ2VuZXJhdGUuXG4gIHZhciBjYWxsYmFjaztcbiAgaWYgKERFQlVHKSB7XG4gICAgdmFyIGJhY2t0cmFjZSA9IG5ldyBFcnJvcjtcbiAgICBjYWxsYmFjayA9IGRlYnVnQ2FsbGJhY2s7XG4gIH0gZWxzZVxuICAgIGNhbGxiYWNrID0gbWlzc2luZ0NhbGxiYWNrO1xuXG4gIHJldHVybiBjYWxsYmFjaztcblxuICBmdW5jdGlvbiBkZWJ1Z0NhbGxiYWNrKGVycikge1xuICAgIGlmIChlcnIpIHtcbiAgICAgIGJhY2t0cmFjZS5tZXNzYWdlID0gZXJyLm1lc3NhZ2U7XG4gICAgICBlcnIgPSBiYWNrdHJhY2U7XG4gICAgICBtaXNzaW5nQ2FsbGJhY2soZXJyKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBtaXNzaW5nQ2FsbGJhY2soZXJyKSB7XG4gICAgaWYgKGVycikge1xuICAgICAgaWYgKHByb2Nlc3MudGhyb3dEZXByZWNhdGlvbilcbiAgICAgICAgdGhyb3cgZXJyOyAgLy8gRm9yZ290IGEgY2FsbGJhY2sgYnV0IGRvbid0IGtub3cgd2hlcmU/IFVzZSBOT0RFX0RFQlVHPWZzXG4gICAgICBlbHNlIGlmICghcHJvY2Vzcy5ub0RlcHJlY2F0aW9uKSB7XG4gICAgICAgIHZhciBtc2cgPSAnZnM6IG1pc3NpbmcgY2FsbGJhY2sgJyArIChlcnIuc3RhY2sgfHwgZXJyLm1lc3NhZ2UpO1xuICAgICAgICBpZiAocHJvY2Vzcy50cmFjZURlcHJlY2F0aW9uKVxuICAgICAgICAgIGNvbnNvbGUudHJhY2UobXNnKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IobXNnKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gbWF5YmVDYWxsYmFjayhjYikge1xuICByZXR1cm4gdHlwZW9mIGNiID09PSAnZnVuY3Rpb24nID8gY2IgOiByZXRocm93KCk7XG59XG5cbnZhciBub3JtYWxpemUgPSBwYXRoTW9kdWxlLm5vcm1hbGl6ZTtcblxuLy8gUmVnZXhwIHRoYXQgZmluZHMgdGhlIG5leHQgcGFydGlvbiBvZiBhIChwYXJ0aWFsKSBwYXRoXG4vLyByZXN1bHQgaXMgW2Jhc2Vfd2l0aF9zbGFzaCwgYmFzZV0sIGUuZy4gWydzb21lZGlyLycsICdzb21lZGlyJ11cbmlmIChpc1dpbmRvd3MpIHtcbiAgdmFyIG5leHRQYXJ0UmUgPSAvKC4qPykoPzpbXFwvXFxcXF0rfCQpL2c7XG59IGVsc2Uge1xuICB2YXIgbmV4dFBhcnRSZSA9IC8oLio/KSg/OltcXC9dK3wkKS9nO1xufVxuXG4vLyBSZWdleCB0byBmaW5kIHRoZSBkZXZpY2Ugcm9vdCwgaW5jbHVkaW5nIHRyYWlsaW5nIHNsYXNoLiBFLmcuICdjOlxcXFwnLlxuaWYgKGlzV2luZG93cykge1xuICB2YXIgc3BsaXRSb290UmUgPSAvXig/OlthLXpBLVpdOnxbXFxcXFxcL117Mn1bXlxcXFxcXC9dK1tcXFxcXFwvXVteXFxcXFxcL10rKT9bXFxcXFxcL10qLztcbn0gZWxzZSB7XG4gIHZhciBzcGxpdFJvb3RSZSA9IC9eW1xcL10qLztcbn1cblxuZXhwb3J0cy5yZWFscGF0aFN5bmMgPSBmdW5jdGlvbiByZWFscGF0aFN5bmMocCwgY2FjaGUpIHtcbiAgLy8gbWFrZSBwIGlzIGFic29sdXRlXG4gIHAgPSBwYXRoTW9kdWxlLnJlc29sdmUocCk7XG5cbiAgaWYgKGNhY2hlICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChjYWNoZSwgcCkpIHtcbiAgICByZXR1cm4gY2FjaGVbcF07XG4gIH1cblxuICB2YXIgb3JpZ2luYWwgPSBwLFxuICAgICAgc2VlbkxpbmtzID0ge30sXG4gICAgICBrbm93bkhhcmQgPSB7fTtcblxuICAvLyBjdXJyZW50IGNoYXJhY3RlciBwb3NpdGlvbiBpbiBwXG4gIHZhciBwb3M7XG4gIC8vIHRoZSBwYXJ0aWFsIHBhdGggc28gZmFyLCBpbmNsdWRpbmcgYSB0cmFpbGluZyBzbGFzaCBpZiBhbnlcbiAgdmFyIGN1cnJlbnQ7XG4gIC8vIHRoZSBwYXJ0aWFsIHBhdGggd2l0aG91dCBhIHRyYWlsaW5nIHNsYXNoIChleGNlcHQgd2hlbiBwb2ludGluZyBhdCBhIHJvb3QpXG4gIHZhciBiYXNlO1xuICAvLyB0aGUgcGFydGlhbCBwYXRoIHNjYW5uZWQgaW4gdGhlIHByZXZpb3VzIHJvdW5kLCB3aXRoIHNsYXNoXG4gIHZhciBwcmV2aW91cztcblxuICBzdGFydCgpO1xuXG4gIGZ1bmN0aW9uIHN0YXJ0KCkge1xuICAgIC8vIFNraXAgb3ZlciByb290c1xuICAgIHZhciBtID0gc3BsaXRSb290UmUuZXhlYyhwKTtcbiAgICBwb3MgPSBtWzBdLmxlbmd0aDtcbiAgICBjdXJyZW50ID0gbVswXTtcbiAgICBiYXNlID0gbVswXTtcbiAgICBwcmV2aW91cyA9ICcnO1xuXG4gICAgLy8gT24gd2luZG93cywgY2hlY2sgdGhhdCB0aGUgcm9vdCBleGlzdHMuIE9uIHVuaXggdGhlcmUgaXMgbm8gbmVlZC5cbiAgICBpZiAoaXNXaW5kb3dzICYmICFrbm93bkhhcmRbYmFzZV0pIHtcbiAgICAgIGZzLmxzdGF0U3luYyhiYXNlKTtcbiAgICAgIGtub3duSGFyZFtiYXNlXSA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgLy8gd2FsayBkb3duIHRoZSBwYXRoLCBzd2FwcGluZyBvdXQgbGlua2VkIHBhdGhwYXJ0cyBmb3IgdGhlaXIgcmVhbFxuICAvLyB2YWx1ZXNcbiAgLy8gTkI6IHAubGVuZ3RoIGNoYW5nZXMuXG4gIHdoaWxlIChwb3MgPCBwLmxlbmd0aCkge1xuICAgIC8vIGZpbmQgdGhlIG5leHQgcGFydFxuICAgIG5leHRQYXJ0UmUubGFzdEluZGV4ID0gcG9zO1xuICAgIHZhciByZXN1bHQgPSBuZXh0UGFydFJlLmV4ZWMocCk7XG4gICAgcHJldmlvdXMgPSBjdXJyZW50O1xuICAgIGN1cnJlbnQgKz0gcmVzdWx0WzBdO1xuICAgIGJhc2UgPSBwcmV2aW91cyArIHJlc3VsdFsxXTtcbiAgICBwb3MgPSBuZXh0UGFydFJlLmxhc3RJbmRleDtcblxuICAgIC8vIGNvbnRpbnVlIGlmIG5vdCBhIHN5bWxpbmtcbiAgICBpZiAoa25vd25IYXJkW2Jhc2VdIHx8IChjYWNoZSAmJiBjYWNoZVtiYXNlXSA9PT0gYmFzZSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHZhciByZXNvbHZlZExpbms7XG4gICAgaWYgKGNhY2hlICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChjYWNoZSwgYmFzZSkpIHtcbiAgICAgIC8vIHNvbWUga25vd24gc3ltYm9saWMgbGluay4gIG5vIG5lZWQgdG8gc3RhdCBhZ2Fpbi5cbiAgICAgIHJlc29sdmVkTGluayA9IGNhY2hlW2Jhc2VdO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgc3RhdCA9IGZzLmxzdGF0U3luYyhiYXNlKTtcbiAgICAgIGlmICghc3RhdC5pc1N5bWJvbGljTGluaygpKSB7XG4gICAgICAgIGtub3duSGFyZFtiYXNlXSA9IHRydWU7XG4gICAgICAgIGlmIChjYWNoZSkgY2FjaGVbYmFzZV0gPSBiYXNlO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gcmVhZCB0aGUgbGluayBpZiBpdCB3YXNuJ3QgcmVhZCBiZWZvcmVcbiAgICAgIC8vIGRldi9pbm8gYWx3YXlzIHJldHVybiAwIG9uIHdpbmRvd3MsIHNvIHNraXAgdGhlIGNoZWNrLlxuICAgICAgdmFyIGxpbmtUYXJnZXQgPSBudWxsO1xuICAgICAgaWYgKCFpc1dpbmRvd3MpIHtcbiAgICAgICAgdmFyIGlkID0gc3RhdC5kZXYudG9TdHJpbmcoMzIpICsgJzonICsgc3RhdC5pbm8udG9TdHJpbmcoMzIpO1xuICAgICAgICBpZiAoc2VlbkxpbmtzLmhhc093blByb3BlcnR5KGlkKSkge1xuICAgICAgICAgIGxpbmtUYXJnZXQgPSBzZWVuTGlua3NbaWRdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobGlua1RhcmdldCA9PT0gbnVsbCkge1xuICAgICAgICBmcy5zdGF0U3luYyhiYXNlKTtcbiAgICAgICAgbGlua1RhcmdldCA9IGZzLnJlYWRsaW5rU3luYyhiYXNlKTtcbiAgICAgIH1cbiAgICAgIHJlc29sdmVkTGluayA9IHBhdGhNb2R1bGUucmVzb2x2ZShwcmV2aW91cywgbGlua1RhcmdldCk7XG4gICAgICAvLyB0cmFjayB0aGlzLCBpZiBnaXZlbiBhIGNhY2hlLlxuICAgICAgaWYgKGNhY2hlKSBjYWNoZVtiYXNlXSA9IHJlc29sdmVkTGluaztcbiAgICAgIGlmICghaXNXaW5kb3dzKSBzZWVuTGlua3NbaWRdID0gbGlua1RhcmdldDtcbiAgICB9XG5cbiAgICAvLyByZXNvbHZlIHRoZSBsaW5rLCB0aGVuIHN0YXJ0IG92ZXJcbiAgICBwID0gcGF0aE1vZHVsZS5yZXNvbHZlKHJlc29sdmVkTGluaywgcC5zbGljZShwb3MpKTtcbiAgICBzdGFydCgpO1xuICB9XG5cbiAgaWYgKGNhY2hlKSBjYWNoZVtvcmlnaW5hbF0gPSBwO1xuXG4gIHJldHVybiBwO1xufTtcblxuXG5leHBvcnRzLnJlYWxwYXRoID0gZnVuY3Rpb24gcmVhbHBhdGgocCwgY2FjaGUsIGNiKSB7XG4gIGlmICh0eXBlb2YgY2IgIT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IG1heWJlQ2FsbGJhY2soY2FjaGUpO1xuICAgIGNhY2hlID0gbnVsbDtcbiAgfVxuXG4gIC8vIG1ha2UgcCBpcyBhYnNvbHV0ZVxuICBwID0gcGF0aE1vZHVsZS5yZXNvbHZlKHApO1xuXG4gIGlmIChjYWNoZSAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoY2FjaGUsIHApKSB7XG4gICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soY2IuYmluZChudWxsLCBudWxsLCBjYWNoZVtwXSkpO1xuICB9XG5cbiAgdmFyIG9yaWdpbmFsID0gcCxcbiAgICAgIHNlZW5MaW5rcyA9IHt9LFxuICAgICAga25vd25IYXJkID0ge307XG5cbiAgLy8gY3VycmVudCBjaGFyYWN0ZXIgcG9zaXRpb24gaW4gcFxuICB2YXIgcG9zO1xuICAvLyB0aGUgcGFydGlhbCBwYXRoIHNvIGZhciwgaW5jbHVkaW5nIGEgdHJhaWxpbmcgc2xhc2ggaWYgYW55XG4gIHZhciBjdXJyZW50O1xuICAvLyB0aGUgcGFydGlhbCBwYXRoIHdpdGhvdXQgYSB0cmFpbGluZyBzbGFzaCAoZXhjZXB0IHdoZW4gcG9pbnRpbmcgYXQgYSByb290KVxuICB2YXIgYmFzZTtcbiAgLy8gdGhlIHBhcnRpYWwgcGF0aCBzY2FubmVkIGluIHRoZSBwcmV2aW91cyByb3VuZCwgd2l0aCBzbGFzaFxuICB2YXIgcHJldmlvdXM7XG5cbiAgc3RhcnQoKTtcblxuICBmdW5jdGlvbiBzdGFydCgpIHtcbiAgICAvLyBTa2lwIG92ZXIgcm9vdHNcbiAgICB2YXIgbSA9IHNwbGl0Um9vdFJlLmV4ZWMocCk7XG4gICAgcG9zID0gbVswXS5sZW5ndGg7XG4gICAgY3VycmVudCA9IG1bMF07XG4gICAgYmFzZSA9IG1bMF07XG4gICAgcHJldmlvdXMgPSAnJztcblxuICAgIC8vIE9uIHdpbmRvd3MsIGNoZWNrIHRoYXQgdGhlIHJvb3QgZXhpc3RzLiBPbiB1bml4IHRoZXJlIGlzIG5vIG5lZWQuXG4gICAgaWYgKGlzV2luZG93cyAmJiAha25vd25IYXJkW2Jhc2VdKSB7XG4gICAgICBmcy5sc3RhdChiYXNlLCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgaWYgKGVycikgcmV0dXJuIGNiKGVycik7XG4gICAgICAgIGtub3duSGFyZFtiYXNlXSA9IHRydWU7XG4gICAgICAgIExPT1AoKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKExPT1ApO1xuICAgIH1cbiAgfVxuXG4gIC8vIHdhbGsgZG93biB0aGUgcGF0aCwgc3dhcHBpbmcgb3V0IGxpbmtlZCBwYXRocGFydHMgZm9yIHRoZWlyIHJlYWxcbiAgLy8gdmFsdWVzXG4gIGZ1bmN0aW9uIExPT1AoKSB7XG4gICAgLy8gc3RvcCBpZiBzY2FubmVkIHBhc3QgZW5kIG9mIHBhdGhcbiAgICBpZiAocG9zID49IHAubGVuZ3RoKSB7XG4gICAgICBpZiAoY2FjaGUpIGNhY2hlW29yaWdpbmFsXSA9IHA7XG4gICAgICByZXR1cm4gY2IobnVsbCwgcCk7XG4gICAgfVxuXG4gICAgLy8gZmluZCB0aGUgbmV4dCBwYXJ0XG4gICAgbmV4dFBhcnRSZS5sYXN0SW5kZXggPSBwb3M7XG4gICAgdmFyIHJlc3VsdCA9IG5leHRQYXJ0UmUuZXhlYyhwKTtcbiAgICBwcmV2aW91cyA9IGN1cnJlbnQ7XG4gICAgY3VycmVudCArPSByZXN1bHRbMF07XG4gICAgYmFzZSA9IHByZXZpb3VzICsgcmVzdWx0WzFdO1xuICAgIHBvcyA9IG5leHRQYXJ0UmUubGFzdEluZGV4O1xuXG4gICAgLy8gY29udGludWUgaWYgbm90IGEgc3ltbGlua1xuICAgIGlmIChrbm93bkhhcmRbYmFzZV0gfHwgKGNhY2hlICYmIGNhY2hlW2Jhc2VdID09PSBiYXNlKSkge1xuICAgICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soTE9PUCk7XG4gICAgfVxuXG4gICAgaWYgKGNhY2hlICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChjYWNoZSwgYmFzZSkpIHtcbiAgICAgIC8vIGtub3duIHN5bWJvbGljIGxpbmsuICBubyBuZWVkIHRvIHN0YXQgYWdhaW4uXG4gICAgICByZXR1cm4gZ290UmVzb2x2ZWRMaW5rKGNhY2hlW2Jhc2VdKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnMubHN0YXQoYmFzZSwgZ290U3RhdCk7XG4gIH1cblxuICBmdW5jdGlvbiBnb3RTdGF0KGVyciwgc3RhdCkge1xuICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpO1xuXG4gICAgLy8gaWYgbm90IGEgc3ltbGluaywgc2tpcCB0byB0aGUgbmV4dCBwYXRoIHBhcnRcbiAgICBpZiAoIXN0YXQuaXNTeW1ib2xpY0xpbmsoKSkge1xuICAgICAga25vd25IYXJkW2Jhc2VdID0gdHJ1ZTtcbiAgICAgIGlmIChjYWNoZSkgY2FjaGVbYmFzZV0gPSBiYXNlO1xuICAgICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soTE9PUCk7XG4gICAgfVxuXG4gICAgLy8gc3RhdCAmIHJlYWQgdGhlIGxpbmsgaWYgbm90IHJlYWQgYmVmb3JlXG4gICAgLy8gY2FsbCBnb3RUYXJnZXQgYXMgc29vbiBhcyB0aGUgbGluayB0YXJnZXQgaXMga25vd25cbiAgICAvLyBkZXYvaW5vIGFsd2F5cyByZXR1cm4gMCBvbiB3aW5kb3dzLCBzbyBza2lwIHRoZSBjaGVjay5cbiAgICBpZiAoIWlzV2luZG93cykge1xuICAgICAgdmFyIGlkID0gc3RhdC5kZXYudG9TdHJpbmcoMzIpICsgJzonICsgc3RhdC5pbm8udG9TdHJpbmcoMzIpO1xuICAgICAgaWYgKHNlZW5MaW5rcy5oYXNPd25Qcm9wZXJ0eShpZCkpIHtcbiAgICAgICAgcmV0dXJuIGdvdFRhcmdldChudWxsLCBzZWVuTGlua3NbaWRdLCBiYXNlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnMuc3RhdChiYXNlLCBmdW5jdGlvbihlcnIpIHtcbiAgICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpO1xuXG4gICAgICBmcy5yZWFkbGluayhiYXNlLCBmdW5jdGlvbihlcnIsIHRhcmdldCkge1xuICAgICAgICBpZiAoIWlzV2luZG93cykgc2VlbkxpbmtzW2lkXSA9IHRhcmdldDtcbiAgICAgICAgZ290VGFyZ2V0KGVyciwgdGFyZ2V0KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gZ290VGFyZ2V0KGVyciwgdGFyZ2V0LCBiYXNlKSB7XG4gICAgaWYgKGVycikgcmV0dXJuIGNiKGVycik7XG5cbiAgICB2YXIgcmVzb2x2ZWRMaW5rID0gcGF0aE1vZHVsZS5yZXNvbHZlKHByZXZpb3VzLCB0YXJnZXQpO1xuICAgIGlmIChjYWNoZSkgY2FjaGVbYmFzZV0gPSByZXNvbHZlZExpbms7XG4gICAgZ290UmVzb2x2ZWRMaW5rKHJlc29sdmVkTGluayk7XG4gIH1cblxuICBmdW5jdGlvbiBnb3RSZXNvbHZlZExpbmsocmVzb2x2ZWRMaW5rKSB7XG4gICAgLy8gcmVzb2x2ZSB0aGUgbGluaywgdGhlbiBzdGFydCBvdmVyXG4gICAgcCA9IHBhdGhNb2R1bGUucmVzb2x2ZShyZXNvbHZlZExpbmssIHAuc2xpY2UocG9zKSk7XG4gICAgc3RhcnQoKTtcbiAgfVxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/fs.realpath/old.js\n");

/***/ }),

/***/ "./node_modules/gh-pages/lib/git.js":
/*!******************************************!*\
  !*** ./node_modules/gh-pages/lib/git.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const cp = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'child_process'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\nconst fs = __webpack_require__(/*! fs-extra */ \"./node_modules/fs-extra/lib/index.js\");\nconst path = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'path'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\nconst util = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'util'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\n\n/**\n * @function Object() { [native code] }\n * @param {number} code Error code.\n * @param {string} message Error message.\n */\nfunction ProcessError(code, message) {\n  const callee = arguments.callee;\n  Error.apply(this, [message]);\n  Error.captureStackTrace(this, callee);\n  this.code = code;\n  this.message = message;\n  this.name = callee.name;\n}\nutil.inherits(ProcessError, Error);\n\n/**\n * Util function for handling spawned processes as promises.\n * @param {string} exe Executable.\n * @param {Array<string>} args Arguments.\n * @param {string} cwd Working directory.\n * @return {Promise} A promise.\n */\nfunction spawn(exe, args, cwd) {\n  return new Promise((resolve, reject) => {\n    const child = cp.spawn(exe, args, {cwd: cwd || process.cwd()});\n    const buffer = [];\n    child.stderr.on('data', (chunk) => {\n      buffer.push(chunk.toString());\n    });\n    child.stdout.on('data', (chunk) => {\n      buffer.push(chunk.toString());\n    });\n    child.on('close', (code) => {\n      const output = buffer.join('');\n      if (code) {\n        const msg = output || 'Process failed: ' + code;\n        reject(new ProcessError(code, msg));\n      } else {\n        resolve(output);\n      }\n    });\n  });\n}\n\n/**\n * Create an object for executing git commands.\n * @param {string} cwd Repository directory.\n * @param {string} cmd Git executable (full path if not already on path).\n * @function Object() { [native code] }\n */\nfunction Git(cwd, cmd) {\n  this.cwd = cwd;\n  this.cmd = cmd || 'git';\n  this.output = '';\n}\n\n/**\n * Execute an arbitrary git command.\n * @param {Array<string>} args Arguments (e.g. ['remote', 'update']).\n * @return {Promise} A promise.  The promise will be resolved with this instance\n *     or rejected with an error.\n */\nGit.prototype.exec = function (...args) {\n  return spawn(this.cmd, [...args], this.cwd).then((output) => {\n    this.output = output;\n    return this;\n  });\n};\n\n/**\n * Initialize repository.\n * @return {Promise} A promise.\n */\nGit.prototype.init = function () {\n  return this.exec('init');\n};\n\n/**\n * Clean up unversioned files.\n * @return {Promise} A promise.\n */\nGit.prototype.clean = function () {\n  return this.exec('clean', '-f', '-d');\n};\n\n/**\n * Hard reset to remote/branch\n * @param {string} remote Remote alias.\n * @param {string} branch Branch name.\n * @return {Promise} A promise.\n */\nGit.prototype.reset = function (remote, branch) {\n  return this.exec('reset', '--hard', remote + '/' + branch);\n};\n\n/**\n * Fetch from a remote.\n * @param {string} remote Remote alias.\n * @return {Promise} A promise.\n */\nGit.prototype.fetch = function (remote) {\n  return this.exec('fetch', remote);\n};\n\n/**\n * Checkout a branch (create an orphan if it doesn't exist on the remote).\n * @param {string} remote Remote alias.\n * @param {string} branch Branch name.\n * @return {Promise} A promise.\n */\nGit.prototype.checkout = function (remote, branch) {\n  const treeish = remote + '/' + branch;\n  return this.exec('ls-remote', '--exit-code', '.', treeish).then(\n    () => {\n      // branch exists on remote, hard reset\n      return this.exec('checkout', branch)\n        .then(() => this.clean())\n        .then(() => this.reset(remote, branch));\n    },\n    (error) => {\n      if (error instanceof ProcessError && error.code === 2) {\n        // branch doesn't exist, create an orphan\n        return this.exec('checkout', '--orphan', branch);\n      } else {\n        // unhandled error\n        throw error;\n      }\n    }\n  );\n};\n\n/**\n * Remove all unversioned files.\n * @param {string | Array<string>} files Files argument.\n * @return {Promise} A promise.\n */\nGit.prototype.rm = function (files) {\n  if (!Array.isArray(files)) {\n    files = [files];\n  }\n  return this.exec('rm', '--ignore-unmatch', '-r', '-f', ...files);\n};\n\n/**\n * Add files.\n * @param {string | Array<string>} files Files argument.\n * @return {Promise} A promise.\n */\nGit.prototype.add = function (files) {\n  if (!Array.isArray(files)) {\n    files = [files];\n  }\n  return this.exec('add', ...files);\n};\n\n/**\n * Commit (if there are any changes).\n * @param {string} message Commit message.\n * @return {Promise} A promise.\n */\nGit.prototype.commit = function (message) {\n  return this.exec('diff-index', '--quiet', 'HEAD').catch(() =>\n    this.exec('commit', '-m', message)\n  );\n};\n\n/**\n * Add tag\n * @param {string} name Name of tag.\n * @return {Promise} A promise.\n */\nGit.prototype.tag = function (name) {\n  return this.exec('tag', name);\n};\n\n/**\n * Push a branch.\n * @param {string} remote Remote alias.\n * @param {string} branch Branch name.\n * @param {boolean} force Force push.\n * @return {Promise} A promise.\n */\nGit.prototype.push = function (remote, branch, force) {\n  const args = ['push', '--tags', remote, branch];\n  if (force) {\n    args.push('--force');\n  }\n  return this.exec.apply(this, args);\n};\n\n/**\n * Get the URL for a remote.\n * @param {string} remote Remote alias.\n * @return {Promise<string>} A promise for the remote URL.\n */\nGit.prototype.getRemoteUrl = function (remote) {\n  return this.exec('config', '--get', 'remote.' + remote + '.url')\n    .then((git) => {\n      const repo = git.output && git.output.split(/[\\n\\r]/).shift();\n      if (repo) {\n        return repo;\n      } else {\n        throw new Error(\n          'Failed to get repo URL from options or current directory.'\n        );\n      }\n    })\n    .catch((err) => {\n      throw new Error(\n        'Failed to get remote.' +\n          remote +\n          '.url (task must either be ' +\n          'run in a git repository with a configured ' +\n          remote +\n          ' remote ' +\n          'or must be configured with the \"repo\" option).'\n      );\n    });\n};\n\n/**\n * Delete ref to remove branch history\n * @param {string} branch The branch name.\n * @return {Promise} A promise.  The promise will be resolved with this instance\n *     or rejected with an error.\n */\nGit.prototype.deleteRef = function (branch) {\n  return this.exec('update-ref', '-d', 'refs/heads/' + branch);\n};\n\n/**\n * Clone a repo into the given dir if it doesn't already exist.\n * @param {string} repo Repository URL.\n * @param {string} dir Target directory.\n * @param {string} branch Branch name.\n * @param {options} options All options.\n * @return {Promise<Git>} A promise.\n */\nGit.clone = function clone(repo, dir, branch, options) {\n  return fs.exists(dir).then((exists) => {\n    if (exists) {\n      return Promise.resolve(new Git(dir, options.git));\n    } else {\n      return fs.mkdirp(path.dirname(path.resolve(dir))).then(() => {\n        const args = [\n          'clone',\n          repo,\n          dir,\n          '--branch',\n          branch,\n          '--single-branch',\n          '--origin',\n          options.remote,\n          '--depth',\n          options.depth,\n        ];\n        return spawn(options.git, args)\n          .catch((err) => {\n            // try again without branch or depth options\n            return spawn(options.git, [\n              'clone',\n              repo,\n              dir,\n              '--origin',\n              options.remote,\n            ]);\n          })\n          .then(() => new Git(dir, options.git));\n      });\n    }\n  });\n};\n\nmodule.exports = Git;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ2gtcGFnZXMvbGliL2dpdC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQSxXQUFXLG1CQUFPLENBQUMsNElBQWU7QUFDbEMsV0FBVyxtQkFBTyxDQUFDLHNEQUFVO0FBQzdCLGFBQWEsbUJBQU8sQ0FBQyxtSUFBTTtBQUMzQixhQUFhLG1CQUFPLENBQUMsbUlBQU07O0FBRTNCO0FBQ0Esd0JBQXdCO0FBQ3hCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLGVBQWU7QUFDMUIsV0FBVyxRQUFRO0FBQ25CLFlBQVksU0FBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsMEJBQTBCO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLFlBQVksU0FBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBLFlBQVksU0FBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFlBQVksU0FBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVksU0FBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyx3QkFBd0I7QUFDbkMsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLHdCQUF3QjtBQUNuQyxZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQixZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVksaUJBQWlCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQixZQUFZLGNBQWM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdG9kby1saXN0Ly4vbm9kZV9tb2R1bGVzL2doLXBhZ2VzL2xpYi9naXQuanM/ODU0ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBjcCA9IHJlcXVpcmUoJ2NoaWxkX3Byb2Nlc3MnKTtcbmNvbnN0IGZzID0gcmVxdWlyZSgnZnMtZXh0cmEnKTtcbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XG5jb25zdCB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xuXG4vKipcbiAqIEBmdW5jdGlvbiBPYmplY3QoKSB7IFtuYXRpdmUgY29kZV0gfVxuICogQHBhcmFtIHtudW1iZXJ9IGNvZGUgRXJyb3IgY29kZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlIEVycm9yIG1lc3NhZ2UuXG4gKi9cbmZ1bmN0aW9uIFByb2Nlc3NFcnJvcihjb2RlLCBtZXNzYWdlKSB7XG4gIGNvbnN0IGNhbGxlZSA9IGFyZ3VtZW50cy5jYWxsZWU7XG4gIEVycm9yLmFwcGx5KHRoaXMsIFttZXNzYWdlXSk7XG4gIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIGNhbGxlZSk7XG4gIHRoaXMuY29kZSA9IGNvZGU7XG4gIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gIHRoaXMubmFtZSA9IGNhbGxlZS5uYW1lO1xufVxudXRpbC5pbmhlcml0cyhQcm9jZXNzRXJyb3IsIEVycm9yKTtcblxuLyoqXG4gKiBVdGlsIGZ1bmN0aW9uIGZvciBoYW5kbGluZyBzcGF3bmVkIHByb2Nlc3NlcyBhcyBwcm9taXNlcy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBleGUgRXhlY3V0YWJsZS5cbiAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gYXJncyBBcmd1bWVudHMuXG4gKiBAcGFyYW0ge3N0cmluZ30gY3dkIFdvcmtpbmcgZGlyZWN0b3J5LlxuICogQHJldHVybiB7UHJvbWlzZX0gQSBwcm9taXNlLlxuICovXG5mdW5jdGlvbiBzcGF3bihleGUsIGFyZ3MsIGN3ZCkge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGNvbnN0IGNoaWxkID0gY3Auc3Bhd24oZXhlLCBhcmdzLCB7Y3dkOiBjd2QgfHwgcHJvY2Vzcy5jd2QoKX0pO1xuICAgIGNvbnN0IGJ1ZmZlciA9IFtdO1xuICAgIGNoaWxkLnN0ZGVyci5vbignZGF0YScsIChjaHVuaykgPT4ge1xuICAgICAgYnVmZmVyLnB1c2goY2h1bmsudG9TdHJpbmcoKSk7XG4gICAgfSk7XG4gICAgY2hpbGQuc3Rkb3V0Lm9uKCdkYXRhJywgKGNodW5rKSA9PiB7XG4gICAgICBidWZmZXIucHVzaChjaHVuay50b1N0cmluZygpKTtcbiAgICB9KTtcbiAgICBjaGlsZC5vbignY2xvc2UnLCAoY29kZSkgPT4ge1xuICAgICAgY29uc3Qgb3V0cHV0ID0gYnVmZmVyLmpvaW4oJycpO1xuICAgICAgaWYgKGNvZGUpIHtcbiAgICAgICAgY29uc3QgbXNnID0gb3V0cHV0IHx8ICdQcm9jZXNzIGZhaWxlZDogJyArIGNvZGU7XG4gICAgICAgIHJlamVjdChuZXcgUHJvY2Vzc0Vycm9yKGNvZGUsIG1zZykpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzb2x2ZShvdXRwdXQpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYW4gb2JqZWN0IGZvciBleGVjdXRpbmcgZ2l0IGNvbW1hbmRzLlxuICogQHBhcmFtIHtzdHJpbmd9IGN3ZCBSZXBvc2l0b3J5IGRpcmVjdG9yeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBjbWQgR2l0IGV4ZWN1dGFibGUgKGZ1bGwgcGF0aCBpZiBub3QgYWxyZWFkeSBvbiBwYXRoKS5cbiAqIEBmdW5jdGlvbiBPYmplY3QoKSB7IFtuYXRpdmUgY29kZV0gfVxuICovXG5mdW5jdGlvbiBHaXQoY3dkLCBjbWQpIHtcbiAgdGhpcy5jd2QgPSBjd2Q7XG4gIHRoaXMuY21kID0gY21kIHx8ICdnaXQnO1xuICB0aGlzLm91dHB1dCA9ICcnO1xufVxuXG4vKipcbiAqIEV4ZWN1dGUgYW4gYXJiaXRyYXJ5IGdpdCBjb21tYW5kLlxuICogQHBhcmFtIHtBcnJheTxzdHJpbmc+fSBhcmdzIEFyZ3VtZW50cyAoZS5nLiBbJ3JlbW90ZScsICd1cGRhdGUnXSkuXG4gKiBAcmV0dXJuIHtQcm9taXNlfSBBIHByb21pc2UuICBUaGUgcHJvbWlzZSB3aWxsIGJlIHJlc29sdmVkIHdpdGggdGhpcyBpbnN0YW5jZVxuICogICAgIG9yIHJlamVjdGVkIHdpdGggYW4gZXJyb3IuXG4gKi9cbkdpdC5wcm90b3R5cGUuZXhlYyA9IGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gIHJldHVybiBzcGF3bih0aGlzLmNtZCwgWy4uLmFyZ3NdLCB0aGlzLmN3ZCkudGhlbigob3V0cHV0KSA9PiB7XG4gICAgdGhpcy5vdXRwdXQgPSBvdXRwdXQ7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBJbml0aWFsaXplIHJlcG9zaXRvcnkuXG4gKiBAcmV0dXJuIHtQcm9taXNlfSBBIHByb21pc2UuXG4gKi9cbkdpdC5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuZXhlYygnaW5pdCcpO1xufTtcblxuLyoqXG4gKiBDbGVhbiB1cCB1bnZlcnNpb25lZCBmaWxlcy5cbiAqIEByZXR1cm4ge1Byb21pc2V9IEEgcHJvbWlzZS5cbiAqL1xuR2l0LnByb3RvdHlwZS5jbGVhbiA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuZXhlYygnY2xlYW4nLCAnLWYnLCAnLWQnKTtcbn07XG5cbi8qKlxuICogSGFyZCByZXNldCB0byByZW1vdGUvYnJhbmNoXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVtb3RlIFJlbW90ZSBhbGlhcy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBicmFuY2ggQnJhbmNoIG5hbWUuXG4gKiBAcmV0dXJuIHtQcm9taXNlfSBBIHByb21pc2UuXG4gKi9cbkdpdC5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAocmVtb3RlLCBicmFuY2gpIHtcbiAgcmV0dXJuIHRoaXMuZXhlYygncmVzZXQnLCAnLS1oYXJkJywgcmVtb3RlICsgJy8nICsgYnJhbmNoKTtcbn07XG5cbi8qKlxuICogRmV0Y2ggZnJvbSBhIHJlbW90ZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSByZW1vdGUgUmVtb3RlIGFsaWFzLlxuICogQHJldHVybiB7UHJvbWlzZX0gQSBwcm9taXNlLlxuICovXG5HaXQucHJvdG90eXBlLmZldGNoID0gZnVuY3Rpb24gKHJlbW90ZSkge1xuICByZXR1cm4gdGhpcy5leGVjKCdmZXRjaCcsIHJlbW90ZSk7XG59O1xuXG4vKipcbiAqIENoZWNrb3V0IGEgYnJhbmNoIChjcmVhdGUgYW4gb3JwaGFuIGlmIGl0IGRvZXNuJ3QgZXhpc3Qgb24gdGhlIHJlbW90ZSkuXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVtb3RlIFJlbW90ZSBhbGlhcy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBicmFuY2ggQnJhbmNoIG5hbWUuXG4gKiBAcmV0dXJuIHtQcm9taXNlfSBBIHByb21pc2UuXG4gKi9cbkdpdC5wcm90b3R5cGUuY2hlY2tvdXQgPSBmdW5jdGlvbiAocmVtb3RlLCBicmFuY2gpIHtcbiAgY29uc3QgdHJlZWlzaCA9IHJlbW90ZSArICcvJyArIGJyYW5jaDtcbiAgcmV0dXJuIHRoaXMuZXhlYygnbHMtcmVtb3RlJywgJy0tZXhpdC1jb2RlJywgJy4nLCB0cmVlaXNoKS50aGVuKFxuICAgICgpID0+IHtcbiAgICAgIC8vIGJyYW5jaCBleGlzdHMgb24gcmVtb3RlLCBoYXJkIHJlc2V0XG4gICAgICByZXR1cm4gdGhpcy5leGVjKCdjaGVja291dCcsIGJyYW5jaClcbiAgICAgICAgLnRoZW4oKCkgPT4gdGhpcy5jbGVhbigpKVxuICAgICAgICAudGhlbigoKSA9PiB0aGlzLnJlc2V0KHJlbW90ZSwgYnJhbmNoKSk7XG4gICAgfSxcbiAgICAoZXJyb3IpID0+IHtcbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIFByb2Nlc3NFcnJvciAmJiBlcnJvci5jb2RlID09PSAyKSB7XG4gICAgICAgIC8vIGJyYW5jaCBkb2Vzbid0IGV4aXN0LCBjcmVhdGUgYW4gb3JwaGFuXG4gICAgICAgIHJldHVybiB0aGlzLmV4ZWMoJ2NoZWNrb3V0JywgJy0tb3JwaGFuJywgYnJhbmNoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHVuaGFuZGxlZCBlcnJvclxuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICB9XG4gICk7XG59O1xuXG4vKipcbiAqIFJlbW92ZSBhbGwgdW52ZXJzaW9uZWQgZmlsZXMuXG4gKiBAcGFyYW0ge3N0cmluZyB8IEFycmF5PHN0cmluZz59IGZpbGVzIEZpbGVzIGFyZ3VtZW50LlxuICogQHJldHVybiB7UHJvbWlzZX0gQSBwcm9taXNlLlxuICovXG5HaXQucHJvdG90eXBlLnJtID0gZnVuY3Rpb24gKGZpbGVzKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShmaWxlcykpIHtcbiAgICBmaWxlcyA9IFtmaWxlc107XG4gIH1cbiAgcmV0dXJuIHRoaXMuZXhlYygncm0nLCAnLS1pZ25vcmUtdW5tYXRjaCcsICctcicsICctZicsIC4uLmZpbGVzKTtcbn07XG5cbi8qKlxuICogQWRkIGZpbGVzLlxuICogQHBhcmFtIHtzdHJpbmcgfCBBcnJheTxzdHJpbmc+fSBmaWxlcyBGaWxlcyBhcmd1bWVudC5cbiAqIEByZXR1cm4ge1Byb21pc2V9IEEgcHJvbWlzZS5cbiAqL1xuR2l0LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAoZmlsZXMpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGZpbGVzKSkge1xuICAgIGZpbGVzID0gW2ZpbGVzXTtcbiAgfVxuICByZXR1cm4gdGhpcy5leGVjKCdhZGQnLCAuLi5maWxlcyk7XG59O1xuXG4vKipcbiAqIENvbW1pdCAoaWYgdGhlcmUgYXJlIGFueSBjaGFuZ2VzKS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlIENvbW1pdCBtZXNzYWdlLlxuICogQHJldHVybiB7UHJvbWlzZX0gQSBwcm9taXNlLlxuICovXG5HaXQucHJvdG90eXBlLmNvbW1pdCA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gIHJldHVybiB0aGlzLmV4ZWMoJ2RpZmYtaW5kZXgnLCAnLS1xdWlldCcsICdIRUFEJykuY2F0Y2goKCkgPT5cbiAgICB0aGlzLmV4ZWMoJ2NvbW1pdCcsICctbScsIG1lc3NhZ2UpXG4gICk7XG59O1xuXG4vKipcbiAqIEFkZCB0YWdcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIE5hbWUgb2YgdGFnLlxuICogQHJldHVybiB7UHJvbWlzZX0gQSBwcm9taXNlLlxuICovXG5HaXQucHJvdG90eXBlLnRhZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiB0aGlzLmV4ZWMoJ3RhZycsIG5hbWUpO1xufTtcblxuLyoqXG4gKiBQdXNoIGEgYnJhbmNoLlxuICogQHBhcmFtIHtzdHJpbmd9IHJlbW90ZSBSZW1vdGUgYWxpYXMuXG4gKiBAcGFyYW0ge3N0cmluZ30gYnJhbmNoIEJyYW5jaCBuYW1lLlxuICogQHBhcmFtIHtib29sZWFufSBmb3JjZSBGb3JjZSBwdXNoLlxuICogQHJldHVybiB7UHJvbWlzZX0gQSBwcm9taXNlLlxuICovXG5HaXQucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAocmVtb3RlLCBicmFuY2gsIGZvcmNlKSB7XG4gIGNvbnN0IGFyZ3MgPSBbJ3B1c2gnLCAnLS10YWdzJywgcmVtb3RlLCBicmFuY2hdO1xuICBpZiAoZm9yY2UpIHtcbiAgICBhcmdzLnB1c2goJy0tZm9yY2UnKTtcbiAgfVxuICByZXR1cm4gdGhpcy5leGVjLmFwcGx5KHRoaXMsIGFyZ3MpO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIFVSTCBmb3IgYSByZW1vdGUuXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVtb3RlIFJlbW90ZSBhbGlhcy5cbiAqIEByZXR1cm4ge1Byb21pc2U8c3RyaW5nPn0gQSBwcm9taXNlIGZvciB0aGUgcmVtb3RlIFVSTC5cbiAqL1xuR2l0LnByb3RvdHlwZS5nZXRSZW1vdGVVcmwgPSBmdW5jdGlvbiAocmVtb3RlKSB7XG4gIHJldHVybiB0aGlzLmV4ZWMoJ2NvbmZpZycsICctLWdldCcsICdyZW1vdGUuJyArIHJlbW90ZSArICcudXJsJylcbiAgICAudGhlbigoZ2l0KSA9PiB7XG4gICAgICBjb25zdCByZXBvID0gZ2l0Lm91dHB1dCAmJiBnaXQub3V0cHV0LnNwbGl0KC9bXFxuXFxyXS8pLnNoaWZ0KCk7XG4gICAgICBpZiAocmVwbykge1xuICAgICAgICByZXR1cm4gcmVwbztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAnRmFpbGVkIHRvIGdldCByZXBvIFVSTCBmcm9tIG9wdGlvbnMgb3IgY3VycmVudCBkaXJlY3RvcnkuJ1xuICAgICAgICApO1xuICAgICAgfVxuICAgIH0pXG4gICAgLmNhdGNoKChlcnIpID0+IHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ0ZhaWxlZCB0byBnZXQgcmVtb3RlLicgK1xuICAgICAgICAgIHJlbW90ZSArXG4gICAgICAgICAgJy51cmwgKHRhc2sgbXVzdCBlaXRoZXIgYmUgJyArXG4gICAgICAgICAgJ3J1biBpbiBhIGdpdCByZXBvc2l0b3J5IHdpdGggYSBjb25maWd1cmVkICcgK1xuICAgICAgICAgIHJlbW90ZSArXG4gICAgICAgICAgJyByZW1vdGUgJyArXG4gICAgICAgICAgJ29yIG11c3QgYmUgY29uZmlndXJlZCB3aXRoIHRoZSBcInJlcG9cIiBvcHRpb24pLidcbiAgICAgICk7XG4gICAgfSk7XG59O1xuXG4vKipcbiAqIERlbGV0ZSByZWYgdG8gcmVtb3ZlIGJyYW5jaCBoaXN0b3J5XG4gKiBAcGFyYW0ge3N0cmluZ30gYnJhbmNoIFRoZSBicmFuY2ggbmFtZS5cbiAqIEByZXR1cm4ge1Byb21pc2V9IEEgcHJvbWlzZS4gIFRoZSBwcm9taXNlIHdpbGwgYmUgcmVzb2x2ZWQgd2l0aCB0aGlzIGluc3RhbmNlXG4gKiAgICAgb3IgcmVqZWN0ZWQgd2l0aCBhbiBlcnJvci5cbiAqL1xuR2l0LnByb3RvdHlwZS5kZWxldGVSZWYgPSBmdW5jdGlvbiAoYnJhbmNoKSB7XG4gIHJldHVybiB0aGlzLmV4ZWMoJ3VwZGF0ZS1yZWYnLCAnLWQnLCAncmVmcy9oZWFkcy8nICsgYnJhbmNoKTtcbn07XG5cbi8qKlxuICogQ2xvbmUgYSByZXBvIGludG8gdGhlIGdpdmVuIGRpciBpZiBpdCBkb2Vzbid0IGFscmVhZHkgZXhpc3QuXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVwbyBSZXBvc2l0b3J5IFVSTC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXIgVGFyZ2V0IGRpcmVjdG9yeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBicmFuY2ggQnJhbmNoIG5hbWUuXG4gKiBAcGFyYW0ge29wdGlvbnN9IG9wdGlvbnMgQWxsIG9wdGlvbnMuXG4gKiBAcmV0dXJuIHtQcm9taXNlPEdpdD59IEEgcHJvbWlzZS5cbiAqL1xuR2l0LmNsb25lID0gZnVuY3Rpb24gY2xvbmUocmVwbywgZGlyLCBicmFuY2gsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIGZzLmV4aXN0cyhkaXIpLnRoZW4oKGV4aXN0cykgPT4ge1xuICAgIGlmIChleGlzdHMpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobmV3IEdpdChkaXIsIG9wdGlvbnMuZ2l0KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmcy5ta2RpcnAocGF0aC5kaXJuYW1lKHBhdGgucmVzb2x2ZShkaXIpKSkudGhlbigoKSA9PiB7XG4gICAgICAgIGNvbnN0IGFyZ3MgPSBbXG4gICAgICAgICAgJ2Nsb25lJyxcbiAgICAgICAgICByZXBvLFxuICAgICAgICAgIGRpcixcbiAgICAgICAgICAnLS1icmFuY2gnLFxuICAgICAgICAgIGJyYW5jaCxcbiAgICAgICAgICAnLS1zaW5nbGUtYnJhbmNoJyxcbiAgICAgICAgICAnLS1vcmlnaW4nLFxuICAgICAgICAgIG9wdGlvbnMucmVtb3RlLFxuICAgICAgICAgICctLWRlcHRoJyxcbiAgICAgICAgICBvcHRpb25zLmRlcHRoLFxuICAgICAgICBdO1xuICAgICAgICByZXR1cm4gc3Bhd24ob3B0aW9ucy5naXQsIGFyZ3MpXG4gICAgICAgICAgLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICAgIC8vIHRyeSBhZ2FpbiB3aXRob3V0IGJyYW5jaCBvciBkZXB0aCBvcHRpb25zXG4gICAgICAgICAgICByZXR1cm4gc3Bhd24ob3B0aW9ucy5naXQsIFtcbiAgICAgICAgICAgICAgJ2Nsb25lJyxcbiAgICAgICAgICAgICAgcmVwbyxcbiAgICAgICAgICAgICAgZGlyLFxuICAgICAgICAgICAgICAnLS1vcmlnaW4nLFxuICAgICAgICAgICAgICBvcHRpb25zLnJlbW90ZSxcbiAgICAgICAgICAgIF0pO1xuICAgICAgICAgIH0pXG4gICAgICAgICAgLnRoZW4oKCkgPT4gbmV3IEdpdChkaXIsIG9wdGlvbnMuZ2l0KSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBHaXQ7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/gh-pages/lib/git.js\n");

/***/ }),

/***/ "./node_modules/gh-pages/lib/index.js":
/*!********************************************!*\
  !*** ./node_modules/gh-pages/lib/index.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("const findCacheDir = __webpack_require__(/*! find-cache-dir */ \"./node_modules/find-cache-dir/index.js\");\nconst Git = __webpack_require__(/*! ./git.js */ \"./node_modules/gh-pages/lib/git.js\");\nconst filenamify = __webpack_require__(/*! filenamify */ \"./node_modules/filenamify/index.js\");\nconst copy = (__webpack_require__(/*! ./util.js */ \"./node_modules/gh-pages/lib/util.js\").copy);\nconst getUser = (__webpack_require__(/*! ./util.js */ \"./node_modules/gh-pages/lib/util.js\").getUser);\nconst fs = __webpack_require__(/*! fs-extra */ \"./node_modules/fs-extra/lib/index.js\");\nconst globby = __webpack_require__(/*! globby */ \"./node_modules/globby/index.js\");\nconst path = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'path'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\nconst util = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'util'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\n\nconst log = util.debuglog('gh-pages');\n\n/**\n * Get the cache directory.\n * @param {string} [optPath] Optional path.\n * @return {string} The full path to the cache directory.\n */\nfunction getCacheDir(optPath) {\n  const dir = findCacheDir({name: 'gh-pages'});\n  if (!optPath) {\n    return dir;\n  }\n\n  return path.join(dir, filenamify(optPath));\n}\nexports.getCacheDir = getCacheDir;\n\nfunction getRepo(options) {\n  if (options.repo) {\n    return Promise.resolve(options.repo);\n  } else {\n    const git = new Git(process.cwd(), options.git);\n    return git.getRemoteUrl(options.remote);\n  }\n}\n\nexports.defaults = {\n  dest: '.',\n  add: false,\n  git: 'git',\n  depth: 1,\n  dotfiles: false,\n  branch: 'gh-pages',\n  remote: 'origin',\n  src: '**/*',\n  remove: '.',\n  push: true,\n  history: true,\n  message: 'Updates',\n  silent: false,\n};\n\n/**\n * Push a git branch to a remote (pushes gh-pages by default).\n * @param {string} basePath The base path.\n * @param {Object} config Publish options.\n * @param {Function} callback Callback.\n * @return {Promise} A promise.\n */\nexports.publish = function publish(basePath, config, callback) {\n  if (typeof config === 'function') {\n    callback = config;\n    config = {};\n  }\n\n  const options = Object.assign({}, exports.defaults, config);\n\n  // For backward compatibility before fixing #334\n  if (options.only) {\n    options.remove = options.only;\n  }\n\n  if (!callback) {\n    callback = function (err) {\n      if (err) {\n        log(err.message);\n      }\n    };\n  }\n\n  function done(err) {\n    try {\n      callback(err);\n    } catch (err2) {\n      log('Publish callback threw: %s', err2.message);\n    }\n  }\n\n  try {\n    if (!fs.statSync(basePath).isDirectory()) {\n      done(new Error('The \"base\" option must be an existing directory'));\n      return;\n    }\n  } catch (err) {\n    done(err);\n    return;\n  }\n\n  const files = globby\n    .sync(options.src, {\n      cwd: basePath,\n      dot: options.dotfiles,\n    })\n    .filter((file) => {\n      return !fs.statSync(path.join(basePath, file)).isDirectory();\n    });\n\n  if (!Array.isArray(files) || files.length === 0) {\n    done(\n      new Error('The pattern in the \"src\" property didn\\'t match any files.')\n    );\n    return;\n  }\n\n  let repoUrl;\n  let userPromise;\n  if (options.user) {\n    userPromise = Promise.resolve(options.user);\n  } else {\n    userPromise = getUser();\n  }\n  return userPromise.then((user) =>\n    getRepo(options)\n      .then((repo) => {\n        repoUrl = repo;\n        const clone = getCacheDir(repo);\n        log('Cloning %s into %s', repo, clone);\n        return Git.clone(repo, clone, options.branch, options);\n      })\n      .then((git) => {\n        return git.getRemoteUrl(options.remote).then((url) => {\n          if (url !== repoUrl) {\n            const message =\n              'Remote url mismatch.  Got \"' +\n              url +\n              '\" ' +\n              'but expected \"' +\n              repoUrl +\n              '\" in ' +\n              git.cwd +\n              '.  Try running the `gh-pages-clean` script first.';\n            throw new Error(message);\n          }\n          return git;\n        });\n      })\n      .then((git) => {\n        // only required if someone mucks with the checkout between builds\n        log('Cleaning');\n        return git.clean();\n      })\n      .then((git) => {\n        log('Fetching %s', options.remote);\n        return git.fetch(options.remote);\n      })\n      .then((git) => {\n        log('Checking out %s/%s ', options.remote, options.branch);\n        return git.checkout(options.remote, options.branch);\n      })\n      .then((git) => {\n        if (!options.history) {\n          return git.deleteRef(options.branch);\n        } else {\n          return git;\n        }\n      })\n      .then((git) => {\n        if (options.add) {\n          return git;\n        }\n\n        log('Removing files');\n        const files = globby\n          .sync(options.remove, {\n            cwd: path.join(git.cwd, options.dest),\n          })\n          .map((file) => path.join(options.dest, file));\n        if (files.length > 0) {\n          return git.rm(files);\n        } else {\n          return git;\n        }\n      })\n      .then((git) => {\n        log('Copying files');\n        return copy(files, basePath, path.join(git.cwd, options.dest)).then(\n          function () {\n            return git;\n          }\n        );\n      })\n      .then((git) => {\n        return Promise.resolve(\n          options.beforeAdd && options.beforeAdd(git)\n        ).then(() => git);\n      })\n      .then((git) => {\n        log('Adding all');\n        return git.add('.');\n      })\n      .then((git) => {\n        if (!user) {\n          return git;\n        }\n        return git.exec('config', 'user.email', user.email).then(() => {\n          if (!user.name) {\n            return git;\n          }\n          return git.exec('config', 'user.name', user.name);\n        });\n      })\n      .then((git) => {\n        log('Committing');\n        return git.commit(options.message);\n      })\n      .then((git) => {\n        if (options.tag) {\n          log('Tagging');\n          return git.tag(options.tag).catch((error) => {\n            // tagging failed probably because this tag alredy exists\n            log(error);\n            log('Tagging failed, continuing');\n            return git;\n          });\n        } else {\n          return git;\n        }\n      })\n      .then((git) => {\n        if (options.push) {\n          log('Pushing');\n          return git.push(options.remote, options.branch, !options.history);\n        } else {\n          return git;\n        }\n      })\n      .then(\n        () => done(),\n        (error) => {\n          if (options.silent) {\n            error = new Error(\n              'Unspecified error (run without silent option for detail)'\n            );\n          }\n          done(error);\n        }\n      )\n  );\n};\n\n/**\n * Clean the cache directory.\n */\nexports.clean = function clean() {\n  fs.removeSync(getCacheDir());\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ2gtcGFnZXMvbGliL2luZGV4LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBLHFCQUFxQixtQkFBTyxDQUFDLDhEQUFnQjtBQUM3QyxZQUFZLG1CQUFPLENBQUMsb0RBQVU7QUFDOUIsbUJBQW1CLG1CQUFPLENBQUMsc0RBQVk7QUFDdkMsYUFBYSxrRkFBeUI7QUFDdEMsZ0JBQWdCLHFGQUE0QjtBQUM1QyxXQUFXLG1CQUFPLENBQUMsc0RBQVU7QUFDN0IsZUFBZSxtQkFBTyxDQUFDLDhDQUFRO0FBQy9CLGFBQWEsbUJBQU8sQ0FBQyxtSUFBTTtBQUMzQixhQUFhLG1CQUFPLENBQUMsbUlBQU07O0FBRTNCOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQSw0QkFBNEIsaUJBQWlCO0FBQzdDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1COztBQUVuQjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxVQUFVO0FBQ3JCLFlBQVksU0FBUztBQUNyQjtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQ0FBa0M7O0FBRWxDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsVUFBVTtBQUNWO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3RvZG8tbGlzdC8uL25vZGVfbW9kdWxlcy9naC1wYWdlcy9saWIvaW5kZXguanM/ZmE4ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBmaW5kQ2FjaGVEaXIgPSByZXF1aXJlKCdmaW5kLWNhY2hlLWRpcicpO1xuY29uc3QgR2l0ID0gcmVxdWlyZSgnLi9naXQuanMnKTtcbmNvbnN0IGZpbGVuYW1pZnkgPSByZXF1aXJlKCdmaWxlbmFtaWZ5Jyk7XG5jb25zdCBjb3B5ID0gcmVxdWlyZSgnLi91dGlsLmpzJykuY29weTtcbmNvbnN0IGdldFVzZXIgPSByZXF1aXJlKCcuL3V0aWwuanMnKS5nZXRVc2VyO1xuY29uc3QgZnMgPSByZXF1aXJlKCdmcy1leHRyYScpO1xuY29uc3QgZ2xvYmJ5ID0gcmVxdWlyZSgnZ2xvYmJ5Jyk7XG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xuY29uc3QgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcblxuY29uc3QgbG9nID0gdXRpbC5kZWJ1Z2xvZygnZ2gtcGFnZXMnKTtcblxuLyoqXG4gKiBHZXQgdGhlIGNhY2hlIGRpcmVjdG9yeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0UGF0aF0gT3B0aW9uYWwgcGF0aC5cbiAqIEByZXR1cm4ge3N0cmluZ30gVGhlIGZ1bGwgcGF0aCB0byB0aGUgY2FjaGUgZGlyZWN0b3J5LlxuICovXG5mdW5jdGlvbiBnZXRDYWNoZURpcihvcHRQYXRoKSB7XG4gIGNvbnN0IGRpciA9IGZpbmRDYWNoZURpcih7bmFtZTogJ2doLXBhZ2VzJ30pO1xuICBpZiAoIW9wdFBhdGgpIHtcbiAgICByZXR1cm4gZGlyO1xuICB9XG5cbiAgcmV0dXJuIHBhdGguam9pbihkaXIsIGZpbGVuYW1pZnkob3B0UGF0aCkpO1xufVxuZXhwb3J0cy5nZXRDYWNoZURpciA9IGdldENhY2hlRGlyO1xuXG5mdW5jdGlvbiBnZXRSZXBvKG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMucmVwbykge1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUob3B0aW9ucy5yZXBvKTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBnaXQgPSBuZXcgR2l0KHByb2Nlc3MuY3dkKCksIG9wdGlvbnMuZ2l0KTtcbiAgICByZXR1cm4gZ2l0LmdldFJlbW90ZVVybChvcHRpb25zLnJlbW90ZSk7XG4gIH1cbn1cblxuZXhwb3J0cy5kZWZhdWx0cyA9IHtcbiAgZGVzdDogJy4nLFxuICBhZGQ6IGZhbHNlLFxuICBnaXQ6ICdnaXQnLFxuICBkZXB0aDogMSxcbiAgZG90ZmlsZXM6IGZhbHNlLFxuICBicmFuY2g6ICdnaC1wYWdlcycsXG4gIHJlbW90ZTogJ29yaWdpbicsXG4gIHNyYzogJyoqLyonLFxuICByZW1vdmU6ICcuJyxcbiAgcHVzaDogdHJ1ZSxcbiAgaGlzdG9yeTogdHJ1ZSxcbiAgbWVzc2FnZTogJ1VwZGF0ZXMnLFxuICBzaWxlbnQ6IGZhbHNlLFxufTtcblxuLyoqXG4gKiBQdXNoIGEgZ2l0IGJyYW5jaCB0byBhIHJlbW90ZSAocHVzaGVzIGdoLXBhZ2VzIGJ5IGRlZmF1bHQpLlxuICogQHBhcmFtIHtzdHJpbmd9IGJhc2VQYXRoIFRoZSBiYXNlIHBhdGguXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIFB1Ymxpc2ggb3B0aW9ucy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrLlxuICogQHJldHVybiB7UHJvbWlzZX0gQSBwcm9taXNlLlxuICovXG5leHBvcnRzLnB1Ymxpc2ggPSBmdW5jdGlvbiBwdWJsaXNoKGJhc2VQYXRoLCBjb25maWcsIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2YgY29uZmlnID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBjb25maWc7XG4gICAgY29uZmlnID0ge307XG4gIH1cblxuICBjb25zdCBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgZXhwb3J0cy5kZWZhdWx0cywgY29uZmlnKTtcblxuICAvLyBGb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSBiZWZvcmUgZml4aW5nICMzMzRcbiAgaWYgKG9wdGlvbnMub25seSkge1xuICAgIG9wdGlvbnMucmVtb3ZlID0gb3B0aW9ucy5vbmx5O1xuICB9XG5cbiAgaWYgKCFjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICBsb2coZXJyLm1lc3NhZ2UpO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBkb25lKGVycikge1xuICAgIHRyeSB7XG4gICAgICBjYWxsYmFjayhlcnIpO1xuICAgIH0gY2F0Y2ggKGVycjIpIHtcbiAgICAgIGxvZygnUHVibGlzaCBjYWxsYmFjayB0aHJldzogJXMnLCBlcnIyLm1lc3NhZ2UpO1xuICAgIH1cbiAgfVxuXG4gIHRyeSB7XG4gICAgaWYgKCFmcy5zdGF0U3luYyhiYXNlUGF0aCkuaXNEaXJlY3RvcnkoKSkge1xuICAgICAgZG9uZShuZXcgRXJyb3IoJ1RoZSBcImJhc2VcIiBvcHRpb24gbXVzdCBiZSBhbiBleGlzdGluZyBkaXJlY3RvcnknKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBkb25lKGVycik7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3QgZmlsZXMgPSBnbG9iYnlcbiAgICAuc3luYyhvcHRpb25zLnNyYywge1xuICAgICAgY3dkOiBiYXNlUGF0aCxcbiAgICAgIGRvdDogb3B0aW9ucy5kb3RmaWxlcyxcbiAgICB9KVxuICAgIC5maWx0ZXIoKGZpbGUpID0+IHtcbiAgICAgIHJldHVybiAhZnMuc3RhdFN5bmMocGF0aC5qb2luKGJhc2VQYXRoLCBmaWxlKSkuaXNEaXJlY3RvcnkoKTtcbiAgICB9KTtcblxuICBpZiAoIUFycmF5LmlzQXJyYXkoZmlsZXMpIHx8IGZpbGVzLmxlbmd0aCA9PT0gMCkge1xuICAgIGRvbmUoXG4gICAgICBuZXcgRXJyb3IoJ1RoZSBwYXR0ZXJuIGluIHRoZSBcInNyY1wiIHByb3BlcnR5IGRpZG5cXCd0IG1hdGNoIGFueSBmaWxlcy4nKVxuICAgICk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgbGV0IHJlcG9Vcmw7XG4gIGxldCB1c2VyUHJvbWlzZTtcbiAgaWYgKG9wdGlvbnMudXNlcikge1xuICAgIHVzZXJQcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKG9wdGlvbnMudXNlcik7XG4gIH0gZWxzZSB7XG4gICAgdXNlclByb21pc2UgPSBnZXRVc2VyKCk7XG4gIH1cbiAgcmV0dXJuIHVzZXJQcm9taXNlLnRoZW4oKHVzZXIpID0+XG4gICAgZ2V0UmVwbyhvcHRpb25zKVxuICAgICAgLnRoZW4oKHJlcG8pID0+IHtcbiAgICAgICAgcmVwb1VybCA9IHJlcG87XG4gICAgICAgIGNvbnN0IGNsb25lID0gZ2V0Q2FjaGVEaXIocmVwbyk7XG4gICAgICAgIGxvZygnQ2xvbmluZyAlcyBpbnRvICVzJywgcmVwbywgY2xvbmUpO1xuICAgICAgICByZXR1cm4gR2l0LmNsb25lKHJlcG8sIGNsb25lLCBvcHRpb25zLmJyYW5jaCwgb3B0aW9ucyk7XG4gICAgICB9KVxuICAgICAgLnRoZW4oKGdpdCkgPT4ge1xuICAgICAgICByZXR1cm4gZ2l0LmdldFJlbW90ZVVybChvcHRpb25zLnJlbW90ZSkudGhlbigodXJsKSA9PiB7XG4gICAgICAgICAgaWYgKHVybCAhPT0gcmVwb1VybCkge1xuICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9XG4gICAgICAgICAgICAgICdSZW1vdGUgdXJsIG1pc21hdGNoLiAgR290IFwiJyArXG4gICAgICAgICAgICAgIHVybCArXG4gICAgICAgICAgICAgICdcIiAnICtcbiAgICAgICAgICAgICAgJ2J1dCBleHBlY3RlZCBcIicgK1xuICAgICAgICAgICAgICByZXBvVXJsICtcbiAgICAgICAgICAgICAgJ1wiIGluICcgK1xuICAgICAgICAgICAgICBnaXQuY3dkICtcbiAgICAgICAgICAgICAgJy4gIFRyeSBydW5uaW5nIHRoZSBgZ2gtcGFnZXMtY2xlYW5gIHNjcmlwdCBmaXJzdC4nO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZ2l0O1xuICAgICAgICB9KTtcbiAgICAgIH0pXG4gICAgICAudGhlbigoZ2l0KSA9PiB7XG4gICAgICAgIC8vIG9ubHkgcmVxdWlyZWQgaWYgc29tZW9uZSBtdWNrcyB3aXRoIHRoZSBjaGVja291dCBiZXR3ZWVuIGJ1aWxkc1xuICAgICAgICBsb2coJ0NsZWFuaW5nJyk7XG4gICAgICAgIHJldHVybiBnaXQuY2xlYW4oKTtcbiAgICAgIH0pXG4gICAgICAudGhlbigoZ2l0KSA9PiB7XG4gICAgICAgIGxvZygnRmV0Y2hpbmcgJXMnLCBvcHRpb25zLnJlbW90ZSk7XG4gICAgICAgIHJldHVybiBnaXQuZmV0Y2gob3B0aW9ucy5yZW1vdGUpO1xuICAgICAgfSlcbiAgICAgIC50aGVuKChnaXQpID0+IHtcbiAgICAgICAgbG9nKCdDaGVja2luZyBvdXQgJXMvJXMgJywgb3B0aW9ucy5yZW1vdGUsIG9wdGlvbnMuYnJhbmNoKTtcbiAgICAgICAgcmV0dXJuIGdpdC5jaGVja291dChvcHRpb25zLnJlbW90ZSwgb3B0aW9ucy5icmFuY2gpO1xuICAgICAgfSlcbiAgICAgIC50aGVuKChnaXQpID0+IHtcbiAgICAgICAgaWYgKCFvcHRpb25zLmhpc3RvcnkpIHtcbiAgICAgICAgICByZXR1cm4gZ2l0LmRlbGV0ZVJlZihvcHRpb25zLmJyYW5jaCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGdpdDtcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIC50aGVuKChnaXQpID0+IHtcbiAgICAgICAgaWYgKG9wdGlvbnMuYWRkKSB7XG4gICAgICAgICAgcmV0dXJuIGdpdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGxvZygnUmVtb3ZpbmcgZmlsZXMnKTtcbiAgICAgICAgY29uc3QgZmlsZXMgPSBnbG9iYnlcbiAgICAgICAgICAuc3luYyhvcHRpb25zLnJlbW92ZSwge1xuICAgICAgICAgICAgY3dkOiBwYXRoLmpvaW4oZ2l0LmN3ZCwgb3B0aW9ucy5kZXN0KSxcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5tYXAoKGZpbGUpID0+IHBhdGguam9pbihvcHRpb25zLmRlc3QsIGZpbGUpKTtcbiAgICAgICAgaWYgKGZpbGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICByZXR1cm4gZ2l0LnJtKGZpbGVzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gZ2l0O1xuICAgICAgICB9XG4gICAgICB9KVxuICAgICAgLnRoZW4oKGdpdCkgPT4ge1xuICAgICAgICBsb2coJ0NvcHlpbmcgZmlsZXMnKTtcbiAgICAgICAgcmV0dXJuIGNvcHkoZmlsZXMsIGJhc2VQYXRoLCBwYXRoLmpvaW4oZ2l0LmN3ZCwgb3B0aW9ucy5kZXN0KSkudGhlbihcbiAgICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2l0O1xuICAgICAgICAgIH1cbiAgICAgICAgKTtcbiAgICAgIH0pXG4gICAgICAudGhlbigoZ2l0KSA9PiB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoXG4gICAgICAgICAgb3B0aW9ucy5iZWZvcmVBZGQgJiYgb3B0aW9ucy5iZWZvcmVBZGQoZ2l0KVxuICAgICAgICApLnRoZW4oKCkgPT4gZ2l0KTtcbiAgICAgIH0pXG4gICAgICAudGhlbigoZ2l0KSA9PiB7XG4gICAgICAgIGxvZygnQWRkaW5nIGFsbCcpO1xuICAgICAgICByZXR1cm4gZ2l0LmFkZCgnLicpO1xuICAgICAgfSlcbiAgICAgIC50aGVuKChnaXQpID0+IHtcbiAgICAgICAgaWYgKCF1c2VyKSB7XG4gICAgICAgICAgcmV0dXJuIGdpdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZ2l0LmV4ZWMoJ2NvbmZpZycsICd1c2VyLmVtYWlsJywgdXNlci5lbWFpbCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgaWYgKCF1c2VyLm5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBnaXQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBnaXQuZXhlYygnY29uZmlnJywgJ3VzZXIubmFtZScsIHVzZXIubmFtZSk7XG4gICAgICAgIH0pO1xuICAgICAgfSlcbiAgICAgIC50aGVuKChnaXQpID0+IHtcbiAgICAgICAgbG9nKCdDb21taXR0aW5nJyk7XG4gICAgICAgIHJldHVybiBnaXQuY29tbWl0KG9wdGlvbnMubWVzc2FnZSk7XG4gICAgICB9KVxuICAgICAgLnRoZW4oKGdpdCkgPT4ge1xuICAgICAgICBpZiAob3B0aW9ucy50YWcpIHtcbiAgICAgICAgICBsb2coJ1RhZ2dpbmcnKTtcbiAgICAgICAgICByZXR1cm4gZ2l0LnRhZyhvcHRpb25zLnRhZykuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAvLyB0YWdnaW5nIGZhaWxlZCBwcm9iYWJseSBiZWNhdXNlIHRoaXMgdGFnIGFscmVkeSBleGlzdHNcbiAgICAgICAgICAgIGxvZyhlcnJvcik7XG4gICAgICAgICAgICBsb2coJ1RhZ2dpbmcgZmFpbGVkLCBjb250aW51aW5nJyk7XG4gICAgICAgICAgICByZXR1cm4gZ2l0O1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBnaXQ7XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgICAudGhlbigoZ2l0KSA9PiB7XG4gICAgICAgIGlmIChvcHRpb25zLnB1c2gpIHtcbiAgICAgICAgICBsb2coJ1B1c2hpbmcnKTtcbiAgICAgICAgICByZXR1cm4gZ2l0LnB1c2gob3B0aW9ucy5yZW1vdGUsIG9wdGlvbnMuYnJhbmNoLCAhb3B0aW9ucy5oaXN0b3J5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gZ2l0O1xuICAgICAgICB9XG4gICAgICB9KVxuICAgICAgLnRoZW4oXG4gICAgICAgICgpID0+IGRvbmUoKSxcbiAgICAgICAgKGVycm9yKSA9PiB7XG4gICAgICAgICAgaWYgKG9wdGlvbnMuc2lsZW50KSB7XG4gICAgICAgICAgICBlcnJvciA9IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgJ1Vuc3BlY2lmaWVkIGVycm9yIChydW4gd2l0aG91dCBzaWxlbnQgb3B0aW9uIGZvciBkZXRhaWwpJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZG9uZShlcnJvcik7XG4gICAgICAgIH1cbiAgICAgIClcbiAgKTtcbn07XG5cbi8qKlxuICogQ2xlYW4gdGhlIGNhY2hlIGRpcmVjdG9yeS5cbiAqL1xuZXhwb3J0cy5jbGVhbiA9IGZ1bmN0aW9uIGNsZWFuKCkge1xuICBmcy5yZW1vdmVTeW5jKGdldENhY2hlRGlyKCkpO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/gh-pages/lib/index.js\n");

/***/ }),

/***/ "./node_modules/gh-pages/lib/util.js":
/*!*******************************************!*\
  !*** ./node_modules/gh-pages/lib/util.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("const path = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'path'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\nconst Git = __webpack_require__(/*! ./git.js */ \"./node_modules/gh-pages/lib/git.js\");\nconst async = __webpack_require__(/*! async */ \"./node_modules/async/dist/async.js\");\nconst fs = __webpack_require__(/*! fs-extra */ \"./node_modules/fs-extra/lib/index.js\");\n\n/**\n * Generate a list of unique directory paths given a list of file paths.\n * @param {Array<string>} files List of file paths.\n * @return {Array<string>} List of directory paths.\n */\nfunction uniqueDirs(files) {\n  const dirs = {};\n  files.forEach((filepath) => {\n    const parts = path.dirname(filepath).split(path.sep);\n    let partial = parts[0] || '/';\n    dirs[partial] = true;\n    for (let i = 1, ii = parts.length; i < ii; ++i) {\n      partial = path.join(partial, parts[i]);\n      dirs[partial] = true;\n    }\n  });\n  return Object.keys(dirs);\n}\nexports.uniqueDirs = uniqueDirs;\n\n/**\n * Sort function for paths.  Sorter paths come first.  Paths of equal length are\n * sorted alphanumerically in path segment order.\n * @param {string} a First path.\n * @param {string} b Second path.\n * @return {number} Comparison.\n */\nfunction byShortPath(a, b) {\n  const aParts = a.split(path.sep);\n  const bParts = b.split(path.sep);\n  const aLength = aParts.length;\n  const bLength = bParts.length;\n  let cmp = 0;\n  if (aLength < bLength) {\n    cmp = -1;\n  } else if (aLength > bLength) {\n    cmp = 1;\n  } else {\n    let aPart, bPart;\n    for (let i = 0; i < aLength; ++i) {\n      aPart = aParts[i];\n      bPart = bParts[i];\n      if (aPart < bPart) {\n        cmp = -1;\n        break;\n      } else if (aPart > bPart) {\n        cmp = 1;\n        break;\n      }\n    }\n  }\n  return cmp;\n}\nexports.byShortPath = byShortPath;\n\n/**\n * Generate a list of directories to create given a list of file paths.\n * @param {Array<string>} files List of file paths.\n * @return {Array<string>} List of directory paths ordered by path length.\n */\nfunction dirsToCreate(files) {\n  return uniqueDirs(files).sort(byShortPath);\n}\nexports.dirsToCreate = dirsToCreate;\n\n/**\n * Copy a file.\n * @param {Object} obj Object with src and dest properties.\n * @param {function(Error)} callback Callback\n */\nfunction copyFile(obj, callback) {\n  let called = false;\n  function done(err) {\n    if (!called) {\n      called = true;\n      callback(err);\n    }\n  }\n\n  const read = fs.createReadStream(obj.src);\n  read.on('error', (err) => {\n    done(err);\n  });\n\n  const write = fs.createWriteStream(obj.dest);\n  write.on('error', (err) => {\n    done(err);\n  });\n  write.on('close', () => {\n    done();\n  });\n\n  read.pipe(write);\n}\nexports.copyFile = copyFile;\n\n/**\n * Make directory, ignoring errors if directory already exists.\n * @param {string} path Directory path.\n * @param {function(Error)} callback Callback.\n */\nfunction makeDir(path, callback) {\n  fs.mkdir(path, (err) => {\n    if (err) {\n      // check if directory exists\n      fs.stat(path, (err2, stat) => {\n        if (err2 || !stat.isDirectory()) {\n          callback(err);\n        } else {\n          callback();\n        }\n      });\n    } else {\n      callback();\n    }\n  });\n}\n\n/**\n * Copy a list of files.\n * @param {Array<string>} files Files to copy.\n * @param {string} base Base directory.\n * @param {string} dest Destination directory.\n * @return {Promise} A promise.\n */\nexports.copy = function (files, base, dest) {\n  return new Promise((resolve, reject) => {\n    const pairs = [];\n    const destFiles = [];\n    files.forEach((file) => {\n      const src = path.resolve(base, file);\n      const relative = path.relative(base, src);\n      const target = path.join(dest, relative);\n      pairs.push({\n        src: src,\n        dest: target,\n      });\n      destFiles.push(target);\n    });\n\n    async.eachSeries(dirsToCreate(destFiles), makeDir, (err) => {\n      if (err) {\n        return reject(err);\n      }\n      async.each(pairs, copyFile, (err) => {\n        if (err) {\n          return reject(err);\n        } else {\n          return resolve();\n        }\n      });\n    });\n  });\n};\n\nexports.getUser = function (cwd) {\n  return Promise.all([\n    new Git(cwd).exec('config', 'user.name'),\n    new Git(cwd).exec('config', 'user.email'),\n  ])\n    .then((results) => {\n      return {name: results[0].output.trim(), email: results[1].output.trim()};\n    })\n    .catch((err) => {\n      // git config exits with 1 if name or email is not set\n      return null;\n    });\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ2gtcGFnZXMvbGliL3V0aWwuanMuanMiLCJtYXBwaW5ncyI6IkFBQUEsYUFBYSxtQkFBTyxDQUFDLG1JQUFNO0FBQzNCLFlBQVksbUJBQU8sQ0FBQyxvREFBVTtBQUM5QixjQUFjLG1CQUFPLENBQUMsaURBQU87QUFDN0IsV0FBVyxtQkFBTyxDQUFDLHNEQUFVOztBQUU3QjtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLFlBQVksZUFBZTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxRQUFRO0FBQy9DO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0Esa0JBQWtCOztBQUVsQjtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxvQkFBb0IsYUFBYTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1COztBQUVuQjtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLFlBQVksZUFBZTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjs7QUFFcEI7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLGlCQUFpQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLGdCQUFnQjs7QUFFaEI7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLGlCQUFpQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBLFdBQVcsZUFBZTtBQUMxQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFlBQVksU0FBUztBQUNyQjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90b2RvLWxpc3QvLi9ub2RlX21vZHVsZXMvZ2gtcGFnZXMvbGliL3V0aWwuanM/NTBhYSJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xuY29uc3QgR2l0ID0gcmVxdWlyZSgnLi9naXQuanMnKTtcbmNvbnN0IGFzeW5jID0gcmVxdWlyZSgnYXN5bmMnKTtcbmNvbnN0IGZzID0gcmVxdWlyZSgnZnMtZXh0cmEnKTtcblxuLyoqXG4gKiBHZW5lcmF0ZSBhIGxpc3Qgb2YgdW5pcXVlIGRpcmVjdG9yeSBwYXRocyBnaXZlbiBhIGxpc3Qgb2YgZmlsZSBwYXRocy5cbiAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gZmlsZXMgTGlzdCBvZiBmaWxlIHBhdGhzLlxuICogQHJldHVybiB7QXJyYXk8c3RyaW5nPn0gTGlzdCBvZiBkaXJlY3RvcnkgcGF0aHMuXG4gKi9cbmZ1bmN0aW9uIHVuaXF1ZURpcnMoZmlsZXMpIHtcbiAgY29uc3QgZGlycyA9IHt9O1xuICBmaWxlcy5mb3JFYWNoKChmaWxlcGF0aCkgPT4ge1xuICAgIGNvbnN0IHBhcnRzID0gcGF0aC5kaXJuYW1lKGZpbGVwYXRoKS5zcGxpdChwYXRoLnNlcCk7XG4gICAgbGV0IHBhcnRpYWwgPSBwYXJ0c1swXSB8fCAnLyc7XG4gICAgZGlyc1twYXJ0aWFsXSA9IHRydWU7XG4gICAgZm9yIChsZXQgaSA9IDEsIGlpID0gcGFydHMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgcGFydGlhbCA9IHBhdGguam9pbihwYXJ0aWFsLCBwYXJ0c1tpXSk7XG4gICAgICBkaXJzW3BhcnRpYWxdID0gdHJ1ZTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gT2JqZWN0LmtleXMoZGlycyk7XG59XG5leHBvcnRzLnVuaXF1ZURpcnMgPSB1bmlxdWVEaXJzO1xuXG4vKipcbiAqIFNvcnQgZnVuY3Rpb24gZm9yIHBhdGhzLiAgU29ydGVyIHBhdGhzIGNvbWUgZmlyc3QuICBQYXRocyBvZiBlcXVhbCBsZW5ndGggYXJlXG4gKiBzb3J0ZWQgYWxwaGFudW1lcmljYWxseSBpbiBwYXRoIHNlZ21lbnQgb3JkZXIuXG4gKiBAcGFyYW0ge3N0cmluZ30gYSBGaXJzdCBwYXRoLlxuICogQHBhcmFtIHtzdHJpbmd9IGIgU2Vjb25kIHBhdGguXG4gKiBAcmV0dXJuIHtudW1iZXJ9IENvbXBhcmlzb24uXG4gKi9cbmZ1bmN0aW9uIGJ5U2hvcnRQYXRoKGEsIGIpIHtcbiAgY29uc3QgYVBhcnRzID0gYS5zcGxpdChwYXRoLnNlcCk7XG4gIGNvbnN0IGJQYXJ0cyA9IGIuc3BsaXQocGF0aC5zZXApO1xuICBjb25zdCBhTGVuZ3RoID0gYVBhcnRzLmxlbmd0aDtcbiAgY29uc3QgYkxlbmd0aCA9IGJQYXJ0cy5sZW5ndGg7XG4gIGxldCBjbXAgPSAwO1xuICBpZiAoYUxlbmd0aCA8IGJMZW5ndGgpIHtcbiAgICBjbXAgPSAtMTtcbiAgfSBlbHNlIGlmIChhTGVuZ3RoID4gYkxlbmd0aCkge1xuICAgIGNtcCA9IDE7XG4gIH0gZWxzZSB7XG4gICAgbGV0IGFQYXJ0LCBiUGFydDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFMZW5ndGg7ICsraSkge1xuICAgICAgYVBhcnQgPSBhUGFydHNbaV07XG4gICAgICBiUGFydCA9IGJQYXJ0c1tpXTtcbiAgICAgIGlmIChhUGFydCA8IGJQYXJ0KSB7XG4gICAgICAgIGNtcCA9IC0xO1xuICAgICAgICBicmVhaztcbiAgICAgIH0gZWxzZSBpZiAoYVBhcnQgPiBiUGFydCkge1xuICAgICAgICBjbXAgPSAxO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNtcDtcbn1cbmV4cG9ydHMuYnlTaG9ydFBhdGggPSBieVNob3J0UGF0aDtcblxuLyoqXG4gKiBHZW5lcmF0ZSBhIGxpc3Qgb2YgZGlyZWN0b3JpZXMgdG8gY3JlYXRlIGdpdmVuIGEgbGlzdCBvZiBmaWxlIHBhdGhzLlxuICogQHBhcmFtIHtBcnJheTxzdHJpbmc+fSBmaWxlcyBMaXN0IG9mIGZpbGUgcGF0aHMuXG4gKiBAcmV0dXJuIHtBcnJheTxzdHJpbmc+fSBMaXN0IG9mIGRpcmVjdG9yeSBwYXRocyBvcmRlcmVkIGJ5IHBhdGggbGVuZ3RoLlxuICovXG5mdW5jdGlvbiBkaXJzVG9DcmVhdGUoZmlsZXMpIHtcbiAgcmV0dXJuIHVuaXF1ZURpcnMoZmlsZXMpLnNvcnQoYnlTaG9ydFBhdGgpO1xufVxuZXhwb3J0cy5kaXJzVG9DcmVhdGUgPSBkaXJzVG9DcmVhdGU7XG5cbi8qKlxuICogQ29weSBhIGZpbGUuXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIE9iamVjdCB3aXRoIHNyYyBhbmQgZGVzdCBwcm9wZXJ0aWVzLlxuICogQHBhcmFtIHtmdW5jdGlvbihFcnJvcil9IGNhbGxiYWNrIENhbGxiYWNrXG4gKi9cbmZ1bmN0aW9uIGNvcHlGaWxlKG9iaiwgY2FsbGJhY2spIHtcbiAgbGV0IGNhbGxlZCA9IGZhbHNlO1xuICBmdW5jdGlvbiBkb25lKGVycikge1xuICAgIGlmICghY2FsbGVkKSB7XG4gICAgICBjYWxsZWQgPSB0cnVlO1xuICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICB9XG4gIH1cblxuICBjb25zdCByZWFkID0gZnMuY3JlYXRlUmVhZFN0cmVhbShvYmouc3JjKTtcbiAgcmVhZC5vbignZXJyb3InLCAoZXJyKSA9PiB7XG4gICAgZG9uZShlcnIpO1xuICB9KTtcblxuICBjb25zdCB3cml0ZSA9IGZzLmNyZWF0ZVdyaXRlU3RyZWFtKG9iai5kZXN0KTtcbiAgd3JpdGUub24oJ2Vycm9yJywgKGVycikgPT4ge1xuICAgIGRvbmUoZXJyKTtcbiAgfSk7XG4gIHdyaXRlLm9uKCdjbG9zZScsICgpID0+IHtcbiAgICBkb25lKCk7XG4gIH0pO1xuXG4gIHJlYWQucGlwZSh3cml0ZSk7XG59XG5leHBvcnRzLmNvcHlGaWxlID0gY29weUZpbGU7XG5cbi8qKlxuICogTWFrZSBkaXJlY3RvcnksIGlnbm9yaW5nIGVycm9ycyBpZiBkaXJlY3RvcnkgYWxyZWFkeSBleGlzdHMuXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBEaXJlY3RvcnkgcGF0aC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IpfSBjYWxsYmFjayBDYWxsYmFjay5cbiAqL1xuZnVuY3Rpb24gbWFrZURpcihwYXRoLCBjYWxsYmFjaykge1xuICBmcy5ta2RpcihwYXRoLCAoZXJyKSA9PiB7XG4gICAgaWYgKGVycikge1xuICAgICAgLy8gY2hlY2sgaWYgZGlyZWN0b3J5IGV4aXN0c1xuICAgICAgZnMuc3RhdChwYXRoLCAoZXJyMiwgc3RhdCkgPT4ge1xuICAgICAgICBpZiAoZXJyMiB8fCAhc3RhdC5pc0RpcmVjdG9yeSgpKSB7XG4gICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2FsbGJhY2soKTtcbiAgICB9XG4gIH0pO1xufVxuXG4vKipcbiAqIENvcHkgYSBsaXN0IG9mIGZpbGVzLlxuICogQHBhcmFtIHtBcnJheTxzdHJpbmc+fSBmaWxlcyBGaWxlcyB0byBjb3B5LlxuICogQHBhcmFtIHtzdHJpbmd9IGJhc2UgQmFzZSBkaXJlY3RvcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGVzdCBEZXN0aW5hdGlvbiBkaXJlY3RvcnkuXG4gKiBAcmV0dXJuIHtQcm9taXNlfSBBIHByb21pc2UuXG4gKi9cbmV4cG9ydHMuY29weSA9IGZ1bmN0aW9uIChmaWxlcywgYmFzZSwgZGVzdCkge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGNvbnN0IHBhaXJzID0gW107XG4gICAgY29uc3QgZGVzdEZpbGVzID0gW107XG4gICAgZmlsZXMuZm9yRWFjaCgoZmlsZSkgPT4ge1xuICAgICAgY29uc3Qgc3JjID0gcGF0aC5yZXNvbHZlKGJhc2UsIGZpbGUpO1xuICAgICAgY29uc3QgcmVsYXRpdmUgPSBwYXRoLnJlbGF0aXZlKGJhc2UsIHNyYyk7XG4gICAgICBjb25zdCB0YXJnZXQgPSBwYXRoLmpvaW4oZGVzdCwgcmVsYXRpdmUpO1xuICAgICAgcGFpcnMucHVzaCh7XG4gICAgICAgIHNyYzogc3JjLFxuICAgICAgICBkZXN0OiB0YXJnZXQsXG4gICAgICB9KTtcbiAgICAgIGRlc3RGaWxlcy5wdXNoKHRhcmdldCk7XG4gICAgfSk7XG5cbiAgICBhc3luYy5lYWNoU2VyaWVzKGRpcnNUb0NyZWF0ZShkZXN0RmlsZXMpLCBtYWtlRGlyLCAoZXJyKSA9PiB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHJldHVybiByZWplY3QoZXJyKTtcbiAgICAgIH1cbiAgICAgIGFzeW5jLmVhY2gocGFpcnMsIGNvcHlGaWxlLCAoZXJyKSA9PiB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICByZXR1cm4gcmVqZWN0KGVycik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xufTtcblxuZXhwb3J0cy5nZXRVc2VyID0gZnVuY3Rpb24gKGN3ZCkge1xuICByZXR1cm4gUHJvbWlzZS5hbGwoW1xuICAgIG5ldyBHaXQoY3dkKS5leGVjKCdjb25maWcnLCAndXNlci5uYW1lJyksXG4gICAgbmV3IEdpdChjd2QpLmV4ZWMoJ2NvbmZpZycsICd1c2VyLmVtYWlsJyksXG4gIF0pXG4gICAgLnRoZW4oKHJlc3VsdHMpID0+IHtcbiAgICAgIHJldHVybiB7bmFtZTogcmVzdWx0c1swXS5vdXRwdXQudHJpbSgpLCBlbWFpbDogcmVzdWx0c1sxXS5vdXRwdXQudHJpbSgpfTtcbiAgICB9KVxuICAgIC5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAvLyBnaXQgY29uZmlnIGV4aXRzIHdpdGggMSBpZiBuYW1lIG9yIGVtYWlsIGlzIG5vdCBzZXRcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0pO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/gh-pages/lib/util.js\n");

/***/ }),

/***/ "./node_modules/glob/common.js":
/*!*************************************!*\
  !*** ./node_modules/glob/common.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("exports.setopts = setopts\nexports.ownProp = ownProp\nexports.makeAbs = makeAbs\nexports.finish = finish\nexports.mark = mark\nexports.isIgnored = isIgnored\nexports.childrenIgnored = childrenIgnored\n\nfunction ownProp (obj, field) {\n  return Object.prototype.hasOwnProperty.call(obj, field)\n}\n\nvar fs = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'fs'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()))\nvar path = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'path'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()))\nvar minimatch = __webpack_require__(/*! minimatch */ \"./node_modules/minimatch/minimatch.js\")\nvar isAbsolute = __webpack_require__(/*! path-is-absolute */ \"./node_modules/path-is-absolute/index.js\")\nvar Minimatch = minimatch.Minimatch\n\nfunction alphasort (a, b) {\n  return a.localeCompare(b, 'en')\n}\n\nfunction setupIgnores (self, options) {\n  self.ignore = options.ignore || []\n\n  if (!Array.isArray(self.ignore))\n    self.ignore = [self.ignore]\n\n  if (self.ignore.length) {\n    self.ignore = self.ignore.map(ignoreMap)\n  }\n}\n\n// ignore patterns are always in dot:true mode.\nfunction ignoreMap (pattern) {\n  var gmatcher = null\n  if (pattern.slice(-3) === '/**') {\n    var gpattern = pattern.replace(/(\\/\\*\\*)+$/, '')\n    gmatcher = new Minimatch(gpattern, { dot: true })\n  }\n\n  return {\n    matcher: new Minimatch(pattern, { dot: true }),\n    gmatcher: gmatcher\n  }\n}\n\nfunction setopts (self, pattern, options) {\n  if (!options)\n    options = {}\n\n  // base-matching: just use globstar for that.\n  if (options.matchBase && -1 === pattern.indexOf(\"/\")) {\n    if (options.noglobstar) {\n      throw new Error(\"base matching requires globstar\")\n    }\n    pattern = \"**/\" + pattern\n  }\n\n  self.silent = !!options.silent\n  self.pattern = pattern\n  self.strict = options.strict !== false\n  self.realpath = !!options.realpath\n  self.realpathCache = options.realpathCache || Object.create(null)\n  self.follow = !!options.follow\n  self.dot = !!options.dot\n  self.mark = !!options.mark\n  self.nodir = !!options.nodir\n  if (self.nodir)\n    self.mark = true\n  self.sync = !!options.sync\n  self.nounique = !!options.nounique\n  self.nonull = !!options.nonull\n  self.nosort = !!options.nosort\n  self.nocase = !!options.nocase\n  self.stat = !!options.stat\n  self.noprocess = !!options.noprocess\n  self.absolute = !!options.absolute\n  self.fs = options.fs || fs\n\n  self.maxLength = options.maxLength || Infinity\n  self.cache = options.cache || Object.create(null)\n  self.statCache = options.statCache || Object.create(null)\n  self.symlinks = options.symlinks || Object.create(null)\n\n  setupIgnores(self, options)\n\n  self.changedCwd = false\n  var cwd = process.cwd()\n  if (!ownProp(options, \"cwd\"))\n    self.cwd = cwd\n  else {\n    self.cwd = path.resolve(options.cwd)\n    self.changedCwd = self.cwd !== cwd\n  }\n\n  self.root = options.root || path.resolve(self.cwd, \"/\")\n  self.root = path.resolve(self.root)\n  if (process.platform === \"win32\")\n    self.root = self.root.replace(/\\\\/g, \"/\")\n\n  // TODO: is an absolute `cwd` supposed to be resolved against `root`?\n  // e.g. { cwd: '/test', root: __dirname } === path.join(__dirname, '/test')\n  self.cwdAbs = isAbsolute(self.cwd) ? self.cwd : makeAbs(self, self.cwd)\n  if (process.platform === \"win32\")\n    self.cwdAbs = self.cwdAbs.replace(/\\\\/g, \"/\")\n  self.nomount = !!options.nomount\n\n  // disable comments and negation in Minimatch.\n  // Note that they are not supported in Glob itself anyway.\n  options.nonegate = true\n  options.nocomment = true\n  // always treat \\ in patterns as escapes, not path separators\n  options.allowWindowsEscape = false\n\n  self.minimatch = new Minimatch(pattern, options)\n  self.options = self.minimatch.options\n}\n\nfunction finish (self) {\n  var nou = self.nounique\n  var all = nou ? [] : Object.create(null)\n\n  for (var i = 0, l = self.matches.length; i < l; i ++) {\n    var matches = self.matches[i]\n    if (!matches || Object.keys(matches).length === 0) {\n      if (self.nonull) {\n        // do like the shell, and spit out the literal glob\n        var literal = self.minimatch.globSet[i]\n        if (nou)\n          all.push(literal)\n        else\n          all[literal] = true\n      }\n    } else {\n      // had matches\n      var m = Object.keys(matches)\n      if (nou)\n        all.push.apply(all, m)\n      else\n        m.forEach(function (m) {\n          all[m] = true\n        })\n    }\n  }\n\n  if (!nou)\n    all = Object.keys(all)\n\n  if (!self.nosort)\n    all = all.sort(alphasort)\n\n  // at *some* point we statted all of these\n  if (self.mark) {\n    for (var i = 0; i < all.length; i++) {\n      all[i] = self._mark(all[i])\n    }\n    if (self.nodir) {\n      all = all.filter(function (e) {\n        var notDir = !(/\\/$/.test(e))\n        var c = self.cache[e] || self.cache[makeAbs(self, e)]\n        if (notDir && c)\n          notDir = c !== 'DIR' && !Array.isArray(c)\n        return notDir\n      })\n    }\n  }\n\n  if (self.ignore.length)\n    all = all.filter(function(m) {\n      return !isIgnored(self, m)\n    })\n\n  self.found = all\n}\n\nfunction mark (self, p) {\n  var abs = makeAbs(self, p)\n  var c = self.cache[abs]\n  var m = p\n  if (c) {\n    var isDir = c === 'DIR' || Array.isArray(c)\n    var slash = p.slice(-1) === '/'\n\n    if (isDir && !slash)\n      m += '/'\n    else if (!isDir && slash)\n      m = m.slice(0, -1)\n\n    if (m !== p) {\n      var mabs = makeAbs(self, m)\n      self.statCache[mabs] = self.statCache[abs]\n      self.cache[mabs] = self.cache[abs]\n    }\n  }\n\n  return m\n}\n\n// lotta situps...\nfunction makeAbs (self, f) {\n  var abs = f\n  if (f.charAt(0) === '/') {\n    abs = path.join(self.root, f)\n  } else if (isAbsolute(f) || f === '') {\n    abs = f\n  } else if (self.changedCwd) {\n    abs = path.resolve(self.cwd, f)\n  } else {\n    abs = path.resolve(f)\n  }\n\n  if (process.platform === 'win32')\n    abs = abs.replace(/\\\\/g, '/')\n\n  return abs\n}\n\n\n// Return true, if pattern ends with globstar '**', for the accompanying parent directory.\n// Ex:- If node_modules/** is the pattern, add 'node_modules' to ignore list along with it's contents\nfunction isIgnored (self, path) {\n  if (!self.ignore.length)\n    return false\n\n  return self.ignore.some(function(item) {\n    return item.matcher.match(path) || !!(item.gmatcher && item.gmatcher.match(path))\n  })\n}\n\nfunction childrenIgnored (self, path) {\n  if (!self.ignore.length)\n    return false\n\n  return self.ignore.some(function(item) {\n    return !!(item.gmatcher && item.gmatcher.match(path))\n  })\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ2xvYi9jb21tb24uanMuanMiLCJtYXBwaW5ncyI6IkFBQUEsZUFBZTtBQUNmLGVBQWU7QUFDZixlQUFlO0FBQ2YsY0FBYztBQUNkLFlBQVk7QUFDWixpQkFBaUI7QUFDakIsdUJBQXVCOztBQUV2QjtBQUNBO0FBQ0E7O0FBRUEsU0FBUyxtQkFBTyxDQUFDLGlJQUFJO0FBQ3JCLFdBQVcsbUJBQU8sQ0FBQyxtSUFBTTtBQUN6QixnQkFBZ0IsbUJBQU8sQ0FBQyx3REFBVztBQUNuQyxpQkFBaUIsbUJBQU8sQ0FBQyxrRUFBa0I7QUFDM0M7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLFdBQVc7QUFDcEQ7O0FBRUE7QUFDQSxzQ0FBc0MsV0FBVztBQUNqRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVksZ0NBQWdDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDJDQUEyQyxPQUFPO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90b2RvLWxpc3QvLi9ub2RlX21vZHVsZXMvZ2xvYi9jb21tb24uanM/ZGZmYyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnRzLnNldG9wdHMgPSBzZXRvcHRzXG5leHBvcnRzLm93blByb3AgPSBvd25Qcm9wXG5leHBvcnRzLm1ha2VBYnMgPSBtYWtlQWJzXG5leHBvcnRzLmZpbmlzaCA9IGZpbmlzaFxuZXhwb3J0cy5tYXJrID0gbWFya1xuZXhwb3J0cy5pc0lnbm9yZWQgPSBpc0lnbm9yZWRcbmV4cG9ydHMuY2hpbGRyZW5JZ25vcmVkID0gY2hpbGRyZW5JZ25vcmVkXG5cbmZ1bmN0aW9uIG93blByb3AgKG9iaiwgZmllbGQpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGZpZWxkKVxufVxuXG52YXIgZnMgPSByZXF1aXJlKFwiZnNcIilcbnZhciBwYXRoID0gcmVxdWlyZShcInBhdGhcIilcbnZhciBtaW5pbWF0Y2ggPSByZXF1aXJlKFwibWluaW1hdGNoXCIpXG52YXIgaXNBYnNvbHV0ZSA9IHJlcXVpcmUoXCJwYXRoLWlzLWFic29sdXRlXCIpXG52YXIgTWluaW1hdGNoID0gbWluaW1hdGNoLk1pbmltYXRjaFxuXG5mdW5jdGlvbiBhbHBoYXNvcnQgKGEsIGIpIHtcbiAgcmV0dXJuIGEubG9jYWxlQ29tcGFyZShiLCAnZW4nKVxufVxuXG5mdW5jdGlvbiBzZXR1cElnbm9yZXMgKHNlbGYsIG9wdGlvbnMpIHtcbiAgc2VsZi5pZ25vcmUgPSBvcHRpb25zLmlnbm9yZSB8fCBbXVxuXG4gIGlmICghQXJyYXkuaXNBcnJheShzZWxmLmlnbm9yZSkpXG4gICAgc2VsZi5pZ25vcmUgPSBbc2VsZi5pZ25vcmVdXG5cbiAgaWYgKHNlbGYuaWdub3JlLmxlbmd0aCkge1xuICAgIHNlbGYuaWdub3JlID0gc2VsZi5pZ25vcmUubWFwKGlnbm9yZU1hcClcbiAgfVxufVxuXG4vLyBpZ25vcmUgcGF0dGVybnMgYXJlIGFsd2F5cyBpbiBkb3Q6dHJ1ZSBtb2RlLlxuZnVuY3Rpb24gaWdub3JlTWFwIChwYXR0ZXJuKSB7XG4gIHZhciBnbWF0Y2hlciA9IG51bGxcbiAgaWYgKHBhdHRlcm4uc2xpY2UoLTMpID09PSAnLyoqJykge1xuICAgIHZhciBncGF0dGVybiA9IHBhdHRlcm4ucmVwbGFjZSgvKFxcL1xcKlxcKikrJC8sICcnKVxuICAgIGdtYXRjaGVyID0gbmV3IE1pbmltYXRjaChncGF0dGVybiwgeyBkb3Q6IHRydWUgfSlcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgbWF0Y2hlcjogbmV3IE1pbmltYXRjaChwYXR0ZXJuLCB7IGRvdDogdHJ1ZSB9KSxcbiAgICBnbWF0Y2hlcjogZ21hdGNoZXJcbiAgfVxufVxuXG5mdW5jdGlvbiBzZXRvcHRzIChzZWxmLCBwYXR0ZXJuLCBvcHRpb25zKSB7XG4gIGlmICghb3B0aW9ucylcbiAgICBvcHRpb25zID0ge31cblxuICAvLyBiYXNlLW1hdGNoaW5nOiBqdXN0IHVzZSBnbG9ic3RhciBmb3IgdGhhdC5cbiAgaWYgKG9wdGlvbnMubWF0Y2hCYXNlICYmIC0xID09PSBwYXR0ZXJuLmluZGV4T2YoXCIvXCIpKSB7XG4gICAgaWYgKG9wdGlvbnMubm9nbG9ic3Rhcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYmFzZSBtYXRjaGluZyByZXF1aXJlcyBnbG9ic3RhclwiKVxuICAgIH1cbiAgICBwYXR0ZXJuID0gXCIqKi9cIiArIHBhdHRlcm5cbiAgfVxuXG4gIHNlbGYuc2lsZW50ID0gISFvcHRpb25zLnNpbGVudFxuICBzZWxmLnBhdHRlcm4gPSBwYXR0ZXJuXG4gIHNlbGYuc3RyaWN0ID0gb3B0aW9ucy5zdHJpY3QgIT09IGZhbHNlXG4gIHNlbGYucmVhbHBhdGggPSAhIW9wdGlvbnMucmVhbHBhdGhcbiAgc2VsZi5yZWFscGF0aENhY2hlID0gb3B0aW9ucy5yZWFscGF0aENhY2hlIHx8IE9iamVjdC5jcmVhdGUobnVsbClcbiAgc2VsZi5mb2xsb3cgPSAhIW9wdGlvbnMuZm9sbG93XG4gIHNlbGYuZG90ID0gISFvcHRpb25zLmRvdFxuICBzZWxmLm1hcmsgPSAhIW9wdGlvbnMubWFya1xuICBzZWxmLm5vZGlyID0gISFvcHRpb25zLm5vZGlyXG4gIGlmIChzZWxmLm5vZGlyKVxuICAgIHNlbGYubWFyayA9IHRydWVcbiAgc2VsZi5zeW5jID0gISFvcHRpb25zLnN5bmNcbiAgc2VsZi5ub3VuaXF1ZSA9ICEhb3B0aW9ucy5ub3VuaXF1ZVxuICBzZWxmLm5vbnVsbCA9ICEhb3B0aW9ucy5ub251bGxcbiAgc2VsZi5ub3NvcnQgPSAhIW9wdGlvbnMubm9zb3J0XG4gIHNlbGYubm9jYXNlID0gISFvcHRpb25zLm5vY2FzZVxuICBzZWxmLnN0YXQgPSAhIW9wdGlvbnMuc3RhdFxuICBzZWxmLm5vcHJvY2VzcyA9ICEhb3B0aW9ucy5ub3Byb2Nlc3NcbiAgc2VsZi5hYnNvbHV0ZSA9ICEhb3B0aW9ucy5hYnNvbHV0ZVxuICBzZWxmLmZzID0gb3B0aW9ucy5mcyB8fCBmc1xuXG4gIHNlbGYubWF4TGVuZ3RoID0gb3B0aW9ucy5tYXhMZW5ndGggfHwgSW5maW5pdHlcbiAgc2VsZi5jYWNoZSA9IG9wdGlvbnMuY2FjaGUgfHwgT2JqZWN0LmNyZWF0ZShudWxsKVxuICBzZWxmLnN0YXRDYWNoZSA9IG9wdGlvbnMuc3RhdENhY2hlIHx8IE9iamVjdC5jcmVhdGUobnVsbClcbiAgc2VsZi5zeW1saW5rcyA9IG9wdGlvbnMuc3ltbGlua3MgfHwgT2JqZWN0LmNyZWF0ZShudWxsKVxuXG4gIHNldHVwSWdub3JlcyhzZWxmLCBvcHRpb25zKVxuXG4gIHNlbGYuY2hhbmdlZEN3ZCA9IGZhbHNlXG4gIHZhciBjd2QgPSBwcm9jZXNzLmN3ZCgpXG4gIGlmICghb3duUHJvcChvcHRpb25zLCBcImN3ZFwiKSlcbiAgICBzZWxmLmN3ZCA9IGN3ZFxuICBlbHNlIHtcbiAgICBzZWxmLmN3ZCA9IHBhdGgucmVzb2x2ZShvcHRpb25zLmN3ZClcbiAgICBzZWxmLmNoYW5nZWRDd2QgPSBzZWxmLmN3ZCAhPT0gY3dkXG4gIH1cblxuICBzZWxmLnJvb3QgPSBvcHRpb25zLnJvb3QgfHwgcGF0aC5yZXNvbHZlKHNlbGYuY3dkLCBcIi9cIilcbiAgc2VsZi5yb290ID0gcGF0aC5yZXNvbHZlKHNlbGYucm9vdClcbiAgaWYgKHByb2Nlc3MucGxhdGZvcm0gPT09IFwid2luMzJcIilcbiAgICBzZWxmLnJvb3QgPSBzZWxmLnJvb3QucmVwbGFjZSgvXFxcXC9nLCBcIi9cIilcblxuICAvLyBUT0RPOiBpcyBhbiBhYnNvbHV0ZSBgY3dkYCBzdXBwb3NlZCB0byBiZSByZXNvbHZlZCBhZ2FpbnN0IGByb290YD9cbiAgLy8gZS5nLiB7IGN3ZDogJy90ZXN0Jywgcm9vdDogX19kaXJuYW1lIH0gPT09IHBhdGguam9pbihfX2Rpcm5hbWUsICcvdGVzdCcpXG4gIHNlbGYuY3dkQWJzID0gaXNBYnNvbHV0ZShzZWxmLmN3ZCkgPyBzZWxmLmN3ZCA6IG1ha2VBYnMoc2VsZiwgc2VsZi5jd2QpXG4gIGlmIChwcm9jZXNzLnBsYXRmb3JtID09PSBcIndpbjMyXCIpXG4gICAgc2VsZi5jd2RBYnMgPSBzZWxmLmN3ZEFicy5yZXBsYWNlKC9cXFxcL2csIFwiL1wiKVxuICBzZWxmLm5vbW91bnQgPSAhIW9wdGlvbnMubm9tb3VudFxuXG4gIC8vIGRpc2FibGUgY29tbWVudHMgYW5kIG5lZ2F0aW9uIGluIE1pbmltYXRjaC5cbiAgLy8gTm90ZSB0aGF0IHRoZXkgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gR2xvYiBpdHNlbGYgYW55d2F5LlxuICBvcHRpb25zLm5vbmVnYXRlID0gdHJ1ZVxuICBvcHRpb25zLm5vY29tbWVudCA9IHRydWVcbiAgLy8gYWx3YXlzIHRyZWF0IFxcIGluIHBhdHRlcm5zIGFzIGVzY2FwZXMsIG5vdCBwYXRoIHNlcGFyYXRvcnNcbiAgb3B0aW9ucy5hbGxvd1dpbmRvd3NFc2NhcGUgPSBmYWxzZVxuXG4gIHNlbGYubWluaW1hdGNoID0gbmV3IE1pbmltYXRjaChwYXR0ZXJuLCBvcHRpb25zKVxuICBzZWxmLm9wdGlvbnMgPSBzZWxmLm1pbmltYXRjaC5vcHRpb25zXG59XG5cbmZ1bmN0aW9uIGZpbmlzaCAoc2VsZikge1xuICB2YXIgbm91ID0gc2VsZi5ub3VuaXF1ZVxuICB2YXIgYWxsID0gbm91ID8gW10gOiBPYmplY3QuY3JlYXRlKG51bGwpXG5cbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBzZWxmLm1hdGNoZXMubGVuZ3RoOyBpIDwgbDsgaSArKykge1xuICAgIHZhciBtYXRjaGVzID0gc2VsZi5tYXRjaGVzW2ldXG4gICAgaWYgKCFtYXRjaGVzIHx8IE9iamVjdC5rZXlzKG1hdGNoZXMpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgaWYgKHNlbGYubm9udWxsKSB7XG4gICAgICAgIC8vIGRvIGxpa2UgdGhlIHNoZWxsLCBhbmQgc3BpdCBvdXQgdGhlIGxpdGVyYWwgZ2xvYlxuICAgICAgICB2YXIgbGl0ZXJhbCA9IHNlbGYubWluaW1hdGNoLmdsb2JTZXRbaV1cbiAgICAgICAgaWYgKG5vdSlcbiAgICAgICAgICBhbGwucHVzaChsaXRlcmFsKVxuICAgICAgICBlbHNlXG4gICAgICAgICAgYWxsW2xpdGVyYWxdID0gdHJ1ZVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBoYWQgbWF0Y2hlc1xuICAgICAgdmFyIG0gPSBPYmplY3Qua2V5cyhtYXRjaGVzKVxuICAgICAgaWYgKG5vdSlcbiAgICAgICAgYWxsLnB1c2guYXBwbHkoYWxsLCBtKVxuICAgICAgZWxzZVxuICAgICAgICBtLmZvckVhY2goZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgICBhbGxbbV0gPSB0cnVlXG4gICAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgaWYgKCFub3UpXG4gICAgYWxsID0gT2JqZWN0LmtleXMoYWxsKVxuXG4gIGlmICghc2VsZi5ub3NvcnQpXG4gICAgYWxsID0gYWxsLnNvcnQoYWxwaGFzb3J0KVxuXG4gIC8vIGF0ICpzb21lKiBwb2ludCB3ZSBzdGF0dGVkIGFsbCBvZiB0aGVzZVxuICBpZiAoc2VsZi5tYXJrKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbGwubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFsbFtpXSA9IHNlbGYuX21hcmsoYWxsW2ldKVxuICAgIH1cbiAgICBpZiAoc2VsZi5ub2Rpcikge1xuICAgICAgYWxsID0gYWxsLmZpbHRlcihmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgbm90RGlyID0gISgvXFwvJC8udGVzdChlKSlcbiAgICAgICAgdmFyIGMgPSBzZWxmLmNhY2hlW2VdIHx8IHNlbGYuY2FjaGVbbWFrZUFicyhzZWxmLCBlKV1cbiAgICAgICAgaWYgKG5vdERpciAmJiBjKVxuICAgICAgICAgIG5vdERpciA9IGMgIT09ICdESVInICYmICFBcnJheS5pc0FycmF5KGMpXG4gICAgICAgIHJldHVybiBub3REaXJcbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgaWYgKHNlbGYuaWdub3JlLmxlbmd0aClcbiAgICBhbGwgPSBhbGwuZmlsdGVyKGZ1bmN0aW9uKG0pIHtcbiAgICAgIHJldHVybiAhaXNJZ25vcmVkKHNlbGYsIG0pXG4gICAgfSlcblxuICBzZWxmLmZvdW5kID0gYWxsXG59XG5cbmZ1bmN0aW9uIG1hcmsgKHNlbGYsIHApIHtcbiAgdmFyIGFicyA9IG1ha2VBYnMoc2VsZiwgcClcbiAgdmFyIGMgPSBzZWxmLmNhY2hlW2Fic11cbiAgdmFyIG0gPSBwXG4gIGlmIChjKSB7XG4gICAgdmFyIGlzRGlyID0gYyA9PT0gJ0RJUicgfHwgQXJyYXkuaXNBcnJheShjKVxuICAgIHZhciBzbGFzaCA9IHAuc2xpY2UoLTEpID09PSAnLydcblxuICAgIGlmIChpc0RpciAmJiAhc2xhc2gpXG4gICAgICBtICs9ICcvJ1xuICAgIGVsc2UgaWYgKCFpc0RpciAmJiBzbGFzaClcbiAgICAgIG0gPSBtLnNsaWNlKDAsIC0xKVxuXG4gICAgaWYgKG0gIT09IHApIHtcbiAgICAgIHZhciBtYWJzID0gbWFrZUFicyhzZWxmLCBtKVxuICAgICAgc2VsZi5zdGF0Q2FjaGVbbWFic10gPSBzZWxmLnN0YXRDYWNoZVthYnNdXG4gICAgICBzZWxmLmNhY2hlW21hYnNdID0gc2VsZi5jYWNoZVthYnNdXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG1cbn1cblxuLy8gbG90dGEgc2l0dXBzLi4uXG5mdW5jdGlvbiBtYWtlQWJzIChzZWxmLCBmKSB7XG4gIHZhciBhYnMgPSBmXG4gIGlmIChmLmNoYXJBdCgwKSA9PT0gJy8nKSB7XG4gICAgYWJzID0gcGF0aC5qb2luKHNlbGYucm9vdCwgZilcbiAgfSBlbHNlIGlmIChpc0Fic29sdXRlKGYpIHx8IGYgPT09ICcnKSB7XG4gICAgYWJzID0gZlxuICB9IGVsc2UgaWYgKHNlbGYuY2hhbmdlZEN3ZCkge1xuICAgIGFicyA9IHBhdGgucmVzb2x2ZShzZWxmLmN3ZCwgZilcbiAgfSBlbHNlIHtcbiAgICBhYnMgPSBwYXRoLnJlc29sdmUoZilcbiAgfVxuXG4gIGlmIChwcm9jZXNzLnBsYXRmb3JtID09PSAnd2luMzInKVxuICAgIGFicyA9IGFicy5yZXBsYWNlKC9cXFxcL2csICcvJylcblxuICByZXR1cm4gYWJzXG59XG5cblxuLy8gUmV0dXJuIHRydWUsIGlmIHBhdHRlcm4gZW5kcyB3aXRoIGdsb2JzdGFyICcqKicsIGZvciB0aGUgYWNjb21wYW55aW5nIHBhcmVudCBkaXJlY3RvcnkuXG4vLyBFeDotIElmIG5vZGVfbW9kdWxlcy8qKiBpcyB0aGUgcGF0dGVybiwgYWRkICdub2RlX21vZHVsZXMnIHRvIGlnbm9yZSBsaXN0IGFsb25nIHdpdGggaXQncyBjb250ZW50c1xuZnVuY3Rpb24gaXNJZ25vcmVkIChzZWxmLCBwYXRoKSB7XG4gIGlmICghc2VsZi5pZ25vcmUubGVuZ3RoKVxuICAgIHJldHVybiBmYWxzZVxuXG4gIHJldHVybiBzZWxmLmlnbm9yZS5zb21lKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICByZXR1cm4gaXRlbS5tYXRjaGVyLm1hdGNoKHBhdGgpIHx8ICEhKGl0ZW0uZ21hdGNoZXIgJiYgaXRlbS5nbWF0Y2hlci5tYXRjaChwYXRoKSlcbiAgfSlcbn1cblxuZnVuY3Rpb24gY2hpbGRyZW5JZ25vcmVkIChzZWxmLCBwYXRoKSB7XG4gIGlmICghc2VsZi5pZ25vcmUubGVuZ3RoKVxuICAgIHJldHVybiBmYWxzZVxuXG4gIHJldHVybiBzZWxmLmlnbm9yZS5zb21lKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICByZXR1cm4gISEoaXRlbS5nbWF0Y2hlciAmJiBpdGVtLmdtYXRjaGVyLm1hdGNoKHBhdGgpKVxuICB9KVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/glob/common.js\n");

/***/ }),

/***/ "./node_modules/glob/glob.js":
/*!***********************************!*\
  !*** ./node_modules/glob/glob.js ***!
  \***********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Approach:\n//\n// 1. Get the minimatch set\n// 2. For each pattern in the set, PROCESS(pattern, false)\n// 3. Store matches per-set, then uniq them\n//\n// PROCESS(pattern, inGlobStar)\n// Get the first [n] items from pattern that are all strings\n// Join these together.  This is PREFIX.\n//   If there is no more remaining, then stat(PREFIX) and\n//   add to matches if it succeeds.  END.\n//\n// If inGlobStar and PREFIX is symlink and points to dir\n//   set ENTRIES = []\n// else readdir(PREFIX) as ENTRIES\n//   If fail, END\n//\n// with ENTRIES\n//   If pattern[n] is GLOBSTAR\n//     // handle the case where the globstar match is empty\n//     // by pruning it out, and testing the resulting pattern\n//     PROCESS(pattern[0..n] + pattern[n+1 .. $], false)\n//     // handle other cases.\n//     for ENTRY in ENTRIES (not dotfiles)\n//       // attach globstar + tail onto the entry\n//       // Mark that this entry is a globstar match\n//       PROCESS(pattern[0..n] + ENTRY + pattern[n .. $], true)\n//\n//   else // not globstar\n//     for ENTRY in ENTRIES (not dotfiles, unless pattern[n] is dot)\n//       Test ENTRY against pattern[n]\n//       If fails, continue\n//       If passes, PROCESS(pattern[0..n] + item + pattern[n+1 .. $])\n//\n// Caveat:\n//   Cache all stats and readdirs results to minimize syscall.  Since all\n//   we ever care about is existence and directory-ness, we can just keep\n//   `true` for files, and [children,...] for directories, or `false` for\n//   things that don't exist.\n\nmodule.exports = glob\n\nvar rp = __webpack_require__(/*! fs.realpath */ \"./node_modules/fs.realpath/index.js\")\nvar minimatch = __webpack_require__(/*! minimatch */ \"./node_modules/minimatch/minimatch.js\")\nvar Minimatch = minimatch.Minimatch\nvar inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\")\nvar EE = (__webpack_require__(/*! events */ \"./node_modules/events/events.js\").EventEmitter)\nvar path = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'path'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()))\nvar assert = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'assert'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()))\nvar isAbsolute = __webpack_require__(/*! path-is-absolute */ \"./node_modules/path-is-absolute/index.js\")\nvar globSync = __webpack_require__(/*! ./sync.js */ \"./node_modules/glob/sync.js\")\nvar common = __webpack_require__(/*! ./common.js */ \"./node_modules/glob/common.js\")\nvar setopts = common.setopts\nvar ownProp = common.ownProp\nvar inflight = __webpack_require__(/*! inflight */ \"./node_modules/inflight/inflight.js\")\nvar util = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'util'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()))\nvar childrenIgnored = common.childrenIgnored\nvar isIgnored = common.isIgnored\n\nvar once = __webpack_require__(/*! once */ \"./node_modules/once/once.js\")\n\nfunction glob (pattern, options, cb) {\n  if (typeof options === 'function') cb = options, options = {}\n  if (!options) options = {}\n\n  if (options.sync) {\n    if (cb)\n      throw new TypeError('callback provided to sync glob')\n    return globSync(pattern, options)\n  }\n\n  return new Glob(pattern, options, cb)\n}\n\nglob.sync = globSync\nvar GlobSync = glob.GlobSync = globSync.GlobSync\n\n// old api surface\nglob.glob = glob\n\nfunction extend (origin, add) {\n  if (add === null || typeof add !== 'object') {\n    return origin\n  }\n\n  var keys = Object.keys(add)\n  var i = keys.length\n  while (i--) {\n    origin[keys[i]] = add[keys[i]]\n  }\n  return origin\n}\n\nglob.hasMagic = function (pattern, options_) {\n  var options = extend({}, options_)\n  options.noprocess = true\n\n  var g = new Glob(pattern, options)\n  var set = g.minimatch.set\n\n  if (!pattern)\n    return false\n\n  if (set.length > 1)\n    return true\n\n  for (var j = 0; j < set[0].length; j++) {\n    if (typeof set[0][j] !== 'string')\n      return true\n  }\n\n  return false\n}\n\nglob.Glob = Glob\ninherits(Glob, EE)\nfunction Glob (pattern, options, cb) {\n  if (typeof options === 'function') {\n    cb = options\n    options = null\n  }\n\n  if (options && options.sync) {\n    if (cb)\n      throw new TypeError('callback provided to sync glob')\n    return new GlobSync(pattern, options)\n  }\n\n  if (!(this instanceof Glob))\n    return new Glob(pattern, options, cb)\n\n  setopts(this, pattern, options)\n  this._didRealPath = false\n\n  // process each pattern in the minimatch set\n  var n = this.minimatch.set.length\n\n  // The matches are stored as {<filename>: true,...} so that\n  // duplicates are automagically pruned.\n  // Later, we do an Object.keys() on these.\n  // Keep them as a list so we can fill in when nonull is set.\n  this.matches = new Array(n)\n\n  if (typeof cb === 'function') {\n    cb = once(cb)\n    this.on('error', cb)\n    this.on('end', function (matches) {\n      cb(null, matches)\n    })\n  }\n\n  var self = this\n  this._processing = 0\n\n  this._emitQueue = []\n  this._processQueue = []\n  this.paused = false\n\n  if (this.noprocess)\n    return this\n\n  if (n === 0)\n    return done()\n\n  var sync = true\n  for (var i = 0; i < n; i ++) {\n    this._process(this.minimatch.set[i], i, false, done)\n  }\n  sync = false\n\n  function done () {\n    --self._processing\n    if (self._processing <= 0) {\n      if (sync) {\n        process.nextTick(function () {\n          self._finish()\n        })\n      } else {\n        self._finish()\n      }\n    }\n  }\n}\n\nGlob.prototype._finish = function () {\n  assert(this instanceof Glob)\n  if (this.aborted)\n    return\n\n  if (this.realpath && !this._didRealpath)\n    return this._realpath()\n\n  common.finish(this)\n  this.emit('end', this.found)\n}\n\nGlob.prototype._realpath = function () {\n  if (this._didRealpath)\n    return\n\n  this._didRealpath = true\n\n  var n = this.matches.length\n  if (n === 0)\n    return this._finish()\n\n  var self = this\n  for (var i = 0; i < this.matches.length; i++)\n    this._realpathSet(i, next)\n\n  function next () {\n    if (--n === 0)\n      self._finish()\n  }\n}\n\nGlob.prototype._realpathSet = function (index, cb) {\n  var matchset = this.matches[index]\n  if (!matchset)\n    return cb()\n\n  var found = Object.keys(matchset)\n  var self = this\n  var n = found.length\n\n  if (n === 0)\n    return cb()\n\n  var set = this.matches[index] = Object.create(null)\n  found.forEach(function (p, i) {\n    // If there's a problem with the stat, then it means that\n    // one or more of the links in the realpath couldn't be\n    // resolved.  just return the abs value in that case.\n    p = self._makeAbs(p)\n    rp.realpath(p, self.realpathCache, function (er, real) {\n      if (!er)\n        set[real] = true\n      else if (er.syscall === 'stat')\n        set[p] = true\n      else\n        self.emit('error', er) // srsly wtf right here\n\n      if (--n === 0) {\n        self.matches[index] = set\n        cb()\n      }\n    })\n  })\n}\n\nGlob.prototype._mark = function (p) {\n  return common.mark(this, p)\n}\n\nGlob.prototype._makeAbs = function (f) {\n  return common.makeAbs(this, f)\n}\n\nGlob.prototype.abort = function () {\n  this.aborted = true\n  this.emit('abort')\n}\n\nGlob.prototype.pause = function () {\n  if (!this.paused) {\n    this.paused = true\n    this.emit('pause')\n  }\n}\n\nGlob.prototype.resume = function () {\n  if (this.paused) {\n    this.emit('resume')\n    this.paused = false\n    if (this._emitQueue.length) {\n      var eq = this._emitQueue.slice(0)\n      this._emitQueue.length = 0\n      for (var i = 0; i < eq.length; i ++) {\n        var e = eq[i]\n        this._emitMatch(e[0], e[1])\n      }\n    }\n    if (this._processQueue.length) {\n      var pq = this._processQueue.slice(0)\n      this._processQueue.length = 0\n      for (var i = 0; i < pq.length; i ++) {\n        var p = pq[i]\n        this._processing--\n        this._process(p[0], p[1], p[2], p[3])\n      }\n    }\n  }\n}\n\nGlob.prototype._process = function (pattern, index, inGlobStar, cb) {\n  assert(this instanceof Glob)\n  assert(typeof cb === 'function')\n\n  if (this.aborted)\n    return\n\n  this._processing++\n  if (this.paused) {\n    this._processQueue.push([pattern, index, inGlobStar, cb])\n    return\n  }\n\n  //console.error('PROCESS %d', this._processing, pattern)\n\n  // Get the first [n] parts of pattern that are all strings.\n  var n = 0\n  while (typeof pattern[n] === 'string') {\n    n ++\n  }\n  // now n is the index of the first one that is *not* a string.\n\n  // see if there's anything else\n  var prefix\n  switch (n) {\n    // if not, then this is rather simple\n    case pattern.length:\n      this._processSimple(pattern.join('/'), index, cb)\n      return\n\n    case 0:\n      // pattern *starts* with some non-trivial item.\n      // going to readdir(cwd), but not include the prefix in matches.\n      prefix = null\n      break\n\n    default:\n      // pattern has some string bits in the front.\n      // whatever it starts with, whether that's 'absolute' like /foo/bar,\n      // or 'relative' like '../baz'\n      prefix = pattern.slice(0, n).join('/')\n      break\n  }\n\n  var remain = pattern.slice(n)\n\n  // get the list of entries.\n  var read\n  if (prefix === null)\n    read = '.'\n  else if (isAbsolute(prefix) ||\n      isAbsolute(pattern.map(function (p) {\n        return typeof p === 'string' ? p : '[*]'\n      }).join('/'))) {\n    if (!prefix || !isAbsolute(prefix))\n      prefix = '/' + prefix\n    read = prefix\n  } else\n    read = prefix\n\n  var abs = this._makeAbs(read)\n\n  //if ignored, skip _processing\n  if (childrenIgnored(this, read))\n    return cb()\n\n  var isGlobStar = remain[0] === minimatch.GLOBSTAR\n  if (isGlobStar)\n    this._processGlobStar(prefix, read, abs, remain, index, inGlobStar, cb)\n  else\n    this._processReaddir(prefix, read, abs, remain, index, inGlobStar, cb)\n}\n\nGlob.prototype._processReaddir = function (prefix, read, abs, remain, index, inGlobStar, cb) {\n  var self = this\n  this._readdir(abs, inGlobStar, function (er, entries) {\n    return self._processReaddir2(prefix, read, abs, remain, index, inGlobStar, entries, cb)\n  })\n}\n\nGlob.prototype._processReaddir2 = function (prefix, read, abs, remain, index, inGlobStar, entries, cb) {\n\n  // if the abs isn't a dir, then nothing can match!\n  if (!entries)\n    return cb()\n\n  // It will only match dot entries if it starts with a dot, or if\n  // dot is set.  Stuff like @(.foo|.bar) isn't allowed.\n  var pn = remain[0]\n  var negate = !!this.minimatch.negate\n  var rawGlob = pn._glob\n  var dotOk = this.dot || rawGlob.charAt(0) === '.'\n\n  var matchedEntries = []\n  for (var i = 0; i < entries.length; i++) {\n    var e = entries[i]\n    if (e.charAt(0) !== '.' || dotOk) {\n      var m\n      if (negate && !prefix) {\n        m = !e.match(pn)\n      } else {\n        m = e.match(pn)\n      }\n      if (m)\n        matchedEntries.push(e)\n    }\n  }\n\n  //console.error('prd2', prefix, entries, remain[0]._glob, matchedEntries)\n\n  var len = matchedEntries.length\n  // If there are no matched entries, then nothing matches.\n  if (len === 0)\n    return cb()\n\n  // if this is the last remaining pattern bit, then no need for\n  // an additional stat *unless* the user has specified mark or\n  // stat explicitly.  We know they exist, since readdir returned\n  // them.\n\n  if (remain.length === 1 && !this.mark && !this.stat) {\n    if (!this.matches[index])\n      this.matches[index] = Object.create(null)\n\n    for (var i = 0; i < len; i ++) {\n      var e = matchedEntries[i]\n      if (prefix) {\n        if (prefix !== '/')\n          e = prefix + '/' + e\n        else\n          e = prefix + e\n      }\n\n      if (e.charAt(0) === '/' && !this.nomount) {\n        e = path.join(this.root, e)\n      }\n      this._emitMatch(index, e)\n    }\n    // This was the last one, and no stats were needed\n    return cb()\n  }\n\n  // now test all matched entries as stand-ins for that part\n  // of the pattern.\n  remain.shift()\n  for (var i = 0; i < len; i ++) {\n    var e = matchedEntries[i]\n    var newPattern\n    if (prefix) {\n      if (prefix !== '/')\n        e = prefix + '/' + e\n      else\n        e = prefix + e\n    }\n    this._process([e].concat(remain), index, inGlobStar, cb)\n  }\n  cb()\n}\n\nGlob.prototype._emitMatch = function (index, e) {\n  if (this.aborted)\n    return\n\n  if (isIgnored(this, e))\n    return\n\n  if (this.paused) {\n    this._emitQueue.push([index, e])\n    return\n  }\n\n  var abs = isAbsolute(e) ? e : this._makeAbs(e)\n\n  if (this.mark)\n    e = this._mark(e)\n\n  if (this.absolute)\n    e = abs\n\n  if (this.matches[index][e])\n    return\n\n  if (this.nodir) {\n    var c = this.cache[abs]\n    if (c === 'DIR' || Array.isArray(c))\n      return\n  }\n\n  this.matches[index][e] = true\n\n  var st = this.statCache[abs]\n  if (st)\n    this.emit('stat', e, st)\n\n  this.emit('match', e)\n}\n\nGlob.prototype._readdirInGlobStar = function (abs, cb) {\n  if (this.aborted)\n    return\n\n  // follow all symlinked directories forever\n  // just proceed as if this is a non-globstar situation\n  if (this.follow)\n    return this._readdir(abs, false, cb)\n\n  var lstatkey = 'lstat\\0' + abs\n  var self = this\n  var lstatcb = inflight(lstatkey, lstatcb_)\n\n  if (lstatcb)\n    self.fs.lstat(abs, lstatcb)\n\n  function lstatcb_ (er, lstat) {\n    if (er && er.code === 'ENOENT')\n      return cb()\n\n    var isSym = lstat && lstat.isSymbolicLink()\n    self.symlinks[abs] = isSym\n\n    // If it's not a symlink or a dir, then it's definitely a regular file.\n    // don't bother doing a readdir in that case.\n    if (!isSym && lstat && !lstat.isDirectory()) {\n      self.cache[abs] = 'FILE'\n      cb()\n    } else\n      self._readdir(abs, false, cb)\n  }\n}\n\nGlob.prototype._readdir = function (abs, inGlobStar, cb) {\n  if (this.aborted)\n    return\n\n  cb = inflight('readdir\\0'+abs+'\\0'+inGlobStar, cb)\n  if (!cb)\n    return\n\n  //console.error('RD %j %j', +inGlobStar, abs)\n  if (inGlobStar && !ownProp(this.symlinks, abs))\n    return this._readdirInGlobStar(abs, cb)\n\n  if (ownProp(this.cache, abs)) {\n    var c = this.cache[abs]\n    if (!c || c === 'FILE')\n      return cb()\n\n    if (Array.isArray(c))\n      return cb(null, c)\n  }\n\n  var self = this\n  self.fs.readdir(abs, readdirCb(this, abs, cb))\n}\n\nfunction readdirCb (self, abs, cb) {\n  return function (er, entries) {\n    if (er)\n      self._readdirError(abs, er, cb)\n    else\n      self._readdirEntries(abs, entries, cb)\n  }\n}\n\nGlob.prototype._readdirEntries = function (abs, entries, cb) {\n  if (this.aborted)\n    return\n\n  // if we haven't asked to stat everything, then just\n  // assume that everything in there exists, so we can avoid\n  // having to stat it a second time.\n  if (!this.mark && !this.stat) {\n    for (var i = 0; i < entries.length; i ++) {\n      var e = entries[i]\n      if (abs === '/')\n        e = abs + e\n      else\n        e = abs + '/' + e\n      this.cache[e] = true\n    }\n  }\n\n  this.cache[abs] = entries\n  return cb(null, entries)\n}\n\nGlob.prototype._readdirError = function (f, er, cb) {\n  if (this.aborted)\n    return\n\n  // handle errors, and cache the information\n  switch (er.code) {\n    case 'ENOTSUP': // https://github.com/isaacs/node-glob/issues/205\n    case 'ENOTDIR': // totally normal. means it *does* exist.\n      var abs = this._makeAbs(f)\n      this.cache[abs] = 'FILE'\n      if (abs === this.cwdAbs) {\n        var error = new Error(er.code + ' invalid cwd ' + this.cwd)\n        error.path = this.cwd\n        error.code = er.code\n        this.emit('error', error)\n        this.abort()\n      }\n      break\n\n    case 'ENOENT': // not terribly unusual\n    case 'ELOOP':\n    case 'ENAMETOOLONG':\n    case 'UNKNOWN':\n      this.cache[this._makeAbs(f)] = false\n      break\n\n    default: // some unusual error.  Treat as failure.\n      this.cache[this._makeAbs(f)] = false\n      if (this.strict) {\n        this.emit('error', er)\n        // If the error is handled, then we abort\n        // if not, we threw out of here\n        this.abort()\n      }\n      if (!this.silent)\n        console.error('glob error', er)\n      break\n  }\n\n  return cb()\n}\n\nGlob.prototype._processGlobStar = function (prefix, read, abs, remain, index, inGlobStar, cb) {\n  var self = this\n  this._readdir(abs, inGlobStar, function (er, entries) {\n    self._processGlobStar2(prefix, read, abs, remain, index, inGlobStar, entries, cb)\n  })\n}\n\n\nGlob.prototype._processGlobStar2 = function (prefix, read, abs, remain, index, inGlobStar, entries, cb) {\n  //console.error('pgs2', prefix, remain[0], entries)\n\n  // no entries means not a dir, so it can never have matches\n  // foo.txt/** doesn't match foo.txt\n  if (!entries)\n    return cb()\n\n  // test without the globstar, and with every child both below\n  // and replacing the globstar.\n  var remainWithoutGlobStar = remain.slice(1)\n  var gspref = prefix ? [ prefix ] : []\n  var noGlobStar = gspref.concat(remainWithoutGlobStar)\n\n  // the noGlobStar pattern exits the inGlobStar state\n  this._process(noGlobStar, index, false, cb)\n\n  var isSym = this.symlinks[abs]\n  var len = entries.length\n\n  // If it's a symlink, and we're in a globstar, then stop\n  if (isSym && inGlobStar)\n    return cb()\n\n  for (var i = 0; i < len; i++) {\n    var e = entries[i]\n    if (e.charAt(0) === '.' && !this.dot)\n      continue\n\n    // these two cases enter the inGlobStar state\n    var instead = gspref.concat(entries[i], remainWithoutGlobStar)\n    this._process(instead, index, true, cb)\n\n    var below = gspref.concat(entries[i], remain)\n    this._process(below, index, true, cb)\n  }\n\n  cb()\n}\n\nGlob.prototype._processSimple = function (prefix, index, cb) {\n  // XXX review this.  Shouldn't it be doing the mounting etc\n  // before doing stat?  kinda weird?\n  var self = this\n  this._stat(prefix, function (er, exists) {\n    self._processSimple2(prefix, index, er, exists, cb)\n  })\n}\nGlob.prototype._processSimple2 = function (prefix, index, er, exists, cb) {\n\n  //console.error('ps2', prefix, exists)\n\n  if (!this.matches[index])\n    this.matches[index] = Object.create(null)\n\n  // If it doesn't exist, then just mark the lack of results\n  if (!exists)\n    return cb()\n\n  if (prefix && isAbsolute(prefix) && !this.nomount) {\n    var trail = /[\\/\\\\]$/.test(prefix)\n    if (prefix.charAt(0) === '/') {\n      prefix = path.join(this.root, prefix)\n    } else {\n      prefix = path.resolve(this.root, prefix)\n      if (trail)\n        prefix += '/'\n    }\n  }\n\n  if (process.platform === 'win32')\n    prefix = prefix.replace(/\\\\/g, '/')\n\n  // Mark this as a match\n  this._emitMatch(index, prefix)\n  cb()\n}\n\n// Returns either 'DIR', 'FILE', or false\nGlob.prototype._stat = function (f, cb) {\n  var abs = this._makeAbs(f)\n  var needDir = f.slice(-1) === '/'\n\n  if (f.length > this.maxLength)\n    return cb()\n\n  if (!this.stat && ownProp(this.cache, abs)) {\n    var c = this.cache[abs]\n\n    if (Array.isArray(c))\n      c = 'DIR'\n\n    // It exists, but maybe not how we need it\n    if (!needDir || c === 'DIR')\n      return cb(null, c)\n\n    if (needDir && c === 'FILE')\n      return cb()\n\n    // otherwise we have to stat, because maybe c=true\n    // if we know it exists, but not what it is.\n  }\n\n  var exists\n  var stat = this.statCache[abs]\n  if (stat !== undefined) {\n    if (stat === false)\n      return cb(null, stat)\n    else {\n      var type = stat.isDirectory() ? 'DIR' : 'FILE'\n      if (needDir && type === 'FILE')\n        return cb()\n      else\n        return cb(null, type, stat)\n    }\n  }\n\n  var self = this\n  var statcb = inflight('stat\\0' + abs, lstatcb_)\n  if (statcb)\n    self.fs.lstat(abs, statcb)\n\n  function lstatcb_ (er, lstat) {\n    if (lstat && lstat.isSymbolicLink()) {\n      // If it's a symlink, then treat it as the target, unless\n      // the target does not exist, then treat it as a file.\n      return self.fs.stat(abs, function (er, stat) {\n        if (er)\n          self._stat2(f, abs, null, lstat, cb)\n        else\n          self._stat2(f, abs, er, stat, cb)\n      })\n    } else {\n      self._stat2(f, abs, er, lstat, cb)\n    }\n  }\n}\n\nGlob.prototype._stat2 = function (f, abs, er, stat, cb) {\n  if (er && (er.code === 'ENOENT' || er.code === 'ENOTDIR')) {\n    this.statCache[abs] = false\n    return cb()\n  }\n\n  var needDir = f.slice(-1) === '/'\n  this.statCache[abs] = stat\n\n  if (abs.slice(-1) === '/' && stat && !stat.isDirectory())\n    return cb(null, false, stat)\n\n  var c = true\n  if (stat)\n    c = stat.isDirectory() ? 'DIR' : 'FILE'\n  this.cache[abs] = this.cache[abs] || c\n\n  if (needDir && c === 'FILE')\n    return cb()\n\n  return cb(null, c, stat)\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ2xvYi9nbG9iLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxTQUFTLG1CQUFPLENBQUMsd0RBQWE7QUFDOUIsZ0JBQWdCLG1CQUFPLENBQUMsd0RBQVc7QUFDbkM7QUFDQSxlQUFlLG1CQUFPLENBQUMsNkRBQVU7QUFDakMsU0FBUyxtRkFBOEI7QUFDdkMsV0FBVyxtQkFBTyxDQUFDLG1JQUFNO0FBQ3pCLGFBQWEsbUJBQU8sQ0FBQyxxSUFBUTtBQUM3QixpQkFBaUIsbUJBQU8sQ0FBQyxrRUFBa0I7QUFDM0MsZUFBZSxtQkFBTyxDQUFDLDhDQUFXO0FBQ2xDLGFBQWEsbUJBQU8sQ0FBQyxrREFBYTtBQUNsQztBQUNBO0FBQ0EsZUFBZSxtQkFBTyxDQUFDLHFEQUFVO0FBQ2pDLFdBQVcsbUJBQU8sQ0FBQyxtSUFBTTtBQUN6QjtBQUNBOztBQUVBLFdBQVcsbUJBQU8sQ0FBQyx5Q0FBTTs7QUFFekI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5QkFBeUI7QUFDekI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsa0JBQWtCLG1CQUFtQjtBQUNyQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGdDQUFnQyxzQkFBc0I7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IsT0FBTztBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IseUJBQXlCO0FBQzNDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGVBQWU7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsZUFBZTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0Isb0JBQW9CO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG9CQUFvQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3RvZG8tbGlzdC8uL25vZGVfbW9kdWxlcy9nbG9iL2dsb2IuanM/ZTE0MCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBBcHByb2FjaDpcbi8vXG4vLyAxLiBHZXQgdGhlIG1pbmltYXRjaCBzZXRcbi8vIDIuIEZvciBlYWNoIHBhdHRlcm4gaW4gdGhlIHNldCwgUFJPQ0VTUyhwYXR0ZXJuLCBmYWxzZSlcbi8vIDMuIFN0b3JlIG1hdGNoZXMgcGVyLXNldCwgdGhlbiB1bmlxIHRoZW1cbi8vXG4vLyBQUk9DRVNTKHBhdHRlcm4sIGluR2xvYlN0YXIpXG4vLyBHZXQgdGhlIGZpcnN0IFtuXSBpdGVtcyBmcm9tIHBhdHRlcm4gdGhhdCBhcmUgYWxsIHN0cmluZ3Ncbi8vIEpvaW4gdGhlc2UgdG9nZXRoZXIuICBUaGlzIGlzIFBSRUZJWC5cbi8vICAgSWYgdGhlcmUgaXMgbm8gbW9yZSByZW1haW5pbmcsIHRoZW4gc3RhdChQUkVGSVgpIGFuZFxuLy8gICBhZGQgdG8gbWF0Y2hlcyBpZiBpdCBzdWNjZWVkcy4gIEVORC5cbi8vXG4vLyBJZiBpbkdsb2JTdGFyIGFuZCBQUkVGSVggaXMgc3ltbGluayBhbmQgcG9pbnRzIHRvIGRpclxuLy8gICBzZXQgRU5UUklFUyA9IFtdXG4vLyBlbHNlIHJlYWRkaXIoUFJFRklYKSBhcyBFTlRSSUVTXG4vLyAgIElmIGZhaWwsIEVORFxuLy9cbi8vIHdpdGggRU5UUklFU1xuLy8gICBJZiBwYXR0ZXJuW25dIGlzIEdMT0JTVEFSXG4vLyAgICAgLy8gaGFuZGxlIHRoZSBjYXNlIHdoZXJlIHRoZSBnbG9ic3RhciBtYXRjaCBpcyBlbXB0eVxuLy8gICAgIC8vIGJ5IHBydW5pbmcgaXQgb3V0LCBhbmQgdGVzdGluZyB0aGUgcmVzdWx0aW5nIHBhdHRlcm5cbi8vICAgICBQUk9DRVNTKHBhdHRlcm5bMC4ubl0gKyBwYXR0ZXJuW24rMSAuLiAkXSwgZmFsc2UpXG4vLyAgICAgLy8gaGFuZGxlIG90aGVyIGNhc2VzLlxuLy8gICAgIGZvciBFTlRSWSBpbiBFTlRSSUVTIChub3QgZG90ZmlsZXMpXG4vLyAgICAgICAvLyBhdHRhY2ggZ2xvYnN0YXIgKyB0YWlsIG9udG8gdGhlIGVudHJ5XG4vLyAgICAgICAvLyBNYXJrIHRoYXQgdGhpcyBlbnRyeSBpcyBhIGdsb2JzdGFyIG1hdGNoXG4vLyAgICAgICBQUk9DRVNTKHBhdHRlcm5bMC4ubl0gKyBFTlRSWSArIHBhdHRlcm5bbiAuLiAkXSwgdHJ1ZSlcbi8vXG4vLyAgIGVsc2UgLy8gbm90IGdsb2JzdGFyXG4vLyAgICAgZm9yIEVOVFJZIGluIEVOVFJJRVMgKG5vdCBkb3RmaWxlcywgdW5sZXNzIHBhdHRlcm5bbl0gaXMgZG90KVxuLy8gICAgICAgVGVzdCBFTlRSWSBhZ2FpbnN0IHBhdHRlcm5bbl1cbi8vICAgICAgIElmIGZhaWxzLCBjb250aW51ZVxuLy8gICAgICAgSWYgcGFzc2VzLCBQUk9DRVNTKHBhdHRlcm5bMC4ubl0gKyBpdGVtICsgcGF0dGVybltuKzEgLi4gJF0pXG4vL1xuLy8gQ2F2ZWF0OlxuLy8gICBDYWNoZSBhbGwgc3RhdHMgYW5kIHJlYWRkaXJzIHJlc3VsdHMgdG8gbWluaW1pemUgc3lzY2FsbC4gIFNpbmNlIGFsbFxuLy8gICB3ZSBldmVyIGNhcmUgYWJvdXQgaXMgZXhpc3RlbmNlIGFuZCBkaXJlY3RvcnktbmVzcywgd2UgY2FuIGp1c3Qga2VlcFxuLy8gICBgdHJ1ZWAgZm9yIGZpbGVzLCBhbmQgW2NoaWxkcmVuLC4uLl0gZm9yIGRpcmVjdG9yaWVzLCBvciBgZmFsc2VgIGZvclxuLy8gICB0aGluZ3MgdGhhdCBkb24ndCBleGlzdC5cblxubW9kdWxlLmV4cG9ydHMgPSBnbG9iXG5cbnZhciBycCA9IHJlcXVpcmUoJ2ZzLnJlYWxwYXRoJylcbnZhciBtaW5pbWF0Y2ggPSByZXF1aXJlKCdtaW5pbWF0Y2gnKVxudmFyIE1pbmltYXRjaCA9IG1pbmltYXRjaC5NaW5pbWF0Y2hcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbnZhciBFRSA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlclxudmFyIHBhdGggPSByZXF1aXJlKCdwYXRoJylcbnZhciBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKVxudmFyIGlzQWJzb2x1dGUgPSByZXF1aXJlKCdwYXRoLWlzLWFic29sdXRlJylcbnZhciBnbG9iU3luYyA9IHJlcXVpcmUoJy4vc3luYy5qcycpXG52YXIgY29tbW9uID0gcmVxdWlyZSgnLi9jb21tb24uanMnKVxudmFyIHNldG9wdHMgPSBjb21tb24uc2V0b3B0c1xudmFyIG93blByb3AgPSBjb21tb24ub3duUHJvcFxudmFyIGluZmxpZ2h0ID0gcmVxdWlyZSgnaW5mbGlnaHQnKVxudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJylcbnZhciBjaGlsZHJlbklnbm9yZWQgPSBjb21tb24uY2hpbGRyZW5JZ25vcmVkXG52YXIgaXNJZ25vcmVkID0gY29tbW9uLmlzSWdub3JlZFxuXG52YXIgb25jZSA9IHJlcXVpcmUoJ29uY2UnKVxuXG5mdW5jdGlvbiBnbG9iIChwYXR0ZXJuLCBvcHRpb25zLCBjYikge1xuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIGNiID0gb3B0aW9ucywgb3B0aW9ucyA9IHt9XG4gIGlmICghb3B0aW9ucykgb3B0aW9ucyA9IHt9XG5cbiAgaWYgKG9wdGlvbnMuc3luYykge1xuICAgIGlmIChjYilcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2NhbGxiYWNrIHByb3ZpZGVkIHRvIHN5bmMgZ2xvYicpXG4gICAgcmV0dXJuIGdsb2JTeW5jKHBhdHRlcm4sIG9wdGlvbnMpXG4gIH1cblxuICByZXR1cm4gbmV3IEdsb2IocGF0dGVybiwgb3B0aW9ucywgY2IpXG59XG5cbmdsb2Iuc3luYyA9IGdsb2JTeW5jXG52YXIgR2xvYlN5bmMgPSBnbG9iLkdsb2JTeW5jID0gZ2xvYlN5bmMuR2xvYlN5bmNcblxuLy8gb2xkIGFwaSBzdXJmYWNlXG5nbG9iLmdsb2IgPSBnbG9iXG5cbmZ1bmN0aW9uIGV4dGVuZCAob3JpZ2luLCBhZGQpIHtcbiAgaWYgKGFkZCA9PT0gbnVsbCB8fCB0eXBlb2YgYWRkICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBvcmlnaW5cbiAgfVxuXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoYWRkKVxuICB2YXIgaSA9IGtleXMubGVuZ3RoXG4gIHdoaWxlIChpLS0pIHtcbiAgICBvcmlnaW5ba2V5c1tpXV0gPSBhZGRba2V5c1tpXV1cbiAgfVxuICByZXR1cm4gb3JpZ2luXG59XG5cbmdsb2IuaGFzTWFnaWMgPSBmdW5jdGlvbiAocGF0dGVybiwgb3B0aW9uc18pIHtcbiAgdmFyIG9wdGlvbnMgPSBleHRlbmQoe30sIG9wdGlvbnNfKVxuICBvcHRpb25zLm5vcHJvY2VzcyA9IHRydWVcblxuICB2YXIgZyA9IG5ldyBHbG9iKHBhdHRlcm4sIG9wdGlvbnMpXG4gIHZhciBzZXQgPSBnLm1pbmltYXRjaC5zZXRcblxuICBpZiAoIXBhdHRlcm4pXG4gICAgcmV0dXJuIGZhbHNlXG5cbiAgaWYgKHNldC5sZW5ndGggPiAxKVxuICAgIHJldHVybiB0cnVlXG5cbiAgZm9yICh2YXIgaiA9IDA7IGogPCBzZXRbMF0ubGVuZ3RoOyBqKyspIHtcbiAgICBpZiAodHlwZW9mIHNldFswXVtqXSAhPT0gJ3N0cmluZycpXG4gICAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlXG59XG5cbmdsb2IuR2xvYiA9IEdsb2JcbmluaGVyaXRzKEdsb2IsIEVFKVxuZnVuY3Rpb24gR2xvYiAocGF0dGVybiwgb3B0aW9ucywgY2IpIHtcbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBvcHRpb25zXG4gICAgb3B0aW9ucyA9IG51bGxcbiAgfVxuXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMuc3luYykge1xuICAgIGlmIChjYilcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2NhbGxiYWNrIHByb3ZpZGVkIHRvIHN5bmMgZ2xvYicpXG4gICAgcmV0dXJuIG5ldyBHbG9iU3luYyhwYXR0ZXJuLCBvcHRpb25zKVxuICB9XG5cbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEdsb2IpKVxuICAgIHJldHVybiBuZXcgR2xvYihwYXR0ZXJuLCBvcHRpb25zLCBjYilcblxuICBzZXRvcHRzKHRoaXMsIHBhdHRlcm4sIG9wdGlvbnMpXG4gIHRoaXMuX2RpZFJlYWxQYXRoID0gZmFsc2VcblxuICAvLyBwcm9jZXNzIGVhY2ggcGF0dGVybiBpbiB0aGUgbWluaW1hdGNoIHNldFxuICB2YXIgbiA9IHRoaXMubWluaW1hdGNoLnNldC5sZW5ndGhcblxuICAvLyBUaGUgbWF0Y2hlcyBhcmUgc3RvcmVkIGFzIHs8ZmlsZW5hbWU+OiB0cnVlLC4uLn0gc28gdGhhdFxuICAvLyBkdXBsaWNhdGVzIGFyZSBhdXRvbWFnaWNhbGx5IHBydW5lZC5cbiAgLy8gTGF0ZXIsIHdlIGRvIGFuIE9iamVjdC5rZXlzKCkgb24gdGhlc2UuXG4gIC8vIEtlZXAgdGhlbSBhcyBhIGxpc3Qgc28gd2UgY2FuIGZpbGwgaW4gd2hlbiBub251bGwgaXMgc2V0LlxuICB0aGlzLm1hdGNoZXMgPSBuZXcgQXJyYXkobilcblxuICBpZiAodHlwZW9mIGNiID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBvbmNlKGNiKVxuICAgIHRoaXMub24oJ2Vycm9yJywgY2IpXG4gICAgdGhpcy5vbignZW5kJywgZnVuY3Rpb24gKG1hdGNoZXMpIHtcbiAgICAgIGNiKG51bGwsIG1hdGNoZXMpXG4gICAgfSlcbiAgfVxuXG4gIHZhciBzZWxmID0gdGhpc1xuICB0aGlzLl9wcm9jZXNzaW5nID0gMFxuXG4gIHRoaXMuX2VtaXRRdWV1ZSA9IFtdXG4gIHRoaXMuX3Byb2Nlc3NRdWV1ZSA9IFtdXG4gIHRoaXMucGF1c2VkID0gZmFsc2VcblxuICBpZiAodGhpcy5ub3Byb2Nlc3MpXG4gICAgcmV0dXJuIHRoaXNcblxuICBpZiAobiA9PT0gMClcbiAgICByZXR1cm4gZG9uZSgpXG5cbiAgdmFyIHN5bmMgPSB0cnVlXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSArKykge1xuICAgIHRoaXMuX3Byb2Nlc3ModGhpcy5taW5pbWF0Y2guc2V0W2ldLCBpLCBmYWxzZSwgZG9uZSlcbiAgfVxuICBzeW5jID0gZmFsc2VcblxuICBmdW5jdGlvbiBkb25lICgpIHtcbiAgICAtLXNlbGYuX3Byb2Nlc3NpbmdcbiAgICBpZiAoc2VsZi5fcHJvY2Vzc2luZyA8PSAwKSB7XG4gICAgICBpZiAoc3luYykge1xuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBzZWxmLl9maW5pc2goKVxuICAgICAgICB9KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VsZi5fZmluaXNoKClcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuR2xvYi5wcm90b3R5cGUuX2ZpbmlzaCA9IGZ1bmN0aW9uICgpIHtcbiAgYXNzZXJ0KHRoaXMgaW5zdGFuY2VvZiBHbG9iKVxuICBpZiAodGhpcy5hYm9ydGVkKVxuICAgIHJldHVyblxuXG4gIGlmICh0aGlzLnJlYWxwYXRoICYmICF0aGlzLl9kaWRSZWFscGF0aClcbiAgICByZXR1cm4gdGhpcy5fcmVhbHBhdGgoKVxuXG4gIGNvbW1vbi5maW5pc2godGhpcylcbiAgdGhpcy5lbWl0KCdlbmQnLCB0aGlzLmZvdW5kKVxufVxuXG5HbG9iLnByb3RvdHlwZS5fcmVhbHBhdGggPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLl9kaWRSZWFscGF0aClcbiAgICByZXR1cm5cblxuICB0aGlzLl9kaWRSZWFscGF0aCA9IHRydWVcblxuICB2YXIgbiA9IHRoaXMubWF0Y2hlcy5sZW5ndGhcbiAgaWYgKG4gPT09IDApXG4gICAgcmV0dXJuIHRoaXMuX2ZpbmlzaCgpXG5cbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5tYXRjaGVzLmxlbmd0aDsgaSsrKVxuICAgIHRoaXMuX3JlYWxwYXRoU2V0KGksIG5leHQpXG5cbiAgZnVuY3Rpb24gbmV4dCAoKSB7XG4gICAgaWYgKC0tbiA9PT0gMClcbiAgICAgIHNlbGYuX2ZpbmlzaCgpXG4gIH1cbn1cblxuR2xvYi5wcm90b3R5cGUuX3JlYWxwYXRoU2V0ID0gZnVuY3Rpb24gKGluZGV4LCBjYikge1xuICB2YXIgbWF0Y2hzZXQgPSB0aGlzLm1hdGNoZXNbaW5kZXhdXG4gIGlmICghbWF0Y2hzZXQpXG4gICAgcmV0dXJuIGNiKClcblxuICB2YXIgZm91bmQgPSBPYmplY3Qua2V5cyhtYXRjaHNldClcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHZhciBuID0gZm91bmQubGVuZ3RoXG5cbiAgaWYgKG4gPT09IDApXG4gICAgcmV0dXJuIGNiKClcblxuICB2YXIgc2V0ID0gdGhpcy5tYXRjaGVzW2luZGV4XSA9IE9iamVjdC5jcmVhdGUobnVsbClcbiAgZm91bmQuZm9yRWFjaChmdW5jdGlvbiAocCwgaSkge1xuICAgIC8vIElmIHRoZXJlJ3MgYSBwcm9ibGVtIHdpdGggdGhlIHN0YXQsIHRoZW4gaXQgbWVhbnMgdGhhdFxuICAgIC8vIG9uZSBvciBtb3JlIG9mIHRoZSBsaW5rcyBpbiB0aGUgcmVhbHBhdGggY291bGRuJ3QgYmVcbiAgICAvLyByZXNvbHZlZC4gIGp1c3QgcmV0dXJuIHRoZSBhYnMgdmFsdWUgaW4gdGhhdCBjYXNlLlxuICAgIHAgPSBzZWxmLl9tYWtlQWJzKHApXG4gICAgcnAucmVhbHBhdGgocCwgc2VsZi5yZWFscGF0aENhY2hlLCBmdW5jdGlvbiAoZXIsIHJlYWwpIHtcbiAgICAgIGlmICghZXIpXG4gICAgICAgIHNldFtyZWFsXSA9IHRydWVcbiAgICAgIGVsc2UgaWYgKGVyLnN5c2NhbGwgPT09ICdzdGF0JylcbiAgICAgICAgc2V0W3BdID0gdHJ1ZVxuICAgICAgZWxzZVxuICAgICAgICBzZWxmLmVtaXQoJ2Vycm9yJywgZXIpIC8vIHNyc2x5IHd0ZiByaWdodCBoZXJlXG5cbiAgICAgIGlmICgtLW4gPT09IDApIHtcbiAgICAgICAgc2VsZi5tYXRjaGVzW2luZGV4XSA9IHNldFxuICAgICAgICBjYigpXG4gICAgICB9XG4gICAgfSlcbiAgfSlcbn1cblxuR2xvYi5wcm90b3R5cGUuX21hcmsgPSBmdW5jdGlvbiAocCkge1xuICByZXR1cm4gY29tbW9uLm1hcmsodGhpcywgcClcbn1cblxuR2xvYi5wcm90b3R5cGUuX21ha2VBYnMgPSBmdW5jdGlvbiAoZikge1xuICByZXR1cm4gY29tbW9uLm1ha2VBYnModGhpcywgZilcbn1cblxuR2xvYi5wcm90b3R5cGUuYWJvcnQgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuYWJvcnRlZCA9IHRydWVcbiAgdGhpcy5lbWl0KCdhYm9ydCcpXG59XG5cbkdsb2IucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24gKCkge1xuICBpZiAoIXRoaXMucGF1c2VkKSB7XG4gICAgdGhpcy5wYXVzZWQgPSB0cnVlXG4gICAgdGhpcy5lbWl0KCdwYXVzZScpXG4gIH1cbn1cblxuR2xvYi5wcm90b3R5cGUucmVzdW1lID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5wYXVzZWQpIHtcbiAgICB0aGlzLmVtaXQoJ3Jlc3VtZScpXG4gICAgdGhpcy5wYXVzZWQgPSBmYWxzZVxuICAgIGlmICh0aGlzLl9lbWl0UXVldWUubGVuZ3RoKSB7XG4gICAgICB2YXIgZXEgPSB0aGlzLl9lbWl0UXVldWUuc2xpY2UoMClcbiAgICAgIHRoaXMuX2VtaXRRdWV1ZS5sZW5ndGggPSAwXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVxLmxlbmd0aDsgaSArKykge1xuICAgICAgICB2YXIgZSA9IGVxW2ldXG4gICAgICAgIHRoaXMuX2VtaXRNYXRjaChlWzBdLCBlWzFdKVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy5fcHJvY2Vzc1F1ZXVlLmxlbmd0aCkge1xuICAgICAgdmFyIHBxID0gdGhpcy5fcHJvY2Vzc1F1ZXVlLnNsaWNlKDApXG4gICAgICB0aGlzLl9wcm9jZXNzUXVldWUubGVuZ3RoID0gMFxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcS5sZW5ndGg7IGkgKyspIHtcbiAgICAgICAgdmFyIHAgPSBwcVtpXVxuICAgICAgICB0aGlzLl9wcm9jZXNzaW5nLS1cbiAgICAgICAgdGhpcy5fcHJvY2VzcyhwWzBdLCBwWzFdLCBwWzJdLCBwWzNdKVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5HbG9iLnByb3RvdHlwZS5fcHJvY2VzcyA9IGZ1bmN0aW9uIChwYXR0ZXJuLCBpbmRleCwgaW5HbG9iU3RhciwgY2IpIHtcbiAgYXNzZXJ0KHRoaXMgaW5zdGFuY2VvZiBHbG9iKVxuICBhc3NlcnQodHlwZW9mIGNiID09PSAnZnVuY3Rpb24nKVxuXG4gIGlmICh0aGlzLmFib3J0ZWQpXG4gICAgcmV0dXJuXG5cbiAgdGhpcy5fcHJvY2Vzc2luZysrXG4gIGlmICh0aGlzLnBhdXNlZCkge1xuICAgIHRoaXMuX3Byb2Nlc3NRdWV1ZS5wdXNoKFtwYXR0ZXJuLCBpbmRleCwgaW5HbG9iU3RhciwgY2JdKVxuICAgIHJldHVyblxuICB9XG5cbiAgLy9jb25zb2xlLmVycm9yKCdQUk9DRVNTICVkJywgdGhpcy5fcHJvY2Vzc2luZywgcGF0dGVybilcblxuICAvLyBHZXQgdGhlIGZpcnN0IFtuXSBwYXJ0cyBvZiBwYXR0ZXJuIHRoYXQgYXJlIGFsbCBzdHJpbmdzLlxuICB2YXIgbiA9IDBcbiAgd2hpbGUgKHR5cGVvZiBwYXR0ZXJuW25dID09PSAnc3RyaW5nJykge1xuICAgIG4gKytcbiAgfVxuICAvLyBub3cgbiBpcyB0aGUgaW5kZXggb2YgdGhlIGZpcnN0IG9uZSB0aGF0IGlzICpub3QqIGEgc3RyaW5nLlxuXG4gIC8vIHNlZSBpZiB0aGVyZSdzIGFueXRoaW5nIGVsc2VcbiAgdmFyIHByZWZpeFxuICBzd2l0Y2ggKG4pIHtcbiAgICAvLyBpZiBub3QsIHRoZW4gdGhpcyBpcyByYXRoZXIgc2ltcGxlXG4gICAgY2FzZSBwYXR0ZXJuLmxlbmd0aDpcbiAgICAgIHRoaXMuX3Byb2Nlc3NTaW1wbGUocGF0dGVybi5qb2luKCcvJyksIGluZGV4LCBjYilcbiAgICAgIHJldHVyblxuXG4gICAgY2FzZSAwOlxuICAgICAgLy8gcGF0dGVybiAqc3RhcnRzKiB3aXRoIHNvbWUgbm9uLXRyaXZpYWwgaXRlbS5cbiAgICAgIC8vIGdvaW5nIHRvIHJlYWRkaXIoY3dkKSwgYnV0IG5vdCBpbmNsdWRlIHRoZSBwcmVmaXggaW4gbWF0Y2hlcy5cbiAgICAgIHByZWZpeCA9IG51bGxcbiAgICAgIGJyZWFrXG5cbiAgICBkZWZhdWx0OlxuICAgICAgLy8gcGF0dGVybiBoYXMgc29tZSBzdHJpbmcgYml0cyBpbiB0aGUgZnJvbnQuXG4gICAgICAvLyB3aGF0ZXZlciBpdCBzdGFydHMgd2l0aCwgd2hldGhlciB0aGF0J3MgJ2Fic29sdXRlJyBsaWtlIC9mb28vYmFyLFxuICAgICAgLy8gb3IgJ3JlbGF0aXZlJyBsaWtlICcuLi9iYXonXG4gICAgICBwcmVmaXggPSBwYXR0ZXJuLnNsaWNlKDAsIG4pLmpvaW4oJy8nKVxuICAgICAgYnJlYWtcbiAgfVxuXG4gIHZhciByZW1haW4gPSBwYXR0ZXJuLnNsaWNlKG4pXG5cbiAgLy8gZ2V0IHRoZSBsaXN0IG9mIGVudHJpZXMuXG4gIHZhciByZWFkXG4gIGlmIChwcmVmaXggPT09IG51bGwpXG4gICAgcmVhZCA9ICcuJ1xuICBlbHNlIGlmIChpc0Fic29sdXRlKHByZWZpeCkgfHxcbiAgICAgIGlzQWJzb2x1dGUocGF0dGVybi5tYXAoZnVuY3Rpb24gKHApIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBwID09PSAnc3RyaW5nJyA/IHAgOiAnWypdJ1xuICAgICAgfSkuam9pbignLycpKSkge1xuICAgIGlmICghcHJlZml4IHx8ICFpc0Fic29sdXRlKHByZWZpeCkpXG4gICAgICBwcmVmaXggPSAnLycgKyBwcmVmaXhcbiAgICByZWFkID0gcHJlZml4XG4gIH0gZWxzZVxuICAgIHJlYWQgPSBwcmVmaXhcblxuICB2YXIgYWJzID0gdGhpcy5fbWFrZUFicyhyZWFkKVxuXG4gIC8vaWYgaWdub3JlZCwgc2tpcCBfcHJvY2Vzc2luZ1xuICBpZiAoY2hpbGRyZW5JZ25vcmVkKHRoaXMsIHJlYWQpKVxuICAgIHJldHVybiBjYigpXG5cbiAgdmFyIGlzR2xvYlN0YXIgPSByZW1haW5bMF0gPT09IG1pbmltYXRjaC5HTE9CU1RBUlxuICBpZiAoaXNHbG9iU3RhcilcbiAgICB0aGlzLl9wcm9jZXNzR2xvYlN0YXIocHJlZml4LCByZWFkLCBhYnMsIHJlbWFpbiwgaW5kZXgsIGluR2xvYlN0YXIsIGNiKVxuICBlbHNlXG4gICAgdGhpcy5fcHJvY2Vzc1JlYWRkaXIocHJlZml4LCByZWFkLCBhYnMsIHJlbWFpbiwgaW5kZXgsIGluR2xvYlN0YXIsIGNiKVxufVxuXG5HbG9iLnByb3RvdHlwZS5fcHJvY2Vzc1JlYWRkaXIgPSBmdW5jdGlvbiAocHJlZml4LCByZWFkLCBhYnMsIHJlbWFpbiwgaW5kZXgsIGluR2xvYlN0YXIsIGNiKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICB0aGlzLl9yZWFkZGlyKGFicywgaW5HbG9iU3RhciwgZnVuY3Rpb24gKGVyLCBlbnRyaWVzKSB7XG4gICAgcmV0dXJuIHNlbGYuX3Byb2Nlc3NSZWFkZGlyMihwcmVmaXgsIHJlYWQsIGFicywgcmVtYWluLCBpbmRleCwgaW5HbG9iU3RhciwgZW50cmllcywgY2IpXG4gIH0pXG59XG5cbkdsb2IucHJvdG90eXBlLl9wcm9jZXNzUmVhZGRpcjIgPSBmdW5jdGlvbiAocHJlZml4LCByZWFkLCBhYnMsIHJlbWFpbiwgaW5kZXgsIGluR2xvYlN0YXIsIGVudHJpZXMsIGNiKSB7XG5cbiAgLy8gaWYgdGhlIGFicyBpc24ndCBhIGRpciwgdGhlbiBub3RoaW5nIGNhbiBtYXRjaCFcbiAgaWYgKCFlbnRyaWVzKVxuICAgIHJldHVybiBjYigpXG5cbiAgLy8gSXQgd2lsbCBvbmx5IG1hdGNoIGRvdCBlbnRyaWVzIGlmIGl0IHN0YXJ0cyB3aXRoIGEgZG90LCBvciBpZlxuICAvLyBkb3QgaXMgc2V0LiAgU3R1ZmYgbGlrZSBAKC5mb298LmJhcikgaXNuJ3QgYWxsb3dlZC5cbiAgdmFyIHBuID0gcmVtYWluWzBdXG4gIHZhciBuZWdhdGUgPSAhIXRoaXMubWluaW1hdGNoLm5lZ2F0ZVxuICB2YXIgcmF3R2xvYiA9IHBuLl9nbG9iXG4gIHZhciBkb3RPayA9IHRoaXMuZG90IHx8IHJhd0dsb2IuY2hhckF0KDApID09PSAnLidcblxuICB2YXIgbWF0Y2hlZEVudHJpZXMgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGVudHJpZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZSA9IGVudHJpZXNbaV1cbiAgICBpZiAoZS5jaGFyQXQoMCkgIT09ICcuJyB8fCBkb3RPaykge1xuICAgICAgdmFyIG1cbiAgICAgIGlmIChuZWdhdGUgJiYgIXByZWZpeCkge1xuICAgICAgICBtID0gIWUubWF0Y2gocG4pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtID0gZS5tYXRjaChwbilcbiAgICAgIH1cbiAgICAgIGlmIChtKVxuICAgICAgICBtYXRjaGVkRW50cmllcy5wdXNoKGUpXG4gICAgfVxuICB9XG5cbiAgLy9jb25zb2xlLmVycm9yKCdwcmQyJywgcHJlZml4LCBlbnRyaWVzLCByZW1haW5bMF0uX2dsb2IsIG1hdGNoZWRFbnRyaWVzKVxuXG4gIHZhciBsZW4gPSBtYXRjaGVkRW50cmllcy5sZW5ndGhcbiAgLy8gSWYgdGhlcmUgYXJlIG5vIG1hdGNoZWQgZW50cmllcywgdGhlbiBub3RoaW5nIG1hdGNoZXMuXG4gIGlmIChsZW4gPT09IDApXG4gICAgcmV0dXJuIGNiKClcblxuICAvLyBpZiB0aGlzIGlzIHRoZSBsYXN0IHJlbWFpbmluZyBwYXR0ZXJuIGJpdCwgdGhlbiBubyBuZWVkIGZvclxuICAvLyBhbiBhZGRpdGlvbmFsIHN0YXQgKnVubGVzcyogdGhlIHVzZXIgaGFzIHNwZWNpZmllZCBtYXJrIG9yXG4gIC8vIHN0YXQgZXhwbGljaXRseS4gIFdlIGtub3cgdGhleSBleGlzdCwgc2luY2UgcmVhZGRpciByZXR1cm5lZFxuICAvLyB0aGVtLlxuXG4gIGlmIChyZW1haW4ubGVuZ3RoID09PSAxICYmICF0aGlzLm1hcmsgJiYgIXRoaXMuc3RhdCkge1xuICAgIGlmICghdGhpcy5tYXRjaGVzW2luZGV4XSlcbiAgICAgIHRoaXMubWF0Y2hlc1tpbmRleF0gPSBPYmplY3QuY3JlYXRlKG51bGwpXG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArKykge1xuICAgICAgdmFyIGUgPSBtYXRjaGVkRW50cmllc1tpXVxuICAgICAgaWYgKHByZWZpeCkge1xuICAgICAgICBpZiAocHJlZml4ICE9PSAnLycpXG4gICAgICAgICAgZSA9IHByZWZpeCArICcvJyArIGVcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGUgPSBwcmVmaXggKyBlXG4gICAgICB9XG5cbiAgICAgIGlmIChlLmNoYXJBdCgwKSA9PT0gJy8nICYmICF0aGlzLm5vbW91bnQpIHtcbiAgICAgICAgZSA9IHBhdGguam9pbih0aGlzLnJvb3QsIGUpXG4gICAgICB9XG4gICAgICB0aGlzLl9lbWl0TWF0Y2goaW5kZXgsIGUpXG4gICAgfVxuICAgIC8vIFRoaXMgd2FzIHRoZSBsYXN0IG9uZSwgYW5kIG5vIHN0YXRzIHdlcmUgbmVlZGVkXG4gICAgcmV0dXJuIGNiKClcbiAgfVxuXG4gIC8vIG5vdyB0ZXN0IGFsbCBtYXRjaGVkIGVudHJpZXMgYXMgc3RhbmQtaW5zIGZvciB0aGF0IHBhcnRcbiAgLy8gb2YgdGhlIHBhdHRlcm4uXG4gIHJlbWFpbi5zaGlmdCgpXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICsrKSB7XG4gICAgdmFyIGUgPSBtYXRjaGVkRW50cmllc1tpXVxuICAgIHZhciBuZXdQYXR0ZXJuXG4gICAgaWYgKHByZWZpeCkge1xuICAgICAgaWYgKHByZWZpeCAhPT0gJy8nKVxuICAgICAgICBlID0gcHJlZml4ICsgJy8nICsgZVxuICAgICAgZWxzZVxuICAgICAgICBlID0gcHJlZml4ICsgZVxuICAgIH1cbiAgICB0aGlzLl9wcm9jZXNzKFtlXS5jb25jYXQocmVtYWluKSwgaW5kZXgsIGluR2xvYlN0YXIsIGNiKVxuICB9XG4gIGNiKClcbn1cblxuR2xvYi5wcm90b3R5cGUuX2VtaXRNYXRjaCA9IGZ1bmN0aW9uIChpbmRleCwgZSkge1xuICBpZiAodGhpcy5hYm9ydGVkKVxuICAgIHJldHVyblxuXG4gIGlmIChpc0lnbm9yZWQodGhpcywgZSkpXG4gICAgcmV0dXJuXG5cbiAgaWYgKHRoaXMucGF1c2VkKSB7XG4gICAgdGhpcy5fZW1pdFF1ZXVlLnB1c2goW2luZGV4LCBlXSlcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciBhYnMgPSBpc0Fic29sdXRlKGUpID8gZSA6IHRoaXMuX21ha2VBYnMoZSlcblxuICBpZiAodGhpcy5tYXJrKVxuICAgIGUgPSB0aGlzLl9tYXJrKGUpXG5cbiAgaWYgKHRoaXMuYWJzb2x1dGUpXG4gICAgZSA9IGFic1xuXG4gIGlmICh0aGlzLm1hdGNoZXNbaW5kZXhdW2VdKVxuICAgIHJldHVyblxuXG4gIGlmICh0aGlzLm5vZGlyKSB7XG4gICAgdmFyIGMgPSB0aGlzLmNhY2hlW2Fic11cbiAgICBpZiAoYyA9PT0gJ0RJUicgfHwgQXJyYXkuaXNBcnJheShjKSlcbiAgICAgIHJldHVyblxuICB9XG5cbiAgdGhpcy5tYXRjaGVzW2luZGV4XVtlXSA9IHRydWVcblxuICB2YXIgc3QgPSB0aGlzLnN0YXRDYWNoZVthYnNdXG4gIGlmIChzdClcbiAgICB0aGlzLmVtaXQoJ3N0YXQnLCBlLCBzdClcblxuICB0aGlzLmVtaXQoJ21hdGNoJywgZSlcbn1cblxuR2xvYi5wcm90b3R5cGUuX3JlYWRkaXJJbkdsb2JTdGFyID0gZnVuY3Rpb24gKGFicywgY2IpIHtcbiAgaWYgKHRoaXMuYWJvcnRlZClcbiAgICByZXR1cm5cblxuICAvLyBmb2xsb3cgYWxsIHN5bWxpbmtlZCBkaXJlY3RvcmllcyBmb3JldmVyXG4gIC8vIGp1c3QgcHJvY2VlZCBhcyBpZiB0aGlzIGlzIGEgbm9uLWdsb2JzdGFyIHNpdHVhdGlvblxuICBpZiAodGhpcy5mb2xsb3cpXG4gICAgcmV0dXJuIHRoaXMuX3JlYWRkaXIoYWJzLCBmYWxzZSwgY2IpXG5cbiAgdmFyIGxzdGF0a2V5ID0gJ2xzdGF0XFwwJyArIGFic1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgdmFyIGxzdGF0Y2IgPSBpbmZsaWdodChsc3RhdGtleSwgbHN0YXRjYl8pXG5cbiAgaWYgKGxzdGF0Y2IpXG4gICAgc2VsZi5mcy5sc3RhdChhYnMsIGxzdGF0Y2IpXG5cbiAgZnVuY3Rpb24gbHN0YXRjYl8gKGVyLCBsc3RhdCkge1xuICAgIGlmIChlciAmJiBlci5jb2RlID09PSAnRU5PRU5UJylcbiAgICAgIHJldHVybiBjYigpXG5cbiAgICB2YXIgaXNTeW0gPSBsc3RhdCAmJiBsc3RhdC5pc1N5bWJvbGljTGluaygpXG4gICAgc2VsZi5zeW1saW5rc1thYnNdID0gaXNTeW1cblxuICAgIC8vIElmIGl0J3Mgbm90IGEgc3ltbGluayBvciBhIGRpciwgdGhlbiBpdCdzIGRlZmluaXRlbHkgYSByZWd1bGFyIGZpbGUuXG4gICAgLy8gZG9uJ3QgYm90aGVyIGRvaW5nIGEgcmVhZGRpciBpbiB0aGF0IGNhc2UuXG4gICAgaWYgKCFpc1N5bSAmJiBsc3RhdCAmJiAhbHN0YXQuaXNEaXJlY3RvcnkoKSkge1xuICAgICAgc2VsZi5jYWNoZVthYnNdID0gJ0ZJTEUnXG4gICAgICBjYigpXG4gICAgfSBlbHNlXG4gICAgICBzZWxmLl9yZWFkZGlyKGFicywgZmFsc2UsIGNiKVxuICB9XG59XG5cbkdsb2IucHJvdG90eXBlLl9yZWFkZGlyID0gZnVuY3Rpb24gKGFicywgaW5HbG9iU3RhciwgY2IpIHtcbiAgaWYgKHRoaXMuYWJvcnRlZClcbiAgICByZXR1cm5cblxuICBjYiA9IGluZmxpZ2h0KCdyZWFkZGlyXFwwJythYnMrJ1xcMCcraW5HbG9iU3RhciwgY2IpXG4gIGlmICghY2IpXG4gICAgcmV0dXJuXG5cbiAgLy9jb25zb2xlLmVycm9yKCdSRCAlaiAlaicsICtpbkdsb2JTdGFyLCBhYnMpXG4gIGlmIChpbkdsb2JTdGFyICYmICFvd25Qcm9wKHRoaXMuc3ltbGlua3MsIGFicykpXG4gICAgcmV0dXJuIHRoaXMuX3JlYWRkaXJJbkdsb2JTdGFyKGFicywgY2IpXG5cbiAgaWYgKG93blByb3AodGhpcy5jYWNoZSwgYWJzKSkge1xuICAgIHZhciBjID0gdGhpcy5jYWNoZVthYnNdXG4gICAgaWYgKCFjIHx8IGMgPT09ICdGSUxFJylcbiAgICAgIHJldHVybiBjYigpXG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShjKSlcbiAgICAgIHJldHVybiBjYihudWxsLCBjKVxuICB9XG5cbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHNlbGYuZnMucmVhZGRpcihhYnMsIHJlYWRkaXJDYih0aGlzLCBhYnMsIGNiKSlcbn1cblxuZnVuY3Rpb24gcmVhZGRpckNiIChzZWxmLCBhYnMsIGNiKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoZXIsIGVudHJpZXMpIHtcbiAgICBpZiAoZXIpXG4gICAgICBzZWxmLl9yZWFkZGlyRXJyb3IoYWJzLCBlciwgY2IpXG4gICAgZWxzZVxuICAgICAgc2VsZi5fcmVhZGRpckVudHJpZXMoYWJzLCBlbnRyaWVzLCBjYilcbiAgfVxufVxuXG5HbG9iLnByb3RvdHlwZS5fcmVhZGRpckVudHJpZXMgPSBmdW5jdGlvbiAoYWJzLCBlbnRyaWVzLCBjYikge1xuICBpZiAodGhpcy5hYm9ydGVkKVxuICAgIHJldHVyblxuXG4gIC8vIGlmIHdlIGhhdmVuJ3QgYXNrZWQgdG8gc3RhdCBldmVyeXRoaW5nLCB0aGVuIGp1c3RcbiAgLy8gYXNzdW1lIHRoYXQgZXZlcnl0aGluZyBpbiB0aGVyZSBleGlzdHMsIHNvIHdlIGNhbiBhdm9pZFxuICAvLyBoYXZpbmcgdG8gc3RhdCBpdCBhIHNlY29uZCB0aW1lLlxuICBpZiAoIXRoaXMubWFyayAmJiAhdGhpcy5zdGF0KSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbnRyaWVzLmxlbmd0aDsgaSArKykge1xuICAgICAgdmFyIGUgPSBlbnRyaWVzW2ldXG4gICAgICBpZiAoYWJzID09PSAnLycpXG4gICAgICAgIGUgPSBhYnMgKyBlXG4gICAgICBlbHNlXG4gICAgICAgIGUgPSBhYnMgKyAnLycgKyBlXG4gICAgICB0aGlzLmNhY2hlW2VdID0gdHJ1ZVxuICAgIH1cbiAgfVxuXG4gIHRoaXMuY2FjaGVbYWJzXSA9IGVudHJpZXNcbiAgcmV0dXJuIGNiKG51bGwsIGVudHJpZXMpXG59XG5cbkdsb2IucHJvdG90eXBlLl9yZWFkZGlyRXJyb3IgPSBmdW5jdGlvbiAoZiwgZXIsIGNiKSB7XG4gIGlmICh0aGlzLmFib3J0ZWQpXG4gICAgcmV0dXJuXG5cbiAgLy8gaGFuZGxlIGVycm9ycywgYW5kIGNhY2hlIHRoZSBpbmZvcm1hdGlvblxuICBzd2l0Y2ggKGVyLmNvZGUpIHtcbiAgICBjYXNlICdFTk9UU1VQJzogLy8gaHR0cHM6Ly9naXRodWIuY29tL2lzYWFjcy9ub2RlLWdsb2IvaXNzdWVzLzIwNVxuICAgIGNhc2UgJ0VOT1RESVInOiAvLyB0b3RhbGx5IG5vcm1hbC4gbWVhbnMgaXQgKmRvZXMqIGV4aXN0LlxuICAgICAgdmFyIGFicyA9IHRoaXMuX21ha2VBYnMoZilcbiAgICAgIHRoaXMuY2FjaGVbYWJzXSA9ICdGSUxFJ1xuICAgICAgaWYgKGFicyA9PT0gdGhpcy5jd2RBYnMpIHtcbiAgICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKGVyLmNvZGUgKyAnIGludmFsaWQgY3dkICcgKyB0aGlzLmN3ZClcbiAgICAgICAgZXJyb3IucGF0aCA9IHRoaXMuY3dkXG4gICAgICAgIGVycm9yLmNvZGUgPSBlci5jb2RlXG4gICAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBlcnJvcilcbiAgICAgICAgdGhpcy5hYm9ydCgpXG4gICAgICB9XG4gICAgICBicmVha1xuXG4gICAgY2FzZSAnRU5PRU5UJzogLy8gbm90IHRlcnJpYmx5IHVudXN1YWxcbiAgICBjYXNlICdFTE9PUCc6XG4gICAgY2FzZSAnRU5BTUVUT09MT05HJzpcbiAgICBjYXNlICdVTktOT1dOJzpcbiAgICAgIHRoaXMuY2FjaGVbdGhpcy5fbWFrZUFicyhmKV0gPSBmYWxzZVxuICAgICAgYnJlYWtcblxuICAgIGRlZmF1bHQ6IC8vIHNvbWUgdW51c3VhbCBlcnJvci4gIFRyZWF0IGFzIGZhaWx1cmUuXG4gICAgICB0aGlzLmNhY2hlW3RoaXMuX21ha2VBYnMoZildID0gZmFsc2VcbiAgICAgIGlmICh0aGlzLnN0cmljdCkge1xuICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZXIpXG4gICAgICAgIC8vIElmIHRoZSBlcnJvciBpcyBoYW5kbGVkLCB0aGVuIHdlIGFib3J0XG4gICAgICAgIC8vIGlmIG5vdCwgd2UgdGhyZXcgb3V0IG9mIGhlcmVcbiAgICAgICAgdGhpcy5hYm9ydCgpXG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuc2lsZW50KVxuICAgICAgICBjb25zb2xlLmVycm9yKCdnbG9iIGVycm9yJywgZXIpXG4gICAgICBicmVha1xuICB9XG5cbiAgcmV0dXJuIGNiKClcbn1cblxuR2xvYi5wcm90b3R5cGUuX3Byb2Nlc3NHbG9iU3RhciA9IGZ1bmN0aW9uIChwcmVmaXgsIHJlYWQsIGFicywgcmVtYWluLCBpbmRleCwgaW5HbG9iU3RhciwgY2IpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHRoaXMuX3JlYWRkaXIoYWJzLCBpbkdsb2JTdGFyLCBmdW5jdGlvbiAoZXIsIGVudHJpZXMpIHtcbiAgICBzZWxmLl9wcm9jZXNzR2xvYlN0YXIyKHByZWZpeCwgcmVhZCwgYWJzLCByZW1haW4sIGluZGV4LCBpbkdsb2JTdGFyLCBlbnRyaWVzLCBjYilcbiAgfSlcbn1cblxuXG5HbG9iLnByb3RvdHlwZS5fcHJvY2Vzc0dsb2JTdGFyMiA9IGZ1bmN0aW9uIChwcmVmaXgsIHJlYWQsIGFicywgcmVtYWluLCBpbmRleCwgaW5HbG9iU3RhciwgZW50cmllcywgY2IpIHtcbiAgLy9jb25zb2xlLmVycm9yKCdwZ3MyJywgcHJlZml4LCByZW1haW5bMF0sIGVudHJpZXMpXG5cbiAgLy8gbm8gZW50cmllcyBtZWFucyBub3QgYSBkaXIsIHNvIGl0IGNhbiBuZXZlciBoYXZlIG1hdGNoZXNcbiAgLy8gZm9vLnR4dC8qKiBkb2Vzbid0IG1hdGNoIGZvby50eHRcbiAgaWYgKCFlbnRyaWVzKVxuICAgIHJldHVybiBjYigpXG5cbiAgLy8gdGVzdCB3aXRob3V0IHRoZSBnbG9ic3RhciwgYW5kIHdpdGggZXZlcnkgY2hpbGQgYm90aCBiZWxvd1xuICAvLyBhbmQgcmVwbGFjaW5nIHRoZSBnbG9ic3Rhci5cbiAgdmFyIHJlbWFpbldpdGhvdXRHbG9iU3RhciA9IHJlbWFpbi5zbGljZSgxKVxuICB2YXIgZ3NwcmVmID0gcHJlZml4ID8gWyBwcmVmaXggXSA6IFtdXG4gIHZhciBub0dsb2JTdGFyID0gZ3NwcmVmLmNvbmNhdChyZW1haW5XaXRob3V0R2xvYlN0YXIpXG5cbiAgLy8gdGhlIG5vR2xvYlN0YXIgcGF0dGVybiBleGl0cyB0aGUgaW5HbG9iU3RhciBzdGF0ZVxuICB0aGlzLl9wcm9jZXNzKG5vR2xvYlN0YXIsIGluZGV4LCBmYWxzZSwgY2IpXG5cbiAgdmFyIGlzU3ltID0gdGhpcy5zeW1saW5rc1thYnNdXG4gIHZhciBsZW4gPSBlbnRyaWVzLmxlbmd0aFxuXG4gIC8vIElmIGl0J3MgYSBzeW1saW5rLCBhbmQgd2UncmUgaW4gYSBnbG9ic3RhciwgdGhlbiBzdG9wXG4gIGlmIChpc1N5bSAmJiBpbkdsb2JTdGFyKVxuICAgIHJldHVybiBjYigpXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIHZhciBlID0gZW50cmllc1tpXVxuICAgIGlmIChlLmNoYXJBdCgwKSA9PT0gJy4nICYmICF0aGlzLmRvdClcbiAgICAgIGNvbnRpbnVlXG5cbiAgICAvLyB0aGVzZSB0d28gY2FzZXMgZW50ZXIgdGhlIGluR2xvYlN0YXIgc3RhdGVcbiAgICB2YXIgaW5zdGVhZCA9IGdzcHJlZi5jb25jYXQoZW50cmllc1tpXSwgcmVtYWluV2l0aG91dEdsb2JTdGFyKVxuICAgIHRoaXMuX3Byb2Nlc3MoaW5zdGVhZCwgaW5kZXgsIHRydWUsIGNiKVxuXG4gICAgdmFyIGJlbG93ID0gZ3NwcmVmLmNvbmNhdChlbnRyaWVzW2ldLCByZW1haW4pXG4gICAgdGhpcy5fcHJvY2VzcyhiZWxvdywgaW5kZXgsIHRydWUsIGNiKVxuICB9XG5cbiAgY2IoKVxufVxuXG5HbG9iLnByb3RvdHlwZS5fcHJvY2Vzc1NpbXBsZSA9IGZ1bmN0aW9uIChwcmVmaXgsIGluZGV4LCBjYikge1xuICAvLyBYWFggcmV2aWV3IHRoaXMuICBTaG91bGRuJ3QgaXQgYmUgZG9pbmcgdGhlIG1vdW50aW5nIGV0Y1xuICAvLyBiZWZvcmUgZG9pbmcgc3RhdD8gIGtpbmRhIHdlaXJkP1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgdGhpcy5fc3RhdChwcmVmaXgsIGZ1bmN0aW9uIChlciwgZXhpc3RzKSB7XG4gICAgc2VsZi5fcHJvY2Vzc1NpbXBsZTIocHJlZml4LCBpbmRleCwgZXIsIGV4aXN0cywgY2IpXG4gIH0pXG59XG5HbG9iLnByb3RvdHlwZS5fcHJvY2Vzc1NpbXBsZTIgPSBmdW5jdGlvbiAocHJlZml4LCBpbmRleCwgZXIsIGV4aXN0cywgY2IpIHtcblxuICAvL2NvbnNvbGUuZXJyb3IoJ3BzMicsIHByZWZpeCwgZXhpc3RzKVxuXG4gIGlmICghdGhpcy5tYXRjaGVzW2luZGV4XSlcbiAgICB0aGlzLm1hdGNoZXNbaW5kZXhdID0gT2JqZWN0LmNyZWF0ZShudWxsKVxuXG4gIC8vIElmIGl0IGRvZXNuJ3QgZXhpc3QsIHRoZW4ganVzdCBtYXJrIHRoZSBsYWNrIG9mIHJlc3VsdHNcbiAgaWYgKCFleGlzdHMpXG4gICAgcmV0dXJuIGNiKClcblxuICBpZiAocHJlZml4ICYmIGlzQWJzb2x1dGUocHJlZml4KSAmJiAhdGhpcy5ub21vdW50KSB7XG4gICAgdmFyIHRyYWlsID0gL1tcXC9cXFxcXSQvLnRlc3QocHJlZml4KVxuICAgIGlmIChwcmVmaXguY2hhckF0KDApID09PSAnLycpIHtcbiAgICAgIHByZWZpeCA9IHBhdGguam9pbih0aGlzLnJvb3QsIHByZWZpeClcbiAgICB9IGVsc2Uge1xuICAgICAgcHJlZml4ID0gcGF0aC5yZXNvbHZlKHRoaXMucm9vdCwgcHJlZml4KVxuICAgICAgaWYgKHRyYWlsKVxuICAgICAgICBwcmVmaXggKz0gJy8nXG4gICAgfVxuICB9XG5cbiAgaWYgKHByb2Nlc3MucGxhdGZvcm0gPT09ICd3aW4zMicpXG4gICAgcHJlZml4ID0gcHJlZml4LnJlcGxhY2UoL1xcXFwvZywgJy8nKVxuXG4gIC8vIE1hcmsgdGhpcyBhcyBhIG1hdGNoXG4gIHRoaXMuX2VtaXRNYXRjaChpbmRleCwgcHJlZml4KVxuICBjYigpXG59XG5cbi8vIFJldHVybnMgZWl0aGVyICdESVInLCAnRklMRScsIG9yIGZhbHNlXG5HbG9iLnByb3RvdHlwZS5fc3RhdCA9IGZ1bmN0aW9uIChmLCBjYikge1xuICB2YXIgYWJzID0gdGhpcy5fbWFrZUFicyhmKVxuICB2YXIgbmVlZERpciA9IGYuc2xpY2UoLTEpID09PSAnLydcblxuICBpZiAoZi5sZW5ndGggPiB0aGlzLm1heExlbmd0aClcbiAgICByZXR1cm4gY2IoKVxuXG4gIGlmICghdGhpcy5zdGF0ICYmIG93blByb3AodGhpcy5jYWNoZSwgYWJzKSkge1xuICAgIHZhciBjID0gdGhpcy5jYWNoZVthYnNdXG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShjKSlcbiAgICAgIGMgPSAnRElSJ1xuXG4gICAgLy8gSXQgZXhpc3RzLCBidXQgbWF5YmUgbm90IGhvdyB3ZSBuZWVkIGl0XG4gICAgaWYgKCFuZWVkRGlyIHx8IGMgPT09ICdESVInKVxuICAgICAgcmV0dXJuIGNiKG51bGwsIGMpXG5cbiAgICBpZiAobmVlZERpciAmJiBjID09PSAnRklMRScpXG4gICAgICByZXR1cm4gY2IoKVxuXG4gICAgLy8gb3RoZXJ3aXNlIHdlIGhhdmUgdG8gc3RhdCwgYmVjYXVzZSBtYXliZSBjPXRydWVcbiAgICAvLyBpZiB3ZSBrbm93IGl0IGV4aXN0cywgYnV0IG5vdCB3aGF0IGl0IGlzLlxuICB9XG5cbiAgdmFyIGV4aXN0c1xuICB2YXIgc3RhdCA9IHRoaXMuc3RhdENhY2hlW2Fic11cbiAgaWYgKHN0YXQgIT09IHVuZGVmaW5lZCkge1xuICAgIGlmIChzdGF0ID09PSBmYWxzZSlcbiAgICAgIHJldHVybiBjYihudWxsLCBzdGF0KVxuICAgIGVsc2Uge1xuICAgICAgdmFyIHR5cGUgPSBzdGF0LmlzRGlyZWN0b3J5KCkgPyAnRElSJyA6ICdGSUxFJ1xuICAgICAgaWYgKG5lZWREaXIgJiYgdHlwZSA9PT0gJ0ZJTEUnKVxuICAgICAgICByZXR1cm4gY2IoKVxuICAgICAgZWxzZVxuICAgICAgICByZXR1cm4gY2IobnVsbCwgdHlwZSwgc3RhdClcbiAgICB9XG4gIH1cblxuICB2YXIgc2VsZiA9IHRoaXNcbiAgdmFyIHN0YXRjYiA9IGluZmxpZ2h0KCdzdGF0XFwwJyArIGFicywgbHN0YXRjYl8pXG4gIGlmIChzdGF0Y2IpXG4gICAgc2VsZi5mcy5sc3RhdChhYnMsIHN0YXRjYilcblxuICBmdW5jdGlvbiBsc3RhdGNiXyAoZXIsIGxzdGF0KSB7XG4gICAgaWYgKGxzdGF0ICYmIGxzdGF0LmlzU3ltYm9saWNMaW5rKCkpIHtcbiAgICAgIC8vIElmIGl0J3MgYSBzeW1saW5rLCB0aGVuIHRyZWF0IGl0IGFzIHRoZSB0YXJnZXQsIHVubGVzc1xuICAgICAgLy8gdGhlIHRhcmdldCBkb2VzIG5vdCBleGlzdCwgdGhlbiB0cmVhdCBpdCBhcyBhIGZpbGUuXG4gICAgICByZXR1cm4gc2VsZi5mcy5zdGF0KGFicywgZnVuY3Rpb24gKGVyLCBzdGF0KSB7XG4gICAgICAgIGlmIChlcilcbiAgICAgICAgICBzZWxmLl9zdGF0MihmLCBhYnMsIG51bGwsIGxzdGF0LCBjYilcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHNlbGYuX3N0YXQyKGYsIGFicywgZXIsIHN0YXQsIGNiKVxuICAgICAgfSlcbiAgICB9IGVsc2Uge1xuICAgICAgc2VsZi5fc3RhdDIoZiwgYWJzLCBlciwgbHN0YXQsIGNiKVxuICAgIH1cbiAgfVxufVxuXG5HbG9iLnByb3RvdHlwZS5fc3RhdDIgPSBmdW5jdGlvbiAoZiwgYWJzLCBlciwgc3RhdCwgY2IpIHtcbiAgaWYgKGVyICYmIChlci5jb2RlID09PSAnRU5PRU5UJyB8fCBlci5jb2RlID09PSAnRU5PVERJUicpKSB7XG4gICAgdGhpcy5zdGF0Q2FjaGVbYWJzXSA9IGZhbHNlXG4gICAgcmV0dXJuIGNiKClcbiAgfVxuXG4gIHZhciBuZWVkRGlyID0gZi5zbGljZSgtMSkgPT09ICcvJ1xuICB0aGlzLnN0YXRDYWNoZVthYnNdID0gc3RhdFxuXG4gIGlmIChhYnMuc2xpY2UoLTEpID09PSAnLycgJiYgc3RhdCAmJiAhc3RhdC5pc0RpcmVjdG9yeSgpKVxuICAgIHJldHVybiBjYihudWxsLCBmYWxzZSwgc3RhdClcblxuICB2YXIgYyA9IHRydWVcbiAgaWYgKHN0YXQpXG4gICAgYyA9IHN0YXQuaXNEaXJlY3RvcnkoKSA/ICdESVInIDogJ0ZJTEUnXG4gIHRoaXMuY2FjaGVbYWJzXSA9IHRoaXMuY2FjaGVbYWJzXSB8fCBjXG5cbiAgaWYgKG5lZWREaXIgJiYgYyA9PT0gJ0ZJTEUnKVxuICAgIHJldHVybiBjYigpXG5cbiAgcmV0dXJuIGNiKG51bGwsIGMsIHN0YXQpXG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/glob/glob.js\n");

/***/ }),

/***/ "./node_modules/glob/sync.js":
/*!***********************************!*\
  !*** ./node_modules/glob/sync.js ***!
  \***********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = globSync\nglobSync.GlobSync = GlobSync\n\nvar rp = __webpack_require__(/*! fs.realpath */ \"./node_modules/fs.realpath/index.js\")\nvar minimatch = __webpack_require__(/*! minimatch */ \"./node_modules/minimatch/minimatch.js\")\nvar Minimatch = minimatch.Minimatch\nvar Glob = (__webpack_require__(/*! ./glob.js */ \"./node_modules/glob/glob.js\").Glob)\nvar util = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'util'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()))\nvar path = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'path'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()))\nvar assert = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'assert'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()))\nvar isAbsolute = __webpack_require__(/*! path-is-absolute */ \"./node_modules/path-is-absolute/index.js\")\nvar common = __webpack_require__(/*! ./common.js */ \"./node_modules/glob/common.js\")\nvar setopts = common.setopts\nvar ownProp = common.ownProp\nvar childrenIgnored = common.childrenIgnored\nvar isIgnored = common.isIgnored\n\nfunction globSync (pattern, options) {\n  if (typeof options === 'function' || arguments.length === 3)\n    throw new TypeError('callback provided to sync glob\\n'+\n                        'See: https://github.com/isaacs/node-glob/issues/167')\n\n  return new GlobSync(pattern, options).found\n}\n\nfunction GlobSync (pattern, options) {\n  if (!pattern)\n    throw new Error('must provide pattern')\n\n  if (typeof options === 'function' || arguments.length === 3)\n    throw new TypeError('callback provided to sync glob\\n'+\n                        'See: https://github.com/isaacs/node-glob/issues/167')\n\n  if (!(this instanceof GlobSync))\n    return new GlobSync(pattern, options)\n\n  setopts(this, pattern, options)\n\n  if (this.noprocess)\n    return this\n\n  var n = this.minimatch.set.length\n  this.matches = new Array(n)\n  for (var i = 0; i < n; i ++) {\n    this._process(this.minimatch.set[i], i, false)\n  }\n  this._finish()\n}\n\nGlobSync.prototype._finish = function () {\n  assert.ok(this instanceof GlobSync)\n  if (this.realpath) {\n    var self = this\n    this.matches.forEach(function (matchset, index) {\n      var set = self.matches[index] = Object.create(null)\n      for (var p in matchset) {\n        try {\n          p = self._makeAbs(p)\n          var real = rp.realpathSync(p, self.realpathCache)\n          set[real] = true\n        } catch (er) {\n          if (er.syscall === 'stat')\n            set[self._makeAbs(p)] = true\n          else\n            throw er\n        }\n      }\n    })\n  }\n  common.finish(this)\n}\n\n\nGlobSync.prototype._process = function (pattern, index, inGlobStar) {\n  assert.ok(this instanceof GlobSync)\n\n  // Get the first [n] parts of pattern that are all strings.\n  var n = 0\n  while (typeof pattern[n] === 'string') {\n    n ++\n  }\n  // now n is the index of the first one that is *not* a string.\n\n  // See if there's anything else\n  var prefix\n  switch (n) {\n    // if not, then this is rather simple\n    case pattern.length:\n      this._processSimple(pattern.join('/'), index)\n      return\n\n    case 0:\n      // pattern *starts* with some non-trivial item.\n      // going to readdir(cwd), but not include the prefix in matches.\n      prefix = null\n      break\n\n    default:\n      // pattern has some string bits in the front.\n      // whatever it starts with, whether that's 'absolute' like /foo/bar,\n      // or 'relative' like '../baz'\n      prefix = pattern.slice(0, n).join('/')\n      break\n  }\n\n  var remain = pattern.slice(n)\n\n  // get the list of entries.\n  var read\n  if (prefix === null)\n    read = '.'\n  else if (isAbsolute(prefix) ||\n      isAbsolute(pattern.map(function (p) {\n        return typeof p === 'string' ? p : '[*]'\n      }).join('/'))) {\n    if (!prefix || !isAbsolute(prefix))\n      prefix = '/' + prefix\n    read = prefix\n  } else\n    read = prefix\n\n  var abs = this._makeAbs(read)\n\n  //if ignored, skip processing\n  if (childrenIgnored(this, read))\n    return\n\n  var isGlobStar = remain[0] === minimatch.GLOBSTAR\n  if (isGlobStar)\n    this._processGlobStar(prefix, read, abs, remain, index, inGlobStar)\n  else\n    this._processReaddir(prefix, read, abs, remain, index, inGlobStar)\n}\n\n\nGlobSync.prototype._processReaddir = function (prefix, read, abs, remain, index, inGlobStar) {\n  var entries = this._readdir(abs, inGlobStar)\n\n  // if the abs isn't a dir, then nothing can match!\n  if (!entries)\n    return\n\n  // It will only match dot entries if it starts with a dot, or if\n  // dot is set.  Stuff like @(.foo|.bar) isn't allowed.\n  var pn = remain[0]\n  var negate = !!this.minimatch.negate\n  var rawGlob = pn._glob\n  var dotOk = this.dot || rawGlob.charAt(0) === '.'\n\n  var matchedEntries = []\n  for (var i = 0; i < entries.length; i++) {\n    var e = entries[i]\n    if (e.charAt(0) !== '.' || dotOk) {\n      var m\n      if (negate && !prefix) {\n        m = !e.match(pn)\n      } else {\n        m = e.match(pn)\n      }\n      if (m)\n        matchedEntries.push(e)\n    }\n  }\n\n  var len = matchedEntries.length\n  // If there are no matched entries, then nothing matches.\n  if (len === 0)\n    return\n\n  // if this is the last remaining pattern bit, then no need for\n  // an additional stat *unless* the user has specified mark or\n  // stat explicitly.  We know they exist, since readdir returned\n  // them.\n\n  if (remain.length === 1 && !this.mark && !this.stat) {\n    if (!this.matches[index])\n      this.matches[index] = Object.create(null)\n\n    for (var i = 0; i < len; i ++) {\n      var e = matchedEntries[i]\n      if (prefix) {\n        if (prefix.slice(-1) !== '/')\n          e = prefix + '/' + e\n        else\n          e = prefix + e\n      }\n\n      if (e.charAt(0) === '/' && !this.nomount) {\n        e = path.join(this.root, e)\n      }\n      this._emitMatch(index, e)\n    }\n    // This was the last one, and no stats were needed\n    return\n  }\n\n  // now test all matched entries as stand-ins for that part\n  // of the pattern.\n  remain.shift()\n  for (var i = 0; i < len; i ++) {\n    var e = matchedEntries[i]\n    var newPattern\n    if (prefix)\n      newPattern = [prefix, e]\n    else\n      newPattern = [e]\n    this._process(newPattern.concat(remain), index, inGlobStar)\n  }\n}\n\n\nGlobSync.prototype._emitMatch = function (index, e) {\n  if (isIgnored(this, e))\n    return\n\n  var abs = this._makeAbs(e)\n\n  if (this.mark)\n    e = this._mark(e)\n\n  if (this.absolute) {\n    e = abs\n  }\n\n  if (this.matches[index][e])\n    return\n\n  if (this.nodir) {\n    var c = this.cache[abs]\n    if (c === 'DIR' || Array.isArray(c))\n      return\n  }\n\n  this.matches[index][e] = true\n\n  if (this.stat)\n    this._stat(e)\n}\n\n\nGlobSync.prototype._readdirInGlobStar = function (abs) {\n  // follow all symlinked directories forever\n  // just proceed as if this is a non-globstar situation\n  if (this.follow)\n    return this._readdir(abs, false)\n\n  var entries\n  var lstat\n  var stat\n  try {\n    lstat = this.fs.lstatSync(abs)\n  } catch (er) {\n    if (er.code === 'ENOENT') {\n      // lstat failed, doesn't exist\n      return null\n    }\n  }\n\n  var isSym = lstat && lstat.isSymbolicLink()\n  this.symlinks[abs] = isSym\n\n  // If it's not a symlink or a dir, then it's definitely a regular file.\n  // don't bother doing a readdir in that case.\n  if (!isSym && lstat && !lstat.isDirectory())\n    this.cache[abs] = 'FILE'\n  else\n    entries = this._readdir(abs, false)\n\n  return entries\n}\n\nGlobSync.prototype._readdir = function (abs, inGlobStar) {\n  var entries\n\n  if (inGlobStar && !ownProp(this.symlinks, abs))\n    return this._readdirInGlobStar(abs)\n\n  if (ownProp(this.cache, abs)) {\n    var c = this.cache[abs]\n    if (!c || c === 'FILE')\n      return null\n\n    if (Array.isArray(c))\n      return c\n  }\n\n  try {\n    return this._readdirEntries(abs, this.fs.readdirSync(abs))\n  } catch (er) {\n    this._readdirError(abs, er)\n    return null\n  }\n}\n\nGlobSync.prototype._readdirEntries = function (abs, entries) {\n  // if we haven't asked to stat everything, then just\n  // assume that everything in there exists, so we can avoid\n  // having to stat it a second time.\n  if (!this.mark && !this.stat) {\n    for (var i = 0; i < entries.length; i ++) {\n      var e = entries[i]\n      if (abs === '/')\n        e = abs + e\n      else\n        e = abs + '/' + e\n      this.cache[e] = true\n    }\n  }\n\n  this.cache[abs] = entries\n\n  // mark and cache dir-ness\n  return entries\n}\n\nGlobSync.prototype._readdirError = function (f, er) {\n  // handle errors, and cache the information\n  switch (er.code) {\n    case 'ENOTSUP': // https://github.com/isaacs/node-glob/issues/205\n    case 'ENOTDIR': // totally normal. means it *does* exist.\n      var abs = this._makeAbs(f)\n      this.cache[abs] = 'FILE'\n      if (abs === this.cwdAbs) {\n        var error = new Error(er.code + ' invalid cwd ' + this.cwd)\n        error.path = this.cwd\n        error.code = er.code\n        throw error\n      }\n      break\n\n    case 'ENOENT': // not terribly unusual\n    case 'ELOOP':\n    case 'ENAMETOOLONG':\n    case 'UNKNOWN':\n      this.cache[this._makeAbs(f)] = false\n      break\n\n    default: // some unusual error.  Treat as failure.\n      this.cache[this._makeAbs(f)] = false\n      if (this.strict)\n        throw er\n      if (!this.silent)\n        console.error('glob error', er)\n      break\n  }\n}\n\nGlobSync.prototype._processGlobStar = function (prefix, read, abs, remain, index, inGlobStar) {\n\n  var entries = this._readdir(abs, inGlobStar)\n\n  // no entries means not a dir, so it can never have matches\n  // foo.txt/** doesn't match foo.txt\n  if (!entries)\n    return\n\n  // test without the globstar, and with every child both below\n  // and replacing the globstar.\n  var remainWithoutGlobStar = remain.slice(1)\n  var gspref = prefix ? [ prefix ] : []\n  var noGlobStar = gspref.concat(remainWithoutGlobStar)\n\n  // the noGlobStar pattern exits the inGlobStar state\n  this._process(noGlobStar, index, false)\n\n  var len = entries.length\n  var isSym = this.symlinks[abs]\n\n  // If it's a symlink, and we're in a globstar, then stop\n  if (isSym && inGlobStar)\n    return\n\n  for (var i = 0; i < len; i++) {\n    var e = entries[i]\n    if (e.charAt(0) === '.' && !this.dot)\n      continue\n\n    // these two cases enter the inGlobStar state\n    var instead = gspref.concat(entries[i], remainWithoutGlobStar)\n    this._process(instead, index, true)\n\n    var below = gspref.concat(entries[i], remain)\n    this._process(below, index, true)\n  }\n}\n\nGlobSync.prototype._processSimple = function (prefix, index) {\n  // XXX review this.  Shouldn't it be doing the mounting etc\n  // before doing stat?  kinda weird?\n  var exists = this._stat(prefix)\n\n  if (!this.matches[index])\n    this.matches[index] = Object.create(null)\n\n  // If it doesn't exist, then just mark the lack of results\n  if (!exists)\n    return\n\n  if (prefix && isAbsolute(prefix) && !this.nomount) {\n    var trail = /[\\/\\\\]$/.test(prefix)\n    if (prefix.charAt(0) === '/') {\n      prefix = path.join(this.root, prefix)\n    } else {\n      prefix = path.resolve(this.root, prefix)\n      if (trail)\n        prefix += '/'\n    }\n  }\n\n  if (process.platform === 'win32')\n    prefix = prefix.replace(/\\\\/g, '/')\n\n  // Mark this as a match\n  this._emitMatch(index, prefix)\n}\n\n// Returns either 'DIR', 'FILE', or false\nGlobSync.prototype._stat = function (f) {\n  var abs = this._makeAbs(f)\n  var needDir = f.slice(-1) === '/'\n\n  if (f.length > this.maxLength)\n    return false\n\n  if (!this.stat && ownProp(this.cache, abs)) {\n    var c = this.cache[abs]\n\n    if (Array.isArray(c))\n      c = 'DIR'\n\n    // It exists, but maybe not how we need it\n    if (!needDir || c === 'DIR')\n      return c\n\n    if (needDir && c === 'FILE')\n      return false\n\n    // otherwise we have to stat, because maybe c=true\n    // if we know it exists, but not what it is.\n  }\n\n  var exists\n  var stat = this.statCache[abs]\n  if (!stat) {\n    var lstat\n    try {\n      lstat = this.fs.lstatSync(abs)\n    } catch (er) {\n      if (er && (er.code === 'ENOENT' || er.code === 'ENOTDIR')) {\n        this.statCache[abs] = false\n        return false\n      }\n    }\n\n    if (lstat && lstat.isSymbolicLink()) {\n      try {\n        stat = this.fs.statSync(abs)\n      } catch (er) {\n        stat = lstat\n      }\n    } else {\n      stat = lstat\n    }\n  }\n\n  this.statCache[abs] = stat\n\n  var c = true\n  if (stat)\n    c = stat.isDirectory() ? 'DIR' : 'FILE'\n\n  this.cache[abs] = this.cache[abs] || c\n\n  if (needDir && c === 'FILE')\n    return false\n\n  return c\n}\n\nGlobSync.prototype._mark = function (p) {\n  return common.mark(this, p)\n}\n\nGlobSync.prototype._makeAbs = function (f) {\n  return common.makeAbs(this, f)\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ2xvYi9zeW5jLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBRUEsU0FBUyxtQkFBTyxDQUFDLHdEQUFhO0FBQzlCLGdCQUFnQixtQkFBTyxDQUFDLHdEQUFXO0FBQ25DO0FBQ0EsV0FBVywwRUFBeUI7QUFDcEMsV0FBVyxtQkFBTyxDQUFDLG1JQUFNO0FBQ3pCLFdBQVcsbUJBQU8sQ0FBQyxtSUFBTTtBQUN6QixhQUFhLG1CQUFPLENBQUMscUlBQVE7QUFDN0IsaUJBQWlCLG1CQUFPLENBQUMsa0VBQWtCO0FBQzNDLGFBQWEsbUJBQU8sQ0FBQyxrREFBYTtBQUNsQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0IsT0FBTztBQUN6QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQixvQkFBb0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvQkFBb0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90b2RvLWxpc3QvLi9ub2RlX21vZHVsZXMvZ2xvYi9zeW5jLmpzPzJjYjgiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBnbG9iU3luY1xuZ2xvYlN5bmMuR2xvYlN5bmMgPSBHbG9iU3luY1xuXG52YXIgcnAgPSByZXF1aXJlKCdmcy5yZWFscGF0aCcpXG52YXIgbWluaW1hdGNoID0gcmVxdWlyZSgnbWluaW1hdGNoJylcbnZhciBNaW5pbWF0Y2ggPSBtaW5pbWF0Y2guTWluaW1hdGNoXG52YXIgR2xvYiA9IHJlcXVpcmUoJy4vZ2xvYi5qcycpLkdsb2JcbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpXG52YXIgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKVxudmFyIGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpXG52YXIgaXNBYnNvbHV0ZSA9IHJlcXVpcmUoJ3BhdGgtaXMtYWJzb2x1dGUnKVxudmFyIGNvbW1vbiA9IHJlcXVpcmUoJy4vY29tbW9uLmpzJylcbnZhciBzZXRvcHRzID0gY29tbW9uLnNldG9wdHNcbnZhciBvd25Qcm9wID0gY29tbW9uLm93blByb3BcbnZhciBjaGlsZHJlbklnbm9yZWQgPSBjb21tb24uY2hpbGRyZW5JZ25vcmVkXG52YXIgaXNJZ25vcmVkID0gY29tbW9uLmlzSWdub3JlZFxuXG5mdW5jdGlvbiBnbG9iU3luYyAocGF0dGVybiwgb3B0aW9ucykge1xuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicgfHwgYXJndW1lbnRzLmxlbmd0aCA9PT0gMylcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdjYWxsYmFjayBwcm92aWRlZCB0byBzeW5jIGdsb2JcXG4nK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ1NlZTogaHR0cHM6Ly9naXRodWIuY29tL2lzYWFjcy9ub2RlLWdsb2IvaXNzdWVzLzE2NycpXG5cbiAgcmV0dXJuIG5ldyBHbG9iU3luYyhwYXR0ZXJuLCBvcHRpb25zKS5mb3VuZFxufVxuXG5mdW5jdGlvbiBHbG9iU3luYyAocGF0dGVybiwgb3B0aW9ucykge1xuICBpZiAoIXBhdHRlcm4pXG4gICAgdGhyb3cgbmV3IEVycm9yKCdtdXN0IHByb3ZpZGUgcGF0dGVybicpXG5cbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nIHx8IGFyZ3VtZW50cy5sZW5ndGggPT09IDMpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignY2FsbGJhY2sgcHJvdmlkZWQgdG8gc3luYyBnbG9iXFxuJytcbiAgICAgICAgICAgICAgICAgICAgICAgICdTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9pc2FhY3Mvbm9kZS1nbG9iL2lzc3Vlcy8xNjcnKVxuXG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBHbG9iU3luYykpXG4gICAgcmV0dXJuIG5ldyBHbG9iU3luYyhwYXR0ZXJuLCBvcHRpb25zKVxuXG4gIHNldG9wdHModGhpcywgcGF0dGVybiwgb3B0aW9ucylcblxuICBpZiAodGhpcy5ub3Byb2Nlc3MpXG4gICAgcmV0dXJuIHRoaXNcblxuICB2YXIgbiA9IHRoaXMubWluaW1hdGNoLnNldC5sZW5ndGhcbiAgdGhpcy5tYXRjaGVzID0gbmV3IEFycmF5KG4pXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSArKykge1xuICAgIHRoaXMuX3Byb2Nlc3ModGhpcy5taW5pbWF0Y2guc2V0W2ldLCBpLCBmYWxzZSlcbiAgfVxuICB0aGlzLl9maW5pc2goKVxufVxuXG5HbG9iU3luYy5wcm90b3R5cGUuX2ZpbmlzaCA9IGZ1bmN0aW9uICgpIHtcbiAgYXNzZXJ0Lm9rKHRoaXMgaW5zdGFuY2VvZiBHbG9iU3luYylcbiAgaWYgKHRoaXMucmVhbHBhdGgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXNcbiAgICB0aGlzLm1hdGNoZXMuZm9yRWFjaChmdW5jdGlvbiAobWF0Y2hzZXQsIGluZGV4KSB7XG4gICAgICB2YXIgc2V0ID0gc2VsZi5tYXRjaGVzW2luZGV4XSA9IE9iamVjdC5jcmVhdGUobnVsbClcbiAgICAgIGZvciAodmFyIHAgaW4gbWF0Y2hzZXQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBwID0gc2VsZi5fbWFrZUFicyhwKVxuICAgICAgICAgIHZhciByZWFsID0gcnAucmVhbHBhdGhTeW5jKHAsIHNlbGYucmVhbHBhdGhDYWNoZSlcbiAgICAgICAgICBzZXRbcmVhbF0gPSB0cnVlXG4gICAgICAgIH0gY2F0Y2ggKGVyKSB7XG4gICAgICAgICAgaWYgKGVyLnN5c2NhbGwgPT09ICdzdGF0JylcbiAgICAgICAgICAgIHNldFtzZWxmLl9tYWtlQWJzKHApXSA9IHRydWVcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aHJvdyBlclxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSlcbiAgfVxuICBjb21tb24uZmluaXNoKHRoaXMpXG59XG5cblxuR2xvYlN5bmMucHJvdG90eXBlLl9wcm9jZXNzID0gZnVuY3Rpb24gKHBhdHRlcm4sIGluZGV4LCBpbkdsb2JTdGFyKSB7XG4gIGFzc2VydC5vayh0aGlzIGluc3RhbmNlb2YgR2xvYlN5bmMpXG5cbiAgLy8gR2V0IHRoZSBmaXJzdCBbbl0gcGFydHMgb2YgcGF0dGVybiB0aGF0IGFyZSBhbGwgc3RyaW5ncy5cbiAgdmFyIG4gPSAwXG4gIHdoaWxlICh0eXBlb2YgcGF0dGVybltuXSA9PT0gJ3N0cmluZycpIHtcbiAgICBuICsrXG4gIH1cbiAgLy8gbm93IG4gaXMgdGhlIGluZGV4IG9mIHRoZSBmaXJzdCBvbmUgdGhhdCBpcyAqbm90KiBhIHN0cmluZy5cblxuICAvLyBTZWUgaWYgdGhlcmUncyBhbnl0aGluZyBlbHNlXG4gIHZhciBwcmVmaXhcbiAgc3dpdGNoIChuKSB7XG4gICAgLy8gaWYgbm90LCB0aGVuIHRoaXMgaXMgcmF0aGVyIHNpbXBsZVxuICAgIGNhc2UgcGF0dGVybi5sZW5ndGg6XG4gICAgICB0aGlzLl9wcm9jZXNzU2ltcGxlKHBhdHRlcm4uam9pbignLycpLCBpbmRleClcbiAgICAgIHJldHVyblxuXG4gICAgY2FzZSAwOlxuICAgICAgLy8gcGF0dGVybiAqc3RhcnRzKiB3aXRoIHNvbWUgbm9uLXRyaXZpYWwgaXRlbS5cbiAgICAgIC8vIGdvaW5nIHRvIHJlYWRkaXIoY3dkKSwgYnV0IG5vdCBpbmNsdWRlIHRoZSBwcmVmaXggaW4gbWF0Y2hlcy5cbiAgICAgIHByZWZpeCA9IG51bGxcbiAgICAgIGJyZWFrXG5cbiAgICBkZWZhdWx0OlxuICAgICAgLy8gcGF0dGVybiBoYXMgc29tZSBzdHJpbmcgYml0cyBpbiB0aGUgZnJvbnQuXG4gICAgICAvLyB3aGF0ZXZlciBpdCBzdGFydHMgd2l0aCwgd2hldGhlciB0aGF0J3MgJ2Fic29sdXRlJyBsaWtlIC9mb28vYmFyLFxuICAgICAgLy8gb3IgJ3JlbGF0aXZlJyBsaWtlICcuLi9iYXonXG4gICAgICBwcmVmaXggPSBwYXR0ZXJuLnNsaWNlKDAsIG4pLmpvaW4oJy8nKVxuICAgICAgYnJlYWtcbiAgfVxuXG4gIHZhciByZW1haW4gPSBwYXR0ZXJuLnNsaWNlKG4pXG5cbiAgLy8gZ2V0IHRoZSBsaXN0IG9mIGVudHJpZXMuXG4gIHZhciByZWFkXG4gIGlmIChwcmVmaXggPT09IG51bGwpXG4gICAgcmVhZCA9ICcuJ1xuICBlbHNlIGlmIChpc0Fic29sdXRlKHByZWZpeCkgfHxcbiAgICAgIGlzQWJzb2x1dGUocGF0dGVybi5tYXAoZnVuY3Rpb24gKHApIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBwID09PSAnc3RyaW5nJyA/IHAgOiAnWypdJ1xuICAgICAgfSkuam9pbignLycpKSkge1xuICAgIGlmICghcHJlZml4IHx8ICFpc0Fic29sdXRlKHByZWZpeCkpXG4gICAgICBwcmVmaXggPSAnLycgKyBwcmVmaXhcbiAgICByZWFkID0gcHJlZml4XG4gIH0gZWxzZVxuICAgIHJlYWQgPSBwcmVmaXhcblxuICB2YXIgYWJzID0gdGhpcy5fbWFrZUFicyhyZWFkKVxuXG4gIC8vaWYgaWdub3JlZCwgc2tpcCBwcm9jZXNzaW5nXG4gIGlmIChjaGlsZHJlbklnbm9yZWQodGhpcywgcmVhZCkpXG4gICAgcmV0dXJuXG5cbiAgdmFyIGlzR2xvYlN0YXIgPSByZW1haW5bMF0gPT09IG1pbmltYXRjaC5HTE9CU1RBUlxuICBpZiAoaXNHbG9iU3RhcilcbiAgICB0aGlzLl9wcm9jZXNzR2xvYlN0YXIocHJlZml4LCByZWFkLCBhYnMsIHJlbWFpbiwgaW5kZXgsIGluR2xvYlN0YXIpXG4gIGVsc2VcbiAgICB0aGlzLl9wcm9jZXNzUmVhZGRpcihwcmVmaXgsIHJlYWQsIGFicywgcmVtYWluLCBpbmRleCwgaW5HbG9iU3Rhcilcbn1cblxuXG5HbG9iU3luYy5wcm90b3R5cGUuX3Byb2Nlc3NSZWFkZGlyID0gZnVuY3Rpb24gKHByZWZpeCwgcmVhZCwgYWJzLCByZW1haW4sIGluZGV4LCBpbkdsb2JTdGFyKSB7XG4gIHZhciBlbnRyaWVzID0gdGhpcy5fcmVhZGRpcihhYnMsIGluR2xvYlN0YXIpXG5cbiAgLy8gaWYgdGhlIGFicyBpc24ndCBhIGRpciwgdGhlbiBub3RoaW5nIGNhbiBtYXRjaCFcbiAgaWYgKCFlbnRyaWVzKVxuICAgIHJldHVyblxuXG4gIC8vIEl0IHdpbGwgb25seSBtYXRjaCBkb3QgZW50cmllcyBpZiBpdCBzdGFydHMgd2l0aCBhIGRvdCwgb3IgaWZcbiAgLy8gZG90IGlzIHNldC4gIFN0dWZmIGxpa2UgQCguZm9vfC5iYXIpIGlzbid0IGFsbG93ZWQuXG4gIHZhciBwbiA9IHJlbWFpblswXVxuICB2YXIgbmVnYXRlID0gISF0aGlzLm1pbmltYXRjaC5uZWdhdGVcbiAgdmFyIHJhd0dsb2IgPSBwbi5fZ2xvYlxuICB2YXIgZG90T2sgPSB0aGlzLmRvdCB8fCByYXdHbG9iLmNoYXJBdCgwKSA9PT0gJy4nXG5cbiAgdmFyIG1hdGNoZWRFbnRyaWVzID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbnRyaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGUgPSBlbnRyaWVzW2ldXG4gICAgaWYgKGUuY2hhckF0KDApICE9PSAnLicgfHwgZG90T2spIHtcbiAgICAgIHZhciBtXG4gICAgICBpZiAobmVnYXRlICYmICFwcmVmaXgpIHtcbiAgICAgICAgbSA9ICFlLm1hdGNoKHBuKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbSA9IGUubWF0Y2gocG4pXG4gICAgICB9XG4gICAgICBpZiAobSlcbiAgICAgICAgbWF0Y2hlZEVudHJpZXMucHVzaChlKVxuICAgIH1cbiAgfVxuXG4gIHZhciBsZW4gPSBtYXRjaGVkRW50cmllcy5sZW5ndGhcbiAgLy8gSWYgdGhlcmUgYXJlIG5vIG1hdGNoZWQgZW50cmllcywgdGhlbiBub3RoaW5nIG1hdGNoZXMuXG4gIGlmIChsZW4gPT09IDApXG4gICAgcmV0dXJuXG5cbiAgLy8gaWYgdGhpcyBpcyB0aGUgbGFzdCByZW1haW5pbmcgcGF0dGVybiBiaXQsIHRoZW4gbm8gbmVlZCBmb3JcbiAgLy8gYW4gYWRkaXRpb25hbCBzdGF0ICp1bmxlc3MqIHRoZSB1c2VyIGhhcyBzcGVjaWZpZWQgbWFyayBvclxuICAvLyBzdGF0IGV4cGxpY2l0bHkuICBXZSBrbm93IHRoZXkgZXhpc3QsIHNpbmNlIHJlYWRkaXIgcmV0dXJuZWRcbiAgLy8gdGhlbS5cblxuICBpZiAocmVtYWluLmxlbmd0aCA9PT0gMSAmJiAhdGhpcy5tYXJrICYmICF0aGlzLnN0YXQpIHtcbiAgICBpZiAoIXRoaXMubWF0Y2hlc1tpbmRleF0pXG4gICAgICB0aGlzLm1hdGNoZXNbaW5kZXhdID0gT2JqZWN0LmNyZWF0ZShudWxsKVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKyspIHtcbiAgICAgIHZhciBlID0gbWF0Y2hlZEVudHJpZXNbaV1cbiAgICAgIGlmIChwcmVmaXgpIHtcbiAgICAgICAgaWYgKHByZWZpeC5zbGljZSgtMSkgIT09ICcvJylcbiAgICAgICAgICBlID0gcHJlZml4ICsgJy8nICsgZVxuICAgICAgICBlbHNlXG4gICAgICAgICAgZSA9IHByZWZpeCArIGVcbiAgICAgIH1cblxuICAgICAgaWYgKGUuY2hhckF0KDApID09PSAnLycgJiYgIXRoaXMubm9tb3VudCkge1xuICAgICAgICBlID0gcGF0aC5qb2luKHRoaXMucm9vdCwgZSlcbiAgICAgIH1cbiAgICAgIHRoaXMuX2VtaXRNYXRjaChpbmRleCwgZSlcbiAgICB9XG4gICAgLy8gVGhpcyB3YXMgdGhlIGxhc3Qgb25lLCBhbmQgbm8gc3RhdHMgd2VyZSBuZWVkZWRcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8vIG5vdyB0ZXN0IGFsbCBtYXRjaGVkIGVudHJpZXMgYXMgc3RhbmQtaW5zIGZvciB0aGF0IHBhcnRcbiAgLy8gb2YgdGhlIHBhdHRlcm4uXG4gIHJlbWFpbi5zaGlmdCgpXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICsrKSB7XG4gICAgdmFyIGUgPSBtYXRjaGVkRW50cmllc1tpXVxuICAgIHZhciBuZXdQYXR0ZXJuXG4gICAgaWYgKHByZWZpeClcbiAgICAgIG5ld1BhdHRlcm4gPSBbcHJlZml4LCBlXVxuICAgIGVsc2VcbiAgICAgIG5ld1BhdHRlcm4gPSBbZV1cbiAgICB0aGlzLl9wcm9jZXNzKG5ld1BhdHRlcm4uY29uY2F0KHJlbWFpbiksIGluZGV4LCBpbkdsb2JTdGFyKVxuICB9XG59XG5cblxuR2xvYlN5bmMucHJvdG90eXBlLl9lbWl0TWF0Y2ggPSBmdW5jdGlvbiAoaW5kZXgsIGUpIHtcbiAgaWYgKGlzSWdub3JlZCh0aGlzLCBlKSlcbiAgICByZXR1cm5cblxuICB2YXIgYWJzID0gdGhpcy5fbWFrZUFicyhlKVxuXG4gIGlmICh0aGlzLm1hcmspXG4gICAgZSA9IHRoaXMuX21hcmsoZSlcblxuICBpZiAodGhpcy5hYnNvbHV0ZSkge1xuICAgIGUgPSBhYnNcbiAgfVxuXG4gIGlmICh0aGlzLm1hdGNoZXNbaW5kZXhdW2VdKVxuICAgIHJldHVyblxuXG4gIGlmICh0aGlzLm5vZGlyKSB7XG4gICAgdmFyIGMgPSB0aGlzLmNhY2hlW2Fic11cbiAgICBpZiAoYyA9PT0gJ0RJUicgfHwgQXJyYXkuaXNBcnJheShjKSlcbiAgICAgIHJldHVyblxuICB9XG5cbiAgdGhpcy5tYXRjaGVzW2luZGV4XVtlXSA9IHRydWVcblxuICBpZiAodGhpcy5zdGF0KVxuICAgIHRoaXMuX3N0YXQoZSlcbn1cblxuXG5HbG9iU3luYy5wcm90b3R5cGUuX3JlYWRkaXJJbkdsb2JTdGFyID0gZnVuY3Rpb24gKGFicykge1xuICAvLyBmb2xsb3cgYWxsIHN5bWxpbmtlZCBkaXJlY3RvcmllcyBmb3JldmVyXG4gIC8vIGp1c3QgcHJvY2VlZCBhcyBpZiB0aGlzIGlzIGEgbm9uLWdsb2JzdGFyIHNpdHVhdGlvblxuICBpZiAodGhpcy5mb2xsb3cpXG4gICAgcmV0dXJuIHRoaXMuX3JlYWRkaXIoYWJzLCBmYWxzZSlcblxuICB2YXIgZW50cmllc1xuICB2YXIgbHN0YXRcbiAgdmFyIHN0YXRcbiAgdHJ5IHtcbiAgICBsc3RhdCA9IHRoaXMuZnMubHN0YXRTeW5jKGFicylcbiAgfSBjYXRjaCAoZXIpIHtcbiAgICBpZiAoZXIuY29kZSA9PT0gJ0VOT0VOVCcpIHtcbiAgICAgIC8vIGxzdGF0IGZhaWxlZCwgZG9lc24ndCBleGlzdFxuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG4gIH1cblxuICB2YXIgaXNTeW0gPSBsc3RhdCAmJiBsc3RhdC5pc1N5bWJvbGljTGluaygpXG4gIHRoaXMuc3ltbGlua3NbYWJzXSA9IGlzU3ltXG5cbiAgLy8gSWYgaXQncyBub3QgYSBzeW1saW5rIG9yIGEgZGlyLCB0aGVuIGl0J3MgZGVmaW5pdGVseSBhIHJlZ3VsYXIgZmlsZS5cbiAgLy8gZG9uJ3QgYm90aGVyIGRvaW5nIGEgcmVhZGRpciBpbiB0aGF0IGNhc2UuXG4gIGlmICghaXNTeW0gJiYgbHN0YXQgJiYgIWxzdGF0LmlzRGlyZWN0b3J5KCkpXG4gICAgdGhpcy5jYWNoZVthYnNdID0gJ0ZJTEUnXG4gIGVsc2VcbiAgICBlbnRyaWVzID0gdGhpcy5fcmVhZGRpcihhYnMsIGZhbHNlKVxuXG4gIHJldHVybiBlbnRyaWVzXG59XG5cbkdsb2JTeW5jLnByb3RvdHlwZS5fcmVhZGRpciA9IGZ1bmN0aW9uIChhYnMsIGluR2xvYlN0YXIpIHtcbiAgdmFyIGVudHJpZXNcblxuICBpZiAoaW5HbG9iU3RhciAmJiAhb3duUHJvcCh0aGlzLnN5bWxpbmtzLCBhYnMpKVxuICAgIHJldHVybiB0aGlzLl9yZWFkZGlySW5HbG9iU3RhcihhYnMpXG5cbiAgaWYgKG93blByb3AodGhpcy5jYWNoZSwgYWJzKSkge1xuICAgIHZhciBjID0gdGhpcy5jYWNoZVthYnNdXG4gICAgaWYgKCFjIHx8IGMgPT09ICdGSUxFJylcbiAgICAgIHJldHVybiBudWxsXG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShjKSlcbiAgICAgIHJldHVybiBjXG4gIH1cblxuICB0cnkge1xuICAgIHJldHVybiB0aGlzLl9yZWFkZGlyRW50cmllcyhhYnMsIHRoaXMuZnMucmVhZGRpclN5bmMoYWJzKSlcbiAgfSBjYXRjaCAoZXIpIHtcbiAgICB0aGlzLl9yZWFkZGlyRXJyb3IoYWJzLCBlcilcbiAgICByZXR1cm4gbnVsbFxuICB9XG59XG5cbkdsb2JTeW5jLnByb3RvdHlwZS5fcmVhZGRpckVudHJpZXMgPSBmdW5jdGlvbiAoYWJzLCBlbnRyaWVzKSB7XG4gIC8vIGlmIHdlIGhhdmVuJ3QgYXNrZWQgdG8gc3RhdCBldmVyeXRoaW5nLCB0aGVuIGp1c3RcbiAgLy8gYXNzdW1lIHRoYXQgZXZlcnl0aGluZyBpbiB0aGVyZSBleGlzdHMsIHNvIHdlIGNhbiBhdm9pZFxuICAvLyBoYXZpbmcgdG8gc3RhdCBpdCBhIHNlY29uZCB0aW1lLlxuICBpZiAoIXRoaXMubWFyayAmJiAhdGhpcy5zdGF0KSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbnRyaWVzLmxlbmd0aDsgaSArKykge1xuICAgICAgdmFyIGUgPSBlbnRyaWVzW2ldXG4gICAgICBpZiAoYWJzID09PSAnLycpXG4gICAgICAgIGUgPSBhYnMgKyBlXG4gICAgICBlbHNlXG4gICAgICAgIGUgPSBhYnMgKyAnLycgKyBlXG4gICAgICB0aGlzLmNhY2hlW2VdID0gdHJ1ZVxuICAgIH1cbiAgfVxuXG4gIHRoaXMuY2FjaGVbYWJzXSA9IGVudHJpZXNcblxuICAvLyBtYXJrIGFuZCBjYWNoZSBkaXItbmVzc1xuICByZXR1cm4gZW50cmllc1xufVxuXG5HbG9iU3luYy5wcm90b3R5cGUuX3JlYWRkaXJFcnJvciA9IGZ1bmN0aW9uIChmLCBlcikge1xuICAvLyBoYW5kbGUgZXJyb3JzLCBhbmQgY2FjaGUgdGhlIGluZm9ybWF0aW9uXG4gIHN3aXRjaCAoZXIuY29kZSkge1xuICAgIGNhc2UgJ0VOT1RTVVAnOiAvLyBodHRwczovL2dpdGh1Yi5jb20vaXNhYWNzL25vZGUtZ2xvYi9pc3N1ZXMvMjA1XG4gICAgY2FzZSAnRU5PVERJUic6IC8vIHRvdGFsbHkgbm9ybWFsLiBtZWFucyBpdCAqZG9lcyogZXhpc3QuXG4gICAgICB2YXIgYWJzID0gdGhpcy5fbWFrZUFicyhmKVxuICAgICAgdGhpcy5jYWNoZVthYnNdID0gJ0ZJTEUnXG4gICAgICBpZiAoYWJzID09PSB0aGlzLmN3ZEFicykge1xuICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoZXIuY29kZSArICcgaW52YWxpZCBjd2QgJyArIHRoaXMuY3dkKVxuICAgICAgICBlcnJvci5wYXRoID0gdGhpcy5jd2RcbiAgICAgICAgZXJyb3IuY29kZSA9IGVyLmNvZGVcbiAgICAgICAgdGhyb3cgZXJyb3JcbiAgICAgIH1cbiAgICAgIGJyZWFrXG5cbiAgICBjYXNlICdFTk9FTlQnOiAvLyBub3QgdGVycmlibHkgdW51c3VhbFxuICAgIGNhc2UgJ0VMT09QJzpcbiAgICBjYXNlICdFTkFNRVRPT0xPTkcnOlxuICAgIGNhc2UgJ1VOS05PV04nOlxuICAgICAgdGhpcy5jYWNoZVt0aGlzLl9tYWtlQWJzKGYpXSA9IGZhbHNlXG4gICAgICBicmVha1xuXG4gICAgZGVmYXVsdDogLy8gc29tZSB1bnVzdWFsIGVycm9yLiAgVHJlYXQgYXMgZmFpbHVyZS5cbiAgICAgIHRoaXMuY2FjaGVbdGhpcy5fbWFrZUFicyhmKV0gPSBmYWxzZVxuICAgICAgaWYgKHRoaXMuc3RyaWN0KVxuICAgICAgICB0aHJvdyBlclxuICAgICAgaWYgKCF0aGlzLnNpbGVudClcbiAgICAgICAgY29uc29sZS5lcnJvcignZ2xvYiBlcnJvcicsIGVyKVxuICAgICAgYnJlYWtcbiAgfVxufVxuXG5HbG9iU3luYy5wcm90b3R5cGUuX3Byb2Nlc3NHbG9iU3RhciA9IGZ1bmN0aW9uIChwcmVmaXgsIHJlYWQsIGFicywgcmVtYWluLCBpbmRleCwgaW5HbG9iU3Rhcikge1xuXG4gIHZhciBlbnRyaWVzID0gdGhpcy5fcmVhZGRpcihhYnMsIGluR2xvYlN0YXIpXG5cbiAgLy8gbm8gZW50cmllcyBtZWFucyBub3QgYSBkaXIsIHNvIGl0IGNhbiBuZXZlciBoYXZlIG1hdGNoZXNcbiAgLy8gZm9vLnR4dC8qKiBkb2Vzbid0IG1hdGNoIGZvby50eHRcbiAgaWYgKCFlbnRyaWVzKVxuICAgIHJldHVyblxuXG4gIC8vIHRlc3Qgd2l0aG91dCB0aGUgZ2xvYnN0YXIsIGFuZCB3aXRoIGV2ZXJ5IGNoaWxkIGJvdGggYmVsb3dcbiAgLy8gYW5kIHJlcGxhY2luZyB0aGUgZ2xvYnN0YXIuXG4gIHZhciByZW1haW5XaXRob3V0R2xvYlN0YXIgPSByZW1haW4uc2xpY2UoMSlcbiAgdmFyIGdzcHJlZiA9IHByZWZpeCA/IFsgcHJlZml4IF0gOiBbXVxuICB2YXIgbm9HbG9iU3RhciA9IGdzcHJlZi5jb25jYXQocmVtYWluV2l0aG91dEdsb2JTdGFyKVxuXG4gIC8vIHRoZSBub0dsb2JTdGFyIHBhdHRlcm4gZXhpdHMgdGhlIGluR2xvYlN0YXIgc3RhdGVcbiAgdGhpcy5fcHJvY2Vzcyhub0dsb2JTdGFyLCBpbmRleCwgZmFsc2UpXG5cbiAgdmFyIGxlbiA9IGVudHJpZXMubGVuZ3RoXG4gIHZhciBpc1N5bSA9IHRoaXMuc3ltbGlua3NbYWJzXVxuXG4gIC8vIElmIGl0J3MgYSBzeW1saW5rLCBhbmQgd2UncmUgaW4gYSBnbG9ic3RhciwgdGhlbiBzdG9wXG4gIGlmIChpc1N5bSAmJiBpbkdsb2JTdGFyKVxuICAgIHJldHVyblxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICB2YXIgZSA9IGVudHJpZXNbaV1cbiAgICBpZiAoZS5jaGFyQXQoMCkgPT09ICcuJyAmJiAhdGhpcy5kb3QpXG4gICAgICBjb250aW51ZVxuXG4gICAgLy8gdGhlc2UgdHdvIGNhc2VzIGVudGVyIHRoZSBpbkdsb2JTdGFyIHN0YXRlXG4gICAgdmFyIGluc3RlYWQgPSBnc3ByZWYuY29uY2F0KGVudHJpZXNbaV0sIHJlbWFpbldpdGhvdXRHbG9iU3RhcilcbiAgICB0aGlzLl9wcm9jZXNzKGluc3RlYWQsIGluZGV4LCB0cnVlKVxuXG4gICAgdmFyIGJlbG93ID0gZ3NwcmVmLmNvbmNhdChlbnRyaWVzW2ldLCByZW1haW4pXG4gICAgdGhpcy5fcHJvY2VzcyhiZWxvdywgaW5kZXgsIHRydWUpXG4gIH1cbn1cblxuR2xvYlN5bmMucHJvdG90eXBlLl9wcm9jZXNzU2ltcGxlID0gZnVuY3Rpb24gKHByZWZpeCwgaW5kZXgpIHtcbiAgLy8gWFhYIHJldmlldyB0aGlzLiAgU2hvdWxkbid0IGl0IGJlIGRvaW5nIHRoZSBtb3VudGluZyBldGNcbiAgLy8gYmVmb3JlIGRvaW5nIHN0YXQ/ICBraW5kYSB3ZWlyZD9cbiAgdmFyIGV4aXN0cyA9IHRoaXMuX3N0YXQocHJlZml4KVxuXG4gIGlmICghdGhpcy5tYXRjaGVzW2luZGV4XSlcbiAgICB0aGlzLm1hdGNoZXNbaW5kZXhdID0gT2JqZWN0LmNyZWF0ZShudWxsKVxuXG4gIC8vIElmIGl0IGRvZXNuJ3QgZXhpc3QsIHRoZW4ganVzdCBtYXJrIHRoZSBsYWNrIG9mIHJlc3VsdHNcbiAgaWYgKCFleGlzdHMpXG4gICAgcmV0dXJuXG5cbiAgaWYgKHByZWZpeCAmJiBpc0Fic29sdXRlKHByZWZpeCkgJiYgIXRoaXMubm9tb3VudCkge1xuICAgIHZhciB0cmFpbCA9IC9bXFwvXFxcXF0kLy50ZXN0KHByZWZpeClcbiAgICBpZiAocHJlZml4LmNoYXJBdCgwKSA9PT0gJy8nKSB7XG4gICAgICBwcmVmaXggPSBwYXRoLmpvaW4odGhpcy5yb290LCBwcmVmaXgpXG4gICAgfSBlbHNlIHtcbiAgICAgIHByZWZpeCA9IHBhdGgucmVzb2x2ZSh0aGlzLnJvb3QsIHByZWZpeClcbiAgICAgIGlmICh0cmFpbClcbiAgICAgICAgcHJlZml4ICs9ICcvJ1xuICAgIH1cbiAgfVxuXG4gIGlmIChwcm9jZXNzLnBsYXRmb3JtID09PSAnd2luMzInKVxuICAgIHByZWZpeCA9IHByZWZpeC5yZXBsYWNlKC9cXFxcL2csICcvJylcblxuICAvLyBNYXJrIHRoaXMgYXMgYSBtYXRjaFxuICB0aGlzLl9lbWl0TWF0Y2goaW5kZXgsIHByZWZpeClcbn1cblxuLy8gUmV0dXJucyBlaXRoZXIgJ0RJUicsICdGSUxFJywgb3IgZmFsc2Vcbkdsb2JTeW5jLnByb3RvdHlwZS5fc3RhdCA9IGZ1bmN0aW9uIChmKSB7XG4gIHZhciBhYnMgPSB0aGlzLl9tYWtlQWJzKGYpXG4gIHZhciBuZWVkRGlyID0gZi5zbGljZSgtMSkgPT09ICcvJ1xuXG4gIGlmIChmLmxlbmd0aCA+IHRoaXMubWF4TGVuZ3RoKVxuICAgIHJldHVybiBmYWxzZVxuXG4gIGlmICghdGhpcy5zdGF0ICYmIG93blByb3AodGhpcy5jYWNoZSwgYWJzKSkge1xuICAgIHZhciBjID0gdGhpcy5jYWNoZVthYnNdXG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShjKSlcbiAgICAgIGMgPSAnRElSJ1xuXG4gICAgLy8gSXQgZXhpc3RzLCBidXQgbWF5YmUgbm90IGhvdyB3ZSBuZWVkIGl0XG4gICAgaWYgKCFuZWVkRGlyIHx8IGMgPT09ICdESVInKVxuICAgICAgcmV0dXJuIGNcblxuICAgIGlmIChuZWVkRGlyICYmIGMgPT09ICdGSUxFJylcbiAgICAgIHJldHVybiBmYWxzZVxuXG4gICAgLy8gb3RoZXJ3aXNlIHdlIGhhdmUgdG8gc3RhdCwgYmVjYXVzZSBtYXliZSBjPXRydWVcbiAgICAvLyBpZiB3ZSBrbm93IGl0IGV4aXN0cywgYnV0IG5vdCB3aGF0IGl0IGlzLlxuICB9XG5cbiAgdmFyIGV4aXN0c1xuICB2YXIgc3RhdCA9IHRoaXMuc3RhdENhY2hlW2Fic11cbiAgaWYgKCFzdGF0KSB7XG4gICAgdmFyIGxzdGF0XG4gICAgdHJ5IHtcbiAgICAgIGxzdGF0ID0gdGhpcy5mcy5sc3RhdFN5bmMoYWJzKVxuICAgIH0gY2F0Y2ggKGVyKSB7XG4gICAgICBpZiAoZXIgJiYgKGVyLmNvZGUgPT09ICdFTk9FTlQnIHx8IGVyLmNvZGUgPT09ICdFTk9URElSJykpIHtcbiAgICAgICAgdGhpcy5zdGF0Q2FjaGVbYWJzXSA9IGZhbHNlXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChsc3RhdCAmJiBsc3RhdC5pc1N5bWJvbGljTGluaygpKSB7XG4gICAgICB0cnkge1xuICAgICAgICBzdGF0ID0gdGhpcy5mcy5zdGF0U3luYyhhYnMpXG4gICAgICB9IGNhdGNoIChlcikge1xuICAgICAgICBzdGF0ID0gbHN0YXRcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdCA9IGxzdGF0XG4gICAgfVxuICB9XG5cbiAgdGhpcy5zdGF0Q2FjaGVbYWJzXSA9IHN0YXRcblxuICB2YXIgYyA9IHRydWVcbiAgaWYgKHN0YXQpXG4gICAgYyA9IHN0YXQuaXNEaXJlY3RvcnkoKSA/ICdESVInIDogJ0ZJTEUnXG5cbiAgdGhpcy5jYWNoZVthYnNdID0gdGhpcy5jYWNoZVthYnNdIHx8IGNcblxuICBpZiAobmVlZERpciAmJiBjID09PSAnRklMRScpXG4gICAgcmV0dXJuIGZhbHNlXG5cbiAgcmV0dXJuIGNcbn1cblxuR2xvYlN5bmMucHJvdG90eXBlLl9tYXJrID0gZnVuY3Rpb24gKHApIHtcbiAgcmV0dXJuIGNvbW1vbi5tYXJrKHRoaXMsIHApXG59XG5cbkdsb2JTeW5jLnByb3RvdHlwZS5fbWFrZUFicyA9IGZ1bmN0aW9uIChmKSB7XG4gIHJldHVybiBjb21tb24ubWFrZUFicyh0aGlzLCBmKVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/glob/sync.js\n");

/***/ }),

/***/ "./node_modules/globby/index.js":
/*!**************************************!*\
  !*** ./node_modules/globby/index.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nvar Promise = __webpack_require__(/*! pinkie-promise */ \"./node_modules/pinkie-promise/index.js\");\nvar arrayUnion = __webpack_require__(/*! array-union */ \"./node_modules/array-union/index.js\");\nvar objectAssign = __webpack_require__(/*! object-assign */ \"./node_modules/object-assign/index.js\");\nvar glob = __webpack_require__(/*! glob */ \"./node_modules/glob/glob.js\");\nvar pify = __webpack_require__(/*! pify */ \"./node_modules/pify/index.js\");\n\nvar globP = pify(glob, Promise).bind(glob);\n\nfunction isNegative(pattern) {\n\treturn pattern[0] === '!';\n}\n\nfunction isString(value) {\n\treturn typeof value === 'string';\n}\n\nfunction assertPatternsInput(patterns) {\n\tif (!patterns.every(isString)) {\n\t\tthrow new TypeError('patterns must be a string or an array of strings');\n\t}\n}\n\nfunction generateGlobTasks(patterns, opts) {\n\tpatterns = [].concat(patterns);\n\tassertPatternsInput(patterns);\n\n\tvar globTasks = [];\n\n\topts = objectAssign({\n\t\tcache: Object.create(null),\n\t\tstatCache: Object.create(null),\n\t\trealpathCache: Object.create(null),\n\t\tsymlinks: Object.create(null),\n\t\tignore: []\n\t}, opts);\n\n\tpatterns.forEach(function (pattern, i) {\n\t\tif (isNegative(pattern)) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar ignore = patterns.slice(i).filter(isNegative).map(function (pattern) {\n\t\t\treturn pattern.slice(1);\n\t\t});\n\n\t\tglobTasks.push({\n\t\t\tpattern: pattern,\n\t\t\topts: objectAssign({}, opts, {\n\t\t\t\tignore: opts.ignore.concat(ignore)\n\t\t\t})\n\t\t});\n\t});\n\n\treturn globTasks;\n}\n\nmodule.exports = function (patterns, opts) {\n\tvar globTasks;\n\n\ttry {\n\t\tglobTasks = generateGlobTasks(patterns, opts);\n\t} catch (err) {\n\t\treturn Promise.reject(err);\n\t}\n\n\treturn Promise.all(globTasks.map(function (task) {\n\t\treturn globP(task.pattern, task.opts);\n\t})).then(function (paths) {\n\t\treturn arrayUnion.apply(null, paths);\n\t});\n};\n\nmodule.exports.sync = function (patterns, opts) {\n\tvar globTasks = generateGlobTasks(patterns, opts);\n\n\treturn globTasks.reduce(function (matches, task) {\n\t\treturn arrayUnion(matches, glob.sync(task.pattern, task.opts));\n\t}, []);\n};\n\nmodule.exports.generateGlobTasks = generateGlobTasks;\n\nmodule.exports.hasMagic = function (patterns, opts) {\n\treturn [].concat(patterns).some(function (pattern) {\n\t\treturn glob.hasMagic(pattern, opts);\n\t});\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ2xvYmJ5L2luZGV4LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsY0FBYyxtQkFBTyxDQUFDLDhEQUFnQjtBQUN0QyxpQkFBaUIsbUJBQU8sQ0FBQyx3REFBYTtBQUN0QyxtQkFBbUIsbUJBQU8sQ0FBQyw0REFBZTtBQUMxQyxXQUFXLG1CQUFPLENBQUMseUNBQU07QUFDekIsV0FBVyxtQkFBTyxDQUFDLDBDQUFNOztBQUV6Qjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBLElBQUk7QUFDSixHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQSxFQUFFO0FBQ0Y7O0FBRUEsbUJBQW1CO0FBQ25COztBQUVBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUEsZ0NBQWdDOztBQUVoQyx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBLEVBQUU7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL3RvZG8tbGlzdC8uL25vZGVfbW9kdWxlcy9nbG9iYnkvaW5kZXguanM/MDI0OCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG52YXIgUHJvbWlzZSA9IHJlcXVpcmUoJ3BpbmtpZS1wcm9taXNlJyk7XG52YXIgYXJyYXlVbmlvbiA9IHJlcXVpcmUoJ2FycmF5LXVuaW9uJyk7XG52YXIgb2JqZWN0QXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xudmFyIGdsb2IgPSByZXF1aXJlKCdnbG9iJyk7XG52YXIgcGlmeSA9IHJlcXVpcmUoJ3BpZnknKTtcblxudmFyIGdsb2JQID0gcGlmeShnbG9iLCBQcm9taXNlKS5iaW5kKGdsb2IpO1xuXG5mdW5jdGlvbiBpc05lZ2F0aXZlKHBhdHRlcm4pIHtcblx0cmV0dXJuIHBhdHRlcm5bMF0gPT09ICchJztcbn1cblxuZnVuY3Rpb24gaXNTdHJpbmcodmFsdWUpIHtcblx0cmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZyc7XG59XG5cbmZ1bmN0aW9uIGFzc2VydFBhdHRlcm5zSW5wdXQocGF0dGVybnMpIHtcblx0aWYgKCFwYXR0ZXJucy5ldmVyeShpc1N0cmluZykpIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdwYXR0ZXJucyBtdXN0IGJlIGEgc3RyaW5nIG9yIGFuIGFycmF5IG9mIHN0cmluZ3MnKTtcblx0fVxufVxuXG5mdW5jdGlvbiBnZW5lcmF0ZUdsb2JUYXNrcyhwYXR0ZXJucywgb3B0cykge1xuXHRwYXR0ZXJucyA9IFtdLmNvbmNhdChwYXR0ZXJucyk7XG5cdGFzc2VydFBhdHRlcm5zSW5wdXQocGF0dGVybnMpO1xuXG5cdHZhciBnbG9iVGFza3MgPSBbXTtcblxuXHRvcHRzID0gb2JqZWN0QXNzaWduKHtcblx0XHRjYWNoZTogT2JqZWN0LmNyZWF0ZShudWxsKSxcblx0XHRzdGF0Q2FjaGU6IE9iamVjdC5jcmVhdGUobnVsbCksXG5cdFx0cmVhbHBhdGhDYWNoZTogT2JqZWN0LmNyZWF0ZShudWxsKSxcblx0XHRzeW1saW5rczogT2JqZWN0LmNyZWF0ZShudWxsKSxcblx0XHRpZ25vcmU6IFtdXG5cdH0sIG9wdHMpO1xuXG5cdHBhdHRlcm5zLmZvckVhY2goZnVuY3Rpb24gKHBhdHRlcm4sIGkpIHtcblx0XHRpZiAoaXNOZWdhdGl2ZShwYXR0ZXJuKSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciBpZ25vcmUgPSBwYXR0ZXJucy5zbGljZShpKS5maWx0ZXIoaXNOZWdhdGl2ZSkubWFwKGZ1bmN0aW9uIChwYXR0ZXJuKSB7XG5cdFx0XHRyZXR1cm4gcGF0dGVybi5zbGljZSgxKTtcblx0XHR9KTtcblxuXHRcdGdsb2JUYXNrcy5wdXNoKHtcblx0XHRcdHBhdHRlcm46IHBhdHRlcm4sXG5cdFx0XHRvcHRzOiBvYmplY3RBc3NpZ24oe30sIG9wdHMsIHtcblx0XHRcdFx0aWdub3JlOiBvcHRzLmlnbm9yZS5jb25jYXQoaWdub3JlKVxuXHRcdFx0fSlcblx0XHR9KTtcblx0fSk7XG5cblx0cmV0dXJuIGdsb2JUYXNrcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAocGF0dGVybnMsIG9wdHMpIHtcblx0dmFyIGdsb2JUYXNrcztcblxuXHR0cnkge1xuXHRcdGdsb2JUYXNrcyA9IGdlbmVyYXRlR2xvYlRhc2tzKHBhdHRlcm5zLCBvcHRzKTtcblx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0cmV0dXJuIFByb21pc2UucmVqZWN0KGVycik7XG5cdH1cblxuXHRyZXR1cm4gUHJvbWlzZS5hbGwoZ2xvYlRhc2tzLm1hcChmdW5jdGlvbiAodGFzaykge1xuXHRcdHJldHVybiBnbG9iUCh0YXNrLnBhdHRlcm4sIHRhc2sub3B0cyk7XG5cdH0pKS50aGVuKGZ1bmN0aW9uIChwYXRocykge1xuXHRcdHJldHVybiBhcnJheVVuaW9uLmFwcGx5KG51bGwsIHBhdGhzKTtcblx0fSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5zeW5jID0gZnVuY3Rpb24gKHBhdHRlcm5zLCBvcHRzKSB7XG5cdHZhciBnbG9iVGFza3MgPSBnZW5lcmF0ZUdsb2JUYXNrcyhwYXR0ZXJucywgb3B0cyk7XG5cblx0cmV0dXJuIGdsb2JUYXNrcy5yZWR1Y2UoZnVuY3Rpb24gKG1hdGNoZXMsIHRhc2spIHtcblx0XHRyZXR1cm4gYXJyYXlVbmlvbihtYXRjaGVzLCBnbG9iLnN5bmModGFzay5wYXR0ZXJuLCB0YXNrLm9wdHMpKTtcblx0fSwgW10pO1xufTtcblxubW9kdWxlLmV4cG9ydHMuZ2VuZXJhdGVHbG9iVGFza3MgPSBnZW5lcmF0ZUdsb2JUYXNrcztcblxubW9kdWxlLmV4cG9ydHMuaGFzTWFnaWMgPSBmdW5jdGlvbiAocGF0dGVybnMsIG9wdHMpIHtcblx0cmV0dXJuIFtdLmNvbmNhdChwYXR0ZXJucykuc29tZShmdW5jdGlvbiAocGF0dGVybikge1xuXHRcdHJldHVybiBnbG9iLmhhc01hZ2ljKHBhdHRlcm4sIG9wdHMpO1xuXHR9KTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/globby/index.js\n");

/***/ }),

/***/ "./node_modules/graceful-fs/clone.js":
/*!*******************************************!*\
  !*** ./node_modules/graceful-fs/clone.js ***!
  \*******************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = clone\n\nvar getPrototypeOf = Object.getPrototypeOf || function (obj) {\n  return obj.__proto__\n}\n\nfunction clone (obj) {\n  if (obj === null || typeof obj !== 'object')\n    return obj\n\n  if (obj instanceof Object)\n    var copy = { __proto__: getPrototypeOf(obj) }\n  else\n    var copy = Object.create(null)\n\n  Object.getOwnPropertyNames(obj).forEach(function (key) {\n    Object.defineProperty(copy, key, Object.getOwnPropertyDescriptor(obj, key))\n  })\n\n  return copy\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ3JhY2VmdWwtZnMvY2xvbmUuanMuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVo7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90b2RvLWxpc3QvLi9ub2RlX21vZHVsZXMvZ3JhY2VmdWwtZnMvY2xvbmUuanM/ZWM2ZCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxubW9kdWxlLmV4cG9ydHMgPSBjbG9uZVxuXG52YXIgZ2V0UHJvdG90eXBlT2YgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gb2JqLl9fcHJvdG9fX1xufVxuXG5mdW5jdGlvbiBjbG9uZSAob2JqKSB7XG4gIGlmIChvYmogPT09IG51bGwgfHwgdHlwZW9mIG9iaiAhPT0gJ29iamVjdCcpXG4gICAgcmV0dXJuIG9ialxuXG4gIGlmIChvYmogaW5zdGFuY2VvZiBPYmplY3QpXG4gICAgdmFyIGNvcHkgPSB7IF9fcHJvdG9fXzogZ2V0UHJvdG90eXBlT2Yob2JqKSB9XG4gIGVsc2VcbiAgICB2YXIgY29weSA9IE9iamVjdC5jcmVhdGUobnVsbClcblxuICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvYmopLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb3B5LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpKVxuICB9KVxuXG4gIHJldHVybiBjb3B5XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/graceful-fs/clone.js\n");

/***/ }),

/***/ "./node_modules/graceful-fs/graceful-fs.js":
/*!*************************************************!*\
  !*** ./node_modules/graceful-fs/graceful-fs.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var fs = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'fs'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()))\nvar polyfills = __webpack_require__(/*! ./polyfills.js */ \"./node_modules/graceful-fs/polyfills.js\")\nvar legacy = __webpack_require__(/*! ./legacy-streams.js */ \"./node_modules/graceful-fs/legacy-streams.js\")\nvar clone = __webpack_require__(/*! ./clone.js */ \"./node_modules/graceful-fs/clone.js\")\n\nvar util = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'util'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()))\n\n/* istanbul ignore next - node 0.x polyfill */\nvar gracefulQueue\nvar previousSymbol\n\n/* istanbul ignore else - node 0.x polyfill */\nif (typeof Symbol === 'function' && typeof Symbol.for === 'function') {\n  gracefulQueue = Symbol.for('graceful-fs.queue')\n  // This is used in testing by future versions\n  previousSymbol = Symbol.for('graceful-fs.previous')\n} else {\n  gracefulQueue = '___graceful-fs.queue'\n  previousSymbol = '___graceful-fs.previous'\n}\n\nfunction noop () {}\n\nfunction publishQueue(context, queue) {\n  Object.defineProperty(context, gracefulQueue, {\n    get: function() {\n      return queue\n    }\n  })\n}\n\nvar debug = noop\nif (util.debuglog)\n  debug = util.debuglog('gfs4')\nelse if (/\\bgfs4\\b/i.test(process.env.NODE_DEBUG || ''))\n  debug = function() {\n    var m = util.format.apply(util, arguments)\n    m = 'GFS4: ' + m.split(/\\n/).join('\\nGFS4: ')\n    console.error(m)\n  }\n\n// Once time initialization\nif (!fs[gracefulQueue]) {\n  // This queue can be shared by multiple loaded instances\n  var queue = __webpack_require__.g[gracefulQueue] || []\n  publishQueue(fs, queue)\n\n  // Patch fs.close/closeSync to shared queue version, because we need\n  // to retry() whenever a close happens *anywhere* in the program.\n  // This is essential when multiple graceful-fs instances are\n  // in play at the same time.\n  fs.close = (function (fs$close) {\n    function close (fd, cb) {\n      return fs$close.call(fs, fd, function (err) {\n        // This function uses the graceful-fs shared queue\n        if (!err) {\n          resetQueue()\n        }\n\n        if (typeof cb === 'function')\n          cb.apply(this, arguments)\n      })\n    }\n\n    Object.defineProperty(close, previousSymbol, {\n      value: fs$close\n    })\n    return close\n  })(fs.close)\n\n  fs.closeSync = (function (fs$closeSync) {\n    function closeSync (fd) {\n      // This function uses the graceful-fs shared queue\n      fs$closeSync.apply(fs, arguments)\n      resetQueue()\n    }\n\n    Object.defineProperty(closeSync, previousSymbol, {\n      value: fs$closeSync\n    })\n    return closeSync\n  })(fs.closeSync)\n\n  if (/\\bgfs4\\b/i.test(process.env.NODE_DEBUG || '')) {\n    process.on('exit', function() {\n      debug(fs[gracefulQueue])\n      Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'assert'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())(fs[gracefulQueue].length, 0)\n    })\n  }\n}\n\nif (!__webpack_require__.g[gracefulQueue]) {\n  publishQueue(__webpack_require__.g, fs[gracefulQueue]);\n}\n\nmodule.exports = patch(clone(fs))\nif (process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !fs.__patched) {\n    module.exports = patch(fs)\n    fs.__patched = true;\n}\n\nfunction patch (fs) {\n  // Everything that references the open() function needs to be in here\n  polyfills(fs)\n  fs.gracefulify = patch\n\n  fs.createReadStream = createReadStream\n  fs.createWriteStream = createWriteStream\n  var fs$readFile = fs.readFile\n  fs.readFile = readFile\n  function readFile (path, options, cb) {\n    if (typeof options === 'function')\n      cb = options, options = null\n\n    return go$readFile(path, options, cb)\n\n    function go$readFile (path, options, cb, startTime) {\n      return fs$readFile(path, options, function (err) {\n        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))\n          enqueue([go$readFile, [path, options, cb], err, startTime || Date.now(), Date.now()])\n        else {\n          if (typeof cb === 'function')\n            cb.apply(this, arguments)\n        }\n      })\n    }\n  }\n\n  var fs$writeFile = fs.writeFile\n  fs.writeFile = writeFile\n  function writeFile (path, data, options, cb) {\n    if (typeof options === 'function')\n      cb = options, options = null\n\n    return go$writeFile(path, data, options, cb)\n\n    function go$writeFile (path, data, options, cb, startTime) {\n      return fs$writeFile(path, data, options, function (err) {\n        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))\n          enqueue([go$writeFile, [path, data, options, cb], err, startTime || Date.now(), Date.now()])\n        else {\n          if (typeof cb === 'function')\n            cb.apply(this, arguments)\n        }\n      })\n    }\n  }\n\n  var fs$appendFile = fs.appendFile\n  if (fs$appendFile)\n    fs.appendFile = appendFile\n  function appendFile (path, data, options, cb) {\n    if (typeof options === 'function')\n      cb = options, options = null\n\n    return go$appendFile(path, data, options, cb)\n\n    function go$appendFile (path, data, options, cb, startTime) {\n      return fs$appendFile(path, data, options, function (err) {\n        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))\n          enqueue([go$appendFile, [path, data, options, cb], err, startTime || Date.now(), Date.now()])\n        else {\n          if (typeof cb === 'function')\n            cb.apply(this, arguments)\n        }\n      })\n    }\n  }\n\n  var fs$copyFile = fs.copyFile\n  if (fs$copyFile)\n    fs.copyFile = copyFile\n  function copyFile (src, dest, flags, cb) {\n    if (typeof flags === 'function') {\n      cb = flags\n      flags = 0\n    }\n    return go$copyFile(src, dest, flags, cb)\n\n    function go$copyFile (src, dest, flags, cb, startTime) {\n      return fs$copyFile(src, dest, flags, function (err) {\n        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))\n          enqueue([go$copyFile, [src, dest, flags, cb], err, startTime || Date.now(), Date.now()])\n        else {\n          if (typeof cb === 'function')\n            cb.apply(this, arguments)\n        }\n      })\n    }\n  }\n\n  var fs$readdir = fs.readdir\n  fs.readdir = readdir\n  function readdir (path, options, cb) {\n    if (typeof options === 'function')\n      cb = options, options = null\n\n    return go$readdir(path, options, cb)\n\n    function go$readdir (path, options, cb, startTime) {\n      return fs$readdir(path, options, function (err, files) {\n        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))\n          enqueue([go$readdir, [path, options, cb], err, startTime || Date.now(), Date.now()])\n        else {\n          if (files && files.sort)\n            files.sort()\n\n          if (typeof cb === 'function')\n            cb.call(this, err, files)\n        }\n      })\n    }\n  }\n\n  if (process.version.substr(0, 4) === 'v0.8') {\n    var legStreams = legacy(fs)\n    ReadStream = legStreams.ReadStream\n    WriteStream = legStreams.WriteStream\n  }\n\n  var fs$ReadStream = fs.ReadStream\n  if (fs$ReadStream) {\n    ReadStream.prototype = Object.create(fs$ReadStream.prototype)\n    ReadStream.prototype.open = ReadStream$open\n  }\n\n  var fs$WriteStream = fs.WriteStream\n  if (fs$WriteStream) {\n    WriteStream.prototype = Object.create(fs$WriteStream.prototype)\n    WriteStream.prototype.open = WriteStream$open\n  }\n\n  Object.defineProperty(fs, 'ReadStream', {\n    get: function () {\n      return ReadStream\n    },\n    set: function (val) {\n      ReadStream = val\n    },\n    enumerable: true,\n    configurable: true\n  })\n  Object.defineProperty(fs, 'WriteStream', {\n    get: function () {\n      return WriteStream\n    },\n    set: function (val) {\n      WriteStream = val\n    },\n    enumerable: true,\n    configurable: true\n  })\n\n  // legacy names\n  var FileReadStream = ReadStream\n  Object.defineProperty(fs, 'FileReadStream', {\n    get: function () {\n      return FileReadStream\n    },\n    set: function (val) {\n      FileReadStream = val\n    },\n    enumerable: true,\n    configurable: true\n  })\n  var FileWriteStream = WriteStream\n  Object.defineProperty(fs, 'FileWriteStream', {\n    get: function () {\n      return FileWriteStream\n    },\n    set: function (val) {\n      FileWriteStream = val\n    },\n    enumerable: true,\n    configurable: true\n  })\n\n  function ReadStream (path, options) {\n    if (this instanceof ReadStream)\n      return fs$ReadStream.apply(this, arguments), this\n    else\n      return ReadStream.apply(Object.create(ReadStream.prototype), arguments)\n  }\n\n  function ReadStream$open () {\n    var that = this\n    open(that.path, that.flags, that.mode, function (err, fd) {\n      if (err) {\n        if (that.autoClose)\n          that.destroy()\n\n        that.emit('error', err)\n      } else {\n        that.fd = fd\n        that.emit('open', fd)\n        that.read()\n      }\n    })\n  }\n\n  function WriteStream (path, options) {\n    if (this instanceof WriteStream)\n      return fs$WriteStream.apply(this, arguments), this\n    else\n      return WriteStream.apply(Object.create(WriteStream.prototype), arguments)\n  }\n\n  function WriteStream$open () {\n    var that = this\n    open(that.path, that.flags, that.mode, function (err, fd) {\n      if (err) {\n        that.destroy()\n        that.emit('error', err)\n      } else {\n        that.fd = fd\n        that.emit('open', fd)\n      }\n    })\n  }\n\n  function createReadStream (path, options) {\n    return new fs.ReadStream(path, options)\n  }\n\n  function createWriteStream (path, options) {\n    return new fs.WriteStream(path, options)\n  }\n\n  var fs$open = fs.open\n  fs.open = open\n  function open (path, flags, mode, cb) {\n    if (typeof mode === 'function')\n      cb = mode, mode = null\n\n    return go$open(path, flags, mode, cb)\n\n    function go$open (path, flags, mode, cb, startTime) {\n      return fs$open(path, flags, mode, function (err, fd) {\n        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))\n          enqueue([go$open, [path, flags, mode, cb], err, startTime || Date.now(), Date.now()])\n        else {\n          if (typeof cb === 'function')\n            cb.apply(this, arguments)\n        }\n      })\n    }\n  }\n\n  return fs\n}\n\nfunction enqueue (elem) {\n  debug('ENQUEUE', elem[0].name, elem[1])\n  fs[gracefulQueue].push(elem)\n  retry()\n}\n\n// keep track of the timeout between retry() calls\nvar retryTimer\n\n// reset the startTime and lastTime to now\n// this resets the start of the 60 second overall timeout as well as the\n// delay between attempts so that we'll retry these jobs sooner\nfunction resetQueue () {\n  var now = Date.now()\n  for (var i = 0; i < fs[gracefulQueue].length; ++i) {\n    // entries that are only a length of 2 are from an older version, don't\n    // bother modifying those since they'll be retried anyway.\n    if (fs[gracefulQueue][i].length > 2) {\n      fs[gracefulQueue][i][3] = now // startTime\n      fs[gracefulQueue][i][4] = now // lastTime\n    }\n  }\n  // call retry to make sure we're actively processing the queue\n  retry()\n}\n\nfunction retry () {\n  // clear the timer and remove it to help prevent unintended concurrency\n  clearTimeout(retryTimer)\n  retryTimer = undefined\n\n  if (fs[gracefulQueue].length === 0)\n    return\n\n  var elem = fs[gracefulQueue].shift()\n  var fn = elem[0]\n  var args = elem[1]\n  // these items may be unset if they were added by an older graceful-fs\n  var err = elem[2]\n  var startTime = elem[3]\n  var lastTime = elem[4]\n\n  // if we don't have a startTime we have no way of knowing if we've waited\n  // long enough, so go ahead and retry this item now\n  if (startTime === undefined) {\n    debug('RETRY', fn.name, args)\n    fn.apply(null, args)\n  } else if (Date.now() - startTime >= 60000) {\n    // it's been more than 60 seconds total, bail now\n    debug('TIMEOUT', fn.name, args)\n    var cb = args.pop()\n    if (typeof cb === 'function')\n      cb.call(null, err)\n  } else {\n    // the amount of time between the last attempt and right now\n    var sinceAttempt = Date.now() - lastTime\n    // the amount of time between when we first tried, and when we last tried\n    // rounded up to at least 1\n    var sinceStart = Math.max(lastTime - startTime, 1)\n    // backoff. wait longer than the total time we've been retrying, but only\n    // up to a maximum of 100ms\n    var desiredDelay = Math.min(sinceStart * 1.2, 100)\n    // it's been long enough since the last retry, do it again\n    if (sinceAttempt >= desiredDelay) {\n      debug('RETRY', fn.name, args)\n      fn.apply(null, args.concat([startTime]))\n    } else {\n      // if we can't do this job yet, push it to the end of the queue\n      // and let the next iteration check again\n      fs[gracefulQueue].push(elem)\n    }\n  }\n\n  // schedule our next run if one isn't already scheduled\n  if (retryTimer === undefined) {\n    retryTimer = setTimeout(retry, 0)\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ3JhY2VmdWwtZnMvZ3JhY2VmdWwtZnMuanMuanMiLCJtYXBwaW5ncyI6IkFBQUEsU0FBUyxtQkFBTyxDQUFDLGlJQUFJO0FBQ3JCLGdCQUFnQixtQkFBTyxDQUFDLCtEQUFnQjtBQUN4QyxhQUFhLG1CQUFPLENBQUMseUVBQXFCO0FBQzFDLFlBQVksbUJBQU8sQ0FBQyx1REFBWTs7QUFFaEMsV0FBVyxtQkFBTyxDQUFDLG1JQUFNOztBQUV6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYyxxQkFBTTtBQUNwQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLE1BQU0scUlBQXVCO0FBQzdCLEtBQUs7QUFDTDtBQUNBOztBQUVBLEtBQUsscUJBQU07QUFDWCxlQUFlLHFCQUFNO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiw4QkFBOEI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3RvZG8tbGlzdC8uL25vZGVfbW9kdWxlcy9ncmFjZWZ1bC1mcy9ncmFjZWZ1bC1mcy5qcz8wZGE3Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBmcyA9IHJlcXVpcmUoJ2ZzJylcbnZhciBwb2x5ZmlsbHMgPSByZXF1aXJlKCcuL3BvbHlmaWxscy5qcycpXG52YXIgbGVnYWN5ID0gcmVxdWlyZSgnLi9sZWdhY3ktc3RyZWFtcy5qcycpXG52YXIgY2xvbmUgPSByZXF1aXJlKCcuL2Nsb25lLmpzJylcblxudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJylcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgLSBub2RlIDAueCBwb2x5ZmlsbCAqL1xudmFyIGdyYWNlZnVsUXVldWVcbnZhciBwcmV2aW91c1N5bWJvbFxuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAtIG5vZGUgMC54IHBvbHlmaWxsICovXG5pZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgU3ltYm9sLmZvciA9PT0gJ2Z1bmN0aW9uJykge1xuICBncmFjZWZ1bFF1ZXVlID0gU3ltYm9sLmZvcignZ3JhY2VmdWwtZnMucXVldWUnKVxuICAvLyBUaGlzIGlzIHVzZWQgaW4gdGVzdGluZyBieSBmdXR1cmUgdmVyc2lvbnNcbiAgcHJldmlvdXNTeW1ib2wgPSBTeW1ib2wuZm9yKCdncmFjZWZ1bC1mcy5wcmV2aW91cycpXG59IGVsc2Uge1xuICBncmFjZWZ1bFF1ZXVlID0gJ19fX2dyYWNlZnVsLWZzLnF1ZXVlJ1xuICBwcmV2aW91c1N5bWJvbCA9ICdfX19ncmFjZWZ1bC1mcy5wcmV2aW91cydcbn1cblxuZnVuY3Rpb24gbm9vcCAoKSB7fVxuXG5mdW5jdGlvbiBwdWJsaXNoUXVldWUoY29udGV4dCwgcXVldWUpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNvbnRleHQsIGdyYWNlZnVsUXVldWUsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHF1ZXVlXG4gICAgfVxuICB9KVxufVxuXG52YXIgZGVidWcgPSBub29wXG5pZiAodXRpbC5kZWJ1Z2xvZylcbiAgZGVidWcgPSB1dGlsLmRlYnVnbG9nKCdnZnM0JylcbmVsc2UgaWYgKC9cXGJnZnM0XFxiL2kudGVzdChwcm9jZXNzLmVudi5OT0RFX0RFQlVHIHx8ICcnKSlcbiAgZGVidWcgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgbSA9IHV0aWwuZm9ybWF0LmFwcGx5KHV0aWwsIGFyZ3VtZW50cylcbiAgICBtID0gJ0dGUzQ6ICcgKyBtLnNwbGl0KC9cXG4vKS5qb2luKCdcXG5HRlM0OiAnKVxuICAgIGNvbnNvbGUuZXJyb3IobSlcbiAgfVxuXG4vLyBPbmNlIHRpbWUgaW5pdGlhbGl6YXRpb25cbmlmICghZnNbZ3JhY2VmdWxRdWV1ZV0pIHtcbiAgLy8gVGhpcyBxdWV1ZSBjYW4gYmUgc2hhcmVkIGJ5IG11bHRpcGxlIGxvYWRlZCBpbnN0YW5jZXNcbiAgdmFyIHF1ZXVlID0gZ2xvYmFsW2dyYWNlZnVsUXVldWVdIHx8IFtdXG4gIHB1Ymxpc2hRdWV1ZShmcywgcXVldWUpXG5cbiAgLy8gUGF0Y2ggZnMuY2xvc2UvY2xvc2VTeW5jIHRvIHNoYXJlZCBxdWV1ZSB2ZXJzaW9uLCBiZWNhdXNlIHdlIG5lZWRcbiAgLy8gdG8gcmV0cnkoKSB3aGVuZXZlciBhIGNsb3NlIGhhcHBlbnMgKmFueXdoZXJlKiBpbiB0aGUgcHJvZ3JhbS5cbiAgLy8gVGhpcyBpcyBlc3NlbnRpYWwgd2hlbiBtdWx0aXBsZSBncmFjZWZ1bC1mcyBpbnN0YW5jZXMgYXJlXG4gIC8vIGluIHBsYXkgYXQgdGhlIHNhbWUgdGltZS5cbiAgZnMuY2xvc2UgPSAoZnVuY3Rpb24gKGZzJGNsb3NlKSB7XG4gICAgZnVuY3Rpb24gY2xvc2UgKGZkLCBjYikge1xuICAgICAgcmV0dXJuIGZzJGNsb3NlLmNhbGwoZnMsIGZkLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIC8vIFRoaXMgZnVuY3Rpb24gdXNlcyB0aGUgZ3JhY2VmdWwtZnMgc2hhcmVkIHF1ZXVlXG4gICAgICAgIGlmICghZXJyKSB7XG4gICAgICAgICAgcmVzZXRRdWV1ZSgpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGNiID09PSAnZnVuY3Rpb24nKVxuICAgICAgICAgIGNiLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNsb3NlLCBwcmV2aW91c1N5bWJvbCwge1xuICAgICAgdmFsdWU6IGZzJGNsb3NlXG4gICAgfSlcbiAgICByZXR1cm4gY2xvc2VcbiAgfSkoZnMuY2xvc2UpXG5cbiAgZnMuY2xvc2VTeW5jID0gKGZ1bmN0aW9uIChmcyRjbG9zZVN5bmMpIHtcbiAgICBmdW5jdGlvbiBjbG9zZVN5bmMgKGZkKSB7XG4gICAgICAvLyBUaGlzIGZ1bmN0aW9uIHVzZXMgdGhlIGdyYWNlZnVsLWZzIHNoYXJlZCBxdWV1ZVxuICAgICAgZnMkY2xvc2VTeW5jLmFwcGx5KGZzLCBhcmd1bWVudHMpXG4gICAgICByZXNldFF1ZXVlKClcbiAgICB9XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY2xvc2VTeW5jLCBwcmV2aW91c1N5bWJvbCwge1xuICAgICAgdmFsdWU6IGZzJGNsb3NlU3luY1xuICAgIH0pXG4gICAgcmV0dXJuIGNsb3NlU3luY1xuICB9KShmcy5jbG9zZVN5bmMpXG5cbiAgaWYgKC9cXGJnZnM0XFxiL2kudGVzdChwcm9jZXNzLmVudi5OT0RFX0RFQlVHIHx8ICcnKSkge1xuICAgIHByb2Nlc3Mub24oJ2V4aXQnLCBmdW5jdGlvbigpIHtcbiAgICAgIGRlYnVnKGZzW2dyYWNlZnVsUXVldWVdKVxuICAgICAgcmVxdWlyZSgnYXNzZXJ0JykuZXF1YWwoZnNbZ3JhY2VmdWxRdWV1ZV0ubGVuZ3RoLCAwKVxuICAgIH0pXG4gIH1cbn1cblxuaWYgKCFnbG9iYWxbZ3JhY2VmdWxRdWV1ZV0pIHtcbiAgcHVibGlzaFF1ZXVlKGdsb2JhbCwgZnNbZ3JhY2VmdWxRdWV1ZV0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHBhdGNoKGNsb25lKGZzKSlcbmlmIChwcm9jZXNzLmVudi5URVNUX0dSQUNFRlVMX0ZTX0dMT0JBTF9QQVRDSCAmJiAhZnMuX19wYXRjaGVkKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBwYXRjaChmcylcbiAgICBmcy5fX3BhdGNoZWQgPSB0cnVlO1xufVxuXG5mdW5jdGlvbiBwYXRjaCAoZnMpIHtcbiAgLy8gRXZlcnl0aGluZyB0aGF0IHJlZmVyZW5jZXMgdGhlIG9wZW4oKSBmdW5jdGlvbiBuZWVkcyB0byBiZSBpbiBoZXJlXG4gIHBvbHlmaWxscyhmcylcbiAgZnMuZ3JhY2VmdWxpZnkgPSBwYXRjaFxuXG4gIGZzLmNyZWF0ZVJlYWRTdHJlYW0gPSBjcmVhdGVSZWFkU3RyZWFtXG4gIGZzLmNyZWF0ZVdyaXRlU3RyZWFtID0gY3JlYXRlV3JpdGVTdHJlYW1cbiAgdmFyIGZzJHJlYWRGaWxlID0gZnMucmVhZEZpbGVcbiAgZnMucmVhZEZpbGUgPSByZWFkRmlsZVxuICBmdW5jdGlvbiByZWFkRmlsZSAocGF0aCwgb3B0aW9ucywgY2IpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpXG4gICAgICBjYiA9IG9wdGlvbnMsIG9wdGlvbnMgPSBudWxsXG5cbiAgICByZXR1cm4gZ28kcmVhZEZpbGUocGF0aCwgb3B0aW9ucywgY2IpXG5cbiAgICBmdW5jdGlvbiBnbyRyZWFkRmlsZSAocGF0aCwgb3B0aW9ucywgY2IsIHN0YXJ0VGltZSkge1xuICAgICAgcmV0dXJuIGZzJHJlYWRGaWxlKHBhdGgsIG9wdGlvbnMsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgaWYgKGVyciAmJiAoZXJyLmNvZGUgPT09ICdFTUZJTEUnIHx8IGVyci5jb2RlID09PSAnRU5GSUxFJykpXG4gICAgICAgICAgZW5xdWV1ZShbZ28kcmVhZEZpbGUsIFtwYXRoLCBvcHRpb25zLCBjYl0sIGVyciwgc3RhcnRUaW1lIHx8IERhdGUubm93KCksIERhdGUubm93KCldKVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBpZiAodHlwZW9mIGNiID09PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgY2IuYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIHZhciBmcyR3cml0ZUZpbGUgPSBmcy53cml0ZUZpbGVcbiAgZnMud3JpdGVGaWxlID0gd3JpdGVGaWxlXG4gIGZ1bmN0aW9uIHdyaXRlRmlsZSAocGF0aCwgZGF0YSwgb3B0aW9ucywgY2IpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpXG4gICAgICBjYiA9IG9wdGlvbnMsIG9wdGlvbnMgPSBudWxsXG5cbiAgICByZXR1cm4gZ28kd3JpdGVGaWxlKHBhdGgsIGRhdGEsIG9wdGlvbnMsIGNiKVxuXG4gICAgZnVuY3Rpb24gZ28kd3JpdGVGaWxlIChwYXRoLCBkYXRhLCBvcHRpb25zLCBjYiwgc3RhcnRUaW1lKSB7XG4gICAgICByZXR1cm4gZnMkd3JpdGVGaWxlKHBhdGgsIGRhdGEsIG9wdGlvbnMsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgaWYgKGVyciAmJiAoZXJyLmNvZGUgPT09ICdFTUZJTEUnIHx8IGVyci5jb2RlID09PSAnRU5GSUxFJykpXG4gICAgICAgICAgZW5xdWV1ZShbZ28kd3JpdGVGaWxlLCBbcGF0aCwgZGF0YSwgb3B0aW9ucywgY2JdLCBlcnIsIHN0YXJ0VGltZSB8fCBEYXRlLm5vdygpLCBEYXRlLm5vdygpXSlcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgIGNiLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICB2YXIgZnMkYXBwZW5kRmlsZSA9IGZzLmFwcGVuZEZpbGVcbiAgaWYgKGZzJGFwcGVuZEZpbGUpXG4gICAgZnMuYXBwZW5kRmlsZSA9IGFwcGVuZEZpbGVcbiAgZnVuY3Rpb24gYXBwZW5kRmlsZSAocGF0aCwgZGF0YSwgb3B0aW9ucywgY2IpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpXG4gICAgICBjYiA9IG9wdGlvbnMsIG9wdGlvbnMgPSBudWxsXG5cbiAgICByZXR1cm4gZ28kYXBwZW5kRmlsZShwYXRoLCBkYXRhLCBvcHRpb25zLCBjYilcblxuICAgIGZ1bmN0aW9uIGdvJGFwcGVuZEZpbGUgKHBhdGgsIGRhdGEsIG9wdGlvbnMsIGNiLCBzdGFydFRpbWUpIHtcbiAgICAgIHJldHVybiBmcyRhcHBlbmRGaWxlKHBhdGgsIGRhdGEsIG9wdGlvbnMsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgaWYgKGVyciAmJiAoZXJyLmNvZGUgPT09ICdFTUZJTEUnIHx8IGVyci5jb2RlID09PSAnRU5GSUxFJykpXG4gICAgICAgICAgZW5xdWV1ZShbZ28kYXBwZW5kRmlsZSwgW3BhdGgsIGRhdGEsIG9wdGlvbnMsIGNiXSwgZXJyLCBzdGFydFRpbWUgfHwgRGF0ZS5ub3coKSwgRGF0ZS5ub3coKV0pXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGlmICh0eXBlb2YgY2IgPT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICBjYi5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgdmFyIGZzJGNvcHlGaWxlID0gZnMuY29weUZpbGVcbiAgaWYgKGZzJGNvcHlGaWxlKVxuICAgIGZzLmNvcHlGaWxlID0gY29weUZpbGVcbiAgZnVuY3Rpb24gY29weUZpbGUgKHNyYywgZGVzdCwgZmxhZ3MsIGNiKSB7XG4gICAgaWYgKHR5cGVvZiBmbGFncyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2IgPSBmbGFnc1xuICAgICAgZmxhZ3MgPSAwXG4gICAgfVxuICAgIHJldHVybiBnbyRjb3B5RmlsZShzcmMsIGRlc3QsIGZsYWdzLCBjYilcblxuICAgIGZ1bmN0aW9uIGdvJGNvcHlGaWxlIChzcmMsIGRlc3QsIGZsYWdzLCBjYiwgc3RhcnRUaW1lKSB7XG4gICAgICByZXR1cm4gZnMkY29weUZpbGUoc3JjLCBkZXN0LCBmbGFncywgZnVuY3Rpb24gKGVycikge1xuICAgICAgICBpZiAoZXJyICYmIChlcnIuY29kZSA9PT0gJ0VNRklMRScgfHwgZXJyLmNvZGUgPT09ICdFTkZJTEUnKSlcbiAgICAgICAgICBlbnF1ZXVlKFtnbyRjb3B5RmlsZSwgW3NyYywgZGVzdCwgZmxhZ3MsIGNiXSwgZXJyLCBzdGFydFRpbWUgfHwgRGF0ZS5ub3coKSwgRGF0ZS5ub3coKV0pXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGlmICh0eXBlb2YgY2IgPT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICBjYi5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgdmFyIGZzJHJlYWRkaXIgPSBmcy5yZWFkZGlyXG4gIGZzLnJlYWRkaXIgPSByZWFkZGlyXG4gIGZ1bmN0aW9uIHJlYWRkaXIgKHBhdGgsIG9wdGlvbnMsIGNiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKVxuICAgICAgY2IgPSBvcHRpb25zLCBvcHRpb25zID0gbnVsbFxuXG4gICAgcmV0dXJuIGdvJHJlYWRkaXIocGF0aCwgb3B0aW9ucywgY2IpXG5cbiAgICBmdW5jdGlvbiBnbyRyZWFkZGlyIChwYXRoLCBvcHRpb25zLCBjYiwgc3RhcnRUaW1lKSB7XG4gICAgICByZXR1cm4gZnMkcmVhZGRpcihwYXRoLCBvcHRpb25zLCBmdW5jdGlvbiAoZXJyLCBmaWxlcykge1xuICAgICAgICBpZiAoZXJyICYmIChlcnIuY29kZSA9PT0gJ0VNRklMRScgfHwgZXJyLmNvZGUgPT09ICdFTkZJTEUnKSlcbiAgICAgICAgICBlbnF1ZXVlKFtnbyRyZWFkZGlyLCBbcGF0aCwgb3B0aW9ucywgY2JdLCBlcnIsIHN0YXJ0VGltZSB8fCBEYXRlLm5vdygpLCBEYXRlLm5vdygpXSlcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgaWYgKGZpbGVzICYmIGZpbGVzLnNvcnQpXG4gICAgICAgICAgICBmaWxlcy5zb3J0KClcblxuICAgICAgICAgIGlmICh0eXBlb2YgY2IgPT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICBjYi5jYWxsKHRoaXMsIGVyciwgZmlsZXMpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgaWYgKHByb2Nlc3MudmVyc2lvbi5zdWJzdHIoMCwgNCkgPT09ICd2MC44Jykge1xuICAgIHZhciBsZWdTdHJlYW1zID0gbGVnYWN5KGZzKVxuICAgIFJlYWRTdHJlYW0gPSBsZWdTdHJlYW1zLlJlYWRTdHJlYW1cbiAgICBXcml0ZVN0cmVhbSA9IGxlZ1N0cmVhbXMuV3JpdGVTdHJlYW1cbiAgfVxuXG4gIHZhciBmcyRSZWFkU3RyZWFtID0gZnMuUmVhZFN0cmVhbVxuICBpZiAoZnMkUmVhZFN0cmVhbSkge1xuICAgIFJlYWRTdHJlYW0ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShmcyRSZWFkU3RyZWFtLnByb3RvdHlwZSlcbiAgICBSZWFkU3RyZWFtLnByb3RvdHlwZS5vcGVuID0gUmVhZFN0cmVhbSRvcGVuXG4gIH1cblxuICB2YXIgZnMkV3JpdGVTdHJlYW0gPSBmcy5Xcml0ZVN0cmVhbVxuICBpZiAoZnMkV3JpdGVTdHJlYW0pIHtcbiAgICBXcml0ZVN0cmVhbS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGZzJFdyaXRlU3RyZWFtLnByb3RvdHlwZSlcbiAgICBXcml0ZVN0cmVhbS5wcm90b3R5cGUub3BlbiA9IFdyaXRlU3RyZWFtJG9wZW5cbiAgfVxuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmcywgJ1JlYWRTdHJlYW0nLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gUmVhZFN0cmVhbVxuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICBSZWFkU3RyZWFtID0gdmFsXG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZnMsICdXcml0ZVN0cmVhbScsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBXcml0ZVN0cmVhbVxuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICBXcml0ZVN0cmVhbSA9IHZhbFxuICAgIH0sXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSlcblxuICAvLyBsZWdhY3kgbmFtZXNcbiAgdmFyIEZpbGVSZWFkU3RyZWFtID0gUmVhZFN0cmVhbVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZnMsICdGaWxlUmVhZFN0cmVhbScsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBGaWxlUmVhZFN0cmVhbVxuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICBGaWxlUmVhZFN0cmVhbSA9IHZhbFxuICAgIH0sXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSlcbiAgdmFyIEZpbGVXcml0ZVN0cmVhbSA9IFdyaXRlU3RyZWFtXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmcywgJ0ZpbGVXcml0ZVN0cmVhbScsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBGaWxlV3JpdGVTdHJlYW1cbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgRmlsZVdyaXRlU3RyZWFtID0gdmFsXG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KVxuXG4gIGZ1bmN0aW9uIFJlYWRTdHJlYW0gKHBhdGgsIG9wdGlvbnMpIHtcbiAgICBpZiAodGhpcyBpbnN0YW5jZW9mIFJlYWRTdHJlYW0pXG4gICAgICByZXR1cm4gZnMkUmVhZFN0cmVhbS5hcHBseSh0aGlzLCBhcmd1bWVudHMpLCB0aGlzXG4gICAgZWxzZVxuICAgICAgcmV0dXJuIFJlYWRTdHJlYW0uYXBwbHkoT2JqZWN0LmNyZWF0ZShSZWFkU3RyZWFtLnByb3RvdHlwZSksIGFyZ3VtZW50cylcbiAgfVxuXG4gIGZ1bmN0aW9uIFJlYWRTdHJlYW0kb3BlbiAoKSB7XG4gICAgdmFyIHRoYXQgPSB0aGlzXG4gICAgb3Blbih0aGF0LnBhdGgsIHRoYXQuZmxhZ3MsIHRoYXQubW9kZSwgZnVuY3Rpb24gKGVyciwgZmQpIHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgaWYgKHRoYXQuYXV0b0Nsb3NlKVxuICAgICAgICAgIHRoYXQuZGVzdHJveSgpXG5cbiAgICAgICAgdGhhdC5lbWl0KCdlcnJvcicsIGVycilcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoYXQuZmQgPSBmZFxuICAgICAgICB0aGF0LmVtaXQoJ29wZW4nLCBmZClcbiAgICAgICAgdGhhdC5yZWFkKClcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgZnVuY3Rpb24gV3JpdGVTdHJlYW0gKHBhdGgsIG9wdGlvbnMpIHtcbiAgICBpZiAodGhpcyBpbnN0YW5jZW9mIFdyaXRlU3RyZWFtKVxuICAgICAgcmV0dXJuIGZzJFdyaXRlU3RyZWFtLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksIHRoaXNcbiAgICBlbHNlXG4gICAgICByZXR1cm4gV3JpdGVTdHJlYW0uYXBwbHkoT2JqZWN0LmNyZWF0ZShXcml0ZVN0cmVhbS5wcm90b3R5cGUpLCBhcmd1bWVudHMpXG4gIH1cblxuICBmdW5jdGlvbiBXcml0ZVN0cmVhbSRvcGVuICgpIHtcbiAgICB2YXIgdGhhdCA9IHRoaXNcbiAgICBvcGVuKHRoYXQucGF0aCwgdGhhdC5mbGFncywgdGhhdC5tb2RlLCBmdW5jdGlvbiAoZXJyLCBmZCkge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICB0aGF0LmRlc3Ryb3koKVxuICAgICAgICB0aGF0LmVtaXQoJ2Vycm9yJywgZXJyKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhhdC5mZCA9IGZkXG4gICAgICAgIHRoYXQuZW1pdCgnb3BlbicsIGZkKVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVSZWFkU3RyZWFtIChwYXRoLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBmcy5SZWFkU3RyZWFtKHBhdGgsIG9wdGlvbnMpXG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVXcml0ZVN0cmVhbSAocGF0aCwgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgZnMuV3JpdGVTdHJlYW0ocGF0aCwgb3B0aW9ucylcbiAgfVxuXG4gIHZhciBmcyRvcGVuID0gZnMub3BlblxuICBmcy5vcGVuID0gb3BlblxuICBmdW5jdGlvbiBvcGVuIChwYXRoLCBmbGFncywgbW9kZSwgY2IpIHtcbiAgICBpZiAodHlwZW9mIG1vZGUgPT09ICdmdW5jdGlvbicpXG4gICAgICBjYiA9IG1vZGUsIG1vZGUgPSBudWxsXG5cbiAgICByZXR1cm4gZ28kb3BlbihwYXRoLCBmbGFncywgbW9kZSwgY2IpXG5cbiAgICBmdW5jdGlvbiBnbyRvcGVuIChwYXRoLCBmbGFncywgbW9kZSwgY2IsIHN0YXJ0VGltZSkge1xuICAgICAgcmV0dXJuIGZzJG9wZW4ocGF0aCwgZmxhZ3MsIG1vZGUsIGZ1bmN0aW9uIChlcnIsIGZkKSB7XG4gICAgICAgIGlmIChlcnIgJiYgKGVyci5jb2RlID09PSAnRU1GSUxFJyB8fCBlcnIuY29kZSA9PT0gJ0VORklMRScpKVxuICAgICAgICAgIGVucXVldWUoW2dvJG9wZW4sIFtwYXRoLCBmbGFncywgbW9kZSwgY2JdLCBlcnIsIHN0YXJ0VGltZSB8fCBEYXRlLm5vdygpLCBEYXRlLm5vdygpXSlcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgIGNiLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZnNcbn1cblxuZnVuY3Rpb24gZW5xdWV1ZSAoZWxlbSkge1xuICBkZWJ1ZygnRU5RVUVVRScsIGVsZW1bMF0ubmFtZSwgZWxlbVsxXSlcbiAgZnNbZ3JhY2VmdWxRdWV1ZV0ucHVzaChlbGVtKVxuICByZXRyeSgpXG59XG5cbi8vIGtlZXAgdHJhY2sgb2YgdGhlIHRpbWVvdXQgYmV0d2VlbiByZXRyeSgpIGNhbGxzXG52YXIgcmV0cnlUaW1lclxuXG4vLyByZXNldCB0aGUgc3RhcnRUaW1lIGFuZCBsYXN0VGltZSB0byBub3dcbi8vIHRoaXMgcmVzZXRzIHRoZSBzdGFydCBvZiB0aGUgNjAgc2Vjb25kIG92ZXJhbGwgdGltZW91dCBhcyB3ZWxsIGFzIHRoZVxuLy8gZGVsYXkgYmV0d2VlbiBhdHRlbXB0cyBzbyB0aGF0IHdlJ2xsIHJldHJ5IHRoZXNlIGpvYnMgc29vbmVyXG5mdW5jdGlvbiByZXNldFF1ZXVlICgpIHtcbiAgdmFyIG5vdyA9IERhdGUubm93KClcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBmc1tncmFjZWZ1bFF1ZXVlXS5sZW5ndGg7ICsraSkge1xuICAgIC8vIGVudHJpZXMgdGhhdCBhcmUgb25seSBhIGxlbmd0aCBvZiAyIGFyZSBmcm9tIGFuIG9sZGVyIHZlcnNpb24sIGRvbid0XG4gICAgLy8gYm90aGVyIG1vZGlmeWluZyB0aG9zZSBzaW5jZSB0aGV5J2xsIGJlIHJldHJpZWQgYW55d2F5LlxuICAgIGlmIChmc1tncmFjZWZ1bFF1ZXVlXVtpXS5sZW5ndGggPiAyKSB7XG4gICAgICBmc1tncmFjZWZ1bFF1ZXVlXVtpXVszXSA9IG5vdyAvLyBzdGFydFRpbWVcbiAgICAgIGZzW2dyYWNlZnVsUXVldWVdW2ldWzRdID0gbm93IC8vIGxhc3RUaW1lXG4gICAgfVxuICB9XG4gIC8vIGNhbGwgcmV0cnkgdG8gbWFrZSBzdXJlIHdlJ3JlIGFjdGl2ZWx5IHByb2Nlc3NpbmcgdGhlIHF1ZXVlXG4gIHJldHJ5KClcbn1cblxuZnVuY3Rpb24gcmV0cnkgKCkge1xuICAvLyBjbGVhciB0aGUgdGltZXIgYW5kIHJlbW92ZSBpdCB0byBoZWxwIHByZXZlbnQgdW5pbnRlbmRlZCBjb25jdXJyZW5jeVxuICBjbGVhclRpbWVvdXQocmV0cnlUaW1lcilcbiAgcmV0cnlUaW1lciA9IHVuZGVmaW5lZFxuXG4gIGlmIChmc1tncmFjZWZ1bFF1ZXVlXS5sZW5ndGggPT09IDApXG4gICAgcmV0dXJuXG5cbiAgdmFyIGVsZW0gPSBmc1tncmFjZWZ1bFF1ZXVlXS5zaGlmdCgpXG4gIHZhciBmbiA9IGVsZW1bMF1cbiAgdmFyIGFyZ3MgPSBlbGVtWzFdXG4gIC8vIHRoZXNlIGl0ZW1zIG1heSBiZSB1bnNldCBpZiB0aGV5IHdlcmUgYWRkZWQgYnkgYW4gb2xkZXIgZ3JhY2VmdWwtZnNcbiAgdmFyIGVyciA9IGVsZW1bMl1cbiAgdmFyIHN0YXJ0VGltZSA9IGVsZW1bM11cbiAgdmFyIGxhc3RUaW1lID0gZWxlbVs0XVxuXG4gIC8vIGlmIHdlIGRvbid0IGhhdmUgYSBzdGFydFRpbWUgd2UgaGF2ZSBubyB3YXkgb2Yga25vd2luZyBpZiB3ZSd2ZSB3YWl0ZWRcbiAgLy8gbG9uZyBlbm91Z2gsIHNvIGdvIGFoZWFkIGFuZCByZXRyeSB0aGlzIGl0ZW0gbm93XG4gIGlmIChzdGFydFRpbWUgPT09IHVuZGVmaW5lZCkge1xuICAgIGRlYnVnKCdSRVRSWScsIGZuLm5hbWUsIGFyZ3MpXG4gICAgZm4uYXBwbHkobnVsbCwgYXJncylcbiAgfSBlbHNlIGlmIChEYXRlLm5vdygpIC0gc3RhcnRUaW1lID49IDYwMDAwKSB7XG4gICAgLy8gaXQncyBiZWVuIG1vcmUgdGhhbiA2MCBzZWNvbmRzIHRvdGFsLCBiYWlsIG5vd1xuICAgIGRlYnVnKCdUSU1FT1VUJywgZm4ubmFtZSwgYXJncylcbiAgICB2YXIgY2IgPSBhcmdzLnBvcCgpXG4gICAgaWYgKHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgIGNiLmNhbGwobnVsbCwgZXJyKVxuICB9IGVsc2Uge1xuICAgIC8vIHRoZSBhbW91bnQgb2YgdGltZSBiZXR3ZWVuIHRoZSBsYXN0IGF0dGVtcHQgYW5kIHJpZ2h0IG5vd1xuICAgIHZhciBzaW5jZUF0dGVtcHQgPSBEYXRlLm5vdygpIC0gbGFzdFRpbWVcbiAgICAvLyB0aGUgYW1vdW50IG9mIHRpbWUgYmV0d2VlbiB3aGVuIHdlIGZpcnN0IHRyaWVkLCBhbmQgd2hlbiB3ZSBsYXN0IHRyaWVkXG4gICAgLy8gcm91bmRlZCB1cCB0byBhdCBsZWFzdCAxXG4gICAgdmFyIHNpbmNlU3RhcnQgPSBNYXRoLm1heChsYXN0VGltZSAtIHN0YXJ0VGltZSwgMSlcbiAgICAvLyBiYWNrb2ZmLiB3YWl0IGxvbmdlciB0aGFuIHRoZSB0b3RhbCB0aW1lIHdlJ3ZlIGJlZW4gcmV0cnlpbmcsIGJ1dCBvbmx5XG4gICAgLy8gdXAgdG8gYSBtYXhpbXVtIG9mIDEwMG1zXG4gICAgdmFyIGRlc2lyZWREZWxheSA9IE1hdGgubWluKHNpbmNlU3RhcnQgKiAxLjIsIDEwMClcbiAgICAvLyBpdCdzIGJlZW4gbG9uZyBlbm91Z2ggc2luY2UgdGhlIGxhc3QgcmV0cnksIGRvIGl0IGFnYWluXG4gICAgaWYgKHNpbmNlQXR0ZW1wdCA+PSBkZXNpcmVkRGVsYXkpIHtcbiAgICAgIGRlYnVnKCdSRVRSWScsIGZuLm5hbWUsIGFyZ3MpXG4gICAgICBmbi5hcHBseShudWxsLCBhcmdzLmNvbmNhdChbc3RhcnRUaW1lXSkpXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGlmIHdlIGNhbid0IGRvIHRoaXMgam9iIHlldCwgcHVzaCBpdCB0byB0aGUgZW5kIG9mIHRoZSBxdWV1ZVxuICAgICAgLy8gYW5kIGxldCB0aGUgbmV4dCBpdGVyYXRpb24gY2hlY2sgYWdhaW5cbiAgICAgIGZzW2dyYWNlZnVsUXVldWVdLnB1c2goZWxlbSlcbiAgICB9XG4gIH1cblxuICAvLyBzY2hlZHVsZSBvdXIgbmV4dCBydW4gaWYgb25lIGlzbid0IGFscmVhZHkgc2NoZWR1bGVkXG4gIGlmIChyZXRyeVRpbWVyID09PSB1bmRlZmluZWQpIHtcbiAgICByZXRyeVRpbWVyID0gc2V0VGltZW91dChyZXRyeSwgMClcbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/graceful-fs/graceful-fs.js\n");

/***/ }),

/***/ "./node_modules/graceful-fs/legacy-streams.js":
/*!****************************************************!*\
  !*** ./node_modules/graceful-fs/legacy-streams.js ***!
  \****************************************************/
/***/ ((module) => {

eval("var Stream = Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'stream'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())\n\nmodule.exports = legacy\n\nfunction legacy (fs) {\n  return {\n    ReadStream: ReadStream,\n    WriteStream: WriteStream\n  }\n\n  function ReadStream (path, options) {\n    if (!(this instanceof ReadStream)) return new ReadStream(path, options);\n\n    Stream.call(this);\n\n    var self = this;\n\n    this.path = path;\n    this.fd = null;\n    this.readable = true;\n    this.paused = false;\n\n    this.flags = 'r';\n    this.mode = 438; /*=0666*/\n    this.bufferSize = 64 * 1024;\n\n    options = options || {};\n\n    // Mixin options into this\n    var keys = Object.keys(options);\n    for (var index = 0, length = keys.length; index < length; index++) {\n      var key = keys[index];\n      this[key] = options[key];\n    }\n\n    if (this.encoding) this.setEncoding(this.encoding);\n\n    if (this.start !== undefined) {\n      if ('number' !== typeof this.start) {\n        throw TypeError('start must be a Number');\n      }\n      if (this.end === undefined) {\n        this.end = Infinity;\n      } else if ('number' !== typeof this.end) {\n        throw TypeError('end must be a Number');\n      }\n\n      if (this.start > this.end) {\n        throw new Error('start must be <= end');\n      }\n\n      this.pos = this.start;\n    }\n\n    if (this.fd !== null) {\n      process.nextTick(function() {\n        self._read();\n      });\n      return;\n    }\n\n    fs.open(this.path, this.flags, this.mode, function (err, fd) {\n      if (err) {\n        self.emit('error', err);\n        self.readable = false;\n        return;\n      }\n\n      self.fd = fd;\n      self.emit('open', fd);\n      self._read();\n    })\n  }\n\n  function WriteStream (path, options) {\n    if (!(this instanceof WriteStream)) return new WriteStream(path, options);\n\n    Stream.call(this);\n\n    this.path = path;\n    this.fd = null;\n    this.writable = true;\n\n    this.flags = 'w';\n    this.encoding = 'binary';\n    this.mode = 438; /*=0666*/\n    this.bytesWritten = 0;\n\n    options = options || {};\n\n    // Mixin options into this\n    var keys = Object.keys(options);\n    for (var index = 0, length = keys.length; index < length; index++) {\n      var key = keys[index];\n      this[key] = options[key];\n    }\n\n    if (this.start !== undefined) {\n      if ('number' !== typeof this.start) {\n        throw TypeError('start must be a Number');\n      }\n      if (this.start < 0) {\n        throw new Error('start must be >= zero');\n      }\n\n      this.pos = this.start;\n    }\n\n    this.busy = false;\n    this._queue = [];\n\n    if (this.fd === null) {\n      this._open = fs.open;\n      this._queue.push([this._open, this.path, this.flags, this.mode, undefined]);\n      this.flush();\n    }\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ3JhY2VmdWwtZnMvbGVnYWN5LXN0cmVhbXMuanMuanMiLCJtYXBwaW5ncyI6IkFBQUEsYUFBYSxxSUFBd0I7O0FBRXJDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQjtBQUNyQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsOENBQThDLGdCQUFnQjtBQUM5RDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCOztBQUVBOztBQUVBO0FBQ0E7QUFDQSw4Q0FBOEMsZ0JBQWdCO0FBQzlEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90b2RvLWxpc3QvLi9ub2RlX21vZHVsZXMvZ3JhY2VmdWwtZnMvbGVnYWN5LXN0cmVhbXMuanM/YzAyZiJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgU3RyZWFtID0gcmVxdWlyZSgnc3RyZWFtJykuU3RyZWFtXG5cbm1vZHVsZS5leHBvcnRzID0gbGVnYWN5XG5cbmZ1bmN0aW9uIGxlZ2FjeSAoZnMpIHtcbiAgcmV0dXJuIHtcbiAgICBSZWFkU3RyZWFtOiBSZWFkU3RyZWFtLFxuICAgIFdyaXRlU3RyZWFtOiBXcml0ZVN0cmVhbVxuICB9XG5cbiAgZnVuY3Rpb24gUmVhZFN0cmVhbSAocGF0aCwgb3B0aW9ucykge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBSZWFkU3RyZWFtKSkgcmV0dXJuIG5ldyBSZWFkU3RyZWFtKHBhdGgsIG9wdGlvbnMpO1xuXG4gICAgU3RyZWFtLmNhbGwodGhpcyk7XG5cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICB0aGlzLnBhdGggPSBwYXRoO1xuICAgIHRoaXMuZmQgPSBudWxsO1xuICAgIHRoaXMucmVhZGFibGUgPSB0cnVlO1xuICAgIHRoaXMucGF1c2VkID0gZmFsc2U7XG5cbiAgICB0aGlzLmZsYWdzID0gJ3InO1xuICAgIHRoaXMubW9kZSA9IDQzODsgLyo9MDY2NiovXG4gICAgdGhpcy5idWZmZXJTaXplID0gNjQgKiAxMDI0O1xuXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAvLyBNaXhpbiBvcHRpb25zIGludG8gdGhpc1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMob3B0aW9ucyk7XG4gICAgZm9yICh2YXIgaW5kZXggPSAwLCBsZW5ndGggPSBrZXlzLmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2luZGV4XTtcbiAgICAgIHRoaXNba2V5XSA9IG9wdGlvbnNba2V5XTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5lbmNvZGluZykgdGhpcy5zZXRFbmNvZGluZyh0aGlzLmVuY29kaW5nKTtcblxuICAgIGlmICh0aGlzLnN0YXJ0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmICgnbnVtYmVyJyAhPT0gdHlwZW9mIHRoaXMuc3RhcnQpIHtcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKCdzdGFydCBtdXN0IGJlIGEgTnVtYmVyJyk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5lbmQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLmVuZCA9IEluZmluaXR5O1xuICAgICAgfSBlbHNlIGlmICgnbnVtYmVyJyAhPT0gdHlwZW9mIHRoaXMuZW5kKSB7XG4gICAgICAgIHRocm93IFR5cGVFcnJvcignZW5kIG11c3QgYmUgYSBOdW1iZXInKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuc3RhcnQgPiB0aGlzLmVuZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3N0YXJ0IG11c3QgYmUgPD0gZW5kJyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMucG9zID0gdGhpcy5zdGFydDtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5mZCAhPT0gbnVsbCkge1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpIHtcbiAgICAgICAgc2VsZi5fcmVhZCgpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZnMub3Blbih0aGlzLnBhdGgsIHRoaXMuZmxhZ3MsIHRoaXMubW9kZSwgZnVuY3Rpb24gKGVyciwgZmQpIHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgc2VsZi5lbWl0KCdlcnJvcicsIGVycik7XG4gICAgICAgIHNlbGYucmVhZGFibGUgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBzZWxmLmZkID0gZmQ7XG4gICAgICBzZWxmLmVtaXQoJ29wZW4nLCBmZCk7XG4gICAgICBzZWxmLl9yZWFkKCk7XG4gICAgfSlcbiAgfVxuXG4gIGZ1bmN0aW9uIFdyaXRlU3RyZWFtIChwYXRoLCBvcHRpb25zKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFdyaXRlU3RyZWFtKSkgcmV0dXJuIG5ldyBXcml0ZVN0cmVhbShwYXRoLCBvcHRpb25zKTtcblxuICAgIFN0cmVhbS5jYWxsKHRoaXMpO1xuXG4gICAgdGhpcy5wYXRoID0gcGF0aDtcbiAgICB0aGlzLmZkID0gbnVsbDtcbiAgICB0aGlzLndyaXRhYmxlID0gdHJ1ZTtcblxuICAgIHRoaXMuZmxhZ3MgPSAndyc7XG4gICAgdGhpcy5lbmNvZGluZyA9ICdiaW5hcnknO1xuICAgIHRoaXMubW9kZSA9IDQzODsgLyo9MDY2NiovXG4gICAgdGhpcy5ieXRlc1dyaXR0ZW4gPSAwO1xuXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAvLyBNaXhpbiBvcHRpb25zIGludG8gdGhpc1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMob3B0aW9ucyk7XG4gICAgZm9yICh2YXIgaW5kZXggPSAwLCBsZW5ndGggPSBrZXlzLmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2luZGV4XTtcbiAgICAgIHRoaXNba2V5XSA9IG9wdGlvbnNba2V5XTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5zdGFydCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoJ251bWJlcicgIT09IHR5cGVvZiB0aGlzLnN0YXJ0KSB7XG4gICAgICAgIHRocm93IFR5cGVFcnJvcignc3RhcnQgbXVzdCBiZSBhIE51bWJlcicpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuc3RhcnQgPCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignc3RhcnQgbXVzdCBiZSA+PSB6ZXJvJyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMucG9zID0gdGhpcy5zdGFydDtcbiAgICB9XG5cbiAgICB0aGlzLmJ1c3kgPSBmYWxzZTtcbiAgICB0aGlzLl9xdWV1ZSA9IFtdO1xuXG4gICAgaWYgKHRoaXMuZmQgPT09IG51bGwpIHtcbiAgICAgIHRoaXMuX29wZW4gPSBmcy5vcGVuO1xuICAgICAgdGhpcy5fcXVldWUucHVzaChbdGhpcy5fb3BlbiwgdGhpcy5wYXRoLCB0aGlzLmZsYWdzLCB0aGlzLm1vZGUsIHVuZGVmaW5lZF0pO1xuICAgICAgdGhpcy5mbHVzaCgpO1xuICAgIH1cbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/graceful-fs/legacy-streams.js\n");

/***/ }),

/***/ "./node_modules/graceful-fs/polyfills.js":
/*!***********************************************!*\
  !*** ./node_modules/graceful-fs/polyfills.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var constants = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'constants'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()))\n\nvar origCwd = process.cwd\nvar cwd = null\n\nvar platform = process.env.GRACEFUL_FS_PLATFORM || process.platform\n\nprocess.cwd = function() {\n  if (!cwd)\n    cwd = origCwd.call(process)\n  return cwd\n}\ntry {\n  process.cwd()\n} catch (er) {}\n\n// This check is needed until node.js 12 is required\nif (typeof process.chdir === 'function') {\n  var chdir = process.chdir\n  process.chdir = function (d) {\n    cwd = null\n    chdir.call(process, d)\n  }\n  if (Object.setPrototypeOf) Object.setPrototypeOf(process.chdir, chdir)\n}\n\nmodule.exports = patch\n\nfunction patch (fs) {\n  // (re-)implement some things that are known busted or missing.\n\n  // lchmod, broken prior to 0.6.2\n  // back-port the fix here.\n  if (constants.hasOwnProperty('O_SYMLINK') &&\n      process.version.match(/^v0\\.6\\.[0-2]|^v0\\.5\\./)) {\n    patchLchmod(fs)\n  }\n\n  // lutimes implementation, or no-op\n  if (!fs.lutimes) {\n    patchLutimes(fs)\n  }\n\n  // https://github.com/isaacs/node-graceful-fs/issues/4\n  // Chown should not fail on einval or eperm if non-root.\n  // It should not fail on enosys ever, as this just indicates\n  // that a fs doesn't support the intended operation.\n\n  fs.chown = chownFix(fs.chown)\n  fs.fchown = chownFix(fs.fchown)\n  fs.lchown = chownFix(fs.lchown)\n\n  fs.chmod = chmodFix(fs.chmod)\n  fs.fchmod = chmodFix(fs.fchmod)\n  fs.lchmod = chmodFix(fs.lchmod)\n\n  fs.chownSync = chownFixSync(fs.chownSync)\n  fs.fchownSync = chownFixSync(fs.fchownSync)\n  fs.lchownSync = chownFixSync(fs.lchownSync)\n\n  fs.chmodSync = chmodFixSync(fs.chmodSync)\n  fs.fchmodSync = chmodFixSync(fs.fchmodSync)\n  fs.lchmodSync = chmodFixSync(fs.lchmodSync)\n\n  fs.stat = statFix(fs.stat)\n  fs.fstat = statFix(fs.fstat)\n  fs.lstat = statFix(fs.lstat)\n\n  fs.statSync = statFixSync(fs.statSync)\n  fs.fstatSync = statFixSync(fs.fstatSync)\n  fs.lstatSync = statFixSync(fs.lstatSync)\n\n  // if lchmod/lchown do not exist, then make them no-ops\n  if (!fs.lchmod) {\n    fs.lchmod = function (path, mode, cb) {\n      if (cb) process.nextTick(cb)\n    }\n    fs.lchmodSync = function () {}\n  }\n  if (!fs.lchown) {\n    fs.lchown = function (path, uid, gid, cb) {\n      if (cb) process.nextTick(cb)\n    }\n    fs.lchownSync = function () {}\n  }\n\n  // on Windows, A/V software can lock the directory, causing this\n  // to fail with an EACCES or EPERM if the directory contains newly\n  // created files.  Try again on failure, for up to 60 seconds.\n\n  // Set the timeout this long because some Windows Anti-Virus, such as Parity\n  // bit9, may lock files for up to a minute, causing npm package install\n  // failures. Also, take care to yield the scheduler. Windows scheduling gives\n  // CPU to a busy looping process, which can cause the program causing the lock\n  // contention to be starved of CPU by node, so the contention doesn't resolve.\n  if (platform === \"win32\") {\n    fs.rename = (function (fs$rename) { return function (from, to, cb) {\n      var start = Date.now()\n      var backoff = 0;\n      fs$rename(from, to, function CB (er) {\n        if (er\n            && (er.code === \"EACCES\" || er.code === \"EPERM\")\n            && Date.now() - start < 60000) {\n          setTimeout(function() {\n            fs.stat(to, function (stater, st) {\n              if (stater && stater.code === \"ENOENT\")\n                fs$rename(from, to, CB);\n              else\n                cb(er)\n            })\n          }, backoff)\n          if (backoff < 100)\n            backoff += 10;\n          return;\n        }\n        if (cb) cb(er)\n      })\n    }})(fs.rename)\n  }\n\n  // if read() returns EAGAIN, then just try it again.\n  fs.read = (function (fs$read) {\n    function read (fd, buffer, offset, length, position, callback_) {\n      var callback\n      if (callback_ && typeof callback_ === 'function') {\n        var eagCounter = 0\n        callback = function (er, _, __) {\n          if (er && er.code === 'EAGAIN' && eagCounter < 10) {\n            eagCounter ++\n            return fs$read.call(fs, fd, buffer, offset, length, position, callback)\n          }\n          callback_.apply(this, arguments)\n        }\n      }\n      return fs$read.call(fs, fd, buffer, offset, length, position, callback)\n    }\n\n    // This ensures `util.promisify` works as it does for native `fs.read`.\n    if (Object.setPrototypeOf) Object.setPrototypeOf(read, fs$read)\n    return read\n  })(fs.read)\n\n  fs.readSync = (function (fs$readSync) { return function (fd, buffer, offset, length, position) {\n    var eagCounter = 0\n    while (true) {\n      try {\n        return fs$readSync.call(fs, fd, buffer, offset, length, position)\n      } catch (er) {\n        if (er.code === 'EAGAIN' && eagCounter < 10) {\n          eagCounter ++\n          continue\n        }\n        throw er\n      }\n    }\n  }})(fs.readSync)\n\n  function patchLchmod (fs) {\n    fs.lchmod = function (path, mode, callback) {\n      fs.open( path\n             , constants.O_WRONLY | constants.O_SYMLINK\n             , mode\n             , function (err, fd) {\n        if (err) {\n          if (callback) callback(err)\n          return\n        }\n        // prefer to return the chmod error, if one occurs,\n        // but still try to close, and report closing errors if they occur.\n        fs.fchmod(fd, mode, function (err) {\n          fs.close(fd, function(err2) {\n            if (callback) callback(err || err2)\n          })\n        })\n      })\n    }\n\n    fs.lchmodSync = function (path, mode) {\n      var fd = fs.openSync(path, constants.O_WRONLY | constants.O_SYMLINK, mode)\n\n      // prefer to return the chmod error, if one occurs,\n      // but still try to close, and report closing errors if they occur.\n      var threw = true\n      var ret\n      try {\n        ret = fs.fchmodSync(fd, mode)\n        threw = false\n      } finally {\n        if (threw) {\n          try {\n            fs.closeSync(fd)\n          } catch (er) {}\n        } else {\n          fs.closeSync(fd)\n        }\n      }\n      return ret\n    }\n  }\n\n  function patchLutimes (fs) {\n    if (constants.hasOwnProperty(\"O_SYMLINK\")) {\n      fs.lutimes = function (path, at, mt, cb) {\n        fs.open(path, constants.O_SYMLINK, function (er, fd) {\n          if (er) {\n            if (cb) cb(er)\n            return\n          }\n          fs.futimes(fd, at, mt, function (er) {\n            fs.close(fd, function (er2) {\n              if (cb) cb(er || er2)\n            })\n          })\n        })\n      }\n\n      fs.lutimesSync = function (path, at, mt) {\n        var fd = fs.openSync(path, constants.O_SYMLINK)\n        var ret\n        var threw = true\n        try {\n          ret = fs.futimesSync(fd, at, mt)\n          threw = false\n        } finally {\n          if (threw) {\n            try {\n              fs.closeSync(fd)\n            } catch (er) {}\n          } else {\n            fs.closeSync(fd)\n          }\n        }\n        return ret\n      }\n\n    } else {\n      fs.lutimes = function (_a, _b, _c, cb) { if (cb) process.nextTick(cb) }\n      fs.lutimesSync = function () {}\n    }\n  }\n\n  function chmodFix (orig) {\n    if (!orig) return orig\n    return function (target, mode, cb) {\n      return orig.call(fs, target, mode, function (er) {\n        if (chownErOk(er)) er = null\n        if (cb) cb.apply(this, arguments)\n      })\n    }\n  }\n\n  function chmodFixSync (orig) {\n    if (!orig) return orig\n    return function (target, mode) {\n      try {\n        return orig.call(fs, target, mode)\n      } catch (er) {\n        if (!chownErOk(er)) throw er\n      }\n    }\n  }\n\n\n  function chownFix (orig) {\n    if (!orig) return orig\n    return function (target, uid, gid, cb) {\n      return orig.call(fs, target, uid, gid, function (er) {\n        if (chownErOk(er)) er = null\n        if (cb) cb.apply(this, arguments)\n      })\n    }\n  }\n\n  function chownFixSync (orig) {\n    if (!orig) return orig\n    return function (target, uid, gid) {\n      try {\n        return orig.call(fs, target, uid, gid)\n      } catch (er) {\n        if (!chownErOk(er)) throw er\n      }\n    }\n  }\n\n  function statFix (orig) {\n    if (!orig) return orig\n    // Older versions of Node erroneously returned signed integers for\n    // uid + gid.\n    return function (target, options, cb) {\n      if (typeof options === 'function') {\n        cb = options\n        options = null\n      }\n      function callback (er, stats) {\n        if (stats) {\n          if (stats.uid < 0) stats.uid += 0x100000000\n          if (stats.gid < 0) stats.gid += 0x100000000\n        }\n        if (cb) cb.apply(this, arguments)\n      }\n      return options ? orig.call(fs, target, options, callback)\n        : orig.call(fs, target, callback)\n    }\n  }\n\n  function statFixSync (orig) {\n    if (!orig) return orig\n    // Older versions of Node erroneously returned signed integers for\n    // uid + gid.\n    return function (target, options) {\n      var stats = options ? orig.call(fs, target, options)\n        : orig.call(fs, target)\n      if (stats) {\n        if (stats.uid < 0) stats.uid += 0x100000000\n        if (stats.gid < 0) stats.gid += 0x100000000\n      }\n      return stats;\n    }\n  }\n\n  // ENOSYS means that the fs doesn't support the op. Just ignore\n  // that, because it doesn't matter.\n  //\n  // if there's no getuid, or if getuid() is something other\n  // than 0, and the error is EINVAL or EPERM, then just ignore\n  // it.\n  //\n  // This specific case is a silent failure in cp, install, tar,\n  // and most other unix tools that manage permissions.\n  //\n  // When running as root, or if other types of errors are\n  // encountered, then it's strict.\n  function chownErOk (er) {\n    if (!er)\n      return true\n\n    if (er.code === \"ENOSYS\")\n      return true\n\n    var nonroot = !process.getuid || process.getuid() !== 0\n    if (nonroot) {\n      if (er.code === \"EINVAL\" || er.code === \"EPERM\")\n        return true\n    }\n\n    return false\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ3JhY2VmdWwtZnMvcG9seWZpbGxzLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBLGdCQUFnQixtQkFBTyxDQUFDLHdJQUFXOztBQUVuQztBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUgsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNULE9BQU87QUFDUDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWixVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsV0FBVztBQUNYLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsTUFBTTtBQUNOLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90b2RvLWxpc3QvLi9ub2RlX21vZHVsZXMvZ3JhY2VmdWwtZnMvcG9seWZpbGxzLmpzP2EwYTMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGNvbnN0YW50cyA9IHJlcXVpcmUoJ2NvbnN0YW50cycpXG5cbnZhciBvcmlnQ3dkID0gcHJvY2Vzcy5jd2RcbnZhciBjd2QgPSBudWxsXG5cbnZhciBwbGF0Zm9ybSA9IHByb2Nlc3MuZW52LkdSQUNFRlVMX0ZTX1BMQVRGT1JNIHx8IHByb2Nlc3MucGxhdGZvcm1cblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbigpIHtcbiAgaWYgKCFjd2QpXG4gICAgY3dkID0gb3JpZ0N3ZC5jYWxsKHByb2Nlc3MpXG4gIHJldHVybiBjd2Rcbn1cbnRyeSB7XG4gIHByb2Nlc3MuY3dkKClcbn0gY2F0Y2ggKGVyKSB7fVxuXG4vLyBUaGlzIGNoZWNrIGlzIG5lZWRlZCB1bnRpbCBub2RlLmpzIDEyIGlzIHJlcXVpcmVkXG5pZiAodHlwZW9mIHByb2Nlc3MuY2hkaXIgPT09ICdmdW5jdGlvbicpIHtcbiAgdmFyIGNoZGlyID0gcHJvY2Vzcy5jaGRpclxuICBwcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGQpIHtcbiAgICBjd2QgPSBudWxsXG4gICAgY2hkaXIuY2FsbChwcm9jZXNzLCBkKVxuICB9XG4gIGlmIChPYmplY3Quc2V0UHJvdG90eXBlT2YpIE9iamVjdC5zZXRQcm90b3R5cGVPZihwcm9jZXNzLmNoZGlyLCBjaGRpcilcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBwYXRjaFxuXG5mdW5jdGlvbiBwYXRjaCAoZnMpIHtcbiAgLy8gKHJlLSlpbXBsZW1lbnQgc29tZSB0aGluZ3MgdGhhdCBhcmUga25vd24gYnVzdGVkIG9yIG1pc3NpbmcuXG5cbiAgLy8gbGNobW9kLCBicm9rZW4gcHJpb3IgdG8gMC42LjJcbiAgLy8gYmFjay1wb3J0IHRoZSBmaXggaGVyZS5cbiAgaWYgKGNvbnN0YW50cy5oYXNPd25Qcm9wZXJ0eSgnT19TWU1MSU5LJykgJiZcbiAgICAgIHByb2Nlc3MudmVyc2lvbi5tYXRjaCgvXnYwXFwuNlxcLlswLTJdfF52MFxcLjVcXC4vKSkge1xuICAgIHBhdGNoTGNobW9kKGZzKVxuICB9XG5cbiAgLy8gbHV0aW1lcyBpbXBsZW1lbnRhdGlvbiwgb3Igbm8tb3BcbiAgaWYgKCFmcy5sdXRpbWVzKSB7XG4gICAgcGF0Y2hMdXRpbWVzKGZzKVxuICB9XG5cbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2lzYWFjcy9ub2RlLWdyYWNlZnVsLWZzL2lzc3Vlcy80XG4gIC8vIENob3duIHNob3VsZCBub3QgZmFpbCBvbiBlaW52YWwgb3IgZXBlcm0gaWYgbm9uLXJvb3QuXG4gIC8vIEl0IHNob3VsZCBub3QgZmFpbCBvbiBlbm9zeXMgZXZlciwgYXMgdGhpcyBqdXN0IGluZGljYXRlc1xuICAvLyB0aGF0IGEgZnMgZG9lc24ndCBzdXBwb3J0IHRoZSBpbnRlbmRlZCBvcGVyYXRpb24uXG5cbiAgZnMuY2hvd24gPSBjaG93bkZpeChmcy5jaG93bilcbiAgZnMuZmNob3duID0gY2hvd25GaXgoZnMuZmNob3duKVxuICBmcy5sY2hvd24gPSBjaG93bkZpeChmcy5sY2hvd24pXG5cbiAgZnMuY2htb2QgPSBjaG1vZEZpeChmcy5jaG1vZClcbiAgZnMuZmNobW9kID0gY2htb2RGaXgoZnMuZmNobW9kKVxuICBmcy5sY2htb2QgPSBjaG1vZEZpeChmcy5sY2htb2QpXG5cbiAgZnMuY2hvd25TeW5jID0gY2hvd25GaXhTeW5jKGZzLmNob3duU3luYylcbiAgZnMuZmNob3duU3luYyA9IGNob3duRml4U3luYyhmcy5mY2hvd25TeW5jKVxuICBmcy5sY2hvd25TeW5jID0gY2hvd25GaXhTeW5jKGZzLmxjaG93blN5bmMpXG5cbiAgZnMuY2htb2RTeW5jID0gY2htb2RGaXhTeW5jKGZzLmNobW9kU3luYylcbiAgZnMuZmNobW9kU3luYyA9IGNobW9kRml4U3luYyhmcy5mY2htb2RTeW5jKVxuICBmcy5sY2htb2RTeW5jID0gY2htb2RGaXhTeW5jKGZzLmxjaG1vZFN5bmMpXG5cbiAgZnMuc3RhdCA9IHN0YXRGaXgoZnMuc3RhdClcbiAgZnMuZnN0YXQgPSBzdGF0Rml4KGZzLmZzdGF0KVxuICBmcy5sc3RhdCA9IHN0YXRGaXgoZnMubHN0YXQpXG5cbiAgZnMuc3RhdFN5bmMgPSBzdGF0Rml4U3luYyhmcy5zdGF0U3luYylcbiAgZnMuZnN0YXRTeW5jID0gc3RhdEZpeFN5bmMoZnMuZnN0YXRTeW5jKVxuICBmcy5sc3RhdFN5bmMgPSBzdGF0Rml4U3luYyhmcy5sc3RhdFN5bmMpXG5cbiAgLy8gaWYgbGNobW9kL2xjaG93biBkbyBub3QgZXhpc3QsIHRoZW4gbWFrZSB0aGVtIG5vLW9wc1xuICBpZiAoIWZzLmxjaG1vZCkge1xuICAgIGZzLmxjaG1vZCA9IGZ1bmN0aW9uIChwYXRoLCBtb2RlLCBjYikge1xuICAgICAgaWYgKGNiKSBwcm9jZXNzLm5leHRUaWNrKGNiKVxuICAgIH1cbiAgICBmcy5sY2htb2RTeW5jID0gZnVuY3Rpb24gKCkge31cbiAgfVxuICBpZiAoIWZzLmxjaG93bikge1xuICAgIGZzLmxjaG93biA9IGZ1bmN0aW9uIChwYXRoLCB1aWQsIGdpZCwgY2IpIHtcbiAgICAgIGlmIChjYikgcHJvY2Vzcy5uZXh0VGljayhjYilcbiAgICB9XG4gICAgZnMubGNob3duU3luYyA9IGZ1bmN0aW9uICgpIHt9XG4gIH1cblxuICAvLyBvbiBXaW5kb3dzLCBBL1Ygc29mdHdhcmUgY2FuIGxvY2sgdGhlIGRpcmVjdG9yeSwgY2F1c2luZyB0aGlzXG4gIC8vIHRvIGZhaWwgd2l0aCBhbiBFQUNDRVMgb3IgRVBFUk0gaWYgdGhlIGRpcmVjdG9yeSBjb250YWlucyBuZXdseVxuICAvLyBjcmVhdGVkIGZpbGVzLiAgVHJ5IGFnYWluIG9uIGZhaWx1cmUsIGZvciB1cCB0byA2MCBzZWNvbmRzLlxuXG4gIC8vIFNldCB0aGUgdGltZW91dCB0aGlzIGxvbmcgYmVjYXVzZSBzb21lIFdpbmRvd3MgQW50aS1WaXJ1cywgc3VjaCBhcyBQYXJpdHlcbiAgLy8gYml0OSwgbWF5IGxvY2sgZmlsZXMgZm9yIHVwIHRvIGEgbWludXRlLCBjYXVzaW5nIG5wbSBwYWNrYWdlIGluc3RhbGxcbiAgLy8gZmFpbHVyZXMuIEFsc28sIHRha2UgY2FyZSB0byB5aWVsZCB0aGUgc2NoZWR1bGVyLiBXaW5kb3dzIHNjaGVkdWxpbmcgZ2l2ZXNcbiAgLy8gQ1BVIHRvIGEgYnVzeSBsb29waW5nIHByb2Nlc3MsIHdoaWNoIGNhbiBjYXVzZSB0aGUgcHJvZ3JhbSBjYXVzaW5nIHRoZSBsb2NrXG4gIC8vIGNvbnRlbnRpb24gdG8gYmUgc3RhcnZlZCBvZiBDUFUgYnkgbm9kZSwgc28gdGhlIGNvbnRlbnRpb24gZG9lc24ndCByZXNvbHZlLlxuICBpZiAocGxhdGZvcm0gPT09IFwid2luMzJcIikge1xuICAgIGZzLnJlbmFtZSA9IChmdW5jdGlvbiAoZnMkcmVuYW1lKSB7IHJldHVybiBmdW5jdGlvbiAoZnJvbSwgdG8sIGNiKSB7XG4gICAgICB2YXIgc3RhcnQgPSBEYXRlLm5vdygpXG4gICAgICB2YXIgYmFja29mZiA9IDA7XG4gICAgICBmcyRyZW5hbWUoZnJvbSwgdG8sIGZ1bmN0aW9uIENCIChlcikge1xuICAgICAgICBpZiAoZXJcbiAgICAgICAgICAgICYmIChlci5jb2RlID09PSBcIkVBQ0NFU1wiIHx8IGVyLmNvZGUgPT09IFwiRVBFUk1cIilcbiAgICAgICAgICAgICYmIERhdGUubm93KCkgLSBzdGFydCA8IDYwMDAwKSB7XG4gICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGZzLnN0YXQodG8sIGZ1bmN0aW9uIChzdGF0ZXIsIHN0KSB7XG4gICAgICAgICAgICAgIGlmIChzdGF0ZXIgJiYgc3RhdGVyLmNvZGUgPT09IFwiRU5PRU5UXCIpXG4gICAgICAgICAgICAgICAgZnMkcmVuYW1lKGZyb20sIHRvLCBDQik7XG4gICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBjYihlcilcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfSwgYmFja29mZilcbiAgICAgICAgICBpZiAoYmFja29mZiA8IDEwMClcbiAgICAgICAgICAgIGJhY2tvZmYgKz0gMTA7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjYikgY2IoZXIpXG4gICAgICB9KVxuICAgIH19KShmcy5yZW5hbWUpXG4gIH1cblxuICAvLyBpZiByZWFkKCkgcmV0dXJucyBFQUdBSU4sIHRoZW4ganVzdCB0cnkgaXQgYWdhaW4uXG4gIGZzLnJlYWQgPSAoZnVuY3Rpb24gKGZzJHJlYWQpIHtcbiAgICBmdW5jdGlvbiByZWFkIChmZCwgYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCwgcG9zaXRpb24sIGNhbGxiYWNrXykge1xuICAgICAgdmFyIGNhbGxiYWNrXG4gICAgICBpZiAoY2FsbGJhY2tfICYmIHR5cGVvZiBjYWxsYmFja18gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdmFyIGVhZ0NvdW50ZXIgPSAwXG4gICAgICAgIGNhbGxiYWNrID0gZnVuY3Rpb24gKGVyLCBfLCBfXykge1xuICAgICAgICAgIGlmIChlciAmJiBlci5jb2RlID09PSAnRUFHQUlOJyAmJiBlYWdDb3VudGVyIDwgMTApIHtcbiAgICAgICAgICAgIGVhZ0NvdW50ZXIgKytcbiAgICAgICAgICAgIHJldHVybiBmcyRyZWFkLmNhbGwoZnMsIGZkLCBidWZmZXIsIG9mZnNldCwgbGVuZ3RoLCBwb3NpdGlvbiwgY2FsbGJhY2spXG4gICAgICAgICAgfVxuICAgICAgICAgIGNhbGxiYWNrXy5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmcyRyZWFkLmNhbGwoZnMsIGZkLCBidWZmZXIsIG9mZnNldCwgbGVuZ3RoLCBwb3NpdGlvbiwgY2FsbGJhY2spXG4gICAgfVxuXG4gICAgLy8gVGhpcyBlbnN1cmVzIGB1dGlsLnByb21pc2lmeWAgd29ya3MgYXMgaXQgZG9lcyBmb3IgbmF0aXZlIGBmcy5yZWFkYC5cbiAgICBpZiAoT2JqZWN0LnNldFByb3RvdHlwZU9mKSBPYmplY3Quc2V0UHJvdG90eXBlT2YocmVhZCwgZnMkcmVhZClcbiAgICByZXR1cm4gcmVhZFxuICB9KShmcy5yZWFkKVxuXG4gIGZzLnJlYWRTeW5jID0gKGZ1bmN0aW9uIChmcyRyZWFkU3luYykgeyByZXR1cm4gZnVuY3Rpb24gKGZkLCBidWZmZXIsIG9mZnNldCwgbGVuZ3RoLCBwb3NpdGlvbikge1xuICAgIHZhciBlYWdDb3VudGVyID0gMFxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gZnMkcmVhZFN5bmMuY2FsbChmcywgZmQsIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIHBvc2l0aW9uKVxuICAgICAgfSBjYXRjaCAoZXIpIHtcbiAgICAgICAgaWYgKGVyLmNvZGUgPT09ICdFQUdBSU4nICYmIGVhZ0NvdW50ZXIgPCAxMCkge1xuICAgICAgICAgIGVhZ0NvdW50ZXIgKytcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG4gICAgICAgIHRocm93IGVyXG4gICAgICB9XG4gICAgfVxuICB9fSkoZnMucmVhZFN5bmMpXG5cbiAgZnVuY3Rpb24gcGF0Y2hMY2htb2QgKGZzKSB7XG4gICAgZnMubGNobW9kID0gZnVuY3Rpb24gKHBhdGgsIG1vZGUsIGNhbGxiYWNrKSB7XG4gICAgICBmcy5vcGVuKCBwYXRoXG4gICAgICAgICAgICAgLCBjb25zdGFudHMuT19XUk9OTFkgfCBjb25zdGFudHMuT19TWU1MSU5LXG4gICAgICAgICAgICAgLCBtb2RlXG4gICAgICAgICAgICAgLCBmdW5jdGlvbiAoZXJyLCBmZCkge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKSBjYWxsYmFjayhlcnIpXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgICAgLy8gcHJlZmVyIHRvIHJldHVybiB0aGUgY2htb2QgZXJyb3IsIGlmIG9uZSBvY2N1cnMsXG4gICAgICAgIC8vIGJ1dCBzdGlsbCB0cnkgdG8gY2xvc2UsIGFuZCByZXBvcnQgY2xvc2luZyBlcnJvcnMgaWYgdGhleSBvY2N1ci5cbiAgICAgICAgZnMuZmNobW9kKGZkLCBtb2RlLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgZnMuY2xvc2UoZmQsIGZ1bmN0aW9uKGVycjIpIHtcbiAgICAgICAgICAgIGlmIChjYWxsYmFjaykgY2FsbGJhY2soZXJyIHx8IGVycjIpXG4gICAgICAgICAgfSlcbiAgICAgICAgfSlcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgZnMubGNobW9kU3luYyA9IGZ1bmN0aW9uIChwYXRoLCBtb2RlKSB7XG4gICAgICB2YXIgZmQgPSBmcy5vcGVuU3luYyhwYXRoLCBjb25zdGFudHMuT19XUk9OTFkgfCBjb25zdGFudHMuT19TWU1MSU5LLCBtb2RlKVxuXG4gICAgICAvLyBwcmVmZXIgdG8gcmV0dXJuIHRoZSBjaG1vZCBlcnJvciwgaWYgb25lIG9jY3VycyxcbiAgICAgIC8vIGJ1dCBzdGlsbCB0cnkgdG8gY2xvc2UsIGFuZCByZXBvcnQgY2xvc2luZyBlcnJvcnMgaWYgdGhleSBvY2N1ci5cbiAgICAgIHZhciB0aHJldyA9IHRydWVcbiAgICAgIHZhciByZXRcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldCA9IGZzLmZjaG1vZFN5bmMoZmQsIG1vZGUpXG4gICAgICAgIHRocmV3ID0gZmFsc2VcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmICh0aHJldykge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmcy5jbG9zZVN5bmMoZmQpXG4gICAgICAgICAgfSBjYXRjaCAoZXIpIHt9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZnMuY2xvc2VTeW5jKGZkKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmV0XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcGF0Y2hMdXRpbWVzIChmcykge1xuICAgIGlmIChjb25zdGFudHMuaGFzT3duUHJvcGVydHkoXCJPX1NZTUxJTktcIikpIHtcbiAgICAgIGZzLmx1dGltZXMgPSBmdW5jdGlvbiAocGF0aCwgYXQsIG10LCBjYikge1xuICAgICAgICBmcy5vcGVuKHBhdGgsIGNvbnN0YW50cy5PX1NZTUxJTkssIGZ1bmN0aW9uIChlciwgZmQpIHtcbiAgICAgICAgICBpZiAoZXIpIHtcbiAgICAgICAgICAgIGlmIChjYikgY2IoZXIpXG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICB9XG4gICAgICAgICAgZnMuZnV0aW1lcyhmZCwgYXQsIG10LCBmdW5jdGlvbiAoZXIpIHtcbiAgICAgICAgICAgIGZzLmNsb3NlKGZkLCBmdW5jdGlvbiAoZXIyKSB7XG4gICAgICAgICAgICAgIGlmIChjYikgY2IoZXIgfHwgZXIyKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9KVxuICAgICAgICB9KVxuICAgICAgfVxuXG4gICAgICBmcy5sdXRpbWVzU3luYyA9IGZ1bmN0aW9uIChwYXRoLCBhdCwgbXQpIHtcbiAgICAgICAgdmFyIGZkID0gZnMub3BlblN5bmMocGF0aCwgY29uc3RhbnRzLk9fU1lNTElOSylcbiAgICAgICAgdmFyIHJldFxuICAgICAgICB2YXIgdGhyZXcgPSB0cnVlXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0ID0gZnMuZnV0aW1lc1N5bmMoZmQsIGF0LCBtdClcbiAgICAgICAgICB0aHJldyA9IGZhbHNlXG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgaWYgKHRocmV3KSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBmcy5jbG9zZVN5bmMoZmQpXG4gICAgICAgICAgICB9IGNhdGNoIChlcikge31cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZnMuY2xvc2VTeW5jKGZkKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0XG4gICAgICB9XG5cbiAgICB9IGVsc2Uge1xuICAgICAgZnMubHV0aW1lcyA9IGZ1bmN0aW9uIChfYSwgX2IsIF9jLCBjYikgeyBpZiAoY2IpIHByb2Nlc3MubmV4dFRpY2soY2IpIH1cbiAgICAgIGZzLmx1dGltZXNTeW5jID0gZnVuY3Rpb24gKCkge31cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjaG1vZEZpeCAob3JpZykge1xuICAgIGlmICghb3JpZykgcmV0dXJuIG9yaWdcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwgbW9kZSwgY2IpIHtcbiAgICAgIHJldHVybiBvcmlnLmNhbGwoZnMsIHRhcmdldCwgbW9kZSwgZnVuY3Rpb24gKGVyKSB7XG4gICAgICAgIGlmIChjaG93bkVyT2soZXIpKSBlciA9IG51bGxcbiAgICAgICAgaWYgKGNiKSBjYi5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNobW9kRml4U3luYyAob3JpZykge1xuICAgIGlmICghb3JpZykgcmV0dXJuIG9yaWdcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwgbW9kZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIG9yaWcuY2FsbChmcywgdGFyZ2V0LCBtb2RlKVxuICAgICAgfSBjYXRjaCAoZXIpIHtcbiAgICAgICAgaWYgKCFjaG93bkVyT2soZXIpKSB0aHJvdyBlclxuICAgICAgfVxuICAgIH1cbiAgfVxuXG5cbiAgZnVuY3Rpb24gY2hvd25GaXggKG9yaWcpIHtcbiAgICBpZiAoIW9yaWcpIHJldHVybiBvcmlnXG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIHVpZCwgZ2lkLCBjYikge1xuICAgICAgcmV0dXJuIG9yaWcuY2FsbChmcywgdGFyZ2V0LCB1aWQsIGdpZCwgZnVuY3Rpb24gKGVyKSB7XG4gICAgICAgIGlmIChjaG93bkVyT2soZXIpKSBlciA9IG51bGxcbiAgICAgICAgaWYgKGNiKSBjYi5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNob3duRml4U3luYyAob3JpZykge1xuICAgIGlmICghb3JpZykgcmV0dXJuIG9yaWdcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwgdWlkLCBnaWQpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBvcmlnLmNhbGwoZnMsIHRhcmdldCwgdWlkLCBnaWQpXG4gICAgICB9IGNhdGNoIChlcikge1xuICAgICAgICBpZiAoIWNob3duRXJPayhlcikpIHRocm93IGVyXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc3RhdEZpeCAob3JpZykge1xuICAgIGlmICghb3JpZykgcmV0dXJuIG9yaWdcbiAgICAvLyBPbGRlciB2ZXJzaW9ucyBvZiBOb2RlIGVycm9uZW91c2x5IHJldHVybmVkIHNpZ25lZCBpbnRlZ2VycyBmb3JcbiAgICAvLyB1aWQgKyBnaWQuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIG9wdGlvbnMsIGNiKSB7XG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY2IgPSBvcHRpb25zXG4gICAgICAgIG9wdGlvbnMgPSBudWxsXG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBjYWxsYmFjayAoZXIsIHN0YXRzKSB7XG4gICAgICAgIGlmIChzdGF0cykge1xuICAgICAgICAgIGlmIChzdGF0cy51aWQgPCAwKSBzdGF0cy51aWQgKz0gMHgxMDAwMDAwMDBcbiAgICAgICAgICBpZiAoc3RhdHMuZ2lkIDwgMCkgc3RhdHMuZ2lkICs9IDB4MTAwMDAwMDAwXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNiKSBjYi5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gICAgICB9XG4gICAgICByZXR1cm4gb3B0aW9ucyA/IG9yaWcuY2FsbChmcywgdGFyZ2V0LCBvcHRpb25zLCBjYWxsYmFjaylcbiAgICAgICAgOiBvcmlnLmNhbGwoZnMsIHRhcmdldCwgY2FsbGJhY2spXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc3RhdEZpeFN5bmMgKG9yaWcpIHtcbiAgICBpZiAoIW9yaWcpIHJldHVybiBvcmlnXG4gICAgLy8gT2xkZXIgdmVyc2lvbnMgb2YgTm9kZSBlcnJvbmVvdXNseSByZXR1cm5lZCBzaWduZWQgaW50ZWdlcnMgZm9yXG4gICAgLy8gdWlkICsgZ2lkLlxuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBvcHRpb25zKSB7XG4gICAgICB2YXIgc3RhdHMgPSBvcHRpb25zID8gb3JpZy5jYWxsKGZzLCB0YXJnZXQsIG9wdGlvbnMpXG4gICAgICAgIDogb3JpZy5jYWxsKGZzLCB0YXJnZXQpXG4gICAgICBpZiAoc3RhdHMpIHtcbiAgICAgICAgaWYgKHN0YXRzLnVpZCA8IDApIHN0YXRzLnVpZCArPSAweDEwMDAwMDAwMFxuICAgICAgICBpZiAoc3RhdHMuZ2lkIDwgMCkgc3RhdHMuZ2lkICs9IDB4MTAwMDAwMDAwXG4gICAgICB9XG4gICAgICByZXR1cm4gc3RhdHM7XG4gICAgfVxuICB9XG5cbiAgLy8gRU5PU1lTIG1lYW5zIHRoYXQgdGhlIGZzIGRvZXNuJ3Qgc3VwcG9ydCB0aGUgb3AuIEp1c3QgaWdub3JlXG4gIC8vIHRoYXQsIGJlY2F1c2UgaXQgZG9lc24ndCBtYXR0ZXIuXG4gIC8vXG4gIC8vIGlmIHRoZXJlJ3Mgbm8gZ2V0dWlkLCBvciBpZiBnZXR1aWQoKSBpcyBzb21ldGhpbmcgb3RoZXJcbiAgLy8gdGhhbiAwLCBhbmQgdGhlIGVycm9yIGlzIEVJTlZBTCBvciBFUEVSTSwgdGhlbiBqdXN0IGlnbm9yZVxuICAvLyBpdC5cbiAgLy9cbiAgLy8gVGhpcyBzcGVjaWZpYyBjYXNlIGlzIGEgc2lsZW50IGZhaWx1cmUgaW4gY3AsIGluc3RhbGwsIHRhcixcbiAgLy8gYW5kIG1vc3Qgb3RoZXIgdW5peCB0b29scyB0aGF0IG1hbmFnZSBwZXJtaXNzaW9ucy5cbiAgLy9cbiAgLy8gV2hlbiBydW5uaW5nIGFzIHJvb3QsIG9yIGlmIG90aGVyIHR5cGVzIG9mIGVycm9ycyBhcmVcbiAgLy8gZW5jb3VudGVyZWQsIHRoZW4gaXQncyBzdHJpY3QuXG4gIGZ1bmN0aW9uIGNob3duRXJPayAoZXIpIHtcbiAgICBpZiAoIWVyKVxuICAgICAgcmV0dXJuIHRydWVcblxuICAgIGlmIChlci5jb2RlID09PSBcIkVOT1NZU1wiKVxuICAgICAgcmV0dXJuIHRydWVcblxuICAgIHZhciBub25yb290ID0gIXByb2Nlc3MuZ2V0dWlkIHx8IHByb2Nlc3MuZ2V0dWlkKCkgIT09IDBcbiAgICBpZiAobm9ucm9vdCkge1xuICAgICAgaWYgKGVyLmNvZGUgPT09IFwiRUlOVkFMXCIgfHwgZXIuY29kZSA9PT0gXCJFUEVSTVwiKVxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/graceful-fs/polyfills.js\n");

/***/ }),

/***/ "./node_modules/inflight/inflight.js":
/*!*******************************************!*\
  !*** ./node_modules/inflight/inflight.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var wrappy = __webpack_require__(/*! wrappy */ \"./node_modules/wrappy/wrappy.js\")\nvar reqs = Object.create(null)\nvar once = __webpack_require__(/*! once */ \"./node_modules/once/once.js\")\n\nmodule.exports = wrappy(inflight)\n\nfunction inflight (key, cb) {\n  if (reqs[key]) {\n    reqs[key].push(cb)\n    return null\n  } else {\n    reqs[key] = [cb]\n    return makeres(key)\n  }\n}\n\nfunction makeres (key) {\n  return once(function RES () {\n    var cbs = reqs[key]\n    var len = cbs.length\n    var args = slice(arguments)\n\n    // XXX It's somewhat ambiguous whether a new callback added in this\n    // pass should be queued for later execution if something in the\n    // list of callbacks throws, or if it should just be discarded.\n    // However, it's such an edge case that it hardly matters, and either\n    // choice is likely as surprising as the other.\n    // As it happens, we do go ahead and schedule it for later execution.\n    try {\n      for (var i = 0; i < len; i++) {\n        cbs[i].apply(null, args)\n      }\n    } finally {\n      if (cbs.length > len) {\n        // added more in the interim.\n        // de-zalgo, just in case, but don't call again.\n        cbs.splice(0, len)\n        process.nextTick(function () {\n          RES.apply(null, args)\n        })\n      } else {\n        delete reqs[key]\n      }\n    }\n  })\n}\n\nfunction slice (args) {\n  var length = args.length\n  var array = []\n\n  for (var i = 0; i < length; i++) array[i] = args[i]\n  return array\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaW5mbGlnaHQvaW5mbGlnaHQuanMuanMiLCJtYXBwaW5ncyI6IkFBQUEsYUFBYSxtQkFBTyxDQUFDLCtDQUFRO0FBQzdCO0FBQ0EsV0FBVyxtQkFBTyxDQUFDLHlDQUFNOztBQUV6Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFNBQVM7QUFDL0I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLFlBQVk7QUFDOUI7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3RvZG8tbGlzdC8uL25vZGVfbW9kdWxlcy9pbmZsaWdodC9pbmZsaWdodC5qcz80NDA2Il0sInNvdXJjZXNDb250ZW50IjpbInZhciB3cmFwcHkgPSByZXF1aXJlKCd3cmFwcHknKVxudmFyIHJlcXMgPSBPYmplY3QuY3JlYXRlKG51bGwpXG52YXIgb25jZSA9IHJlcXVpcmUoJ29uY2UnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IHdyYXBweShpbmZsaWdodClcblxuZnVuY3Rpb24gaW5mbGlnaHQgKGtleSwgY2IpIHtcbiAgaWYgKHJlcXNba2V5XSkge1xuICAgIHJlcXNba2V5XS5wdXNoKGNiKVxuICAgIHJldHVybiBudWxsXG4gIH0gZWxzZSB7XG4gICAgcmVxc1trZXldID0gW2NiXVxuICAgIHJldHVybiBtYWtlcmVzKGtleSlcbiAgfVxufVxuXG5mdW5jdGlvbiBtYWtlcmVzIChrZXkpIHtcbiAgcmV0dXJuIG9uY2UoZnVuY3Rpb24gUkVTICgpIHtcbiAgICB2YXIgY2JzID0gcmVxc1trZXldXG4gICAgdmFyIGxlbiA9IGNicy5sZW5ndGhcbiAgICB2YXIgYXJncyA9IHNsaWNlKGFyZ3VtZW50cylcblxuICAgIC8vIFhYWCBJdCdzIHNvbWV3aGF0IGFtYmlndW91cyB3aGV0aGVyIGEgbmV3IGNhbGxiYWNrIGFkZGVkIGluIHRoaXNcbiAgICAvLyBwYXNzIHNob3VsZCBiZSBxdWV1ZWQgZm9yIGxhdGVyIGV4ZWN1dGlvbiBpZiBzb21ldGhpbmcgaW4gdGhlXG4gICAgLy8gbGlzdCBvZiBjYWxsYmFja3MgdGhyb3dzLCBvciBpZiBpdCBzaG91bGQganVzdCBiZSBkaXNjYXJkZWQuXG4gICAgLy8gSG93ZXZlciwgaXQncyBzdWNoIGFuIGVkZ2UgY2FzZSB0aGF0IGl0IGhhcmRseSBtYXR0ZXJzLCBhbmQgZWl0aGVyXG4gICAgLy8gY2hvaWNlIGlzIGxpa2VseSBhcyBzdXJwcmlzaW5nIGFzIHRoZSBvdGhlci5cbiAgICAvLyBBcyBpdCBoYXBwZW5zLCB3ZSBkbyBnbyBhaGVhZCBhbmQgc2NoZWR1bGUgaXQgZm9yIGxhdGVyIGV4ZWN1dGlvbi5cbiAgICB0cnkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBjYnNbaV0uYXBwbHkobnVsbCwgYXJncylcbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKGNicy5sZW5ndGggPiBsZW4pIHtcbiAgICAgICAgLy8gYWRkZWQgbW9yZSBpbiB0aGUgaW50ZXJpbS5cbiAgICAgICAgLy8gZGUtemFsZ28sIGp1c3QgaW4gY2FzZSwgYnV0IGRvbid0IGNhbGwgYWdhaW4uXG4gICAgICAgIGNicy5zcGxpY2UoMCwgbGVuKVxuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBSRVMuYXBwbHkobnVsbCwgYXJncylcbiAgICAgICAgfSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlbGV0ZSByZXFzW2tleV1cbiAgICAgIH1cbiAgICB9XG4gIH0pXG59XG5cbmZ1bmN0aW9uIHNsaWNlIChhcmdzKSB7XG4gIHZhciBsZW5ndGggPSBhcmdzLmxlbmd0aFxuICB2YXIgYXJyYXkgPSBbXVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIGFycmF5W2ldID0gYXJnc1tpXVxuICByZXR1cm4gYXJyYXlcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/inflight/inflight.js\n");

/***/ }),

/***/ "./node_modules/inherits/inherits_browser.js":
/*!***************************************************!*\
  !*** ./node_modules/inherits/inherits_browser.js ***!
  \***************************************************/
/***/ ((module) => {

eval("if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor\n      ctor.prototype = Object.create(superCtor.prototype, {\n        constructor: {\n          value: ctor,\n          enumerable: false,\n          writable: true,\n          configurable: true\n        }\n      })\n    }\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor\n      var TempCtor = function () {}\n      TempCtor.prototype = superCtor.prototype\n      ctor.prototype = new TempCtor()\n      ctor.prototype.constructor = ctor\n    }\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaW5oZXJpdHMvaW5oZXJpdHNfYnJvd3Nlci5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdG9kby1saXN0Ly4vbm9kZV9tb2R1bGVzL2luaGVyaXRzL2luaGVyaXRzX2Jyb3dzZXIuanM/M2ZiNSJdLCJzb3VyY2VzQ29udGVudCI6WyJpZiAodHlwZW9mIE9iamVjdC5jcmVhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgLy8gaW1wbGVtZW50YXRpb24gZnJvbSBzdGFuZGFyZCBub2RlLmpzICd1dGlsJyBtb2R1bGVcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBpZiAoc3VwZXJDdG9yKSB7XG4gICAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgICAgY3Rvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ3Rvci5wcm90b3R5cGUsIHtcbiAgICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgICB2YWx1ZTogY3RvcixcbiAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG4gIH07XG59IGVsc2Uge1xuICAvLyBvbGQgc2Nob29sIHNoaW0gZm9yIG9sZCBicm93c2Vyc1xuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGlmIChzdXBlckN0b3IpIHtcbiAgICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgICB2YXIgVGVtcEN0b3IgPSBmdW5jdGlvbiAoKSB7fVxuICAgICAgVGVtcEN0b3IucHJvdG90eXBlID0gc3VwZXJDdG9yLnByb3RvdHlwZVxuICAgICAgY3Rvci5wcm90b3R5cGUgPSBuZXcgVGVtcEN0b3IoKVxuICAgICAgY3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjdG9yXG4gICAgfVxuICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/inherits/inherits_browser.js\n");

/***/ }),

/***/ "./node_modules/jsbi/dist/jsbi-umd.js":
/*!********************************************!*\
  !*** ./node_modules/jsbi/dist/jsbi-umd.js ***!
  \********************************************/
/***/ (function(module) {

eval("(function(e,t){ true?module.exports=t():0})(this,function(){\"use strict\";var e=Math.imul,t=Math.clz32;function i(e){\"@babel/helpers - typeof\";return i=\"function\"==typeof Symbol&&\"symbol\"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&\"function\"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?\"symbol\":typeof e},i(e)}function _(e,t){if(!(e instanceof t))throw new TypeError(\"Cannot call a class as a function\")}function n(e,t){for(var _,n=0;n<t.length;n++)_=t[n],_.enumerable=_.enumerable||!1,_.configurable=!0,\"value\"in _&&(_.writable=!0),Object.defineProperty(e,_.key,_)}function l(e,t,i){return t&&n(e.prototype,t),i&&n(e,i),Object.defineProperty(e,\"prototype\",{writable:!1}),e}function g(e,t){if(\"function\"!=typeof t&&null!==t)throw new TypeError(\"Super expression must either be null or a function\");e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),Object.defineProperty(e,\"prototype\",{writable:!1}),t&&u(e,t)}function a(e){return a=Object.setPrototypeOf?Object.getPrototypeOf:function(e){return e.__proto__||Object.getPrototypeOf(e)},a(e)}function u(e,t){return u=Object.setPrototypeOf||function(e,t){return e.__proto__=t,e},u(e,t)}function s(){if(\"undefined\"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if(\"function\"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],function(){})),!0}catch(t){return!1}}function r(){return r=s()?Reflect.construct:function(e,t,i){var _=[null];_.push.apply(_,t);var n=Function.bind.apply(e,_),l=new n;return i&&u(l,i.prototype),l},r.apply(null,arguments)}function d(e){return-1!==Function.toString.call(e).indexOf(\"[native code]\")}function h(e){var t=\"function\"==typeof Map?new Map:void 0;return h=function(e){function i(){return r(e,arguments,a(this).constructor)}if(null===e||!d(e))return e;if(\"function\"!=typeof e)throw new TypeError(\"Super expression must either be null or a function\");if(\"undefined\"!=typeof t){if(t.has(e))return t.get(e);t.set(e,i)}return i.prototype=Object.create(e.prototype,{constructor:{value:i,enumerable:!1,writable:!0,configurable:!0}}),u(i,e)},h(e)}function b(e){if(void 0===e)throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");return e}function m(e,t){if(t&&(\"object\"==typeof t||\"function\"==typeof t))return t;if(void 0!==t)throw new TypeError(\"Derived constructors may only return object or undefined\");return b(e)}function c(e){var t=s();return function(){var i,_=a(e);if(t){var n=a(this).constructor;i=Reflect.construct(_,arguments,n)}else i=_.apply(this,arguments);return m(this,i)}}function v(e,t){return y(e)||f(e,t)||D(e,t)||k()}function y(e){if(Array.isArray(e))return e}function f(e,t){var i=null==e?null:\"undefined\"!=typeof Symbol&&e[Symbol.iterator]||e[\"@@iterator\"];if(null!=i){var _,n,l=[],g=!0,o=!1;try{for(i=i.call(e);!(g=(_=i.next()).done)&&(l.push(_.value),!(t&&l.length===t));g=!0);}catch(e){o=!0,n=e}finally{try{g||null==i[\"return\"]||i[\"return\"]()}finally{if(o)throw n}}return l}}function D(e,t){if(e){if(\"string\"==typeof e)return p(e,t);var i=Object.prototype.toString.call(e).slice(8,-1);return\"Object\"===i&&e.constructor&&(i=e.constructor.name),\"Map\"===i||\"Set\"===i?Array.from(e):\"Arguments\"===i||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i)?p(e,t):void 0}}function p(e,t){(null==t||t>e.length)&&(t=e.length);for(var _=0,n=Array(t);_<t;_++)n[_]=e[_];return n}function k(){throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\")}function B(e,t){var _=\"undefined\"!=typeof Symbol&&e[Symbol.iterator]||e[\"@@iterator\"];if(!_){if(Array.isArray(e)||(_=D(e))||t&&e&&\"number\"==typeof e.length){_&&(e=_);var n=0,l=function(){};return{s:l,n:function(){return n>=e.length?{done:!0}:{done:!1,value:e[n++]}},e:function(t){throw t},f:l}}throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\")}var g,a=!0,u=!1;return{s:function(){_=_.call(e)},n:function(){var e=_.next();return a=e.done,e},e:function(t){u=!0,g=t},f:function(){try{a||null==_.return||_.return()}finally{if(u)throw g}}}}var S=function(e){var t=Math.abs,n=Math.max,o=Math.floor;function a(e,t){var i;if(_(this,a),i=u.call(this,e),i.sign=t,Object.setPrototypeOf(b(i),a.prototype),e>a.__kMaxLength)throw new RangeError(\"Maximum BigInt size exceeded\");return i}g(a,e);var u=c(a);return l(a,[{key:\"toDebugString\",value:function(){var e,t=[\"BigInt[\"],i=B(this);try{for(i.s();!(e=i.n()).done;){var _=e.value;t.push((_?(_>>>0).toString(16):_)+\", \")}}catch(e){i.e(e)}finally{i.f()}return t.push(\"]\"),t.join(\"\")}},{key:\"toString\",value:function(){var e=0<arguments.length&&void 0!==arguments[0]?arguments[0]:10;if(2>e||36<e)throw new RangeError(\"toString() radix argument must be between 2 and 36\");return 0===this.length?\"0\":0==(e&e-1)?a.__toStringBasePowerOfTwo(this,e):a.__toStringGeneric(this,e,!1)}},{key:\"valueOf\",value:function(){throw new Error(\"Convert JSBI instances to native numbers using `toNumber`.\")}},{key:\"__copy\",value:function(){for(var e=new a(this.length,this.sign),t=0;t<this.length;t++)e[t]=this[t];return e}},{key:\"__trim\",value:function(){for(var e=this.length,t=this[e-1];0===t;)e--,t=this[e-1],this.pop();return 0===e&&(this.sign=!1),this}},{key:\"__initializeDigits\",value:function(){for(var e=0;e<this.length;e++)this[e]=0}},{key:\"__clzmsd\",value:function(){return a.__clz30(this.__digit(this.length-1))}},{key:\"__inplaceMultiplyAdd\",value:function(e,t,_){_>this.length&&(_=this.length);for(var n=32767&e,l=e>>>15,g=0,o=t,u=0;u<_;u++){var s=this.__digit(u),r=32767&s,d=s>>>15,h=a.__imul(r,n),b=a.__imul(r,l),m=a.__imul(d,n),c=a.__imul(d,l),v=o+h+g;g=v>>>30,v&=1073741823,v+=((32767&b)<<15)+((32767&m)<<15),g+=v>>>30,o=c+(b>>>15)+(m>>>15),this.__setDigit(u,1073741823&v)}if(0!==g||0!==o)throw new Error(\"implementation bug\")}},{key:\"__inplaceAdd\",value:function(e,t,_){for(var n,l=0,g=0;g<_;g++)n=this.__halfDigit(t+g)+e.__halfDigit(g)+l,l=n>>>15,this.__setHalfDigit(t+g,32767&n);return l}},{key:\"__inplaceSub\",value:function(e,t,_){var n=0;if(1&t){t>>=1;for(var l=this.__digit(t),g=32767&l,o=0;o<_-1>>>1;o++){var a=e.__digit(o),u=(l>>>15)-(32767&a)-n;n=1&u>>>15,this.__setDigit(t+o,(32767&u)<<15|32767&g),l=this.__digit(t+o+1),g=(32767&l)-(a>>>15)-n,n=1&g>>>15}var s=e.__digit(o),r=(l>>>15)-(32767&s)-n;n=1&r>>>15,this.__setDigit(t+o,(32767&r)<<15|32767&g);if(t+o+1>=this.length)throw new RangeError(\"out of bounds\");0==(1&_)&&(l=this.__digit(t+o+1),g=(32767&l)-(s>>>15)-n,n=1&g>>>15,this.__setDigit(t+e.length,1073709056&l|32767&g))}else{t>>=1;for(var d=0;d<e.length-1;d++){var h=this.__digit(t+d),b=e.__digit(d),m=(32767&h)-(32767&b)-n;n=1&m>>>15;var c=(h>>>15)-(b>>>15)-n;n=1&c>>>15,this.__setDigit(t+d,(32767&c)<<15|32767&m)}var v=this.__digit(t+d),y=e.__digit(d),f=(32767&v)-(32767&y)-n;n=1&f>>>15;var D=0;0==(1&_)&&(D=(v>>>15)-(y>>>15)-n,n=1&D>>>15),this.__setDigit(t+d,(32767&D)<<15|32767&f)}return n}},{key:\"__inplaceRightShift\",value:function(e){if(0!==e){for(var t,_=this.__digit(0)>>>e,n=this.length-1,l=0;l<n;l++)t=this.__digit(l+1),this.__setDigit(l,1073741823&t<<30-e|_),_=t>>>e;this.__setDigit(n,_)}}},{key:\"__digit\",value:function(e){return this[e]}},{key:\"__unsignedDigit\",value:function(e){return this[e]>>>0}},{key:\"__setDigit\",value:function(e,t){this[e]=0|t}},{key:\"__setDigitGrow\",value:function(e,t){this[e]=0|t}},{key:\"__halfDigitLength\",value:function(){var e=this.length;return 32767>=this.__unsignedDigit(e-1)?2*e-1:2*e}},{key:\"__halfDigit\",value:function(e){return 32767&this[e>>>1]>>>15*(1&e)}},{key:\"__setHalfDigit\",value:function(e,t){var i=e>>>1,_=this.__digit(i),n=1&e?32767&_|t<<15:1073709056&_|32767&t;this.__setDigit(i,n)}}],[{key:\"BigInt\",value:function(e){var t=Number.isFinite;if(\"number\"==typeof e){if(0===e)return a.__zero();if(a.__isOneDigitInt(e))return 0>e?a.__oneDigit(-e,!0):a.__oneDigit(e,!1);if(!t(e)||o(e)!==e)throw new RangeError(\"The number \"+e+\" cannot be converted to BigInt because it is not an integer\");return a.__fromDouble(e)}if(\"string\"==typeof e){var _=a.__fromString(e);if(null===_)throw new SyntaxError(\"Cannot convert \"+e+\" to a BigInt\");return _}if(\"boolean\"==typeof e)return!0===e?a.__oneDigit(1,!1):a.__zero();if(\"object\"===i(e)){if(e.constructor===a)return e;var n=a.__toPrimitive(e);return a.BigInt(n)}throw new TypeError(\"Cannot convert \"+e+\" to a BigInt\")}},{key:\"toNumber\",value:function(e){var t=e.length;if(0===t)return 0;if(1===t){var i=e.__unsignedDigit(0);return e.sign?-i:i}var _=e.__digit(t-1),n=a.__clz30(_),l=30*t-n;if(1024<l)return e.sign?-Infinity:1/0;var g=l-1,o=_,u=t-1,s=n+3,r=32===s?0:o<<s;r>>>=12;var d=s-12,h=12<=s?0:o<<20+s,b=20+s;for(0<d&&0<u&&(u--,o=e.__digit(u),r|=o>>>30-d,h=o<<d+2,b=d+2);0<b&&0<u;)u--,o=e.__digit(u),h|=30<=b?o<<b-30:o>>>30-b,b-=30;var m=a.__decideRounding(e,b,u,o);if((1===m||0===m&&1==(1&h))&&(h=h+1>>>0,0===h&&(r++,0!=r>>>20&&(r=0,g++,1023<g))))return e.sign?-Infinity:1/0;var c=e.sign?-2147483648:0;return g=g+1023<<20,a.__kBitConversionInts[1]=c|g|r,a.__kBitConversionInts[0]=h,a.__kBitConversionDouble[0]}},{key:\"unaryMinus\",value:function(e){if(0===e.length)return e;var t=e.__copy();return t.sign=!e.sign,t}},{key:\"bitwiseNot\",value:function(e){return e.sign?a.__absoluteSubOne(e).__trim():a.__absoluteAddOne(e,!0)}},{key:\"exponentiate\",value:function(e,t){if(t.sign)throw new RangeError(\"Exponent must be positive\");if(0===t.length)return a.__oneDigit(1,!1);if(0===e.length)return e;if(1===e.length&&1===e.__digit(0))return e.sign&&0==(1&t.__digit(0))?a.unaryMinus(e):e;if(1<t.length)throw new RangeError(\"BigInt too big\");var i=t.__unsignedDigit(0);if(1===i)return e;if(i>=a.__kMaxLengthBits)throw new RangeError(\"BigInt too big\");if(1===e.length&&2===e.__digit(0)){var _=1+(0|i/30),n=e.sign&&0!=(1&i),l=new a(_,n);l.__initializeDigits();var g=1<<i%30;return l.__setDigit(_-1,g),l}var o=null,u=e;for(0!=(1&i)&&(o=e),i>>=1;0!==i;i>>=1)u=a.multiply(u,u),0!=(1&i)&&(null===o?o=u:o=a.multiply(o,u));return o}},{key:\"multiply\",value:function(e,t){if(0===e.length)return e;if(0===t.length)return t;var _=e.length+t.length;30<=e.__clzmsd()+t.__clzmsd()&&_--;var n=new a(_,e.sign!==t.sign);n.__initializeDigits();for(var l=0;l<e.length;l++)a.__multiplyAccumulate(t,e.__digit(l),n,l);return n.__trim()}},{key:\"divide\",value:function(e,t){if(0===t.length)throw new RangeError(\"Division by zero\");if(0>a.__absoluteCompare(e,t))return a.__zero();var i,_=e.sign!==t.sign,n=t.__unsignedDigit(0);if(1===t.length&&32767>=n){if(1===n)return _===e.sign?e:a.unaryMinus(e);i=a.__absoluteDivSmall(e,n,null)}else i=a.__absoluteDivLarge(e,t,!0,!1);return i.sign=_,i.__trim()}},{key:\"remainder\",value:function i(e,t){if(0===t.length)throw new RangeError(\"Division by zero\");if(0>a.__absoluteCompare(e,t))return e;var _=t.__unsignedDigit(0);if(1===t.length&&32767>=_){if(1===_)return a.__zero();var n=a.__absoluteModSmall(e,_);return 0===n?a.__zero():a.__oneDigit(n,e.sign)}var i=a.__absoluteDivLarge(e,t,!1,!0);return i.sign=e.sign,i.__trim()}},{key:\"add\",value:function(e,t){var i=e.sign;return i===t.sign?a.__absoluteAdd(e,t,i):0<=a.__absoluteCompare(e,t)?a.__absoluteSub(e,t,i):a.__absoluteSub(t,e,!i)}},{key:\"subtract\",value:function(e,t){var i=e.sign;return i===t.sign?0<=a.__absoluteCompare(e,t)?a.__absoluteSub(e,t,i):a.__absoluteSub(t,e,!i):a.__absoluteAdd(e,t,i)}},{key:\"leftShift\",value:function(e,t){return 0===t.length||0===e.length?e:t.sign?a.__rightShiftByAbsolute(e,t):a.__leftShiftByAbsolute(e,t)}},{key:\"signedRightShift\",value:function(e,t){return 0===t.length||0===e.length?e:t.sign?a.__leftShiftByAbsolute(e,t):a.__rightShiftByAbsolute(e,t)}},{key:\"unsignedRightShift\",value:function(){throw new TypeError(\"BigInts have no unsigned right shift; use >> instead\")}},{key:\"lessThan\",value:function(e,t){return 0>a.__compareToBigInt(e,t)}},{key:\"lessThanOrEqual\",value:function(e,t){return 0>=a.__compareToBigInt(e,t)}},{key:\"greaterThan\",value:function(e,t){return 0<a.__compareToBigInt(e,t)}},{key:\"greaterThanOrEqual\",value:function(e,t){return 0<=a.__compareToBigInt(e,t)}},{key:\"equal\",value:function(e,t){if(e.sign!==t.sign)return!1;if(e.length!==t.length)return!1;for(var _=0;_<e.length;_++)if(e.__digit(_)!==t.__digit(_))return!1;return!0}},{key:\"notEqual\",value:function(e,t){return!a.equal(e,t)}},{key:\"bitwiseAnd\",value:function(e,t){if(!e.sign&&!t.sign)return a.__absoluteAnd(e,t).__trim();if(e.sign&&t.sign){var i=n(e.length,t.length)+1,_=a.__absoluteSubOne(e,i),l=a.__absoluteSubOne(t);return _=a.__absoluteOr(_,l,_),a.__absoluteAddOne(_,!0,_).__trim()}if(e.sign){var g=[t,e];e=g[0],t=g[1]}return a.__absoluteAndNot(e,a.__absoluteSubOne(t)).__trim()}},{key:\"bitwiseXor\",value:function(e,t){if(!e.sign&&!t.sign)return a.__absoluteXor(e,t).__trim();if(e.sign&&t.sign){var i=n(e.length,t.length),_=a.__absoluteSubOne(e,i),l=a.__absoluteSubOne(t);return a.__absoluteXor(_,l,_).__trim()}var g=n(e.length,t.length)+1;if(e.sign){var o=[t,e];e=o[0],t=o[1]}var u=a.__absoluteSubOne(t,g);return u=a.__absoluteXor(u,e,u),a.__absoluteAddOne(u,!0,u).__trim()}},{key:\"bitwiseOr\",value:function(e,t){var i=n(e.length,t.length);if(!e.sign&&!t.sign)return a.__absoluteOr(e,t).__trim();if(e.sign&&t.sign){var _=a.__absoluteSubOne(e,i),l=a.__absoluteSubOne(t);return _=a.__absoluteAnd(_,l,_),a.__absoluteAddOne(_,!0,_).__trim()}if(e.sign){var g=[t,e];e=g[0],t=g[1]}var o=a.__absoluteSubOne(t,i);return o=a.__absoluteAndNot(o,e,o),a.__absoluteAddOne(o,!0,o).__trim()}},{key:\"asIntN\",value:function(e,t){if(0===t.length)return t;if(e=o(e),0>e)throw new RangeError(\"Invalid value: not (convertible to) a safe integer\");if(0===e)return a.__zero();if(e>=a.__kMaxLengthBits)return t;var _=0|(e+29)/30;if(t.length<_)return t;var l=t.__unsignedDigit(_-1),g=1<<(e-1)%30;if(t.length===_&&l<g)return t;if(!((l&g)===g))return a.__truncateToNBits(e,t);if(!t.sign)return a.__truncateAndSubFromPowerOfTwo(e,t,!0);if(0==(l&g-1)){for(var u=_-2;0<=u;u--)if(0!==t.__digit(u))return a.__truncateAndSubFromPowerOfTwo(e,t,!1);return t.length===_&&l===g?t:a.__truncateToNBits(e,t)}return a.__truncateAndSubFromPowerOfTwo(e,t,!1)}},{key:\"asUintN\",value:function(e,t){if(0===t.length)return t;if(e=o(e),0>e)throw new RangeError(\"Invalid value: not (convertible to) a safe integer\");if(0===e)return a.__zero();if(t.sign){if(e>a.__kMaxLengthBits)throw new RangeError(\"BigInt too big\");return a.__truncateAndSubFromPowerOfTwo(e,t,!1)}if(e>=a.__kMaxLengthBits)return t;var i=0|(e+29)/30;if(t.length<i)return t;var _=e%30;if(t.length==i){if(0===_)return t;var l=t.__digit(i-1);if(0==l>>>_)return t}return a.__truncateToNBits(e,t)}},{key:\"ADD\",value:function(e,t){if(e=a.__toPrimitive(e),t=a.__toPrimitive(t),\"string\"==typeof e)return\"string\"!=typeof t&&(t=t.toString()),e+t;if(\"string\"==typeof t)return e.toString()+t;if(e=a.__toNumeric(e),t=a.__toNumeric(t),a.__isBigInt(e)&&a.__isBigInt(t))return a.add(e,t);if(\"number\"==typeof e&&\"number\"==typeof t)return e+t;throw new TypeError(\"Cannot mix BigInt and other types, use explicit conversions\")}},{key:\"LT\",value:function(e,t){return a.__compare(e,t,0)}},{key:\"LE\",value:function(e,t){return a.__compare(e,t,1)}},{key:\"GT\",value:function(e,t){return a.__compare(e,t,2)}},{key:\"GE\",value:function(e,t){return a.__compare(e,t,3)}},{key:\"EQ\",value:function(e,t){for(;;){if(a.__isBigInt(e))return a.__isBigInt(t)?a.equal(e,t):a.EQ(t,e);if(\"number\"==typeof e){if(a.__isBigInt(t))return a.__equalToNumber(t,e);if(\"object\"!==i(t))return e==t;t=a.__toPrimitive(t)}else if(\"string\"==typeof e){if(a.__isBigInt(t))return e=a.__fromString(e),null!==e&&a.equal(e,t);if(\"object\"!==i(t))return e==t;t=a.__toPrimitive(t)}else if(\"boolean\"==typeof e){if(a.__isBigInt(t))return a.__equalToNumber(t,+e);if(\"object\"!==i(t))return e==t;t=a.__toPrimitive(t)}else if(\"symbol\"===i(e)){if(a.__isBigInt(t))return!1;if(\"object\"!==i(t))return e==t;t=a.__toPrimitive(t)}else if(\"object\"===i(e)){if(\"object\"===i(t)&&t.constructor!==a)return e==t;e=a.__toPrimitive(e)}else return e==t}}},{key:\"NE\",value:function(e,t){return!a.EQ(e,t)}},{key:\"DataViewGetBigInt64\",value:function(e,t){var i=!!(2<arguments.length&&void 0!==arguments[2])&&arguments[2];return a.asIntN(64,a.DataViewGetBigUint64(e,t,i))}},{key:\"DataViewGetBigUint64\",value:function(e,t){var i=!!(2<arguments.length&&void 0!==arguments[2])&&arguments[2],_=i?[4,0]:[0,4],n=v(_,2),g=n[0],o=n[1],l=e.getUint32(t+g,i),u=e.getUint32(t+o,i),s=new a(3,!1);return s.__setDigit(0,1073741823&u),s.__setDigit(1,(268435455&l)<<2|u>>>30),s.__setDigit(2,l>>>28),s.__trim()}},{key:\"DataViewSetBigInt64\",value:function(e,t,i){var _=!!(3<arguments.length&&void 0!==arguments[3])&&arguments[3];a.DataViewSetBigUint64(e,t,i,_)}},{key:\"DataViewSetBigUint64\",value:function(e,t,i){var _=!!(3<arguments.length&&void 0!==arguments[3])&&arguments[3];i=a.asUintN(64,i);var n=0,g=0;if(0<i.length&&(g=i.__digit(0),1<i.length)){var o=i.__digit(1);g|=o<<30,n=o>>>2,2<i.length&&(n|=i.__digit(2)<<28)}var u=_?[4,0]:[0,4],s=v(u,2),r=s[0],d=s[1];e.setUint32(t+r,n,_),e.setUint32(t+d,g,_)}},{key:\"__zero\",value:function(){return new a(0,!1)}},{key:\"__oneDigit\",value:function(e,t){var i=new a(1,t);return i.__setDigit(0,e),i}},{key:\"__decideRounding\",value:function(e,t,i,_){if(0<t)return-1;var n;if(0>t)n=-t-1;else{if(0===i)return-1;i--,_=e.__digit(i),n=29}var l=1<<n;if(0==(_&l))return-1;if(l-=1,0!=(_&l))return 1;for(;0<i;)if(i--,0!==e.__digit(i))return 1;return 0}},{key:\"__fromDouble\",value:function(e){a.__kBitConversionDouble[0]=e;var t,i=2047&a.__kBitConversionInts[1]>>>20,_=i-1023,n=(0|_/30)+1,l=new a(n,0>e),g=1048575&a.__kBitConversionInts[1]|1048576,o=a.__kBitConversionInts[0],u=20,s=_%30,r=0;if(s<u){var d=u-s;r=d+32,t=g>>>d,g=g<<32-d|o>>>d,o<<=32-d}else if(s===u)r=32,t=g,g=o,o=0;else{var h=s-u;r=32-h,t=g<<h|o>>>32-h,g=o<<h,o=0}l.__setDigit(n-1,t);for(var b=n-2;0<=b;b--)0<r?(r-=30,t=g>>>2,g=g<<30|o>>>2,o<<=30):t=0,l.__setDigit(b,t);return l.__trim()}},{key:\"__isWhitespace\",value:function(e){return!!(13>=e&&9<=e)||(159>=e?32==e:131071>=e?160==e||5760==e:196607>=e?(e&=131071,10>=e||40==e||41==e||47==e||95==e||4096==e):65279==e)}},{key:\"__fromString\",value:function(e){var t=1<arguments.length&&void 0!==arguments[1]?arguments[1]:0,i=0,_=e.length,n=0;if(n===_)return a.__zero();for(var l=e.charCodeAt(n);a.__isWhitespace(l);){if(++n===_)return a.__zero();l=e.charCodeAt(n)}if(43===l){if(++n===_)return null;l=e.charCodeAt(n),i=1}else if(45===l){if(++n===_)return null;l=e.charCodeAt(n),i=-1}if(0===t){if(t=10,48===l){if(++n===_)return a.__zero();if(l=e.charCodeAt(n),88===l||120===l){if(t=16,++n===_)return null;l=e.charCodeAt(n)}else if(79===l||111===l){if(t=8,++n===_)return null;l=e.charCodeAt(n)}else if(66===l||98===l){if(t=2,++n===_)return null;l=e.charCodeAt(n)}}}else if(16===t&&48===l){if(++n===_)return a.__zero();if(l=e.charCodeAt(n),88===l||120===l){if(++n===_)return null;l=e.charCodeAt(n)}}if(0!==i&&10!==t)return null;for(;48===l;){if(++n===_)return a.__zero();l=e.charCodeAt(n)}var g=_-n,o=a.__kMaxBitsPerChar[t],u=a.__kBitsPerCharTableMultiplier-1;if(g>1073741824/o)return null;var s=o*g+u>>>a.__kBitsPerCharTableShift,r=new a(0|(s+29)/30,!1),h=10>t?t:10,b=10<t?t-10:0;if(0==(t&t-1)){o>>=a.__kBitsPerCharTableShift;var c=[],v=[],y=!1;do{for(var f,D=0,p=0;;){if(f=void 0,l-48>>>0<h)f=l-48;else if((32|l)-97>>>0<b)f=(32|l)-87;else{y=!0;break}if(p+=o,D=D<<o|f,++n===_){y=!0;break}if(l=e.charCodeAt(n),30<p+o)break}c.push(D),v.push(p)}while(!y);a.__fillFromParts(r,c,v)}else{r.__initializeDigits();var k=!1,B=0;do{for(var S,C=0,I=1;;){if(S=void 0,l-48>>>0<h)S=l-48;else if((32|l)-97>>>0<b)S=(32|l)-87;else{k=!0;break}var A=I*t;if(1073741823<A)break;if(I=A,C=C*t+S,B++,++n===_){k=!0;break}l=e.charCodeAt(n)}u=30*a.__kBitsPerCharTableMultiplier-1;var m=0|(o*B+u>>>a.__kBitsPerCharTableShift)/30;r.__inplaceMultiplyAdd(I,C,m)}while(!k)}if(n!==_){if(!a.__isWhitespace(l))return null;for(n++;n<_;n++)if(l=e.charCodeAt(n),!a.__isWhitespace(l))return null}return r.sign=-1===i,r.__trim()}},{key:\"__fillFromParts\",value:function(e,t,_){for(var n=0,l=0,g=0,o=t.length-1;0<=o;o--){var a=t[o],u=_[o];l|=a<<g,g+=u,30===g?(e.__setDigit(n++,l),g=0,l=0):30<g&&(e.__setDigit(n++,1073741823&l),g-=30,l=a>>>u-g)}if(0!==l){if(n>=e.length)throw new Error(\"implementation bug\");e.__setDigit(n++,l)}for(;n<e.length;n++)e.__setDigit(n,0)}},{key:\"__toStringBasePowerOfTwo\",value:function(e,t){var _=e.length,n=t-1;n=(85&n>>>1)+(85&n),n=(51&n>>>2)+(51&n),n=(15&n>>>4)+(15&n);var l=n,g=t-1,o=e.__digit(_-1),u=a.__clz30(o),s=0|(30*_-u+l-1)/l;if(e.sign&&s++,268435456<s)throw new Error(\"string too long\");for(var r=Array(s),d=s-1,h=0,b=0,m=0;m<_-1;m++){var c=e.__digit(m),v=(h|c<<b)&g;r[d--]=a.__kConversionChars[v];var y=l-b;for(h=c>>>y,b=30-y;b>=l;)r[d--]=a.__kConversionChars[h&g],h>>>=l,b-=l}var f=(h|o<<b)&g;for(r[d--]=a.__kConversionChars[f],h=o>>>l-b;0!==h;)r[d--]=a.__kConversionChars[h&g],h>>>=l;if(e.sign&&(r[d--]=\"-\"),-1!==d)throw new Error(\"implementation bug\");return r.join(\"\")}},{key:\"__toStringGeneric\",value:function(e,t,_){var n=e.length;if(0===n)return\"\";if(1===n){var l=e.__unsignedDigit(0).toString(t);return!1===_&&e.sign&&(l=\"-\"+l),l}var g=30*n-a.__clz30(e.__digit(n-1)),o=a.__kMaxBitsPerChar[t],u=o-1,s=g*a.__kBitsPerCharTableMultiplier;s+=u-1,s=0|s/u;var r,d,h=s+1>>1,b=a.exponentiate(a.__oneDigit(t,!1),a.__oneDigit(h,!1)),m=b.__unsignedDigit(0);if(1===b.length&&32767>=m){r=new a(e.length,!1),r.__initializeDigits();for(var c,v=0,y=2*e.length-1;0<=y;y--)c=v<<15|e.__halfDigit(y),r.__setHalfDigit(y,0|c/m),v=0|c%m;d=v.toString(t)}else{var f=a.__absoluteDivLarge(e,b,!0,!0);r=f.quotient;var D=f.remainder.__trim();d=a.__toStringGeneric(D,t,!0)}r.__trim();for(var p=a.__toStringGeneric(r,t,!0);d.length<h;)d=\"0\"+d;return!1===_&&e.sign&&(p=\"-\"+p),p+d}},{key:\"__unequalSign\",value:function(e){return e?-1:1}},{key:\"__absoluteGreater\",value:function(e){return e?-1:1}},{key:\"__absoluteLess\",value:function(e){return e?1:-1}},{key:\"__compareToBigInt\",value:function(e,t){var i=e.sign;if(i!==t.sign)return a.__unequalSign(i);var _=a.__absoluteCompare(e,t);return 0<_?a.__absoluteGreater(i):0>_?a.__absoluteLess(i):0}},{key:\"__compareToNumber\",value:function(e,i){if(a.__isOneDigitInt(i)){var _=e.sign,n=0>i;if(_!==n)return a.__unequalSign(_);if(0===e.length){if(n)throw new Error(\"implementation bug\");return 0===i?0:-1}if(1<e.length)return a.__absoluteGreater(_);var l=t(i),g=e.__unsignedDigit(0);return g>l?a.__absoluteGreater(_):g<l?a.__absoluteLess(_):0}return a.__compareToDouble(e,i)}},{key:\"__compareToDouble\",value:function(e,t){if(t!==t)return t;if(t===1/0)return-1;if(t===-Infinity)return 1;var i=e.sign;if(i!==0>t)return a.__unequalSign(i);if(0===t)throw new Error(\"implementation bug: should be handled elsewhere\");if(0===e.length)return-1;a.__kBitConversionDouble[0]=t;var _=2047&a.__kBitConversionInts[1]>>>20;if(2047==_)throw new Error(\"implementation bug: handled elsewhere\");var n=_-1023;if(0>n)return a.__absoluteGreater(i);var l=e.length,g=e.__digit(l-1),o=a.__clz30(g),u=30*l-o,s=n+1;if(u<s)return a.__absoluteLess(i);if(u>s)return a.__absoluteGreater(i);var r=1048576|1048575&a.__kBitConversionInts[1],d=a.__kBitConversionInts[0],h=20,b=29-o;if(b!==(0|(u-1)%30))throw new Error(\"implementation bug\");var m,c=0;if(b<h){var v=h-b;c=v+32,m=r>>>v,r=r<<32-v|d>>>v,d<<=32-v}else if(b===h)c=32,m=r,r=d,d=0;else{var y=b-h;c=32-y,m=r<<y|d>>>32-y,r=d<<y,d=0}if(g>>>=0,m>>>=0,g>m)return a.__absoluteGreater(i);if(g<m)return a.__absoluteLess(i);for(var f=l-2;0<=f;f--){0<c?(c-=30,m=r>>>2,r=r<<30|d>>>2,d<<=30):m=0;var D=e.__unsignedDigit(f);if(D>m)return a.__absoluteGreater(i);if(D<m)return a.__absoluteLess(i)}if(0!==r||0!==d){if(0===c)throw new Error(\"implementation bug\");return a.__absoluteLess(i)}return 0}},{key:\"__equalToNumber\",value:function(e,i){return a.__isOneDigitInt(i)?0===i?0===e.length:1===e.length&&e.sign===0>i&&e.__unsignedDigit(0)===t(i):0===a.__compareToDouble(e,i)}},{key:\"__comparisonResultToBool\",value:function(e,t){return 0===t?0>e:1===t?0>=e:2===t?0<e:3===t?0<=e:void 0}},{key:\"__compare\",value:function(e,t,i){if(e=a.__toPrimitive(e),t=a.__toPrimitive(t),\"string\"==typeof e&&\"string\"==typeof t)switch(i){case 0:return e<t;case 1:return e<=t;case 2:return e>t;case 3:return e>=t;}if(a.__isBigInt(e)&&\"string\"==typeof t)return t=a.__fromString(t),null!==t&&a.__comparisonResultToBool(a.__compareToBigInt(e,t),i);if(\"string\"==typeof e&&a.__isBigInt(t))return e=a.__fromString(e),null!==e&&a.__comparisonResultToBool(a.__compareToBigInt(e,t),i);if(e=a.__toNumeric(e),t=a.__toNumeric(t),a.__isBigInt(e)){if(a.__isBigInt(t))return a.__comparisonResultToBool(a.__compareToBigInt(e,t),i);if(\"number\"!=typeof t)throw new Error(\"implementation bug\");return a.__comparisonResultToBool(a.__compareToNumber(e,t),i)}if(\"number\"!=typeof e)throw new Error(\"implementation bug\");if(a.__isBigInt(t))return a.__comparisonResultToBool(a.__compareToNumber(t,e),2^i);if(\"number\"!=typeof t)throw new Error(\"implementation bug\");return 0===i?e<t:1===i?e<=t:2===i?e>t:3===i?e>=t:void 0}},{key:\"__absoluteAdd\",value:function(e,t,_){if(e.length<t.length)return a.__absoluteAdd(t,e,_);if(0===e.length)return e;if(0===t.length)return e.sign===_?e:a.unaryMinus(e);var n=e.length;(0===e.__clzmsd()||t.length===e.length&&0===t.__clzmsd())&&n++;for(var l,g=new a(n,_),o=0,u=0;u<t.length;u++)l=e.__digit(u)+t.__digit(u)+o,o=l>>>30,g.__setDigit(u,1073741823&l);for(;u<e.length;u++){var s=e.__digit(u)+o;o=s>>>30,g.__setDigit(u,1073741823&s)}return u<g.length&&g.__setDigit(u,o),g.__trim()}},{key:\"__absoluteSub\",value:function(e,t,_){if(0===e.length)return e;if(0===t.length)return e.sign===_?e:a.unaryMinus(e);for(var n,l=new a(e.length,_),g=0,o=0;o<t.length;o++)n=e.__digit(o)-t.__digit(o)-g,g=1&n>>>30,l.__setDigit(o,1073741823&n);for(;o<e.length;o++){var u=e.__digit(o)-g;g=1&u>>>30,l.__setDigit(o,1073741823&u)}return l.__trim()}},{key:\"__absoluteAddOne\",value:function(e,t){var _=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null,n=e.length;null===_?_=new a(n,t):_.sign=t;for(var l,g=1,o=0;o<n;o++)l=e.__digit(o)+g,g=l>>>30,_.__setDigit(o,1073741823&l);return 0!==g&&_.__setDigitGrow(n,1),_}},{key:\"__absoluteSubOne\",value:function(e,t){var _=e.length;t=t||_;for(var n,l=new a(t,!1),g=1,o=0;o<_;o++)n=e.__digit(o)-g,g=1&n>>>30,l.__setDigit(o,1073741823&n);if(0!==g)throw new Error(\"implementation bug\");for(var u=_;u<t;u++)l.__setDigit(u,0);return l}},{key:\"__absoluteAnd\",value:function(e,t){var _=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null,n=e.length,l=t.length,g=l;if(n<l){g=n;var o=e,u=n;e=t,n=l,t=o,l=u}var s=g;null===_?_=new a(s,!1):s=_.length;for(var r=0;r<g;r++)_.__setDigit(r,e.__digit(r)&t.__digit(r));for(;r<s;r++)_.__setDigit(r,0);return _}},{key:\"__absoluteAndNot\",value:function(e,t){var _=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null,n=e.length,l=t.length,g=l;n<l&&(g=n);var o=n;null===_?_=new a(o,!1):o=_.length;for(var u=0;u<g;u++)_.__setDigit(u,e.__digit(u)&~t.__digit(u));for(;u<n;u++)_.__setDigit(u,e.__digit(u));for(;u<o;u++)_.__setDigit(u,0);return _}},{key:\"__absoluteOr\",value:function(e,t){var _=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null,n=e.length,l=t.length,g=l;if(n<l){g=n;var o=e,u=n;e=t,n=l,t=o,l=u}var s=n;null===_?_=new a(s,!1):s=_.length;for(var r=0;r<g;r++)_.__setDigit(r,e.__digit(r)|t.__digit(r));for(;r<n;r++)_.__setDigit(r,e.__digit(r));for(;r<s;r++)_.__setDigit(r,0);return _}},{key:\"__absoluteXor\",value:function(e,t){var _=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null,n=e.length,l=t.length,g=l;if(n<l){g=n;var o=e,u=n;e=t,n=l,t=o,l=u}var s=n;null===_?_=new a(s,!1):s=_.length;for(var r=0;r<g;r++)_.__setDigit(r,e.__digit(r)^t.__digit(r));for(;r<n;r++)_.__setDigit(r,e.__digit(r));for(;r<s;r++)_.__setDigit(r,0);return _}},{key:\"__absoluteCompare\",value:function(e,t){var _=e.length-t.length;if(0!=_)return _;for(var n=e.length-1;0<=n&&e.__digit(n)===t.__digit(n);)n--;return 0>n?0:e.__unsignedDigit(n)>t.__unsignedDigit(n)?1:-1}},{key:\"__multiplyAccumulate\",value:function(e,t,_,n){if(0!==t){for(var l=32767&t,g=t>>>15,o=0,u=0,s=0;s<e.length;s++,n++){var r=_.__digit(n),d=e.__digit(s),h=32767&d,b=d>>>15,m=a.__imul(h,l),c=a.__imul(h,g),v=a.__imul(b,l),y=a.__imul(b,g);r+=u+m+o,o=r>>>30,r&=1073741823,r+=((32767&c)<<15)+((32767&v)<<15),o+=r>>>30,u=y+(c>>>15)+(v>>>15),_.__setDigit(n,1073741823&r)}for(;0!==o||0!==u;n++){var f=_.__digit(n);f+=o+u,u=0,o=f>>>30,_.__setDigit(n,1073741823&f)}}}},{key:\"__internalMultiplyAdd\",value:function(e,t,_,l,g){for(var o=_,u=0,s=0;s<l;s++){var d=e.__digit(s),h=a.__imul(32767&d,t),b=a.__imul(d>>>15,t),m=h+((32767&b)<<15)+u+o;o=m>>>30,u=b>>>15,g.__setDigit(s,1073741823&m)}if(g.length>l)for(g.__setDigit(l++,o+u);l<g.length;)g.__setDigit(l++,0);else if(0!==o+u)throw new Error(\"implementation bug\")}},{key:\"__absoluteDivSmall\",value:function(e,t){var _=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;null===_&&(_=new a(e.length,!1));for(var n=0,l=2*e.length-1;0<=l;l-=2){var g=(n<<15|e.__halfDigit(l))>>>0,o=0|g/t;n=0|g%t,g=(n<<15|e.__halfDigit(l-1))>>>0;var u=0|g/t;n=0|g%t,_.__setDigit(l>>>1,o<<15|u)}return _}},{key:\"__absoluteModSmall\",value:function(e,t){for(var _,n=0,l=2*e.length-1;0<=l;l--)_=(n<<15|e.__halfDigit(l))>>>0,n=0|_%t;return n}},{key:\"__absoluteDivLarge\",value:function(e,t,i,_){var l=t.__halfDigitLength(),n=t.length,g=e.__halfDigitLength()-l,o=null;i&&(o=new a(g+2>>>1,!1),o.__initializeDigits());var s=new a(l+2>>>1,!1);s.__initializeDigits();var r=a.__clz15(t.__halfDigit(l-1));0<r&&(t=a.__specialLeftShift(t,r,0));for(var d=a.__specialLeftShift(e,r,1),u=t.__halfDigit(l-1),h=0,b=g;0<=b;b--){var m=32767,v=d.__halfDigit(b+l);if(v!==u){var y=(v<<15|d.__halfDigit(b+l-1))>>>0;m=0|y/u;for(var f=0|y%u,D=t.__halfDigit(l-2),p=d.__halfDigit(b+l-2);a.__imul(m,D)>>>0>(f<<16|p)>>>0&&(m--,f+=u,!(32767<f)););}a.__internalMultiplyAdd(t,m,0,n,s);var k=d.__inplaceSub(s,b,l+1);0!==k&&(k=d.__inplaceAdd(t,b,l),d.__setHalfDigit(b+l,32767&d.__halfDigit(b+l)+k),m--),i&&(1&b?h=m<<15:o.__setDigit(b>>>1,h|m))}if(_)return d.__inplaceRightShift(r),i?{quotient:o,remainder:d}:d;if(i)return o;throw new Error(\"unreachable\")}},{key:\"__clz15\",value:function(e){return a.__clz30(e)-15}},{key:\"__specialLeftShift\",value:function(e,t,_){var l=e.length,n=new a(l+_,!1);if(0===t){for(var g=0;g<l;g++)n.__setDigit(g,e.__digit(g));return 0<_&&n.__setDigit(l,0),n}for(var o,u=0,s=0;s<l;s++)o=e.__digit(s),n.__setDigit(s,1073741823&o<<t|u),u=o>>>30-t;return 0<_&&n.__setDigit(l,u),n}},{key:\"__leftShiftByAbsolute\",value:function(e,t){var _=a.__toShiftAmount(t);if(0>_)throw new RangeError(\"BigInt too big\");var n=0|_/30,l=_%30,g=e.length,o=0!==l&&0!=e.__digit(g-1)>>>30-l,u=g+n+(o?1:0),s=new a(u,e.sign);if(0===l){for(var r=0;r<n;r++)s.__setDigit(r,0);for(;r<u;r++)s.__setDigit(r,e.__digit(r-n))}else{for(var h=0,b=0;b<n;b++)s.__setDigit(b,0);for(var m,c=0;c<g;c++)m=e.__digit(c),s.__setDigit(c+n,1073741823&m<<l|h),h=m>>>30-l;if(o)s.__setDigit(g+n,h);else if(0!==h)throw new Error(\"implementation bug\")}return s.__trim()}},{key:\"__rightShiftByAbsolute\",value:function(e,t){var _=e.length,n=e.sign,l=a.__toShiftAmount(t);if(0>l)return a.__rightShiftByMaximum(n);var g=0|l/30,o=l%30,u=_-g;if(0>=u)return a.__rightShiftByMaximum(n);var s=!1;if(n){if(0!=(e.__digit(g)&(1<<o)-1))s=!0;else for(var r=0;r<g;r++)if(0!==e.__digit(r)){s=!0;break}}if(s&&0===o){var h=e.__digit(_-1);0==~h&&u++}var b=new a(u,n);if(0===o){b.__setDigit(u-1,0);for(var m=g;m<_;m++)b.__setDigit(m-g,e.__digit(m))}else{for(var c,v=e.__digit(g)>>>o,y=_-g-1,f=0;f<y;f++)c=e.__digit(f+g+1),b.__setDigit(f,1073741823&c<<30-o|v),v=c>>>o;b.__setDigit(y,v)}return s&&(b=a.__absoluteAddOne(b,!0,b)),b.__trim()}},{key:\"__rightShiftByMaximum\",value:function(e){return e?a.__oneDigit(1,!0):a.__zero()}},{key:\"__toShiftAmount\",value:function(e){if(1<e.length)return-1;var t=e.__unsignedDigit(0);return t>a.__kMaxLengthBits?-1:t}},{key:\"__toPrimitive\",value:function(e){var t=1<arguments.length&&void 0!==arguments[1]?arguments[1]:\"default\";if(\"object\"!==i(e))return e;if(e.constructor===a)return e;if(\"undefined\"!=typeof Symbol&&\"symbol\"===i(Symbol.toPrimitive)){var _=e[Symbol.toPrimitive];if(_){var n=_(t);if(\"object\"!==i(n))return n;throw new TypeError(\"Cannot convert object to primitive value\")}}var l=e.valueOf;if(l){var g=l.call(e);if(\"object\"!==i(g))return g}var o=e.toString;if(o){var u=o.call(e);if(\"object\"!==i(u))return u}throw new TypeError(\"Cannot convert object to primitive value\")}},{key:\"__toNumeric\",value:function(e){return a.__isBigInt(e)?e:+e}},{key:\"__isBigInt\",value:function(e){return\"object\"===i(e)&&null!==e&&e.constructor===a}},{key:\"__truncateToNBits\",value:function(e,t){for(var _=0|(e+29)/30,n=new a(_,t.sign),l=_-1,g=0;g<l;g++)n.__setDigit(g,t.__digit(g));var o=t.__digit(l);if(0!=e%30){var u=32-e%30;o=o<<u>>>u}return n.__setDigit(l,o),n.__trim()}},{key:\"__truncateAndSubFromPowerOfTwo\",value:function(e,t,_){for(var n=Math.min,l,g=0|(e+29)/30,o=new a(g,_),u=0,s=g-1,d=0,h=n(s,t.length);u<h;u++)l=0-t.__digit(u)-d,d=1&l>>>30,o.__setDigit(u,1073741823&l);for(;u<s;u++)o.__setDigit(u,0|1073741823&-d);var b,m=s<t.length?t.__digit(s):0,c=e%30;if(0===c)b=0-m-d,b&=1073741823;else{var v=32-c;m=m<<v>>>v;var y=1<<32-v;b=y-m-d,b&=y-1}return o.__setDigit(s,b),o.__trim()}},{key:\"__digitPow\",value:function(e,t){for(var i=1;0<t;)1&t&&(i*=e),t>>>=1,e*=e;return i}},{key:\"__isOneDigitInt\",value:function(e){return(1073741823&e)===e}}]),a}(h(Array));return S.__kMaxLength=33554432,S.__kMaxLengthBits=S.__kMaxLength<<5,S.__kMaxBitsPerChar=[0,0,32,51,64,75,83,90,96,102,107,111,115,119,122,126,128,131,134,136,139,141,143,145,147,149,151,153,154,156,158,159,160,162,163,165,166],S.__kBitsPerCharTableShift=5,S.__kBitsPerCharTableMultiplier=1<<S.__kBitsPerCharTableShift,S.__kConversionChars=[\"0\",\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\",\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"m\",\"n\",\"o\",\"p\",\"q\",\"r\",\"s\",\"t\",\"u\",\"v\",\"w\",\"x\",\"y\",\"z\"],S.__kBitConversionBuffer=new ArrayBuffer(8),S.__kBitConversionDouble=new Float64Array(S.__kBitConversionBuffer),S.__kBitConversionInts=new Int32Array(S.__kBitConversionBuffer),S.__clz30=t?function(e){return t(e)-2}:function(e){var t=Math.LN2,i=Math.log;return 0===e?30:0|29-(0|i(e>>>0)/t)},S.__imul=e||function(e,t){return 0|e*t},S});\n//# sourceMappingURL=jsbi-umd.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvanNiaS9kaXN0L2pzYmktdW1kLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBLGVBQWUsS0FBb0Qsb0JBQW9CLENBQXNFLENBQUMsa0JBQWtCLGFBQWEsNkJBQTZCLGNBQWMsMEJBQTBCLGlGQUFpRixnQkFBZ0IsYUFBYSxvR0FBb0csTUFBTSxnQkFBZ0IsOEVBQThFLGdCQUFnQixjQUFjLFdBQVcseUhBQXlILGtCQUFrQiwwRUFBMEUsWUFBWSxJQUFJLGdCQUFnQiw0R0FBNEcsMENBQTBDLGFBQWEscUNBQXFDLHVDQUF1QyxZQUFZLFlBQVksY0FBYyxpRUFBaUUsNkNBQTZDLE1BQU0sZ0JBQWdCLDhDQUE4Qyx1QkFBdUIsUUFBUSxhQUFhLDREQUE0RCxtQ0FBbUMscUNBQXFDLElBQUksK0VBQStFLE1BQU0sU0FBUyxVQUFVLGFBQWEsK0NBQStDLGFBQWEsa0JBQWtCLHVDQUF1Qyw2QkFBNkIseUJBQXlCLGNBQWMsOERBQThELGNBQWMsNENBQTRDLHFCQUFxQixhQUFhLDBDQUEwQyw0QkFBNEIsa0dBQWtHLDBCQUEwQiw0QkFBNEIsV0FBVyw4Q0FBOEMsYUFBYSxtREFBbUQsU0FBUyxNQUFNLGNBQWMsb0dBQW9HLFNBQVMsZ0JBQWdCLDBEQUEwRCw4RkFBOEYsWUFBWSxjQUFjLFVBQVUsa0JBQWtCLGFBQWEsTUFBTSwwQkFBMEIsbUNBQW1DLCtCQUErQixrQkFBa0IsZ0JBQWdCLGlDQUFpQyxjQUFjLDZCQUE2QixnQkFBZ0IsbUZBQW1GLFlBQVksdUJBQXVCLElBQUksZ0JBQWdCLDZEQUE2RCxPQUFPLFNBQVMsU0FBUyxRQUFRLElBQUksb0NBQW9DLFFBQVEsY0FBYyxVQUFVLGdCQUFnQixNQUFNLG9DQUFvQyxvREFBb0QsZ0xBQWdMLGdCQUFnQixvQ0FBb0MsdUJBQXVCLElBQUksY0FBYyxTQUFTLGFBQWEsaUtBQWlLLGdCQUFnQixzRUFBc0UsT0FBTyxnRUFBZ0UsU0FBUyx1QkFBdUIsT0FBTyxpQkFBaUIsb0JBQW9CLFFBQVEsRUFBRSxz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QUFLLElBQUksb0NBQW9DLHlDQUF5QywrQkFBK0IsS0FBSyxXQUFXLFdBQVcsY0FBYyxlQUFlLHFDQUFxQyxFQUFFLHFDQUFxQyxZQUFZLElBQUkseUJBQXlCLFVBQVUsRUFBRSx3Q0FBd0MsMEJBQTBCLEtBQUssV0FBVyw2cUJBQTZxQixjQUFjLGFBQWEsMEJBQTBCLG9DQUFvQywyQkFBMkIsYUFBYSxHQUFHO0FBQzdpakMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90b2RvLWxpc3QvLi9ub2RlX21vZHVsZXMvanNiaS9kaXN0L2pzYmktdW1kLmpzP2Y1NTciXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKGUsdCl7XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHMmJlwidW5kZWZpbmVkXCIhPXR5cGVvZiBtb2R1bGU/bW9kdWxlLmV4cG9ydHM9dCgpOlwiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUodCk6KGU9ZXx8c2VsZixlLkpTQkk9dCgpKX0pKHRoaXMsZnVuY3Rpb24oKXtcInVzZSBzdHJpY3RcIjt2YXIgZT1NYXRoLmltdWwsdD1NYXRoLmNsejMyO2Z1bmN0aW9uIGkoZSl7XCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiO3JldHVybiBpPVwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmXCJzeW1ib2xcIj09dHlwZW9mIFN5bWJvbC5pdGVyYXRvcj9mdW5jdGlvbihlKXtyZXR1cm4gdHlwZW9mIGV9OmZ1bmN0aW9uKGUpe3JldHVybiBlJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJmUuY29uc3RydWN0b3I9PT1TeW1ib2wmJmUhPT1TeW1ib2wucHJvdG90eXBlP1wic3ltYm9sXCI6dHlwZW9mIGV9LGkoZSl9ZnVuY3Rpb24gXyhlLHQpe2lmKCEoZSBpbnN0YW5jZW9mIHQpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIil9ZnVuY3Rpb24gbihlLHQpe2Zvcih2YXIgXyxuPTA7bjx0Lmxlbmd0aDtuKyspXz10W25dLF8uZW51bWVyYWJsZT1fLmVudW1lcmFibGV8fCExLF8uY29uZmlndXJhYmxlPSEwLFwidmFsdWVcImluIF8mJihfLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxfLmtleSxfKX1mdW5jdGlvbiBsKGUsdCxpKXtyZXR1cm4gdCYmbihlLnByb3RvdHlwZSx0KSxpJiZuKGUsaSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJwcm90b3R5cGVcIix7d3JpdGFibGU6ITF9KSxlfWZ1bmN0aW9uIGcoZSx0KXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiB0JiZudWxsIT09dCl0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7ZS5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZSh0JiZ0LnByb3RvdHlwZSx7Y29uc3RydWN0b3I6e3ZhbHVlOmUsd3JpdGFibGU6ITAsY29uZmlndXJhYmxlOiEwfX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwicHJvdG90eXBlXCIse3dyaXRhYmxlOiExfSksdCYmdShlLHQpfWZ1bmN0aW9uIGEoZSl7cmV0dXJuIGE9T2JqZWN0LnNldFByb3RvdHlwZU9mP09iamVjdC5nZXRQcm90b3R5cGVPZjpmdW5jdGlvbihlKXtyZXR1cm4gZS5fX3Byb3RvX198fE9iamVjdC5nZXRQcm90b3R5cGVPZihlKX0sYShlKX1mdW5jdGlvbiB1KGUsdCl7cmV0dXJuIHU9T2JqZWN0LnNldFByb3RvdHlwZU9mfHxmdW5jdGlvbihlLHQpe3JldHVybiBlLl9fcHJvdG9fXz10LGV9LHUoZSx0KX1mdW5jdGlvbiBzKCl7aWYoXCJ1bmRlZmluZWRcIj09dHlwZW9mIFJlZmxlY3R8fCFSZWZsZWN0LmNvbnN0cnVjdClyZXR1cm4hMTtpZihSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKXJldHVybiExO2lmKFwiZnVuY3Rpb25cIj09dHlwZW9mIFByb3h5KXJldHVybiEwO3RyeXtyZXR1cm4gQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sW10sZnVuY3Rpb24oKXt9KSksITB9Y2F0Y2godCl7cmV0dXJuITF9fWZ1bmN0aW9uIHIoKXtyZXR1cm4gcj1zKCk/UmVmbGVjdC5jb25zdHJ1Y3Q6ZnVuY3Rpb24oZSx0LGkpe3ZhciBfPVtudWxsXTtfLnB1c2guYXBwbHkoXyx0KTt2YXIgbj1GdW5jdGlvbi5iaW5kLmFwcGx5KGUsXyksbD1uZXcgbjtyZXR1cm4gaSYmdShsLGkucHJvdG90eXBlKSxsfSxyLmFwcGx5KG51bGwsYXJndW1lbnRzKX1mdW5jdGlvbiBkKGUpe3JldHVybi0xIT09RnVuY3Rpb24udG9TdHJpbmcuY2FsbChlKS5pbmRleE9mKFwiW25hdGl2ZSBjb2RlXVwiKX1mdW5jdGlvbiBoKGUpe3ZhciB0PVwiZnVuY3Rpb25cIj09dHlwZW9mIE1hcD9uZXcgTWFwOnZvaWQgMDtyZXR1cm4gaD1mdW5jdGlvbihlKXtmdW5jdGlvbiBpKCl7cmV0dXJuIHIoZSxhcmd1bWVudHMsYSh0aGlzKS5jb25zdHJ1Y3Rvcil9aWYobnVsbD09PWV8fCFkKGUpKXJldHVybiBlO2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIGUpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO2lmKFwidW5kZWZpbmVkXCIhPXR5cGVvZiB0KXtpZih0LmhhcyhlKSlyZXR1cm4gdC5nZXQoZSk7dC5zZXQoZSxpKX1yZXR1cm4gaS5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShlLnByb3RvdHlwZSx7Y29uc3RydWN0b3I6e3ZhbHVlOmksZW51bWVyYWJsZTohMSx3cml0YWJsZTohMCxjb25maWd1cmFibGU6ITB9fSksdShpLGUpfSxoKGUpfWZ1bmN0aW9uIGIoZSl7aWYodm9pZCAwPT09ZSl0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7cmV0dXJuIGV9ZnVuY3Rpb24gbShlLHQpe2lmKHQmJihcIm9iamVjdFwiPT10eXBlb2YgdHx8XCJmdW5jdGlvblwiPT10eXBlb2YgdCkpcmV0dXJuIHQ7aWYodm9pZCAwIT09dCl0aHJvdyBuZXcgVHlwZUVycm9yKFwiRGVyaXZlZCBjb25zdHJ1Y3RvcnMgbWF5IG9ubHkgcmV0dXJuIG9iamVjdCBvciB1bmRlZmluZWRcIik7cmV0dXJuIGIoZSl9ZnVuY3Rpb24gYyhlKXt2YXIgdD1zKCk7cmV0dXJuIGZ1bmN0aW9uKCl7dmFyIGksXz1hKGUpO2lmKHQpe3ZhciBuPWEodGhpcykuY29uc3RydWN0b3I7aT1SZWZsZWN0LmNvbnN0cnVjdChfLGFyZ3VtZW50cyxuKX1lbHNlIGk9Xy5hcHBseSh0aGlzLGFyZ3VtZW50cyk7cmV0dXJuIG0odGhpcyxpKX19ZnVuY3Rpb24gdihlLHQpe3JldHVybiB5KGUpfHxmKGUsdCl8fEQoZSx0KXx8aygpfWZ1bmN0aW9uIHkoZSl7aWYoQXJyYXkuaXNBcnJheShlKSlyZXR1cm4gZX1mdW5jdGlvbiBmKGUsdCl7dmFyIGk9bnVsbD09ZT9udWxsOlwidW5kZWZpbmVkXCIhPXR5cGVvZiBTeW1ib2wmJmVbU3ltYm9sLml0ZXJhdG9yXXx8ZVtcIkBAaXRlcmF0b3JcIl07aWYobnVsbCE9aSl7dmFyIF8sbixsPVtdLGc9ITAsbz0hMTt0cnl7Zm9yKGk9aS5jYWxsKGUpOyEoZz0oXz1pLm5leHQoKSkuZG9uZSkmJihsLnB1c2goXy52YWx1ZSksISh0JiZsLmxlbmd0aD09PXQpKTtnPSEwKTt9Y2F0Y2goZSl7bz0hMCxuPWV9ZmluYWxseXt0cnl7Z3x8bnVsbD09aVtcInJldHVyblwiXXx8aVtcInJldHVyblwiXSgpfWZpbmFsbHl7aWYobyl0aHJvdyBufX1yZXR1cm4gbH19ZnVuY3Rpb24gRChlLHQpe2lmKGUpe2lmKFwic3RyaW5nXCI9PXR5cGVvZiBlKXJldHVybiBwKGUsdCk7dmFyIGk9T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGUpLnNsaWNlKDgsLTEpO3JldHVyblwiT2JqZWN0XCI9PT1pJiZlLmNvbnN0cnVjdG9yJiYoaT1lLmNvbnN0cnVjdG9yLm5hbWUpLFwiTWFwXCI9PT1pfHxcIlNldFwiPT09aT9BcnJheS5mcm9tKGUpOlwiQXJndW1lbnRzXCI9PT1pfHwvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChpKT9wKGUsdCk6dm9pZCAwfX1mdW5jdGlvbiBwKGUsdCl7KG51bGw9PXR8fHQ+ZS5sZW5ndGgpJiYodD1lLmxlbmd0aCk7Zm9yKHZhciBfPTAsbj1BcnJheSh0KTtfPHQ7XysrKW5bX109ZVtfXTtyZXR1cm4gbn1mdW5jdGlvbiBrKCl7dGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKX1mdW5jdGlvbiBCKGUsdCl7dmFyIF89XCJ1bmRlZmluZWRcIiE9dHlwZW9mIFN5bWJvbCYmZVtTeW1ib2wuaXRlcmF0b3JdfHxlW1wiQEBpdGVyYXRvclwiXTtpZighXyl7aWYoQXJyYXkuaXNBcnJheShlKXx8KF89RChlKSl8fHQmJmUmJlwibnVtYmVyXCI9PXR5cGVvZiBlLmxlbmd0aCl7XyYmKGU9Xyk7dmFyIG49MCxsPWZ1bmN0aW9uKCl7fTtyZXR1cm57czpsLG46ZnVuY3Rpb24oKXtyZXR1cm4gbj49ZS5sZW5ndGg/e2RvbmU6ITB9Ontkb25lOiExLHZhbHVlOmVbbisrXX19LGU6ZnVuY3Rpb24odCl7dGhyb3cgdH0sZjpsfX10aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIil9dmFyIGcsYT0hMCx1PSExO3JldHVybntzOmZ1bmN0aW9uKCl7Xz1fLmNhbGwoZSl9LG46ZnVuY3Rpb24oKXt2YXIgZT1fLm5leHQoKTtyZXR1cm4gYT1lLmRvbmUsZX0sZTpmdW5jdGlvbih0KXt1PSEwLGc9dH0sZjpmdW5jdGlvbigpe3RyeXthfHxudWxsPT1fLnJldHVybnx8Xy5yZXR1cm4oKX1maW5hbGx5e2lmKHUpdGhyb3cgZ319fX12YXIgUz1mdW5jdGlvbihlKXt2YXIgdD1NYXRoLmFicyxuPU1hdGgubWF4LG89TWF0aC5mbG9vcjtmdW5jdGlvbiBhKGUsdCl7dmFyIGk7aWYoXyh0aGlzLGEpLGk9dS5jYWxsKHRoaXMsZSksaS5zaWduPXQsT2JqZWN0LnNldFByb3RvdHlwZU9mKGIoaSksYS5wcm90b3R5cGUpLGU+YS5fX2tNYXhMZW5ndGgpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJNYXhpbXVtIEJpZ0ludCBzaXplIGV4Y2VlZGVkXCIpO3JldHVybiBpfWcoYSxlKTt2YXIgdT1jKGEpO3JldHVybiBsKGEsW3trZXk6XCJ0b0RlYnVnU3RyaW5nXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZSx0PVtcIkJpZ0ludFtcIl0saT1CKHRoaXMpO3RyeXtmb3IoaS5zKCk7IShlPWkubigpKS5kb25lOyl7dmFyIF89ZS52YWx1ZTt0LnB1c2goKF8/KF8+Pj4wKS50b1N0cmluZygxNik6XykrXCIsIFwiKX19Y2F0Y2goZSl7aS5lKGUpfWZpbmFsbHl7aS5mKCl9cmV0dXJuIHQucHVzaChcIl1cIiksdC5qb2luKFwiXCIpfX0se2tleTpcInRvU3RyaW5nXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT0wPGFyZ3VtZW50cy5sZW5ndGgmJnZvaWQgMCE9PWFyZ3VtZW50c1swXT9hcmd1bWVudHNbMF06MTA7aWYoMj5lfHwzNjxlKXRocm93IG5ldyBSYW5nZUVycm9yKFwidG9TdHJpbmcoKSByYWRpeCBhcmd1bWVudCBtdXN0IGJlIGJldHdlZW4gMiBhbmQgMzZcIik7cmV0dXJuIDA9PT10aGlzLmxlbmd0aD9cIjBcIjowPT0oZSZlLTEpP2EuX190b1N0cmluZ0Jhc2VQb3dlck9mVHdvKHRoaXMsZSk6YS5fX3RvU3RyaW5nR2VuZXJpYyh0aGlzLGUsITEpfX0se2tleTpcInZhbHVlT2ZcIix2YWx1ZTpmdW5jdGlvbigpe3Rocm93IG5ldyBFcnJvcihcIkNvbnZlcnQgSlNCSSBpbnN0YW5jZXMgdG8gbmF0aXZlIG51bWJlcnMgdXNpbmcgYHRvTnVtYmVyYC5cIil9fSx7a2V5OlwiX19jb3B5XCIsdmFsdWU6ZnVuY3Rpb24oKXtmb3IodmFyIGU9bmV3IGEodGhpcy5sZW5ndGgsdGhpcy5zaWduKSx0PTA7dDx0aGlzLmxlbmd0aDt0KyspZVt0XT10aGlzW3RdO3JldHVybiBlfX0se2tleTpcIl9fdHJpbVwiLHZhbHVlOmZ1bmN0aW9uKCl7Zm9yKHZhciBlPXRoaXMubGVuZ3RoLHQ9dGhpc1tlLTFdOzA9PT10OyllLS0sdD10aGlzW2UtMV0sdGhpcy5wb3AoKTtyZXR1cm4gMD09PWUmJih0aGlzLnNpZ249ITEpLHRoaXN9fSx7a2V5OlwiX19pbml0aWFsaXplRGlnaXRzXCIsdmFsdWU6ZnVuY3Rpb24oKXtmb3IodmFyIGU9MDtlPHRoaXMubGVuZ3RoO2UrKyl0aGlzW2VdPTB9fSx7a2V5OlwiX19jbHptc2RcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiBhLl9fY2x6MzAodGhpcy5fX2RpZ2l0KHRoaXMubGVuZ3RoLTEpKX19LHtrZXk6XCJfX2lucGxhY2VNdWx0aXBseUFkZFwiLHZhbHVlOmZ1bmN0aW9uKGUsdCxfKXtfPnRoaXMubGVuZ3RoJiYoXz10aGlzLmxlbmd0aCk7Zm9yKHZhciBuPTMyNzY3JmUsbD1lPj4+MTUsZz0wLG89dCx1PTA7dTxfO3UrKyl7dmFyIHM9dGhpcy5fX2RpZ2l0KHUpLHI9MzI3NjcmcyxkPXM+Pj4xNSxoPWEuX19pbXVsKHIsbiksYj1hLl9faW11bChyLGwpLG09YS5fX2ltdWwoZCxuKSxjPWEuX19pbXVsKGQsbCksdj1vK2grZztnPXY+Pj4zMCx2Jj0xMDczNzQxODIzLHYrPSgoMzI3NjcmYik8PDE1KSsoKDMyNzY3Jm0pPDwxNSksZys9dj4+PjMwLG89YysoYj4+PjE1KSsobT4+PjE1KSx0aGlzLl9fc2V0RGlnaXQodSwxMDczNzQxODIzJnYpfWlmKDAhPT1nfHwwIT09byl0aHJvdyBuZXcgRXJyb3IoXCJpbXBsZW1lbnRhdGlvbiBidWdcIil9fSx7a2V5OlwiX19pbnBsYWNlQWRkXCIsdmFsdWU6ZnVuY3Rpb24oZSx0LF8pe2Zvcih2YXIgbixsPTAsZz0wO2c8XztnKyspbj10aGlzLl9faGFsZkRpZ2l0KHQrZykrZS5fX2hhbGZEaWdpdChnKStsLGw9bj4+PjE1LHRoaXMuX19zZXRIYWxmRGlnaXQodCtnLDMyNzY3Jm4pO3JldHVybiBsfX0se2tleTpcIl9faW5wbGFjZVN1YlwiLHZhbHVlOmZ1bmN0aW9uKGUsdCxfKXt2YXIgbj0wO2lmKDEmdCl7dD4+PTE7Zm9yKHZhciBsPXRoaXMuX19kaWdpdCh0KSxnPTMyNzY3Jmwsbz0wO288Xy0xPj4+MTtvKyspe3ZhciBhPWUuX19kaWdpdChvKSx1PShsPj4+MTUpLSgzMjc2NyZhKS1uO249MSZ1Pj4+MTUsdGhpcy5fX3NldERpZ2l0KHQrbywoMzI3NjcmdSk8PDE1fDMyNzY3JmcpLGw9dGhpcy5fX2RpZ2l0KHQrbysxKSxnPSgzMjc2NyZsKS0oYT4+PjE1KS1uLG49MSZnPj4+MTV9dmFyIHM9ZS5fX2RpZ2l0KG8pLHI9KGw+Pj4xNSktKDMyNzY3JnMpLW47bj0xJnI+Pj4xNSx0aGlzLl9fc2V0RGlnaXQodCtvLCgzMjc2NyZyKTw8MTV8MzI3NjcmZyk7aWYodCtvKzE+PXRoaXMubGVuZ3RoKXRocm93IG5ldyBSYW5nZUVycm9yKFwib3V0IG9mIGJvdW5kc1wiKTswPT0oMSZfKSYmKGw9dGhpcy5fX2RpZ2l0KHQrbysxKSxnPSgzMjc2NyZsKS0ocz4+PjE1KS1uLG49MSZnPj4+MTUsdGhpcy5fX3NldERpZ2l0KHQrZS5sZW5ndGgsMTA3MzcwOTA1NiZsfDMyNzY3JmcpKX1lbHNle3Q+Pj0xO2Zvcih2YXIgZD0wO2Q8ZS5sZW5ndGgtMTtkKyspe3ZhciBoPXRoaXMuX19kaWdpdCh0K2QpLGI9ZS5fX2RpZ2l0KGQpLG09KDMyNzY3JmgpLSgzMjc2NyZiKS1uO249MSZtPj4+MTU7dmFyIGM9KGg+Pj4xNSktKGI+Pj4xNSktbjtuPTEmYz4+PjE1LHRoaXMuX19zZXREaWdpdCh0K2QsKDMyNzY3JmMpPDwxNXwzMjc2NyZtKX12YXIgdj10aGlzLl9fZGlnaXQodCtkKSx5PWUuX19kaWdpdChkKSxmPSgzMjc2NyZ2KS0oMzI3NjcmeSktbjtuPTEmZj4+PjE1O3ZhciBEPTA7MD09KDEmXykmJihEPSh2Pj4+MTUpLSh5Pj4+MTUpLW4sbj0xJkQ+Pj4xNSksdGhpcy5fX3NldERpZ2l0KHQrZCwoMzI3NjcmRCk8PDE1fDMyNzY3JmYpfXJldHVybiBufX0se2tleTpcIl9faW5wbGFjZVJpZ2h0U2hpZnRcIix2YWx1ZTpmdW5jdGlvbihlKXtpZigwIT09ZSl7Zm9yKHZhciB0LF89dGhpcy5fX2RpZ2l0KDApPj4+ZSxuPXRoaXMubGVuZ3RoLTEsbD0wO2w8bjtsKyspdD10aGlzLl9fZGlnaXQobCsxKSx0aGlzLl9fc2V0RGlnaXQobCwxMDczNzQxODIzJnQ8PDMwLWV8XyksXz10Pj4+ZTt0aGlzLl9fc2V0RGlnaXQobixfKX19fSx7a2V5OlwiX19kaWdpdFwiLHZhbHVlOmZ1bmN0aW9uKGUpe3JldHVybiB0aGlzW2VdfX0se2tleTpcIl9fdW5zaWduZWREaWdpdFwiLHZhbHVlOmZ1bmN0aW9uKGUpe3JldHVybiB0aGlzW2VdPj4+MH19LHtrZXk6XCJfX3NldERpZ2l0XCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXt0aGlzW2VdPTB8dH19LHtrZXk6XCJfX3NldERpZ2l0R3Jvd1wiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7dGhpc1tlXT0wfHR9fSx7a2V5OlwiX19oYWxmRGlnaXRMZW5ndGhcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPXRoaXMubGVuZ3RoO3JldHVybiAzMjc2Nz49dGhpcy5fX3Vuc2lnbmVkRGlnaXQoZS0xKT8yKmUtMToyKmV9fSx7a2V5OlwiX19oYWxmRGlnaXRcIix2YWx1ZTpmdW5jdGlvbihlKXtyZXR1cm4gMzI3NjcmdGhpc1tlPj4+MV0+Pj4xNSooMSZlKX19LHtrZXk6XCJfX3NldEhhbGZEaWdpdFwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7dmFyIGk9ZT4+PjEsXz10aGlzLl9fZGlnaXQoaSksbj0xJmU/MzI3NjcmX3x0PDwxNToxMDczNzA5MDU2Jl98MzI3NjcmdDt0aGlzLl9fc2V0RGlnaXQoaSxuKX19XSxbe2tleTpcIkJpZ0ludFwiLHZhbHVlOmZ1bmN0aW9uKGUpe3ZhciB0PU51bWJlci5pc0Zpbml0ZTtpZihcIm51bWJlclwiPT10eXBlb2YgZSl7aWYoMD09PWUpcmV0dXJuIGEuX196ZXJvKCk7aWYoYS5fX2lzT25lRGlnaXRJbnQoZSkpcmV0dXJuIDA+ZT9hLl9fb25lRGlnaXQoLWUsITApOmEuX19vbmVEaWdpdChlLCExKTtpZighdChlKXx8byhlKSE9PWUpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJUaGUgbnVtYmVyIFwiK2UrXCIgY2Fubm90IGJlIGNvbnZlcnRlZCB0byBCaWdJbnQgYmVjYXVzZSBpdCBpcyBub3QgYW4gaW50ZWdlclwiKTtyZXR1cm4gYS5fX2Zyb21Eb3VibGUoZSl9aWYoXCJzdHJpbmdcIj09dHlwZW9mIGUpe3ZhciBfPWEuX19mcm9tU3RyaW5nKGUpO2lmKG51bGw9PT1fKXRocm93IG5ldyBTeW50YXhFcnJvcihcIkNhbm5vdCBjb252ZXJ0IFwiK2UrXCIgdG8gYSBCaWdJbnRcIik7cmV0dXJuIF99aWYoXCJib29sZWFuXCI9PXR5cGVvZiBlKXJldHVybiEwPT09ZT9hLl9fb25lRGlnaXQoMSwhMSk6YS5fX3plcm8oKTtpZihcIm9iamVjdFwiPT09aShlKSl7aWYoZS5jb25zdHJ1Y3Rvcj09PWEpcmV0dXJuIGU7dmFyIG49YS5fX3RvUHJpbWl0aXZlKGUpO3JldHVybiBhLkJpZ0ludChuKX10aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNvbnZlcnQgXCIrZStcIiB0byBhIEJpZ0ludFwiKX19LHtrZXk6XCJ0b051bWJlclwiLHZhbHVlOmZ1bmN0aW9uKGUpe3ZhciB0PWUubGVuZ3RoO2lmKDA9PT10KXJldHVybiAwO2lmKDE9PT10KXt2YXIgaT1lLl9fdW5zaWduZWREaWdpdCgwKTtyZXR1cm4gZS5zaWduPy1pOml9dmFyIF89ZS5fX2RpZ2l0KHQtMSksbj1hLl9fY2x6MzAoXyksbD0zMCp0LW47aWYoMTAyNDxsKXJldHVybiBlLnNpZ24/LUluZmluaXR5OjEvMDt2YXIgZz1sLTEsbz1fLHU9dC0xLHM9biszLHI9MzI9PT1zPzA6bzw8cztyPj4+PTEyO3ZhciBkPXMtMTIsaD0xMjw9cz8wOm88PDIwK3MsYj0yMCtzO2ZvcigwPGQmJjA8dSYmKHUtLSxvPWUuX19kaWdpdCh1KSxyfD1vPj4+MzAtZCxoPW88PGQrMixiPWQrMik7MDxiJiYwPHU7KXUtLSxvPWUuX19kaWdpdCh1KSxofD0zMDw9Yj9vPDxiLTMwOm8+Pj4zMC1iLGItPTMwO3ZhciBtPWEuX19kZWNpZGVSb3VuZGluZyhlLGIsdSxvKTtpZigoMT09PW18fDA9PT1tJiYxPT0oMSZoKSkmJihoPWgrMT4+PjAsMD09PWgmJihyKyssMCE9cj4+PjIwJiYocj0wLGcrKywxMDIzPGcpKSkpcmV0dXJuIGUuc2lnbj8tSW5maW5pdHk6MS8wO3ZhciBjPWUuc2lnbj8tMjE0NzQ4MzY0ODowO3JldHVybiBnPWcrMTAyMzw8MjAsYS5fX2tCaXRDb252ZXJzaW9uSW50c1sxXT1jfGd8cixhLl9fa0JpdENvbnZlcnNpb25JbnRzWzBdPWgsYS5fX2tCaXRDb252ZXJzaW9uRG91YmxlWzBdfX0se2tleTpcInVuYXJ5TWludXNcIix2YWx1ZTpmdW5jdGlvbihlKXtpZigwPT09ZS5sZW5ndGgpcmV0dXJuIGU7dmFyIHQ9ZS5fX2NvcHkoKTtyZXR1cm4gdC5zaWduPSFlLnNpZ24sdH19LHtrZXk6XCJiaXR3aXNlTm90XCIsdmFsdWU6ZnVuY3Rpb24oZSl7cmV0dXJuIGUuc2lnbj9hLl9fYWJzb2x1dGVTdWJPbmUoZSkuX190cmltKCk6YS5fX2Fic29sdXRlQWRkT25lKGUsITApfX0se2tleTpcImV4cG9uZW50aWF0ZVwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7aWYodC5zaWduKXRocm93IG5ldyBSYW5nZUVycm9yKFwiRXhwb25lbnQgbXVzdCBiZSBwb3NpdGl2ZVwiKTtpZigwPT09dC5sZW5ndGgpcmV0dXJuIGEuX19vbmVEaWdpdCgxLCExKTtpZigwPT09ZS5sZW5ndGgpcmV0dXJuIGU7aWYoMT09PWUubGVuZ3RoJiYxPT09ZS5fX2RpZ2l0KDApKXJldHVybiBlLnNpZ24mJjA9PSgxJnQuX19kaWdpdCgwKSk/YS51bmFyeU1pbnVzKGUpOmU7aWYoMTx0Lmxlbmd0aCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkJpZ0ludCB0b28gYmlnXCIpO3ZhciBpPXQuX191bnNpZ25lZERpZ2l0KDApO2lmKDE9PT1pKXJldHVybiBlO2lmKGk+PWEuX19rTWF4TGVuZ3RoQml0cyl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkJpZ0ludCB0b28gYmlnXCIpO2lmKDE9PT1lLmxlbmd0aCYmMj09PWUuX19kaWdpdCgwKSl7dmFyIF89MSsoMHxpLzMwKSxuPWUuc2lnbiYmMCE9KDEmaSksbD1uZXcgYShfLG4pO2wuX19pbml0aWFsaXplRGlnaXRzKCk7dmFyIGc9MTw8aSUzMDtyZXR1cm4gbC5fX3NldERpZ2l0KF8tMSxnKSxsfXZhciBvPW51bGwsdT1lO2ZvcigwIT0oMSZpKSYmKG89ZSksaT4+PTE7MCE9PWk7aT4+PTEpdT1hLm11bHRpcGx5KHUsdSksMCE9KDEmaSkmJihudWxsPT09bz9vPXU6bz1hLm11bHRpcGx5KG8sdSkpO3JldHVybiBvfX0se2tleTpcIm11bHRpcGx5XCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXtpZigwPT09ZS5sZW5ndGgpcmV0dXJuIGU7aWYoMD09PXQubGVuZ3RoKXJldHVybiB0O3ZhciBfPWUubGVuZ3RoK3QubGVuZ3RoOzMwPD1lLl9fY2x6bXNkKCkrdC5fX2Nsem1zZCgpJiZfLS07dmFyIG49bmV3IGEoXyxlLnNpZ24hPT10LnNpZ24pO24uX19pbml0aWFsaXplRGlnaXRzKCk7Zm9yKHZhciBsPTA7bDxlLmxlbmd0aDtsKyspYS5fX211bHRpcGx5QWNjdW11bGF0ZSh0LGUuX19kaWdpdChsKSxuLGwpO3JldHVybiBuLl9fdHJpbSgpfX0se2tleTpcImRpdmlkZVwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7aWYoMD09PXQubGVuZ3RoKXRocm93IG5ldyBSYW5nZUVycm9yKFwiRGl2aXNpb24gYnkgemVyb1wiKTtpZigwPmEuX19hYnNvbHV0ZUNvbXBhcmUoZSx0KSlyZXR1cm4gYS5fX3plcm8oKTt2YXIgaSxfPWUuc2lnbiE9PXQuc2lnbixuPXQuX191bnNpZ25lZERpZ2l0KDApO2lmKDE9PT10Lmxlbmd0aCYmMzI3Njc+PW4pe2lmKDE9PT1uKXJldHVybiBfPT09ZS5zaWduP2U6YS51bmFyeU1pbnVzKGUpO2k9YS5fX2Fic29sdXRlRGl2U21hbGwoZSxuLG51bGwpfWVsc2UgaT1hLl9fYWJzb2x1dGVEaXZMYXJnZShlLHQsITAsITEpO3JldHVybiBpLnNpZ249XyxpLl9fdHJpbSgpfX0se2tleTpcInJlbWFpbmRlclwiLHZhbHVlOmZ1bmN0aW9uIGkoZSx0KXtpZigwPT09dC5sZW5ndGgpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJEaXZpc2lvbiBieSB6ZXJvXCIpO2lmKDA+YS5fX2Fic29sdXRlQ29tcGFyZShlLHQpKXJldHVybiBlO3ZhciBfPXQuX191bnNpZ25lZERpZ2l0KDApO2lmKDE9PT10Lmxlbmd0aCYmMzI3Njc+PV8pe2lmKDE9PT1fKXJldHVybiBhLl9femVybygpO3ZhciBuPWEuX19hYnNvbHV0ZU1vZFNtYWxsKGUsXyk7cmV0dXJuIDA9PT1uP2EuX196ZXJvKCk6YS5fX29uZURpZ2l0KG4sZS5zaWduKX12YXIgaT1hLl9fYWJzb2x1dGVEaXZMYXJnZShlLHQsITEsITApO3JldHVybiBpLnNpZ249ZS5zaWduLGkuX190cmltKCl9fSx7a2V5OlwiYWRkXCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXt2YXIgaT1lLnNpZ247cmV0dXJuIGk9PT10LnNpZ24/YS5fX2Fic29sdXRlQWRkKGUsdCxpKTowPD1hLl9fYWJzb2x1dGVDb21wYXJlKGUsdCk/YS5fX2Fic29sdXRlU3ViKGUsdCxpKTphLl9fYWJzb2x1dGVTdWIodCxlLCFpKX19LHtrZXk6XCJzdWJ0cmFjdFwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7dmFyIGk9ZS5zaWduO3JldHVybiBpPT09dC5zaWduPzA8PWEuX19hYnNvbHV0ZUNvbXBhcmUoZSx0KT9hLl9fYWJzb2x1dGVTdWIoZSx0LGkpOmEuX19hYnNvbHV0ZVN1Yih0LGUsIWkpOmEuX19hYnNvbHV0ZUFkZChlLHQsaSl9fSx7a2V5OlwibGVmdFNoaWZ0XCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gMD09PXQubGVuZ3RofHwwPT09ZS5sZW5ndGg/ZTp0LnNpZ24/YS5fX3JpZ2h0U2hpZnRCeUFic29sdXRlKGUsdCk6YS5fX2xlZnRTaGlmdEJ5QWJzb2x1dGUoZSx0KX19LHtrZXk6XCJzaWduZWRSaWdodFNoaWZ0XCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gMD09PXQubGVuZ3RofHwwPT09ZS5sZW5ndGg/ZTp0LnNpZ24/YS5fX2xlZnRTaGlmdEJ5QWJzb2x1dGUoZSx0KTphLl9fcmlnaHRTaGlmdEJ5QWJzb2x1dGUoZSx0KX19LHtrZXk6XCJ1bnNpZ25lZFJpZ2h0U2hpZnRcIix2YWx1ZTpmdW5jdGlvbigpe3Rocm93IG5ldyBUeXBlRXJyb3IoXCJCaWdJbnRzIGhhdmUgbm8gdW5zaWduZWQgcmlnaHQgc2hpZnQ7IHVzZSA+PiBpbnN0ZWFkXCIpfX0se2tleTpcImxlc3NUaGFuXCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gMD5hLl9fY29tcGFyZVRvQmlnSW50KGUsdCl9fSx7a2V5OlwibGVzc1RoYW5PckVxdWFsXCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gMD49YS5fX2NvbXBhcmVUb0JpZ0ludChlLHQpfX0se2tleTpcImdyZWF0ZXJUaGFuXCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gMDxhLl9fY29tcGFyZVRvQmlnSW50KGUsdCl9fSx7a2V5OlwiZ3JlYXRlclRoYW5PckVxdWFsXCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gMDw9YS5fX2NvbXBhcmVUb0JpZ0ludChlLHQpfX0se2tleTpcImVxdWFsXCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXtpZihlLnNpZ24hPT10LnNpZ24pcmV0dXJuITE7aWYoZS5sZW5ndGghPT10Lmxlbmd0aClyZXR1cm4hMTtmb3IodmFyIF89MDtfPGUubGVuZ3RoO18rKylpZihlLl9fZGlnaXQoXykhPT10Ll9fZGlnaXQoXykpcmV0dXJuITE7cmV0dXJuITB9fSx7a2V5Olwibm90RXF1YWxcIix2YWx1ZTpmdW5jdGlvbihlLHQpe3JldHVybiFhLmVxdWFsKGUsdCl9fSx7a2V5OlwiYml0d2lzZUFuZFwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7aWYoIWUuc2lnbiYmIXQuc2lnbilyZXR1cm4gYS5fX2Fic29sdXRlQW5kKGUsdCkuX190cmltKCk7aWYoZS5zaWduJiZ0LnNpZ24pe3ZhciBpPW4oZS5sZW5ndGgsdC5sZW5ndGgpKzEsXz1hLl9fYWJzb2x1dGVTdWJPbmUoZSxpKSxsPWEuX19hYnNvbHV0ZVN1Yk9uZSh0KTtyZXR1cm4gXz1hLl9fYWJzb2x1dGVPcihfLGwsXyksYS5fX2Fic29sdXRlQWRkT25lKF8sITAsXykuX190cmltKCl9aWYoZS5zaWduKXt2YXIgZz1bdCxlXTtlPWdbMF0sdD1nWzFdfXJldHVybiBhLl9fYWJzb2x1dGVBbmROb3QoZSxhLl9fYWJzb2x1dGVTdWJPbmUodCkpLl9fdHJpbSgpfX0se2tleTpcImJpdHdpc2VYb3JcIix2YWx1ZTpmdW5jdGlvbihlLHQpe2lmKCFlLnNpZ24mJiF0LnNpZ24pcmV0dXJuIGEuX19hYnNvbHV0ZVhvcihlLHQpLl9fdHJpbSgpO2lmKGUuc2lnbiYmdC5zaWduKXt2YXIgaT1uKGUubGVuZ3RoLHQubGVuZ3RoKSxfPWEuX19hYnNvbHV0ZVN1Yk9uZShlLGkpLGw9YS5fX2Fic29sdXRlU3ViT25lKHQpO3JldHVybiBhLl9fYWJzb2x1dGVYb3IoXyxsLF8pLl9fdHJpbSgpfXZhciBnPW4oZS5sZW5ndGgsdC5sZW5ndGgpKzE7aWYoZS5zaWduKXt2YXIgbz1bdCxlXTtlPW9bMF0sdD1vWzFdfXZhciB1PWEuX19hYnNvbHV0ZVN1Yk9uZSh0LGcpO3JldHVybiB1PWEuX19hYnNvbHV0ZVhvcih1LGUsdSksYS5fX2Fic29sdXRlQWRkT25lKHUsITAsdSkuX190cmltKCl9fSx7a2V5OlwiYml0d2lzZU9yXCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXt2YXIgaT1uKGUubGVuZ3RoLHQubGVuZ3RoKTtpZighZS5zaWduJiYhdC5zaWduKXJldHVybiBhLl9fYWJzb2x1dGVPcihlLHQpLl9fdHJpbSgpO2lmKGUuc2lnbiYmdC5zaWduKXt2YXIgXz1hLl9fYWJzb2x1dGVTdWJPbmUoZSxpKSxsPWEuX19hYnNvbHV0ZVN1Yk9uZSh0KTtyZXR1cm4gXz1hLl9fYWJzb2x1dGVBbmQoXyxsLF8pLGEuX19hYnNvbHV0ZUFkZE9uZShfLCEwLF8pLl9fdHJpbSgpfWlmKGUuc2lnbil7dmFyIGc9W3QsZV07ZT1nWzBdLHQ9Z1sxXX12YXIgbz1hLl9fYWJzb2x1dGVTdWJPbmUodCxpKTtyZXR1cm4gbz1hLl9fYWJzb2x1dGVBbmROb3QobyxlLG8pLGEuX19hYnNvbHV0ZUFkZE9uZShvLCEwLG8pLl9fdHJpbSgpfX0se2tleTpcImFzSW50TlwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7aWYoMD09PXQubGVuZ3RoKXJldHVybiB0O2lmKGU9byhlKSwwPmUpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIHZhbHVlOiBub3QgKGNvbnZlcnRpYmxlIHRvKSBhIHNhZmUgaW50ZWdlclwiKTtpZigwPT09ZSlyZXR1cm4gYS5fX3plcm8oKTtpZihlPj1hLl9fa01heExlbmd0aEJpdHMpcmV0dXJuIHQ7dmFyIF89MHwoZSsyOSkvMzA7aWYodC5sZW5ndGg8XylyZXR1cm4gdDt2YXIgbD10Ll9fdW5zaWduZWREaWdpdChfLTEpLGc9MTw8KGUtMSklMzA7aWYodC5sZW5ndGg9PT1fJiZsPGcpcmV0dXJuIHQ7aWYoISgobCZnKT09PWcpKXJldHVybiBhLl9fdHJ1bmNhdGVUb05CaXRzKGUsdCk7aWYoIXQuc2lnbilyZXR1cm4gYS5fX3RydW5jYXRlQW5kU3ViRnJvbVBvd2VyT2ZUd28oZSx0LCEwKTtpZigwPT0obCZnLTEpKXtmb3IodmFyIHU9Xy0yOzA8PXU7dS0tKWlmKDAhPT10Ll9fZGlnaXQodSkpcmV0dXJuIGEuX190cnVuY2F0ZUFuZFN1YkZyb21Qb3dlck9mVHdvKGUsdCwhMSk7cmV0dXJuIHQubGVuZ3RoPT09XyYmbD09PWc/dDphLl9fdHJ1bmNhdGVUb05CaXRzKGUsdCl9cmV0dXJuIGEuX190cnVuY2F0ZUFuZFN1YkZyb21Qb3dlck9mVHdvKGUsdCwhMSl9fSx7a2V5OlwiYXNVaW50TlwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7aWYoMD09PXQubGVuZ3RoKXJldHVybiB0O2lmKGU9byhlKSwwPmUpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIHZhbHVlOiBub3QgKGNvbnZlcnRpYmxlIHRvKSBhIHNhZmUgaW50ZWdlclwiKTtpZigwPT09ZSlyZXR1cm4gYS5fX3plcm8oKTtpZih0LnNpZ24pe2lmKGU+YS5fX2tNYXhMZW5ndGhCaXRzKXRocm93IG5ldyBSYW5nZUVycm9yKFwiQmlnSW50IHRvbyBiaWdcIik7cmV0dXJuIGEuX190cnVuY2F0ZUFuZFN1YkZyb21Qb3dlck9mVHdvKGUsdCwhMSl9aWYoZT49YS5fX2tNYXhMZW5ndGhCaXRzKXJldHVybiB0O3ZhciBpPTB8KGUrMjkpLzMwO2lmKHQubGVuZ3RoPGkpcmV0dXJuIHQ7dmFyIF89ZSUzMDtpZih0Lmxlbmd0aD09aSl7aWYoMD09PV8pcmV0dXJuIHQ7dmFyIGw9dC5fX2RpZ2l0KGktMSk7aWYoMD09bD4+Pl8pcmV0dXJuIHR9cmV0dXJuIGEuX190cnVuY2F0ZVRvTkJpdHMoZSx0KX19LHtrZXk6XCJBRERcIix2YWx1ZTpmdW5jdGlvbihlLHQpe2lmKGU9YS5fX3RvUHJpbWl0aXZlKGUpLHQ9YS5fX3RvUHJpbWl0aXZlKHQpLFwic3RyaW5nXCI9PXR5cGVvZiBlKXJldHVyblwic3RyaW5nXCIhPXR5cGVvZiB0JiYodD10LnRvU3RyaW5nKCkpLGUrdDtpZihcInN0cmluZ1wiPT10eXBlb2YgdClyZXR1cm4gZS50b1N0cmluZygpK3Q7aWYoZT1hLl9fdG9OdW1lcmljKGUpLHQ9YS5fX3RvTnVtZXJpYyh0KSxhLl9faXNCaWdJbnQoZSkmJmEuX19pc0JpZ0ludCh0KSlyZXR1cm4gYS5hZGQoZSx0KTtpZihcIm51bWJlclwiPT10eXBlb2YgZSYmXCJudW1iZXJcIj09dHlwZW9mIHQpcmV0dXJuIGUrdDt0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IG1peCBCaWdJbnQgYW5kIG90aGVyIHR5cGVzLCB1c2UgZXhwbGljaXQgY29udmVyc2lvbnNcIil9fSx7a2V5OlwiTFRcIix2YWx1ZTpmdW5jdGlvbihlLHQpe3JldHVybiBhLl9fY29tcGFyZShlLHQsMCl9fSx7a2V5OlwiTEVcIix2YWx1ZTpmdW5jdGlvbihlLHQpe3JldHVybiBhLl9fY29tcGFyZShlLHQsMSl9fSx7a2V5OlwiR1RcIix2YWx1ZTpmdW5jdGlvbihlLHQpe3JldHVybiBhLl9fY29tcGFyZShlLHQsMil9fSx7a2V5OlwiR0VcIix2YWx1ZTpmdW5jdGlvbihlLHQpe3JldHVybiBhLl9fY29tcGFyZShlLHQsMyl9fSx7a2V5OlwiRVFcIix2YWx1ZTpmdW5jdGlvbihlLHQpe2Zvcig7Oyl7aWYoYS5fX2lzQmlnSW50KGUpKXJldHVybiBhLl9faXNCaWdJbnQodCk/YS5lcXVhbChlLHQpOmEuRVEodCxlKTtpZihcIm51bWJlclwiPT10eXBlb2YgZSl7aWYoYS5fX2lzQmlnSW50KHQpKXJldHVybiBhLl9fZXF1YWxUb051bWJlcih0LGUpO2lmKFwib2JqZWN0XCIhPT1pKHQpKXJldHVybiBlPT10O3Q9YS5fX3RvUHJpbWl0aXZlKHQpfWVsc2UgaWYoXCJzdHJpbmdcIj09dHlwZW9mIGUpe2lmKGEuX19pc0JpZ0ludCh0KSlyZXR1cm4gZT1hLl9fZnJvbVN0cmluZyhlKSxudWxsIT09ZSYmYS5lcXVhbChlLHQpO2lmKFwib2JqZWN0XCIhPT1pKHQpKXJldHVybiBlPT10O3Q9YS5fX3RvUHJpbWl0aXZlKHQpfWVsc2UgaWYoXCJib29sZWFuXCI9PXR5cGVvZiBlKXtpZihhLl9faXNCaWdJbnQodCkpcmV0dXJuIGEuX19lcXVhbFRvTnVtYmVyKHQsK2UpO2lmKFwib2JqZWN0XCIhPT1pKHQpKXJldHVybiBlPT10O3Q9YS5fX3RvUHJpbWl0aXZlKHQpfWVsc2UgaWYoXCJzeW1ib2xcIj09PWkoZSkpe2lmKGEuX19pc0JpZ0ludCh0KSlyZXR1cm4hMTtpZihcIm9iamVjdFwiIT09aSh0KSlyZXR1cm4gZT09dDt0PWEuX190b1ByaW1pdGl2ZSh0KX1lbHNlIGlmKFwib2JqZWN0XCI9PT1pKGUpKXtpZihcIm9iamVjdFwiPT09aSh0KSYmdC5jb25zdHJ1Y3RvciE9PWEpcmV0dXJuIGU9PXQ7ZT1hLl9fdG9QcmltaXRpdmUoZSl9ZWxzZSByZXR1cm4gZT09dH19fSx7a2V5OlwiTkVcIix2YWx1ZTpmdW5jdGlvbihlLHQpe3JldHVybiFhLkVRKGUsdCl9fSx7a2V5OlwiRGF0YVZpZXdHZXRCaWdJbnQ2NFwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7dmFyIGk9ISEoMjxhcmd1bWVudHMubGVuZ3RoJiZ2b2lkIDAhPT1hcmd1bWVudHNbMl0pJiZhcmd1bWVudHNbMl07cmV0dXJuIGEuYXNJbnROKDY0LGEuRGF0YVZpZXdHZXRCaWdVaW50NjQoZSx0LGkpKX19LHtrZXk6XCJEYXRhVmlld0dldEJpZ1VpbnQ2NFwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7dmFyIGk9ISEoMjxhcmd1bWVudHMubGVuZ3RoJiZ2b2lkIDAhPT1hcmd1bWVudHNbMl0pJiZhcmd1bWVudHNbMl0sXz1pP1s0LDBdOlswLDRdLG49dihfLDIpLGc9blswXSxvPW5bMV0sbD1lLmdldFVpbnQzMih0K2csaSksdT1lLmdldFVpbnQzMih0K28saSkscz1uZXcgYSgzLCExKTtyZXR1cm4gcy5fX3NldERpZ2l0KDAsMTA3Mzc0MTgyMyZ1KSxzLl9fc2V0RGlnaXQoMSwoMjY4NDM1NDU1JmwpPDwyfHU+Pj4zMCkscy5fX3NldERpZ2l0KDIsbD4+PjI4KSxzLl9fdHJpbSgpfX0se2tleTpcIkRhdGFWaWV3U2V0QmlnSW50NjRcIix2YWx1ZTpmdW5jdGlvbihlLHQsaSl7dmFyIF89ISEoMzxhcmd1bWVudHMubGVuZ3RoJiZ2b2lkIDAhPT1hcmd1bWVudHNbM10pJiZhcmd1bWVudHNbM107YS5EYXRhVmlld1NldEJpZ1VpbnQ2NChlLHQsaSxfKX19LHtrZXk6XCJEYXRhVmlld1NldEJpZ1VpbnQ2NFwiLHZhbHVlOmZ1bmN0aW9uKGUsdCxpKXt2YXIgXz0hISgzPGFyZ3VtZW50cy5sZW5ndGgmJnZvaWQgMCE9PWFyZ3VtZW50c1szXSkmJmFyZ3VtZW50c1szXTtpPWEuYXNVaW50Tig2NCxpKTt2YXIgbj0wLGc9MDtpZigwPGkubGVuZ3RoJiYoZz1pLl9fZGlnaXQoMCksMTxpLmxlbmd0aCkpe3ZhciBvPWkuX19kaWdpdCgxKTtnfD1vPDwzMCxuPW8+Pj4yLDI8aS5sZW5ndGgmJihufD1pLl9fZGlnaXQoMik8PDI4KX12YXIgdT1fP1s0LDBdOlswLDRdLHM9dih1LDIpLHI9c1swXSxkPXNbMV07ZS5zZXRVaW50MzIodCtyLG4sXyksZS5zZXRVaW50MzIodCtkLGcsXyl9fSx7a2V5OlwiX196ZXJvXCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IGEoMCwhMSl9fSx7a2V5OlwiX19vbmVEaWdpdFwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7dmFyIGk9bmV3IGEoMSx0KTtyZXR1cm4gaS5fX3NldERpZ2l0KDAsZSksaX19LHtrZXk6XCJfX2RlY2lkZVJvdW5kaW5nXCIsdmFsdWU6ZnVuY3Rpb24oZSx0LGksXyl7aWYoMDx0KXJldHVybi0xO3ZhciBuO2lmKDA+dCluPS10LTE7ZWxzZXtpZigwPT09aSlyZXR1cm4tMTtpLS0sXz1lLl9fZGlnaXQoaSksbj0yOX12YXIgbD0xPDxuO2lmKDA9PShfJmwpKXJldHVybi0xO2lmKGwtPTEsMCE9KF8mbCkpcmV0dXJuIDE7Zm9yKDswPGk7KWlmKGktLSwwIT09ZS5fX2RpZ2l0KGkpKXJldHVybiAxO3JldHVybiAwfX0se2tleTpcIl9fZnJvbURvdWJsZVwiLHZhbHVlOmZ1bmN0aW9uKGUpe2EuX19rQml0Q29udmVyc2lvbkRvdWJsZVswXT1lO3ZhciB0LGk9MjA0NyZhLl9fa0JpdENvbnZlcnNpb25JbnRzWzFdPj4+MjAsXz1pLTEwMjMsbj0oMHxfLzMwKSsxLGw9bmV3IGEobiwwPmUpLGc9MTA0ODU3NSZhLl9fa0JpdENvbnZlcnNpb25JbnRzWzFdfDEwNDg1NzYsbz1hLl9fa0JpdENvbnZlcnNpb25JbnRzWzBdLHU9MjAscz1fJTMwLHI9MDtpZihzPHUpe3ZhciBkPXUtcztyPWQrMzIsdD1nPj4+ZCxnPWc8PDMyLWR8bz4+PmQsbzw8PTMyLWR9ZWxzZSBpZihzPT09dSlyPTMyLHQ9ZyxnPW8sbz0wO2Vsc2V7dmFyIGg9cy11O3I9MzItaCx0PWc8PGh8bz4+PjMyLWgsZz1vPDxoLG89MH1sLl9fc2V0RGlnaXQobi0xLHQpO2Zvcih2YXIgYj1uLTI7MDw9YjtiLS0pMDxyPyhyLT0zMCx0PWc+Pj4yLGc9Zzw8MzB8bz4+PjIsbzw8PTMwKTp0PTAsbC5fX3NldERpZ2l0KGIsdCk7cmV0dXJuIGwuX190cmltKCl9fSx7a2V5OlwiX19pc1doaXRlc3BhY2VcIix2YWx1ZTpmdW5jdGlvbihlKXtyZXR1cm4hISgxMz49ZSYmOTw9ZSl8fCgxNTk+PWU/MzI9PWU6MTMxMDcxPj1lPzE2MD09ZXx8NTc2MD09ZToxOTY2MDc+PWU/KGUmPTEzMTA3MSwxMD49ZXx8NDA9PWV8fDQxPT1lfHw0Nz09ZXx8OTU9PWV8fDQwOTY9PWUpOjY1Mjc5PT1lKX19LHtrZXk6XCJfX2Zyb21TdHJpbmdcIix2YWx1ZTpmdW5jdGlvbihlKXt2YXIgdD0xPGFyZ3VtZW50cy5sZW5ndGgmJnZvaWQgMCE9PWFyZ3VtZW50c1sxXT9hcmd1bWVudHNbMV06MCxpPTAsXz1lLmxlbmd0aCxuPTA7aWYobj09PV8pcmV0dXJuIGEuX196ZXJvKCk7Zm9yKHZhciBsPWUuY2hhckNvZGVBdChuKTthLl9faXNXaGl0ZXNwYWNlKGwpOyl7aWYoKytuPT09XylyZXR1cm4gYS5fX3plcm8oKTtsPWUuY2hhckNvZGVBdChuKX1pZig0Mz09PWwpe2lmKCsrbj09PV8pcmV0dXJuIG51bGw7bD1lLmNoYXJDb2RlQXQobiksaT0xfWVsc2UgaWYoNDU9PT1sKXtpZigrK249PT1fKXJldHVybiBudWxsO2w9ZS5jaGFyQ29kZUF0KG4pLGk9LTF9aWYoMD09PXQpe2lmKHQ9MTAsNDg9PT1sKXtpZigrK249PT1fKXJldHVybiBhLl9femVybygpO2lmKGw9ZS5jaGFyQ29kZUF0KG4pLDg4PT09bHx8MTIwPT09bCl7aWYodD0xNiwrK249PT1fKXJldHVybiBudWxsO2w9ZS5jaGFyQ29kZUF0KG4pfWVsc2UgaWYoNzk9PT1sfHwxMTE9PT1sKXtpZih0PTgsKytuPT09XylyZXR1cm4gbnVsbDtsPWUuY2hhckNvZGVBdChuKX1lbHNlIGlmKDY2PT09bHx8OTg9PT1sKXtpZih0PTIsKytuPT09XylyZXR1cm4gbnVsbDtsPWUuY2hhckNvZGVBdChuKX19fWVsc2UgaWYoMTY9PT10JiY0OD09PWwpe2lmKCsrbj09PV8pcmV0dXJuIGEuX196ZXJvKCk7aWYobD1lLmNoYXJDb2RlQXQobiksODg9PT1sfHwxMjA9PT1sKXtpZigrK249PT1fKXJldHVybiBudWxsO2w9ZS5jaGFyQ29kZUF0KG4pfX1pZigwIT09aSYmMTAhPT10KXJldHVybiBudWxsO2Zvcig7NDg9PT1sOyl7aWYoKytuPT09XylyZXR1cm4gYS5fX3plcm8oKTtsPWUuY2hhckNvZGVBdChuKX12YXIgZz1fLW4sbz1hLl9fa01heEJpdHNQZXJDaGFyW3RdLHU9YS5fX2tCaXRzUGVyQ2hhclRhYmxlTXVsdGlwbGllci0xO2lmKGc+MTA3Mzc0MTgyNC9vKXJldHVybiBudWxsO3ZhciBzPW8qZyt1Pj4+YS5fX2tCaXRzUGVyQ2hhclRhYmxlU2hpZnQscj1uZXcgYSgwfChzKzI5KS8zMCwhMSksaD0xMD50P3Q6MTAsYj0xMDx0P3QtMTA6MDtpZigwPT0odCZ0LTEpKXtvPj49YS5fX2tCaXRzUGVyQ2hhclRhYmxlU2hpZnQ7dmFyIGM9W10sdj1bXSx5PSExO2Rve2Zvcih2YXIgZixEPTAscD0wOzspe2lmKGY9dm9pZCAwLGwtNDg+Pj4wPGgpZj1sLTQ4O2Vsc2UgaWYoKDMyfGwpLTk3Pj4+MDxiKWY9KDMyfGwpLTg3O2Vsc2V7eT0hMDticmVha31pZihwKz1vLEQ9RDw8b3xmLCsrbj09PV8pe3k9ITA7YnJlYWt9aWYobD1lLmNoYXJDb2RlQXQobiksMzA8cCtvKWJyZWFrfWMucHVzaChEKSx2LnB1c2gocCl9d2hpbGUoIXkpO2EuX19maWxsRnJvbVBhcnRzKHIsYyx2KX1lbHNle3IuX19pbml0aWFsaXplRGlnaXRzKCk7dmFyIGs9ITEsQj0wO2Rve2Zvcih2YXIgUyxDPTAsST0xOzspe2lmKFM9dm9pZCAwLGwtNDg+Pj4wPGgpUz1sLTQ4O2Vsc2UgaWYoKDMyfGwpLTk3Pj4+MDxiKVM9KDMyfGwpLTg3O2Vsc2V7az0hMDticmVha312YXIgQT1JKnQ7aWYoMTA3Mzc0MTgyMzxBKWJyZWFrO2lmKEk9QSxDPUMqdCtTLEIrKywrK249PT1fKXtrPSEwO2JyZWFrfWw9ZS5jaGFyQ29kZUF0KG4pfXU9MzAqYS5fX2tCaXRzUGVyQ2hhclRhYmxlTXVsdGlwbGllci0xO3ZhciBtPTB8KG8qQit1Pj4+YS5fX2tCaXRzUGVyQ2hhclRhYmxlU2hpZnQpLzMwO3IuX19pbnBsYWNlTXVsdGlwbHlBZGQoSSxDLG0pfXdoaWxlKCFrKX1pZihuIT09Xyl7aWYoIWEuX19pc1doaXRlc3BhY2UobCkpcmV0dXJuIG51bGw7Zm9yKG4rKztuPF87bisrKWlmKGw9ZS5jaGFyQ29kZUF0KG4pLCFhLl9faXNXaGl0ZXNwYWNlKGwpKXJldHVybiBudWxsfXJldHVybiByLnNpZ249LTE9PT1pLHIuX190cmltKCl9fSx7a2V5OlwiX19maWxsRnJvbVBhcnRzXCIsdmFsdWU6ZnVuY3Rpb24oZSx0LF8pe2Zvcih2YXIgbj0wLGw9MCxnPTAsbz10Lmxlbmd0aC0xOzA8PW87by0tKXt2YXIgYT10W29dLHU9X1tvXTtsfD1hPDxnLGcrPXUsMzA9PT1nPyhlLl9fc2V0RGlnaXQobisrLGwpLGc9MCxsPTApOjMwPGcmJihlLl9fc2V0RGlnaXQobisrLDEwNzM3NDE4MjMmbCksZy09MzAsbD1hPj4+dS1nKX1pZigwIT09bCl7aWYobj49ZS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiaW1wbGVtZW50YXRpb24gYnVnXCIpO2UuX19zZXREaWdpdChuKyssbCl9Zm9yKDtuPGUubGVuZ3RoO24rKyllLl9fc2V0RGlnaXQobiwwKX19LHtrZXk6XCJfX3RvU3RyaW5nQmFzZVBvd2VyT2ZUd29cIix2YWx1ZTpmdW5jdGlvbihlLHQpe3ZhciBfPWUubGVuZ3RoLG49dC0xO249KDg1Jm4+Pj4xKSsoODUmbiksbj0oNTEmbj4+PjIpKyg1MSZuKSxuPSgxNSZuPj4+NCkrKDE1Jm4pO3ZhciBsPW4sZz10LTEsbz1lLl9fZGlnaXQoXy0xKSx1PWEuX19jbHozMChvKSxzPTB8KDMwKl8tdStsLTEpL2w7aWYoZS5zaWduJiZzKyssMjY4NDM1NDU2PHMpdGhyb3cgbmV3IEVycm9yKFwic3RyaW5nIHRvbyBsb25nXCIpO2Zvcih2YXIgcj1BcnJheShzKSxkPXMtMSxoPTAsYj0wLG09MDttPF8tMTttKyspe3ZhciBjPWUuX19kaWdpdChtKSx2PShofGM8PGIpJmc7cltkLS1dPWEuX19rQ29udmVyc2lvbkNoYXJzW3ZdO3ZhciB5PWwtYjtmb3IoaD1jPj4+eSxiPTMwLXk7Yj49bDspcltkLS1dPWEuX19rQ29udmVyc2lvbkNoYXJzW2gmZ10saD4+Pj1sLGItPWx9dmFyIGY9KGh8bzw8YikmZztmb3IocltkLS1dPWEuX19rQ29udmVyc2lvbkNoYXJzW2ZdLGg9bz4+PmwtYjswIT09aDspcltkLS1dPWEuX19rQ29udmVyc2lvbkNoYXJzW2gmZ10saD4+Pj1sO2lmKGUuc2lnbiYmKHJbZC0tXT1cIi1cIiksLTEhPT1kKXRocm93IG5ldyBFcnJvcihcImltcGxlbWVudGF0aW9uIGJ1Z1wiKTtyZXR1cm4gci5qb2luKFwiXCIpfX0se2tleTpcIl9fdG9TdHJpbmdHZW5lcmljXCIsdmFsdWU6ZnVuY3Rpb24oZSx0LF8pe3ZhciBuPWUubGVuZ3RoO2lmKDA9PT1uKXJldHVyblwiXCI7aWYoMT09PW4pe3ZhciBsPWUuX191bnNpZ25lZERpZ2l0KDApLnRvU3RyaW5nKHQpO3JldHVybiExPT09XyYmZS5zaWduJiYobD1cIi1cIitsKSxsfXZhciBnPTMwKm4tYS5fX2NsejMwKGUuX19kaWdpdChuLTEpKSxvPWEuX19rTWF4Qml0c1BlckNoYXJbdF0sdT1vLTEscz1nKmEuX19rQml0c1BlckNoYXJUYWJsZU11bHRpcGxpZXI7cys9dS0xLHM9MHxzL3U7dmFyIHIsZCxoPXMrMT4+MSxiPWEuZXhwb25lbnRpYXRlKGEuX19vbmVEaWdpdCh0LCExKSxhLl9fb25lRGlnaXQoaCwhMSkpLG09Yi5fX3Vuc2lnbmVkRGlnaXQoMCk7aWYoMT09PWIubGVuZ3RoJiYzMjc2Nz49bSl7cj1uZXcgYShlLmxlbmd0aCwhMSksci5fX2luaXRpYWxpemVEaWdpdHMoKTtmb3IodmFyIGMsdj0wLHk9MiplLmxlbmd0aC0xOzA8PXk7eS0tKWM9djw8MTV8ZS5fX2hhbGZEaWdpdCh5KSxyLl9fc2V0SGFsZkRpZ2l0KHksMHxjL20pLHY9MHxjJW07ZD12LnRvU3RyaW5nKHQpfWVsc2V7dmFyIGY9YS5fX2Fic29sdXRlRGl2TGFyZ2UoZSxiLCEwLCEwKTtyPWYucXVvdGllbnQ7dmFyIEQ9Zi5yZW1haW5kZXIuX190cmltKCk7ZD1hLl9fdG9TdHJpbmdHZW5lcmljKEQsdCwhMCl9ci5fX3RyaW0oKTtmb3IodmFyIHA9YS5fX3RvU3RyaW5nR2VuZXJpYyhyLHQsITApO2QubGVuZ3RoPGg7KWQ9XCIwXCIrZDtyZXR1cm4hMT09PV8mJmUuc2lnbiYmKHA9XCItXCIrcCkscCtkfX0se2tleTpcIl9fdW5lcXVhbFNpZ25cIix2YWx1ZTpmdW5jdGlvbihlKXtyZXR1cm4gZT8tMToxfX0se2tleTpcIl9fYWJzb2x1dGVHcmVhdGVyXCIsdmFsdWU6ZnVuY3Rpb24oZSl7cmV0dXJuIGU/LTE6MX19LHtrZXk6XCJfX2Fic29sdXRlTGVzc1wiLHZhbHVlOmZ1bmN0aW9uKGUpe3JldHVybiBlPzE6LTF9fSx7a2V5OlwiX19jb21wYXJlVG9CaWdJbnRcIix2YWx1ZTpmdW5jdGlvbihlLHQpe3ZhciBpPWUuc2lnbjtpZihpIT09dC5zaWduKXJldHVybiBhLl9fdW5lcXVhbFNpZ24oaSk7dmFyIF89YS5fX2Fic29sdXRlQ29tcGFyZShlLHQpO3JldHVybiAwPF8/YS5fX2Fic29sdXRlR3JlYXRlcihpKTowPl8/YS5fX2Fic29sdXRlTGVzcyhpKTowfX0se2tleTpcIl9fY29tcGFyZVRvTnVtYmVyXCIsdmFsdWU6ZnVuY3Rpb24oZSxpKXtpZihhLl9faXNPbmVEaWdpdEludChpKSl7dmFyIF89ZS5zaWduLG49MD5pO2lmKF8hPT1uKXJldHVybiBhLl9fdW5lcXVhbFNpZ24oXyk7aWYoMD09PWUubGVuZ3RoKXtpZihuKXRocm93IG5ldyBFcnJvcihcImltcGxlbWVudGF0aW9uIGJ1Z1wiKTtyZXR1cm4gMD09PWk/MDotMX1pZigxPGUubGVuZ3RoKXJldHVybiBhLl9fYWJzb2x1dGVHcmVhdGVyKF8pO3ZhciBsPXQoaSksZz1lLl9fdW5zaWduZWREaWdpdCgwKTtyZXR1cm4gZz5sP2EuX19hYnNvbHV0ZUdyZWF0ZXIoXyk6ZzxsP2EuX19hYnNvbHV0ZUxlc3MoXyk6MH1yZXR1cm4gYS5fX2NvbXBhcmVUb0RvdWJsZShlLGkpfX0se2tleTpcIl9fY29tcGFyZVRvRG91YmxlXCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXtpZih0IT09dClyZXR1cm4gdDtpZih0PT09MS8wKXJldHVybi0xO2lmKHQ9PT0tSW5maW5pdHkpcmV0dXJuIDE7dmFyIGk9ZS5zaWduO2lmKGkhPT0wPnQpcmV0dXJuIGEuX191bmVxdWFsU2lnbihpKTtpZigwPT09dCl0aHJvdyBuZXcgRXJyb3IoXCJpbXBsZW1lbnRhdGlvbiBidWc6IHNob3VsZCBiZSBoYW5kbGVkIGVsc2V3aGVyZVwiKTtpZigwPT09ZS5sZW5ndGgpcmV0dXJuLTE7YS5fX2tCaXRDb252ZXJzaW9uRG91YmxlWzBdPXQ7dmFyIF89MjA0NyZhLl9fa0JpdENvbnZlcnNpb25JbnRzWzFdPj4+MjA7aWYoMjA0Nz09Xyl0aHJvdyBuZXcgRXJyb3IoXCJpbXBsZW1lbnRhdGlvbiBidWc6IGhhbmRsZWQgZWxzZXdoZXJlXCIpO3ZhciBuPV8tMTAyMztpZigwPm4pcmV0dXJuIGEuX19hYnNvbHV0ZUdyZWF0ZXIoaSk7dmFyIGw9ZS5sZW5ndGgsZz1lLl9fZGlnaXQobC0xKSxvPWEuX19jbHozMChnKSx1PTMwKmwtbyxzPW4rMTtpZih1PHMpcmV0dXJuIGEuX19hYnNvbHV0ZUxlc3MoaSk7aWYodT5zKXJldHVybiBhLl9fYWJzb2x1dGVHcmVhdGVyKGkpO3ZhciByPTEwNDg1NzZ8MTA0ODU3NSZhLl9fa0JpdENvbnZlcnNpb25JbnRzWzFdLGQ9YS5fX2tCaXRDb252ZXJzaW9uSW50c1swXSxoPTIwLGI9MjktbztpZihiIT09KDB8KHUtMSklMzApKXRocm93IG5ldyBFcnJvcihcImltcGxlbWVudGF0aW9uIGJ1Z1wiKTt2YXIgbSxjPTA7aWYoYjxoKXt2YXIgdj1oLWI7Yz12KzMyLG09cj4+PnYscj1yPDwzMi12fGQ+Pj52LGQ8PD0zMi12fWVsc2UgaWYoYj09PWgpYz0zMixtPXIscj1kLGQ9MDtlbHNle3ZhciB5PWItaDtjPTMyLXksbT1yPDx5fGQ+Pj4zMi15LHI9ZDw8eSxkPTB9aWYoZz4+Pj0wLG0+Pj49MCxnPm0pcmV0dXJuIGEuX19hYnNvbHV0ZUdyZWF0ZXIoaSk7aWYoZzxtKXJldHVybiBhLl9fYWJzb2x1dGVMZXNzKGkpO2Zvcih2YXIgZj1sLTI7MDw9ZjtmLS0pezA8Yz8oYy09MzAsbT1yPj4+MixyPXI8PDMwfGQ+Pj4yLGQ8PD0zMCk6bT0wO3ZhciBEPWUuX191bnNpZ25lZERpZ2l0KGYpO2lmKEQ+bSlyZXR1cm4gYS5fX2Fic29sdXRlR3JlYXRlcihpKTtpZihEPG0pcmV0dXJuIGEuX19hYnNvbHV0ZUxlc3MoaSl9aWYoMCE9PXJ8fDAhPT1kKXtpZigwPT09Yyl0aHJvdyBuZXcgRXJyb3IoXCJpbXBsZW1lbnRhdGlvbiBidWdcIik7cmV0dXJuIGEuX19hYnNvbHV0ZUxlc3MoaSl9cmV0dXJuIDB9fSx7a2V5OlwiX19lcXVhbFRvTnVtYmVyXCIsdmFsdWU6ZnVuY3Rpb24oZSxpKXtyZXR1cm4gYS5fX2lzT25lRGlnaXRJbnQoaSk/MD09PWk/MD09PWUubGVuZ3RoOjE9PT1lLmxlbmd0aCYmZS5zaWduPT09MD5pJiZlLl9fdW5zaWduZWREaWdpdCgwKT09PXQoaSk6MD09PWEuX19jb21wYXJlVG9Eb3VibGUoZSxpKX19LHtrZXk6XCJfX2NvbXBhcmlzb25SZXN1bHRUb0Jvb2xcIix2YWx1ZTpmdW5jdGlvbihlLHQpe3JldHVybiAwPT09dD8wPmU6MT09PXQ/MD49ZToyPT09dD8wPGU6Mz09PXQ/MDw9ZTp2b2lkIDB9fSx7a2V5OlwiX19jb21wYXJlXCIsdmFsdWU6ZnVuY3Rpb24oZSx0LGkpe2lmKGU9YS5fX3RvUHJpbWl0aXZlKGUpLHQ9YS5fX3RvUHJpbWl0aXZlKHQpLFwic3RyaW5nXCI9PXR5cGVvZiBlJiZcInN0cmluZ1wiPT10eXBlb2YgdClzd2l0Y2goaSl7Y2FzZSAwOnJldHVybiBlPHQ7Y2FzZSAxOnJldHVybiBlPD10O2Nhc2UgMjpyZXR1cm4gZT50O2Nhc2UgMzpyZXR1cm4gZT49dDt9aWYoYS5fX2lzQmlnSW50KGUpJiZcInN0cmluZ1wiPT10eXBlb2YgdClyZXR1cm4gdD1hLl9fZnJvbVN0cmluZyh0KSxudWxsIT09dCYmYS5fX2NvbXBhcmlzb25SZXN1bHRUb0Jvb2woYS5fX2NvbXBhcmVUb0JpZ0ludChlLHQpLGkpO2lmKFwic3RyaW5nXCI9PXR5cGVvZiBlJiZhLl9faXNCaWdJbnQodCkpcmV0dXJuIGU9YS5fX2Zyb21TdHJpbmcoZSksbnVsbCE9PWUmJmEuX19jb21wYXJpc29uUmVzdWx0VG9Cb29sKGEuX19jb21wYXJlVG9CaWdJbnQoZSx0KSxpKTtpZihlPWEuX190b051bWVyaWMoZSksdD1hLl9fdG9OdW1lcmljKHQpLGEuX19pc0JpZ0ludChlKSl7aWYoYS5fX2lzQmlnSW50KHQpKXJldHVybiBhLl9fY29tcGFyaXNvblJlc3VsdFRvQm9vbChhLl9fY29tcGFyZVRvQmlnSW50KGUsdCksaSk7aWYoXCJudW1iZXJcIiE9dHlwZW9mIHQpdGhyb3cgbmV3IEVycm9yKFwiaW1wbGVtZW50YXRpb24gYnVnXCIpO3JldHVybiBhLl9fY29tcGFyaXNvblJlc3VsdFRvQm9vbChhLl9fY29tcGFyZVRvTnVtYmVyKGUsdCksaSl9aWYoXCJudW1iZXJcIiE9dHlwZW9mIGUpdGhyb3cgbmV3IEVycm9yKFwiaW1wbGVtZW50YXRpb24gYnVnXCIpO2lmKGEuX19pc0JpZ0ludCh0KSlyZXR1cm4gYS5fX2NvbXBhcmlzb25SZXN1bHRUb0Jvb2woYS5fX2NvbXBhcmVUb051bWJlcih0LGUpLDJeaSk7aWYoXCJudW1iZXJcIiE9dHlwZW9mIHQpdGhyb3cgbmV3IEVycm9yKFwiaW1wbGVtZW50YXRpb24gYnVnXCIpO3JldHVybiAwPT09aT9lPHQ6MT09PWk/ZTw9dDoyPT09aT9lPnQ6Mz09PWk/ZT49dDp2b2lkIDB9fSx7a2V5OlwiX19hYnNvbHV0ZUFkZFwiLHZhbHVlOmZ1bmN0aW9uKGUsdCxfKXtpZihlLmxlbmd0aDx0Lmxlbmd0aClyZXR1cm4gYS5fX2Fic29sdXRlQWRkKHQsZSxfKTtpZigwPT09ZS5sZW5ndGgpcmV0dXJuIGU7aWYoMD09PXQubGVuZ3RoKXJldHVybiBlLnNpZ249PT1fP2U6YS51bmFyeU1pbnVzKGUpO3ZhciBuPWUubGVuZ3RoOygwPT09ZS5fX2Nsem1zZCgpfHx0Lmxlbmd0aD09PWUubGVuZ3RoJiYwPT09dC5fX2Nsem1zZCgpKSYmbisrO2Zvcih2YXIgbCxnPW5ldyBhKG4sXyksbz0wLHU9MDt1PHQubGVuZ3RoO3UrKylsPWUuX19kaWdpdCh1KSt0Ll9fZGlnaXQodSkrbyxvPWw+Pj4zMCxnLl9fc2V0RGlnaXQodSwxMDczNzQxODIzJmwpO2Zvcig7dTxlLmxlbmd0aDt1Kyspe3ZhciBzPWUuX19kaWdpdCh1KStvO289cz4+PjMwLGcuX19zZXREaWdpdCh1LDEwNzM3NDE4MjMmcyl9cmV0dXJuIHU8Zy5sZW5ndGgmJmcuX19zZXREaWdpdCh1LG8pLGcuX190cmltKCl9fSx7a2V5OlwiX19hYnNvbHV0ZVN1YlwiLHZhbHVlOmZ1bmN0aW9uKGUsdCxfKXtpZigwPT09ZS5sZW5ndGgpcmV0dXJuIGU7aWYoMD09PXQubGVuZ3RoKXJldHVybiBlLnNpZ249PT1fP2U6YS51bmFyeU1pbnVzKGUpO2Zvcih2YXIgbixsPW5ldyBhKGUubGVuZ3RoLF8pLGc9MCxvPTA7bzx0Lmxlbmd0aDtvKyspbj1lLl9fZGlnaXQobyktdC5fX2RpZ2l0KG8pLWcsZz0xJm4+Pj4zMCxsLl9fc2V0RGlnaXQobywxMDczNzQxODIzJm4pO2Zvcig7bzxlLmxlbmd0aDtvKyspe3ZhciB1PWUuX19kaWdpdChvKS1nO2c9MSZ1Pj4+MzAsbC5fX3NldERpZ2l0KG8sMTA3Mzc0MTgyMyZ1KX1yZXR1cm4gbC5fX3RyaW0oKX19LHtrZXk6XCJfX2Fic29sdXRlQWRkT25lXCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXt2YXIgXz0yPGFyZ3VtZW50cy5sZW5ndGgmJnZvaWQgMCE9PWFyZ3VtZW50c1syXT9hcmd1bWVudHNbMl06bnVsbCxuPWUubGVuZ3RoO251bGw9PT1fP189bmV3IGEobix0KTpfLnNpZ249dDtmb3IodmFyIGwsZz0xLG89MDtvPG47bysrKWw9ZS5fX2RpZ2l0KG8pK2csZz1sPj4+MzAsXy5fX3NldERpZ2l0KG8sMTA3Mzc0MTgyMyZsKTtyZXR1cm4gMCE9PWcmJl8uX19zZXREaWdpdEdyb3cobiwxKSxffX0se2tleTpcIl9fYWJzb2x1dGVTdWJPbmVcIix2YWx1ZTpmdW5jdGlvbihlLHQpe3ZhciBfPWUubGVuZ3RoO3Q9dHx8Xztmb3IodmFyIG4sbD1uZXcgYSh0LCExKSxnPTEsbz0wO288XztvKyspbj1lLl9fZGlnaXQobyktZyxnPTEmbj4+PjMwLGwuX19zZXREaWdpdChvLDEwNzM3NDE4MjMmbik7aWYoMCE9PWcpdGhyb3cgbmV3IEVycm9yKFwiaW1wbGVtZW50YXRpb24gYnVnXCIpO2Zvcih2YXIgdT1fO3U8dDt1KyspbC5fX3NldERpZ2l0KHUsMCk7cmV0dXJuIGx9fSx7a2V5OlwiX19hYnNvbHV0ZUFuZFwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7dmFyIF89Mjxhcmd1bWVudHMubGVuZ3RoJiZ2b2lkIDAhPT1hcmd1bWVudHNbMl0/YXJndW1lbnRzWzJdOm51bGwsbj1lLmxlbmd0aCxsPXQubGVuZ3RoLGc9bDtpZihuPGwpe2c9bjt2YXIgbz1lLHU9bjtlPXQsbj1sLHQ9byxsPXV9dmFyIHM9ZztudWxsPT09Xz9fPW5ldyBhKHMsITEpOnM9Xy5sZW5ndGg7Zm9yKHZhciByPTA7cjxnO3IrKylfLl9fc2V0RGlnaXQocixlLl9fZGlnaXQocikmdC5fX2RpZ2l0KHIpKTtmb3IoO3I8cztyKyspXy5fX3NldERpZ2l0KHIsMCk7cmV0dXJuIF99fSx7a2V5OlwiX19hYnNvbHV0ZUFuZE5vdFwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7dmFyIF89Mjxhcmd1bWVudHMubGVuZ3RoJiZ2b2lkIDAhPT1hcmd1bWVudHNbMl0/YXJndW1lbnRzWzJdOm51bGwsbj1lLmxlbmd0aCxsPXQubGVuZ3RoLGc9bDtuPGwmJihnPW4pO3ZhciBvPW47bnVsbD09PV8/Xz1uZXcgYShvLCExKTpvPV8ubGVuZ3RoO2Zvcih2YXIgdT0wO3U8Zzt1KyspXy5fX3NldERpZ2l0KHUsZS5fX2RpZ2l0KHUpJn50Ll9fZGlnaXQodSkpO2Zvcig7dTxuO3UrKylfLl9fc2V0RGlnaXQodSxlLl9fZGlnaXQodSkpO2Zvcig7dTxvO3UrKylfLl9fc2V0RGlnaXQodSwwKTtyZXR1cm4gX319LHtrZXk6XCJfX2Fic29sdXRlT3JcIix2YWx1ZTpmdW5jdGlvbihlLHQpe3ZhciBfPTI8YXJndW1lbnRzLmxlbmd0aCYmdm9pZCAwIT09YXJndW1lbnRzWzJdP2FyZ3VtZW50c1syXTpudWxsLG49ZS5sZW5ndGgsbD10Lmxlbmd0aCxnPWw7aWYobjxsKXtnPW47dmFyIG89ZSx1PW47ZT10LG49bCx0PW8sbD11fXZhciBzPW47bnVsbD09PV8/Xz1uZXcgYShzLCExKTpzPV8ubGVuZ3RoO2Zvcih2YXIgcj0wO3I8ZztyKyspXy5fX3NldERpZ2l0KHIsZS5fX2RpZ2l0KHIpfHQuX19kaWdpdChyKSk7Zm9yKDtyPG47cisrKV8uX19zZXREaWdpdChyLGUuX19kaWdpdChyKSk7Zm9yKDtyPHM7cisrKV8uX19zZXREaWdpdChyLDApO3JldHVybiBffX0se2tleTpcIl9fYWJzb2x1dGVYb3JcIix2YWx1ZTpmdW5jdGlvbihlLHQpe3ZhciBfPTI8YXJndW1lbnRzLmxlbmd0aCYmdm9pZCAwIT09YXJndW1lbnRzWzJdP2FyZ3VtZW50c1syXTpudWxsLG49ZS5sZW5ndGgsbD10Lmxlbmd0aCxnPWw7aWYobjxsKXtnPW47dmFyIG89ZSx1PW47ZT10LG49bCx0PW8sbD11fXZhciBzPW47bnVsbD09PV8/Xz1uZXcgYShzLCExKTpzPV8ubGVuZ3RoO2Zvcih2YXIgcj0wO3I8ZztyKyspXy5fX3NldERpZ2l0KHIsZS5fX2RpZ2l0KHIpXnQuX19kaWdpdChyKSk7Zm9yKDtyPG47cisrKV8uX19zZXREaWdpdChyLGUuX19kaWdpdChyKSk7Zm9yKDtyPHM7cisrKV8uX19zZXREaWdpdChyLDApO3JldHVybiBffX0se2tleTpcIl9fYWJzb2x1dGVDb21wYXJlXCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXt2YXIgXz1lLmxlbmd0aC10Lmxlbmd0aDtpZigwIT1fKXJldHVybiBfO2Zvcih2YXIgbj1lLmxlbmd0aC0xOzA8PW4mJmUuX19kaWdpdChuKT09PXQuX19kaWdpdChuKTspbi0tO3JldHVybiAwPm4/MDplLl9fdW5zaWduZWREaWdpdChuKT50Ll9fdW5zaWduZWREaWdpdChuKT8xOi0xfX0se2tleTpcIl9fbXVsdGlwbHlBY2N1bXVsYXRlXCIsdmFsdWU6ZnVuY3Rpb24oZSx0LF8sbil7aWYoMCE9PXQpe2Zvcih2YXIgbD0zMjc2NyZ0LGc9dD4+PjE1LG89MCx1PTAscz0wO3M8ZS5sZW5ndGg7cysrLG4rKyl7dmFyIHI9Xy5fX2RpZ2l0KG4pLGQ9ZS5fX2RpZ2l0KHMpLGg9MzI3NjcmZCxiPWQ+Pj4xNSxtPWEuX19pbXVsKGgsbCksYz1hLl9faW11bChoLGcpLHY9YS5fX2ltdWwoYixsKSx5PWEuX19pbXVsKGIsZyk7cis9dSttK28sbz1yPj4+MzAsciY9MTA3Mzc0MTgyMyxyKz0oKDMyNzY3JmMpPDwxNSkrKCgzMjc2NyZ2KTw8MTUpLG8rPXI+Pj4zMCx1PXkrKGM+Pj4xNSkrKHY+Pj4xNSksXy5fX3NldERpZ2l0KG4sMTA3Mzc0MTgyMyZyKX1mb3IoOzAhPT1vfHwwIT09dTtuKyspe3ZhciBmPV8uX19kaWdpdChuKTtmKz1vK3UsdT0wLG89Zj4+PjMwLF8uX19zZXREaWdpdChuLDEwNzM3NDE4MjMmZil9fX19LHtrZXk6XCJfX2ludGVybmFsTXVsdGlwbHlBZGRcIix2YWx1ZTpmdW5jdGlvbihlLHQsXyxsLGcpe2Zvcih2YXIgbz1fLHU9MCxzPTA7czxsO3MrKyl7dmFyIGQ9ZS5fX2RpZ2l0KHMpLGg9YS5fX2ltdWwoMzI3NjcmZCx0KSxiPWEuX19pbXVsKGQ+Pj4xNSx0KSxtPWgrKCgzMjc2NyZiKTw8MTUpK3UrbztvPW0+Pj4zMCx1PWI+Pj4xNSxnLl9fc2V0RGlnaXQocywxMDczNzQxODIzJm0pfWlmKGcubGVuZ3RoPmwpZm9yKGcuX19zZXREaWdpdChsKyssbyt1KTtsPGcubGVuZ3RoOylnLl9fc2V0RGlnaXQobCsrLDApO2Vsc2UgaWYoMCE9PW8rdSl0aHJvdyBuZXcgRXJyb3IoXCJpbXBsZW1lbnRhdGlvbiBidWdcIil9fSx7a2V5OlwiX19hYnNvbHV0ZURpdlNtYWxsXCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXt2YXIgXz0yPGFyZ3VtZW50cy5sZW5ndGgmJnZvaWQgMCE9PWFyZ3VtZW50c1syXT9hcmd1bWVudHNbMl06bnVsbDtudWxsPT09XyYmKF89bmV3IGEoZS5sZW5ndGgsITEpKTtmb3IodmFyIG49MCxsPTIqZS5sZW5ndGgtMTswPD1sO2wtPTIpe3ZhciBnPShuPDwxNXxlLl9faGFsZkRpZ2l0KGwpKT4+PjAsbz0wfGcvdDtuPTB8ZyV0LGc9KG48PDE1fGUuX19oYWxmRGlnaXQobC0xKSk+Pj4wO3ZhciB1PTB8Zy90O249MHxnJXQsXy5fX3NldERpZ2l0KGw+Pj4xLG88PDE1fHUpfXJldHVybiBffX0se2tleTpcIl9fYWJzb2x1dGVNb2RTbWFsbFwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7Zm9yKHZhciBfLG49MCxsPTIqZS5sZW5ndGgtMTswPD1sO2wtLSlfPShuPDwxNXxlLl9faGFsZkRpZ2l0KGwpKT4+PjAsbj0wfF8ldDtyZXR1cm4gbn19LHtrZXk6XCJfX2Fic29sdXRlRGl2TGFyZ2VcIix2YWx1ZTpmdW5jdGlvbihlLHQsaSxfKXt2YXIgbD10Ll9faGFsZkRpZ2l0TGVuZ3RoKCksbj10Lmxlbmd0aCxnPWUuX19oYWxmRGlnaXRMZW5ndGgoKS1sLG89bnVsbDtpJiYobz1uZXcgYShnKzI+Pj4xLCExKSxvLl9faW5pdGlhbGl6ZURpZ2l0cygpKTt2YXIgcz1uZXcgYShsKzI+Pj4xLCExKTtzLl9faW5pdGlhbGl6ZURpZ2l0cygpO3ZhciByPWEuX19jbHoxNSh0Ll9faGFsZkRpZ2l0KGwtMSkpOzA8ciYmKHQ9YS5fX3NwZWNpYWxMZWZ0U2hpZnQodCxyLDApKTtmb3IodmFyIGQ9YS5fX3NwZWNpYWxMZWZ0U2hpZnQoZSxyLDEpLHU9dC5fX2hhbGZEaWdpdChsLTEpLGg9MCxiPWc7MDw9YjtiLS0pe3ZhciBtPTMyNzY3LHY9ZC5fX2hhbGZEaWdpdChiK2wpO2lmKHYhPT11KXt2YXIgeT0odjw8MTV8ZC5fX2hhbGZEaWdpdChiK2wtMSkpPj4+MDttPTB8eS91O2Zvcih2YXIgZj0wfHkldSxEPXQuX19oYWxmRGlnaXQobC0yKSxwPWQuX19oYWxmRGlnaXQoYitsLTIpO2EuX19pbXVsKG0sRCk+Pj4wPihmPDwxNnxwKT4+PjAmJihtLS0sZis9dSwhKDMyNzY3PGYpKTspO31hLl9faW50ZXJuYWxNdWx0aXBseUFkZCh0LG0sMCxuLHMpO3ZhciBrPWQuX19pbnBsYWNlU3ViKHMsYixsKzEpOzAhPT1rJiYoaz1kLl9faW5wbGFjZUFkZCh0LGIsbCksZC5fX3NldEhhbGZEaWdpdChiK2wsMzI3NjcmZC5fX2hhbGZEaWdpdChiK2wpK2spLG0tLSksaSYmKDEmYj9oPW08PDE1Om8uX19zZXREaWdpdChiPj4+MSxofG0pKX1pZihfKXJldHVybiBkLl9faW5wbGFjZVJpZ2h0U2hpZnQociksaT97cXVvdGllbnQ6byxyZW1haW5kZXI6ZH06ZDtpZihpKXJldHVybiBvO3Rocm93IG5ldyBFcnJvcihcInVucmVhY2hhYmxlXCIpfX0se2tleTpcIl9fY2x6MTVcIix2YWx1ZTpmdW5jdGlvbihlKXtyZXR1cm4gYS5fX2NsejMwKGUpLTE1fX0se2tleTpcIl9fc3BlY2lhbExlZnRTaGlmdFwiLHZhbHVlOmZ1bmN0aW9uKGUsdCxfKXt2YXIgbD1lLmxlbmd0aCxuPW5ldyBhKGwrXywhMSk7aWYoMD09PXQpe2Zvcih2YXIgZz0wO2c8bDtnKyspbi5fX3NldERpZ2l0KGcsZS5fX2RpZ2l0KGcpKTtyZXR1cm4gMDxfJiZuLl9fc2V0RGlnaXQobCwwKSxufWZvcih2YXIgbyx1PTAscz0wO3M8bDtzKyspbz1lLl9fZGlnaXQocyksbi5fX3NldERpZ2l0KHMsMTA3Mzc0MTgyMyZvPDx0fHUpLHU9bz4+PjMwLXQ7cmV0dXJuIDA8XyYmbi5fX3NldERpZ2l0KGwsdSksbn19LHtrZXk6XCJfX2xlZnRTaGlmdEJ5QWJzb2x1dGVcIix2YWx1ZTpmdW5jdGlvbihlLHQpe3ZhciBfPWEuX190b1NoaWZ0QW1vdW50KHQpO2lmKDA+Xyl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkJpZ0ludCB0b28gYmlnXCIpO3ZhciBuPTB8Xy8zMCxsPV8lMzAsZz1lLmxlbmd0aCxvPTAhPT1sJiYwIT1lLl9fZGlnaXQoZy0xKT4+PjMwLWwsdT1nK24rKG8/MTowKSxzPW5ldyBhKHUsZS5zaWduKTtpZigwPT09bCl7Zm9yKHZhciByPTA7cjxuO3IrKylzLl9fc2V0RGlnaXQociwwKTtmb3IoO3I8dTtyKyspcy5fX3NldERpZ2l0KHIsZS5fX2RpZ2l0KHItbikpfWVsc2V7Zm9yKHZhciBoPTAsYj0wO2I8bjtiKyspcy5fX3NldERpZ2l0KGIsMCk7Zm9yKHZhciBtLGM9MDtjPGc7YysrKW09ZS5fX2RpZ2l0KGMpLHMuX19zZXREaWdpdChjK24sMTA3Mzc0MTgyMyZtPDxsfGgpLGg9bT4+PjMwLWw7aWYobylzLl9fc2V0RGlnaXQoZytuLGgpO2Vsc2UgaWYoMCE9PWgpdGhyb3cgbmV3IEVycm9yKFwiaW1wbGVtZW50YXRpb24gYnVnXCIpfXJldHVybiBzLl9fdHJpbSgpfX0se2tleTpcIl9fcmlnaHRTaGlmdEJ5QWJzb2x1dGVcIix2YWx1ZTpmdW5jdGlvbihlLHQpe3ZhciBfPWUubGVuZ3RoLG49ZS5zaWduLGw9YS5fX3RvU2hpZnRBbW91bnQodCk7aWYoMD5sKXJldHVybiBhLl9fcmlnaHRTaGlmdEJ5TWF4aW11bShuKTt2YXIgZz0wfGwvMzAsbz1sJTMwLHU9Xy1nO2lmKDA+PXUpcmV0dXJuIGEuX19yaWdodFNoaWZ0QnlNYXhpbXVtKG4pO3ZhciBzPSExO2lmKG4pe2lmKDAhPShlLl9fZGlnaXQoZykmKDE8PG8pLTEpKXM9ITA7ZWxzZSBmb3IodmFyIHI9MDtyPGc7cisrKWlmKDAhPT1lLl9fZGlnaXQocikpe3M9ITA7YnJlYWt9fWlmKHMmJjA9PT1vKXt2YXIgaD1lLl9fZGlnaXQoXy0xKTswPT1+aCYmdSsrfXZhciBiPW5ldyBhKHUsbik7aWYoMD09PW8pe2IuX19zZXREaWdpdCh1LTEsMCk7Zm9yKHZhciBtPWc7bTxfO20rKyliLl9fc2V0RGlnaXQobS1nLGUuX19kaWdpdChtKSl9ZWxzZXtmb3IodmFyIGMsdj1lLl9fZGlnaXQoZyk+Pj5vLHk9Xy1nLTEsZj0wO2Y8eTtmKyspYz1lLl9fZGlnaXQoZitnKzEpLGIuX19zZXREaWdpdChmLDEwNzM3NDE4MjMmYzw8MzAtb3x2KSx2PWM+Pj5vO2IuX19zZXREaWdpdCh5LHYpfXJldHVybiBzJiYoYj1hLl9fYWJzb2x1dGVBZGRPbmUoYiwhMCxiKSksYi5fX3RyaW0oKX19LHtrZXk6XCJfX3JpZ2h0U2hpZnRCeU1heGltdW1cIix2YWx1ZTpmdW5jdGlvbihlKXtyZXR1cm4gZT9hLl9fb25lRGlnaXQoMSwhMCk6YS5fX3plcm8oKX19LHtrZXk6XCJfX3RvU2hpZnRBbW91bnRcIix2YWx1ZTpmdW5jdGlvbihlKXtpZigxPGUubGVuZ3RoKXJldHVybi0xO3ZhciB0PWUuX191bnNpZ25lZERpZ2l0KDApO3JldHVybiB0PmEuX19rTWF4TGVuZ3RoQml0cz8tMTp0fX0se2tleTpcIl9fdG9QcmltaXRpdmVcIix2YWx1ZTpmdW5jdGlvbihlKXt2YXIgdD0xPGFyZ3VtZW50cy5sZW5ndGgmJnZvaWQgMCE9PWFyZ3VtZW50c1sxXT9hcmd1bWVudHNbMV06XCJkZWZhdWx0XCI7aWYoXCJvYmplY3RcIiE9PWkoZSkpcmV0dXJuIGU7aWYoZS5jb25zdHJ1Y3Rvcj09PWEpcmV0dXJuIGU7aWYoXCJ1bmRlZmluZWRcIiE9dHlwZW9mIFN5bWJvbCYmXCJzeW1ib2xcIj09PWkoU3ltYm9sLnRvUHJpbWl0aXZlKSl7dmFyIF89ZVtTeW1ib2wudG9QcmltaXRpdmVdO2lmKF8pe3ZhciBuPV8odCk7aWYoXCJvYmplY3RcIiE9PWkobikpcmV0dXJuIG47dGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjb252ZXJ0IG9iamVjdCB0byBwcmltaXRpdmUgdmFsdWVcIil9fXZhciBsPWUudmFsdWVPZjtpZihsKXt2YXIgZz1sLmNhbGwoZSk7aWYoXCJvYmplY3RcIiE9PWkoZykpcmV0dXJuIGd9dmFyIG89ZS50b1N0cmluZztpZihvKXt2YXIgdT1vLmNhbGwoZSk7aWYoXCJvYmplY3RcIiE9PWkodSkpcmV0dXJuIHV9dGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjb252ZXJ0IG9iamVjdCB0byBwcmltaXRpdmUgdmFsdWVcIil9fSx7a2V5OlwiX190b051bWVyaWNcIix2YWx1ZTpmdW5jdGlvbihlKXtyZXR1cm4gYS5fX2lzQmlnSW50KGUpP2U6K2V9fSx7a2V5OlwiX19pc0JpZ0ludFwiLHZhbHVlOmZ1bmN0aW9uKGUpe3JldHVyblwib2JqZWN0XCI9PT1pKGUpJiZudWxsIT09ZSYmZS5jb25zdHJ1Y3Rvcj09PWF9fSx7a2V5OlwiX190cnVuY2F0ZVRvTkJpdHNcIix2YWx1ZTpmdW5jdGlvbihlLHQpe2Zvcih2YXIgXz0wfChlKzI5KS8zMCxuPW5ldyBhKF8sdC5zaWduKSxsPV8tMSxnPTA7ZzxsO2crKyluLl9fc2V0RGlnaXQoZyx0Ll9fZGlnaXQoZykpO3ZhciBvPXQuX19kaWdpdChsKTtpZigwIT1lJTMwKXt2YXIgdT0zMi1lJTMwO289bzw8dT4+PnV9cmV0dXJuIG4uX19zZXREaWdpdChsLG8pLG4uX190cmltKCl9fSx7a2V5OlwiX190cnVuY2F0ZUFuZFN1YkZyb21Qb3dlck9mVHdvXCIsdmFsdWU6ZnVuY3Rpb24oZSx0LF8pe2Zvcih2YXIgbj1NYXRoLm1pbixsLGc9MHwoZSsyOSkvMzAsbz1uZXcgYShnLF8pLHU9MCxzPWctMSxkPTAsaD1uKHMsdC5sZW5ndGgpO3U8aDt1KyspbD0wLXQuX19kaWdpdCh1KS1kLGQ9MSZsPj4+MzAsby5fX3NldERpZ2l0KHUsMTA3Mzc0MTgyMyZsKTtmb3IoO3U8czt1Kyspby5fX3NldERpZ2l0KHUsMHwxMDczNzQxODIzJi1kKTt2YXIgYixtPXM8dC5sZW5ndGg/dC5fX2RpZ2l0KHMpOjAsYz1lJTMwO2lmKDA9PT1jKWI9MC1tLWQsYiY9MTA3Mzc0MTgyMztlbHNle3ZhciB2PTMyLWM7bT1tPDx2Pj4+djt2YXIgeT0xPDwzMi12O2I9eS1tLWQsYiY9eS0xfXJldHVybiBvLl9fc2V0RGlnaXQocyxiKSxvLl9fdHJpbSgpfX0se2tleTpcIl9fZGlnaXRQb3dcIix2YWx1ZTpmdW5jdGlvbihlLHQpe2Zvcih2YXIgaT0xOzA8dDspMSZ0JiYoaSo9ZSksdD4+Pj0xLGUqPWU7cmV0dXJuIGl9fSx7a2V5OlwiX19pc09uZURpZ2l0SW50XCIsdmFsdWU6ZnVuY3Rpb24oZSl7cmV0dXJuKDEwNzM3NDE4MjMmZSk9PT1lfX1dKSxhfShoKEFycmF5KSk7cmV0dXJuIFMuX19rTWF4TGVuZ3RoPTMzNTU0NDMyLFMuX19rTWF4TGVuZ3RoQml0cz1TLl9fa01heExlbmd0aDw8NSxTLl9fa01heEJpdHNQZXJDaGFyPVswLDAsMzIsNTEsNjQsNzUsODMsOTAsOTYsMTAyLDEwNywxMTEsMTE1LDExOSwxMjIsMTI2LDEyOCwxMzEsMTM0LDEzNiwxMzksMTQxLDE0MywxNDUsMTQ3LDE0OSwxNTEsMTUzLDE1NCwxNTYsMTU4LDE1OSwxNjAsMTYyLDE2MywxNjUsMTY2XSxTLl9fa0JpdHNQZXJDaGFyVGFibGVTaGlmdD01LFMuX19rQml0c1BlckNoYXJUYWJsZU11bHRpcGxpZXI9MTw8Uy5fX2tCaXRzUGVyQ2hhclRhYmxlU2hpZnQsUy5fX2tDb252ZXJzaW9uQ2hhcnM9W1wiMFwiLFwiMVwiLFwiMlwiLFwiM1wiLFwiNFwiLFwiNVwiLFwiNlwiLFwiN1wiLFwiOFwiLFwiOVwiLFwiYVwiLFwiYlwiLFwiY1wiLFwiZFwiLFwiZVwiLFwiZlwiLFwiZ1wiLFwiaFwiLFwiaVwiLFwialwiLFwia1wiLFwibFwiLFwibVwiLFwiblwiLFwib1wiLFwicFwiLFwicVwiLFwiclwiLFwic1wiLFwidFwiLFwidVwiLFwidlwiLFwid1wiLFwieFwiLFwieVwiLFwielwiXSxTLl9fa0JpdENvbnZlcnNpb25CdWZmZXI9bmV3IEFycmF5QnVmZmVyKDgpLFMuX19rQml0Q29udmVyc2lvbkRvdWJsZT1uZXcgRmxvYXQ2NEFycmF5KFMuX19rQml0Q29udmVyc2lvbkJ1ZmZlciksUy5fX2tCaXRDb252ZXJzaW9uSW50cz1uZXcgSW50MzJBcnJheShTLl9fa0JpdENvbnZlcnNpb25CdWZmZXIpLFMuX19jbHozMD10P2Z1bmN0aW9uKGUpe3JldHVybiB0KGUpLTJ9OmZ1bmN0aW9uKGUpe3ZhciB0PU1hdGguTE4yLGk9TWF0aC5sb2c7cmV0dXJuIDA9PT1lPzMwOjB8MjktKDB8aShlPj4+MCkvdCl9LFMuX19pbXVsPWV8fGZ1bmN0aW9uKGUsdCl7cmV0dXJuIDB8ZSp0fSxTfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1qc2JpLXVtZC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/jsbi/dist/jsbi-umd.js\n");

/***/ }),

/***/ "./node_modules/jsonfile/index.js":
/*!****************************************!*\
  !*** ./node_modules/jsonfile/index.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var _fs\ntry {\n  _fs = __webpack_require__(/*! graceful-fs */ \"./node_modules/graceful-fs/graceful-fs.js\")\n} catch (_) {\n  _fs = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'fs'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()))\n}\n\nfunction readFile (file, options, callback) {\n  if (callback == null) {\n    callback = options\n    options = {}\n  }\n\n  if (typeof options === 'string') {\n    options = {encoding: options}\n  }\n\n  options = options || {}\n  var fs = options.fs || _fs\n\n  var shouldThrow = true\n  if ('throws' in options) {\n    shouldThrow = options.throws\n  }\n\n  fs.readFile(file, options, function (err, data) {\n    if (err) return callback(err)\n\n    data = stripBom(data)\n\n    var obj\n    try {\n      obj = JSON.parse(data, options ? options.reviver : null)\n    } catch (err2) {\n      if (shouldThrow) {\n        err2.message = file + ': ' + err2.message\n        return callback(err2)\n      } else {\n        return callback(null, null)\n      }\n    }\n\n    callback(null, obj)\n  })\n}\n\nfunction readFileSync (file, options) {\n  options = options || {}\n  if (typeof options === 'string') {\n    options = {encoding: options}\n  }\n\n  var fs = options.fs || _fs\n\n  var shouldThrow = true\n  if ('throws' in options) {\n    shouldThrow = options.throws\n  }\n\n  try {\n    var content = fs.readFileSync(file, options)\n    content = stripBom(content)\n    return JSON.parse(content, options.reviver)\n  } catch (err) {\n    if (shouldThrow) {\n      err.message = file + ': ' + err.message\n      throw err\n    } else {\n      return null\n    }\n  }\n}\n\nfunction stringify (obj, options) {\n  var spaces\n  var EOL = '\\n'\n  if (typeof options === 'object' && options !== null) {\n    if (options.spaces) {\n      spaces = options.spaces\n    }\n    if (options.EOL) {\n      EOL = options.EOL\n    }\n  }\n\n  var str = JSON.stringify(obj, options ? options.replacer : null, spaces)\n\n  return str.replace(/\\n/g, EOL) + EOL\n}\n\nfunction writeFile (file, obj, options, callback) {\n  if (callback == null) {\n    callback = options\n    options = {}\n  }\n  options = options || {}\n  var fs = options.fs || _fs\n\n  var str = ''\n  try {\n    str = stringify(obj, options)\n  } catch (err) {\n    // Need to return whether a callback was passed or not\n    if (callback) callback(err, null)\n    return\n  }\n\n  fs.writeFile(file, str, options, callback)\n}\n\nfunction writeFileSync (file, obj, options) {\n  options = options || {}\n  var fs = options.fs || _fs\n\n  var str = stringify(obj, options)\n  // not sure if fs.writeFileSync returns anything, but just in case\n  return fs.writeFileSync(file, str, options)\n}\n\nfunction stripBom (content) {\n  // we do this because JSON.parse would convert it to a utf8 string if encoding wasn't specified\n  if (Buffer.isBuffer(content)) content = content.toString('utf8')\n  content = content.replace(/^\\uFEFF/, '')\n  return content\n}\n\nvar jsonfile = {\n  readFile: readFile,\n  readFileSync: readFileSync,\n  writeFile: writeFile,\n  writeFileSync: writeFileSync\n}\n\nmodule.exports = jsonfile\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvanNvbmZpbGUvaW5kZXguanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBLFFBQVEsbUJBQU8sQ0FBQyw4REFBYTtBQUM3QixFQUFFO0FBQ0YsUUFBUSxtQkFBTyxDQUFDLGlJQUFJO0FBQ3BCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlO0FBQ2Y7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdG9kby1saXN0Ly4vbm9kZV9tb2R1bGVzL2pzb25maWxlL2luZGV4LmpzP2MzMTMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9mc1xudHJ5IHtcbiAgX2ZzID0gcmVxdWlyZSgnZ3JhY2VmdWwtZnMnKVxufSBjYXRjaCAoXykge1xuICBfZnMgPSByZXF1aXJlKCdmcycpXG59XG5cbmZ1bmN0aW9uIHJlYWRGaWxlIChmaWxlLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICBpZiAoY2FsbGJhY2sgPT0gbnVsbCkge1xuICAgIGNhbGxiYWNrID0gb3B0aW9uc1xuICAgIG9wdGlvbnMgPSB7fVxuICB9XG5cbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnc3RyaW5nJykge1xuICAgIG9wdGlvbnMgPSB7ZW5jb2Rpbmc6IG9wdGlvbnN9XG4gIH1cblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fVxuICB2YXIgZnMgPSBvcHRpb25zLmZzIHx8IF9mc1xuXG4gIHZhciBzaG91bGRUaHJvdyA9IHRydWVcbiAgaWYgKCd0aHJvd3MnIGluIG9wdGlvbnMpIHtcbiAgICBzaG91bGRUaHJvdyA9IG9wdGlvbnMudGhyb3dzXG4gIH1cblxuICBmcy5yZWFkRmlsZShmaWxlLCBvcHRpb25zLCBmdW5jdGlvbiAoZXJyLCBkYXRhKSB7XG4gICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycilcblxuICAgIGRhdGEgPSBzdHJpcEJvbShkYXRhKVxuXG4gICAgdmFyIG9ialxuICAgIHRyeSB7XG4gICAgICBvYmogPSBKU09OLnBhcnNlKGRhdGEsIG9wdGlvbnMgPyBvcHRpb25zLnJldml2ZXIgOiBudWxsKVxuICAgIH0gY2F0Y2ggKGVycjIpIHtcbiAgICAgIGlmIChzaG91bGRUaHJvdykge1xuICAgICAgICBlcnIyLm1lc3NhZ2UgPSBmaWxlICsgJzogJyArIGVycjIubWVzc2FnZVxuICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyMilcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCBudWxsKVxuICAgICAgfVxuICAgIH1cblxuICAgIGNhbGxiYWNrKG51bGwsIG9iailcbiAgfSlcbn1cblxuZnVuY3Rpb24gcmVhZEZpbGVTeW5jIChmaWxlLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ3N0cmluZycpIHtcbiAgICBvcHRpb25zID0ge2VuY29kaW5nOiBvcHRpb25zfVxuICB9XG5cbiAgdmFyIGZzID0gb3B0aW9ucy5mcyB8fCBfZnNcblxuICB2YXIgc2hvdWxkVGhyb3cgPSB0cnVlXG4gIGlmICgndGhyb3dzJyBpbiBvcHRpb25zKSB7XG4gICAgc2hvdWxkVGhyb3cgPSBvcHRpb25zLnRocm93c1xuICB9XG5cbiAgdHJ5IHtcbiAgICB2YXIgY29udGVudCA9IGZzLnJlYWRGaWxlU3luYyhmaWxlLCBvcHRpb25zKVxuICAgIGNvbnRlbnQgPSBzdHJpcEJvbShjb250ZW50KVxuICAgIHJldHVybiBKU09OLnBhcnNlKGNvbnRlbnQsIG9wdGlvbnMucmV2aXZlcilcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgaWYgKHNob3VsZFRocm93KSB7XG4gICAgICBlcnIubWVzc2FnZSA9IGZpbGUgKyAnOiAnICsgZXJyLm1lc3NhZ2VcbiAgICAgIHRocm93IGVyclxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBzdHJpbmdpZnkgKG9iaiwgb3B0aW9ucykge1xuICB2YXIgc3BhY2VzXG4gIHZhciBFT0wgPSAnXFxuJ1xuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdvYmplY3QnICYmIG9wdGlvbnMgIT09IG51bGwpIHtcbiAgICBpZiAob3B0aW9ucy5zcGFjZXMpIHtcbiAgICAgIHNwYWNlcyA9IG9wdGlvbnMuc3BhY2VzXG4gICAgfVxuICAgIGlmIChvcHRpb25zLkVPTCkge1xuICAgICAgRU9MID0gb3B0aW9ucy5FT0xcbiAgICB9XG4gIH1cblxuICB2YXIgc3RyID0gSlNPTi5zdHJpbmdpZnkob2JqLCBvcHRpb25zID8gb3B0aW9ucy5yZXBsYWNlciA6IG51bGwsIHNwYWNlcylcblxuICByZXR1cm4gc3RyLnJlcGxhY2UoL1xcbi9nLCBFT0wpICsgRU9MXG59XG5cbmZ1bmN0aW9uIHdyaXRlRmlsZSAoZmlsZSwgb2JqLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICBpZiAoY2FsbGJhY2sgPT0gbnVsbCkge1xuICAgIGNhbGxiYWNrID0gb3B0aW9uc1xuICAgIG9wdGlvbnMgPSB7fVxuICB9XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XG4gIHZhciBmcyA9IG9wdGlvbnMuZnMgfHwgX2ZzXG5cbiAgdmFyIHN0ciA9ICcnXG4gIHRyeSB7XG4gICAgc3RyID0gc3RyaW5naWZ5KG9iaiwgb3B0aW9ucylcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgLy8gTmVlZCB0byByZXR1cm4gd2hldGhlciBhIGNhbGxiYWNrIHdhcyBwYXNzZWQgb3Igbm90XG4gICAgaWYgKGNhbGxiYWNrKSBjYWxsYmFjayhlcnIsIG51bGwpXG4gICAgcmV0dXJuXG4gIH1cblxuICBmcy53cml0ZUZpbGUoZmlsZSwgc3RyLCBvcHRpb25zLCBjYWxsYmFjaylcbn1cblxuZnVuY3Rpb24gd3JpdGVGaWxlU3luYyAoZmlsZSwgb2JqLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XG4gIHZhciBmcyA9IG9wdGlvbnMuZnMgfHwgX2ZzXG5cbiAgdmFyIHN0ciA9IHN0cmluZ2lmeShvYmosIG9wdGlvbnMpXG4gIC8vIG5vdCBzdXJlIGlmIGZzLndyaXRlRmlsZVN5bmMgcmV0dXJucyBhbnl0aGluZywgYnV0IGp1c3QgaW4gY2FzZVxuICByZXR1cm4gZnMud3JpdGVGaWxlU3luYyhmaWxlLCBzdHIsIG9wdGlvbnMpXG59XG5cbmZ1bmN0aW9uIHN0cmlwQm9tIChjb250ZW50KSB7XG4gIC8vIHdlIGRvIHRoaXMgYmVjYXVzZSBKU09OLnBhcnNlIHdvdWxkIGNvbnZlcnQgaXQgdG8gYSB1dGY4IHN0cmluZyBpZiBlbmNvZGluZyB3YXNuJ3Qgc3BlY2lmaWVkXG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoY29udGVudCkpIGNvbnRlbnQgPSBjb250ZW50LnRvU3RyaW5nKCd1dGY4JylcbiAgY29udGVudCA9IGNvbnRlbnQucmVwbGFjZSgvXlxcdUZFRkYvLCAnJylcbiAgcmV0dXJuIGNvbnRlbnRcbn1cblxudmFyIGpzb25maWxlID0ge1xuICByZWFkRmlsZTogcmVhZEZpbGUsXG4gIHJlYWRGaWxlU3luYzogcmVhZEZpbGVTeW5jLFxuICB3cml0ZUZpbGU6IHdyaXRlRmlsZSxcbiAgd3JpdGVGaWxlU3luYzogd3JpdGVGaWxlU3luY1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGpzb25maWxlXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/jsonfile/index.js\n");

/***/ }),

/***/ "./node_modules/locate-path/index.js":
/*!*******************************************!*\
  !*** ./node_modules/locate-path/index.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst path = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'path'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\nconst fs = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'fs'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\nconst {promisify} = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'util'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\nconst pLocate = __webpack_require__(/*! p-locate */ \"./node_modules/p-locate/index.js\");\n\nconst fsStat = promisify(fs.stat);\nconst fsLStat = promisify(fs.lstat);\n\nconst typeMappings = {\n\tdirectory: 'isDirectory',\n\tfile: 'isFile'\n};\n\nfunction checkType({type}) {\n\tif (type in typeMappings) {\n\t\treturn;\n\t}\n\n\tthrow new Error(`Invalid type specified: ${type}`);\n}\n\nconst matchType = (type, stat) => type === undefined || stat[typeMappings[type]]();\n\nmodule.exports = async (paths, options) => {\n\toptions = {\n\t\tcwd: process.cwd(),\n\t\ttype: 'file',\n\t\tallowSymlinks: true,\n\t\t...options\n\t};\n\tcheckType(options);\n\tconst statFn = options.allowSymlinks ? fsStat : fsLStat;\n\n\treturn pLocate(paths, async path_ => {\n\t\ttry {\n\t\t\tconst stat = await statFn(path.resolve(options.cwd, path_));\n\t\t\treturn matchType(options.type, stat);\n\t\t} catch (_) {\n\t\t\treturn false;\n\t\t}\n\t}, options);\n};\n\nmodule.exports.sync = (paths, options) => {\n\toptions = {\n\t\tcwd: process.cwd(),\n\t\tallowSymlinks: true,\n\t\ttype: 'file',\n\t\t...options\n\t};\n\tcheckType(options);\n\tconst statFn = options.allowSymlinks ? fs.statSync : fs.lstatSync;\n\n\tfor (const path_ of paths) {\n\t\ttry {\n\t\t\tconst stat = statFn(path.resolve(options.cwd, path_));\n\n\t\t\tif (matchType(options.type, stat)) {\n\t\t\t\treturn path_;\n\t\t\t}\n\t\t} catch (_) {\n\t\t}\n\t}\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbG9jYXRlLXBhdGgvaW5kZXguanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixhQUFhLG1CQUFPLENBQUMsbUlBQU07QUFDM0IsV0FBVyxtQkFBTyxDQUFDLGlJQUFJO0FBQ3ZCLE9BQU8sV0FBVyxFQUFFLG1CQUFPLENBQUMsbUlBQU07QUFDbEMsZ0JBQWdCLG1CQUFPLENBQUMsa0RBQVU7O0FBRWxDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLEtBQUs7QUFDekI7QUFDQTtBQUNBOztBQUVBLDRDQUE0QyxLQUFLO0FBQ2pEOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdG9kby1saXN0Ly4vbm9kZV9tb2R1bGVzL2xvY2F0ZS1wYXRoL2luZGV4LmpzP2EzM2QiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcbmNvbnN0IGZzID0gcmVxdWlyZSgnZnMnKTtcbmNvbnN0IHtwcm9taXNpZnl9ID0gcmVxdWlyZSgndXRpbCcpO1xuY29uc3QgcExvY2F0ZSA9IHJlcXVpcmUoJ3AtbG9jYXRlJyk7XG5cbmNvbnN0IGZzU3RhdCA9IHByb21pc2lmeShmcy5zdGF0KTtcbmNvbnN0IGZzTFN0YXQgPSBwcm9taXNpZnkoZnMubHN0YXQpO1xuXG5jb25zdCB0eXBlTWFwcGluZ3MgPSB7XG5cdGRpcmVjdG9yeTogJ2lzRGlyZWN0b3J5Jyxcblx0ZmlsZTogJ2lzRmlsZSdcbn07XG5cbmZ1bmN0aW9uIGNoZWNrVHlwZSh7dHlwZX0pIHtcblx0aWYgKHR5cGUgaW4gdHlwZU1hcHBpbmdzKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0dGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHR5cGUgc3BlY2lmaWVkOiAke3R5cGV9YCk7XG59XG5cbmNvbnN0IG1hdGNoVHlwZSA9ICh0eXBlLCBzdGF0KSA9PiB0eXBlID09PSB1bmRlZmluZWQgfHwgc3RhdFt0eXBlTWFwcGluZ3NbdHlwZV1dKCk7XG5cbm1vZHVsZS5leHBvcnRzID0gYXN5bmMgKHBhdGhzLCBvcHRpb25zKSA9PiB7XG5cdG9wdGlvbnMgPSB7XG5cdFx0Y3dkOiBwcm9jZXNzLmN3ZCgpLFxuXHRcdHR5cGU6ICdmaWxlJyxcblx0XHRhbGxvd1N5bWxpbmtzOiB0cnVlLFxuXHRcdC4uLm9wdGlvbnNcblx0fTtcblx0Y2hlY2tUeXBlKG9wdGlvbnMpO1xuXHRjb25zdCBzdGF0Rm4gPSBvcHRpb25zLmFsbG93U3ltbGlua3MgPyBmc1N0YXQgOiBmc0xTdGF0O1xuXG5cdHJldHVybiBwTG9jYXRlKHBhdGhzLCBhc3luYyBwYXRoXyA9PiB7XG5cdFx0dHJ5IHtcblx0XHRcdGNvbnN0IHN0YXQgPSBhd2FpdCBzdGF0Rm4ocGF0aC5yZXNvbHZlKG9wdGlvbnMuY3dkLCBwYXRoXykpO1xuXHRcdFx0cmV0dXJuIG1hdGNoVHlwZShvcHRpb25zLnR5cGUsIHN0YXQpO1xuXHRcdH0gY2F0Y2ggKF8pIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdH0sIG9wdGlvbnMpO1xufTtcblxubW9kdWxlLmV4cG9ydHMuc3luYyA9IChwYXRocywgb3B0aW9ucykgPT4ge1xuXHRvcHRpb25zID0ge1xuXHRcdGN3ZDogcHJvY2Vzcy5jd2QoKSxcblx0XHRhbGxvd1N5bWxpbmtzOiB0cnVlLFxuXHRcdHR5cGU6ICdmaWxlJyxcblx0XHQuLi5vcHRpb25zXG5cdH07XG5cdGNoZWNrVHlwZShvcHRpb25zKTtcblx0Y29uc3Qgc3RhdEZuID0gb3B0aW9ucy5hbGxvd1N5bWxpbmtzID8gZnMuc3RhdFN5bmMgOiBmcy5sc3RhdFN5bmM7XG5cblx0Zm9yIChjb25zdCBwYXRoXyBvZiBwYXRocykge1xuXHRcdHRyeSB7XG5cdFx0XHRjb25zdCBzdGF0ID0gc3RhdEZuKHBhdGgucmVzb2x2ZShvcHRpb25zLmN3ZCwgcGF0aF8pKTtcblxuXHRcdFx0aWYgKG1hdGNoVHlwZShvcHRpb25zLnR5cGUsIHN0YXQpKSB7XG5cdFx0XHRcdHJldHVybiBwYXRoXztcblx0XHRcdH1cblx0XHR9IGNhdGNoIChfKSB7XG5cdFx0fVxuXHR9XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/locate-path/index.js\n");

/***/ }),

/***/ "./node_modules/make-dir/index.js":
/*!****************************************!*\
  !*** ./node_modules/make-dir/index.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst fs = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'fs'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\nconst path = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'path'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\nconst {promisify} = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'util'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\nconst semver = __webpack_require__(/*! semver */ \"./node_modules/make-dir/node_modules/semver/semver.js\");\n\nconst useNativeRecursiveOption = semver.satisfies(process.version, '>=10.12.0');\n\n// https://github.com/nodejs/node/issues/8987\n// https://github.com/libuv/libuv/pull/1088\nconst checkPath = pth => {\n\tif (process.platform === 'win32') {\n\t\tconst pathHasInvalidWinCharacters = /[<>:\"|?*]/.test(pth.replace(path.parse(pth).root, ''));\n\n\t\tif (pathHasInvalidWinCharacters) {\n\t\t\tconst error = new Error(`Path contains invalid characters: ${pth}`);\n\t\t\terror.code = 'EINVAL';\n\t\t\tthrow error;\n\t\t}\n\t}\n};\n\nconst processOptions = options => {\n\t// https://github.com/sindresorhus/make-dir/issues/18\n\tconst defaults = {\n\t\tmode: 0o777,\n\t\tfs\n\t};\n\n\treturn {\n\t\t...defaults,\n\t\t...options\n\t};\n};\n\nconst permissionError = pth => {\n\t// This replicates the exception of `fs.mkdir` with native the\n\t// `recusive` option when run on an invalid drive under Windows.\n\tconst error = new Error(`operation not permitted, mkdir '${pth}'`);\n\terror.code = 'EPERM';\n\terror.errno = -4048;\n\terror.path = pth;\n\terror.syscall = 'mkdir';\n\treturn error;\n};\n\nconst makeDir = async (input, options) => {\n\tcheckPath(input);\n\toptions = processOptions(options);\n\n\tconst mkdir = promisify(options.fs.mkdir);\n\tconst stat = promisify(options.fs.stat);\n\n\tif (useNativeRecursiveOption && options.fs.mkdir === fs.mkdir) {\n\t\tconst pth = path.resolve(input);\n\n\t\tawait mkdir(pth, {\n\t\t\tmode: options.mode,\n\t\t\trecursive: true\n\t\t});\n\n\t\treturn pth;\n\t}\n\n\tconst make = async pth => {\n\t\ttry {\n\t\t\tawait mkdir(pth, options.mode);\n\n\t\t\treturn pth;\n\t\t} catch (error) {\n\t\t\tif (error.code === 'EPERM') {\n\t\t\t\tthrow error;\n\t\t\t}\n\n\t\t\tif (error.code === 'ENOENT') {\n\t\t\t\tif (path.dirname(pth) === pth) {\n\t\t\t\t\tthrow permissionError(pth);\n\t\t\t\t}\n\n\t\t\t\tif (error.message.includes('null bytes')) {\n\t\t\t\t\tthrow error;\n\t\t\t\t}\n\n\t\t\t\tawait make(path.dirname(pth));\n\n\t\t\t\treturn make(pth);\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tconst stats = await stat(pth);\n\t\t\t\tif (!stats.isDirectory()) {\n\t\t\t\t\tthrow new Error('The path is not a directory');\n\t\t\t\t}\n\t\t\t} catch (_) {\n\t\t\t\tthrow error;\n\t\t\t}\n\n\t\t\treturn pth;\n\t\t}\n\t};\n\n\treturn make(path.resolve(input));\n};\n\nmodule.exports = makeDir;\n\nmodule.exports.sync = (input, options) => {\n\tcheckPath(input);\n\toptions = processOptions(options);\n\n\tif (useNativeRecursiveOption && options.fs.mkdirSync === fs.mkdirSync) {\n\t\tconst pth = path.resolve(input);\n\n\t\tfs.mkdirSync(pth, {\n\t\t\tmode: options.mode,\n\t\t\trecursive: true\n\t\t});\n\n\t\treturn pth;\n\t}\n\n\tconst make = pth => {\n\t\ttry {\n\t\t\toptions.fs.mkdirSync(pth, options.mode);\n\t\t} catch (error) {\n\t\t\tif (error.code === 'EPERM') {\n\t\t\t\tthrow error;\n\t\t\t}\n\n\t\t\tif (error.code === 'ENOENT') {\n\t\t\t\tif (path.dirname(pth) === pth) {\n\t\t\t\t\tthrow permissionError(pth);\n\t\t\t\t}\n\n\t\t\t\tif (error.message.includes('null bytes')) {\n\t\t\t\t\tthrow error;\n\t\t\t\t}\n\n\t\t\t\tmake(path.dirname(pth));\n\t\t\t\treturn make(pth);\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (!options.fs.statSync(pth).isDirectory()) {\n\t\t\t\t\tthrow new Error('The path is not a directory');\n\t\t\t\t}\n\t\t\t} catch (_) {\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t}\n\n\t\treturn pth;\n\t};\n\n\treturn make(path.resolve(input));\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbWFrZS1kaXIvaW5kZXguanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixXQUFXLG1CQUFPLENBQUMsaUlBQUk7QUFDdkIsYUFBYSxtQkFBTyxDQUFDLG1JQUFNO0FBQzNCLE9BQU8sV0FBVyxFQUFFLG1CQUFPLENBQUMsbUlBQU07QUFDbEMsZUFBZSxtQkFBTyxDQUFDLHFFQUFROztBQUUvQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0VBQWdFLElBQUk7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsSUFBSTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsbUJBQW1CO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90b2RvLWxpc3QvLi9ub2RlX21vZHVsZXMvbWFrZS1kaXIvaW5kZXguanM/ZWM2MyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5jb25zdCBmcyA9IHJlcXVpcmUoJ2ZzJyk7XG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xuY29uc3Qge3Byb21pc2lmeX0gPSByZXF1aXJlKCd1dGlsJyk7XG5jb25zdCBzZW12ZXIgPSByZXF1aXJlKCdzZW12ZXInKTtcblxuY29uc3QgdXNlTmF0aXZlUmVjdXJzaXZlT3B0aW9uID0gc2VtdmVyLnNhdGlzZmllcyhwcm9jZXNzLnZlcnNpb24sICc+PTEwLjEyLjAnKTtcblxuLy8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2lzc3Vlcy84OTg3XG4vLyBodHRwczovL2dpdGh1Yi5jb20vbGlidXYvbGlidXYvcHVsbC8xMDg4XG5jb25zdCBjaGVja1BhdGggPSBwdGggPT4ge1xuXHRpZiAocHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJykge1xuXHRcdGNvbnN0IHBhdGhIYXNJbnZhbGlkV2luQ2hhcmFjdGVycyA9IC9bPD46XCJ8PypdLy50ZXN0KHB0aC5yZXBsYWNlKHBhdGgucGFyc2UocHRoKS5yb290LCAnJykpO1xuXG5cdFx0aWYgKHBhdGhIYXNJbnZhbGlkV2luQ2hhcmFjdGVycykge1xuXHRcdFx0Y29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYFBhdGggY29udGFpbnMgaW52YWxpZCBjaGFyYWN0ZXJzOiAke3B0aH1gKTtcblx0XHRcdGVycm9yLmNvZGUgPSAnRUlOVkFMJztcblx0XHRcdHRocm93IGVycm9yO1xuXHRcdH1cblx0fVxufTtcblxuY29uc3QgcHJvY2Vzc09wdGlvbnMgPSBvcHRpb25zID0+IHtcblx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL3NpbmRyZXNvcmh1cy9tYWtlLWRpci9pc3N1ZXMvMThcblx0Y29uc3QgZGVmYXVsdHMgPSB7XG5cdFx0bW9kZTogMG83NzcsXG5cdFx0ZnNcblx0fTtcblxuXHRyZXR1cm4ge1xuXHRcdC4uLmRlZmF1bHRzLFxuXHRcdC4uLm9wdGlvbnNcblx0fTtcbn07XG5cbmNvbnN0IHBlcm1pc3Npb25FcnJvciA9IHB0aCA9PiB7XG5cdC8vIFRoaXMgcmVwbGljYXRlcyB0aGUgZXhjZXB0aW9uIG9mIGBmcy5ta2RpcmAgd2l0aCBuYXRpdmUgdGhlXG5cdC8vIGByZWN1c2l2ZWAgb3B0aW9uIHdoZW4gcnVuIG9uIGFuIGludmFsaWQgZHJpdmUgdW5kZXIgV2luZG93cy5cblx0Y29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYG9wZXJhdGlvbiBub3QgcGVybWl0dGVkLCBta2RpciAnJHtwdGh9J2ApO1xuXHRlcnJvci5jb2RlID0gJ0VQRVJNJztcblx0ZXJyb3IuZXJybm8gPSAtNDA0ODtcblx0ZXJyb3IucGF0aCA9IHB0aDtcblx0ZXJyb3Iuc3lzY2FsbCA9ICdta2Rpcic7XG5cdHJldHVybiBlcnJvcjtcbn07XG5cbmNvbnN0IG1ha2VEaXIgPSBhc3luYyAoaW5wdXQsIG9wdGlvbnMpID0+IHtcblx0Y2hlY2tQYXRoKGlucHV0KTtcblx0b3B0aW9ucyA9IHByb2Nlc3NPcHRpb25zKG9wdGlvbnMpO1xuXG5cdGNvbnN0IG1rZGlyID0gcHJvbWlzaWZ5KG9wdGlvbnMuZnMubWtkaXIpO1xuXHRjb25zdCBzdGF0ID0gcHJvbWlzaWZ5KG9wdGlvbnMuZnMuc3RhdCk7XG5cblx0aWYgKHVzZU5hdGl2ZVJlY3Vyc2l2ZU9wdGlvbiAmJiBvcHRpb25zLmZzLm1rZGlyID09PSBmcy5ta2Rpcikge1xuXHRcdGNvbnN0IHB0aCA9IHBhdGgucmVzb2x2ZShpbnB1dCk7XG5cblx0XHRhd2FpdCBta2RpcihwdGgsIHtcblx0XHRcdG1vZGU6IG9wdGlvbnMubW9kZSxcblx0XHRcdHJlY3Vyc2l2ZTogdHJ1ZVxuXHRcdH0pO1xuXG5cdFx0cmV0dXJuIHB0aDtcblx0fVxuXG5cdGNvbnN0IG1ha2UgPSBhc3luYyBwdGggPT4ge1xuXHRcdHRyeSB7XG5cdFx0XHRhd2FpdCBta2RpcihwdGgsIG9wdGlvbnMubW9kZSk7XG5cblx0XHRcdHJldHVybiBwdGg7XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdGlmIChlcnJvci5jb2RlID09PSAnRVBFUk0nKSB7XG5cdFx0XHRcdHRocm93IGVycm9yO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoZXJyb3IuY29kZSA9PT0gJ0VOT0VOVCcpIHtcblx0XHRcdFx0aWYgKHBhdGguZGlybmFtZShwdGgpID09PSBwdGgpIHtcblx0XHRcdFx0XHR0aHJvdyBwZXJtaXNzaW9uRXJyb3IocHRoKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChlcnJvci5tZXNzYWdlLmluY2x1ZGVzKCdudWxsIGJ5dGVzJykpIHtcblx0XHRcdFx0XHR0aHJvdyBlcnJvcjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGF3YWl0IG1ha2UocGF0aC5kaXJuYW1lKHB0aCkpO1xuXG5cdFx0XHRcdHJldHVybiBtYWtlKHB0aCk7XG5cdFx0XHR9XG5cblx0XHRcdHRyeSB7XG5cdFx0XHRcdGNvbnN0IHN0YXRzID0gYXdhaXQgc3RhdChwdGgpO1xuXHRcdFx0XHRpZiAoIXN0YXRzLmlzRGlyZWN0b3J5KCkpIHtcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1RoZSBwYXRoIGlzIG5vdCBhIGRpcmVjdG9yeScpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGNhdGNoIChfKSB7XG5cdFx0XHRcdHRocm93IGVycm9yO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gcHRoO1xuXHRcdH1cblx0fTtcblxuXHRyZXR1cm4gbWFrZShwYXRoLnJlc29sdmUoaW5wdXQpKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gbWFrZURpcjtcblxubW9kdWxlLmV4cG9ydHMuc3luYyA9IChpbnB1dCwgb3B0aW9ucykgPT4ge1xuXHRjaGVja1BhdGgoaW5wdXQpO1xuXHRvcHRpb25zID0gcHJvY2Vzc09wdGlvbnMob3B0aW9ucyk7XG5cblx0aWYgKHVzZU5hdGl2ZVJlY3Vyc2l2ZU9wdGlvbiAmJiBvcHRpb25zLmZzLm1rZGlyU3luYyA9PT0gZnMubWtkaXJTeW5jKSB7XG5cdFx0Y29uc3QgcHRoID0gcGF0aC5yZXNvbHZlKGlucHV0KTtcblxuXHRcdGZzLm1rZGlyU3luYyhwdGgsIHtcblx0XHRcdG1vZGU6IG9wdGlvbnMubW9kZSxcblx0XHRcdHJlY3Vyc2l2ZTogdHJ1ZVxuXHRcdH0pO1xuXG5cdFx0cmV0dXJuIHB0aDtcblx0fVxuXG5cdGNvbnN0IG1ha2UgPSBwdGggPT4ge1xuXHRcdHRyeSB7XG5cdFx0XHRvcHRpb25zLmZzLm1rZGlyU3luYyhwdGgsIG9wdGlvbnMubW9kZSk7XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdGlmIChlcnJvci5jb2RlID09PSAnRVBFUk0nKSB7XG5cdFx0XHRcdHRocm93IGVycm9yO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoZXJyb3IuY29kZSA9PT0gJ0VOT0VOVCcpIHtcblx0XHRcdFx0aWYgKHBhdGguZGlybmFtZShwdGgpID09PSBwdGgpIHtcblx0XHRcdFx0XHR0aHJvdyBwZXJtaXNzaW9uRXJyb3IocHRoKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChlcnJvci5tZXNzYWdlLmluY2x1ZGVzKCdudWxsIGJ5dGVzJykpIHtcblx0XHRcdFx0XHR0aHJvdyBlcnJvcjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdG1ha2UocGF0aC5kaXJuYW1lKHB0aCkpO1xuXHRcdFx0XHRyZXR1cm4gbWFrZShwdGgpO1xuXHRcdFx0fVxuXG5cdFx0XHR0cnkge1xuXHRcdFx0XHRpZiAoIW9wdGlvbnMuZnMuc3RhdFN5bmMocHRoKS5pc0RpcmVjdG9yeSgpKSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdUaGUgcGF0aCBpcyBub3QgYSBkaXJlY3RvcnknKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBjYXRjaCAoXykge1xuXHRcdFx0XHR0aHJvdyBlcnJvcjtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gcHRoO1xuXHR9O1xuXG5cdHJldHVybiBtYWtlKHBhdGgucmVzb2x2ZShpbnB1dCkpO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/make-dir/index.js\n");

/***/ }),

/***/ "./node_modules/make-dir/node_modules/semver/semver.js":
/*!*************************************************************!*\
  !*** ./node_modules/make-dir/node_modules/semver/semver.js ***!
  \*************************************************************/
/***/ ((module, exports) => {

eval("exports = module.exports = SemVer\n\nvar debug\n/* istanbul ignore next */\nif (typeof process === 'object' &&\n    process.env &&\n    process.env.NODE_DEBUG &&\n    /\\bsemver\\b/i.test(process.env.NODE_DEBUG)) {\n  debug = function () {\n    var args = Array.prototype.slice.call(arguments, 0)\n    args.unshift('SEMVER')\n    console.log.apply(console, args)\n  }\n} else {\n  debug = function () {}\n}\n\n// Note: this is the semver.org version of the spec that it implements\n// Not necessarily the package version of this code.\nexports.SEMVER_SPEC_VERSION = '2.0.0'\n\nvar MAX_LENGTH = 256\nvar MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER ||\n  /* istanbul ignore next */ 9007199254740991\n\n// Max safe segment length for coercion.\nvar MAX_SAFE_COMPONENT_LENGTH = 16\n\n// The actual regexps go on exports.re\nvar re = exports.re = []\nvar src = exports.src = []\nvar t = exports.tokens = {}\nvar R = 0\n\nfunction tok (n) {\n  t[n] = R++\n}\n\n// The following Regular Expressions can be used for tokenizing,\n// validating, and parsing SemVer version strings.\n\n// ## Numeric Identifier\n// A single `0`, or a non-zero digit followed by zero or more digits.\n\ntok('NUMERICIDENTIFIER')\nsrc[t.NUMERICIDENTIFIER] = '0|[1-9]\\\\d*'\ntok('NUMERICIDENTIFIERLOOSE')\nsrc[t.NUMERICIDENTIFIERLOOSE] = '[0-9]+'\n\n// ## Non-numeric Identifier\n// Zero or more digits, followed by a letter or hyphen, and then zero or\n// more letters, digits, or hyphens.\n\ntok('NONNUMERICIDENTIFIER')\nsrc[t.NONNUMERICIDENTIFIER] = '\\\\d*[a-zA-Z-][a-zA-Z0-9-]*'\n\n// ## Main Version\n// Three dot-separated numeric identifiers.\n\ntok('MAINVERSION')\nsrc[t.MAINVERSION] = '(' + src[t.NUMERICIDENTIFIER] + ')\\\\.' +\n                   '(' + src[t.NUMERICIDENTIFIER] + ')\\\\.' +\n                   '(' + src[t.NUMERICIDENTIFIER] + ')'\n\ntok('MAINVERSIONLOOSE')\nsrc[t.MAINVERSIONLOOSE] = '(' + src[t.NUMERICIDENTIFIERLOOSE] + ')\\\\.' +\n                        '(' + src[t.NUMERICIDENTIFIERLOOSE] + ')\\\\.' +\n                        '(' + src[t.NUMERICIDENTIFIERLOOSE] + ')'\n\n// ## Pre-release Version Identifier\n// A numeric identifier, or a non-numeric identifier.\n\ntok('PRERELEASEIDENTIFIER')\nsrc[t.PRERELEASEIDENTIFIER] = '(?:' + src[t.NUMERICIDENTIFIER] +\n                            '|' + src[t.NONNUMERICIDENTIFIER] + ')'\n\ntok('PRERELEASEIDENTIFIERLOOSE')\nsrc[t.PRERELEASEIDENTIFIERLOOSE] = '(?:' + src[t.NUMERICIDENTIFIERLOOSE] +\n                                 '|' + src[t.NONNUMERICIDENTIFIER] + ')'\n\n// ## Pre-release Version\n// Hyphen, followed by one or more dot-separated pre-release version\n// identifiers.\n\ntok('PRERELEASE')\nsrc[t.PRERELEASE] = '(?:-(' + src[t.PRERELEASEIDENTIFIER] +\n                  '(?:\\\\.' + src[t.PRERELEASEIDENTIFIER] + ')*))'\n\ntok('PRERELEASELOOSE')\nsrc[t.PRERELEASELOOSE] = '(?:-?(' + src[t.PRERELEASEIDENTIFIERLOOSE] +\n                       '(?:\\\\.' + src[t.PRERELEASEIDENTIFIERLOOSE] + ')*))'\n\n// ## Build Metadata Identifier\n// Any combination of digits, letters, or hyphens.\n\ntok('BUILDIDENTIFIER')\nsrc[t.BUILDIDENTIFIER] = '[0-9A-Za-z-]+'\n\n// ## Build Metadata\n// Plus sign, followed by one or more period-separated build metadata\n// identifiers.\n\ntok('BUILD')\nsrc[t.BUILD] = '(?:\\\\+(' + src[t.BUILDIDENTIFIER] +\n             '(?:\\\\.' + src[t.BUILDIDENTIFIER] + ')*))'\n\n// ## Full Version String\n// A main version, followed optionally by a pre-release version and\n// build metadata.\n\n// Note that the only major, minor, patch, and pre-release sections of\n// the version string are capturing groups.  The build metadata is not a\n// capturing group, because it should not ever be used in version\n// comparison.\n\ntok('FULL')\ntok('FULLPLAIN')\nsrc[t.FULLPLAIN] = 'v?' + src[t.MAINVERSION] +\n                  src[t.PRERELEASE] + '?' +\n                  src[t.BUILD] + '?'\n\nsrc[t.FULL] = '^' + src[t.FULLPLAIN] + '$'\n\n// like full, but allows v1.2.3 and =1.2.3, which people do sometimes.\n// also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty\n// common in the npm registry.\ntok('LOOSEPLAIN')\nsrc[t.LOOSEPLAIN] = '[v=\\\\s]*' + src[t.MAINVERSIONLOOSE] +\n                  src[t.PRERELEASELOOSE] + '?' +\n                  src[t.BUILD] + '?'\n\ntok('LOOSE')\nsrc[t.LOOSE] = '^' + src[t.LOOSEPLAIN] + '$'\n\ntok('GTLT')\nsrc[t.GTLT] = '((?:<|>)?=?)'\n\n// Something like \"2.*\" or \"1.2.x\".\n// Note that \"x.x\" is a valid xRange identifer, meaning \"any version\"\n// Only the first item is strictly required.\ntok('XRANGEIDENTIFIERLOOSE')\nsrc[t.XRANGEIDENTIFIERLOOSE] = src[t.NUMERICIDENTIFIERLOOSE] + '|x|X|\\\\*'\ntok('XRANGEIDENTIFIER')\nsrc[t.XRANGEIDENTIFIER] = src[t.NUMERICIDENTIFIER] + '|x|X|\\\\*'\n\ntok('XRANGEPLAIN')\nsrc[t.XRANGEPLAIN] = '[v=\\\\s]*(' + src[t.XRANGEIDENTIFIER] + ')' +\n                   '(?:\\\\.(' + src[t.XRANGEIDENTIFIER] + ')' +\n                   '(?:\\\\.(' + src[t.XRANGEIDENTIFIER] + ')' +\n                   '(?:' + src[t.PRERELEASE] + ')?' +\n                   src[t.BUILD] + '?' +\n                   ')?)?'\n\ntok('XRANGEPLAINLOOSE')\nsrc[t.XRANGEPLAINLOOSE] = '[v=\\\\s]*(' + src[t.XRANGEIDENTIFIERLOOSE] + ')' +\n                        '(?:\\\\.(' + src[t.XRANGEIDENTIFIERLOOSE] + ')' +\n                        '(?:\\\\.(' + src[t.XRANGEIDENTIFIERLOOSE] + ')' +\n                        '(?:' + src[t.PRERELEASELOOSE] + ')?' +\n                        src[t.BUILD] + '?' +\n                        ')?)?'\n\ntok('XRANGE')\nsrc[t.XRANGE] = '^' + src[t.GTLT] + '\\\\s*' + src[t.XRANGEPLAIN] + '$'\ntok('XRANGELOOSE')\nsrc[t.XRANGELOOSE] = '^' + src[t.GTLT] + '\\\\s*' + src[t.XRANGEPLAINLOOSE] + '$'\n\n// Coercion.\n// Extract anything that could conceivably be a part of a valid semver\ntok('COERCE')\nsrc[t.COERCE] = '(^|[^\\\\d])' +\n              '(\\\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '})' +\n              '(?:\\\\.(\\\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '}))?' +\n              '(?:\\\\.(\\\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '}))?' +\n              '(?:$|[^\\\\d])'\ntok('COERCERTL')\nre[t.COERCERTL] = new RegExp(src[t.COERCE], 'g')\n\n// Tilde ranges.\n// Meaning is \"reasonably at or greater than\"\ntok('LONETILDE')\nsrc[t.LONETILDE] = '(?:~>?)'\n\ntok('TILDETRIM')\nsrc[t.TILDETRIM] = '(\\\\s*)' + src[t.LONETILDE] + '\\\\s+'\nre[t.TILDETRIM] = new RegExp(src[t.TILDETRIM], 'g')\nvar tildeTrimReplace = '$1~'\n\ntok('TILDE')\nsrc[t.TILDE] = '^' + src[t.LONETILDE] + src[t.XRANGEPLAIN] + '$'\ntok('TILDELOOSE')\nsrc[t.TILDELOOSE] = '^' + src[t.LONETILDE] + src[t.XRANGEPLAINLOOSE] + '$'\n\n// Caret ranges.\n// Meaning is \"at least and backwards compatible with\"\ntok('LONECARET')\nsrc[t.LONECARET] = '(?:\\\\^)'\n\ntok('CARETTRIM')\nsrc[t.CARETTRIM] = '(\\\\s*)' + src[t.LONECARET] + '\\\\s+'\nre[t.CARETTRIM] = new RegExp(src[t.CARETTRIM], 'g')\nvar caretTrimReplace = '$1^'\n\ntok('CARET')\nsrc[t.CARET] = '^' + src[t.LONECARET] + src[t.XRANGEPLAIN] + '$'\ntok('CARETLOOSE')\nsrc[t.CARETLOOSE] = '^' + src[t.LONECARET] + src[t.XRANGEPLAINLOOSE] + '$'\n\n// A simple gt/lt/eq thing, or just \"\" to indicate \"any version\"\ntok('COMPARATORLOOSE')\nsrc[t.COMPARATORLOOSE] = '^' + src[t.GTLT] + '\\\\s*(' + src[t.LOOSEPLAIN] + ')$|^$'\ntok('COMPARATOR')\nsrc[t.COMPARATOR] = '^' + src[t.GTLT] + '\\\\s*(' + src[t.FULLPLAIN] + ')$|^$'\n\n// An expression to strip any whitespace between the gtlt and the thing\n// it modifies, so that `> 1.2.3` ==> `>1.2.3`\ntok('COMPARATORTRIM')\nsrc[t.COMPARATORTRIM] = '(\\\\s*)' + src[t.GTLT] +\n                      '\\\\s*(' + src[t.LOOSEPLAIN] + '|' + src[t.XRANGEPLAIN] + ')'\n\n// this one has to use the /g flag\nre[t.COMPARATORTRIM] = new RegExp(src[t.COMPARATORTRIM], 'g')\nvar comparatorTrimReplace = '$1$2$3'\n\n// Something like `1.2.3 - 1.2.4`\n// Note that these all use the loose form, because they'll be\n// checked against either the strict or loose comparator form\n// later.\ntok('HYPHENRANGE')\nsrc[t.HYPHENRANGE] = '^\\\\s*(' + src[t.XRANGEPLAIN] + ')' +\n                   '\\\\s+-\\\\s+' +\n                   '(' + src[t.XRANGEPLAIN] + ')' +\n                   '\\\\s*$'\n\ntok('HYPHENRANGELOOSE')\nsrc[t.HYPHENRANGELOOSE] = '^\\\\s*(' + src[t.XRANGEPLAINLOOSE] + ')' +\n                        '\\\\s+-\\\\s+' +\n                        '(' + src[t.XRANGEPLAINLOOSE] + ')' +\n                        '\\\\s*$'\n\n// Star ranges basically just allow anything at all.\ntok('STAR')\nsrc[t.STAR] = '(<|>)?=?\\\\s*\\\\*'\n\n// Compile to actual regexp objects.\n// All are flag-free, unless they were created above with a flag.\nfor (var i = 0; i < R; i++) {\n  debug(i, src[i])\n  if (!re[i]) {\n    re[i] = new RegExp(src[i])\n  }\n}\n\nexports.parse = parse\nfunction parse (version, options) {\n  if (!options || typeof options !== 'object') {\n    options = {\n      loose: !!options,\n      includePrerelease: false\n    }\n  }\n\n  if (version instanceof SemVer) {\n    return version\n  }\n\n  if (typeof version !== 'string') {\n    return null\n  }\n\n  if (version.length > MAX_LENGTH) {\n    return null\n  }\n\n  var r = options.loose ? re[t.LOOSE] : re[t.FULL]\n  if (!r.test(version)) {\n    return null\n  }\n\n  try {\n    return new SemVer(version, options)\n  } catch (er) {\n    return null\n  }\n}\n\nexports.valid = valid\nfunction valid (version, options) {\n  var v = parse(version, options)\n  return v ? v.version : null\n}\n\nexports.clean = clean\nfunction clean (version, options) {\n  var s = parse(version.trim().replace(/^[=v]+/, ''), options)\n  return s ? s.version : null\n}\n\nexports.SemVer = SemVer\n\nfunction SemVer (version, options) {\n  if (!options || typeof options !== 'object') {\n    options = {\n      loose: !!options,\n      includePrerelease: false\n    }\n  }\n  if (version instanceof SemVer) {\n    if (version.loose === options.loose) {\n      return version\n    } else {\n      version = version.version\n    }\n  } else if (typeof version !== 'string') {\n    throw new TypeError('Invalid Version: ' + version)\n  }\n\n  if (version.length > MAX_LENGTH) {\n    throw new TypeError('version is longer than ' + MAX_LENGTH + ' characters')\n  }\n\n  if (!(this instanceof SemVer)) {\n    return new SemVer(version, options)\n  }\n\n  debug('SemVer', version, options)\n  this.options = options\n  this.loose = !!options.loose\n\n  var m = version.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL])\n\n  if (!m) {\n    throw new TypeError('Invalid Version: ' + version)\n  }\n\n  this.raw = version\n\n  // these are actually numbers\n  this.major = +m[1]\n  this.minor = +m[2]\n  this.patch = +m[3]\n\n  if (this.major > MAX_SAFE_INTEGER || this.major < 0) {\n    throw new TypeError('Invalid major version')\n  }\n\n  if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {\n    throw new TypeError('Invalid minor version')\n  }\n\n  if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {\n    throw new TypeError('Invalid patch version')\n  }\n\n  // numberify any prerelease numeric ids\n  if (!m[4]) {\n    this.prerelease = []\n  } else {\n    this.prerelease = m[4].split('.').map(function (id) {\n      if (/^[0-9]+$/.test(id)) {\n        var num = +id\n        if (num >= 0 && num < MAX_SAFE_INTEGER) {\n          return num\n        }\n      }\n      return id\n    })\n  }\n\n  this.build = m[5] ? m[5].split('.') : []\n  this.format()\n}\n\nSemVer.prototype.format = function () {\n  this.version = this.major + '.' + this.minor + '.' + this.patch\n  if (this.prerelease.length) {\n    this.version += '-' + this.prerelease.join('.')\n  }\n  return this.version\n}\n\nSemVer.prototype.toString = function () {\n  return this.version\n}\n\nSemVer.prototype.compare = function (other) {\n  debug('SemVer.compare', this.version, this.options, other)\n  if (!(other instanceof SemVer)) {\n    other = new SemVer(other, this.options)\n  }\n\n  return this.compareMain(other) || this.comparePre(other)\n}\n\nSemVer.prototype.compareMain = function (other) {\n  if (!(other instanceof SemVer)) {\n    other = new SemVer(other, this.options)\n  }\n\n  return compareIdentifiers(this.major, other.major) ||\n         compareIdentifiers(this.minor, other.minor) ||\n         compareIdentifiers(this.patch, other.patch)\n}\n\nSemVer.prototype.comparePre = function (other) {\n  if (!(other instanceof SemVer)) {\n    other = new SemVer(other, this.options)\n  }\n\n  // NOT having a prerelease is > having one\n  if (this.prerelease.length && !other.prerelease.length) {\n    return -1\n  } else if (!this.prerelease.length && other.prerelease.length) {\n    return 1\n  } else if (!this.prerelease.length && !other.prerelease.length) {\n    return 0\n  }\n\n  var i = 0\n  do {\n    var a = this.prerelease[i]\n    var b = other.prerelease[i]\n    debug('prerelease compare', i, a, b)\n    if (a === undefined && b === undefined) {\n      return 0\n    } else if (b === undefined) {\n      return 1\n    } else if (a === undefined) {\n      return -1\n    } else if (a === b) {\n      continue\n    } else {\n      return compareIdentifiers(a, b)\n    }\n  } while (++i)\n}\n\nSemVer.prototype.compareBuild = function (other) {\n  if (!(other instanceof SemVer)) {\n    other = new SemVer(other, this.options)\n  }\n\n  var i = 0\n  do {\n    var a = this.build[i]\n    var b = other.build[i]\n    debug('prerelease compare', i, a, b)\n    if (a === undefined && b === undefined) {\n      return 0\n    } else if (b === undefined) {\n      return 1\n    } else if (a === undefined) {\n      return -1\n    } else if (a === b) {\n      continue\n    } else {\n      return compareIdentifiers(a, b)\n    }\n  } while (++i)\n}\n\n// preminor will bump the version up to the next minor release, and immediately\n// down to pre-release. premajor and prepatch work the same way.\nSemVer.prototype.inc = function (release, identifier) {\n  switch (release) {\n    case 'premajor':\n      this.prerelease.length = 0\n      this.patch = 0\n      this.minor = 0\n      this.major++\n      this.inc('pre', identifier)\n      break\n    case 'preminor':\n      this.prerelease.length = 0\n      this.patch = 0\n      this.minor++\n      this.inc('pre', identifier)\n      break\n    case 'prepatch':\n      // If this is already a prerelease, it will bump to the next version\n      // drop any prereleases that might already exist, since they are not\n      // relevant at this point.\n      this.prerelease.length = 0\n      this.inc('patch', identifier)\n      this.inc('pre', identifier)\n      break\n    // If the input is a non-prerelease version, this acts the same as\n    // prepatch.\n    case 'prerelease':\n      if (this.prerelease.length === 0) {\n        this.inc('patch', identifier)\n      }\n      this.inc('pre', identifier)\n      break\n\n    case 'major':\n      // If this is a pre-major version, bump up to the same major version.\n      // Otherwise increment major.\n      // 1.0.0-5 bumps to 1.0.0\n      // 1.1.0 bumps to 2.0.0\n      if (this.minor !== 0 ||\n          this.patch !== 0 ||\n          this.prerelease.length === 0) {\n        this.major++\n      }\n      this.minor = 0\n      this.patch = 0\n      this.prerelease = []\n      break\n    case 'minor':\n      // If this is a pre-minor version, bump up to the same minor version.\n      // Otherwise increment minor.\n      // 1.2.0-5 bumps to 1.2.0\n      // 1.2.1 bumps to 1.3.0\n      if (this.patch !== 0 || this.prerelease.length === 0) {\n        this.minor++\n      }\n      this.patch = 0\n      this.prerelease = []\n      break\n    case 'patch':\n      // If this is not a pre-release version, it will increment the patch.\n      // If it is a pre-release it will bump up to the same patch version.\n      // 1.2.0-5 patches to 1.2.0\n      // 1.2.0 patches to 1.2.1\n      if (this.prerelease.length === 0) {\n        this.patch++\n      }\n      this.prerelease = []\n      break\n    // This probably shouldn't be used publicly.\n    // 1.0.0 \"pre\" would become 1.0.0-0 which is the wrong direction.\n    case 'pre':\n      if (this.prerelease.length === 0) {\n        this.prerelease = [0]\n      } else {\n        var i = this.prerelease.length\n        while (--i >= 0) {\n          if (typeof this.prerelease[i] === 'number') {\n            this.prerelease[i]++\n            i = -2\n          }\n        }\n        if (i === -1) {\n          // didn't increment anything\n          this.prerelease.push(0)\n        }\n      }\n      if (identifier) {\n        // 1.2.0-beta.1 bumps to 1.2.0-beta.2,\n        // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0\n        if (this.prerelease[0] === identifier) {\n          if (isNaN(this.prerelease[1])) {\n            this.prerelease = [identifier, 0]\n          }\n        } else {\n          this.prerelease = [identifier, 0]\n        }\n      }\n      break\n\n    default:\n      throw new Error('invalid increment argument: ' + release)\n  }\n  this.format()\n  this.raw = this.version\n  return this\n}\n\nexports.inc = inc\nfunction inc (version, release, loose, identifier) {\n  if (typeof (loose) === 'string') {\n    identifier = loose\n    loose = undefined\n  }\n\n  try {\n    return new SemVer(version, loose).inc(release, identifier).version\n  } catch (er) {\n    return null\n  }\n}\n\nexports.diff = diff\nfunction diff (version1, version2) {\n  if (eq(version1, version2)) {\n    return null\n  } else {\n    var v1 = parse(version1)\n    var v2 = parse(version2)\n    var prefix = ''\n    if (v1.prerelease.length || v2.prerelease.length) {\n      prefix = 'pre'\n      var defaultResult = 'prerelease'\n    }\n    for (var key in v1) {\n      if (key === 'major' || key === 'minor' || key === 'patch') {\n        if (v1[key] !== v2[key]) {\n          return prefix + key\n        }\n      }\n    }\n    return defaultResult // may be undefined\n  }\n}\n\nexports.compareIdentifiers = compareIdentifiers\n\nvar numeric = /^[0-9]+$/\nfunction compareIdentifiers (a, b) {\n  var anum = numeric.test(a)\n  var bnum = numeric.test(b)\n\n  if (anum && bnum) {\n    a = +a\n    b = +b\n  }\n\n  return a === b ? 0\n    : (anum && !bnum) ? -1\n    : (bnum && !anum) ? 1\n    : a < b ? -1\n    : 1\n}\n\nexports.rcompareIdentifiers = rcompareIdentifiers\nfunction rcompareIdentifiers (a, b) {\n  return compareIdentifiers(b, a)\n}\n\nexports.major = major\nfunction major (a, loose) {\n  return new SemVer(a, loose).major\n}\n\nexports.minor = minor\nfunction minor (a, loose) {\n  return new SemVer(a, loose).minor\n}\n\nexports.patch = patch\nfunction patch (a, loose) {\n  return new SemVer(a, loose).patch\n}\n\nexports.compare = compare\nfunction compare (a, b, loose) {\n  return new SemVer(a, loose).compare(new SemVer(b, loose))\n}\n\nexports.compareLoose = compareLoose\nfunction compareLoose (a, b) {\n  return compare(a, b, true)\n}\n\nexports.compareBuild = compareBuild\nfunction compareBuild (a, b, loose) {\n  var versionA = new SemVer(a, loose)\n  var versionB = new SemVer(b, loose)\n  return versionA.compare(versionB) || versionA.compareBuild(versionB)\n}\n\nexports.rcompare = rcompare\nfunction rcompare (a, b, loose) {\n  return compare(b, a, loose)\n}\n\nexports.sort = sort\nfunction sort (list, loose) {\n  return list.sort(function (a, b) {\n    return exports.compareBuild(a, b, loose)\n  })\n}\n\nexports.rsort = rsort\nfunction rsort (list, loose) {\n  return list.sort(function (a, b) {\n    return exports.compareBuild(b, a, loose)\n  })\n}\n\nexports.gt = gt\nfunction gt (a, b, loose) {\n  return compare(a, b, loose) > 0\n}\n\nexports.lt = lt\nfunction lt (a, b, loose) {\n  return compare(a, b, loose) < 0\n}\n\nexports.eq = eq\nfunction eq (a, b, loose) {\n  return compare(a, b, loose) === 0\n}\n\nexports.neq = neq\nfunction neq (a, b, loose) {\n  return compare(a, b, loose) !== 0\n}\n\nexports.gte = gte\nfunction gte (a, b, loose) {\n  return compare(a, b, loose) >= 0\n}\n\nexports.lte = lte\nfunction lte (a, b, loose) {\n  return compare(a, b, loose) <= 0\n}\n\nexports.cmp = cmp\nfunction cmp (a, op, b, loose) {\n  switch (op) {\n    case '===':\n      if (typeof a === 'object')\n        a = a.version\n      if (typeof b === 'object')\n        b = b.version\n      return a === b\n\n    case '!==':\n      if (typeof a === 'object')\n        a = a.version\n      if (typeof b === 'object')\n        b = b.version\n      return a !== b\n\n    case '':\n    case '=':\n    case '==':\n      return eq(a, b, loose)\n\n    case '!=':\n      return neq(a, b, loose)\n\n    case '>':\n      return gt(a, b, loose)\n\n    case '>=':\n      return gte(a, b, loose)\n\n    case '<':\n      return lt(a, b, loose)\n\n    case '<=':\n      return lte(a, b, loose)\n\n    default:\n      throw new TypeError('Invalid operator: ' + op)\n  }\n}\n\nexports.Comparator = Comparator\nfunction Comparator (comp, options) {\n  if (!options || typeof options !== 'object') {\n    options = {\n      loose: !!options,\n      includePrerelease: false\n    }\n  }\n\n  if (comp instanceof Comparator) {\n    if (comp.loose === !!options.loose) {\n      return comp\n    } else {\n      comp = comp.value\n    }\n  }\n\n  if (!(this instanceof Comparator)) {\n    return new Comparator(comp, options)\n  }\n\n  debug('comparator', comp, options)\n  this.options = options\n  this.loose = !!options.loose\n  this.parse(comp)\n\n  if (this.semver === ANY) {\n    this.value = ''\n  } else {\n    this.value = this.operator + this.semver.version\n  }\n\n  debug('comp', this)\n}\n\nvar ANY = {}\nComparator.prototype.parse = function (comp) {\n  var r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR]\n  var m = comp.match(r)\n\n  if (!m) {\n    throw new TypeError('Invalid comparator: ' + comp)\n  }\n\n  this.operator = m[1] !== undefined ? m[1] : ''\n  if (this.operator === '=') {\n    this.operator = ''\n  }\n\n  // if it literally is just '>' or '' then allow anything.\n  if (!m[2]) {\n    this.semver = ANY\n  } else {\n    this.semver = new SemVer(m[2], this.options.loose)\n  }\n}\n\nComparator.prototype.toString = function () {\n  return this.value\n}\n\nComparator.prototype.test = function (version) {\n  debug('Comparator.test', version, this.options.loose)\n\n  if (this.semver === ANY || version === ANY) {\n    return true\n  }\n\n  if (typeof version === 'string') {\n    try {\n      version = new SemVer(version, this.options)\n    } catch (er) {\n      return false\n    }\n  }\n\n  return cmp(version, this.operator, this.semver, this.options)\n}\n\nComparator.prototype.intersects = function (comp, options) {\n  if (!(comp instanceof Comparator)) {\n    throw new TypeError('a Comparator is required')\n  }\n\n  if (!options || typeof options !== 'object') {\n    options = {\n      loose: !!options,\n      includePrerelease: false\n    }\n  }\n\n  var rangeTmp\n\n  if (this.operator === '') {\n    if (this.value === '') {\n      return true\n    }\n    rangeTmp = new Range(comp.value, options)\n    return satisfies(this.value, rangeTmp, options)\n  } else if (comp.operator === '') {\n    if (comp.value === '') {\n      return true\n    }\n    rangeTmp = new Range(this.value, options)\n    return satisfies(comp.semver, rangeTmp, options)\n  }\n\n  var sameDirectionIncreasing =\n    (this.operator === '>=' || this.operator === '>') &&\n    (comp.operator === '>=' || comp.operator === '>')\n  var sameDirectionDecreasing =\n    (this.operator === '<=' || this.operator === '<') &&\n    (comp.operator === '<=' || comp.operator === '<')\n  var sameSemVer = this.semver.version === comp.semver.version\n  var differentDirectionsInclusive =\n    (this.operator === '>=' || this.operator === '<=') &&\n    (comp.operator === '>=' || comp.operator === '<=')\n  var oppositeDirectionsLessThan =\n    cmp(this.semver, '<', comp.semver, options) &&\n    ((this.operator === '>=' || this.operator === '>') &&\n    (comp.operator === '<=' || comp.operator === '<'))\n  var oppositeDirectionsGreaterThan =\n    cmp(this.semver, '>', comp.semver, options) &&\n    ((this.operator === '<=' || this.operator === '<') &&\n    (comp.operator === '>=' || comp.operator === '>'))\n\n  return sameDirectionIncreasing || sameDirectionDecreasing ||\n    (sameSemVer && differentDirectionsInclusive) ||\n    oppositeDirectionsLessThan || oppositeDirectionsGreaterThan\n}\n\nexports.Range = Range\nfunction Range (range, options) {\n  if (!options || typeof options !== 'object') {\n    options = {\n      loose: !!options,\n      includePrerelease: false\n    }\n  }\n\n  if (range instanceof Range) {\n    if (range.loose === !!options.loose &&\n        range.includePrerelease === !!options.includePrerelease) {\n      return range\n    } else {\n      return new Range(range.raw, options)\n    }\n  }\n\n  if (range instanceof Comparator) {\n    return new Range(range.value, options)\n  }\n\n  if (!(this instanceof Range)) {\n    return new Range(range, options)\n  }\n\n  this.options = options\n  this.loose = !!options.loose\n  this.includePrerelease = !!options.includePrerelease\n\n  // First, split based on boolean or ||\n  this.raw = range\n  this.set = range.split(/\\s*\\|\\|\\s*/).map(function (range) {\n    return this.parseRange(range.trim())\n  }, this).filter(function (c) {\n    // throw out any that are not relevant for whatever reason\n    return c.length\n  })\n\n  if (!this.set.length) {\n    throw new TypeError('Invalid SemVer Range: ' + range)\n  }\n\n  this.format()\n}\n\nRange.prototype.format = function () {\n  this.range = this.set.map(function (comps) {\n    return comps.join(' ').trim()\n  }).join('||').trim()\n  return this.range\n}\n\nRange.prototype.toString = function () {\n  return this.range\n}\n\nRange.prototype.parseRange = function (range) {\n  var loose = this.options.loose\n  range = range.trim()\n  // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`\n  var hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE]\n  range = range.replace(hr, hyphenReplace)\n  debug('hyphen replace', range)\n  // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`\n  range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace)\n  debug('comparator trim', range, re[t.COMPARATORTRIM])\n\n  // `~ 1.2.3` => `~1.2.3`\n  range = range.replace(re[t.TILDETRIM], tildeTrimReplace)\n\n  // `^ 1.2.3` => `^1.2.3`\n  range = range.replace(re[t.CARETTRIM], caretTrimReplace)\n\n  // normalize spaces\n  range = range.split(/\\s+/).join(' ')\n\n  // At this point, the range is completely trimmed and\n  // ready to be split into comparators.\n\n  var compRe = loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR]\n  var set = range.split(' ').map(function (comp) {\n    return parseComparator(comp, this.options)\n  }, this).join(' ').split(/\\s+/)\n  if (this.options.loose) {\n    // in loose mode, throw out any that are not valid comparators\n    set = set.filter(function (comp) {\n      return !!comp.match(compRe)\n    })\n  }\n  set = set.map(function (comp) {\n    return new Comparator(comp, this.options)\n  }, this)\n\n  return set\n}\n\nRange.prototype.intersects = function (range, options) {\n  if (!(range instanceof Range)) {\n    throw new TypeError('a Range is required')\n  }\n\n  return this.set.some(function (thisComparators) {\n    return (\n      isSatisfiable(thisComparators, options) &&\n      range.set.some(function (rangeComparators) {\n        return (\n          isSatisfiable(rangeComparators, options) &&\n          thisComparators.every(function (thisComparator) {\n            return rangeComparators.every(function (rangeComparator) {\n              return thisComparator.intersects(rangeComparator, options)\n            })\n          })\n        )\n      })\n    )\n  })\n}\n\n// take a set of comparators and determine whether there\n// exists a version which can satisfy it\nfunction isSatisfiable (comparators, options) {\n  var result = true\n  var remainingComparators = comparators.slice()\n  var testComparator = remainingComparators.pop()\n\n  while (result && remainingComparators.length) {\n    result = remainingComparators.every(function (otherComparator) {\n      return testComparator.intersects(otherComparator, options)\n    })\n\n    testComparator = remainingComparators.pop()\n  }\n\n  return result\n}\n\n// Mostly just for testing and legacy API reasons\nexports.toComparators = toComparators\nfunction toComparators (range, options) {\n  return new Range(range, options).set.map(function (comp) {\n    return comp.map(function (c) {\n      return c.value\n    }).join(' ').trim().split(' ')\n  })\n}\n\n// comprised of xranges, tildes, stars, and gtlt's at this point.\n// already replaced the hyphen ranges\n// turn into a set of JUST comparators.\nfunction parseComparator (comp, options) {\n  debug('comp', comp, options)\n  comp = replaceCarets(comp, options)\n  debug('caret', comp)\n  comp = replaceTildes(comp, options)\n  debug('tildes', comp)\n  comp = replaceXRanges(comp, options)\n  debug('xrange', comp)\n  comp = replaceStars(comp, options)\n  debug('stars', comp)\n  return comp\n}\n\nfunction isX (id) {\n  return !id || id.toLowerCase() === 'x' || id === '*'\n}\n\n// ~, ~> --> * (any, kinda silly)\n// ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0\n// ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0\n// ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0\n// ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0\n// ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0\nfunction replaceTildes (comp, options) {\n  return comp.trim().split(/\\s+/).map(function (comp) {\n    return replaceTilde(comp, options)\n  }).join(' ')\n}\n\nfunction replaceTilde (comp, options) {\n  var r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE]\n  return comp.replace(r, function (_, M, m, p, pr) {\n    debug('tilde', comp, _, M, m, p, pr)\n    var ret\n\n    if (isX(M)) {\n      ret = ''\n    } else if (isX(m)) {\n      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0'\n    } else if (isX(p)) {\n      // ~1.2 == >=1.2.0 <1.3.0\n      ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0'\n    } else if (pr) {\n      debug('replaceTilde pr', pr)\n      ret = '>=' + M + '.' + m + '.' + p + '-' + pr +\n            ' <' + M + '.' + (+m + 1) + '.0'\n    } else {\n      // ~1.2.3 == >=1.2.3 <1.3.0\n      ret = '>=' + M + '.' + m + '.' + p +\n            ' <' + M + '.' + (+m + 1) + '.0'\n    }\n\n    debug('tilde return', ret)\n    return ret\n  })\n}\n\n// ^ --> * (any, kinda silly)\n// ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0\n// ^2.0, ^2.0.x --> >=2.0.0 <3.0.0\n// ^1.2, ^1.2.x --> >=1.2.0 <2.0.0\n// ^1.2.3 --> >=1.2.3 <2.0.0\n// ^1.2.0 --> >=1.2.0 <2.0.0\nfunction replaceCarets (comp, options) {\n  return comp.trim().split(/\\s+/).map(function (comp) {\n    return replaceCaret(comp, options)\n  }).join(' ')\n}\n\nfunction replaceCaret (comp, options) {\n  debug('caret', comp, options)\n  var r = options.loose ? re[t.CARETLOOSE] : re[t.CARET]\n  return comp.replace(r, function (_, M, m, p, pr) {\n    debug('caret', comp, _, M, m, p, pr)\n    var ret\n\n    if (isX(M)) {\n      ret = ''\n    } else if (isX(m)) {\n      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0'\n    } else if (isX(p)) {\n      if (M === '0') {\n        ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0'\n      } else {\n        ret = '>=' + M + '.' + m + '.0 <' + (+M + 1) + '.0.0'\n      }\n    } else if (pr) {\n      debug('replaceCaret pr', pr)\n      if (M === '0') {\n        if (m === '0') {\n          ret = '>=' + M + '.' + m + '.' + p + '-' + pr +\n                ' <' + M + '.' + m + '.' + (+p + 1)\n        } else {\n          ret = '>=' + M + '.' + m + '.' + p + '-' + pr +\n                ' <' + M + '.' + (+m + 1) + '.0'\n        }\n      } else {\n        ret = '>=' + M + '.' + m + '.' + p + '-' + pr +\n              ' <' + (+M + 1) + '.0.0'\n      }\n    } else {\n      debug('no pr')\n      if (M === '0') {\n        if (m === '0') {\n          ret = '>=' + M + '.' + m + '.' + p +\n                ' <' + M + '.' + m + '.' + (+p + 1)\n        } else {\n          ret = '>=' + M + '.' + m + '.' + p +\n                ' <' + M + '.' + (+m + 1) + '.0'\n        }\n      } else {\n        ret = '>=' + M + '.' + m + '.' + p +\n              ' <' + (+M + 1) + '.0.0'\n      }\n    }\n\n    debug('caret return', ret)\n    return ret\n  })\n}\n\nfunction replaceXRanges (comp, options) {\n  debug('replaceXRanges', comp, options)\n  return comp.split(/\\s+/).map(function (comp) {\n    return replaceXRange(comp, options)\n  }).join(' ')\n}\n\nfunction replaceXRange (comp, options) {\n  comp = comp.trim()\n  var r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE]\n  return comp.replace(r, function (ret, gtlt, M, m, p, pr) {\n    debug('xRange', comp, ret, gtlt, M, m, p, pr)\n    var xM = isX(M)\n    var xm = xM || isX(m)\n    var xp = xm || isX(p)\n    var anyX = xp\n\n    if (gtlt === '=' && anyX) {\n      gtlt = ''\n    }\n\n    // if we're including prereleases in the match, then we need\n    // to fix this to -0, the lowest possible prerelease value\n    pr = options.includePrerelease ? '-0' : ''\n\n    if (xM) {\n      if (gtlt === '>' || gtlt === '<') {\n        // nothing is allowed\n        ret = '<0.0.0-0'\n      } else {\n        // nothing is forbidden\n        ret = '*'\n      }\n    } else if (gtlt && anyX) {\n      // we know patch is an x, because we have any x at all.\n      // replace X with 0\n      if (xm) {\n        m = 0\n      }\n      p = 0\n\n      if (gtlt === '>') {\n        // >1 => >=2.0.0\n        // >1.2 => >=1.3.0\n        // >1.2.3 => >= 1.2.4\n        gtlt = '>='\n        if (xm) {\n          M = +M + 1\n          m = 0\n          p = 0\n        } else {\n          m = +m + 1\n          p = 0\n        }\n      } else if (gtlt === '<=') {\n        // <=0.7.x is actually <0.8.0, since any 0.7.x should\n        // pass.  Similarly, <=7.x is actually <8.0.0, etc.\n        gtlt = '<'\n        if (xm) {\n          M = +M + 1\n        } else {\n          m = +m + 1\n        }\n      }\n\n      ret = gtlt + M + '.' + m + '.' + p + pr\n    } else if (xm) {\n      ret = '>=' + M + '.0.0' + pr + ' <' + (+M + 1) + '.0.0' + pr\n    } else if (xp) {\n      ret = '>=' + M + '.' + m + '.0' + pr +\n        ' <' + M + '.' + (+m + 1) + '.0' + pr\n    }\n\n    debug('xRange return', ret)\n\n    return ret\n  })\n}\n\n// Because * is AND-ed with everything else in the comparator,\n// and '' means \"any version\", just remove the *s entirely.\nfunction replaceStars (comp, options) {\n  debug('replaceStars', comp, options)\n  // Looseness is ignored here.  star is always as loose as it gets!\n  return comp.trim().replace(re[t.STAR], '')\n}\n\n// This function is passed to string.replace(re[t.HYPHENRANGE])\n// M, m, patch, prerelease, build\n// 1.2 - 3.4.5 => >=1.2.0 <=3.4.5\n// 1.2.3 - 3.4 => >=1.2.0 <3.5.0 Any 3.4.x will do\n// 1.2 - 3.4 => >=1.2.0 <3.5.0\nfunction hyphenReplace ($0,\n  from, fM, fm, fp, fpr, fb,\n  to, tM, tm, tp, tpr, tb) {\n  if (isX(fM)) {\n    from = ''\n  } else if (isX(fm)) {\n    from = '>=' + fM + '.0.0'\n  } else if (isX(fp)) {\n    from = '>=' + fM + '.' + fm + '.0'\n  } else {\n    from = '>=' + from\n  }\n\n  if (isX(tM)) {\n    to = ''\n  } else if (isX(tm)) {\n    to = '<' + (+tM + 1) + '.0.0'\n  } else if (isX(tp)) {\n    to = '<' + tM + '.' + (+tm + 1) + '.0'\n  } else if (tpr) {\n    to = '<=' + tM + '.' + tm + '.' + tp + '-' + tpr\n  } else {\n    to = '<=' + to\n  }\n\n  return (from + ' ' + to).trim()\n}\n\n// if ANY of the sets match ALL of its comparators, then pass\nRange.prototype.test = function (version) {\n  if (!version) {\n    return false\n  }\n\n  if (typeof version === 'string') {\n    try {\n      version = new SemVer(version, this.options)\n    } catch (er) {\n      return false\n    }\n  }\n\n  for (var i = 0; i < this.set.length; i++) {\n    if (testSet(this.set[i], version, this.options)) {\n      return true\n    }\n  }\n  return false\n}\n\nfunction testSet (set, version, options) {\n  for (var i = 0; i < set.length; i++) {\n    if (!set[i].test(version)) {\n      return false\n    }\n  }\n\n  if (version.prerelease.length && !options.includePrerelease) {\n    // Find the set of versions that are allowed to have prereleases\n    // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0\n    // That should allow `1.2.3-pr.2` to pass.\n    // However, `1.2.4-alpha.notready` should NOT be allowed,\n    // even though it's within the range set by the comparators.\n    for (i = 0; i < set.length; i++) {\n      debug(set[i].semver)\n      if (set[i].semver === ANY) {\n        continue\n      }\n\n      if (set[i].semver.prerelease.length > 0) {\n        var allowed = set[i].semver\n        if (allowed.major === version.major &&\n            allowed.minor === version.minor &&\n            allowed.patch === version.patch) {\n          return true\n        }\n      }\n    }\n\n    // Version has a -pre, but it's not one of the ones we like.\n    return false\n  }\n\n  return true\n}\n\nexports.satisfies = satisfies\nfunction satisfies (version, range, options) {\n  try {\n    range = new Range(range, options)\n  } catch (er) {\n    return false\n  }\n  return range.test(version)\n}\n\nexports.maxSatisfying = maxSatisfying\nfunction maxSatisfying (versions, range, options) {\n  var max = null\n  var maxSV = null\n  try {\n    var rangeObj = new Range(range, options)\n  } catch (er) {\n    return null\n  }\n  versions.forEach(function (v) {\n    if (rangeObj.test(v)) {\n      // satisfies(v, range, options)\n      if (!max || maxSV.compare(v) === -1) {\n        // compare(max, v, true)\n        max = v\n        maxSV = new SemVer(max, options)\n      }\n    }\n  })\n  return max\n}\n\nexports.minSatisfying = minSatisfying\nfunction minSatisfying (versions, range, options) {\n  var min = null\n  var minSV = null\n  try {\n    var rangeObj = new Range(range, options)\n  } catch (er) {\n    return null\n  }\n  versions.forEach(function (v) {\n    if (rangeObj.test(v)) {\n      // satisfies(v, range, options)\n      if (!min || minSV.compare(v) === 1) {\n        // compare(min, v, true)\n        min = v\n        minSV = new SemVer(min, options)\n      }\n    }\n  })\n  return min\n}\n\nexports.minVersion = minVersion\nfunction minVersion (range, loose) {\n  range = new Range(range, loose)\n\n  var minver = new SemVer('0.0.0')\n  if (range.test(minver)) {\n    return minver\n  }\n\n  minver = new SemVer('0.0.0-0')\n  if (range.test(minver)) {\n    return minver\n  }\n\n  minver = null\n  for (var i = 0; i < range.set.length; ++i) {\n    var comparators = range.set[i]\n\n    comparators.forEach(function (comparator) {\n      // Clone to avoid manipulating the comparator's semver object.\n      var compver = new SemVer(comparator.semver.version)\n      switch (comparator.operator) {\n        case '>':\n          if (compver.prerelease.length === 0) {\n            compver.patch++\n          } else {\n            compver.prerelease.push(0)\n          }\n          compver.raw = compver.format()\n          /* fallthrough */\n        case '':\n        case '>=':\n          if (!minver || gt(minver, compver)) {\n            minver = compver\n          }\n          break\n        case '<':\n        case '<=':\n          /* Ignore maximum versions */\n          break\n        /* istanbul ignore next */\n        default:\n          throw new Error('Unexpected operation: ' + comparator.operator)\n      }\n    })\n  }\n\n  if (minver && range.test(minver)) {\n    return minver\n  }\n\n  return null\n}\n\nexports.validRange = validRange\nfunction validRange (range, options) {\n  try {\n    // Return '*' instead of '' so that truthiness works.\n    // This will throw if it's invalid anyway\n    return new Range(range, options).range || '*'\n  } catch (er) {\n    return null\n  }\n}\n\n// Determine if version is less than all the versions possible in the range\nexports.ltr = ltr\nfunction ltr (version, range, options) {\n  return outside(version, range, '<', options)\n}\n\n// Determine if version is greater than all the versions possible in the range.\nexports.gtr = gtr\nfunction gtr (version, range, options) {\n  return outside(version, range, '>', options)\n}\n\nexports.outside = outside\nfunction outside (version, range, hilo, options) {\n  version = new SemVer(version, options)\n  range = new Range(range, options)\n\n  var gtfn, ltefn, ltfn, comp, ecomp\n  switch (hilo) {\n    case '>':\n      gtfn = gt\n      ltefn = lte\n      ltfn = lt\n      comp = '>'\n      ecomp = '>='\n      break\n    case '<':\n      gtfn = lt\n      ltefn = gte\n      ltfn = gt\n      comp = '<'\n      ecomp = '<='\n      break\n    default:\n      throw new TypeError('Must provide a hilo val of \"<\" or \">\"')\n  }\n\n  // If it satisifes the range it is not outside\n  if (satisfies(version, range, options)) {\n    return false\n  }\n\n  // From now on, variable terms are as if we're in \"gtr\" mode.\n  // but note that everything is flipped for the \"ltr\" function.\n\n  for (var i = 0; i < range.set.length; ++i) {\n    var comparators = range.set[i]\n\n    var high = null\n    var low = null\n\n    comparators.forEach(function (comparator) {\n      if (comparator.semver === ANY) {\n        comparator = new Comparator('>=0.0.0')\n      }\n      high = high || comparator\n      low = low || comparator\n      if (gtfn(comparator.semver, high.semver, options)) {\n        high = comparator\n      } else if (ltfn(comparator.semver, low.semver, options)) {\n        low = comparator\n      }\n    })\n\n    // If the edge version comparator has a operator then our version\n    // isn't outside it\n    if (high.operator === comp || high.operator === ecomp) {\n      return false\n    }\n\n    // If the lowest version comparator has an operator and our version\n    // is less than it then it isn't higher than the range\n    if ((!low.operator || low.operator === comp) &&\n        ltefn(version, low.semver)) {\n      return false\n    } else if (low.operator === ecomp && ltfn(version, low.semver)) {\n      return false\n    }\n  }\n  return true\n}\n\nexports.prerelease = prerelease\nfunction prerelease (version, options) {\n  var parsed = parse(version, options)\n  return (parsed && parsed.prerelease.length) ? parsed.prerelease : null\n}\n\nexports.intersects = intersects\nfunction intersects (r1, r2, options) {\n  r1 = new Range(r1, options)\n  r2 = new Range(r2, options)\n  return r1.intersects(r2)\n}\n\nexports.coerce = coerce\nfunction coerce (version, options) {\n  if (version instanceof SemVer) {\n    return version\n  }\n\n  if (typeof version === 'number') {\n    version = String(version)\n  }\n\n  if (typeof version !== 'string') {\n    return null\n  }\n\n  options = options || {}\n\n  var match = null\n  if (!options.rtl) {\n    match = version.match(re[t.COERCE])\n  } else {\n    // Find the right-most coercible string that does not share\n    // a terminus with a more left-ward coercible string.\n    // Eg, '1.2.3.4' wants to coerce '2.3.4', not '3.4' or '4'\n    //\n    // Walk through the string checking with a /g regexp\n    // Manually set the index so as to pick up overlapping matches.\n    // Stop when we get a match that ends at the string end, since no\n    // coercible string can be more right-ward without the same terminus.\n    var next\n    while ((next = re[t.COERCERTL].exec(version)) &&\n      (!match || match.index + match[0].length !== version.length)\n    ) {\n      if (!match ||\n          next.index + next[0].length !== match.index + match[0].length) {\n        match = next\n      }\n      re[t.COERCERTL].lastIndex = next.index + next[1].length + next[2].length\n    }\n    // leave it in a clean state\n    re[t.COERCERTL].lastIndex = -1\n  }\n\n  if (match === null) {\n    return null\n  }\n\n  return parse(match[2] +\n    '.' + (match[3] || '0') +\n    '.' + (match[4] || '0'), options)\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbWFrZS1kaXIvbm9kZV9tb2R1bGVzL3NlbXZlci9zZW12ZXIuanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQSwyQkFBMkI7O0FBRTNCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsU0FBUyxVQUFVO0FBQ25CLFVBQVUsV0FBVztBQUNyQixRQUFRLGNBQWM7QUFDdEI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isb0NBQW9DO0FBQ3hELDBCQUEwQixvQ0FBb0M7QUFDOUQsMEJBQTBCLG9DQUFvQztBQUM5RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYzs7QUFFZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUEsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBCQUEwQjs7QUFFMUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7O0FBRUEsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUEsZUFBZTtBQUNmO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBOztBQUVBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7O0FBRUEsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUEsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUEsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsV0FBVztBQUNYO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBLGtCQUFrQixxQkFBcUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLGdCQUFnQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsZ0JBQWdCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUEsa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0Isc0JBQXNCO0FBQ3hDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsa0JBQWtCLHNCQUFzQjtBQUN4Qzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdG9kby1saXN0Ly4vbm9kZV9tb2R1bGVzL21ha2UtZGlyL25vZGVfbW9kdWxlcy9zZW12ZXIvc2VtdmVyLmpzPzM5YjQiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gU2VtVmVyXG5cbnZhciBkZWJ1Z1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmlmICh0eXBlb2YgcHJvY2VzcyA9PT0gJ29iamVjdCcgJiZcbiAgICBwcm9jZXNzLmVudiAmJlxuICAgIHByb2Nlc3MuZW52Lk5PREVfREVCVUcgJiZcbiAgICAvXFxic2VtdmVyXFxiL2kudGVzdChwcm9jZXNzLmVudi5OT0RFX0RFQlVHKSkge1xuICBkZWJ1ZyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMClcbiAgICBhcmdzLnVuc2hpZnQoJ1NFTVZFUicpXG4gICAgY29uc29sZS5sb2cuYXBwbHkoY29uc29sZSwgYXJncylcbiAgfVxufSBlbHNlIHtcbiAgZGVidWcgPSBmdW5jdGlvbiAoKSB7fVxufVxuXG4vLyBOb3RlOiB0aGlzIGlzIHRoZSBzZW12ZXIub3JnIHZlcnNpb24gb2YgdGhlIHNwZWMgdGhhdCBpdCBpbXBsZW1lbnRzXG4vLyBOb3QgbmVjZXNzYXJpbHkgdGhlIHBhY2thZ2UgdmVyc2lvbiBvZiB0aGlzIGNvZGUuXG5leHBvcnRzLlNFTVZFUl9TUEVDX1ZFUlNJT04gPSAnMi4wLjAnXG5cbnZhciBNQVhfTEVOR1RIID0gMjU2XG52YXIgTUFYX1NBRkVfSU5URUdFUiA9IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSIHx8XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIDkwMDcxOTkyNTQ3NDA5OTFcblxuLy8gTWF4IHNhZmUgc2VnbWVudCBsZW5ndGggZm9yIGNvZXJjaW9uLlxudmFyIE1BWF9TQUZFX0NPTVBPTkVOVF9MRU5HVEggPSAxNlxuXG4vLyBUaGUgYWN0dWFsIHJlZ2V4cHMgZ28gb24gZXhwb3J0cy5yZVxudmFyIHJlID0gZXhwb3J0cy5yZSA9IFtdXG52YXIgc3JjID0gZXhwb3J0cy5zcmMgPSBbXVxudmFyIHQgPSBleHBvcnRzLnRva2VucyA9IHt9XG52YXIgUiA9IDBcblxuZnVuY3Rpb24gdG9rIChuKSB7XG4gIHRbbl0gPSBSKytcbn1cblxuLy8gVGhlIGZvbGxvd2luZyBSZWd1bGFyIEV4cHJlc3Npb25zIGNhbiBiZSB1c2VkIGZvciB0b2tlbml6aW5nLFxuLy8gdmFsaWRhdGluZywgYW5kIHBhcnNpbmcgU2VtVmVyIHZlcnNpb24gc3RyaW5ncy5cblxuLy8gIyMgTnVtZXJpYyBJZGVudGlmaWVyXG4vLyBBIHNpbmdsZSBgMGAsIG9yIGEgbm9uLXplcm8gZGlnaXQgZm9sbG93ZWQgYnkgemVybyBvciBtb3JlIGRpZ2l0cy5cblxudG9rKCdOVU1FUklDSURFTlRJRklFUicpXG5zcmNbdC5OVU1FUklDSURFTlRJRklFUl0gPSAnMHxbMS05XVxcXFxkKidcbnRvaygnTlVNRVJJQ0lERU5USUZJRVJMT09TRScpXG5zcmNbdC5OVU1FUklDSURFTlRJRklFUkxPT1NFXSA9ICdbMC05XSsnXG5cbi8vICMjIE5vbi1udW1lcmljIElkZW50aWZpZXJcbi8vIFplcm8gb3IgbW9yZSBkaWdpdHMsIGZvbGxvd2VkIGJ5IGEgbGV0dGVyIG9yIGh5cGhlbiwgYW5kIHRoZW4gemVybyBvclxuLy8gbW9yZSBsZXR0ZXJzLCBkaWdpdHMsIG9yIGh5cGhlbnMuXG5cbnRvaygnTk9OTlVNRVJJQ0lERU5USUZJRVInKVxuc3JjW3QuTk9OTlVNRVJJQ0lERU5USUZJRVJdID0gJ1xcXFxkKlthLXpBLVotXVthLXpBLVowLTktXSonXG5cbi8vICMjIE1haW4gVmVyc2lvblxuLy8gVGhyZWUgZG90LXNlcGFyYXRlZCBudW1lcmljIGlkZW50aWZpZXJzLlxuXG50b2soJ01BSU5WRVJTSU9OJylcbnNyY1t0Lk1BSU5WRVJTSU9OXSA9ICcoJyArIHNyY1t0Lk5VTUVSSUNJREVOVElGSUVSXSArICcpXFxcXC4nICtcbiAgICAgICAgICAgICAgICAgICAnKCcgKyBzcmNbdC5OVU1FUklDSURFTlRJRklFUl0gKyAnKVxcXFwuJyArXG4gICAgICAgICAgICAgICAgICAgJygnICsgc3JjW3QuTlVNRVJJQ0lERU5USUZJRVJdICsgJyknXG5cbnRvaygnTUFJTlZFUlNJT05MT09TRScpXG5zcmNbdC5NQUlOVkVSU0lPTkxPT1NFXSA9ICcoJyArIHNyY1t0Lk5VTUVSSUNJREVOVElGSUVSTE9PU0VdICsgJylcXFxcLicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJygnICsgc3JjW3QuTlVNRVJJQ0lERU5USUZJRVJMT09TRV0gKyAnKVxcXFwuJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnKCcgKyBzcmNbdC5OVU1FUklDSURFTlRJRklFUkxPT1NFXSArICcpJ1xuXG4vLyAjIyBQcmUtcmVsZWFzZSBWZXJzaW9uIElkZW50aWZpZXJcbi8vIEEgbnVtZXJpYyBpZGVudGlmaWVyLCBvciBhIG5vbi1udW1lcmljIGlkZW50aWZpZXIuXG5cbnRvaygnUFJFUkVMRUFTRUlERU5USUZJRVInKVxuc3JjW3QuUFJFUkVMRUFTRUlERU5USUZJRVJdID0gJyg/OicgKyBzcmNbdC5OVU1FUklDSURFTlRJRklFUl0gK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICd8JyArIHNyY1t0Lk5PTk5VTUVSSUNJREVOVElGSUVSXSArICcpJ1xuXG50b2soJ1BSRVJFTEVBU0VJREVOVElGSUVSTE9PU0UnKVxuc3JjW3QuUFJFUkVMRUFTRUlERU5USUZJRVJMT09TRV0gPSAnKD86JyArIHNyY1t0Lk5VTUVSSUNJREVOVElGSUVSTE9PU0VdICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICd8JyArIHNyY1t0Lk5PTk5VTUVSSUNJREVOVElGSUVSXSArICcpJ1xuXG4vLyAjIyBQcmUtcmVsZWFzZSBWZXJzaW9uXG4vLyBIeXBoZW4sIGZvbGxvd2VkIGJ5IG9uZSBvciBtb3JlIGRvdC1zZXBhcmF0ZWQgcHJlLXJlbGVhc2UgdmVyc2lvblxuLy8gaWRlbnRpZmllcnMuXG5cbnRvaygnUFJFUkVMRUFTRScpXG5zcmNbdC5QUkVSRUxFQVNFXSA9ICcoPzotKCcgKyBzcmNbdC5QUkVSRUxFQVNFSURFTlRJRklFUl0gK1xuICAgICAgICAgICAgICAgICAgJyg/OlxcXFwuJyArIHNyY1t0LlBSRVJFTEVBU0VJREVOVElGSUVSXSArICcpKikpJ1xuXG50b2soJ1BSRVJFTEVBU0VMT09TRScpXG5zcmNbdC5QUkVSRUxFQVNFTE9PU0VdID0gJyg/Oi0/KCcgKyBzcmNbdC5QUkVSRUxFQVNFSURFTlRJRklFUkxPT1NFXSArXG4gICAgICAgICAgICAgICAgICAgICAgICcoPzpcXFxcLicgKyBzcmNbdC5QUkVSRUxFQVNFSURFTlRJRklFUkxPT1NFXSArICcpKikpJ1xuXG4vLyAjIyBCdWlsZCBNZXRhZGF0YSBJZGVudGlmaWVyXG4vLyBBbnkgY29tYmluYXRpb24gb2YgZGlnaXRzLCBsZXR0ZXJzLCBvciBoeXBoZW5zLlxuXG50b2soJ0JVSUxESURFTlRJRklFUicpXG5zcmNbdC5CVUlMRElERU5USUZJRVJdID0gJ1swLTlBLVphLXotXSsnXG5cbi8vICMjIEJ1aWxkIE1ldGFkYXRhXG4vLyBQbHVzIHNpZ24sIGZvbGxvd2VkIGJ5IG9uZSBvciBtb3JlIHBlcmlvZC1zZXBhcmF0ZWQgYnVpbGQgbWV0YWRhdGFcbi8vIGlkZW50aWZpZXJzLlxuXG50b2soJ0JVSUxEJylcbnNyY1t0LkJVSUxEXSA9ICcoPzpcXFxcKygnICsgc3JjW3QuQlVJTERJREVOVElGSUVSXSArXG4gICAgICAgICAgICAgJyg/OlxcXFwuJyArIHNyY1t0LkJVSUxESURFTlRJRklFUl0gKyAnKSopKSdcblxuLy8gIyMgRnVsbCBWZXJzaW9uIFN0cmluZ1xuLy8gQSBtYWluIHZlcnNpb24sIGZvbGxvd2VkIG9wdGlvbmFsbHkgYnkgYSBwcmUtcmVsZWFzZSB2ZXJzaW9uIGFuZFxuLy8gYnVpbGQgbWV0YWRhdGEuXG5cbi8vIE5vdGUgdGhhdCB0aGUgb25seSBtYWpvciwgbWlub3IsIHBhdGNoLCBhbmQgcHJlLXJlbGVhc2Ugc2VjdGlvbnMgb2Zcbi8vIHRoZSB2ZXJzaW9uIHN0cmluZyBhcmUgY2FwdHVyaW5nIGdyb3Vwcy4gIFRoZSBidWlsZCBtZXRhZGF0YSBpcyBub3QgYVxuLy8gY2FwdHVyaW5nIGdyb3VwLCBiZWNhdXNlIGl0IHNob3VsZCBub3QgZXZlciBiZSB1c2VkIGluIHZlcnNpb25cbi8vIGNvbXBhcmlzb24uXG5cbnRvaygnRlVMTCcpXG50b2soJ0ZVTExQTEFJTicpXG5zcmNbdC5GVUxMUExBSU5dID0gJ3Y/JyArIHNyY1t0Lk1BSU5WRVJTSU9OXSArXG4gICAgICAgICAgICAgICAgICBzcmNbdC5QUkVSRUxFQVNFXSArICc/JyArXG4gICAgICAgICAgICAgICAgICBzcmNbdC5CVUlMRF0gKyAnPydcblxuc3JjW3QuRlVMTF0gPSAnXicgKyBzcmNbdC5GVUxMUExBSU5dICsgJyQnXG5cbi8vIGxpa2UgZnVsbCwgYnV0IGFsbG93cyB2MS4yLjMgYW5kID0xLjIuMywgd2hpY2ggcGVvcGxlIGRvIHNvbWV0aW1lcy5cbi8vIGFsc28sIDEuMC4wYWxwaGExIChwcmVyZWxlYXNlIHdpdGhvdXQgdGhlIGh5cGhlbikgd2hpY2ggaXMgcHJldHR5XG4vLyBjb21tb24gaW4gdGhlIG5wbSByZWdpc3RyeS5cbnRvaygnTE9PU0VQTEFJTicpXG5zcmNbdC5MT09TRVBMQUlOXSA9ICdbdj1cXFxcc10qJyArIHNyY1t0Lk1BSU5WRVJTSU9OTE9PU0VdICtcbiAgICAgICAgICAgICAgICAgIHNyY1t0LlBSRVJFTEVBU0VMT09TRV0gKyAnPycgK1xuICAgICAgICAgICAgICAgICAgc3JjW3QuQlVJTERdICsgJz8nXG5cbnRvaygnTE9PU0UnKVxuc3JjW3QuTE9PU0VdID0gJ14nICsgc3JjW3QuTE9PU0VQTEFJTl0gKyAnJCdcblxudG9rKCdHVExUJylcbnNyY1t0LkdUTFRdID0gJygoPzo8fD4pPz0/KSdcblxuLy8gU29tZXRoaW5nIGxpa2UgXCIyLipcIiBvciBcIjEuMi54XCIuXG4vLyBOb3RlIHRoYXQgXCJ4LnhcIiBpcyBhIHZhbGlkIHhSYW5nZSBpZGVudGlmZXIsIG1lYW5pbmcgXCJhbnkgdmVyc2lvblwiXG4vLyBPbmx5IHRoZSBmaXJzdCBpdGVtIGlzIHN0cmljdGx5IHJlcXVpcmVkLlxudG9rKCdYUkFOR0VJREVOVElGSUVSTE9PU0UnKVxuc3JjW3QuWFJBTkdFSURFTlRJRklFUkxPT1NFXSA9IHNyY1t0Lk5VTUVSSUNJREVOVElGSUVSTE9PU0VdICsgJ3x4fFh8XFxcXConXG50b2soJ1hSQU5HRUlERU5USUZJRVInKVxuc3JjW3QuWFJBTkdFSURFTlRJRklFUl0gPSBzcmNbdC5OVU1FUklDSURFTlRJRklFUl0gKyAnfHh8WHxcXFxcKidcblxudG9rKCdYUkFOR0VQTEFJTicpXG5zcmNbdC5YUkFOR0VQTEFJTl0gPSAnW3Y9XFxcXHNdKignICsgc3JjW3QuWFJBTkdFSURFTlRJRklFUl0gKyAnKScgK1xuICAgICAgICAgICAgICAgICAgICcoPzpcXFxcLignICsgc3JjW3QuWFJBTkdFSURFTlRJRklFUl0gKyAnKScgK1xuICAgICAgICAgICAgICAgICAgICcoPzpcXFxcLignICsgc3JjW3QuWFJBTkdFSURFTlRJRklFUl0gKyAnKScgK1xuICAgICAgICAgICAgICAgICAgICcoPzonICsgc3JjW3QuUFJFUkVMRUFTRV0gKyAnKT8nICtcbiAgICAgICAgICAgICAgICAgICBzcmNbdC5CVUlMRF0gKyAnPycgK1xuICAgICAgICAgICAgICAgICAgICcpPyk/J1xuXG50b2soJ1hSQU5HRVBMQUlOTE9PU0UnKVxuc3JjW3QuWFJBTkdFUExBSU5MT09TRV0gPSAnW3Y9XFxcXHNdKignICsgc3JjW3QuWFJBTkdFSURFTlRJRklFUkxPT1NFXSArICcpJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnKD86XFxcXC4oJyArIHNyY1t0LlhSQU5HRUlERU5USUZJRVJMT09TRV0gKyAnKScgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJyg/OlxcXFwuKCcgKyBzcmNbdC5YUkFOR0VJREVOVElGSUVSTE9PU0VdICsgJyknICtcbiAgICAgICAgICAgICAgICAgICAgICAgICcoPzonICsgc3JjW3QuUFJFUkVMRUFTRUxPT1NFXSArICcpPycgK1xuICAgICAgICAgICAgICAgICAgICAgICAgc3JjW3QuQlVJTERdICsgJz8nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICcpPyk/J1xuXG50b2soJ1hSQU5HRScpXG5zcmNbdC5YUkFOR0VdID0gJ14nICsgc3JjW3QuR1RMVF0gKyAnXFxcXHMqJyArIHNyY1t0LlhSQU5HRVBMQUlOXSArICckJ1xudG9rKCdYUkFOR0VMT09TRScpXG5zcmNbdC5YUkFOR0VMT09TRV0gPSAnXicgKyBzcmNbdC5HVExUXSArICdcXFxccyonICsgc3JjW3QuWFJBTkdFUExBSU5MT09TRV0gKyAnJCdcblxuLy8gQ29lcmNpb24uXG4vLyBFeHRyYWN0IGFueXRoaW5nIHRoYXQgY291bGQgY29uY2VpdmFibHkgYmUgYSBwYXJ0IG9mIGEgdmFsaWQgc2VtdmVyXG50b2soJ0NPRVJDRScpXG5zcmNbdC5DT0VSQ0VdID0gJyhefFteXFxcXGRdKScgK1xuICAgICAgICAgICAgICAnKFxcXFxkezEsJyArIE1BWF9TQUZFX0NPTVBPTkVOVF9MRU5HVEggKyAnfSknICtcbiAgICAgICAgICAgICAgJyg/OlxcXFwuKFxcXFxkezEsJyArIE1BWF9TQUZFX0NPTVBPTkVOVF9MRU5HVEggKyAnfSkpPycgK1xuICAgICAgICAgICAgICAnKD86XFxcXC4oXFxcXGR7MSwnICsgTUFYX1NBRkVfQ09NUE9ORU5UX0xFTkdUSCArICd9KSk/JyArXG4gICAgICAgICAgICAgICcoPzokfFteXFxcXGRdKSdcbnRvaygnQ09FUkNFUlRMJylcbnJlW3QuQ09FUkNFUlRMXSA9IG5ldyBSZWdFeHAoc3JjW3QuQ09FUkNFXSwgJ2cnKVxuXG4vLyBUaWxkZSByYW5nZXMuXG4vLyBNZWFuaW5nIGlzIFwicmVhc29uYWJseSBhdCBvciBncmVhdGVyIHRoYW5cIlxudG9rKCdMT05FVElMREUnKVxuc3JjW3QuTE9ORVRJTERFXSA9ICcoPzp+Pj8pJ1xuXG50b2soJ1RJTERFVFJJTScpXG5zcmNbdC5USUxERVRSSU1dID0gJyhcXFxccyopJyArIHNyY1t0LkxPTkVUSUxERV0gKyAnXFxcXHMrJ1xucmVbdC5USUxERVRSSU1dID0gbmV3IFJlZ0V4cChzcmNbdC5USUxERVRSSU1dLCAnZycpXG52YXIgdGlsZGVUcmltUmVwbGFjZSA9ICckMX4nXG5cbnRvaygnVElMREUnKVxuc3JjW3QuVElMREVdID0gJ14nICsgc3JjW3QuTE9ORVRJTERFXSArIHNyY1t0LlhSQU5HRVBMQUlOXSArICckJ1xudG9rKCdUSUxERUxPT1NFJylcbnNyY1t0LlRJTERFTE9PU0VdID0gJ14nICsgc3JjW3QuTE9ORVRJTERFXSArIHNyY1t0LlhSQU5HRVBMQUlOTE9PU0VdICsgJyQnXG5cbi8vIENhcmV0IHJhbmdlcy5cbi8vIE1lYW5pbmcgaXMgXCJhdCBsZWFzdCBhbmQgYmFja3dhcmRzIGNvbXBhdGlibGUgd2l0aFwiXG50b2soJ0xPTkVDQVJFVCcpXG5zcmNbdC5MT05FQ0FSRVRdID0gJyg/OlxcXFxeKSdcblxudG9rKCdDQVJFVFRSSU0nKVxuc3JjW3QuQ0FSRVRUUklNXSA9ICcoXFxcXHMqKScgKyBzcmNbdC5MT05FQ0FSRVRdICsgJ1xcXFxzKydcbnJlW3QuQ0FSRVRUUklNXSA9IG5ldyBSZWdFeHAoc3JjW3QuQ0FSRVRUUklNXSwgJ2cnKVxudmFyIGNhcmV0VHJpbVJlcGxhY2UgPSAnJDFeJ1xuXG50b2soJ0NBUkVUJylcbnNyY1t0LkNBUkVUXSA9ICdeJyArIHNyY1t0LkxPTkVDQVJFVF0gKyBzcmNbdC5YUkFOR0VQTEFJTl0gKyAnJCdcbnRvaygnQ0FSRVRMT09TRScpXG5zcmNbdC5DQVJFVExPT1NFXSA9ICdeJyArIHNyY1t0LkxPTkVDQVJFVF0gKyBzcmNbdC5YUkFOR0VQTEFJTkxPT1NFXSArICckJ1xuXG4vLyBBIHNpbXBsZSBndC9sdC9lcSB0aGluZywgb3IganVzdCBcIlwiIHRvIGluZGljYXRlIFwiYW55IHZlcnNpb25cIlxudG9rKCdDT01QQVJBVE9STE9PU0UnKVxuc3JjW3QuQ09NUEFSQVRPUkxPT1NFXSA9ICdeJyArIHNyY1t0LkdUTFRdICsgJ1xcXFxzKignICsgc3JjW3QuTE9PU0VQTEFJTl0gKyAnKSR8XiQnXG50b2soJ0NPTVBBUkFUT1InKVxuc3JjW3QuQ09NUEFSQVRPUl0gPSAnXicgKyBzcmNbdC5HVExUXSArICdcXFxccyooJyArIHNyY1t0LkZVTExQTEFJTl0gKyAnKSR8XiQnXG5cbi8vIEFuIGV4cHJlc3Npb24gdG8gc3RyaXAgYW55IHdoaXRlc3BhY2UgYmV0d2VlbiB0aGUgZ3RsdCBhbmQgdGhlIHRoaW5nXG4vLyBpdCBtb2RpZmllcywgc28gdGhhdCBgPiAxLjIuM2AgPT0+IGA+MS4yLjNgXG50b2soJ0NPTVBBUkFUT1JUUklNJylcbnNyY1t0LkNPTVBBUkFUT1JUUklNXSA9ICcoXFxcXHMqKScgKyBzcmNbdC5HVExUXSArXG4gICAgICAgICAgICAgICAgICAgICAgJ1xcXFxzKignICsgc3JjW3QuTE9PU0VQTEFJTl0gKyAnfCcgKyBzcmNbdC5YUkFOR0VQTEFJTl0gKyAnKSdcblxuLy8gdGhpcyBvbmUgaGFzIHRvIHVzZSB0aGUgL2cgZmxhZ1xucmVbdC5DT01QQVJBVE9SVFJJTV0gPSBuZXcgUmVnRXhwKHNyY1t0LkNPTVBBUkFUT1JUUklNXSwgJ2cnKVxudmFyIGNvbXBhcmF0b3JUcmltUmVwbGFjZSA9ICckMSQyJDMnXG5cbi8vIFNvbWV0aGluZyBsaWtlIGAxLjIuMyAtIDEuMi40YFxuLy8gTm90ZSB0aGF0IHRoZXNlIGFsbCB1c2UgdGhlIGxvb3NlIGZvcm0sIGJlY2F1c2UgdGhleSdsbCBiZVxuLy8gY2hlY2tlZCBhZ2FpbnN0IGVpdGhlciB0aGUgc3RyaWN0IG9yIGxvb3NlIGNvbXBhcmF0b3IgZm9ybVxuLy8gbGF0ZXIuXG50b2soJ0hZUEhFTlJBTkdFJylcbnNyY1t0LkhZUEhFTlJBTkdFXSA9ICdeXFxcXHMqKCcgKyBzcmNbdC5YUkFOR0VQTEFJTl0gKyAnKScgK1xuICAgICAgICAgICAgICAgICAgICdcXFxccystXFxcXHMrJyArXG4gICAgICAgICAgICAgICAgICAgJygnICsgc3JjW3QuWFJBTkdFUExBSU5dICsgJyknICtcbiAgICAgICAgICAgICAgICAgICAnXFxcXHMqJCdcblxudG9rKCdIWVBIRU5SQU5HRUxPT1NFJylcbnNyY1t0LkhZUEhFTlJBTkdFTE9PU0VdID0gJ15cXFxccyooJyArIHNyY1t0LlhSQU5HRVBMQUlOTE9PU0VdICsgJyknICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdcXFxccystXFxcXHMrJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnKCcgKyBzcmNbdC5YUkFOR0VQTEFJTkxPT1NFXSArICcpJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnXFxcXHMqJCdcblxuLy8gU3RhciByYW5nZXMgYmFzaWNhbGx5IGp1c3QgYWxsb3cgYW55dGhpbmcgYXQgYWxsLlxudG9rKCdTVEFSJylcbnNyY1t0LlNUQVJdID0gJyg8fD4pPz0/XFxcXHMqXFxcXConXG5cbi8vIENvbXBpbGUgdG8gYWN0dWFsIHJlZ2V4cCBvYmplY3RzLlxuLy8gQWxsIGFyZSBmbGFnLWZyZWUsIHVubGVzcyB0aGV5IHdlcmUgY3JlYXRlZCBhYm92ZSB3aXRoIGEgZmxhZy5cbmZvciAodmFyIGkgPSAwOyBpIDwgUjsgaSsrKSB7XG4gIGRlYnVnKGksIHNyY1tpXSlcbiAgaWYgKCFyZVtpXSkge1xuICAgIHJlW2ldID0gbmV3IFJlZ0V4cChzcmNbaV0pXG4gIH1cbn1cblxuZXhwb3J0cy5wYXJzZSA9IHBhcnNlXG5mdW5jdGlvbiBwYXJzZSAodmVyc2lvbiwgb3B0aW9ucykge1xuICBpZiAoIW9wdGlvbnMgfHwgdHlwZW9mIG9wdGlvbnMgIT09ICdvYmplY3QnKSB7XG4gICAgb3B0aW9ucyA9IHtcbiAgICAgIGxvb3NlOiAhIW9wdGlvbnMsXG4gICAgICBpbmNsdWRlUHJlcmVsZWFzZTogZmFsc2VcbiAgICB9XG4gIH1cblxuICBpZiAodmVyc2lvbiBpbnN0YW5jZW9mIFNlbVZlcikge1xuICAgIHJldHVybiB2ZXJzaW9uXG4gIH1cblxuICBpZiAodHlwZW9mIHZlcnNpb24gIT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIGlmICh2ZXJzaW9uLmxlbmd0aCA+IE1BWF9MRU5HVEgpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgdmFyIHIgPSBvcHRpb25zLmxvb3NlID8gcmVbdC5MT09TRV0gOiByZVt0LkZVTExdXG4gIGlmICghci50ZXN0KHZlcnNpb24pKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIHRyeSB7XG4gICAgcmV0dXJuIG5ldyBTZW1WZXIodmVyc2lvbiwgb3B0aW9ucylcbiAgfSBjYXRjaCAoZXIpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG59XG5cbmV4cG9ydHMudmFsaWQgPSB2YWxpZFxuZnVuY3Rpb24gdmFsaWQgKHZlcnNpb24sIG9wdGlvbnMpIHtcbiAgdmFyIHYgPSBwYXJzZSh2ZXJzaW9uLCBvcHRpb25zKVxuICByZXR1cm4gdiA/IHYudmVyc2lvbiA6IG51bGxcbn1cblxuZXhwb3J0cy5jbGVhbiA9IGNsZWFuXG5mdW5jdGlvbiBjbGVhbiAodmVyc2lvbiwgb3B0aW9ucykge1xuICB2YXIgcyA9IHBhcnNlKHZlcnNpb24udHJpbSgpLnJlcGxhY2UoL15bPXZdKy8sICcnKSwgb3B0aW9ucylcbiAgcmV0dXJuIHMgPyBzLnZlcnNpb24gOiBudWxsXG59XG5cbmV4cG9ydHMuU2VtVmVyID0gU2VtVmVyXG5cbmZ1bmN0aW9uIFNlbVZlciAodmVyc2lvbiwgb3B0aW9ucykge1xuICBpZiAoIW9wdGlvbnMgfHwgdHlwZW9mIG9wdGlvbnMgIT09ICdvYmplY3QnKSB7XG4gICAgb3B0aW9ucyA9IHtcbiAgICAgIGxvb3NlOiAhIW9wdGlvbnMsXG4gICAgICBpbmNsdWRlUHJlcmVsZWFzZTogZmFsc2VcbiAgICB9XG4gIH1cbiAgaWYgKHZlcnNpb24gaW5zdGFuY2VvZiBTZW1WZXIpIHtcbiAgICBpZiAodmVyc2lvbi5sb29zZSA9PT0gb3B0aW9ucy5sb29zZSkge1xuICAgICAgcmV0dXJuIHZlcnNpb25cbiAgICB9IGVsc2Uge1xuICAgICAgdmVyc2lvbiA9IHZlcnNpb24udmVyc2lvblxuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgdmVyc2lvbiAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIFZlcnNpb246ICcgKyB2ZXJzaW9uKVxuICB9XG5cbiAgaWYgKHZlcnNpb24ubGVuZ3RoID4gTUFYX0xFTkdUSCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3ZlcnNpb24gaXMgbG9uZ2VyIHRoYW4gJyArIE1BWF9MRU5HVEggKyAnIGNoYXJhY3RlcnMnKVxuICB9XG5cbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFNlbVZlcikpIHtcbiAgICByZXR1cm4gbmV3IFNlbVZlcih2ZXJzaW9uLCBvcHRpb25zKVxuICB9XG5cbiAgZGVidWcoJ1NlbVZlcicsIHZlcnNpb24sIG9wdGlvbnMpXG4gIHRoaXMub3B0aW9ucyA9IG9wdGlvbnNcbiAgdGhpcy5sb29zZSA9ICEhb3B0aW9ucy5sb29zZVxuXG4gIHZhciBtID0gdmVyc2lvbi50cmltKCkubWF0Y2gob3B0aW9ucy5sb29zZSA/IHJlW3QuTE9PU0VdIDogcmVbdC5GVUxMXSlcblxuICBpZiAoIW0pIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIFZlcnNpb246ICcgKyB2ZXJzaW9uKVxuICB9XG5cbiAgdGhpcy5yYXcgPSB2ZXJzaW9uXG5cbiAgLy8gdGhlc2UgYXJlIGFjdHVhbGx5IG51bWJlcnNcbiAgdGhpcy5tYWpvciA9ICttWzFdXG4gIHRoaXMubWlub3IgPSArbVsyXVxuICB0aGlzLnBhdGNoID0gK21bM11cblxuICBpZiAodGhpcy5tYWpvciA+IE1BWF9TQUZFX0lOVEVHRVIgfHwgdGhpcy5tYWpvciA8IDApIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIG1ham9yIHZlcnNpb24nKVxuICB9XG5cbiAgaWYgKHRoaXMubWlub3IgPiBNQVhfU0FGRV9JTlRFR0VSIHx8IHRoaXMubWlub3IgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBtaW5vciB2ZXJzaW9uJylcbiAgfVxuXG4gIGlmICh0aGlzLnBhdGNoID4gTUFYX1NBRkVfSU5URUdFUiB8fCB0aGlzLnBhdGNoIDwgMCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgcGF0Y2ggdmVyc2lvbicpXG4gIH1cblxuICAvLyBudW1iZXJpZnkgYW55IHByZXJlbGVhc2UgbnVtZXJpYyBpZHNcbiAgaWYgKCFtWzRdKSB7XG4gICAgdGhpcy5wcmVyZWxlYXNlID0gW11cbiAgfSBlbHNlIHtcbiAgICB0aGlzLnByZXJlbGVhc2UgPSBtWzRdLnNwbGl0KCcuJykubWFwKGZ1bmN0aW9uIChpZCkge1xuICAgICAgaWYgKC9eWzAtOV0rJC8udGVzdChpZCkpIHtcbiAgICAgICAgdmFyIG51bSA9ICtpZFxuICAgICAgICBpZiAobnVtID49IDAgJiYgbnVtIDwgTUFYX1NBRkVfSU5URUdFUikge1xuICAgICAgICAgIHJldHVybiBudW1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGlkXG4gICAgfSlcbiAgfVxuXG4gIHRoaXMuYnVpbGQgPSBtWzVdID8gbVs1XS5zcGxpdCgnLicpIDogW11cbiAgdGhpcy5mb3JtYXQoKVxufVxuXG5TZW1WZXIucHJvdG90eXBlLmZvcm1hdCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy52ZXJzaW9uID0gdGhpcy5tYWpvciArICcuJyArIHRoaXMubWlub3IgKyAnLicgKyB0aGlzLnBhdGNoXG4gIGlmICh0aGlzLnByZXJlbGVhc2UubGVuZ3RoKSB7XG4gICAgdGhpcy52ZXJzaW9uICs9ICctJyArIHRoaXMucHJlcmVsZWFzZS5qb2luKCcuJylcbiAgfVxuICByZXR1cm4gdGhpcy52ZXJzaW9uXG59XG5cblNlbVZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnZlcnNpb25cbn1cblxuU2VtVmVyLnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gKG90aGVyKSB7XG4gIGRlYnVnKCdTZW1WZXIuY29tcGFyZScsIHRoaXMudmVyc2lvbiwgdGhpcy5vcHRpb25zLCBvdGhlcilcbiAgaWYgKCEob3RoZXIgaW5zdGFuY2VvZiBTZW1WZXIpKSB7XG4gICAgb3RoZXIgPSBuZXcgU2VtVmVyKG90aGVyLCB0aGlzLm9wdGlvbnMpXG4gIH1cblxuICByZXR1cm4gdGhpcy5jb21wYXJlTWFpbihvdGhlcikgfHwgdGhpcy5jb21wYXJlUHJlKG90aGVyKVxufVxuXG5TZW1WZXIucHJvdG90eXBlLmNvbXBhcmVNYWluID0gZnVuY3Rpb24gKG90aGVyKSB7XG4gIGlmICghKG90aGVyIGluc3RhbmNlb2YgU2VtVmVyKSkge1xuICAgIG90aGVyID0gbmV3IFNlbVZlcihvdGhlciwgdGhpcy5vcHRpb25zKVxuICB9XG5cbiAgcmV0dXJuIGNvbXBhcmVJZGVudGlmaWVycyh0aGlzLm1ham9yLCBvdGhlci5tYWpvcikgfHxcbiAgICAgICAgIGNvbXBhcmVJZGVudGlmaWVycyh0aGlzLm1pbm9yLCBvdGhlci5taW5vcikgfHxcbiAgICAgICAgIGNvbXBhcmVJZGVudGlmaWVycyh0aGlzLnBhdGNoLCBvdGhlci5wYXRjaClcbn1cblxuU2VtVmVyLnByb3RvdHlwZS5jb21wYXJlUHJlID0gZnVuY3Rpb24gKG90aGVyKSB7XG4gIGlmICghKG90aGVyIGluc3RhbmNlb2YgU2VtVmVyKSkge1xuICAgIG90aGVyID0gbmV3IFNlbVZlcihvdGhlciwgdGhpcy5vcHRpb25zKVxuICB9XG5cbiAgLy8gTk9UIGhhdmluZyBhIHByZXJlbGVhc2UgaXMgPiBoYXZpbmcgb25lXG4gIGlmICh0aGlzLnByZXJlbGVhc2UubGVuZ3RoICYmICFvdGhlci5wcmVyZWxlYXNlLmxlbmd0aCkge1xuICAgIHJldHVybiAtMVxuICB9IGVsc2UgaWYgKCF0aGlzLnByZXJlbGVhc2UubGVuZ3RoICYmIG90aGVyLnByZXJlbGVhc2UubGVuZ3RoKSB7XG4gICAgcmV0dXJuIDFcbiAgfSBlbHNlIGlmICghdGhpcy5wcmVyZWxlYXNlLmxlbmd0aCAmJiAhb3RoZXIucHJlcmVsZWFzZS5sZW5ndGgpIHtcbiAgICByZXR1cm4gMFxuICB9XG5cbiAgdmFyIGkgPSAwXG4gIGRvIHtcbiAgICB2YXIgYSA9IHRoaXMucHJlcmVsZWFzZVtpXVxuICAgIHZhciBiID0gb3RoZXIucHJlcmVsZWFzZVtpXVxuICAgIGRlYnVnKCdwcmVyZWxlYXNlIGNvbXBhcmUnLCBpLCBhLCBiKVxuICAgIGlmIChhID09PSB1bmRlZmluZWQgJiYgYiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gMFxuICAgIH0gZWxzZSBpZiAoYiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gMVxuICAgIH0gZWxzZSBpZiAoYSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gLTFcbiAgICB9IGVsc2UgaWYgKGEgPT09IGIpIHtcbiAgICAgIGNvbnRpbnVlXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBjb21wYXJlSWRlbnRpZmllcnMoYSwgYilcbiAgICB9XG4gIH0gd2hpbGUgKCsraSlcbn1cblxuU2VtVmVyLnByb3RvdHlwZS5jb21wYXJlQnVpbGQgPSBmdW5jdGlvbiAob3RoZXIpIHtcbiAgaWYgKCEob3RoZXIgaW5zdGFuY2VvZiBTZW1WZXIpKSB7XG4gICAgb3RoZXIgPSBuZXcgU2VtVmVyKG90aGVyLCB0aGlzLm9wdGlvbnMpXG4gIH1cblxuICB2YXIgaSA9IDBcbiAgZG8ge1xuICAgIHZhciBhID0gdGhpcy5idWlsZFtpXVxuICAgIHZhciBiID0gb3RoZXIuYnVpbGRbaV1cbiAgICBkZWJ1ZygncHJlcmVsZWFzZSBjb21wYXJlJywgaSwgYSwgYilcbiAgICBpZiAoYSA9PT0gdW5kZWZpbmVkICYmIGIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIDBcbiAgICB9IGVsc2UgaWYgKGIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIDFcbiAgICB9IGVsc2UgaWYgKGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIC0xXG4gICAgfSBlbHNlIGlmIChhID09PSBiKSB7XG4gICAgICBjb250aW51ZVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gY29tcGFyZUlkZW50aWZpZXJzKGEsIGIpXG4gICAgfVxuICB9IHdoaWxlICgrK2kpXG59XG5cbi8vIHByZW1pbm9yIHdpbGwgYnVtcCB0aGUgdmVyc2lvbiB1cCB0byB0aGUgbmV4dCBtaW5vciByZWxlYXNlLCBhbmQgaW1tZWRpYXRlbHlcbi8vIGRvd24gdG8gcHJlLXJlbGVhc2UuIHByZW1ham9yIGFuZCBwcmVwYXRjaCB3b3JrIHRoZSBzYW1lIHdheS5cblNlbVZlci5wcm90b3R5cGUuaW5jID0gZnVuY3Rpb24gKHJlbGVhc2UsIGlkZW50aWZpZXIpIHtcbiAgc3dpdGNoIChyZWxlYXNlKSB7XG4gICAgY2FzZSAncHJlbWFqb3InOlxuICAgICAgdGhpcy5wcmVyZWxlYXNlLmxlbmd0aCA9IDBcbiAgICAgIHRoaXMucGF0Y2ggPSAwXG4gICAgICB0aGlzLm1pbm9yID0gMFxuICAgICAgdGhpcy5tYWpvcisrXG4gICAgICB0aGlzLmluYygncHJlJywgaWRlbnRpZmllcilcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAncHJlbWlub3InOlxuICAgICAgdGhpcy5wcmVyZWxlYXNlLmxlbmd0aCA9IDBcbiAgICAgIHRoaXMucGF0Y2ggPSAwXG4gICAgICB0aGlzLm1pbm9yKytcbiAgICAgIHRoaXMuaW5jKCdwcmUnLCBpZGVudGlmaWVyKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICdwcmVwYXRjaCc6XG4gICAgICAvLyBJZiB0aGlzIGlzIGFscmVhZHkgYSBwcmVyZWxlYXNlLCBpdCB3aWxsIGJ1bXAgdG8gdGhlIG5leHQgdmVyc2lvblxuICAgICAgLy8gZHJvcCBhbnkgcHJlcmVsZWFzZXMgdGhhdCBtaWdodCBhbHJlYWR5IGV4aXN0LCBzaW5jZSB0aGV5IGFyZSBub3RcbiAgICAgIC8vIHJlbGV2YW50IGF0IHRoaXMgcG9pbnQuXG4gICAgICB0aGlzLnByZXJlbGVhc2UubGVuZ3RoID0gMFxuICAgICAgdGhpcy5pbmMoJ3BhdGNoJywgaWRlbnRpZmllcilcbiAgICAgIHRoaXMuaW5jKCdwcmUnLCBpZGVudGlmaWVyKVxuICAgICAgYnJlYWtcbiAgICAvLyBJZiB0aGUgaW5wdXQgaXMgYSBub24tcHJlcmVsZWFzZSB2ZXJzaW9uLCB0aGlzIGFjdHMgdGhlIHNhbWUgYXNcbiAgICAvLyBwcmVwYXRjaC5cbiAgICBjYXNlICdwcmVyZWxlYXNlJzpcbiAgICAgIGlmICh0aGlzLnByZXJlbGVhc2UubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRoaXMuaW5jKCdwYXRjaCcsIGlkZW50aWZpZXIpXG4gICAgICB9XG4gICAgICB0aGlzLmluYygncHJlJywgaWRlbnRpZmllcilcbiAgICAgIGJyZWFrXG5cbiAgICBjYXNlICdtYWpvcic6XG4gICAgICAvLyBJZiB0aGlzIGlzIGEgcHJlLW1ham9yIHZlcnNpb24sIGJ1bXAgdXAgdG8gdGhlIHNhbWUgbWFqb3IgdmVyc2lvbi5cbiAgICAgIC8vIE90aGVyd2lzZSBpbmNyZW1lbnQgbWFqb3IuXG4gICAgICAvLyAxLjAuMC01IGJ1bXBzIHRvIDEuMC4wXG4gICAgICAvLyAxLjEuMCBidW1wcyB0byAyLjAuMFxuICAgICAgaWYgKHRoaXMubWlub3IgIT09IDAgfHxcbiAgICAgICAgICB0aGlzLnBhdGNoICE9PSAwIHx8XG4gICAgICAgICAgdGhpcy5wcmVyZWxlYXNlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aGlzLm1ham9yKytcbiAgICAgIH1cbiAgICAgIHRoaXMubWlub3IgPSAwXG4gICAgICB0aGlzLnBhdGNoID0gMFxuICAgICAgdGhpcy5wcmVyZWxlYXNlID0gW11cbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnbWlub3InOlxuICAgICAgLy8gSWYgdGhpcyBpcyBhIHByZS1taW5vciB2ZXJzaW9uLCBidW1wIHVwIHRvIHRoZSBzYW1lIG1pbm9yIHZlcnNpb24uXG4gICAgICAvLyBPdGhlcndpc2UgaW5jcmVtZW50IG1pbm9yLlxuICAgICAgLy8gMS4yLjAtNSBidW1wcyB0byAxLjIuMFxuICAgICAgLy8gMS4yLjEgYnVtcHMgdG8gMS4zLjBcbiAgICAgIGlmICh0aGlzLnBhdGNoICE9PSAwIHx8IHRoaXMucHJlcmVsZWFzZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhpcy5taW5vcisrXG4gICAgICB9XG4gICAgICB0aGlzLnBhdGNoID0gMFxuICAgICAgdGhpcy5wcmVyZWxlYXNlID0gW11cbiAgICAgIGJyZWFrXG4gICAgY2FzZSAncGF0Y2gnOlxuICAgICAgLy8gSWYgdGhpcyBpcyBub3QgYSBwcmUtcmVsZWFzZSB2ZXJzaW9uLCBpdCB3aWxsIGluY3JlbWVudCB0aGUgcGF0Y2guXG4gICAgICAvLyBJZiBpdCBpcyBhIHByZS1yZWxlYXNlIGl0IHdpbGwgYnVtcCB1cCB0byB0aGUgc2FtZSBwYXRjaCB2ZXJzaW9uLlxuICAgICAgLy8gMS4yLjAtNSBwYXRjaGVzIHRvIDEuMi4wXG4gICAgICAvLyAxLjIuMCBwYXRjaGVzIHRvIDEuMi4xXG4gICAgICBpZiAodGhpcy5wcmVyZWxlYXNlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aGlzLnBhdGNoKytcbiAgICAgIH1cbiAgICAgIHRoaXMucHJlcmVsZWFzZSA9IFtdXG4gICAgICBicmVha1xuICAgIC8vIFRoaXMgcHJvYmFibHkgc2hvdWxkbid0IGJlIHVzZWQgcHVibGljbHkuXG4gICAgLy8gMS4wLjAgXCJwcmVcIiB3b3VsZCBiZWNvbWUgMS4wLjAtMCB3aGljaCBpcyB0aGUgd3JvbmcgZGlyZWN0aW9uLlxuICAgIGNhc2UgJ3ByZSc6XG4gICAgICBpZiAodGhpcy5wcmVyZWxlYXNlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aGlzLnByZXJlbGVhc2UgPSBbMF1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBpID0gdGhpcy5wcmVyZWxlYXNlLmxlbmd0aFxuICAgICAgICB3aGlsZSAoLS1pID49IDApIHtcbiAgICAgICAgICBpZiAodHlwZW9mIHRoaXMucHJlcmVsZWFzZVtpXSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHRoaXMucHJlcmVsZWFzZVtpXSsrXG4gICAgICAgICAgICBpID0gLTJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGkgPT09IC0xKSB7XG4gICAgICAgICAgLy8gZGlkbid0IGluY3JlbWVudCBhbnl0aGluZ1xuICAgICAgICAgIHRoaXMucHJlcmVsZWFzZS5wdXNoKDApXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpZGVudGlmaWVyKSB7XG4gICAgICAgIC8vIDEuMi4wLWJldGEuMSBidW1wcyB0byAxLjIuMC1iZXRhLjIsXG4gICAgICAgIC8vIDEuMi4wLWJldGEuZm9vYmx6IG9yIDEuMi4wLWJldGEgYnVtcHMgdG8gMS4yLjAtYmV0YS4wXG4gICAgICAgIGlmICh0aGlzLnByZXJlbGVhc2VbMF0gPT09IGlkZW50aWZpZXIpIHtcbiAgICAgICAgICBpZiAoaXNOYU4odGhpcy5wcmVyZWxlYXNlWzFdKSkge1xuICAgICAgICAgICAgdGhpcy5wcmVyZWxlYXNlID0gW2lkZW50aWZpZXIsIDBdXG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucHJlcmVsZWFzZSA9IFtpZGVudGlmaWVyLCAwXVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBicmVha1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBpbmNyZW1lbnQgYXJndW1lbnQ6ICcgKyByZWxlYXNlKVxuICB9XG4gIHRoaXMuZm9ybWF0KClcbiAgdGhpcy5yYXcgPSB0aGlzLnZlcnNpb25cbiAgcmV0dXJuIHRoaXNcbn1cblxuZXhwb3J0cy5pbmMgPSBpbmNcbmZ1bmN0aW9uIGluYyAodmVyc2lvbiwgcmVsZWFzZSwgbG9vc2UsIGlkZW50aWZpZXIpIHtcbiAgaWYgKHR5cGVvZiAobG9vc2UpID09PSAnc3RyaW5nJykge1xuICAgIGlkZW50aWZpZXIgPSBsb29zZVxuICAgIGxvb3NlID0gdW5kZWZpbmVkXG4gIH1cblxuICB0cnkge1xuICAgIHJldHVybiBuZXcgU2VtVmVyKHZlcnNpb24sIGxvb3NlKS5pbmMocmVsZWFzZSwgaWRlbnRpZmllcikudmVyc2lvblxuICB9IGNhdGNoIChlcikge1xuICAgIHJldHVybiBudWxsXG4gIH1cbn1cblxuZXhwb3J0cy5kaWZmID0gZGlmZlxuZnVuY3Rpb24gZGlmZiAodmVyc2lvbjEsIHZlcnNpb24yKSB7XG4gIGlmIChlcSh2ZXJzaW9uMSwgdmVyc2lvbjIpKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfSBlbHNlIHtcbiAgICB2YXIgdjEgPSBwYXJzZSh2ZXJzaW9uMSlcbiAgICB2YXIgdjIgPSBwYXJzZSh2ZXJzaW9uMilcbiAgICB2YXIgcHJlZml4ID0gJydcbiAgICBpZiAodjEucHJlcmVsZWFzZS5sZW5ndGggfHwgdjIucHJlcmVsZWFzZS5sZW5ndGgpIHtcbiAgICAgIHByZWZpeCA9ICdwcmUnXG4gICAgICB2YXIgZGVmYXVsdFJlc3VsdCA9ICdwcmVyZWxlYXNlJ1xuICAgIH1cbiAgICBmb3IgKHZhciBrZXkgaW4gdjEpIHtcbiAgICAgIGlmIChrZXkgPT09ICdtYWpvcicgfHwga2V5ID09PSAnbWlub3InIHx8IGtleSA9PT0gJ3BhdGNoJykge1xuICAgICAgICBpZiAodjFba2V5XSAhPT0gdjJba2V5XSkge1xuICAgICAgICAgIHJldHVybiBwcmVmaXggKyBrZXlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZGVmYXVsdFJlc3VsdCAvLyBtYXkgYmUgdW5kZWZpbmVkXG4gIH1cbn1cblxuZXhwb3J0cy5jb21wYXJlSWRlbnRpZmllcnMgPSBjb21wYXJlSWRlbnRpZmllcnNcblxudmFyIG51bWVyaWMgPSAvXlswLTldKyQvXG5mdW5jdGlvbiBjb21wYXJlSWRlbnRpZmllcnMgKGEsIGIpIHtcbiAgdmFyIGFudW0gPSBudW1lcmljLnRlc3QoYSlcbiAgdmFyIGJudW0gPSBudW1lcmljLnRlc3QoYilcblxuICBpZiAoYW51bSAmJiBibnVtKSB7XG4gICAgYSA9ICthXG4gICAgYiA9ICtiXG4gIH1cblxuICByZXR1cm4gYSA9PT0gYiA/IDBcbiAgICA6IChhbnVtICYmICFibnVtKSA/IC0xXG4gICAgOiAoYm51bSAmJiAhYW51bSkgPyAxXG4gICAgOiBhIDwgYiA/IC0xXG4gICAgOiAxXG59XG5cbmV4cG9ydHMucmNvbXBhcmVJZGVudGlmaWVycyA9IHJjb21wYXJlSWRlbnRpZmllcnNcbmZ1bmN0aW9uIHJjb21wYXJlSWRlbnRpZmllcnMgKGEsIGIpIHtcbiAgcmV0dXJuIGNvbXBhcmVJZGVudGlmaWVycyhiLCBhKVxufVxuXG5leHBvcnRzLm1ham9yID0gbWFqb3JcbmZ1bmN0aW9uIG1ham9yIChhLCBsb29zZSkge1xuICByZXR1cm4gbmV3IFNlbVZlcihhLCBsb29zZSkubWFqb3Jcbn1cblxuZXhwb3J0cy5taW5vciA9IG1pbm9yXG5mdW5jdGlvbiBtaW5vciAoYSwgbG9vc2UpIHtcbiAgcmV0dXJuIG5ldyBTZW1WZXIoYSwgbG9vc2UpLm1pbm9yXG59XG5cbmV4cG9ydHMucGF0Y2ggPSBwYXRjaFxuZnVuY3Rpb24gcGF0Y2ggKGEsIGxvb3NlKSB7XG4gIHJldHVybiBuZXcgU2VtVmVyKGEsIGxvb3NlKS5wYXRjaFxufVxuXG5leHBvcnRzLmNvbXBhcmUgPSBjb21wYXJlXG5mdW5jdGlvbiBjb21wYXJlIChhLCBiLCBsb29zZSkge1xuICByZXR1cm4gbmV3IFNlbVZlcihhLCBsb29zZSkuY29tcGFyZShuZXcgU2VtVmVyKGIsIGxvb3NlKSlcbn1cblxuZXhwb3J0cy5jb21wYXJlTG9vc2UgPSBjb21wYXJlTG9vc2VcbmZ1bmN0aW9uIGNvbXBhcmVMb29zZSAoYSwgYikge1xuICByZXR1cm4gY29tcGFyZShhLCBiLCB0cnVlKVxufVxuXG5leHBvcnRzLmNvbXBhcmVCdWlsZCA9IGNvbXBhcmVCdWlsZFxuZnVuY3Rpb24gY29tcGFyZUJ1aWxkIChhLCBiLCBsb29zZSkge1xuICB2YXIgdmVyc2lvbkEgPSBuZXcgU2VtVmVyKGEsIGxvb3NlKVxuICB2YXIgdmVyc2lvbkIgPSBuZXcgU2VtVmVyKGIsIGxvb3NlKVxuICByZXR1cm4gdmVyc2lvbkEuY29tcGFyZSh2ZXJzaW9uQikgfHwgdmVyc2lvbkEuY29tcGFyZUJ1aWxkKHZlcnNpb25CKVxufVxuXG5leHBvcnRzLnJjb21wYXJlID0gcmNvbXBhcmVcbmZ1bmN0aW9uIHJjb21wYXJlIChhLCBiLCBsb29zZSkge1xuICByZXR1cm4gY29tcGFyZShiLCBhLCBsb29zZSlcbn1cblxuZXhwb3J0cy5zb3J0ID0gc29ydFxuZnVuY3Rpb24gc29ydCAobGlzdCwgbG9vc2UpIHtcbiAgcmV0dXJuIGxpc3Quc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBleHBvcnRzLmNvbXBhcmVCdWlsZChhLCBiLCBsb29zZSlcbiAgfSlcbn1cblxuZXhwb3J0cy5yc29ydCA9IHJzb3J0XG5mdW5jdGlvbiByc29ydCAobGlzdCwgbG9vc2UpIHtcbiAgcmV0dXJuIGxpc3Quc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBleHBvcnRzLmNvbXBhcmVCdWlsZChiLCBhLCBsb29zZSlcbiAgfSlcbn1cblxuZXhwb3J0cy5ndCA9IGd0XG5mdW5jdGlvbiBndCAoYSwgYiwgbG9vc2UpIHtcbiAgcmV0dXJuIGNvbXBhcmUoYSwgYiwgbG9vc2UpID4gMFxufVxuXG5leHBvcnRzLmx0ID0gbHRcbmZ1bmN0aW9uIGx0IChhLCBiLCBsb29zZSkge1xuICByZXR1cm4gY29tcGFyZShhLCBiLCBsb29zZSkgPCAwXG59XG5cbmV4cG9ydHMuZXEgPSBlcVxuZnVuY3Rpb24gZXEgKGEsIGIsIGxvb3NlKSB7XG4gIHJldHVybiBjb21wYXJlKGEsIGIsIGxvb3NlKSA9PT0gMFxufVxuXG5leHBvcnRzLm5lcSA9IG5lcVxuZnVuY3Rpb24gbmVxIChhLCBiLCBsb29zZSkge1xuICByZXR1cm4gY29tcGFyZShhLCBiLCBsb29zZSkgIT09IDBcbn1cblxuZXhwb3J0cy5ndGUgPSBndGVcbmZ1bmN0aW9uIGd0ZSAoYSwgYiwgbG9vc2UpIHtcbiAgcmV0dXJuIGNvbXBhcmUoYSwgYiwgbG9vc2UpID49IDBcbn1cblxuZXhwb3J0cy5sdGUgPSBsdGVcbmZ1bmN0aW9uIGx0ZSAoYSwgYiwgbG9vc2UpIHtcbiAgcmV0dXJuIGNvbXBhcmUoYSwgYiwgbG9vc2UpIDw9IDBcbn1cblxuZXhwb3J0cy5jbXAgPSBjbXBcbmZ1bmN0aW9uIGNtcCAoYSwgb3AsIGIsIGxvb3NlKSB7XG4gIHN3aXRjaCAob3ApIHtcbiAgICBjYXNlICc9PT0nOlxuICAgICAgaWYgKHR5cGVvZiBhID09PSAnb2JqZWN0JylcbiAgICAgICAgYSA9IGEudmVyc2lvblxuICAgICAgaWYgKHR5cGVvZiBiID09PSAnb2JqZWN0JylcbiAgICAgICAgYiA9IGIudmVyc2lvblxuICAgICAgcmV0dXJuIGEgPT09IGJcblxuICAgIGNhc2UgJyE9PSc6XG4gICAgICBpZiAodHlwZW9mIGEgPT09ICdvYmplY3QnKVxuICAgICAgICBhID0gYS52ZXJzaW9uXG4gICAgICBpZiAodHlwZW9mIGIgPT09ICdvYmplY3QnKVxuICAgICAgICBiID0gYi52ZXJzaW9uXG4gICAgICByZXR1cm4gYSAhPT0gYlxuXG4gICAgY2FzZSAnJzpcbiAgICBjYXNlICc9JzpcbiAgICBjYXNlICc9PSc6XG4gICAgICByZXR1cm4gZXEoYSwgYiwgbG9vc2UpXG5cbiAgICBjYXNlICchPSc6XG4gICAgICByZXR1cm4gbmVxKGEsIGIsIGxvb3NlKVxuXG4gICAgY2FzZSAnPic6XG4gICAgICByZXR1cm4gZ3QoYSwgYiwgbG9vc2UpXG5cbiAgICBjYXNlICc+PSc6XG4gICAgICByZXR1cm4gZ3RlKGEsIGIsIGxvb3NlKVxuXG4gICAgY2FzZSAnPCc6XG4gICAgICByZXR1cm4gbHQoYSwgYiwgbG9vc2UpXG5cbiAgICBjYXNlICc8PSc6XG4gICAgICByZXR1cm4gbHRlKGEsIGIsIGxvb3NlKVxuXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgb3BlcmF0b3I6ICcgKyBvcClcbiAgfVxufVxuXG5leHBvcnRzLkNvbXBhcmF0b3IgPSBDb21wYXJhdG9yXG5mdW5jdGlvbiBDb21wYXJhdG9yIChjb21wLCBvcHRpb25zKSB7XG4gIGlmICghb3B0aW9ucyB8fCB0eXBlb2Ygb3B0aW9ucyAhPT0gJ29iamVjdCcpIHtcbiAgICBvcHRpb25zID0ge1xuICAgICAgbG9vc2U6ICEhb3B0aW9ucyxcbiAgICAgIGluY2x1ZGVQcmVyZWxlYXNlOiBmYWxzZVxuICAgIH1cbiAgfVxuXG4gIGlmIChjb21wIGluc3RhbmNlb2YgQ29tcGFyYXRvcikge1xuICAgIGlmIChjb21wLmxvb3NlID09PSAhIW9wdGlvbnMubG9vc2UpIHtcbiAgICAgIHJldHVybiBjb21wXG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbXAgPSBjb21wLnZhbHVlXG4gICAgfVxuICB9XG5cbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIENvbXBhcmF0b3IpKSB7XG4gICAgcmV0dXJuIG5ldyBDb21wYXJhdG9yKGNvbXAsIG9wdGlvbnMpXG4gIH1cblxuICBkZWJ1ZygnY29tcGFyYXRvcicsIGNvbXAsIG9wdGlvbnMpXG4gIHRoaXMub3B0aW9ucyA9IG9wdGlvbnNcbiAgdGhpcy5sb29zZSA9ICEhb3B0aW9ucy5sb29zZVxuICB0aGlzLnBhcnNlKGNvbXApXG5cbiAgaWYgKHRoaXMuc2VtdmVyID09PSBBTlkpIHtcbiAgICB0aGlzLnZhbHVlID0gJydcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnZhbHVlID0gdGhpcy5vcGVyYXRvciArIHRoaXMuc2VtdmVyLnZlcnNpb25cbiAgfVxuXG4gIGRlYnVnKCdjb21wJywgdGhpcylcbn1cblxudmFyIEFOWSA9IHt9XG5Db21wYXJhdG9yLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uIChjb21wKSB7XG4gIHZhciByID0gdGhpcy5vcHRpb25zLmxvb3NlID8gcmVbdC5DT01QQVJBVE9STE9PU0VdIDogcmVbdC5DT01QQVJBVE9SXVxuICB2YXIgbSA9IGNvbXAubWF0Y2gocilcblxuICBpZiAoIW0pIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGNvbXBhcmF0b3I6ICcgKyBjb21wKVxuICB9XG5cbiAgdGhpcy5vcGVyYXRvciA9IG1bMV0gIT09IHVuZGVmaW5lZCA/IG1bMV0gOiAnJ1xuICBpZiAodGhpcy5vcGVyYXRvciA9PT0gJz0nKSB7XG4gICAgdGhpcy5vcGVyYXRvciA9ICcnXG4gIH1cblxuICAvLyBpZiBpdCBsaXRlcmFsbHkgaXMganVzdCAnPicgb3IgJycgdGhlbiBhbGxvdyBhbnl0aGluZy5cbiAgaWYgKCFtWzJdKSB7XG4gICAgdGhpcy5zZW12ZXIgPSBBTllcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnNlbXZlciA9IG5ldyBTZW1WZXIobVsyXSwgdGhpcy5vcHRpb25zLmxvb3NlKVxuICB9XG59XG5cbkNvbXBhcmF0b3IucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy52YWx1ZVxufVxuXG5Db21wYXJhdG9yLnByb3RvdHlwZS50ZXN0ID0gZnVuY3Rpb24gKHZlcnNpb24pIHtcbiAgZGVidWcoJ0NvbXBhcmF0b3IudGVzdCcsIHZlcnNpb24sIHRoaXMub3B0aW9ucy5sb29zZSlcblxuICBpZiAodGhpcy5zZW12ZXIgPT09IEFOWSB8fCB2ZXJzaW9uID09PSBBTlkpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgaWYgKHR5cGVvZiB2ZXJzaW9uID09PSAnc3RyaW5nJykge1xuICAgIHRyeSB7XG4gICAgICB2ZXJzaW9uID0gbmV3IFNlbVZlcih2ZXJzaW9uLCB0aGlzLm9wdGlvbnMpXG4gICAgfSBjYXRjaCAoZXIpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjbXAodmVyc2lvbiwgdGhpcy5vcGVyYXRvciwgdGhpcy5zZW12ZXIsIHRoaXMub3B0aW9ucylcbn1cblxuQ29tcGFyYXRvci5wcm90b3R5cGUuaW50ZXJzZWN0cyA9IGZ1bmN0aW9uIChjb21wLCBvcHRpb25zKSB7XG4gIGlmICghKGNvbXAgaW5zdGFuY2VvZiBDb21wYXJhdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2EgQ29tcGFyYXRvciBpcyByZXF1aXJlZCcpXG4gIH1cblxuICBpZiAoIW9wdGlvbnMgfHwgdHlwZW9mIG9wdGlvbnMgIT09ICdvYmplY3QnKSB7XG4gICAgb3B0aW9ucyA9IHtcbiAgICAgIGxvb3NlOiAhIW9wdGlvbnMsXG4gICAgICBpbmNsdWRlUHJlcmVsZWFzZTogZmFsc2VcbiAgICB9XG4gIH1cblxuICB2YXIgcmFuZ2VUbXBcblxuICBpZiAodGhpcy5vcGVyYXRvciA9PT0gJycpIHtcbiAgICBpZiAodGhpcy52YWx1ZSA9PT0gJycpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHJhbmdlVG1wID0gbmV3IFJhbmdlKGNvbXAudmFsdWUsIG9wdGlvbnMpXG4gICAgcmV0dXJuIHNhdGlzZmllcyh0aGlzLnZhbHVlLCByYW5nZVRtcCwgb3B0aW9ucylcbiAgfSBlbHNlIGlmIChjb21wLm9wZXJhdG9yID09PSAnJykge1xuICAgIGlmIChjb21wLnZhbHVlID09PSAnJykge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgcmFuZ2VUbXAgPSBuZXcgUmFuZ2UodGhpcy52YWx1ZSwgb3B0aW9ucylcbiAgICByZXR1cm4gc2F0aXNmaWVzKGNvbXAuc2VtdmVyLCByYW5nZVRtcCwgb3B0aW9ucylcbiAgfVxuXG4gIHZhciBzYW1lRGlyZWN0aW9uSW5jcmVhc2luZyA9XG4gICAgKHRoaXMub3BlcmF0b3IgPT09ICc+PScgfHwgdGhpcy5vcGVyYXRvciA9PT0gJz4nKSAmJlxuICAgIChjb21wLm9wZXJhdG9yID09PSAnPj0nIHx8IGNvbXAub3BlcmF0b3IgPT09ICc+JylcbiAgdmFyIHNhbWVEaXJlY3Rpb25EZWNyZWFzaW5nID1cbiAgICAodGhpcy5vcGVyYXRvciA9PT0gJzw9JyB8fCB0aGlzLm9wZXJhdG9yID09PSAnPCcpICYmXG4gICAgKGNvbXAub3BlcmF0b3IgPT09ICc8PScgfHwgY29tcC5vcGVyYXRvciA9PT0gJzwnKVxuICB2YXIgc2FtZVNlbVZlciA9IHRoaXMuc2VtdmVyLnZlcnNpb24gPT09IGNvbXAuc2VtdmVyLnZlcnNpb25cbiAgdmFyIGRpZmZlcmVudERpcmVjdGlvbnNJbmNsdXNpdmUgPVxuICAgICh0aGlzLm9wZXJhdG9yID09PSAnPj0nIHx8IHRoaXMub3BlcmF0b3IgPT09ICc8PScpICYmXG4gICAgKGNvbXAub3BlcmF0b3IgPT09ICc+PScgfHwgY29tcC5vcGVyYXRvciA9PT0gJzw9JylcbiAgdmFyIG9wcG9zaXRlRGlyZWN0aW9uc0xlc3NUaGFuID1cbiAgICBjbXAodGhpcy5zZW12ZXIsICc8JywgY29tcC5zZW12ZXIsIG9wdGlvbnMpICYmXG4gICAgKCh0aGlzLm9wZXJhdG9yID09PSAnPj0nIHx8IHRoaXMub3BlcmF0b3IgPT09ICc+JykgJiZcbiAgICAoY29tcC5vcGVyYXRvciA9PT0gJzw9JyB8fCBjb21wLm9wZXJhdG9yID09PSAnPCcpKVxuICB2YXIgb3Bwb3NpdGVEaXJlY3Rpb25zR3JlYXRlclRoYW4gPVxuICAgIGNtcCh0aGlzLnNlbXZlciwgJz4nLCBjb21wLnNlbXZlciwgb3B0aW9ucykgJiZcbiAgICAoKHRoaXMub3BlcmF0b3IgPT09ICc8PScgfHwgdGhpcy5vcGVyYXRvciA9PT0gJzwnKSAmJlxuICAgIChjb21wLm9wZXJhdG9yID09PSAnPj0nIHx8IGNvbXAub3BlcmF0b3IgPT09ICc+JykpXG5cbiAgcmV0dXJuIHNhbWVEaXJlY3Rpb25JbmNyZWFzaW5nIHx8IHNhbWVEaXJlY3Rpb25EZWNyZWFzaW5nIHx8XG4gICAgKHNhbWVTZW1WZXIgJiYgZGlmZmVyZW50RGlyZWN0aW9uc0luY2x1c2l2ZSkgfHxcbiAgICBvcHBvc2l0ZURpcmVjdGlvbnNMZXNzVGhhbiB8fCBvcHBvc2l0ZURpcmVjdGlvbnNHcmVhdGVyVGhhblxufVxuXG5leHBvcnRzLlJhbmdlID0gUmFuZ2VcbmZ1bmN0aW9uIFJhbmdlIChyYW5nZSwgb3B0aW9ucykge1xuICBpZiAoIW9wdGlvbnMgfHwgdHlwZW9mIG9wdGlvbnMgIT09ICdvYmplY3QnKSB7XG4gICAgb3B0aW9ucyA9IHtcbiAgICAgIGxvb3NlOiAhIW9wdGlvbnMsXG4gICAgICBpbmNsdWRlUHJlcmVsZWFzZTogZmFsc2VcbiAgICB9XG4gIH1cblxuICBpZiAocmFuZ2UgaW5zdGFuY2VvZiBSYW5nZSkge1xuICAgIGlmIChyYW5nZS5sb29zZSA9PT0gISFvcHRpb25zLmxvb3NlICYmXG4gICAgICAgIHJhbmdlLmluY2x1ZGVQcmVyZWxlYXNlID09PSAhIW9wdGlvbnMuaW5jbHVkZVByZXJlbGVhc2UpIHtcbiAgICAgIHJldHVybiByYW5nZVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbmV3IFJhbmdlKHJhbmdlLnJhdywgb3B0aW9ucylcbiAgICB9XG4gIH1cblxuICBpZiAocmFuZ2UgaW5zdGFuY2VvZiBDb21wYXJhdG9yKSB7XG4gICAgcmV0dXJuIG5ldyBSYW5nZShyYW5nZS52YWx1ZSwgb3B0aW9ucylcbiAgfVxuXG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBSYW5nZSkpIHtcbiAgICByZXR1cm4gbmV3IFJhbmdlKHJhbmdlLCBvcHRpb25zKVxuICB9XG5cbiAgdGhpcy5vcHRpb25zID0gb3B0aW9uc1xuICB0aGlzLmxvb3NlID0gISFvcHRpb25zLmxvb3NlXG4gIHRoaXMuaW5jbHVkZVByZXJlbGVhc2UgPSAhIW9wdGlvbnMuaW5jbHVkZVByZXJlbGVhc2VcblxuICAvLyBGaXJzdCwgc3BsaXQgYmFzZWQgb24gYm9vbGVhbiBvciB8fFxuICB0aGlzLnJhdyA9IHJhbmdlXG4gIHRoaXMuc2V0ID0gcmFuZ2Uuc3BsaXQoL1xccypcXHxcXHxcXHMqLykubWFwKGZ1bmN0aW9uIChyYW5nZSkge1xuICAgIHJldHVybiB0aGlzLnBhcnNlUmFuZ2UocmFuZ2UudHJpbSgpKVxuICB9LCB0aGlzKS5maWx0ZXIoZnVuY3Rpb24gKGMpIHtcbiAgICAvLyB0aHJvdyBvdXQgYW55IHRoYXQgYXJlIG5vdCByZWxldmFudCBmb3Igd2hhdGV2ZXIgcmVhc29uXG4gICAgcmV0dXJuIGMubGVuZ3RoXG4gIH0pXG5cbiAgaWYgKCF0aGlzLnNldC5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIFNlbVZlciBSYW5nZTogJyArIHJhbmdlKVxuICB9XG5cbiAgdGhpcy5mb3JtYXQoKVxufVxuXG5SYW5nZS5wcm90b3R5cGUuZm9ybWF0ID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLnJhbmdlID0gdGhpcy5zZXQubWFwKGZ1bmN0aW9uIChjb21wcykge1xuICAgIHJldHVybiBjb21wcy5qb2luKCcgJykudHJpbSgpXG4gIH0pLmpvaW4oJ3x8JykudHJpbSgpXG4gIHJldHVybiB0aGlzLnJhbmdlXG59XG5cblJhbmdlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMucmFuZ2Vcbn1cblxuUmFuZ2UucHJvdG90eXBlLnBhcnNlUmFuZ2UgPSBmdW5jdGlvbiAocmFuZ2UpIHtcbiAgdmFyIGxvb3NlID0gdGhpcy5vcHRpb25zLmxvb3NlXG4gIHJhbmdlID0gcmFuZ2UudHJpbSgpXG4gIC8vIGAxLjIuMyAtIDEuMi40YCA9PiBgPj0xLjIuMyA8PTEuMi40YFxuICB2YXIgaHIgPSBsb29zZSA/IHJlW3QuSFlQSEVOUkFOR0VMT09TRV0gOiByZVt0LkhZUEhFTlJBTkdFXVxuICByYW5nZSA9IHJhbmdlLnJlcGxhY2UoaHIsIGh5cGhlblJlcGxhY2UpXG4gIGRlYnVnKCdoeXBoZW4gcmVwbGFjZScsIHJhbmdlKVxuICAvLyBgPiAxLjIuMyA8IDEuMi41YCA9PiBgPjEuMi4zIDwxLjIuNWBcbiAgcmFuZ2UgPSByYW5nZS5yZXBsYWNlKHJlW3QuQ09NUEFSQVRPUlRSSU1dLCBjb21wYXJhdG9yVHJpbVJlcGxhY2UpXG4gIGRlYnVnKCdjb21wYXJhdG9yIHRyaW0nLCByYW5nZSwgcmVbdC5DT01QQVJBVE9SVFJJTV0pXG5cbiAgLy8gYH4gMS4yLjNgID0+IGB+MS4yLjNgXG4gIHJhbmdlID0gcmFuZ2UucmVwbGFjZShyZVt0LlRJTERFVFJJTV0sIHRpbGRlVHJpbVJlcGxhY2UpXG5cbiAgLy8gYF4gMS4yLjNgID0+IGBeMS4yLjNgXG4gIHJhbmdlID0gcmFuZ2UucmVwbGFjZShyZVt0LkNBUkVUVFJJTV0sIGNhcmV0VHJpbVJlcGxhY2UpXG5cbiAgLy8gbm9ybWFsaXplIHNwYWNlc1xuICByYW5nZSA9IHJhbmdlLnNwbGl0KC9cXHMrLykuam9pbignICcpXG5cbiAgLy8gQXQgdGhpcyBwb2ludCwgdGhlIHJhbmdlIGlzIGNvbXBsZXRlbHkgdHJpbW1lZCBhbmRcbiAgLy8gcmVhZHkgdG8gYmUgc3BsaXQgaW50byBjb21wYXJhdG9ycy5cblxuICB2YXIgY29tcFJlID0gbG9vc2UgPyByZVt0LkNPTVBBUkFUT1JMT09TRV0gOiByZVt0LkNPTVBBUkFUT1JdXG4gIHZhciBzZXQgPSByYW5nZS5zcGxpdCgnICcpLm1hcChmdW5jdGlvbiAoY29tcCkge1xuICAgIHJldHVybiBwYXJzZUNvbXBhcmF0b3IoY29tcCwgdGhpcy5vcHRpb25zKVxuICB9LCB0aGlzKS5qb2luKCcgJykuc3BsaXQoL1xccysvKVxuICBpZiAodGhpcy5vcHRpb25zLmxvb3NlKSB7XG4gICAgLy8gaW4gbG9vc2UgbW9kZSwgdGhyb3cgb3V0IGFueSB0aGF0IGFyZSBub3QgdmFsaWQgY29tcGFyYXRvcnNcbiAgICBzZXQgPSBzZXQuZmlsdGVyKGZ1bmN0aW9uIChjb21wKSB7XG4gICAgICByZXR1cm4gISFjb21wLm1hdGNoKGNvbXBSZSlcbiAgICB9KVxuICB9XG4gIHNldCA9IHNldC5tYXAoZnVuY3Rpb24gKGNvbXApIHtcbiAgICByZXR1cm4gbmV3IENvbXBhcmF0b3IoY29tcCwgdGhpcy5vcHRpb25zKVxuICB9LCB0aGlzKVxuXG4gIHJldHVybiBzZXRcbn1cblxuUmFuZ2UucHJvdG90eXBlLmludGVyc2VjdHMgPSBmdW5jdGlvbiAocmFuZ2UsIG9wdGlvbnMpIHtcbiAgaWYgKCEocmFuZ2UgaW5zdGFuY2VvZiBSYW5nZSkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdhIFJhbmdlIGlzIHJlcXVpcmVkJylcbiAgfVxuXG4gIHJldHVybiB0aGlzLnNldC5zb21lKGZ1bmN0aW9uICh0aGlzQ29tcGFyYXRvcnMpIHtcbiAgICByZXR1cm4gKFxuICAgICAgaXNTYXRpc2ZpYWJsZSh0aGlzQ29tcGFyYXRvcnMsIG9wdGlvbnMpICYmXG4gICAgICByYW5nZS5zZXQuc29tZShmdW5jdGlvbiAocmFuZ2VDb21wYXJhdG9ycykge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIGlzU2F0aXNmaWFibGUocmFuZ2VDb21wYXJhdG9ycywgb3B0aW9ucykgJiZcbiAgICAgICAgICB0aGlzQ29tcGFyYXRvcnMuZXZlcnkoZnVuY3Rpb24gKHRoaXNDb21wYXJhdG9yKSB7XG4gICAgICAgICAgICByZXR1cm4gcmFuZ2VDb21wYXJhdG9ycy5ldmVyeShmdW5jdGlvbiAocmFuZ2VDb21wYXJhdG9yKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzQ29tcGFyYXRvci5pbnRlcnNlY3RzKHJhbmdlQ29tcGFyYXRvciwgb3B0aW9ucylcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfSlcbiAgICAgICAgKVxuICAgICAgfSlcbiAgICApXG4gIH0pXG59XG5cbi8vIHRha2UgYSBzZXQgb2YgY29tcGFyYXRvcnMgYW5kIGRldGVybWluZSB3aGV0aGVyIHRoZXJlXG4vLyBleGlzdHMgYSB2ZXJzaW9uIHdoaWNoIGNhbiBzYXRpc2Z5IGl0XG5mdW5jdGlvbiBpc1NhdGlzZmlhYmxlIChjb21wYXJhdG9ycywgb3B0aW9ucykge1xuICB2YXIgcmVzdWx0ID0gdHJ1ZVxuICB2YXIgcmVtYWluaW5nQ29tcGFyYXRvcnMgPSBjb21wYXJhdG9ycy5zbGljZSgpXG4gIHZhciB0ZXN0Q29tcGFyYXRvciA9IHJlbWFpbmluZ0NvbXBhcmF0b3JzLnBvcCgpXG5cbiAgd2hpbGUgKHJlc3VsdCAmJiByZW1haW5pbmdDb21wYXJhdG9ycy5sZW5ndGgpIHtcbiAgICByZXN1bHQgPSByZW1haW5pbmdDb21wYXJhdG9ycy5ldmVyeShmdW5jdGlvbiAob3RoZXJDb21wYXJhdG9yKSB7XG4gICAgICByZXR1cm4gdGVzdENvbXBhcmF0b3IuaW50ZXJzZWN0cyhvdGhlckNvbXBhcmF0b3IsIG9wdGlvbnMpXG4gICAgfSlcblxuICAgIHRlc3RDb21wYXJhdG9yID0gcmVtYWluaW5nQ29tcGFyYXRvcnMucG9wKClcbiAgfVxuXG4gIHJldHVybiByZXN1bHRcbn1cblxuLy8gTW9zdGx5IGp1c3QgZm9yIHRlc3RpbmcgYW5kIGxlZ2FjeSBBUEkgcmVhc29uc1xuZXhwb3J0cy50b0NvbXBhcmF0b3JzID0gdG9Db21wYXJhdG9yc1xuZnVuY3Rpb24gdG9Db21wYXJhdG9ycyAocmFuZ2UsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIG5ldyBSYW5nZShyYW5nZSwgb3B0aW9ucykuc2V0Lm1hcChmdW5jdGlvbiAoY29tcCkge1xuICAgIHJldHVybiBjb21wLm1hcChmdW5jdGlvbiAoYykge1xuICAgICAgcmV0dXJuIGMudmFsdWVcbiAgICB9KS5qb2luKCcgJykudHJpbSgpLnNwbGl0KCcgJylcbiAgfSlcbn1cblxuLy8gY29tcHJpc2VkIG9mIHhyYW5nZXMsIHRpbGRlcywgc3RhcnMsIGFuZCBndGx0J3MgYXQgdGhpcyBwb2ludC5cbi8vIGFscmVhZHkgcmVwbGFjZWQgdGhlIGh5cGhlbiByYW5nZXNcbi8vIHR1cm4gaW50byBhIHNldCBvZiBKVVNUIGNvbXBhcmF0b3JzLlxuZnVuY3Rpb24gcGFyc2VDb21wYXJhdG9yIChjb21wLCBvcHRpb25zKSB7XG4gIGRlYnVnKCdjb21wJywgY29tcCwgb3B0aW9ucylcbiAgY29tcCA9IHJlcGxhY2VDYXJldHMoY29tcCwgb3B0aW9ucylcbiAgZGVidWcoJ2NhcmV0JywgY29tcClcbiAgY29tcCA9IHJlcGxhY2VUaWxkZXMoY29tcCwgb3B0aW9ucylcbiAgZGVidWcoJ3RpbGRlcycsIGNvbXApXG4gIGNvbXAgPSByZXBsYWNlWFJhbmdlcyhjb21wLCBvcHRpb25zKVxuICBkZWJ1ZygneHJhbmdlJywgY29tcClcbiAgY29tcCA9IHJlcGxhY2VTdGFycyhjb21wLCBvcHRpb25zKVxuICBkZWJ1Zygnc3RhcnMnLCBjb21wKVxuICByZXR1cm4gY29tcFxufVxuXG5mdW5jdGlvbiBpc1ggKGlkKSB7XG4gIHJldHVybiAhaWQgfHwgaWQudG9Mb3dlckNhc2UoKSA9PT0gJ3gnIHx8IGlkID09PSAnKidcbn1cblxuLy8gfiwgfj4gLS0+ICogKGFueSwga2luZGEgc2lsbHkpXG4vLyB+MiwgfjIueCwgfjIueC54LCB+PjIsIH4+Mi54IH4+Mi54LnggLS0+ID49Mi4wLjAgPDMuMC4wXG4vLyB+Mi4wLCB+Mi4wLngsIH4+Mi4wLCB+PjIuMC54IC0tPiA+PTIuMC4wIDwyLjEuMFxuLy8gfjEuMiwgfjEuMi54LCB+PjEuMiwgfj4xLjIueCAtLT4gPj0xLjIuMCA8MS4zLjBcbi8vIH4xLjIuMywgfj4xLjIuMyAtLT4gPj0xLjIuMyA8MS4zLjBcbi8vIH4xLjIuMCwgfj4xLjIuMCAtLT4gPj0xLjIuMCA8MS4zLjBcbmZ1bmN0aW9uIHJlcGxhY2VUaWxkZXMgKGNvbXAsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIGNvbXAudHJpbSgpLnNwbGl0KC9cXHMrLykubWFwKGZ1bmN0aW9uIChjb21wKSB7XG4gICAgcmV0dXJuIHJlcGxhY2VUaWxkZShjb21wLCBvcHRpb25zKVxuICB9KS5qb2luKCcgJylcbn1cblxuZnVuY3Rpb24gcmVwbGFjZVRpbGRlIChjb21wLCBvcHRpb25zKSB7XG4gIHZhciByID0gb3B0aW9ucy5sb29zZSA/IHJlW3QuVElMREVMT09TRV0gOiByZVt0LlRJTERFXVxuICByZXR1cm4gY29tcC5yZXBsYWNlKHIsIGZ1bmN0aW9uIChfLCBNLCBtLCBwLCBwcikge1xuICAgIGRlYnVnKCd0aWxkZScsIGNvbXAsIF8sIE0sIG0sIHAsIHByKVxuICAgIHZhciByZXRcblxuICAgIGlmIChpc1goTSkpIHtcbiAgICAgIHJldCA9ICcnXG4gICAgfSBlbHNlIGlmIChpc1gobSkpIHtcbiAgICAgIHJldCA9ICc+PScgKyBNICsgJy4wLjAgPCcgKyAoK00gKyAxKSArICcuMC4wJ1xuICAgIH0gZWxzZSBpZiAoaXNYKHApKSB7XG4gICAgICAvLyB+MS4yID09ID49MS4yLjAgPDEuMy4wXG4gICAgICByZXQgPSAnPj0nICsgTSArICcuJyArIG0gKyAnLjAgPCcgKyBNICsgJy4nICsgKCttICsgMSkgKyAnLjAnXG4gICAgfSBlbHNlIGlmIChwcikge1xuICAgICAgZGVidWcoJ3JlcGxhY2VUaWxkZSBwcicsIHByKVxuICAgICAgcmV0ID0gJz49JyArIE0gKyAnLicgKyBtICsgJy4nICsgcCArICctJyArIHByICtcbiAgICAgICAgICAgICcgPCcgKyBNICsgJy4nICsgKCttICsgMSkgKyAnLjAnXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIH4xLjIuMyA9PSA+PTEuMi4zIDwxLjMuMFxuICAgICAgcmV0ID0gJz49JyArIE0gKyAnLicgKyBtICsgJy4nICsgcCArXG4gICAgICAgICAgICAnIDwnICsgTSArICcuJyArICgrbSArIDEpICsgJy4wJ1xuICAgIH1cblxuICAgIGRlYnVnKCd0aWxkZSByZXR1cm4nLCByZXQpXG4gICAgcmV0dXJuIHJldFxuICB9KVxufVxuXG4vLyBeIC0tPiAqIChhbnksIGtpbmRhIHNpbGx5KVxuLy8gXjIsIF4yLngsIF4yLngueCAtLT4gPj0yLjAuMCA8My4wLjBcbi8vIF4yLjAsIF4yLjAueCAtLT4gPj0yLjAuMCA8My4wLjBcbi8vIF4xLjIsIF4xLjIueCAtLT4gPj0xLjIuMCA8Mi4wLjBcbi8vIF4xLjIuMyAtLT4gPj0xLjIuMyA8Mi4wLjBcbi8vIF4xLjIuMCAtLT4gPj0xLjIuMCA8Mi4wLjBcbmZ1bmN0aW9uIHJlcGxhY2VDYXJldHMgKGNvbXAsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIGNvbXAudHJpbSgpLnNwbGl0KC9cXHMrLykubWFwKGZ1bmN0aW9uIChjb21wKSB7XG4gICAgcmV0dXJuIHJlcGxhY2VDYXJldChjb21wLCBvcHRpb25zKVxuICB9KS5qb2luKCcgJylcbn1cblxuZnVuY3Rpb24gcmVwbGFjZUNhcmV0IChjb21wLCBvcHRpb25zKSB7XG4gIGRlYnVnKCdjYXJldCcsIGNvbXAsIG9wdGlvbnMpXG4gIHZhciByID0gb3B0aW9ucy5sb29zZSA/IHJlW3QuQ0FSRVRMT09TRV0gOiByZVt0LkNBUkVUXVxuICByZXR1cm4gY29tcC5yZXBsYWNlKHIsIGZ1bmN0aW9uIChfLCBNLCBtLCBwLCBwcikge1xuICAgIGRlYnVnKCdjYXJldCcsIGNvbXAsIF8sIE0sIG0sIHAsIHByKVxuICAgIHZhciByZXRcblxuICAgIGlmIChpc1goTSkpIHtcbiAgICAgIHJldCA9ICcnXG4gICAgfSBlbHNlIGlmIChpc1gobSkpIHtcbiAgICAgIHJldCA9ICc+PScgKyBNICsgJy4wLjAgPCcgKyAoK00gKyAxKSArICcuMC4wJ1xuICAgIH0gZWxzZSBpZiAoaXNYKHApKSB7XG4gICAgICBpZiAoTSA9PT0gJzAnKSB7XG4gICAgICAgIHJldCA9ICc+PScgKyBNICsgJy4nICsgbSArICcuMCA8JyArIE0gKyAnLicgKyAoK20gKyAxKSArICcuMCdcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldCA9ICc+PScgKyBNICsgJy4nICsgbSArICcuMCA8JyArICgrTSArIDEpICsgJy4wLjAnXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwcikge1xuICAgICAgZGVidWcoJ3JlcGxhY2VDYXJldCBwcicsIHByKVxuICAgICAgaWYgKE0gPT09ICcwJykge1xuICAgICAgICBpZiAobSA9PT0gJzAnKSB7XG4gICAgICAgICAgcmV0ID0gJz49JyArIE0gKyAnLicgKyBtICsgJy4nICsgcCArICctJyArIHByICtcbiAgICAgICAgICAgICAgICAnIDwnICsgTSArICcuJyArIG0gKyAnLicgKyAoK3AgKyAxKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldCA9ICc+PScgKyBNICsgJy4nICsgbSArICcuJyArIHAgKyAnLScgKyBwciArXG4gICAgICAgICAgICAgICAgJyA8JyArIE0gKyAnLicgKyAoK20gKyAxKSArICcuMCdcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0ID0gJz49JyArIE0gKyAnLicgKyBtICsgJy4nICsgcCArICctJyArIHByICtcbiAgICAgICAgICAgICAgJyA8JyArICgrTSArIDEpICsgJy4wLjAnXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlYnVnKCdubyBwcicpXG4gICAgICBpZiAoTSA9PT0gJzAnKSB7XG4gICAgICAgIGlmIChtID09PSAnMCcpIHtcbiAgICAgICAgICByZXQgPSAnPj0nICsgTSArICcuJyArIG0gKyAnLicgKyBwICtcbiAgICAgICAgICAgICAgICAnIDwnICsgTSArICcuJyArIG0gKyAnLicgKyAoK3AgKyAxKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldCA9ICc+PScgKyBNICsgJy4nICsgbSArICcuJyArIHAgK1xuICAgICAgICAgICAgICAgICcgPCcgKyBNICsgJy4nICsgKCttICsgMSkgKyAnLjAnXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldCA9ICc+PScgKyBNICsgJy4nICsgbSArICcuJyArIHAgK1xuICAgICAgICAgICAgICAnIDwnICsgKCtNICsgMSkgKyAnLjAuMCdcbiAgICAgIH1cbiAgICB9XG5cbiAgICBkZWJ1ZygnY2FyZXQgcmV0dXJuJywgcmV0KVxuICAgIHJldHVybiByZXRcbiAgfSlcbn1cblxuZnVuY3Rpb24gcmVwbGFjZVhSYW5nZXMgKGNvbXAsIG9wdGlvbnMpIHtcbiAgZGVidWcoJ3JlcGxhY2VYUmFuZ2VzJywgY29tcCwgb3B0aW9ucylcbiAgcmV0dXJuIGNvbXAuc3BsaXQoL1xccysvKS5tYXAoZnVuY3Rpb24gKGNvbXApIHtcbiAgICByZXR1cm4gcmVwbGFjZVhSYW5nZShjb21wLCBvcHRpb25zKVxuICB9KS5qb2luKCcgJylcbn1cblxuZnVuY3Rpb24gcmVwbGFjZVhSYW5nZSAoY29tcCwgb3B0aW9ucykge1xuICBjb21wID0gY29tcC50cmltKClcbiAgdmFyIHIgPSBvcHRpb25zLmxvb3NlID8gcmVbdC5YUkFOR0VMT09TRV0gOiByZVt0LlhSQU5HRV1cbiAgcmV0dXJuIGNvbXAucmVwbGFjZShyLCBmdW5jdGlvbiAocmV0LCBndGx0LCBNLCBtLCBwLCBwcikge1xuICAgIGRlYnVnKCd4UmFuZ2UnLCBjb21wLCByZXQsIGd0bHQsIE0sIG0sIHAsIHByKVxuICAgIHZhciB4TSA9IGlzWChNKVxuICAgIHZhciB4bSA9IHhNIHx8IGlzWChtKVxuICAgIHZhciB4cCA9IHhtIHx8IGlzWChwKVxuICAgIHZhciBhbnlYID0geHBcblxuICAgIGlmIChndGx0ID09PSAnPScgJiYgYW55WCkge1xuICAgICAgZ3RsdCA9ICcnXG4gICAgfVxuXG4gICAgLy8gaWYgd2UncmUgaW5jbHVkaW5nIHByZXJlbGVhc2VzIGluIHRoZSBtYXRjaCwgdGhlbiB3ZSBuZWVkXG4gICAgLy8gdG8gZml4IHRoaXMgdG8gLTAsIHRoZSBsb3dlc3QgcG9zc2libGUgcHJlcmVsZWFzZSB2YWx1ZVxuICAgIHByID0gb3B0aW9ucy5pbmNsdWRlUHJlcmVsZWFzZSA/ICctMCcgOiAnJ1xuXG4gICAgaWYgKHhNKSB7XG4gICAgICBpZiAoZ3RsdCA9PT0gJz4nIHx8IGd0bHQgPT09ICc8Jykge1xuICAgICAgICAvLyBub3RoaW5nIGlzIGFsbG93ZWRcbiAgICAgICAgcmV0ID0gJzwwLjAuMC0wJ1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gbm90aGluZyBpcyBmb3JiaWRkZW5cbiAgICAgICAgcmV0ID0gJyonXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChndGx0ICYmIGFueVgpIHtcbiAgICAgIC8vIHdlIGtub3cgcGF0Y2ggaXMgYW4geCwgYmVjYXVzZSB3ZSBoYXZlIGFueSB4IGF0IGFsbC5cbiAgICAgIC8vIHJlcGxhY2UgWCB3aXRoIDBcbiAgICAgIGlmICh4bSkge1xuICAgICAgICBtID0gMFxuICAgICAgfVxuICAgICAgcCA9IDBcblxuICAgICAgaWYgKGd0bHQgPT09ICc+Jykge1xuICAgICAgICAvLyA+MSA9PiA+PTIuMC4wXG4gICAgICAgIC8vID4xLjIgPT4gPj0xLjMuMFxuICAgICAgICAvLyA+MS4yLjMgPT4gPj0gMS4yLjRcbiAgICAgICAgZ3RsdCA9ICc+PSdcbiAgICAgICAgaWYgKHhtKSB7XG4gICAgICAgICAgTSA9ICtNICsgMVxuICAgICAgICAgIG0gPSAwXG4gICAgICAgICAgcCA9IDBcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtID0gK20gKyAxXG4gICAgICAgICAgcCA9IDBcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChndGx0ID09PSAnPD0nKSB7XG4gICAgICAgIC8vIDw9MC43LnggaXMgYWN0dWFsbHkgPDAuOC4wLCBzaW5jZSBhbnkgMC43Lnggc2hvdWxkXG4gICAgICAgIC8vIHBhc3MuICBTaW1pbGFybHksIDw9Ny54IGlzIGFjdHVhbGx5IDw4LjAuMCwgZXRjLlxuICAgICAgICBndGx0ID0gJzwnXG4gICAgICAgIGlmICh4bSkge1xuICAgICAgICAgIE0gPSArTSArIDFcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtID0gK20gKyAxXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0ID0gZ3RsdCArIE0gKyAnLicgKyBtICsgJy4nICsgcCArIHByXG4gICAgfSBlbHNlIGlmICh4bSkge1xuICAgICAgcmV0ID0gJz49JyArIE0gKyAnLjAuMCcgKyBwciArICcgPCcgKyAoK00gKyAxKSArICcuMC4wJyArIHByXG4gICAgfSBlbHNlIGlmICh4cCkge1xuICAgICAgcmV0ID0gJz49JyArIE0gKyAnLicgKyBtICsgJy4wJyArIHByICtcbiAgICAgICAgJyA8JyArIE0gKyAnLicgKyAoK20gKyAxKSArICcuMCcgKyBwclxuICAgIH1cblxuICAgIGRlYnVnKCd4UmFuZ2UgcmV0dXJuJywgcmV0KVxuXG4gICAgcmV0dXJuIHJldFxuICB9KVxufVxuXG4vLyBCZWNhdXNlICogaXMgQU5ELWVkIHdpdGggZXZlcnl0aGluZyBlbHNlIGluIHRoZSBjb21wYXJhdG9yLFxuLy8gYW5kICcnIG1lYW5zIFwiYW55IHZlcnNpb25cIiwganVzdCByZW1vdmUgdGhlICpzIGVudGlyZWx5LlxuZnVuY3Rpb24gcmVwbGFjZVN0YXJzIChjb21wLCBvcHRpb25zKSB7XG4gIGRlYnVnKCdyZXBsYWNlU3RhcnMnLCBjb21wLCBvcHRpb25zKVxuICAvLyBMb29zZW5lc3MgaXMgaWdub3JlZCBoZXJlLiAgc3RhciBpcyBhbHdheXMgYXMgbG9vc2UgYXMgaXQgZ2V0cyFcbiAgcmV0dXJuIGNvbXAudHJpbSgpLnJlcGxhY2UocmVbdC5TVEFSXSwgJycpXG59XG5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgcGFzc2VkIHRvIHN0cmluZy5yZXBsYWNlKHJlW3QuSFlQSEVOUkFOR0VdKVxuLy8gTSwgbSwgcGF0Y2gsIHByZXJlbGVhc2UsIGJ1aWxkXG4vLyAxLjIgLSAzLjQuNSA9PiA+PTEuMi4wIDw9My40LjVcbi8vIDEuMi4zIC0gMy40ID0+ID49MS4yLjAgPDMuNS4wIEFueSAzLjQueCB3aWxsIGRvXG4vLyAxLjIgLSAzLjQgPT4gPj0xLjIuMCA8My41LjBcbmZ1bmN0aW9uIGh5cGhlblJlcGxhY2UgKCQwLFxuICBmcm9tLCBmTSwgZm0sIGZwLCBmcHIsIGZiLFxuICB0bywgdE0sIHRtLCB0cCwgdHByLCB0Yikge1xuICBpZiAoaXNYKGZNKSkge1xuICAgIGZyb20gPSAnJ1xuICB9IGVsc2UgaWYgKGlzWChmbSkpIHtcbiAgICBmcm9tID0gJz49JyArIGZNICsgJy4wLjAnXG4gIH0gZWxzZSBpZiAoaXNYKGZwKSkge1xuICAgIGZyb20gPSAnPj0nICsgZk0gKyAnLicgKyBmbSArICcuMCdcbiAgfSBlbHNlIHtcbiAgICBmcm9tID0gJz49JyArIGZyb21cbiAgfVxuXG4gIGlmIChpc1godE0pKSB7XG4gICAgdG8gPSAnJ1xuICB9IGVsc2UgaWYgKGlzWCh0bSkpIHtcbiAgICB0byA9ICc8JyArICgrdE0gKyAxKSArICcuMC4wJ1xuICB9IGVsc2UgaWYgKGlzWCh0cCkpIHtcbiAgICB0byA9ICc8JyArIHRNICsgJy4nICsgKCt0bSArIDEpICsgJy4wJ1xuICB9IGVsc2UgaWYgKHRwcikge1xuICAgIHRvID0gJzw9JyArIHRNICsgJy4nICsgdG0gKyAnLicgKyB0cCArICctJyArIHRwclxuICB9IGVsc2Uge1xuICAgIHRvID0gJzw9JyArIHRvXG4gIH1cblxuICByZXR1cm4gKGZyb20gKyAnICcgKyB0bykudHJpbSgpXG59XG5cbi8vIGlmIEFOWSBvZiB0aGUgc2V0cyBtYXRjaCBBTEwgb2YgaXRzIGNvbXBhcmF0b3JzLCB0aGVuIHBhc3NcblJhbmdlLnByb3RvdHlwZS50ZXN0ID0gZnVuY3Rpb24gKHZlcnNpb24pIHtcbiAgaWYgKCF2ZXJzaW9uKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBpZiAodHlwZW9mIHZlcnNpb24gPT09ICdzdHJpbmcnKSB7XG4gICAgdHJ5IHtcbiAgICAgIHZlcnNpb24gPSBuZXcgU2VtVmVyKHZlcnNpb24sIHRoaXMub3B0aW9ucylcbiAgICB9IGNhdGNoIChlcikge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnNldC5sZW5ndGg7IGkrKykge1xuICAgIGlmICh0ZXN0U2V0KHRoaXMuc2V0W2ldLCB2ZXJzaW9uLCB0aGlzLm9wdGlvbnMpKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuZnVuY3Rpb24gdGVzdFNldCAoc2V0LCB2ZXJzaW9uLCBvcHRpb25zKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc2V0Lmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKCFzZXRbaV0udGVzdCh2ZXJzaW9uKSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG5cbiAgaWYgKHZlcnNpb24ucHJlcmVsZWFzZS5sZW5ndGggJiYgIW9wdGlvbnMuaW5jbHVkZVByZXJlbGVhc2UpIHtcbiAgICAvLyBGaW5kIHRoZSBzZXQgb2YgdmVyc2lvbnMgdGhhdCBhcmUgYWxsb3dlZCB0byBoYXZlIHByZXJlbGVhc2VzXG4gICAgLy8gRm9yIGV4YW1wbGUsIF4xLjIuMy1wci4xIGRlc3VnYXJzIHRvID49MS4yLjMtcHIuMSA8Mi4wLjBcbiAgICAvLyBUaGF0IHNob3VsZCBhbGxvdyBgMS4yLjMtcHIuMmAgdG8gcGFzcy5cbiAgICAvLyBIb3dldmVyLCBgMS4yLjQtYWxwaGEubm90cmVhZHlgIHNob3VsZCBOT1QgYmUgYWxsb3dlZCxcbiAgICAvLyBldmVuIHRob3VnaCBpdCdzIHdpdGhpbiB0aGUgcmFuZ2Ugc2V0IGJ5IHRoZSBjb21wYXJhdG9ycy5cbiAgICBmb3IgKGkgPSAwOyBpIDwgc2V0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBkZWJ1ZyhzZXRbaV0uc2VtdmVyKVxuICAgICAgaWYgKHNldFtpXS5zZW12ZXIgPT09IEFOWSkge1xuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICBpZiAoc2V0W2ldLnNlbXZlci5wcmVyZWxlYXNlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdmFyIGFsbG93ZWQgPSBzZXRbaV0uc2VtdmVyXG4gICAgICAgIGlmIChhbGxvd2VkLm1ham9yID09PSB2ZXJzaW9uLm1ham9yICYmXG4gICAgICAgICAgICBhbGxvd2VkLm1pbm9yID09PSB2ZXJzaW9uLm1pbm9yICYmXG4gICAgICAgICAgICBhbGxvd2VkLnBhdGNoID09PSB2ZXJzaW9uLnBhdGNoKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFZlcnNpb24gaGFzIGEgLXByZSwgYnV0IGl0J3Mgbm90IG9uZSBvZiB0aGUgb25lcyB3ZSBsaWtlLlxuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgcmV0dXJuIHRydWVcbn1cblxuZXhwb3J0cy5zYXRpc2ZpZXMgPSBzYXRpc2ZpZXNcbmZ1bmN0aW9uIHNhdGlzZmllcyAodmVyc2lvbiwgcmFuZ2UsIG9wdGlvbnMpIHtcbiAgdHJ5IHtcbiAgICByYW5nZSA9IG5ldyBSYW5nZShyYW5nZSwgb3B0aW9ucylcbiAgfSBjYXRjaCAoZXIpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICByZXR1cm4gcmFuZ2UudGVzdCh2ZXJzaW9uKVxufVxuXG5leHBvcnRzLm1heFNhdGlzZnlpbmcgPSBtYXhTYXRpc2Z5aW5nXG5mdW5jdGlvbiBtYXhTYXRpc2Z5aW5nICh2ZXJzaW9ucywgcmFuZ2UsIG9wdGlvbnMpIHtcbiAgdmFyIG1heCA9IG51bGxcbiAgdmFyIG1heFNWID0gbnVsbFxuICB0cnkge1xuICAgIHZhciByYW5nZU9iaiA9IG5ldyBSYW5nZShyYW5nZSwgb3B0aW9ucylcbiAgfSBjYXRjaCAoZXIpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG4gIHZlcnNpb25zLmZvckVhY2goZnVuY3Rpb24gKHYpIHtcbiAgICBpZiAocmFuZ2VPYmoudGVzdCh2KSkge1xuICAgICAgLy8gc2F0aXNmaWVzKHYsIHJhbmdlLCBvcHRpb25zKVxuICAgICAgaWYgKCFtYXggfHwgbWF4U1YuY29tcGFyZSh2KSA9PT0gLTEpIHtcbiAgICAgICAgLy8gY29tcGFyZShtYXgsIHYsIHRydWUpXG4gICAgICAgIG1heCA9IHZcbiAgICAgICAgbWF4U1YgPSBuZXcgU2VtVmVyKG1heCwgb3B0aW9ucylcbiAgICAgIH1cbiAgICB9XG4gIH0pXG4gIHJldHVybiBtYXhcbn1cblxuZXhwb3J0cy5taW5TYXRpc2Z5aW5nID0gbWluU2F0aXNmeWluZ1xuZnVuY3Rpb24gbWluU2F0aXNmeWluZyAodmVyc2lvbnMsIHJhbmdlLCBvcHRpb25zKSB7XG4gIHZhciBtaW4gPSBudWxsXG4gIHZhciBtaW5TViA9IG51bGxcbiAgdHJ5IHtcbiAgICB2YXIgcmFuZ2VPYmogPSBuZXcgUmFuZ2UocmFuZ2UsIG9wdGlvbnMpXG4gIH0gY2F0Y2ggKGVyKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuICB2ZXJzaW9ucy5mb3JFYWNoKGZ1bmN0aW9uICh2KSB7XG4gICAgaWYgKHJhbmdlT2JqLnRlc3QodikpIHtcbiAgICAgIC8vIHNhdGlzZmllcyh2LCByYW5nZSwgb3B0aW9ucylcbiAgICAgIGlmICghbWluIHx8IG1pblNWLmNvbXBhcmUodikgPT09IDEpIHtcbiAgICAgICAgLy8gY29tcGFyZShtaW4sIHYsIHRydWUpXG4gICAgICAgIG1pbiA9IHZcbiAgICAgICAgbWluU1YgPSBuZXcgU2VtVmVyKG1pbiwgb3B0aW9ucylcbiAgICAgIH1cbiAgICB9XG4gIH0pXG4gIHJldHVybiBtaW5cbn1cblxuZXhwb3J0cy5taW5WZXJzaW9uID0gbWluVmVyc2lvblxuZnVuY3Rpb24gbWluVmVyc2lvbiAocmFuZ2UsIGxvb3NlKSB7XG4gIHJhbmdlID0gbmV3IFJhbmdlKHJhbmdlLCBsb29zZSlcblxuICB2YXIgbWludmVyID0gbmV3IFNlbVZlcignMC4wLjAnKVxuICBpZiAocmFuZ2UudGVzdChtaW52ZXIpKSB7XG4gICAgcmV0dXJuIG1pbnZlclxuICB9XG5cbiAgbWludmVyID0gbmV3IFNlbVZlcignMC4wLjAtMCcpXG4gIGlmIChyYW5nZS50ZXN0KG1pbnZlcikpIHtcbiAgICByZXR1cm4gbWludmVyXG4gIH1cblxuICBtaW52ZXIgPSBudWxsXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcmFuZ2Uuc2V0Lmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGNvbXBhcmF0b3JzID0gcmFuZ2Uuc2V0W2ldXG5cbiAgICBjb21wYXJhdG9ycy5mb3JFYWNoKGZ1bmN0aW9uIChjb21wYXJhdG9yKSB7XG4gICAgICAvLyBDbG9uZSB0byBhdm9pZCBtYW5pcHVsYXRpbmcgdGhlIGNvbXBhcmF0b3IncyBzZW12ZXIgb2JqZWN0LlxuICAgICAgdmFyIGNvbXB2ZXIgPSBuZXcgU2VtVmVyKGNvbXBhcmF0b3Iuc2VtdmVyLnZlcnNpb24pXG4gICAgICBzd2l0Y2ggKGNvbXBhcmF0b3Iub3BlcmF0b3IpIHtcbiAgICAgICAgY2FzZSAnPic6XG4gICAgICAgICAgaWYgKGNvbXB2ZXIucHJlcmVsZWFzZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGNvbXB2ZXIucGF0Y2grK1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb21wdmVyLnByZXJlbGVhc2UucHVzaCgwKVxuICAgICAgICAgIH1cbiAgICAgICAgICBjb21wdmVyLnJhdyA9IGNvbXB2ZXIuZm9ybWF0KClcbiAgICAgICAgICAvKiBmYWxsdGhyb3VnaCAqL1xuICAgICAgICBjYXNlICcnOlxuICAgICAgICBjYXNlICc+PSc6XG4gICAgICAgICAgaWYgKCFtaW52ZXIgfHwgZ3QobWludmVyLCBjb21wdmVyKSkge1xuICAgICAgICAgICAgbWludmVyID0gY29tcHZlclxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlICc8JzpcbiAgICAgICAgY2FzZSAnPD0nOlxuICAgICAgICAgIC8qIElnbm9yZSBtYXhpbXVtIHZlcnNpb25zICovXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQgb3BlcmF0aW9uOiAnICsgY29tcGFyYXRvci5vcGVyYXRvcilcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgaWYgKG1pbnZlciAmJiByYW5nZS50ZXN0KG1pbnZlcikpIHtcbiAgICByZXR1cm4gbWludmVyXG4gIH1cblxuICByZXR1cm4gbnVsbFxufVxuXG5leHBvcnRzLnZhbGlkUmFuZ2UgPSB2YWxpZFJhbmdlXG5mdW5jdGlvbiB2YWxpZFJhbmdlIChyYW5nZSwgb3B0aW9ucykge1xuICB0cnkge1xuICAgIC8vIFJldHVybiAnKicgaW5zdGVhZCBvZiAnJyBzbyB0aGF0IHRydXRoaW5lc3Mgd29ya3MuXG4gICAgLy8gVGhpcyB3aWxsIHRocm93IGlmIGl0J3MgaW52YWxpZCBhbnl3YXlcbiAgICByZXR1cm4gbmV3IFJhbmdlKHJhbmdlLCBvcHRpb25zKS5yYW5nZSB8fCAnKidcbiAgfSBjYXRjaCAoZXIpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG59XG5cbi8vIERldGVybWluZSBpZiB2ZXJzaW9uIGlzIGxlc3MgdGhhbiBhbGwgdGhlIHZlcnNpb25zIHBvc3NpYmxlIGluIHRoZSByYW5nZVxuZXhwb3J0cy5sdHIgPSBsdHJcbmZ1bmN0aW9uIGx0ciAodmVyc2lvbiwgcmFuZ2UsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIG91dHNpZGUodmVyc2lvbiwgcmFuZ2UsICc8Jywgb3B0aW9ucylcbn1cblxuLy8gRGV0ZXJtaW5lIGlmIHZlcnNpb24gaXMgZ3JlYXRlciB0aGFuIGFsbCB0aGUgdmVyc2lvbnMgcG9zc2libGUgaW4gdGhlIHJhbmdlLlxuZXhwb3J0cy5ndHIgPSBndHJcbmZ1bmN0aW9uIGd0ciAodmVyc2lvbiwgcmFuZ2UsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIG91dHNpZGUodmVyc2lvbiwgcmFuZ2UsICc+Jywgb3B0aW9ucylcbn1cblxuZXhwb3J0cy5vdXRzaWRlID0gb3V0c2lkZVxuZnVuY3Rpb24gb3V0c2lkZSAodmVyc2lvbiwgcmFuZ2UsIGhpbG8sIG9wdGlvbnMpIHtcbiAgdmVyc2lvbiA9IG5ldyBTZW1WZXIodmVyc2lvbiwgb3B0aW9ucylcbiAgcmFuZ2UgPSBuZXcgUmFuZ2UocmFuZ2UsIG9wdGlvbnMpXG5cbiAgdmFyIGd0Zm4sIGx0ZWZuLCBsdGZuLCBjb21wLCBlY29tcFxuICBzd2l0Y2ggKGhpbG8pIHtcbiAgICBjYXNlICc+JzpcbiAgICAgIGd0Zm4gPSBndFxuICAgICAgbHRlZm4gPSBsdGVcbiAgICAgIGx0Zm4gPSBsdFxuICAgICAgY29tcCA9ICc+J1xuICAgICAgZWNvbXAgPSAnPj0nXG4gICAgICBicmVha1xuICAgIGNhc2UgJzwnOlxuICAgICAgZ3RmbiA9IGx0XG4gICAgICBsdGVmbiA9IGd0ZVxuICAgICAgbHRmbiA9IGd0XG4gICAgICBjb21wID0gJzwnXG4gICAgICBlY29tcCA9ICc8PSdcbiAgICAgIGJyZWFrXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ011c3QgcHJvdmlkZSBhIGhpbG8gdmFsIG9mIFwiPFwiIG9yIFwiPlwiJylcbiAgfVxuXG4gIC8vIElmIGl0IHNhdGlzaWZlcyB0aGUgcmFuZ2UgaXQgaXMgbm90IG91dHNpZGVcbiAgaWYgKHNhdGlzZmllcyh2ZXJzaW9uLCByYW5nZSwgb3B0aW9ucykpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIC8vIEZyb20gbm93IG9uLCB2YXJpYWJsZSB0ZXJtcyBhcmUgYXMgaWYgd2UncmUgaW4gXCJndHJcIiBtb2RlLlxuICAvLyBidXQgbm90ZSB0aGF0IGV2ZXJ5dGhpbmcgaXMgZmxpcHBlZCBmb3IgdGhlIFwibHRyXCIgZnVuY3Rpb24uXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCByYW5nZS5zZXQubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgY29tcGFyYXRvcnMgPSByYW5nZS5zZXRbaV1cblxuICAgIHZhciBoaWdoID0gbnVsbFxuICAgIHZhciBsb3cgPSBudWxsXG5cbiAgICBjb21wYXJhdG9ycy5mb3JFYWNoKGZ1bmN0aW9uIChjb21wYXJhdG9yKSB7XG4gICAgICBpZiAoY29tcGFyYXRvci5zZW12ZXIgPT09IEFOWSkge1xuICAgICAgICBjb21wYXJhdG9yID0gbmV3IENvbXBhcmF0b3IoJz49MC4wLjAnKVxuICAgICAgfVxuICAgICAgaGlnaCA9IGhpZ2ggfHwgY29tcGFyYXRvclxuICAgICAgbG93ID0gbG93IHx8IGNvbXBhcmF0b3JcbiAgICAgIGlmIChndGZuKGNvbXBhcmF0b3Iuc2VtdmVyLCBoaWdoLnNlbXZlciwgb3B0aW9ucykpIHtcbiAgICAgICAgaGlnaCA9IGNvbXBhcmF0b3JcbiAgICAgIH0gZWxzZSBpZiAobHRmbihjb21wYXJhdG9yLnNlbXZlciwgbG93LnNlbXZlciwgb3B0aW9ucykpIHtcbiAgICAgICAgbG93ID0gY29tcGFyYXRvclxuICAgICAgfVxuICAgIH0pXG5cbiAgICAvLyBJZiB0aGUgZWRnZSB2ZXJzaW9uIGNvbXBhcmF0b3IgaGFzIGEgb3BlcmF0b3IgdGhlbiBvdXIgdmVyc2lvblxuICAgIC8vIGlzbid0IG91dHNpZGUgaXRcbiAgICBpZiAoaGlnaC5vcGVyYXRvciA9PT0gY29tcCB8fCBoaWdoLm9wZXJhdG9yID09PSBlY29tcCkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIGxvd2VzdCB2ZXJzaW9uIGNvbXBhcmF0b3IgaGFzIGFuIG9wZXJhdG9yIGFuZCBvdXIgdmVyc2lvblxuICAgIC8vIGlzIGxlc3MgdGhhbiBpdCB0aGVuIGl0IGlzbid0IGhpZ2hlciB0aGFuIHRoZSByYW5nZVxuICAgIGlmICgoIWxvdy5vcGVyYXRvciB8fCBsb3cub3BlcmF0b3IgPT09IGNvbXApICYmXG4gICAgICAgIGx0ZWZuKHZlcnNpb24sIGxvdy5zZW12ZXIpKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9IGVsc2UgaWYgKGxvdy5vcGVyYXRvciA9PT0gZWNvbXAgJiYgbHRmbih2ZXJzaW9uLCBsb3cuc2VtdmVyKSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlXG59XG5cbmV4cG9ydHMucHJlcmVsZWFzZSA9IHByZXJlbGVhc2VcbmZ1bmN0aW9uIHByZXJlbGVhc2UgKHZlcnNpb24sIG9wdGlvbnMpIHtcbiAgdmFyIHBhcnNlZCA9IHBhcnNlKHZlcnNpb24sIG9wdGlvbnMpXG4gIHJldHVybiAocGFyc2VkICYmIHBhcnNlZC5wcmVyZWxlYXNlLmxlbmd0aCkgPyBwYXJzZWQucHJlcmVsZWFzZSA6IG51bGxcbn1cblxuZXhwb3J0cy5pbnRlcnNlY3RzID0gaW50ZXJzZWN0c1xuZnVuY3Rpb24gaW50ZXJzZWN0cyAocjEsIHIyLCBvcHRpb25zKSB7XG4gIHIxID0gbmV3IFJhbmdlKHIxLCBvcHRpb25zKVxuICByMiA9IG5ldyBSYW5nZShyMiwgb3B0aW9ucylcbiAgcmV0dXJuIHIxLmludGVyc2VjdHMocjIpXG59XG5cbmV4cG9ydHMuY29lcmNlID0gY29lcmNlXG5mdW5jdGlvbiBjb2VyY2UgKHZlcnNpb24sIG9wdGlvbnMpIHtcbiAgaWYgKHZlcnNpb24gaW5zdGFuY2VvZiBTZW1WZXIpIHtcbiAgICByZXR1cm4gdmVyc2lvblxuICB9XG5cbiAgaWYgKHR5cGVvZiB2ZXJzaW9uID09PSAnbnVtYmVyJykge1xuICAgIHZlcnNpb24gPSBTdHJpbmcodmVyc2lvbilcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmVyc2lvbiAhPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge31cblxuICB2YXIgbWF0Y2ggPSBudWxsXG4gIGlmICghb3B0aW9ucy5ydGwpIHtcbiAgICBtYXRjaCA9IHZlcnNpb24ubWF0Y2gocmVbdC5DT0VSQ0VdKVxuICB9IGVsc2Uge1xuICAgIC8vIEZpbmQgdGhlIHJpZ2h0LW1vc3QgY29lcmNpYmxlIHN0cmluZyB0aGF0IGRvZXMgbm90IHNoYXJlXG4gICAgLy8gYSB0ZXJtaW51cyB3aXRoIGEgbW9yZSBsZWZ0LXdhcmQgY29lcmNpYmxlIHN0cmluZy5cbiAgICAvLyBFZywgJzEuMi4zLjQnIHdhbnRzIHRvIGNvZXJjZSAnMi4zLjQnLCBub3QgJzMuNCcgb3IgJzQnXG4gICAgLy9cbiAgICAvLyBXYWxrIHRocm91Z2ggdGhlIHN0cmluZyBjaGVja2luZyB3aXRoIGEgL2cgcmVnZXhwXG4gICAgLy8gTWFudWFsbHkgc2V0IHRoZSBpbmRleCBzbyBhcyB0byBwaWNrIHVwIG92ZXJsYXBwaW5nIG1hdGNoZXMuXG4gICAgLy8gU3RvcCB3aGVuIHdlIGdldCBhIG1hdGNoIHRoYXQgZW5kcyBhdCB0aGUgc3RyaW5nIGVuZCwgc2luY2Ugbm9cbiAgICAvLyBjb2VyY2libGUgc3RyaW5nIGNhbiBiZSBtb3JlIHJpZ2h0LXdhcmQgd2l0aG91dCB0aGUgc2FtZSB0ZXJtaW51cy5cbiAgICB2YXIgbmV4dFxuICAgIHdoaWxlICgobmV4dCA9IHJlW3QuQ09FUkNFUlRMXS5leGVjKHZlcnNpb24pKSAmJlxuICAgICAgKCFtYXRjaCB8fCBtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aCAhPT0gdmVyc2lvbi5sZW5ndGgpXG4gICAgKSB7XG4gICAgICBpZiAoIW1hdGNoIHx8XG4gICAgICAgICAgbmV4dC5pbmRleCArIG5leHRbMF0ubGVuZ3RoICE9PSBtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aCkge1xuICAgICAgICBtYXRjaCA9IG5leHRcbiAgICAgIH1cbiAgICAgIHJlW3QuQ09FUkNFUlRMXS5sYXN0SW5kZXggPSBuZXh0LmluZGV4ICsgbmV4dFsxXS5sZW5ndGggKyBuZXh0WzJdLmxlbmd0aFxuICAgIH1cbiAgICAvLyBsZWF2ZSBpdCBpbiBhIGNsZWFuIHN0YXRlXG4gICAgcmVbdC5DT0VSQ0VSVExdLmxhc3RJbmRleCA9IC0xXG4gIH1cblxuICBpZiAobWF0Y2ggPT09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgcmV0dXJuIHBhcnNlKG1hdGNoWzJdICtcbiAgICAnLicgKyAobWF0Y2hbM10gfHwgJzAnKSArXG4gICAgJy4nICsgKG1hdGNoWzRdIHx8ICcwJyksIG9wdGlvbnMpXG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/make-dir/node_modules/semver/semver.js\n");

/***/ }),

/***/ "./node_modules/minimatch/minimatch.js":
/*!*********************************************!*\
  !*** ./node_modules/minimatch/minimatch.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = minimatch\nminimatch.Minimatch = Minimatch\n\nvar path = (function () { try { return __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'path'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())) } catch (e) {}}()) || {\n  sep: '/'\n}\nminimatch.sep = path.sep\n\nvar GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {}\nvar expand = __webpack_require__(/*! brace-expansion */ \"./node_modules/brace-expansion/index.js\")\n\nvar plTypes = {\n  '!': { open: '(?:(?!(?:', close: '))[^/]*?)'},\n  '?': { open: '(?:', close: ')?' },\n  '+': { open: '(?:', close: ')+' },\n  '*': { open: '(?:', close: ')*' },\n  '@': { open: '(?:', close: ')' }\n}\n\n// any single thing other than /\n// don't need to escape / when using new RegExp()\nvar qmark = '[^/]'\n\n// * => any number of characters\nvar star = qmark + '*?'\n\n// ** when dots are allowed.  Anything goes, except .. and .\n// not (^ or / followed by one or two dots followed by $ or /),\n// followed by anything, any number of times.\nvar twoStarDot = '(?:(?!(?:\\\\\\/|^)(?:\\\\.{1,2})($|\\\\\\/)).)*?'\n\n// not a ^ or / followed by a dot,\n// followed by anything, any number of times.\nvar twoStarNoDot = '(?:(?!(?:\\\\\\/|^)\\\\.).)*?'\n\n// characters that need to be escaped in RegExp.\nvar reSpecials = charSet('().*{}+?[]^$\\\\!')\n\n// \"abc\" -> { a:true, b:true, c:true }\nfunction charSet (s) {\n  return s.split('').reduce(function (set, c) {\n    set[c] = true\n    return set\n  }, {})\n}\n\n// normalizes slashes.\nvar slashSplit = /\\/+/\n\nminimatch.filter = filter\nfunction filter (pattern, options) {\n  options = options || {}\n  return function (p, i, list) {\n    return minimatch(p, pattern, options)\n  }\n}\n\nfunction ext (a, b) {\n  b = b || {}\n  var t = {}\n  Object.keys(a).forEach(function (k) {\n    t[k] = a[k]\n  })\n  Object.keys(b).forEach(function (k) {\n    t[k] = b[k]\n  })\n  return t\n}\n\nminimatch.defaults = function (def) {\n  if (!def || typeof def !== 'object' || !Object.keys(def).length) {\n    return minimatch\n  }\n\n  var orig = minimatch\n\n  var m = function minimatch (p, pattern, options) {\n    return orig(p, pattern, ext(def, options))\n  }\n\n  m.Minimatch = function Minimatch (pattern, options) {\n    return new orig.Minimatch(pattern, ext(def, options))\n  }\n  m.Minimatch.defaults = function defaults (options) {\n    return orig.defaults(ext(def, options)).Minimatch\n  }\n\n  m.filter = function filter (pattern, options) {\n    return orig.filter(pattern, ext(def, options))\n  }\n\n  m.defaults = function defaults (options) {\n    return orig.defaults(ext(def, options))\n  }\n\n  m.makeRe = function makeRe (pattern, options) {\n    return orig.makeRe(pattern, ext(def, options))\n  }\n\n  m.braceExpand = function braceExpand (pattern, options) {\n    return orig.braceExpand(pattern, ext(def, options))\n  }\n\n  m.match = function (list, pattern, options) {\n    return orig.match(list, pattern, ext(def, options))\n  }\n\n  return m\n}\n\nMinimatch.defaults = function (def) {\n  return minimatch.defaults(def).Minimatch\n}\n\nfunction minimatch (p, pattern, options) {\n  assertValidPattern(pattern)\n\n  if (!options) options = {}\n\n  // shortcut: comments match nothing.\n  if (!options.nocomment && pattern.charAt(0) === '#') {\n    return false\n  }\n\n  return new Minimatch(pattern, options).match(p)\n}\n\nfunction Minimatch (pattern, options) {\n  if (!(this instanceof Minimatch)) {\n    return new Minimatch(pattern, options)\n  }\n\n  assertValidPattern(pattern)\n\n  if (!options) options = {}\n\n  pattern = pattern.trim()\n\n  // windows support: need to use /, not \\\n  if (!options.allowWindowsEscape && path.sep !== '/') {\n    pattern = pattern.split(path.sep).join('/')\n  }\n\n  this.options = options\n  this.set = []\n  this.pattern = pattern\n  this.regexp = null\n  this.negate = false\n  this.comment = false\n  this.empty = false\n  this.partial = !!options.partial\n\n  // make the set of regexps etc.\n  this.make()\n}\n\nMinimatch.prototype.debug = function () {}\n\nMinimatch.prototype.make = make\nfunction make () {\n  var pattern = this.pattern\n  var options = this.options\n\n  // empty patterns and comments match nothing.\n  if (!options.nocomment && pattern.charAt(0) === '#') {\n    this.comment = true\n    return\n  }\n  if (!pattern) {\n    this.empty = true\n    return\n  }\n\n  // step 1: figure out negation, etc.\n  this.parseNegate()\n\n  // step 2: expand braces\n  var set = this.globSet = this.braceExpand()\n\n  if (options.debug) this.debug = function debug() { console.error.apply(console, arguments) }\n\n  this.debug(this.pattern, set)\n\n  // step 3: now we have a set, so turn each one into a series of path-portion\n  // matching patterns.\n  // These will be regexps, except in the case of \"**\", which is\n  // set to the GLOBSTAR object for globstar behavior,\n  // and will not contain any / characters\n  set = this.globParts = set.map(function (s) {\n    return s.split(slashSplit)\n  })\n\n  this.debug(this.pattern, set)\n\n  // glob --> regexps\n  set = set.map(function (s, si, set) {\n    return s.map(this.parse, this)\n  }, this)\n\n  this.debug(this.pattern, set)\n\n  // filter out everything that didn't compile properly.\n  set = set.filter(function (s) {\n    return s.indexOf(false) === -1\n  })\n\n  this.debug(this.pattern, set)\n\n  this.set = set\n}\n\nMinimatch.prototype.parseNegate = parseNegate\nfunction parseNegate () {\n  var pattern = this.pattern\n  var negate = false\n  var options = this.options\n  var negateOffset = 0\n\n  if (options.nonegate) return\n\n  for (var i = 0, l = pattern.length\n    ; i < l && pattern.charAt(i) === '!'\n    ; i++) {\n    negate = !negate\n    negateOffset++\n  }\n\n  if (negateOffset) this.pattern = pattern.substr(negateOffset)\n  this.negate = negate\n}\n\n// Brace expansion:\n// a{b,c}d -> abd acd\n// a{b,}c -> abc ac\n// a{0..3}d -> a0d a1d a2d a3d\n// a{b,c{d,e}f}g -> abg acdfg acefg\n// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg\n//\n// Invalid sets are not expanded.\n// a{2..}b -> a{2..}b\n// a{b}c -> a{b}c\nminimatch.braceExpand = function (pattern, options) {\n  return braceExpand(pattern, options)\n}\n\nMinimatch.prototype.braceExpand = braceExpand\n\nfunction braceExpand (pattern, options) {\n  if (!options) {\n    if (this instanceof Minimatch) {\n      options = this.options\n    } else {\n      options = {}\n    }\n  }\n\n  pattern = typeof pattern === 'undefined'\n    ? this.pattern : pattern\n\n  assertValidPattern(pattern)\n\n  // Thanks to Yeting Li <https://github.com/yetingli> for\n  // improving this regexp to avoid a ReDOS vulnerability.\n  if (options.nobrace || !/\\{(?:(?!\\{).)*\\}/.test(pattern)) {\n    // shortcut. no need to expand.\n    return [pattern]\n  }\n\n  return expand(pattern)\n}\n\nvar MAX_PATTERN_LENGTH = 1024 * 64\nvar assertValidPattern = function (pattern) {\n  if (typeof pattern !== 'string') {\n    throw new TypeError('invalid pattern')\n  }\n\n  if (pattern.length > MAX_PATTERN_LENGTH) {\n    throw new TypeError('pattern is too long')\n  }\n}\n\n// parse a component of the expanded set.\n// At this point, no pattern may contain \"/\" in it\n// so we're going to return a 2d array, where each entry is the full\n// pattern, split on '/', and then turned into a regular expression.\n// A regexp is made at the end which joins each array with an\n// escaped /, and another full one which joins each regexp with |.\n//\n// Following the lead of Bash 4.1, note that \"**\" only has special meaning\n// when it is the *only* thing in a path portion.  Otherwise, any series\n// of * is equivalent to a single *.  Globstar behavior is enabled by\n// default, and can be disabled by setting options.noglobstar.\nMinimatch.prototype.parse = parse\nvar SUBPARSE = {}\nfunction parse (pattern, isSub) {\n  assertValidPattern(pattern)\n\n  var options = this.options\n\n  // shortcuts\n  if (pattern === '**') {\n    if (!options.noglobstar)\n      return GLOBSTAR\n    else\n      pattern = '*'\n  }\n  if (pattern === '') return ''\n\n  var re = ''\n  var hasMagic = !!options.nocase\n  var escaping = false\n  // ? => one single character\n  var patternListStack = []\n  var negativeLists = []\n  var stateChar\n  var inClass = false\n  var reClassStart = -1\n  var classStart = -1\n  // . and .. never match anything that doesn't start with .,\n  // even when options.dot is set.\n  var patternStart = pattern.charAt(0) === '.' ? '' // anything\n  // not (start or / followed by . or .. followed by / or end)\n  : options.dot ? '(?!(?:^|\\\\\\/)\\\\.{1,2}(?:$|\\\\\\/))'\n  : '(?!\\\\.)'\n  var self = this\n\n  function clearStateChar () {\n    if (stateChar) {\n      // we had some state-tracking character\n      // that wasn't consumed by this pass.\n      switch (stateChar) {\n        case '*':\n          re += star\n          hasMagic = true\n        break\n        case '?':\n          re += qmark\n          hasMagic = true\n        break\n        default:\n          re += '\\\\' + stateChar\n        break\n      }\n      self.debug('clearStateChar %j %j', stateChar, re)\n      stateChar = false\n    }\n  }\n\n  for (var i = 0, len = pattern.length, c\n    ; (i < len) && (c = pattern.charAt(i))\n    ; i++) {\n    this.debug('%s\\t%s %s %j', pattern, i, re, c)\n\n    // skip over any that are escaped.\n    if (escaping && reSpecials[c]) {\n      re += '\\\\' + c\n      escaping = false\n      continue\n    }\n\n    switch (c) {\n      /* istanbul ignore next */\n      case '/': {\n        // completely not allowed, even escaped.\n        // Should already be path-split by now.\n        return false\n      }\n\n      case '\\\\':\n        clearStateChar()\n        escaping = true\n      continue\n\n      // the various stateChar values\n      // for the \"extglob\" stuff.\n      case '?':\n      case '*':\n      case '+':\n      case '@':\n      case '!':\n        this.debug('%s\\t%s %s %j <-- stateChar', pattern, i, re, c)\n\n        // all of those are literals inside a class, except that\n        // the glob [!a] means [^a] in regexp\n        if (inClass) {\n          this.debug('  in class')\n          if (c === '!' && i === classStart + 1) c = '^'\n          re += c\n          continue\n        }\n\n        // if we already have a stateChar, then it means\n        // that there was something like ** or +? in there.\n        // Handle the stateChar, then proceed with this one.\n        self.debug('call clearStateChar %j', stateChar)\n        clearStateChar()\n        stateChar = c\n        // if extglob is disabled, then +(asdf|foo) isn't a thing.\n        // just clear the statechar *now*, rather than even diving into\n        // the patternList stuff.\n        if (options.noext) clearStateChar()\n      continue\n\n      case '(':\n        if (inClass) {\n          re += '('\n          continue\n        }\n\n        if (!stateChar) {\n          re += '\\\\('\n          continue\n        }\n\n        patternListStack.push({\n          type: stateChar,\n          start: i - 1,\n          reStart: re.length,\n          open: plTypes[stateChar].open,\n          close: plTypes[stateChar].close\n        })\n        // negation is (?:(?!js)[^/]*)\n        re += stateChar === '!' ? '(?:(?!(?:' : '(?:'\n        this.debug('plType %j %j', stateChar, re)\n        stateChar = false\n      continue\n\n      case ')':\n        if (inClass || !patternListStack.length) {\n          re += '\\\\)'\n          continue\n        }\n\n        clearStateChar()\n        hasMagic = true\n        var pl = patternListStack.pop()\n        // negation is (?:(?!js)[^/]*)\n        // The others are (?:<pattern>)<type>\n        re += pl.close\n        if (pl.type === '!') {\n          negativeLists.push(pl)\n        }\n        pl.reEnd = re.length\n      continue\n\n      case '|':\n        if (inClass || !patternListStack.length || escaping) {\n          re += '\\\\|'\n          escaping = false\n          continue\n        }\n\n        clearStateChar()\n        re += '|'\n      continue\n\n      // these are mostly the same in regexp and glob\n      case '[':\n        // swallow any state-tracking char before the [\n        clearStateChar()\n\n        if (inClass) {\n          re += '\\\\' + c\n          continue\n        }\n\n        inClass = true\n        classStart = i\n        reClassStart = re.length\n        re += c\n      continue\n\n      case ']':\n        //  a right bracket shall lose its special\n        //  meaning and represent itself in\n        //  a bracket expression if it occurs\n        //  first in the list.  -- POSIX.2 2.8.3.2\n        if (i === classStart + 1 || !inClass) {\n          re += '\\\\' + c\n          escaping = false\n          continue\n        }\n\n        // handle the case where we left a class open.\n        // \"[z-a]\" is valid, equivalent to \"\\[z-a\\]\"\n        // split where the last [ was, make sure we don't have\n        // an invalid re. if so, re-walk the contents of the\n        // would-be class to re-translate any characters that\n        // were passed through as-is\n        // TODO: It would probably be faster to determine this\n        // without a try/catch and a new RegExp, but it's tricky\n        // to do safely.  For now, this is safe and works.\n        var cs = pattern.substring(classStart + 1, i)\n        try {\n          RegExp('[' + cs + ']')\n        } catch (er) {\n          // not a valid class!\n          var sp = this.parse(cs, SUBPARSE)\n          re = re.substr(0, reClassStart) + '\\\\[' + sp[0] + '\\\\]'\n          hasMagic = hasMagic || sp[1]\n          inClass = false\n          continue\n        }\n\n        // finish up the class.\n        hasMagic = true\n        inClass = false\n        re += c\n      continue\n\n      default:\n        // swallow any state char that wasn't consumed\n        clearStateChar()\n\n        if (escaping) {\n          // no need\n          escaping = false\n        } else if (reSpecials[c]\n          && !(c === '^' && inClass)) {\n          re += '\\\\'\n        }\n\n        re += c\n\n    } // switch\n  } // for\n\n  // handle the case where we left a class open.\n  // \"[abc\" is valid, equivalent to \"\\[abc\"\n  if (inClass) {\n    // split where the last [ was, and escape it\n    // this is a huge pita.  We now have to re-walk\n    // the contents of the would-be class to re-translate\n    // any characters that were passed through as-is\n    cs = pattern.substr(classStart + 1)\n    sp = this.parse(cs, SUBPARSE)\n    re = re.substr(0, reClassStart) + '\\\\[' + sp[0]\n    hasMagic = hasMagic || sp[1]\n  }\n\n  // handle the case where we had a +( thing at the *end*\n  // of the pattern.\n  // each pattern list stack adds 3 chars, and we need to go through\n  // and escape any | chars that were passed through as-is for the regexp.\n  // Go through and escape them, taking care not to double-escape any\n  // | chars that were already escaped.\n  for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {\n    var tail = re.slice(pl.reStart + pl.open.length)\n    this.debug('setting tail', re, pl)\n    // maybe some even number of \\, then maybe 1 \\, followed by a |\n    tail = tail.replace(/((?:\\\\{2}){0,64})(\\\\?)\\|/g, function (_, $1, $2) {\n      if (!$2) {\n        // the | isn't already escaped, so escape it.\n        $2 = '\\\\'\n      }\n\n      // need to escape all those slashes *again*, without escaping the\n      // one that we need for escaping the | character.  As it works out,\n      // escaping an even number of slashes can be done by simply repeating\n      // it exactly after itself.  That's why this trick works.\n      //\n      // I am sorry that you have to see this.\n      return $1 + $1 + $2 + '|'\n    })\n\n    this.debug('tail=%j\\n   %s', tail, tail, pl, re)\n    var t = pl.type === '*' ? star\n      : pl.type === '?' ? qmark\n      : '\\\\' + pl.type\n\n    hasMagic = true\n    re = re.slice(0, pl.reStart) + t + '\\\\(' + tail\n  }\n\n  // handle trailing things that only matter at the very end.\n  clearStateChar()\n  if (escaping) {\n    // trailing \\\\\n    re += '\\\\\\\\'\n  }\n\n  // only need to apply the nodot start if the re starts with\n  // something that could conceivably capture a dot\n  var addPatternStart = false\n  switch (re.charAt(0)) {\n    case '[': case '.': case '(': addPatternStart = true\n  }\n\n  // Hack to work around lack of negative lookbehind in JS\n  // A pattern like: *.!(x).!(y|z) needs to ensure that a name\n  // like 'a.xyz.yz' doesn't match.  So, the first negative\n  // lookahead, has to look ALL the way ahead, to the end of\n  // the pattern.\n  for (var n = negativeLists.length - 1; n > -1; n--) {\n    var nl = negativeLists[n]\n\n    var nlBefore = re.slice(0, nl.reStart)\n    var nlFirst = re.slice(nl.reStart, nl.reEnd - 8)\n    var nlLast = re.slice(nl.reEnd - 8, nl.reEnd)\n    var nlAfter = re.slice(nl.reEnd)\n\n    nlLast += nlAfter\n\n    // Handle nested stuff like *(*.js|!(*.json)), where open parens\n    // mean that we should *not* include the ) in the bit that is considered\n    // \"after\" the negated section.\n    var openParensBefore = nlBefore.split('(').length - 1\n    var cleanAfter = nlAfter\n    for (i = 0; i < openParensBefore; i++) {\n      cleanAfter = cleanAfter.replace(/\\)[+*?]?/, '')\n    }\n    nlAfter = cleanAfter\n\n    var dollar = ''\n    if (nlAfter === '' && isSub !== SUBPARSE) {\n      dollar = '$'\n    }\n    var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast\n    re = newRe\n  }\n\n  // if the re is not \"\" at this point, then we need to make sure\n  // it doesn't match against an empty path part.\n  // Otherwise a/* will match a/, which it should not.\n  if (re !== '' && hasMagic) {\n    re = '(?=.)' + re\n  }\n\n  if (addPatternStart) {\n    re = patternStart + re\n  }\n\n  // parsing just a piece of a larger pattern.\n  if (isSub === SUBPARSE) {\n    return [re, hasMagic]\n  }\n\n  // skip the regexp for non-magical patterns\n  // unescape anything in it, though, so that it'll be\n  // an exact match against a file etc.\n  if (!hasMagic) {\n    return globUnescape(pattern)\n  }\n\n  var flags = options.nocase ? 'i' : ''\n  try {\n    var regExp = new RegExp('^' + re + '$', flags)\n  } catch (er) /* istanbul ignore next - should be impossible */ {\n    // If it was an invalid regular expression, then it can't match\n    // anything.  This trick looks for a character after the end of\n    // the string, which is of course impossible, except in multi-line\n    // mode, but it's not a /m regex.\n    return new RegExp('$.')\n  }\n\n  regExp._glob = pattern\n  regExp._src = re\n\n  return regExp\n}\n\nminimatch.makeRe = function (pattern, options) {\n  return new Minimatch(pattern, options || {}).makeRe()\n}\n\nMinimatch.prototype.makeRe = makeRe\nfunction makeRe () {\n  if (this.regexp || this.regexp === false) return this.regexp\n\n  // at this point, this.set is a 2d array of partial\n  // pattern strings, or \"**\".\n  //\n  // It's better to use .match().  This function shouldn't\n  // be used, really, but it's pretty convenient sometimes,\n  // when you just want to work with a regex.\n  var set = this.set\n\n  if (!set.length) {\n    this.regexp = false\n    return this.regexp\n  }\n  var options = this.options\n\n  var twoStar = options.noglobstar ? star\n    : options.dot ? twoStarDot\n    : twoStarNoDot\n  var flags = options.nocase ? 'i' : ''\n\n  var re = set.map(function (pattern) {\n    return pattern.map(function (p) {\n      return (p === GLOBSTAR) ? twoStar\n      : (typeof p === 'string') ? regExpEscape(p)\n      : p._src\n    }).join('\\\\\\/')\n  }).join('|')\n\n  // must match entire pattern\n  // ending in a * or ** will make it less strict.\n  re = '^(?:' + re + ')$'\n\n  // can match anything, as long as it's not this.\n  if (this.negate) re = '^(?!' + re + ').*$'\n\n  try {\n    this.regexp = new RegExp(re, flags)\n  } catch (ex) /* istanbul ignore next - should be impossible */ {\n    this.regexp = false\n  }\n  return this.regexp\n}\n\nminimatch.match = function (list, pattern, options) {\n  options = options || {}\n  var mm = new Minimatch(pattern, options)\n  list = list.filter(function (f) {\n    return mm.match(f)\n  })\n  if (mm.options.nonull && !list.length) {\n    list.push(pattern)\n  }\n  return list\n}\n\nMinimatch.prototype.match = function match (f, partial) {\n  if (typeof partial === 'undefined') partial = this.partial\n  this.debug('match', f, this.pattern)\n  // short-circuit in the case of busted things.\n  // comments, etc.\n  if (this.comment) return false\n  if (this.empty) return f === ''\n\n  if (f === '/' && partial) return true\n\n  var options = this.options\n\n  // windows: need to use /, not \\\n  if (path.sep !== '/') {\n    f = f.split(path.sep).join('/')\n  }\n\n  // treat the test path as a set of pathparts.\n  f = f.split(slashSplit)\n  this.debug(this.pattern, 'split', f)\n\n  // just ONE of the pattern sets in this.set needs to match\n  // in order for it to be valid.  If negating, then just one\n  // match means that we have failed.\n  // Either way, return on the first hit.\n\n  var set = this.set\n  this.debug(this.pattern, 'set', set)\n\n  // Find the basename of the path by looking for the last non-empty segment\n  var filename\n  var i\n  for (i = f.length - 1; i >= 0; i--) {\n    filename = f[i]\n    if (filename) break\n  }\n\n  for (i = 0; i < set.length; i++) {\n    var pattern = set[i]\n    var file = f\n    if (options.matchBase && pattern.length === 1) {\n      file = [filename]\n    }\n    var hit = this.matchOne(file, pattern, partial)\n    if (hit) {\n      if (options.flipNegate) return true\n      return !this.negate\n    }\n  }\n\n  // didn't get any hits.  this is success if it's a negative\n  // pattern, failure otherwise.\n  if (options.flipNegate) return false\n  return this.negate\n}\n\n// set partial to true to test if, for example,\n// \"/a/b\" matches the start of \"/*/b/*/d\"\n// Partial means, if you run out of file before you run\n// out of pattern, then that's fine, as long as all\n// the parts match.\nMinimatch.prototype.matchOne = function (file, pattern, partial) {\n  var options = this.options\n\n  this.debug('matchOne',\n    { 'this': this, file: file, pattern: pattern })\n\n  this.debug('matchOne', file.length, pattern.length)\n\n  for (var fi = 0,\n      pi = 0,\n      fl = file.length,\n      pl = pattern.length\n      ; (fi < fl) && (pi < pl)\n      ; fi++, pi++) {\n    this.debug('matchOne loop')\n    var p = pattern[pi]\n    var f = file[fi]\n\n    this.debug(pattern, p, f)\n\n    // should be impossible.\n    // some invalid regexp stuff in the set.\n    /* istanbul ignore if */\n    if (p === false) return false\n\n    if (p === GLOBSTAR) {\n      this.debug('GLOBSTAR', [pattern, p, f])\n\n      // \"**\"\n      // a/**/b/**/c would match the following:\n      // a/b/x/y/z/c\n      // a/x/y/z/b/c\n      // a/b/x/b/x/c\n      // a/b/c\n      // To do this, take the rest of the pattern after\n      // the **, and see if it would match the file remainder.\n      // If so, return success.\n      // If not, the ** \"swallows\" a segment, and try again.\n      // This is recursively awful.\n      //\n      // a/**/b/**/c matching a/b/x/y/z/c\n      // - a matches a\n      // - doublestar\n      //   - matchOne(b/x/y/z/c, b/**/c)\n      //     - b matches b\n      //     - doublestar\n      //       - matchOne(x/y/z/c, c) -> no\n      //       - matchOne(y/z/c, c) -> no\n      //       - matchOne(z/c, c) -> no\n      //       - matchOne(c, c) yes, hit\n      var fr = fi\n      var pr = pi + 1\n      if (pr === pl) {\n        this.debug('** at the end')\n        // a ** at the end will just swallow the rest.\n        // We have found a match.\n        // however, it will not swallow /.x, unless\n        // options.dot is set.\n        // . and .. are *never* matched by **, for explosively\n        // exponential reasons.\n        for (; fi < fl; fi++) {\n          if (file[fi] === '.' || file[fi] === '..' ||\n            (!options.dot && file[fi].charAt(0) === '.')) return false\n        }\n        return true\n      }\n\n      // ok, let's see if we can swallow whatever we can.\n      while (fr < fl) {\n        var swallowee = file[fr]\n\n        this.debug('\\nglobstar while', file, fr, pattern, pr, swallowee)\n\n        // XXX remove this slice.  Just pass the start index.\n        if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {\n          this.debug('globstar found match!', fr, fl, swallowee)\n          // found a match.\n          return true\n        } else {\n          // can't swallow \".\" or \"..\" ever.\n          // can only swallow \".foo\" when explicitly asked.\n          if (swallowee === '.' || swallowee === '..' ||\n            (!options.dot && swallowee.charAt(0) === '.')) {\n            this.debug('dot detected!', file, fr, pattern, pr)\n            break\n          }\n\n          // ** swallows a segment, and continue.\n          this.debug('globstar swallow a segment, and continue')\n          fr++\n        }\n      }\n\n      // no match was found.\n      // However, in partial mode, we can't say this is necessarily over.\n      // If there's more *pattern* left, then\n      /* istanbul ignore if */\n      if (partial) {\n        // ran out of file\n        this.debug('\\n>>> no match, partial?', file, fr, pattern, pr)\n        if (fr === fl) return true\n      }\n      return false\n    }\n\n    // something other than **\n    // non-magic patterns just have to match exactly\n    // patterns with magic have been turned into regexps.\n    var hit\n    if (typeof p === 'string') {\n      hit = f === p\n      this.debug('string match', p, f, hit)\n    } else {\n      hit = f.match(p)\n      this.debug('pattern match', p, f, hit)\n    }\n\n    if (!hit) return false\n  }\n\n  // Note: ending in / means that we'll get a final \"\"\n  // at the end of the pattern.  This can only match a\n  // corresponding \"\" at the end of the file.\n  // If the file ends in /, then it can only match a\n  // a pattern that ends in /, unless the pattern just\n  // doesn't have any more for it. But, a/b/ should *not*\n  // match \"a/b/*\", even though \"\" matches against the\n  // [^/]*? pattern, except in partial mode, where it might\n  // simply not be reached yet.\n  // However, a/b/ should still satisfy a/*\n\n  // now either we fell off the end of the pattern, or we're done.\n  if (fi === fl && pi === pl) {\n    // ran out of pattern and filename at the same time.\n    // an exact hit!\n    return true\n  } else if (fi === fl) {\n    // ran out of file, but still had pattern left.\n    // this is ok if we're doing the match as part of\n    // a glob fs traversal.\n    return partial\n  } else /* istanbul ignore else */ if (pi === pl) {\n    // ran out of pattern, still have file left.\n    // this is only acceptable if we're on the very last\n    // empty segment of a file with a trailing slash.\n    // a/* should match a/b/\n    return (fi === fl - 1) && (file[fi] === '')\n  }\n\n  // should be unreachable.\n  /* istanbul ignore next */\n  throw new Error('wtf?')\n}\n\n// replace stuff like \\* with *\nfunction globUnescape (s) {\n  return s.replace(/\\\\(.)/g, '$1')\n}\n\nfunction regExpEscape (s) {\n  return s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&')\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbWluaW1hdGNoL21pbmltYXRjaC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBOztBQUVBLDBCQUEwQixNQUFNLE9BQU8sbUJBQU8sQ0FBQyxtSUFBTSxJQUFJLGFBQWE7QUFDdEU7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxtQkFBTyxDQUFDLGdFQUFpQjs7QUFFdEM7QUFDQSxTQUFTLHNDQUFzQztBQUMvQyxTQUFTLDBCQUEwQjtBQUNuQyxTQUFTLDBCQUEwQjtBQUNuQyxTQUFTLDBCQUEwQjtBQUNuQyxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLElBQUk7O0FBRTdDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdDQUFnQzs7QUFFaEMsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxJQUFJO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEscURBQXFEOztBQUVyRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsTUFBTTtBQUNOLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSyxJQUFJO0FBQ1QsS0FBSyxHQUFHO0FBQ1IsS0FBSyxLQUFLO0FBQ1YsS0FBSyxJQUFJLElBQUksRUFBRTtBQUNmLEtBQUssSUFBSSxFQUFFLElBQUk7QUFDZjtBQUNBO0FBQ0EsS0FBSyxJQUFJLE9BQU8sSUFBSTtBQUNwQixLQUFLLEVBQUUsT0FBTyxFQUFFO0FBQ2hCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsNkJBQTZCLFFBQVEsTUFBTTtBQUMzQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsSUFBSTtBQUN4QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07QUFDTixNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxNQUFNO0FBQ04sSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLElBQUk7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLEVBQUUsRUFBRSxLQUFLO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLFFBQVE7QUFDakQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixzQkFBc0I7QUFDdEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsNkNBQTZDO0FBQzdDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsUUFBUTtBQUNqQztBQUNBO0FBQ0E7O0FBRUEsY0FBYyxnQkFBZ0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTSw0Q0FBNEM7O0FBRWxEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCO0FBQzNCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdG9kby1saXN0Ly4vbm9kZV9tb2R1bGVzL21pbmltYXRjaC9taW5pbWF0Y2guanM/ZDhiMiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IG1pbmltYXRjaFxubWluaW1hdGNoLk1pbmltYXRjaCA9IE1pbmltYXRjaFxuXG52YXIgcGF0aCA9IChmdW5jdGlvbiAoKSB7IHRyeSB7IHJldHVybiByZXF1aXJlKCdwYXRoJykgfSBjYXRjaCAoZSkge319KCkpIHx8IHtcbiAgc2VwOiAnLydcbn1cbm1pbmltYXRjaC5zZXAgPSBwYXRoLnNlcFxuXG52YXIgR0xPQlNUQVIgPSBtaW5pbWF0Y2guR0xPQlNUQVIgPSBNaW5pbWF0Y2guR0xPQlNUQVIgPSB7fVxudmFyIGV4cGFuZCA9IHJlcXVpcmUoJ2JyYWNlLWV4cGFuc2lvbicpXG5cbnZhciBwbFR5cGVzID0ge1xuICAnISc6IHsgb3BlbjogJyg/Oig/ISg/OicsIGNsb3NlOiAnKSlbXi9dKj8pJ30sXG4gICc/JzogeyBvcGVuOiAnKD86JywgY2xvc2U6ICcpPycgfSxcbiAgJysnOiB7IG9wZW46ICcoPzonLCBjbG9zZTogJykrJyB9LFxuICAnKic6IHsgb3BlbjogJyg/OicsIGNsb3NlOiAnKSonIH0sXG4gICdAJzogeyBvcGVuOiAnKD86JywgY2xvc2U6ICcpJyB9XG59XG5cbi8vIGFueSBzaW5nbGUgdGhpbmcgb3RoZXIgdGhhbiAvXG4vLyBkb24ndCBuZWVkIHRvIGVzY2FwZSAvIHdoZW4gdXNpbmcgbmV3IFJlZ0V4cCgpXG52YXIgcW1hcmsgPSAnW14vXSdcblxuLy8gKiA9PiBhbnkgbnVtYmVyIG9mIGNoYXJhY3RlcnNcbnZhciBzdGFyID0gcW1hcmsgKyAnKj8nXG5cbi8vICoqIHdoZW4gZG90cyBhcmUgYWxsb3dlZC4gIEFueXRoaW5nIGdvZXMsIGV4Y2VwdCAuLiBhbmQgLlxuLy8gbm90ICheIG9yIC8gZm9sbG93ZWQgYnkgb25lIG9yIHR3byBkb3RzIGZvbGxvd2VkIGJ5ICQgb3IgLyksXG4vLyBmb2xsb3dlZCBieSBhbnl0aGluZywgYW55IG51bWJlciBvZiB0aW1lcy5cbnZhciB0d29TdGFyRG90ID0gJyg/Oig/ISg/OlxcXFxcXC98XikoPzpcXFxcLnsxLDJ9KSgkfFxcXFxcXC8pKS4pKj8nXG5cbi8vIG5vdCBhIF4gb3IgLyBmb2xsb3dlZCBieSBhIGRvdCxcbi8vIGZvbGxvd2VkIGJ5IGFueXRoaW5nLCBhbnkgbnVtYmVyIG9mIHRpbWVzLlxudmFyIHR3b1N0YXJOb0RvdCA9ICcoPzooPyEoPzpcXFxcXFwvfF4pXFxcXC4pLikqPydcblxuLy8gY2hhcmFjdGVycyB0aGF0IG5lZWQgdG8gYmUgZXNjYXBlZCBpbiBSZWdFeHAuXG52YXIgcmVTcGVjaWFscyA9IGNoYXJTZXQoJygpLip7fSs/W11eJFxcXFwhJylcblxuLy8gXCJhYmNcIiAtPiB7IGE6dHJ1ZSwgYjp0cnVlLCBjOnRydWUgfVxuZnVuY3Rpb24gY2hhclNldCAocykge1xuICByZXR1cm4gcy5zcGxpdCgnJykucmVkdWNlKGZ1bmN0aW9uIChzZXQsIGMpIHtcbiAgICBzZXRbY10gPSB0cnVlXG4gICAgcmV0dXJuIHNldFxuICB9LCB7fSlcbn1cblxuLy8gbm9ybWFsaXplcyBzbGFzaGVzLlxudmFyIHNsYXNoU3BsaXQgPSAvXFwvKy9cblxubWluaW1hdGNoLmZpbHRlciA9IGZpbHRlclxuZnVuY3Rpb24gZmlsdGVyIChwYXR0ZXJuLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XG4gIHJldHVybiBmdW5jdGlvbiAocCwgaSwgbGlzdCkge1xuICAgIHJldHVybiBtaW5pbWF0Y2gocCwgcGF0dGVybiwgb3B0aW9ucylcbiAgfVxufVxuXG5mdW5jdGlvbiBleHQgKGEsIGIpIHtcbiAgYiA9IGIgfHwge31cbiAgdmFyIHQgPSB7fVxuICBPYmplY3Qua2V5cyhhKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgdFtrXSA9IGFba11cbiAgfSlcbiAgT2JqZWN0LmtleXMoYikuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICAgIHRba10gPSBiW2tdXG4gIH0pXG4gIHJldHVybiB0XG59XG5cbm1pbmltYXRjaC5kZWZhdWx0cyA9IGZ1bmN0aW9uIChkZWYpIHtcbiAgaWYgKCFkZWYgfHwgdHlwZW9mIGRlZiAhPT0gJ29iamVjdCcgfHwgIU9iamVjdC5rZXlzKGRlZikubGVuZ3RoKSB7XG4gICAgcmV0dXJuIG1pbmltYXRjaFxuICB9XG5cbiAgdmFyIG9yaWcgPSBtaW5pbWF0Y2hcblxuICB2YXIgbSA9IGZ1bmN0aW9uIG1pbmltYXRjaCAocCwgcGF0dGVybiwgb3B0aW9ucykge1xuICAgIHJldHVybiBvcmlnKHAsIHBhdHRlcm4sIGV4dChkZWYsIG9wdGlvbnMpKVxuICB9XG5cbiAgbS5NaW5pbWF0Y2ggPSBmdW5jdGlvbiBNaW5pbWF0Y2ggKHBhdHRlcm4sIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IG9yaWcuTWluaW1hdGNoKHBhdHRlcm4sIGV4dChkZWYsIG9wdGlvbnMpKVxuICB9XG4gIG0uTWluaW1hdGNoLmRlZmF1bHRzID0gZnVuY3Rpb24gZGVmYXVsdHMgKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gb3JpZy5kZWZhdWx0cyhleHQoZGVmLCBvcHRpb25zKSkuTWluaW1hdGNoXG4gIH1cblxuICBtLmZpbHRlciA9IGZ1bmN0aW9uIGZpbHRlciAocGF0dGVybiwgb3B0aW9ucykge1xuICAgIHJldHVybiBvcmlnLmZpbHRlcihwYXR0ZXJuLCBleHQoZGVmLCBvcHRpb25zKSlcbiAgfVxuXG4gIG0uZGVmYXVsdHMgPSBmdW5jdGlvbiBkZWZhdWx0cyAob3B0aW9ucykge1xuICAgIHJldHVybiBvcmlnLmRlZmF1bHRzKGV4dChkZWYsIG9wdGlvbnMpKVxuICB9XG5cbiAgbS5tYWtlUmUgPSBmdW5jdGlvbiBtYWtlUmUgKHBhdHRlcm4sIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gb3JpZy5tYWtlUmUocGF0dGVybiwgZXh0KGRlZiwgb3B0aW9ucykpXG4gIH1cblxuICBtLmJyYWNlRXhwYW5kID0gZnVuY3Rpb24gYnJhY2VFeHBhbmQgKHBhdHRlcm4sIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gb3JpZy5icmFjZUV4cGFuZChwYXR0ZXJuLCBleHQoZGVmLCBvcHRpb25zKSlcbiAgfVxuXG4gIG0ubWF0Y2ggPSBmdW5jdGlvbiAobGlzdCwgcGF0dGVybiwgb3B0aW9ucykge1xuICAgIHJldHVybiBvcmlnLm1hdGNoKGxpc3QsIHBhdHRlcm4sIGV4dChkZWYsIG9wdGlvbnMpKVxuICB9XG5cbiAgcmV0dXJuIG1cbn1cblxuTWluaW1hdGNoLmRlZmF1bHRzID0gZnVuY3Rpb24gKGRlZikge1xuICByZXR1cm4gbWluaW1hdGNoLmRlZmF1bHRzKGRlZikuTWluaW1hdGNoXG59XG5cbmZ1bmN0aW9uIG1pbmltYXRjaCAocCwgcGF0dGVybiwgb3B0aW9ucykge1xuICBhc3NlcnRWYWxpZFBhdHRlcm4ocGF0dGVybilcblxuICBpZiAoIW9wdGlvbnMpIG9wdGlvbnMgPSB7fVxuXG4gIC8vIHNob3J0Y3V0OiBjb21tZW50cyBtYXRjaCBub3RoaW5nLlxuICBpZiAoIW9wdGlvbnMubm9jb21tZW50ICYmIHBhdHRlcm4uY2hhckF0KDApID09PSAnIycpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIHJldHVybiBuZXcgTWluaW1hdGNoKHBhdHRlcm4sIG9wdGlvbnMpLm1hdGNoKHApXG59XG5cbmZ1bmN0aW9uIE1pbmltYXRjaCAocGF0dGVybiwgb3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgTWluaW1hdGNoKSkge1xuICAgIHJldHVybiBuZXcgTWluaW1hdGNoKHBhdHRlcm4sIG9wdGlvbnMpXG4gIH1cblxuICBhc3NlcnRWYWxpZFBhdHRlcm4ocGF0dGVybilcblxuICBpZiAoIW9wdGlvbnMpIG9wdGlvbnMgPSB7fVxuXG4gIHBhdHRlcm4gPSBwYXR0ZXJuLnRyaW0oKVxuXG4gIC8vIHdpbmRvd3Mgc3VwcG9ydDogbmVlZCB0byB1c2UgLywgbm90IFxcXG4gIGlmICghb3B0aW9ucy5hbGxvd1dpbmRvd3NFc2NhcGUgJiYgcGF0aC5zZXAgIT09ICcvJykge1xuICAgIHBhdHRlcm4gPSBwYXR0ZXJuLnNwbGl0KHBhdGguc2VwKS5qb2luKCcvJylcbiAgfVxuXG4gIHRoaXMub3B0aW9ucyA9IG9wdGlvbnNcbiAgdGhpcy5zZXQgPSBbXVxuICB0aGlzLnBhdHRlcm4gPSBwYXR0ZXJuXG4gIHRoaXMucmVnZXhwID0gbnVsbFxuICB0aGlzLm5lZ2F0ZSA9IGZhbHNlXG4gIHRoaXMuY29tbWVudCA9IGZhbHNlXG4gIHRoaXMuZW1wdHkgPSBmYWxzZVxuICB0aGlzLnBhcnRpYWwgPSAhIW9wdGlvbnMucGFydGlhbFxuXG4gIC8vIG1ha2UgdGhlIHNldCBvZiByZWdleHBzIGV0Yy5cbiAgdGhpcy5tYWtlKClcbn1cblxuTWluaW1hdGNoLnByb3RvdHlwZS5kZWJ1ZyA9IGZ1bmN0aW9uICgpIHt9XG5cbk1pbmltYXRjaC5wcm90b3R5cGUubWFrZSA9IG1ha2VcbmZ1bmN0aW9uIG1ha2UgKCkge1xuICB2YXIgcGF0dGVybiA9IHRoaXMucGF0dGVyblxuICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9uc1xuXG4gIC8vIGVtcHR5IHBhdHRlcm5zIGFuZCBjb21tZW50cyBtYXRjaCBub3RoaW5nLlxuICBpZiAoIW9wdGlvbnMubm9jb21tZW50ICYmIHBhdHRlcm4uY2hhckF0KDApID09PSAnIycpIHtcbiAgICB0aGlzLmNvbW1lbnQgPSB0cnVlXG4gICAgcmV0dXJuXG4gIH1cbiAgaWYgKCFwYXR0ZXJuKSB7XG4gICAgdGhpcy5lbXB0eSA9IHRydWVcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8vIHN0ZXAgMTogZmlndXJlIG91dCBuZWdhdGlvbiwgZXRjLlxuICB0aGlzLnBhcnNlTmVnYXRlKClcblxuICAvLyBzdGVwIDI6IGV4cGFuZCBicmFjZXNcbiAgdmFyIHNldCA9IHRoaXMuZ2xvYlNldCA9IHRoaXMuYnJhY2VFeHBhbmQoKVxuXG4gIGlmIChvcHRpb25zLmRlYnVnKSB0aGlzLmRlYnVnID0gZnVuY3Rpb24gZGVidWcoKSB7IGNvbnNvbGUuZXJyb3IuYXBwbHkoY29uc29sZSwgYXJndW1lbnRzKSB9XG5cbiAgdGhpcy5kZWJ1Zyh0aGlzLnBhdHRlcm4sIHNldClcblxuICAvLyBzdGVwIDM6IG5vdyB3ZSBoYXZlIGEgc2V0LCBzbyB0dXJuIGVhY2ggb25lIGludG8gYSBzZXJpZXMgb2YgcGF0aC1wb3J0aW9uXG4gIC8vIG1hdGNoaW5nIHBhdHRlcm5zLlxuICAvLyBUaGVzZSB3aWxsIGJlIHJlZ2V4cHMsIGV4Y2VwdCBpbiB0aGUgY2FzZSBvZiBcIioqXCIsIHdoaWNoIGlzXG4gIC8vIHNldCB0byB0aGUgR0xPQlNUQVIgb2JqZWN0IGZvciBnbG9ic3RhciBiZWhhdmlvcixcbiAgLy8gYW5kIHdpbGwgbm90IGNvbnRhaW4gYW55IC8gY2hhcmFjdGVyc1xuICBzZXQgPSB0aGlzLmdsb2JQYXJ0cyA9IHNldC5tYXAoZnVuY3Rpb24gKHMpIHtcbiAgICByZXR1cm4gcy5zcGxpdChzbGFzaFNwbGl0KVxuICB9KVxuXG4gIHRoaXMuZGVidWcodGhpcy5wYXR0ZXJuLCBzZXQpXG5cbiAgLy8gZ2xvYiAtLT4gcmVnZXhwc1xuICBzZXQgPSBzZXQubWFwKGZ1bmN0aW9uIChzLCBzaSwgc2V0KSB7XG4gICAgcmV0dXJuIHMubWFwKHRoaXMucGFyc2UsIHRoaXMpXG4gIH0sIHRoaXMpXG5cbiAgdGhpcy5kZWJ1Zyh0aGlzLnBhdHRlcm4sIHNldClcblxuICAvLyBmaWx0ZXIgb3V0IGV2ZXJ5dGhpbmcgdGhhdCBkaWRuJ3QgY29tcGlsZSBwcm9wZXJseS5cbiAgc2V0ID0gc2V0LmZpbHRlcihmdW5jdGlvbiAocykge1xuICAgIHJldHVybiBzLmluZGV4T2YoZmFsc2UpID09PSAtMVxuICB9KVxuXG4gIHRoaXMuZGVidWcodGhpcy5wYXR0ZXJuLCBzZXQpXG5cbiAgdGhpcy5zZXQgPSBzZXRcbn1cblxuTWluaW1hdGNoLnByb3RvdHlwZS5wYXJzZU5lZ2F0ZSA9IHBhcnNlTmVnYXRlXG5mdW5jdGlvbiBwYXJzZU5lZ2F0ZSAoKSB7XG4gIHZhciBwYXR0ZXJuID0gdGhpcy5wYXR0ZXJuXG4gIHZhciBuZWdhdGUgPSBmYWxzZVxuICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9uc1xuICB2YXIgbmVnYXRlT2Zmc2V0ID0gMFxuXG4gIGlmIChvcHRpb25zLm5vbmVnYXRlKSByZXR1cm5cblxuICBmb3IgKHZhciBpID0gMCwgbCA9IHBhdHRlcm4ubGVuZ3RoXG4gICAgOyBpIDwgbCAmJiBwYXR0ZXJuLmNoYXJBdChpKSA9PT0gJyEnXG4gICAgOyBpKyspIHtcbiAgICBuZWdhdGUgPSAhbmVnYXRlXG4gICAgbmVnYXRlT2Zmc2V0KytcbiAgfVxuXG4gIGlmIChuZWdhdGVPZmZzZXQpIHRoaXMucGF0dGVybiA9IHBhdHRlcm4uc3Vic3RyKG5lZ2F0ZU9mZnNldClcbiAgdGhpcy5uZWdhdGUgPSBuZWdhdGVcbn1cblxuLy8gQnJhY2UgZXhwYW5zaW9uOlxuLy8gYXtiLGN9ZCAtPiBhYmQgYWNkXG4vLyBhe2IsfWMgLT4gYWJjIGFjXG4vLyBhezAuLjN9ZCAtPiBhMGQgYTFkIGEyZCBhM2Rcbi8vIGF7Yixje2QsZX1mfWcgLT4gYWJnIGFjZGZnIGFjZWZnXG4vLyBhe2IsY31ke2UsZn1nIC0+IGFiZGVnIGFjZGVnIGFiZGVnIGFiZGZnXG4vL1xuLy8gSW52YWxpZCBzZXRzIGFyZSBub3QgZXhwYW5kZWQuXG4vLyBhezIuLn1iIC0+IGF7Mi4ufWJcbi8vIGF7Yn1jIC0+IGF7Yn1jXG5taW5pbWF0Y2guYnJhY2VFeHBhbmQgPSBmdW5jdGlvbiAocGF0dGVybiwgb3B0aW9ucykge1xuICByZXR1cm4gYnJhY2VFeHBhbmQocGF0dGVybiwgb3B0aW9ucylcbn1cblxuTWluaW1hdGNoLnByb3RvdHlwZS5icmFjZUV4cGFuZCA9IGJyYWNlRXhwYW5kXG5cbmZ1bmN0aW9uIGJyYWNlRXhwYW5kIChwYXR0ZXJuLCBvcHRpb25zKSB7XG4gIGlmICghb3B0aW9ucykge1xuICAgIGlmICh0aGlzIGluc3RhbmNlb2YgTWluaW1hdGNoKSB7XG4gICAgICBvcHRpb25zID0gdGhpcy5vcHRpb25zXG4gICAgfSBlbHNlIHtcbiAgICAgIG9wdGlvbnMgPSB7fVxuICAgIH1cbiAgfVxuXG4gIHBhdHRlcm4gPSB0eXBlb2YgcGF0dGVybiA9PT0gJ3VuZGVmaW5lZCdcbiAgICA/IHRoaXMucGF0dGVybiA6IHBhdHRlcm5cblxuICBhc3NlcnRWYWxpZFBhdHRlcm4ocGF0dGVybilcblxuICAvLyBUaGFua3MgdG8gWWV0aW5nIExpIDxodHRwczovL2dpdGh1Yi5jb20veWV0aW5nbGk+IGZvclxuICAvLyBpbXByb3ZpbmcgdGhpcyByZWdleHAgdG8gYXZvaWQgYSBSZURPUyB2dWxuZXJhYmlsaXR5LlxuICBpZiAob3B0aW9ucy5ub2JyYWNlIHx8ICEvXFx7KD86KD8hXFx7KS4pKlxcfS8udGVzdChwYXR0ZXJuKSkge1xuICAgIC8vIHNob3J0Y3V0LiBubyBuZWVkIHRvIGV4cGFuZC5cbiAgICByZXR1cm4gW3BhdHRlcm5dXG4gIH1cblxuICByZXR1cm4gZXhwYW5kKHBhdHRlcm4pXG59XG5cbnZhciBNQVhfUEFUVEVSTl9MRU5HVEggPSAxMDI0ICogNjRcbnZhciBhc3NlcnRWYWxpZFBhdHRlcm4gPSBmdW5jdGlvbiAocGF0dGVybikge1xuICBpZiAodHlwZW9mIHBhdHRlcm4gIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBwYXR0ZXJuJylcbiAgfVxuXG4gIGlmIChwYXR0ZXJuLmxlbmd0aCA+IE1BWF9QQVRURVJOX0xFTkdUSCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3BhdHRlcm4gaXMgdG9vIGxvbmcnKVxuICB9XG59XG5cbi8vIHBhcnNlIGEgY29tcG9uZW50IG9mIHRoZSBleHBhbmRlZCBzZXQuXG4vLyBBdCB0aGlzIHBvaW50LCBubyBwYXR0ZXJuIG1heSBjb250YWluIFwiL1wiIGluIGl0XG4vLyBzbyB3ZSdyZSBnb2luZyB0byByZXR1cm4gYSAyZCBhcnJheSwgd2hlcmUgZWFjaCBlbnRyeSBpcyB0aGUgZnVsbFxuLy8gcGF0dGVybiwgc3BsaXQgb24gJy8nLCBhbmQgdGhlbiB0dXJuZWQgaW50byBhIHJlZ3VsYXIgZXhwcmVzc2lvbi5cbi8vIEEgcmVnZXhwIGlzIG1hZGUgYXQgdGhlIGVuZCB3aGljaCBqb2lucyBlYWNoIGFycmF5IHdpdGggYW5cbi8vIGVzY2FwZWQgLywgYW5kIGFub3RoZXIgZnVsbCBvbmUgd2hpY2ggam9pbnMgZWFjaCByZWdleHAgd2l0aCB8LlxuLy9cbi8vIEZvbGxvd2luZyB0aGUgbGVhZCBvZiBCYXNoIDQuMSwgbm90ZSB0aGF0IFwiKipcIiBvbmx5IGhhcyBzcGVjaWFsIG1lYW5pbmdcbi8vIHdoZW4gaXQgaXMgdGhlICpvbmx5KiB0aGluZyBpbiBhIHBhdGggcG9ydGlvbi4gIE90aGVyd2lzZSwgYW55IHNlcmllc1xuLy8gb2YgKiBpcyBlcXVpdmFsZW50IHRvIGEgc2luZ2xlICouICBHbG9ic3RhciBiZWhhdmlvciBpcyBlbmFibGVkIGJ5XG4vLyBkZWZhdWx0LCBhbmQgY2FuIGJlIGRpc2FibGVkIGJ5IHNldHRpbmcgb3B0aW9ucy5ub2dsb2JzdGFyLlxuTWluaW1hdGNoLnByb3RvdHlwZS5wYXJzZSA9IHBhcnNlXG52YXIgU1VCUEFSU0UgPSB7fVxuZnVuY3Rpb24gcGFyc2UgKHBhdHRlcm4sIGlzU3ViKSB7XG4gIGFzc2VydFZhbGlkUGF0dGVybihwYXR0ZXJuKVxuXG4gIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zXG5cbiAgLy8gc2hvcnRjdXRzXG4gIGlmIChwYXR0ZXJuID09PSAnKionKSB7XG4gICAgaWYgKCFvcHRpb25zLm5vZ2xvYnN0YXIpXG4gICAgICByZXR1cm4gR0xPQlNUQVJcbiAgICBlbHNlXG4gICAgICBwYXR0ZXJuID0gJyonXG4gIH1cbiAgaWYgKHBhdHRlcm4gPT09ICcnKSByZXR1cm4gJydcblxuICB2YXIgcmUgPSAnJ1xuICB2YXIgaGFzTWFnaWMgPSAhIW9wdGlvbnMubm9jYXNlXG4gIHZhciBlc2NhcGluZyA9IGZhbHNlXG4gIC8vID8gPT4gb25lIHNpbmdsZSBjaGFyYWN0ZXJcbiAgdmFyIHBhdHRlcm5MaXN0U3RhY2sgPSBbXVxuICB2YXIgbmVnYXRpdmVMaXN0cyA9IFtdXG4gIHZhciBzdGF0ZUNoYXJcbiAgdmFyIGluQ2xhc3MgPSBmYWxzZVxuICB2YXIgcmVDbGFzc1N0YXJ0ID0gLTFcbiAgdmFyIGNsYXNzU3RhcnQgPSAtMVxuICAvLyAuIGFuZCAuLiBuZXZlciBtYXRjaCBhbnl0aGluZyB0aGF0IGRvZXNuJ3Qgc3RhcnQgd2l0aCAuLFxuICAvLyBldmVuIHdoZW4gb3B0aW9ucy5kb3QgaXMgc2V0LlxuICB2YXIgcGF0dGVyblN0YXJ0ID0gcGF0dGVybi5jaGFyQXQoMCkgPT09ICcuJyA/ICcnIC8vIGFueXRoaW5nXG4gIC8vIG5vdCAoc3RhcnQgb3IgLyBmb2xsb3dlZCBieSAuIG9yIC4uIGZvbGxvd2VkIGJ5IC8gb3IgZW5kKVxuICA6IG9wdGlvbnMuZG90ID8gJyg/ISg/Ol58XFxcXFxcLylcXFxcLnsxLDJ9KD86JHxcXFxcXFwvKSknXG4gIDogJyg/IVxcXFwuKSdcbiAgdmFyIHNlbGYgPSB0aGlzXG5cbiAgZnVuY3Rpb24gY2xlYXJTdGF0ZUNoYXIgKCkge1xuICAgIGlmIChzdGF0ZUNoYXIpIHtcbiAgICAgIC8vIHdlIGhhZCBzb21lIHN0YXRlLXRyYWNraW5nIGNoYXJhY3RlclxuICAgICAgLy8gdGhhdCB3YXNuJ3QgY29uc3VtZWQgYnkgdGhpcyBwYXNzLlxuICAgICAgc3dpdGNoIChzdGF0ZUNoYXIpIHtcbiAgICAgICAgY2FzZSAnKic6XG4gICAgICAgICAgcmUgKz0gc3RhclxuICAgICAgICAgIGhhc01hZ2ljID0gdHJ1ZVxuICAgICAgICBicmVha1xuICAgICAgICBjYXNlICc/JzpcbiAgICAgICAgICByZSArPSBxbWFya1xuICAgICAgICAgIGhhc01hZ2ljID0gdHJ1ZVxuICAgICAgICBicmVha1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJlICs9ICdcXFxcJyArIHN0YXRlQ2hhclxuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgc2VsZi5kZWJ1ZygnY2xlYXJTdGF0ZUNoYXIgJWogJWonLCBzdGF0ZUNoYXIsIHJlKVxuICAgICAgc3RhdGVDaGFyID0gZmFsc2VcbiAgICB9XG4gIH1cblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gcGF0dGVybi5sZW5ndGgsIGNcbiAgICA7IChpIDwgbGVuKSAmJiAoYyA9IHBhdHRlcm4uY2hhckF0KGkpKVxuICAgIDsgaSsrKSB7XG4gICAgdGhpcy5kZWJ1ZygnJXNcXHQlcyAlcyAlaicsIHBhdHRlcm4sIGksIHJlLCBjKVxuXG4gICAgLy8gc2tpcCBvdmVyIGFueSB0aGF0IGFyZSBlc2NhcGVkLlxuICAgIGlmIChlc2NhcGluZyAmJiByZVNwZWNpYWxzW2NdKSB7XG4gICAgICByZSArPSAnXFxcXCcgKyBjXG4gICAgICBlc2NhcGluZyA9IGZhbHNlXG4gICAgICBjb250aW51ZVxuICAgIH1cblxuICAgIHN3aXRjaCAoYykge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgIGNhc2UgJy8nOiB7XG4gICAgICAgIC8vIGNvbXBsZXRlbHkgbm90IGFsbG93ZWQsIGV2ZW4gZXNjYXBlZC5cbiAgICAgICAgLy8gU2hvdWxkIGFscmVhZHkgYmUgcGF0aC1zcGxpdCBieSBub3cuXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuXG4gICAgICBjYXNlICdcXFxcJzpcbiAgICAgICAgY2xlYXJTdGF0ZUNoYXIoKVxuICAgICAgICBlc2NhcGluZyA9IHRydWVcbiAgICAgIGNvbnRpbnVlXG5cbiAgICAgIC8vIHRoZSB2YXJpb3VzIHN0YXRlQ2hhciB2YWx1ZXNcbiAgICAgIC8vIGZvciB0aGUgXCJleHRnbG9iXCIgc3R1ZmYuXG4gICAgICBjYXNlICc/JzpcbiAgICAgIGNhc2UgJyonOlxuICAgICAgY2FzZSAnKyc6XG4gICAgICBjYXNlICdAJzpcbiAgICAgIGNhc2UgJyEnOlxuICAgICAgICB0aGlzLmRlYnVnKCclc1xcdCVzICVzICVqIDwtLSBzdGF0ZUNoYXInLCBwYXR0ZXJuLCBpLCByZSwgYylcblxuICAgICAgICAvLyBhbGwgb2YgdGhvc2UgYXJlIGxpdGVyYWxzIGluc2lkZSBhIGNsYXNzLCBleGNlcHQgdGhhdFxuICAgICAgICAvLyB0aGUgZ2xvYiBbIWFdIG1lYW5zIFteYV0gaW4gcmVnZXhwXG4gICAgICAgIGlmIChpbkNsYXNzKSB7XG4gICAgICAgICAgdGhpcy5kZWJ1ZygnICBpbiBjbGFzcycpXG4gICAgICAgICAgaWYgKGMgPT09ICchJyAmJiBpID09PSBjbGFzc1N0YXJ0ICsgMSkgYyA9ICdeJ1xuICAgICAgICAgIHJlICs9IGNcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgd2UgYWxyZWFkeSBoYXZlIGEgc3RhdGVDaGFyLCB0aGVuIGl0IG1lYW5zXG4gICAgICAgIC8vIHRoYXQgdGhlcmUgd2FzIHNvbWV0aGluZyBsaWtlICoqIG9yICs/IGluIHRoZXJlLlxuICAgICAgICAvLyBIYW5kbGUgdGhlIHN0YXRlQ2hhciwgdGhlbiBwcm9jZWVkIHdpdGggdGhpcyBvbmUuXG4gICAgICAgIHNlbGYuZGVidWcoJ2NhbGwgY2xlYXJTdGF0ZUNoYXIgJWonLCBzdGF0ZUNoYXIpXG4gICAgICAgIGNsZWFyU3RhdGVDaGFyKClcbiAgICAgICAgc3RhdGVDaGFyID0gY1xuICAgICAgICAvLyBpZiBleHRnbG9iIGlzIGRpc2FibGVkLCB0aGVuICsoYXNkZnxmb28pIGlzbid0IGEgdGhpbmcuXG4gICAgICAgIC8vIGp1c3QgY2xlYXIgdGhlIHN0YXRlY2hhciAqbm93KiwgcmF0aGVyIHRoYW4gZXZlbiBkaXZpbmcgaW50b1xuICAgICAgICAvLyB0aGUgcGF0dGVybkxpc3Qgc3R1ZmYuXG4gICAgICAgIGlmIChvcHRpb25zLm5vZXh0KSBjbGVhclN0YXRlQ2hhcigpXG4gICAgICBjb250aW51ZVxuXG4gICAgICBjYXNlICcoJzpcbiAgICAgICAgaWYgKGluQ2xhc3MpIHtcbiAgICAgICAgICByZSArPSAnKCdcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFzdGF0ZUNoYXIpIHtcbiAgICAgICAgICByZSArPSAnXFxcXCgnXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIHBhdHRlcm5MaXN0U3RhY2sucHVzaCh7XG4gICAgICAgICAgdHlwZTogc3RhdGVDaGFyLFxuICAgICAgICAgIHN0YXJ0OiBpIC0gMSxcbiAgICAgICAgICByZVN0YXJ0OiByZS5sZW5ndGgsXG4gICAgICAgICAgb3BlbjogcGxUeXBlc1tzdGF0ZUNoYXJdLm9wZW4sXG4gICAgICAgICAgY2xvc2U6IHBsVHlwZXNbc3RhdGVDaGFyXS5jbG9zZVxuICAgICAgICB9KVxuICAgICAgICAvLyBuZWdhdGlvbiBpcyAoPzooPyFqcylbXi9dKilcbiAgICAgICAgcmUgKz0gc3RhdGVDaGFyID09PSAnIScgPyAnKD86KD8hKD86JyA6ICcoPzonXG4gICAgICAgIHRoaXMuZGVidWcoJ3BsVHlwZSAlaiAlaicsIHN0YXRlQ2hhciwgcmUpXG4gICAgICAgIHN0YXRlQ2hhciA9IGZhbHNlXG4gICAgICBjb250aW51ZVxuXG4gICAgICBjYXNlICcpJzpcbiAgICAgICAgaWYgKGluQ2xhc3MgfHwgIXBhdHRlcm5MaXN0U3RhY2subGVuZ3RoKSB7XG4gICAgICAgICAgcmUgKz0gJ1xcXFwpJ1xuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICBjbGVhclN0YXRlQ2hhcigpXG4gICAgICAgIGhhc01hZ2ljID0gdHJ1ZVxuICAgICAgICB2YXIgcGwgPSBwYXR0ZXJuTGlzdFN0YWNrLnBvcCgpXG4gICAgICAgIC8vIG5lZ2F0aW9uIGlzICg/Oig/IWpzKVteL10qKVxuICAgICAgICAvLyBUaGUgb3RoZXJzIGFyZSAoPzo8cGF0dGVybj4pPHR5cGU+XG4gICAgICAgIHJlICs9IHBsLmNsb3NlXG4gICAgICAgIGlmIChwbC50eXBlID09PSAnIScpIHtcbiAgICAgICAgICBuZWdhdGl2ZUxpc3RzLnB1c2gocGwpXG4gICAgICAgIH1cbiAgICAgICAgcGwucmVFbmQgPSByZS5sZW5ndGhcbiAgICAgIGNvbnRpbnVlXG5cbiAgICAgIGNhc2UgJ3wnOlxuICAgICAgICBpZiAoaW5DbGFzcyB8fCAhcGF0dGVybkxpc3RTdGFjay5sZW5ndGggfHwgZXNjYXBpbmcpIHtcbiAgICAgICAgICByZSArPSAnXFxcXHwnXG4gICAgICAgICAgZXNjYXBpbmcgPSBmYWxzZVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICBjbGVhclN0YXRlQ2hhcigpXG4gICAgICAgIHJlICs9ICd8J1xuICAgICAgY29udGludWVcblxuICAgICAgLy8gdGhlc2UgYXJlIG1vc3RseSB0aGUgc2FtZSBpbiByZWdleHAgYW5kIGdsb2JcbiAgICAgIGNhc2UgJ1snOlxuICAgICAgICAvLyBzd2FsbG93IGFueSBzdGF0ZS10cmFja2luZyBjaGFyIGJlZm9yZSB0aGUgW1xuICAgICAgICBjbGVhclN0YXRlQ2hhcigpXG5cbiAgICAgICAgaWYgKGluQ2xhc3MpIHtcbiAgICAgICAgICByZSArPSAnXFxcXCcgKyBjXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIGluQ2xhc3MgPSB0cnVlXG4gICAgICAgIGNsYXNzU3RhcnQgPSBpXG4gICAgICAgIHJlQ2xhc3NTdGFydCA9IHJlLmxlbmd0aFxuICAgICAgICByZSArPSBjXG4gICAgICBjb250aW51ZVxuXG4gICAgICBjYXNlICddJzpcbiAgICAgICAgLy8gIGEgcmlnaHQgYnJhY2tldCBzaGFsbCBsb3NlIGl0cyBzcGVjaWFsXG4gICAgICAgIC8vICBtZWFuaW5nIGFuZCByZXByZXNlbnQgaXRzZWxmIGluXG4gICAgICAgIC8vICBhIGJyYWNrZXQgZXhwcmVzc2lvbiBpZiBpdCBvY2N1cnNcbiAgICAgICAgLy8gIGZpcnN0IGluIHRoZSBsaXN0LiAgLS0gUE9TSVguMiAyLjguMy4yXG4gICAgICAgIGlmIChpID09PSBjbGFzc1N0YXJ0ICsgMSB8fCAhaW5DbGFzcykge1xuICAgICAgICAgIHJlICs9ICdcXFxcJyArIGNcbiAgICAgICAgICBlc2NhcGluZyA9IGZhbHNlXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGhhbmRsZSB0aGUgY2FzZSB3aGVyZSB3ZSBsZWZ0IGEgY2xhc3Mgb3Blbi5cbiAgICAgICAgLy8gXCJbei1hXVwiIGlzIHZhbGlkLCBlcXVpdmFsZW50IHRvIFwiXFxbei1hXFxdXCJcbiAgICAgICAgLy8gc3BsaXQgd2hlcmUgdGhlIGxhc3QgWyB3YXMsIG1ha2Ugc3VyZSB3ZSBkb24ndCBoYXZlXG4gICAgICAgIC8vIGFuIGludmFsaWQgcmUuIGlmIHNvLCByZS13YWxrIHRoZSBjb250ZW50cyBvZiB0aGVcbiAgICAgICAgLy8gd291bGQtYmUgY2xhc3MgdG8gcmUtdHJhbnNsYXRlIGFueSBjaGFyYWN0ZXJzIHRoYXRcbiAgICAgICAgLy8gd2VyZSBwYXNzZWQgdGhyb3VnaCBhcy1pc1xuICAgICAgICAvLyBUT0RPOiBJdCB3b3VsZCBwcm9iYWJseSBiZSBmYXN0ZXIgdG8gZGV0ZXJtaW5lIHRoaXNcbiAgICAgICAgLy8gd2l0aG91dCBhIHRyeS9jYXRjaCBhbmQgYSBuZXcgUmVnRXhwLCBidXQgaXQncyB0cmlja3lcbiAgICAgICAgLy8gdG8gZG8gc2FmZWx5LiAgRm9yIG5vdywgdGhpcyBpcyBzYWZlIGFuZCB3b3Jrcy5cbiAgICAgICAgdmFyIGNzID0gcGF0dGVybi5zdWJzdHJpbmcoY2xhc3NTdGFydCArIDEsIGkpXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgUmVnRXhwKCdbJyArIGNzICsgJ10nKVxuICAgICAgICB9IGNhdGNoIChlcikge1xuICAgICAgICAgIC8vIG5vdCBhIHZhbGlkIGNsYXNzIVxuICAgICAgICAgIHZhciBzcCA9IHRoaXMucGFyc2UoY3MsIFNVQlBBUlNFKVxuICAgICAgICAgIHJlID0gcmUuc3Vic3RyKDAsIHJlQ2xhc3NTdGFydCkgKyAnXFxcXFsnICsgc3BbMF0gKyAnXFxcXF0nXG4gICAgICAgICAgaGFzTWFnaWMgPSBoYXNNYWdpYyB8fCBzcFsxXVxuICAgICAgICAgIGluQ2xhc3MgPSBmYWxzZVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyBmaW5pc2ggdXAgdGhlIGNsYXNzLlxuICAgICAgICBoYXNNYWdpYyA9IHRydWVcbiAgICAgICAgaW5DbGFzcyA9IGZhbHNlXG4gICAgICAgIHJlICs9IGNcbiAgICAgIGNvbnRpbnVlXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIC8vIHN3YWxsb3cgYW55IHN0YXRlIGNoYXIgdGhhdCB3YXNuJ3QgY29uc3VtZWRcbiAgICAgICAgY2xlYXJTdGF0ZUNoYXIoKVxuXG4gICAgICAgIGlmIChlc2NhcGluZykge1xuICAgICAgICAgIC8vIG5vIG5lZWRcbiAgICAgICAgICBlc2NhcGluZyA9IGZhbHNlXG4gICAgICAgIH0gZWxzZSBpZiAocmVTcGVjaWFsc1tjXVxuICAgICAgICAgICYmICEoYyA9PT0gJ14nICYmIGluQ2xhc3MpKSB7XG4gICAgICAgICAgcmUgKz0gJ1xcXFwnXG4gICAgICAgIH1cblxuICAgICAgICByZSArPSBjXG5cbiAgICB9IC8vIHN3aXRjaFxuICB9IC8vIGZvclxuXG4gIC8vIGhhbmRsZSB0aGUgY2FzZSB3aGVyZSB3ZSBsZWZ0IGEgY2xhc3Mgb3Blbi5cbiAgLy8gXCJbYWJjXCIgaXMgdmFsaWQsIGVxdWl2YWxlbnQgdG8gXCJcXFthYmNcIlxuICBpZiAoaW5DbGFzcykge1xuICAgIC8vIHNwbGl0IHdoZXJlIHRoZSBsYXN0IFsgd2FzLCBhbmQgZXNjYXBlIGl0XG4gICAgLy8gdGhpcyBpcyBhIGh1Z2UgcGl0YS4gIFdlIG5vdyBoYXZlIHRvIHJlLXdhbGtcbiAgICAvLyB0aGUgY29udGVudHMgb2YgdGhlIHdvdWxkLWJlIGNsYXNzIHRvIHJlLXRyYW5zbGF0ZVxuICAgIC8vIGFueSBjaGFyYWN0ZXJzIHRoYXQgd2VyZSBwYXNzZWQgdGhyb3VnaCBhcy1pc1xuICAgIGNzID0gcGF0dGVybi5zdWJzdHIoY2xhc3NTdGFydCArIDEpXG4gICAgc3AgPSB0aGlzLnBhcnNlKGNzLCBTVUJQQVJTRSlcbiAgICByZSA9IHJlLnN1YnN0cigwLCByZUNsYXNzU3RhcnQpICsgJ1xcXFxbJyArIHNwWzBdXG4gICAgaGFzTWFnaWMgPSBoYXNNYWdpYyB8fCBzcFsxXVxuICB9XG5cbiAgLy8gaGFuZGxlIHRoZSBjYXNlIHdoZXJlIHdlIGhhZCBhICsoIHRoaW5nIGF0IHRoZSAqZW5kKlxuICAvLyBvZiB0aGUgcGF0dGVybi5cbiAgLy8gZWFjaCBwYXR0ZXJuIGxpc3Qgc3RhY2sgYWRkcyAzIGNoYXJzLCBhbmQgd2UgbmVlZCB0byBnbyB0aHJvdWdoXG4gIC8vIGFuZCBlc2NhcGUgYW55IHwgY2hhcnMgdGhhdCB3ZXJlIHBhc3NlZCB0aHJvdWdoIGFzLWlzIGZvciB0aGUgcmVnZXhwLlxuICAvLyBHbyB0aHJvdWdoIGFuZCBlc2NhcGUgdGhlbSwgdGFraW5nIGNhcmUgbm90IHRvIGRvdWJsZS1lc2NhcGUgYW55XG4gIC8vIHwgY2hhcnMgdGhhdCB3ZXJlIGFscmVhZHkgZXNjYXBlZC5cbiAgZm9yIChwbCA9IHBhdHRlcm5MaXN0U3RhY2sucG9wKCk7IHBsOyBwbCA9IHBhdHRlcm5MaXN0U3RhY2sucG9wKCkpIHtcbiAgICB2YXIgdGFpbCA9IHJlLnNsaWNlKHBsLnJlU3RhcnQgKyBwbC5vcGVuLmxlbmd0aClcbiAgICB0aGlzLmRlYnVnKCdzZXR0aW5nIHRhaWwnLCByZSwgcGwpXG4gICAgLy8gbWF5YmUgc29tZSBldmVuIG51bWJlciBvZiBcXCwgdGhlbiBtYXliZSAxIFxcLCBmb2xsb3dlZCBieSBhIHxcbiAgICB0YWlsID0gdGFpbC5yZXBsYWNlKC8oKD86XFxcXHsyfSl7MCw2NH0pKFxcXFw/KVxcfC9nLCBmdW5jdGlvbiAoXywgJDEsICQyKSB7XG4gICAgICBpZiAoISQyKSB7XG4gICAgICAgIC8vIHRoZSB8IGlzbid0IGFscmVhZHkgZXNjYXBlZCwgc28gZXNjYXBlIGl0LlxuICAgICAgICAkMiA9ICdcXFxcJ1xuICAgICAgfVxuXG4gICAgICAvLyBuZWVkIHRvIGVzY2FwZSBhbGwgdGhvc2Ugc2xhc2hlcyAqYWdhaW4qLCB3aXRob3V0IGVzY2FwaW5nIHRoZVxuICAgICAgLy8gb25lIHRoYXQgd2UgbmVlZCBmb3IgZXNjYXBpbmcgdGhlIHwgY2hhcmFjdGVyLiAgQXMgaXQgd29ya3Mgb3V0LFxuICAgICAgLy8gZXNjYXBpbmcgYW4gZXZlbiBudW1iZXIgb2Ygc2xhc2hlcyBjYW4gYmUgZG9uZSBieSBzaW1wbHkgcmVwZWF0aW5nXG4gICAgICAvLyBpdCBleGFjdGx5IGFmdGVyIGl0c2VsZi4gIFRoYXQncyB3aHkgdGhpcyB0cmljayB3b3Jrcy5cbiAgICAgIC8vXG4gICAgICAvLyBJIGFtIHNvcnJ5IHRoYXQgeW91IGhhdmUgdG8gc2VlIHRoaXMuXG4gICAgICByZXR1cm4gJDEgKyAkMSArICQyICsgJ3wnXG4gICAgfSlcblxuICAgIHRoaXMuZGVidWcoJ3RhaWw9JWpcXG4gICAlcycsIHRhaWwsIHRhaWwsIHBsLCByZSlcbiAgICB2YXIgdCA9IHBsLnR5cGUgPT09ICcqJyA/IHN0YXJcbiAgICAgIDogcGwudHlwZSA9PT0gJz8nID8gcW1hcmtcbiAgICAgIDogJ1xcXFwnICsgcGwudHlwZVxuXG4gICAgaGFzTWFnaWMgPSB0cnVlXG4gICAgcmUgPSByZS5zbGljZSgwLCBwbC5yZVN0YXJ0KSArIHQgKyAnXFxcXCgnICsgdGFpbFxuICB9XG5cbiAgLy8gaGFuZGxlIHRyYWlsaW5nIHRoaW5ncyB0aGF0IG9ubHkgbWF0dGVyIGF0IHRoZSB2ZXJ5IGVuZC5cbiAgY2xlYXJTdGF0ZUNoYXIoKVxuICBpZiAoZXNjYXBpbmcpIHtcbiAgICAvLyB0cmFpbGluZyBcXFxcXG4gICAgcmUgKz0gJ1xcXFxcXFxcJ1xuICB9XG5cbiAgLy8gb25seSBuZWVkIHRvIGFwcGx5IHRoZSBub2RvdCBzdGFydCBpZiB0aGUgcmUgc3RhcnRzIHdpdGhcbiAgLy8gc29tZXRoaW5nIHRoYXQgY291bGQgY29uY2VpdmFibHkgY2FwdHVyZSBhIGRvdFxuICB2YXIgYWRkUGF0dGVyblN0YXJ0ID0gZmFsc2VcbiAgc3dpdGNoIChyZS5jaGFyQXQoMCkpIHtcbiAgICBjYXNlICdbJzogY2FzZSAnLic6IGNhc2UgJygnOiBhZGRQYXR0ZXJuU3RhcnQgPSB0cnVlXG4gIH1cblxuICAvLyBIYWNrIHRvIHdvcmsgYXJvdW5kIGxhY2sgb2YgbmVnYXRpdmUgbG9va2JlaGluZCBpbiBKU1xuICAvLyBBIHBhdHRlcm4gbGlrZTogKi4hKHgpLiEoeXx6KSBuZWVkcyB0byBlbnN1cmUgdGhhdCBhIG5hbWVcbiAgLy8gbGlrZSAnYS54eXoueXonIGRvZXNuJ3QgbWF0Y2guICBTbywgdGhlIGZpcnN0IG5lZ2F0aXZlXG4gIC8vIGxvb2thaGVhZCwgaGFzIHRvIGxvb2sgQUxMIHRoZSB3YXkgYWhlYWQsIHRvIHRoZSBlbmQgb2ZcbiAgLy8gdGhlIHBhdHRlcm4uXG4gIGZvciAodmFyIG4gPSBuZWdhdGl2ZUxpc3RzLmxlbmd0aCAtIDE7IG4gPiAtMTsgbi0tKSB7XG4gICAgdmFyIG5sID0gbmVnYXRpdmVMaXN0c1tuXVxuXG4gICAgdmFyIG5sQmVmb3JlID0gcmUuc2xpY2UoMCwgbmwucmVTdGFydClcbiAgICB2YXIgbmxGaXJzdCA9IHJlLnNsaWNlKG5sLnJlU3RhcnQsIG5sLnJlRW5kIC0gOClcbiAgICB2YXIgbmxMYXN0ID0gcmUuc2xpY2UobmwucmVFbmQgLSA4LCBubC5yZUVuZClcbiAgICB2YXIgbmxBZnRlciA9IHJlLnNsaWNlKG5sLnJlRW5kKVxuXG4gICAgbmxMYXN0ICs9IG5sQWZ0ZXJcblxuICAgIC8vIEhhbmRsZSBuZXN0ZWQgc3R1ZmYgbGlrZSAqKCouanN8ISgqLmpzb24pKSwgd2hlcmUgb3BlbiBwYXJlbnNcbiAgICAvLyBtZWFuIHRoYXQgd2Ugc2hvdWxkICpub3QqIGluY2x1ZGUgdGhlICkgaW4gdGhlIGJpdCB0aGF0IGlzIGNvbnNpZGVyZWRcbiAgICAvLyBcImFmdGVyXCIgdGhlIG5lZ2F0ZWQgc2VjdGlvbi5cbiAgICB2YXIgb3BlblBhcmVuc0JlZm9yZSA9IG5sQmVmb3JlLnNwbGl0KCcoJykubGVuZ3RoIC0gMVxuICAgIHZhciBjbGVhbkFmdGVyID0gbmxBZnRlclxuICAgIGZvciAoaSA9IDA7IGkgPCBvcGVuUGFyZW5zQmVmb3JlOyBpKyspIHtcbiAgICAgIGNsZWFuQWZ0ZXIgPSBjbGVhbkFmdGVyLnJlcGxhY2UoL1xcKVsrKj9dPy8sICcnKVxuICAgIH1cbiAgICBubEFmdGVyID0gY2xlYW5BZnRlclxuXG4gICAgdmFyIGRvbGxhciA9ICcnXG4gICAgaWYgKG5sQWZ0ZXIgPT09ICcnICYmIGlzU3ViICE9PSBTVUJQQVJTRSkge1xuICAgICAgZG9sbGFyID0gJyQnXG4gICAgfVxuICAgIHZhciBuZXdSZSA9IG5sQmVmb3JlICsgbmxGaXJzdCArIG5sQWZ0ZXIgKyBkb2xsYXIgKyBubExhc3RcbiAgICByZSA9IG5ld1JlXG4gIH1cblxuICAvLyBpZiB0aGUgcmUgaXMgbm90IFwiXCIgYXQgdGhpcyBwb2ludCwgdGhlbiB3ZSBuZWVkIHRvIG1ha2Ugc3VyZVxuICAvLyBpdCBkb2Vzbid0IG1hdGNoIGFnYWluc3QgYW4gZW1wdHkgcGF0aCBwYXJ0LlxuICAvLyBPdGhlcndpc2UgYS8qIHdpbGwgbWF0Y2ggYS8sIHdoaWNoIGl0IHNob3VsZCBub3QuXG4gIGlmIChyZSAhPT0gJycgJiYgaGFzTWFnaWMpIHtcbiAgICByZSA9ICcoPz0uKScgKyByZVxuICB9XG5cbiAgaWYgKGFkZFBhdHRlcm5TdGFydCkge1xuICAgIHJlID0gcGF0dGVyblN0YXJ0ICsgcmVcbiAgfVxuXG4gIC8vIHBhcnNpbmcganVzdCBhIHBpZWNlIG9mIGEgbGFyZ2VyIHBhdHRlcm4uXG4gIGlmIChpc1N1YiA9PT0gU1VCUEFSU0UpIHtcbiAgICByZXR1cm4gW3JlLCBoYXNNYWdpY11cbiAgfVxuXG4gIC8vIHNraXAgdGhlIHJlZ2V4cCBmb3Igbm9uLW1hZ2ljYWwgcGF0dGVybnNcbiAgLy8gdW5lc2NhcGUgYW55dGhpbmcgaW4gaXQsIHRob3VnaCwgc28gdGhhdCBpdCdsbCBiZVxuICAvLyBhbiBleGFjdCBtYXRjaCBhZ2FpbnN0IGEgZmlsZSBldGMuXG4gIGlmICghaGFzTWFnaWMpIHtcbiAgICByZXR1cm4gZ2xvYlVuZXNjYXBlKHBhdHRlcm4pXG4gIH1cblxuICB2YXIgZmxhZ3MgPSBvcHRpb25zLm5vY2FzZSA/ICdpJyA6ICcnXG4gIHRyeSB7XG4gICAgdmFyIHJlZ0V4cCA9IG5ldyBSZWdFeHAoJ14nICsgcmUgKyAnJCcsIGZsYWdzKVxuICB9IGNhdGNoIChlcikgLyogaXN0YW5idWwgaWdub3JlIG5leHQgLSBzaG91bGQgYmUgaW1wb3NzaWJsZSAqLyB7XG4gICAgLy8gSWYgaXQgd2FzIGFuIGludmFsaWQgcmVndWxhciBleHByZXNzaW9uLCB0aGVuIGl0IGNhbid0IG1hdGNoXG4gICAgLy8gYW55dGhpbmcuICBUaGlzIHRyaWNrIGxvb2tzIGZvciBhIGNoYXJhY3RlciBhZnRlciB0aGUgZW5kIG9mXG4gICAgLy8gdGhlIHN0cmluZywgd2hpY2ggaXMgb2YgY291cnNlIGltcG9zc2libGUsIGV4Y2VwdCBpbiBtdWx0aS1saW5lXG4gICAgLy8gbW9kZSwgYnV0IGl0J3Mgbm90IGEgL20gcmVnZXguXG4gICAgcmV0dXJuIG5ldyBSZWdFeHAoJyQuJylcbiAgfVxuXG4gIHJlZ0V4cC5fZ2xvYiA9IHBhdHRlcm5cbiAgcmVnRXhwLl9zcmMgPSByZVxuXG4gIHJldHVybiByZWdFeHBcbn1cblxubWluaW1hdGNoLm1ha2VSZSA9IGZ1bmN0aW9uIChwYXR0ZXJuLCBvcHRpb25zKSB7XG4gIHJldHVybiBuZXcgTWluaW1hdGNoKHBhdHRlcm4sIG9wdGlvbnMgfHwge30pLm1ha2VSZSgpXG59XG5cbk1pbmltYXRjaC5wcm90b3R5cGUubWFrZVJlID0gbWFrZVJlXG5mdW5jdGlvbiBtYWtlUmUgKCkge1xuICBpZiAodGhpcy5yZWdleHAgfHwgdGhpcy5yZWdleHAgPT09IGZhbHNlKSByZXR1cm4gdGhpcy5yZWdleHBcblxuICAvLyBhdCB0aGlzIHBvaW50LCB0aGlzLnNldCBpcyBhIDJkIGFycmF5IG9mIHBhcnRpYWxcbiAgLy8gcGF0dGVybiBzdHJpbmdzLCBvciBcIioqXCIuXG4gIC8vXG4gIC8vIEl0J3MgYmV0dGVyIHRvIHVzZSAubWF0Y2goKS4gIFRoaXMgZnVuY3Rpb24gc2hvdWxkbid0XG4gIC8vIGJlIHVzZWQsIHJlYWxseSwgYnV0IGl0J3MgcHJldHR5IGNvbnZlbmllbnQgc29tZXRpbWVzLFxuICAvLyB3aGVuIHlvdSBqdXN0IHdhbnQgdG8gd29yayB3aXRoIGEgcmVnZXguXG4gIHZhciBzZXQgPSB0aGlzLnNldFxuXG4gIGlmICghc2V0Lmxlbmd0aCkge1xuICAgIHRoaXMucmVnZXhwID0gZmFsc2VcbiAgICByZXR1cm4gdGhpcy5yZWdleHBcbiAgfVxuICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9uc1xuXG4gIHZhciB0d29TdGFyID0gb3B0aW9ucy5ub2dsb2JzdGFyID8gc3RhclxuICAgIDogb3B0aW9ucy5kb3QgPyB0d29TdGFyRG90XG4gICAgOiB0d29TdGFyTm9Eb3RcbiAgdmFyIGZsYWdzID0gb3B0aW9ucy5ub2Nhc2UgPyAnaScgOiAnJ1xuXG4gIHZhciByZSA9IHNldC5tYXAoZnVuY3Rpb24gKHBhdHRlcm4pIHtcbiAgICByZXR1cm4gcGF0dGVybi5tYXAoZnVuY3Rpb24gKHApIHtcbiAgICAgIHJldHVybiAocCA9PT0gR0xPQlNUQVIpID8gdHdvU3RhclxuICAgICAgOiAodHlwZW9mIHAgPT09ICdzdHJpbmcnKSA/IHJlZ0V4cEVzY2FwZShwKVxuICAgICAgOiBwLl9zcmNcbiAgICB9KS5qb2luKCdcXFxcXFwvJylcbiAgfSkuam9pbignfCcpXG5cbiAgLy8gbXVzdCBtYXRjaCBlbnRpcmUgcGF0dGVyblxuICAvLyBlbmRpbmcgaW4gYSAqIG9yICoqIHdpbGwgbWFrZSBpdCBsZXNzIHN0cmljdC5cbiAgcmUgPSAnXig/OicgKyByZSArICcpJCdcblxuICAvLyBjYW4gbWF0Y2ggYW55dGhpbmcsIGFzIGxvbmcgYXMgaXQncyBub3QgdGhpcy5cbiAgaWYgKHRoaXMubmVnYXRlKSByZSA9ICdeKD8hJyArIHJlICsgJykuKiQnXG5cbiAgdHJ5IHtcbiAgICB0aGlzLnJlZ2V4cCA9IG5ldyBSZWdFeHAocmUsIGZsYWdzKVxuICB9IGNhdGNoIChleCkgLyogaXN0YW5idWwgaWdub3JlIG5leHQgLSBzaG91bGQgYmUgaW1wb3NzaWJsZSAqLyB7XG4gICAgdGhpcy5yZWdleHAgPSBmYWxzZVxuICB9XG4gIHJldHVybiB0aGlzLnJlZ2V4cFxufVxuXG5taW5pbWF0Y2gubWF0Y2ggPSBmdW5jdGlvbiAobGlzdCwgcGF0dGVybiwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fVxuICB2YXIgbW0gPSBuZXcgTWluaW1hdGNoKHBhdHRlcm4sIG9wdGlvbnMpXG4gIGxpc3QgPSBsaXN0LmZpbHRlcihmdW5jdGlvbiAoZikge1xuICAgIHJldHVybiBtbS5tYXRjaChmKVxuICB9KVxuICBpZiAobW0ub3B0aW9ucy5ub251bGwgJiYgIWxpc3QubGVuZ3RoKSB7XG4gICAgbGlzdC5wdXNoKHBhdHRlcm4pXG4gIH1cbiAgcmV0dXJuIGxpc3Rcbn1cblxuTWluaW1hdGNoLnByb3RvdHlwZS5tYXRjaCA9IGZ1bmN0aW9uIG1hdGNoIChmLCBwYXJ0aWFsKSB7XG4gIGlmICh0eXBlb2YgcGFydGlhbCA9PT0gJ3VuZGVmaW5lZCcpIHBhcnRpYWwgPSB0aGlzLnBhcnRpYWxcbiAgdGhpcy5kZWJ1ZygnbWF0Y2gnLCBmLCB0aGlzLnBhdHRlcm4pXG4gIC8vIHNob3J0LWNpcmN1aXQgaW4gdGhlIGNhc2Ugb2YgYnVzdGVkIHRoaW5ncy5cbiAgLy8gY29tbWVudHMsIGV0Yy5cbiAgaWYgKHRoaXMuY29tbWVudCkgcmV0dXJuIGZhbHNlXG4gIGlmICh0aGlzLmVtcHR5KSByZXR1cm4gZiA9PT0gJydcblxuICBpZiAoZiA9PT0gJy8nICYmIHBhcnRpYWwpIHJldHVybiB0cnVlXG5cbiAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnNcblxuICAvLyB3aW5kb3dzOiBuZWVkIHRvIHVzZSAvLCBub3QgXFxcbiAgaWYgKHBhdGguc2VwICE9PSAnLycpIHtcbiAgICBmID0gZi5zcGxpdChwYXRoLnNlcCkuam9pbignLycpXG4gIH1cblxuICAvLyB0cmVhdCB0aGUgdGVzdCBwYXRoIGFzIGEgc2V0IG9mIHBhdGhwYXJ0cy5cbiAgZiA9IGYuc3BsaXQoc2xhc2hTcGxpdClcbiAgdGhpcy5kZWJ1Zyh0aGlzLnBhdHRlcm4sICdzcGxpdCcsIGYpXG5cbiAgLy8ganVzdCBPTkUgb2YgdGhlIHBhdHRlcm4gc2V0cyBpbiB0aGlzLnNldCBuZWVkcyB0byBtYXRjaFxuICAvLyBpbiBvcmRlciBmb3IgaXQgdG8gYmUgdmFsaWQuICBJZiBuZWdhdGluZywgdGhlbiBqdXN0IG9uZVxuICAvLyBtYXRjaCBtZWFucyB0aGF0IHdlIGhhdmUgZmFpbGVkLlxuICAvLyBFaXRoZXIgd2F5LCByZXR1cm4gb24gdGhlIGZpcnN0IGhpdC5cblxuICB2YXIgc2V0ID0gdGhpcy5zZXRcbiAgdGhpcy5kZWJ1Zyh0aGlzLnBhdHRlcm4sICdzZXQnLCBzZXQpXG5cbiAgLy8gRmluZCB0aGUgYmFzZW5hbWUgb2YgdGhlIHBhdGggYnkgbG9va2luZyBmb3IgdGhlIGxhc3Qgbm9uLWVtcHR5IHNlZ21lbnRcbiAgdmFyIGZpbGVuYW1lXG4gIHZhciBpXG4gIGZvciAoaSA9IGYubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBmaWxlbmFtZSA9IGZbaV1cbiAgICBpZiAoZmlsZW5hbWUpIGJyZWFrXG4gIH1cblxuICBmb3IgKGkgPSAwOyBpIDwgc2V0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHBhdHRlcm4gPSBzZXRbaV1cbiAgICB2YXIgZmlsZSA9IGZcbiAgICBpZiAob3B0aW9ucy5tYXRjaEJhc2UgJiYgcGF0dGVybi5sZW5ndGggPT09IDEpIHtcbiAgICAgIGZpbGUgPSBbZmlsZW5hbWVdXG4gICAgfVxuICAgIHZhciBoaXQgPSB0aGlzLm1hdGNoT25lKGZpbGUsIHBhdHRlcm4sIHBhcnRpYWwpXG4gICAgaWYgKGhpdCkge1xuICAgICAgaWYgKG9wdGlvbnMuZmxpcE5lZ2F0ZSkgcmV0dXJuIHRydWVcbiAgICAgIHJldHVybiAhdGhpcy5uZWdhdGVcbiAgICB9XG4gIH1cblxuICAvLyBkaWRuJ3QgZ2V0IGFueSBoaXRzLiAgdGhpcyBpcyBzdWNjZXNzIGlmIGl0J3MgYSBuZWdhdGl2ZVxuICAvLyBwYXR0ZXJuLCBmYWlsdXJlIG90aGVyd2lzZS5cbiAgaWYgKG9wdGlvbnMuZmxpcE5lZ2F0ZSkgcmV0dXJuIGZhbHNlXG4gIHJldHVybiB0aGlzLm5lZ2F0ZVxufVxuXG4vLyBzZXQgcGFydGlhbCB0byB0cnVlIHRvIHRlc3QgaWYsIGZvciBleGFtcGxlLFxuLy8gXCIvYS9iXCIgbWF0Y2hlcyB0aGUgc3RhcnQgb2YgXCIvKi9iLyovZFwiXG4vLyBQYXJ0aWFsIG1lYW5zLCBpZiB5b3UgcnVuIG91dCBvZiBmaWxlIGJlZm9yZSB5b3UgcnVuXG4vLyBvdXQgb2YgcGF0dGVybiwgdGhlbiB0aGF0J3MgZmluZSwgYXMgbG9uZyBhcyBhbGxcbi8vIHRoZSBwYXJ0cyBtYXRjaC5cbk1pbmltYXRjaC5wcm90b3R5cGUubWF0Y2hPbmUgPSBmdW5jdGlvbiAoZmlsZSwgcGF0dGVybiwgcGFydGlhbCkge1xuICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9uc1xuXG4gIHRoaXMuZGVidWcoJ21hdGNoT25lJyxcbiAgICB7ICd0aGlzJzogdGhpcywgZmlsZTogZmlsZSwgcGF0dGVybjogcGF0dGVybiB9KVxuXG4gIHRoaXMuZGVidWcoJ21hdGNoT25lJywgZmlsZS5sZW5ndGgsIHBhdHRlcm4ubGVuZ3RoKVxuXG4gIGZvciAodmFyIGZpID0gMCxcbiAgICAgIHBpID0gMCxcbiAgICAgIGZsID0gZmlsZS5sZW5ndGgsXG4gICAgICBwbCA9IHBhdHRlcm4ubGVuZ3RoXG4gICAgICA7IChmaSA8IGZsKSAmJiAocGkgPCBwbClcbiAgICAgIDsgZmkrKywgcGkrKykge1xuICAgIHRoaXMuZGVidWcoJ21hdGNoT25lIGxvb3AnKVxuICAgIHZhciBwID0gcGF0dGVybltwaV1cbiAgICB2YXIgZiA9IGZpbGVbZmldXG5cbiAgICB0aGlzLmRlYnVnKHBhdHRlcm4sIHAsIGYpXG5cbiAgICAvLyBzaG91bGQgYmUgaW1wb3NzaWJsZS5cbiAgICAvLyBzb21lIGludmFsaWQgcmVnZXhwIHN0dWZmIGluIHRoZSBzZXQuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHAgPT09IGZhbHNlKSByZXR1cm4gZmFsc2VcblxuICAgIGlmIChwID09PSBHTE9CU1RBUikge1xuICAgICAgdGhpcy5kZWJ1ZygnR0xPQlNUQVInLCBbcGF0dGVybiwgcCwgZl0pXG5cbiAgICAgIC8vIFwiKipcIlxuICAgICAgLy8gYS8qKi9iLyoqL2Mgd291bGQgbWF0Y2ggdGhlIGZvbGxvd2luZzpcbiAgICAgIC8vIGEvYi94L3kvei9jXG4gICAgICAvLyBhL3gveS96L2IvY1xuICAgICAgLy8gYS9iL3gvYi94L2NcbiAgICAgIC8vIGEvYi9jXG4gICAgICAvLyBUbyBkbyB0aGlzLCB0YWtlIHRoZSByZXN0IG9mIHRoZSBwYXR0ZXJuIGFmdGVyXG4gICAgICAvLyB0aGUgKiosIGFuZCBzZWUgaWYgaXQgd291bGQgbWF0Y2ggdGhlIGZpbGUgcmVtYWluZGVyLlxuICAgICAgLy8gSWYgc28sIHJldHVybiBzdWNjZXNzLlxuICAgICAgLy8gSWYgbm90LCB0aGUgKiogXCJzd2FsbG93c1wiIGEgc2VnbWVudCwgYW5kIHRyeSBhZ2Fpbi5cbiAgICAgIC8vIFRoaXMgaXMgcmVjdXJzaXZlbHkgYXdmdWwuXG4gICAgICAvL1xuICAgICAgLy8gYS8qKi9iLyoqL2MgbWF0Y2hpbmcgYS9iL3gveS96L2NcbiAgICAgIC8vIC0gYSBtYXRjaGVzIGFcbiAgICAgIC8vIC0gZG91Ymxlc3RhclxuICAgICAgLy8gICAtIG1hdGNoT25lKGIveC95L3ovYywgYi8qKi9jKVxuICAgICAgLy8gICAgIC0gYiBtYXRjaGVzIGJcbiAgICAgIC8vICAgICAtIGRvdWJsZXN0YXJcbiAgICAgIC8vICAgICAgIC0gbWF0Y2hPbmUoeC95L3ovYywgYykgLT4gbm9cbiAgICAgIC8vICAgICAgIC0gbWF0Y2hPbmUoeS96L2MsIGMpIC0+IG5vXG4gICAgICAvLyAgICAgICAtIG1hdGNoT25lKHovYywgYykgLT4gbm9cbiAgICAgIC8vICAgICAgIC0gbWF0Y2hPbmUoYywgYykgeWVzLCBoaXRcbiAgICAgIHZhciBmciA9IGZpXG4gICAgICB2YXIgcHIgPSBwaSArIDFcbiAgICAgIGlmIChwciA9PT0gcGwpIHtcbiAgICAgICAgdGhpcy5kZWJ1ZygnKiogYXQgdGhlIGVuZCcpXG4gICAgICAgIC8vIGEgKiogYXQgdGhlIGVuZCB3aWxsIGp1c3Qgc3dhbGxvdyB0aGUgcmVzdC5cbiAgICAgICAgLy8gV2UgaGF2ZSBmb3VuZCBhIG1hdGNoLlxuICAgICAgICAvLyBob3dldmVyLCBpdCB3aWxsIG5vdCBzd2FsbG93IC8ueCwgdW5sZXNzXG4gICAgICAgIC8vIG9wdGlvbnMuZG90IGlzIHNldC5cbiAgICAgICAgLy8gLiBhbmQgLi4gYXJlICpuZXZlciogbWF0Y2hlZCBieSAqKiwgZm9yIGV4cGxvc2l2ZWx5XG4gICAgICAgIC8vIGV4cG9uZW50aWFsIHJlYXNvbnMuXG4gICAgICAgIGZvciAoOyBmaSA8IGZsOyBmaSsrKSB7XG4gICAgICAgICAgaWYgKGZpbGVbZmldID09PSAnLicgfHwgZmlsZVtmaV0gPT09ICcuLicgfHxcbiAgICAgICAgICAgICghb3B0aW9ucy5kb3QgJiYgZmlsZVtmaV0uY2hhckF0KDApID09PSAnLicpKSByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuXG4gICAgICAvLyBvaywgbGV0J3Mgc2VlIGlmIHdlIGNhbiBzd2FsbG93IHdoYXRldmVyIHdlIGNhbi5cbiAgICAgIHdoaWxlIChmciA8IGZsKSB7XG4gICAgICAgIHZhciBzd2FsbG93ZWUgPSBmaWxlW2ZyXVxuXG4gICAgICAgIHRoaXMuZGVidWcoJ1xcbmdsb2JzdGFyIHdoaWxlJywgZmlsZSwgZnIsIHBhdHRlcm4sIHByLCBzd2FsbG93ZWUpXG5cbiAgICAgICAgLy8gWFhYIHJlbW92ZSB0aGlzIHNsaWNlLiAgSnVzdCBwYXNzIHRoZSBzdGFydCBpbmRleC5cbiAgICAgICAgaWYgKHRoaXMubWF0Y2hPbmUoZmlsZS5zbGljZShmciksIHBhdHRlcm4uc2xpY2UocHIpLCBwYXJ0aWFsKSkge1xuICAgICAgICAgIHRoaXMuZGVidWcoJ2dsb2JzdGFyIGZvdW5kIG1hdGNoIScsIGZyLCBmbCwgc3dhbGxvd2VlKVxuICAgICAgICAgIC8vIGZvdW5kIGEgbWF0Y2guXG4gICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBjYW4ndCBzd2FsbG93IFwiLlwiIG9yIFwiLi5cIiBldmVyLlxuICAgICAgICAgIC8vIGNhbiBvbmx5IHN3YWxsb3cgXCIuZm9vXCIgd2hlbiBleHBsaWNpdGx5IGFza2VkLlxuICAgICAgICAgIGlmIChzd2FsbG93ZWUgPT09ICcuJyB8fCBzd2FsbG93ZWUgPT09ICcuLicgfHxcbiAgICAgICAgICAgICghb3B0aW9ucy5kb3QgJiYgc3dhbGxvd2VlLmNoYXJBdCgwKSA9PT0gJy4nKSkge1xuICAgICAgICAgICAgdGhpcy5kZWJ1ZygnZG90IGRldGVjdGVkIScsIGZpbGUsIGZyLCBwYXR0ZXJuLCBwcilcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gKiogc3dhbGxvd3MgYSBzZWdtZW50LCBhbmQgY29udGludWUuXG4gICAgICAgICAgdGhpcy5kZWJ1ZygnZ2xvYnN0YXIgc3dhbGxvdyBhIHNlZ21lbnQsIGFuZCBjb250aW51ZScpXG4gICAgICAgICAgZnIrK1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIG5vIG1hdGNoIHdhcyBmb3VuZC5cbiAgICAgIC8vIEhvd2V2ZXIsIGluIHBhcnRpYWwgbW9kZSwgd2UgY2FuJ3Qgc2F5IHRoaXMgaXMgbmVjZXNzYXJpbHkgb3Zlci5cbiAgICAgIC8vIElmIHRoZXJlJ3MgbW9yZSAqcGF0dGVybiogbGVmdCwgdGhlblxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAocGFydGlhbCkge1xuICAgICAgICAvLyByYW4gb3V0IG9mIGZpbGVcbiAgICAgICAgdGhpcy5kZWJ1ZygnXFxuPj4+IG5vIG1hdGNoLCBwYXJ0aWFsPycsIGZpbGUsIGZyLCBwYXR0ZXJuLCBwcilcbiAgICAgICAgaWYgKGZyID09PSBmbCkgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIC8vIHNvbWV0aGluZyBvdGhlciB0aGFuICoqXG4gICAgLy8gbm9uLW1hZ2ljIHBhdHRlcm5zIGp1c3QgaGF2ZSB0byBtYXRjaCBleGFjdGx5XG4gICAgLy8gcGF0dGVybnMgd2l0aCBtYWdpYyBoYXZlIGJlZW4gdHVybmVkIGludG8gcmVnZXhwcy5cbiAgICB2YXIgaGl0XG4gICAgaWYgKHR5cGVvZiBwID09PSAnc3RyaW5nJykge1xuICAgICAgaGl0ID0gZiA9PT0gcFxuICAgICAgdGhpcy5kZWJ1Zygnc3RyaW5nIG1hdGNoJywgcCwgZiwgaGl0KVxuICAgIH0gZWxzZSB7XG4gICAgICBoaXQgPSBmLm1hdGNoKHApXG4gICAgICB0aGlzLmRlYnVnKCdwYXR0ZXJuIG1hdGNoJywgcCwgZiwgaGl0KVxuICAgIH1cblxuICAgIGlmICghaGl0KSByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIC8vIE5vdGU6IGVuZGluZyBpbiAvIG1lYW5zIHRoYXQgd2UnbGwgZ2V0IGEgZmluYWwgXCJcIlxuICAvLyBhdCB0aGUgZW5kIG9mIHRoZSBwYXR0ZXJuLiAgVGhpcyBjYW4gb25seSBtYXRjaCBhXG4gIC8vIGNvcnJlc3BvbmRpbmcgXCJcIiBhdCB0aGUgZW5kIG9mIHRoZSBmaWxlLlxuICAvLyBJZiB0aGUgZmlsZSBlbmRzIGluIC8sIHRoZW4gaXQgY2FuIG9ubHkgbWF0Y2ggYVxuICAvLyBhIHBhdHRlcm4gdGhhdCBlbmRzIGluIC8sIHVubGVzcyB0aGUgcGF0dGVybiBqdXN0XG4gIC8vIGRvZXNuJ3QgaGF2ZSBhbnkgbW9yZSBmb3IgaXQuIEJ1dCwgYS9iLyBzaG91bGQgKm5vdCpcbiAgLy8gbWF0Y2ggXCJhL2IvKlwiLCBldmVuIHRob3VnaCBcIlwiIG1hdGNoZXMgYWdhaW5zdCB0aGVcbiAgLy8gW14vXSo/IHBhdHRlcm4sIGV4Y2VwdCBpbiBwYXJ0aWFsIG1vZGUsIHdoZXJlIGl0IG1pZ2h0XG4gIC8vIHNpbXBseSBub3QgYmUgcmVhY2hlZCB5ZXQuXG4gIC8vIEhvd2V2ZXIsIGEvYi8gc2hvdWxkIHN0aWxsIHNhdGlzZnkgYS8qXG5cbiAgLy8gbm93IGVpdGhlciB3ZSBmZWxsIG9mZiB0aGUgZW5kIG9mIHRoZSBwYXR0ZXJuLCBvciB3ZSdyZSBkb25lLlxuICBpZiAoZmkgPT09IGZsICYmIHBpID09PSBwbCkge1xuICAgIC8vIHJhbiBvdXQgb2YgcGF0dGVybiBhbmQgZmlsZW5hbWUgYXQgdGhlIHNhbWUgdGltZS5cbiAgICAvLyBhbiBleGFjdCBoaXQhXG4gICAgcmV0dXJuIHRydWVcbiAgfSBlbHNlIGlmIChmaSA9PT0gZmwpIHtcbiAgICAvLyByYW4gb3V0IG9mIGZpbGUsIGJ1dCBzdGlsbCBoYWQgcGF0dGVybiBsZWZ0LlxuICAgIC8vIHRoaXMgaXMgb2sgaWYgd2UncmUgZG9pbmcgdGhlIG1hdGNoIGFzIHBhcnQgb2ZcbiAgICAvLyBhIGdsb2IgZnMgdHJhdmVyc2FsLlxuICAgIHJldHVybiBwYXJ0aWFsXG4gIH0gZWxzZSAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqLyBpZiAocGkgPT09IHBsKSB7XG4gICAgLy8gcmFuIG91dCBvZiBwYXR0ZXJuLCBzdGlsbCBoYXZlIGZpbGUgbGVmdC5cbiAgICAvLyB0aGlzIGlzIG9ubHkgYWNjZXB0YWJsZSBpZiB3ZSdyZSBvbiB0aGUgdmVyeSBsYXN0XG4gICAgLy8gZW1wdHkgc2VnbWVudCBvZiBhIGZpbGUgd2l0aCBhIHRyYWlsaW5nIHNsYXNoLlxuICAgIC8vIGEvKiBzaG91bGQgbWF0Y2ggYS9iL1xuICAgIHJldHVybiAoZmkgPT09IGZsIC0gMSkgJiYgKGZpbGVbZmldID09PSAnJylcbiAgfVxuXG4gIC8vIHNob3VsZCBiZSB1bnJlYWNoYWJsZS5cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgdGhyb3cgbmV3IEVycm9yKCd3dGY/Jylcbn1cblxuLy8gcmVwbGFjZSBzdHVmZiBsaWtlIFxcKiB3aXRoICpcbmZ1bmN0aW9uIGdsb2JVbmVzY2FwZSAocykge1xuICByZXR1cm4gcy5yZXBsYWNlKC9cXFxcKC4pL2csICckMScpXG59XG5cbmZ1bmN0aW9uIHJlZ0V4cEVzY2FwZSAocykge1xuICByZXR1cm4gcy5yZXBsYWNlKC9bLVtcXF17fSgpKis/LixcXFxcXiR8I1xcc10vZywgJ1xcXFwkJicpXG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/minimatch/minimatch.js\n");

/***/ }),

/***/ "./node_modules/object-assign/index.js":
/*!*********************************************!*\
  !*** ./node_modules/object-assign/index.js ***!
  \*********************************************/
/***/ ((module) => {

"use strict";
eval("/*\nobject-assign\n(c) Sindre Sorhus\n@license MIT\n*/\n\n\n/* eslint-disable no-unused-vars */\nvar getOwnPropertySymbols = Object.getOwnPropertySymbols;\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nvar propIsEnumerable = Object.prototype.propertyIsEnumerable;\n\nfunction toObject(val) {\n\tif (val === null || val === undefined) {\n\t\tthrow new TypeError('Object.assign cannot be called with null or undefined');\n\t}\n\n\treturn Object(val);\n}\n\nfunction shouldUseNative() {\n\ttry {\n\t\tif (!Object.assign) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Detect buggy property enumeration order in older V8 versions.\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=4118\n\t\tvar test1 = new String('abc');  // eslint-disable-line no-new-wrappers\n\t\ttest1[5] = 'de';\n\t\tif (Object.getOwnPropertyNames(test1)[0] === '5') {\n\t\t\treturn false;\n\t\t}\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\tvar test2 = {};\n\t\tfor (var i = 0; i < 10; i++) {\n\t\t\ttest2['_' + String.fromCharCode(i)] = i;\n\t\t}\n\t\tvar order2 = Object.getOwnPropertyNames(test2).map(function (n) {\n\t\t\treturn test2[n];\n\t\t});\n\t\tif (order2.join('') !== '0123456789') {\n\t\t\treturn false;\n\t\t}\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\tvar test3 = {};\n\t\t'abcdefghijklmnopqrst'.split('').forEach(function (letter) {\n\t\t\ttest3[letter] = letter;\n\t\t});\n\t\tif (Object.keys(Object.assign({}, test3)).join('') !==\n\t\t\t\t'abcdefghijklmnopqrst') {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t} catch (err) {\n\t\t// We don't expect any of the above to throw, but better to be safe.\n\t\treturn false;\n\t}\n}\n\nmodule.exports = shouldUseNative() ? Object.assign : function (target, source) {\n\tvar from;\n\tvar to = toObject(target);\n\tvar symbols;\n\n\tfor (var s = 1; s < arguments.length; s++) {\n\t\tfrom = Object(arguments[s]);\n\n\t\tfor (var key in from) {\n\t\t\tif (hasOwnProperty.call(from, key)) {\n\t\t\t\tto[key] = from[key];\n\t\t\t}\n\t\t}\n\n\t\tif (getOwnPropertySymbols) {\n\t\t\tsymbols = getOwnPropertySymbols(from);\n\t\t\tfor (var i = 0; i < symbols.length; i++) {\n\t\t\t\tif (propIsEnumerable.call(from, symbols[i])) {\n\t\t\t\t\tto[symbols[i]] = from[symbols[i]];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn to;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvb2JqZWN0LWFzc2lnbi9pbmRleC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0IsUUFBUTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsc0JBQXNCO0FBQ3ZDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQixvQkFBb0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90b2RvLWxpc3QvLi9ub2RlX21vZHVsZXMvb2JqZWN0LWFzc2lnbi9pbmRleC5qcz8zMjBjIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG5vYmplY3QtYXNzaWduXG4oYykgU2luZHJlIFNvcmh1c1xuQGxpY2Vuc2UgTUlUXG4qL1xuXG4ndXNlIHN0cmljdCc7XG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xudmFyIGdldE93blByb3BlcnR5U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIHByb3BJc0VudW1lcmFibGUgPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG5mdW5jdGlvbiB0b09iamVjdCh2YWwpIHtcblx0aWYgKHZhbCA9PT0gbnVsbCB8fCB2YWwgPT09IHVuZGVmaW5lZCkge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ09iamVjdC5hc3NpZ24gY2Fubm90IGJlIGNhbGxlZCB3aXRoIG51bGwgb3IgdW5kZWZpbmVkJyk7XG5cdH1cblxuXHRyZXR1cm4gT2JqZWN0KHZhbCk7XG59XG5cbmZ1bmN0aW9uIHNob3VsZFVzZU5hdGl2ZSgpIHtcblx0dHJ5IHtcblx0XHRpZiAoIU9iamVjdC5hc3NpZ24pIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBEZXRlY3QgYnVnZ3kgcHJvcGVydHkgZW51bWVyYXRpb24gb3JkZXIgaW4gb2xkZXIgVjggdmVyc2lvbnMuXG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD00MTE4XG5cdFx0dmFyIHRlc3QxID0gbmV3IFN0cmluZygnYWJjJyk7ICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ldy13cmFwcGVyc1xuXHRcdHRlc3QxWzVdID0gJ2RlJztcblx0XHRpZiAoT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGVzdDEpWzBdID09PSAnNScpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zMDU2XG5cdFx0dmFyIHRlc3QyID0ge307XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCAxMDsgaSsrKSB7XG5cdFx0XHR0ZXN0MlsnXycgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGkpXSA9IGk7XG5cdFx0fVxuXHRcdHZhciBvcmRlcjIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0ZXN0MikubWFwKGZ1bmN0aW9uIChuKSB7XG5cdFx0XHRyZXR1cm4gdGVzdDJbbl07XG5cdFx0fSk7XG5cdFx0aWYgKG9yZGVyMi5qb2luKCcnKSAhPT0gJzAxMjM0NTY3ODknKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzA1NlxuXHRcdHZhciB0ZXN0MyA9IHt9O1xuXHRcdCdhYmNkZWZnaGlqa2xtbm9wcXJzdCcuc3BsaXQoJycpLmZvckVhY2goZnVuY3Rpb24gKGxldHRlcikge1xuXHRcdFx0dGVzdDNbbGV0dGVyXSA9IGxldHRlcjtcblx0XHR9KTtcblx0XHRpZiAoT2JqZWN0LmtleXMoT2JqZWN0LmFzc2lnbih7fSwgdGVzdDMpKS5qb2luKCcnKSAhPT1cblx0XHRcdFx0J2FiY2RlZmdoaWprbG1ub3BxcnN0Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdHJldHVybiB0cnVlO1xuXHR9IGNhdGNoIChlcnIpIHtcblx0XHQvLyBXZSBkb24ndCBleHBlY3QgYW55IG9mIHRoZSBhYm92ZSB0byB0aHJvdywgYnV0IGJldHRlciB0byBiZSBzYWZlLlxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNob3VsZFVzZU5hdGl2ZSgpID8gT2JqZWN0LmFzc2lnbiA6IGZ1bmN0aW9uICh0YXJnZXQsIHNvdXJjZSkge1xuXHR2YXIgZnJvbTtcblx0dmFyIHRvID0gdG9PYmplY3QodGFyZ2V0KTtcblx0dmFyIHN5bWJvbHM7XG5cblx0Zm9yICh2YXIgcyA9IDE7IHMgPCBhcmd1bWVudHMubGVuZ3RoOyBzKyspIHtcblx0XHRmcm9tID0gT2JqZWN0KGFyZ3VtZW50c1tzXSk7XG5cblx0XHRmb3IgKHZhciBrZXkgaW4gZnJvbSkge1xuXHRcdFx0aWYgKGhhc093blByb3BlcnR5LmNhbGwoZnJvbSwga2V5KSkge1xuXHRcdFx0XHR0b1trZXldID0gZnJvbVtrZXldO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChnZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcblx0XHRcdHN5bWJvbHMgPSBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZnJvbSk7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHN5bWJvbHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0aWYgKHByb3BJc0VudW1lcmFibGUuY2FsbChmcm9tLCBzeW1ib2xzW2ldKSkge1xuXHRcdFx0XHRcdHRvW3N5bWJvbHNbaV1dID0gZnJvbVtzeW1ib2xzW2ldXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiB0bztcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/object-assign/index.js\n");

/***/ }),

/***/ "./node_modules/once/once.js":
/*!***********************************!*\
  !*** ./node_modules/once/once.js ***!
  \***********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var wrappy = __webpack_require__(/*! wrappy */ \"./node_modules/wrappy/wrappy.js\")\nmodule.exports = wrappy(once)\nmodule.exports.strict = wrappy(onceStrict)\n\nonce.proto = once(function () {\n  Object.defineProperty(Function.prototype, 'once', {\n    value: function () {\n      return once(this)\n    },\n    configurable: true\n  })\n\n  Object.defineProperty(Function.prototype, 'onceStrict', {\n    value: function () {\n      return onceStrict(this)\n    },\n    configurable: true\n  })\n})\n\nfunction once (fn) {\n  var f = function () {\n    if (f.called) return f.value\n    f.called = true\n    return f.value = fn.apply(this, arguments)\n  }\n  f.called = false\n  return f\n}\n\nfunction onceStrict (fn) {\n  var f = function () {\n    if (f.called)\n      throw new Error(f.onceError)\n    f.called = true\n    return f.value = fn.apply(this, arguments)\n  }\n  var name = fn.name || 'Function wrapped with `once`'\n  f.onceError = name + \" shouldn't be called more than once\"\n  f.called = false\n  return f\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvb25jZS9vbmNlLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBLGFBQWEsbUJBQU8sQ0FBQywrQ0FBUTtBQUM3QjtBQUNBLHFCQUFxQjs7QUFFckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSCxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90b2RvLWxpc3QvLi9ub2RlX21vZHVsZXMvb25jZS9vbmNlLmpzPzU2NmIiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIHdyYXBweSA9IHJlcXVpcmUoJ3dyYXBweScpXG5tb2R1bGUuZXhwb3J0cyA9IHdyYXBweShvbmNlKVxubW9kdWxlLmV4cG9ydHMuc3RyaWN0ID0gd3JhcHB5KG9uY2VTdHJpY3QpXG5cbm9uY2UucHJvdG8gPSBvbmNlKGZ1bmN0aW9uICgpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZ1bmN0aW9uLnByb3RvdHlwZSwgJ29uY2UnLCB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBvbmNlKHRoaXMpXG4gICAgfSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSlcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRnVuY3Rpb24ucHJvdG90eXBlLCAnb25jZVN0cmljdCcsIHtcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG9uY2VTdHJpY3QodGhpcylcbiAgICB9LFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KVxufSlcblxuZnVuY3Rpb24gb25jZSAoZm4pIHtcbiAgdmFyIGYgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGYuY2FsbGVkKSByZXR1cm4gZi52YWx1ZVxuICAgIGYuY2FsbGVkID0gdHJ1ZVxuICAgIHJldHVybiBmLnZhbHVlID0gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICB9XG4gIGYuY2FsbGVkID0gZmFsc2VcbiAgcmV0dXJuIGZcbn1cblxuZnVuY3Rpb24gb25jZVN0cmljdCAoZm4pIHtcbiAgdmFyIGYgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGYuY2FsbGVkKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGYub25jZUVycm9yKVxuICAgIGYuY2FsbGVkID0gdHJ1ZVxuICAgIHJldHVybiBmLnZhbHVlID0gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICB9XG4gIHZhciBuYW1lID0gZm4ubmFtZSB8fCAnRnVuY3Rpb24gd3JhcHBlZCB3aXRoIGBvbmNlYCdcbiAgZi5vbmNlRXJyb3IgPSBuYW1lICsgXCIgc2hvdWxkbid0IGJlIGNhbGxlZCBtb3JlIHRoYW4gb25jZVwiXG4gIGYuY2FsbGVkID0gZmFsc2VcbiAgcmV0dXJuIGZcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/once/once.js\n");

/***/ }),

/***/ "./node_modules/p-limit/index.js":
/*!***************************************!*\
  !*** ./node_modules/p-limit/index.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst pTry = __webpack_require__(/*! p-try */ \"./node_modules/p-try/index.js\");\n\nconst pLimit = concurrency => {\n\tif (!((Number.isInteger(concurrency) || concurrency === Infinity) && concurrency > 0)) {\n\t\treturn Promise.reject(new TypeError('Expected `concurrency` to be a number from 1 and up'));\n\t}\n\n\tconst queue = [];\n\tlet activeCount = 0;\n\n\tconst next = () => {\n\t\tactiveCount--;\n\n\t\tif (queue.length > 0) {\n\t\t\tqueue.shift()();\n\t\t}\n\t};\n\n\tconst run = (fn, resolve, ...args) => {\n\t\tactiveCount++;\n\n\t\tconst result = pTry(fn, ...args);\n\n\t\tresolve(result);\n\n\t\tresult.then(next, next);\n\t};\n\n\tconst enqueue = (fn, resolve, ...args) => {\n\t\tif (activeCount < concurrency) {\n\t\t\trun(fn, resolve, ...args);\n\t\t} else {\n\t\t\tqueue.push(run.bind(null, fn, resolve, ...args));\n\t\t}\n\t};\n\n\tconst generator = (fn, ...args) => new Promise(resolve => enqueue(fn, resolve, ...args));\n\tObject.defineProperties(generator, {\n\t\tactiveCount: {\n\t\t\tget: () => activeCount\n\t\t},\n\t\tpendingCount: {\n\t\t\tget: () => queue.length\n\t\t},\n\t\tclearQueue: {\n\t\t\tvalue: () => {\n\t\t\t\tqueue.length = 0;\n\t\t\t}\n\t\t}\n\t});\n\n\treturn generator;\n};\n\nmodule.exports = pLimit;\nmodule.exports[\"default\"] = pLimit;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcC1saW1pdC9pbmRleC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLGFBQWEsbUJBQU8sQ0FBQyw0Q0FBTzs7QUFFNUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBLHlCQUFzQiIsInNvdXJjZXMiOlsid2VicGFjazovL3RvZG8tbGlzdC8uL25vZGVfbW9kdWxlcy9wLWxpbWl0L2luZGV4LmpzP2NkYzQiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuY29uc3QgcFRyeSA9IHJlcXVpcmUoJ3AtdHJ5Jyk7XG5cbmNvbnN0IHBMaW1pdCA9IGNvbmN1cnJlbmN5ID0+IHtcblx0aWYgKCEoKE51bWJlci5pc0ludGVnZXIoY29uY3VycmVuY3kpIHx8IGNvbmN1cnJlbmN5ID09PSBJbmZpbml0eSkgJiYgY29uY3VycmVuY3kgPiAwKSkge1xuXHRcdHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBgY29uY3VycmVuY3lgIHRvIGJlIGEgbnVtYmVyIGZyb20gMSBhbmQgdXAnKSk7XG5cdH1cblxuXHRjb25zdCBxdWV1ZSA9IFtdO1xuXHRsZXQgYWN0aXZlQ291bnQgPSAwO1xuXG5cdGNvbnN0IG5leHQgPSAoKSA9PiB7XG5cdFx0YWN0aXZlQ291bnQtLTtcblxuXHRcdGlmIChxdWV1ZS5sZW5ndGggPiAwKSB7XG5cdFx0XHRxdWV1ZS5zaGlmdCgpKCk7XG5cdFx0fVxuXHR9O1xuXG5cdGNvbnN0IHJ1biA9IChmbiwgcmVzb2x2ZSwgLi4uYXJncykgPT4ge1xuXHRcdGFjdGl2ZUNvdW50Kys7XG5cblx0XHRjb25zdCByZXN1bHQgPSBwVHJ5KGZuLCAuLi5hcmdzKTtcblxuXHRcdHJlc29sdmUocmVzdWx0KTtcblxuXHRcdHJlc3VsdC50aGVuKG5leHQsIG5leHQpO1xuXHR9O1xuXG5cdGNvbnN0IGVucXVldWUgPSAoZm4sIHJlc29sdmUsIC4uLmFyZ3MpID0+IHtcblx0XHRpZiAoYWN0aXZlQ291bnQgPCBjb25jdXJyZW5jeSkge1xuXHRcdFx0cnVuKGZuLCByZXNvbHZlLCAuLi5hcmdzKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cXVldWUucHVzaChydW4uYmluZChudWxsLCBmbiwgcmVzb2x2ZSwgLi4uYXJncykpO1xuXHRcdH1cblx0fTtcblxuXHRjb25zdCBnZW5lcmF0b3IgPSAoZm4sIC4uLmFyZ3MpID0+IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gZW5xdWV1ZShmbiwgcmVzb2x2ZSwgLi4uYXJncykpO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydGllcyhnZW5lcmF0b3IsIHtcblx0XHRhY3RpdmVDb3VudDoge1xuXHRcdFx0Z2V0OiAoKSA9PiBhY3RpdmVDb3VudFxuXHRcdH0sXG5cdFx0cGVuZGluZ0NvdW50OiB7XG5cdFx0XHRnZXQ6ICgpID0+IHF1ZXVlLmxlbmd0aFxuXHRcdH0sXG5cdFx0Y2xlYXJRdWV1ZToge1xuXHRcdFx0dmFsdWU6ICgpID0+IHtcblx0XHRcdFx0cXVldWUubGVuZ3RoID0gMDtcblx0XHRcdH1cblx0XHR9XG5cdH0pO1xuXG5cdHJldHVybiBnZW5lcmF0b3I7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHBMaW1pdDtcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBwTGltaXQ7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/p-limit/index.js\n");

/***/ }),

/***/ "./node_modules/p-locate/index.js":
/*!****************************************!*\
  !*** ./node_modules/p-locate/index.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst pLimit = __webpack_require__(/*! p-limit */ \"./node_modules/p-limit/index.js\");\n\nclass EndError extends Error {\n\tconstructor(value) {\n\t\tsuper();\n\t\tthis.value = value;\n\t}\n}\n\n// The input can also be a promise, so we await it\nconst testElement = async (element, tester) => tester(await element);\n\n// The input can also be a promise, so we `Promise.all()` them both\nconst finder = async element => {\n\tconst values = await Promise.all(element);\n\tif (values[1] === true) {\n\t\tthrow new EndError(values[0]);\n\t}\n\n\treturn false;\n};\n\nconst pLocate = async (iterable, tester, options) => {\n\toptions = {\n\t\tconcurrency: Infinity,\n\t\tpreserveOrder: true,\n\t\t...options\n\t};\n\n\tconst limit = pLimit(options.concurrency);\n\n\t// Start all the promises concurrently with optional limit\n\tconst items = [...iterable].map(element => [element, limit(testElement, element, tester)]);\n\n\t// Check the promises either serially or concurrently\n\tconst checkLimit = pLimit(options.preserveOrder ? 1 : Infinity);\n\n\ttry {\n\t\tawait Promise.all(items.map(element => checkLimit(finder, element)));\n\t} catch (error) {\n\t\tif (error instanceof EndError) {\n\t\t\treturn error.value;\n\t\t}\n\n\t\tthrow error;\n\t}\n};\n\nmodule.exports = pLocate;\n// TODO: Remove this for the next major release\nmodule.exports[\"default\"] = pLocate;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcC1sb2NhdGUvaW5kZXguanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixlQUFlLG1CQUFPLENBQUMsZ0RBQVM7O0FBRWhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx5QkFBc0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90b2RvLWxpc3QvLi9ub2RlX21vZHVsZXMvcC1sb2NhdGUvaW5kZXguanM/Y2JmZiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5jb25zdCBwTGltaXQgPSByZXF1aXJlKCdwLWxpbWl0Jyk7XG5cbmNsYXNzIEVuZEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuXHRjb25zdHJ1Y3Rvcih2YWx1ZSkge1xuXHRcdHN1cGVyKCk7XG5cdFx0dGhpcy52YWx1ZSA9IHZhbHVlO1xuXHR9XG59XG5cbi8vIFRoZSBpbnB1dCBjYW4gYWxzbyBiZSBhIHByb21pc2UsIHNvIHdlIGF3YWl0IGl0XG5jb25zdCB0ZXN0RWxlbWVudCA9IGFzeW5jIChlbGVtZW50LCB0ZXN0ZXIpID0+IHRlc3Rlcihhd2FpdCBlbGVtZW50KTtcblxuLy8gVGhlIGlucHV0IGNhbiBhbHNvIGJlIGEgcHJvbWlzZSwgc28gd2UgYFByb21pc2UuYWxsKClgIHRoZW0gYm90aFxuY29uc3QgZmluZGVyID0gYXN5bmMgZWxlbWVudCA9PiB7XG5cdGNvbnN0IHZhbHVlcyA9IGF3YWl0IFByb21pc2UuYWxsKGVsZW1lbnQpO1xuXHRpZiAodmFsdWVzWzFdID09PSB0cnVlKSB7XG5cdFx0dGhyb3cgbmV3IEVuZEVycm9yKHZhbHVlc1swXSk7XG5cdH1cblxuXHRyZXR1cm4gZmFsc2U7XG59O1xuXG5jb25zdCBwTG9jYXRlID0gYXN5bmMgKGl0ZXJhYmxlLCB0ZXN0ZXIsIG9wdGlvbnMpID0+IHtcblx0b3B0aW9ucyA9IHtcblx0XHRjb25jdXJyZW5jeTogSW5maW5pdHksXG5cdFx0cHJlc2VydmVPcmRlcjogdHJ1ZSxcblx0XHQuLi5vcHRpb25zXG5cdH07XG5cblx0Y29uc3QgbGltaXQgPSBwTGltaXQob3B0aW9ucy5jb25jdXJyZW5jeSk7XG5cblx0Ly8gU3RhcnQgYWxsIHRoZSBwcm9taXNlcyBjb25jdXJyZW50bHkgd2l0aCBvcHRpb25hbCBsaW1pdFxuXHRjb25zdCBpdGVtcyA9IFsuLi5pdGVyYWJsZV0ubWFwKGVsZW1lbnQgPT4gW2VsZW1lbnQsIGxpbWl0KHRlc3RFbGVtZW50LCBlbGVtZW50LCB0ZXN0ZXIpXSk7XG5cblx0Ly8gQ2hlY2sgdGhlIHByb21pc2VzIGVpdGhlciBzZXJpYWxseSBvciBjb25jdXJyZW50bHlcblx0Y29uc3QgY2hlY2tMaW1pdCA9IHBMaW1pdChvcHRpb25zLnByZXNlcnZlT3JkZXIgPyAxIDogSW5maW5pdHkpO1xuXG5cdHRyeSB7XG5cdFx0YXdhaXQgUHJvbWlzZS5hbGwoaXRlbXMubWFwKGVsZW1lbnQgPT4gY2hlY2tMaW1pdChmaW5kZXIsIGVsZW1lbnQpKSk7XG5cdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0aWYgKGVycm9yIGluc3RhbmNlb2YgRW5kRXJyb3IpIHtcblx0XHRcdHJldHVybiBlcnJvci52YWx1ZTtcblx0XHR9XG5cblx0XHR0aHJvdyBlcnJvcjtcblx0fVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBwTG9jYXRlO1xuLy8gVE9ETzogUmVtb3ZlIHRoaXMgZm9yIHRoZSBuZXh0IG1ham9yIHJlbGVhc2Vcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBwTG9jYXRlO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/p-locate/index.js\n");

/***/ }),

/***/ "./node_modules/p-try/index.js":
/*!*************************************!*\
  !*** ./node_modules/p-try/index.js ***!
  \*************************************/
/***/ ((module) => {

"use strict";
eval("\n\nconst pTry = (fn, ...arguments_) => new Promise(resolve => {\n\tresolve(fn(...arguments_));\n});\n\nmodule.exports = pTry;\n// TODO: remove this in the next major version\nmodule.exports[\"default\"] = pTry;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcC10cnkvaW5kZXguanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLHlCQUFzQiIsInNvdXJjZXMiOlsid2VicGFjazovL3RvZG8tbGlzdC8uL25vZGVfbW9kdWxlcy9wLXRyeS9pbmRleC5qcz9kODM1Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgcFRyeSA9IChmbiwgLi4uYXJndW1lbnRzXykgPT4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG5cdHJlc29sdmUoZm4oLi4uYXJndW1lbnRzXykpO1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gcFRyeTtcbi8vIFRPRE86IHJlbW92ZSB0aGlzIGluIHRoZSBuZXh0IG1ham9yIHZlcnNpb25cbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBwVHJ5O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/p-try/index.js\n");

/***/ }),

/***/ "./node_modules/path-exists/index.js":
/*!*******************************************!*\
  !*** ./node_modules/path-exists/index.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst fs = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'fs'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\nconst {promisify} = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'util'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\n\nconst pAccess = promisify(fs.access);\n\nmodule.exports = async path => {\n\ttry {\n\t\tawait pAccess(path);\n\t\treturn true;\n\t} catch (_) {\n\t\treturn false;\n\t}\n};\n\nmodule.exports.sync = path => {\n\ttry {\n\t\tfs.accessSync(path);\n\t\treturn true;\n\t} catch (_) {\n\t\treturn false;\n\t}\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcGF0aC1leGlzdHMvaW5kZXguanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixXQUFXLG1CQUFPLENBQUMsaUlBQUk7QUFDdkIsT0FBTyxXQUFXLEVBQUUsbUJBQU8sQ0FBQyxtSUFBTTs7QUFFbEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdG9kby1saXN0Ly4vbm9kZV9tb2R1bGVzL3BhdGgtZXhpc3RzL2luZGV4LmpzPzgyMjAiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuY29uc3QgZnMgPSByZXF1aXJlKCdmcycpO1xuY29uc3Qge3Byb21pc2lmeX0gPSByZXF1aXJlKCd1dGlsJyk7XG5cbmNvbnN0IHBBY2Nlc3MgPSBwcm9taXNpZnkoZnMuYWNjZXNzKTtcblxubW9kdWxlLmV4cG9ydHMgPSBhc3luYyBwYXRoID0+IHtcblx0dHJ5IHtcblx0XHRhd2FpdCBwQWNjZXNzKHBhdGgpO1xuXHRcdHJldHVybiB0cnVlO1xuXHR9IGNhdGNoIChfKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5zeW5jID0gcGF0aCA9PiB7XG5cdHRyeSB7XG5cdFx0ZnMuYWNjZXNzU3luYyhwYXRoKTtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSBjYXRjaCAoXykge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/path-exists/index.js\n");

/***/ }),

/***/ "./node_modules/path-is-absolute/index.js":
/*!************************************************!*\
  !*** ./node_modules/path-is-absolute/index.js ***!
  \************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nfunction posix(path) {\n\treturn path.charAt(0) === '/';\n}\n\nfunction win32(path) {\n\t// https://github.com/nodejs/node/blob/b3fcc245fb25539909ef1d5eaa01dbf92e168633/lib/path.js#L56\n\tvar splitDeviceRe = /^([a-zA-Z]:|[\\\\\\/]{2}[^\\\\\\/]+[\\\\\\/]+[^\\\\\\/]+)?([\\\\\\/])?([\\s\\S]*?)$/;\n\tvar result = splitDeviceRe.exec(path);\n\tvar device = result[1] || '';\n\tvar isUnc = Boolean(device && device.charAt(1) !== ':');\n\n\t// UNC paths are always absolute\n\treturn Boolean(result[2] || isUnc);\n}\n\nmodule.exports = process.platform === 'win32' ? win32 : posix;\nmodule.exports.posix = posix;\nmodule.exports.win32 = win32;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcGF0aC1pcy1hYnNvbHV0ZS9pbmRleC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlDQUF5QyxFQUFFO0FBQzNDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0I7QUFDcEIsb0JBQW9CIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdG9kby1saXN0Ly4vbm9kZV9tb2R1bGVzL3BhdGgtaXMtYWJzb2x1dGUvaW5kZXguanM/YTFhMiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIHBvc2l4KHBhdGgpIHtcblx0cmV0dXJuIHBhdGguY2hhckF0KDApID09PSAnLyc7XG59XG5cbmZ1bmN0aW9uIHdpbjMyKHBhdGgpIHtcblx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2Jsb2IvYjNmY2MyNDVmYjI1NTM5OTA5ZWYxZDVlYWEwMWRiZjkyZTE2ODYzMy9saWIvcGF0aC5qcyNMNTZcblx0dmFyIHNwbGl0RGV2aWNlUmUgPSAvXihbYS16QS1aXTp8W1xcXFxcXC9dezJ9W15cXFxcXFwvXStbXFxcXFxcL10rW15cXFxcXFwvXSspPyhbXFxcXFxcL10pPyhbXFxzXFxTXSo/KSQvO1xuXHR2YXIgcmVzdWx0ID0gc3BsaXREZXZpY2VSZS5leGVjKHBhdGgpO1xuXHR2YXIgZGV2aWNlID0gcmVzdWx0WzFdIHx8ICcnO1xuXHR2YXIgaXNVbmMgPSBCb29sZWFuKGRldmljZSAmJiBkZXZpY2UuY2hhckF0KDEpICE9PSAnOicpO1xuXG5cdC8vIFVOQyBwYXRocyBhcmUgYWx3YXlzIGFic29sdXRlXG5cdHJldHVybiBCb29sZWFuKHJlc3VsdFsyXSB8fCBpc1VuYyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJyA/IHdpbjMyIDogcG9zaXg7XG5tb2R1bGUuZXhwb3J0cy5wb3NpeCA9IHBvc2l4O1xubW9kdWxlLmV4cG9ydHMud2luMzIgPSB3aW4zMjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/path-is-absolute/index.js\n");

/***/ }),

/***/ "./node_modules/pify/index.js":
/*!************************************!*\
  !*** ./node_modules/pify/index.js ***!
  \************************************/
/***/ ((module) => {

"use strict";
eval("\n\nvar processFn = function (fn, P, opts) {\n\treturn function () {\n\t\tvar that = this;\n\t\tvar args = new Array(arguments.length);\n\n\t\tfor (var i = 0; i < arguments.length; i++) {\n\t\t\targs[i] = arguments[i];\n\t\t}\n\n\t\treturn new P(function (resolve, reject) {\n\t\t\targs.push(function (err, result) {\n\t\t\t\tif (err) {\n\t\t\t\t\treject(err);\n\t\t\t\t} else if (opts.multiArgs) {\n\t\t\t\t\tvar results = new Array(arguments.length - 1);\n\n\t\t\t\t\tfor (var i = 1; i < arguments.length; i++) {\n\t\t\t\t\t\tresults[i - 1] = arguments[i];\n\t\t\t\t\t}\n\n\t\t\t\t\tresolve(results);\n\t\t\t\t} else {\n\t\t\t\t\tresolve(result);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tfn.apply(that, args);\n\t\t});\n\t};\n};\n\nvar pify = module.exports = function (obj, P, opts) {\n\tif (typeof P !== 'function') {\n\t\topts = P;\n\t\tP = Promise;\n\t}\n\n\topts = opts || {};\n\topts.exclude = opts.exclude || [/.+Sync$/];\n\n\tvar filter = function (key) {\n\t\tvar match = function (pattern) {\n\t\t\treturn typeof pattern === 'string' ? key === pattern : pattern.test(key);\n\t\t};\n\n\t\treturn opts.include ? opts.include.some(match) : !opts.exclude.some(match);\n\t};\n\n\tvar ret = typeof obj === 'function' ? function () {\n\t\tif (opts.excludeMain) {\n\t\t\treturn obj.apply(this, arguments);\n\t\t}\n\n\t\treturn processFn(obj, P, opts).apply(this, arguments);\n\t} : {};\n\n\treturn Object.keys(obj).reduce(function (ret, key) {\n\t\tvar x = obj[key];\n\n\t\tret[key] = typeof x === 'function' && filter(key) ? processFn(x, P, opts) : x;\n\n\t\treturn ret;\n\t}, ret);\n};\n\npify.all = pify;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcGlmeS9pbmRleC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0Isc0JBQXNCO0FBQ3hDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUEscUJBQXFCLHNCQUFzQjtBQUMzQztBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxFQUFFO0FBQ0Y7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90b2RvLWxpc3QvLi9ub2RlX21vZHVsZXMvcGlmeS9pbmRleC5qcz8zNjRkIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIHByb2Nlc3NGbiA9IGZ1bmN0aW9uIChmbiwgUCwgb3B0cykge1xuXHRyZXR1cm4gZnVuY3Rpb24gKCkge1xuXHRcdHZhciB0aGF0ID0gdGhpcztcblx0XHR2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoKTtcblxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRhcmdzW2ldID0gYXJndW1lbnRzW2ldO1xuXHRcdH1cblxuXHRcdHJldHVybiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG5cdFx0XHRhcmdzLnB1c2goZnVuY3Rpb24gKGVyciwgcmVzdWx0KSB7XG5cdFx0XHRcdGlmIChlcnIpIHtcblx0XHRcdFx0XHRyZWplY3QoZXJyKTtcblx0XHRcdFx0fSBlbHNlIGlmIChvcHRzLm11bHRpQXJncykge1xuXHRcdFx0XHRcdHZhciByZXN1bHRzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcblxuXHRcdFx0XHRcdGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRyZXN1bHRzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRyZXNvbHZlKHJlc3VsdHMpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHJlc29sdmUocmVzdWx0KTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cblx0XHRcdGZuLmFwcGx5KHRoYXQsIGFyZ3MpO1xuXHRcdH0pO1xuXHR9O1xufTtcblxudmFyIHBpZnkgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmosIFAsIG9wdHMpIHtcblx0aWYgKHR5cGVvZiBQICE9PSAnZnVuY3Rpb24nKSB7XG5cdFx0b3B0cyA9IFA7XG5cdFx0UCA9IFByb21pc2U7XG5cdH1cblxuXHRvcHRzID0gb3B0cyB8fCB7fTtcblx0b3B0cy5leGNsdWRlID0gb3B0cy5leGNsdWRlIHx8IFsvLitTeW5jJC9dO1xuXG5cdHZhciBmaWx0ZXIgPSBmdW5jdGlvbiAoa2V5KSB7XG5cdFx0dmFyIG1hdGNoID0gZnVuY3Rpb24gKHBhdHRlcm4pIHtcblx0XHRcdHJldHVybiB0eXBlb2YgcGF0dGVybiA9PT0gJ3N0cmluZycgPyBrZXkgPT09IHBhdHRlcm4gOiBwYXR0ZXJuLnRlc3Qoa2V5KTtcblx0XHR9O1xuXG5cdFx0cmV0dXJuIG9wdHMuaW5jbHVkZSA/IG9wdHMuaW5jbHVkZS5zb21lKG1hdGNoKSA6ICFvcHRzLmV4Y2x1ZGUuc29tZShtYXRjaCk7XG5cdH07XG5cblx0dmFyIHJldCA9IHR5cGVvZiBvYmogPT09ICdmdW5jdGlvbicgPyBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKG9wdHMuZXhjbHVkZU1haW4pIHtcblx0XHRcdHJldHVybiBvYmouYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gcHJvY2Vzc0ZuKG9iaiwgUCwgb3B0cykuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0fSA6IHt9O1xuXG5cdHJldHVybiBPYmplY3Qua2V5cyhvYmopLnJlZHVjZShmdW5jdGlvbiAocmV0LCBrZXkpIHtcblx0XHR2YXIgeCA9IG9ialtrZXldO1xuXG5cdFx0cmV0W2tleV0gPSB0eXBlb2YgeCA9PT0gJ2Z1bmN0aW9uJyAmJiBmaWx0ZXIoa2V5KSA/IHByb2Nlc3NGbih4LCBQLCBvcHRzKSA6IHg7XG5cblx0XHRyZXR1cm4gcmV0O1xuXHR9LCByZXQpO1xufTtcblxucGlmeS5hbGwgPSBwaWZ5O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/pify/index.js\n");

/***/ }),

/***/ "./node_modules/pinkie-promise/index.js":
/*!**********************************************!*\
  !*** ./node_modules/pinkie-promise/index.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nmodule.exports = typeof Promise === 'function' ? Promise : __webpack_require__(/*! pinkie */ \"./node_modules/pinkie/index.js\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcGlua2llLXByb21pc2UvaW5kZXguanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsMkRBQTJELG1CQUFPLENBQUMsOENBQVEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90b2RvLWxpc3QvLi9ub2RlX21vZHVsZXMvcGlua2llLXByb21pc2UvaW5kZXguanM/YjEyMSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gdHlwZW9mIFByb21pc2UgPT09ICdmdW5jdGlvbicgPyBQcm9taXNlIDogcmVxdWlyZSgncGlua2llJyk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/pinkie-promise/index.js\n");

/***/ }),

/***/ "./node_modules/pinkie/index.js":
/*!**************************************!*\
  !*** ./node_modules/pinkie/index.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar PENDING = 'pending';\nvar SETTLED = 'settled';\nvar FULFILLED = 'fulfilled';\nvar REJECTED = 'rejected';\nvar NOOP = function () {};\nvar isNode = typeof __webpack_require__.g !== 'undefined' && typeof __webpack_require__.g.process !== 'undefined' && typeof __webpack_require__.g.process.emit === 'function';\n\nvar asyncSetTimer = typeof setImmediate === 'undefined' ? setTimeout : setImmediate;\nvar asyncQueue = [];\nvar asyncTimer;\n\nfunction asyncFlush() {\n\t// run promise callbacks\n\tfor (var i = 0; i < asyncQueue.length; i++) {\n\t\tasyncQueue[i][0](asyncQueue[i][1]);\n\t}\n\n\t// reset async asyncQueue\n\tasyncQueue = [];\n\tasyncTimer = false;\n}\n\nfunction asyncCall(callback, arg) {\n\tasyncQueue.push([callback, arg]);\n\n\tif (!asyncTimer) {\n\t\tasyncTimer = true;\n\t\tasyncSetTimer(asyncFlush, 0);\n\t}\n}\n\nfunction invokeResolver(resolver, promise) {\n\tfunction resolvePromise(value) {\n\t\tresolve(promise, value);\n\t}\n\n\tfunction rejectPromise(reason) {\n\t\treject(promise, reason);\n\t}\n\n\ttry {\n\t\tresolver(resolvePromise, rejectPromise);\n\t} catch (e) {\n\t\trejectPromise(e);\n\t}\n}\n\nfunction invokeCallback(subscriber) {\n\tvar owner = subscriber.owner;\n\tvar settled = owner._state;\n\tvar value = owner._data;\n\tvar callback = subscriber[settled];\n\tvar promise = subscriber.then;\n\n\tif (typeof callback === 'function') {\n\t\tsettled = FULFILLED;\n\t\ttry {\n\t\t\tvalue = callback(value);\n\t\t} catch (e) {\n\t\t\treject(promise, e);\n\t\t}\n\t}\n\n\tif (!handleThenable(promise, value)) {\n\t\tif (settled === FULFILLED) {\n\t\t\tresolve(promise, value);\n\t\t}\n\n\t\tif (settled === REJECTED) {\n\t\t\treject(promise, value);\n\t\t}\n\t}\n}\n\nfunction handleThenable(promise, value) {\n\tvar resolved;\n\n\ttry {\n\t\tif (promise === value) {\n\t\t\tthrow new TypeError('A promises callback cannot return that same promise.');\n\t\t}\n\n\t\tif (value && (typeof value === 'function' || typeof value === 'object')) {\n\t\t\t// then should be retrieved only once\n\t\t\tvar then = value.then;\n\n\t\t\tif (typeof then === 'function') {\n\t\t\t\tthen.call(value, function (val) {\n\t\t\t\t\tif (!resolved) {\n\t\t\t\t\t\tresolved = true;\n\n\t\t\t\t\t\tif (value === val) {\n\t\t\t\t\t\t\tfulfill(promise, val);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresolve(promise, val);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}, function (reason) {\n\t\t\t\t\tif (!resolved) {\n\t\t\t\t\t\tresolved = true;\n\n\t\t\t\t\t\treject(promise, reason);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t} catch (e) {\n\t\tif (!resolved) {\n\t\t\treject(promise, e);\n\t\t}\n\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nfunction resolve(promise, value) {\n\tif (promise === value || !handleThenable(promise, value)) {\n\t\tfulfill(promise, value);\n\t}\n}\n\nfunction fulfill(promise, value) {\n\tif (promise._state === PENDING) {\n\t\tpromise._state = SETTLED;\n\t\tpromise._data = value;\n\n\t\tasyncCall(publishFulfillment, promise);\n\t}\n}\n\nfunction reject(promise, reason) {\n\tif (promise._state === PENDING) {\n\t\tpromise._state = SETTLED;\n\t\tpromise._data = reason;\n\n\t\tasyncCall(publishRejection, promise);\n\t}\n}\n\nfunction publish(promise) {\n\tpromise._then = promise._then.forEach(invokeCallback);\n}\n\nfunction publishFulfillment(promise) {\n\tpromise._state = FULFILLED;\n\tpublish(promise);\n}\n\nfunction publishRejection(promise) {\n\tpromise._state = REJECTED;\n\tpublish(promise);\n\tif (!promise._handled && isNode) {\n\t\t__webpack_require__.g.process.emit('unhandledRejection', promise._data, promise);\n\t}\n}\n\nfunction notifyRejectionHandled(promise) {\n\t__webpack_require__.g.process.emit('rejectionHandled', promise);\n}\n\n/**\n * @class\n */\nfunction Promise(resolver) {\n\tif (typeof resolver !== 'function') {\n\t\tthrow new TypeError('Promise resolver ' + resolver + ' is not a function');\n\t}\n\n\tif (this instanceof Promise === false) {\n\t\tthrow new TypeError('Failed to construct \\'Promise\\': Please use the \\'new\\' operator, this object constructor cannot be called as a function.');\n\t}\n\n\tthis._then = [];\n\n\tinvokeResolver(resolver, this);\n}\n\nPromise.prototype = {\n\tconstructor: Promise,\n\n\t_state: PENDING,\n\t_then: null,\n\t_data: undefined,\n\t_handled: false,\n\n\tthen: function (onFulfillment, onRejection) {\n\t\tvar subscriber = {\n\t\t\towner: this,\n\t\t\tthen: new this.constructor(NOOP),\n\t\t\tfulfilled: onFulfillment,\n\t\t\trejected: onRejection\n\t\t};\n\n\t\tif ((onRejection || onFulfillment) && !this._handled) {\n\t\t\tthis._handled = true;\n\t\t\tif (this._state === REJECTED && isNode) {\n\t\t\t\tasyncCall(notifyRejectionHandled, this);\n\t\t\t}\n\t\t}\n\n\t\tif (this._state === FULFILLED || this._state === REJECTED) {\n\t\t\t// already resolved, call callback async\n\t\t\tasyncCall(invokeCallback, subscriber);\n\t\t} else {\n\t\t\t// subscribe\n\t\t\tthis._then.push(subscriber);\n\t\t}\n\n\t\treturn subscriber.then;\n\t},\n\n\tcatch: function (onRejection) {\n\t\treturn this.then(null, onRejection);\n\t}\n};\n\nPromise.all = function (promises) {\n\tif (!Array.isArray(promises)) {\n\t\tthrow new TypeError('You must pass an array to Promise.all().');\n\t}\n\n\treturn new Promise(function (resolve, reject) {\n\t\tvar results = [];\n\t\tvar remaining = 0;\n\n\t\tfunction resolver(index) {\n\t\t\tremaining++;\n\t\t\treturn function (value) {\n\t\t\t\tresults[index] = value;\n\t\t\t\tif (!--remaining) {\n\t\t\t\t\tresolve(results);\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\n\t\tfor (var i = 0, promise; i < promises.length; i++) {\n\t\t\tpromise = promises[i];\n\n\t\t\tif (promise && typeof promise.then === 'function') {\n\t\t\t\tpromise.then(resolver(i), reject);\n\t\t\t} else {\n\t\t\t\tresults[i] = promise;\n\t\t\t}\n\t\t}\n\n\t\tif (!remaining) {\n\t\t\tresolve(results);\n\t\t}\n\t});\n};\n\nPromise.race = function (promises) {\n\tif (!Array.isArray(promises)) {\n\t\tthrow new TypeError('You must pass an array to Promise.race().');\n\t}\n\n\treturn new Promise(function (resolve, reject) {\n\t\tfor (var i = 0, promise; i < promises.length; i++) {\n\t\t\tpromise = promises[i];\n\n\t\t\tif (promise && typeof promise.then === 'function') {\n\t\t\t\tpromise.then(resolve, reject);\n\t\t\t} else {\n\t\t\t\tresolve(promise);\n\t\t\t}\n\t\t}\n\t});\n};\n\nPromise.resolve = function (value) {\n\tif (value && typeof value === 'object' && value.constructor === Promise) {\n\t\treturn value;\n\t}\n\n\treturn new Promise(function (resolve) {\n\t\tresolve(value);\n\t});\n};\n\nPromise.reject = function (reason) {\n\treturn new Promise(function (resolve, reject) {\n\t\treject(reason);\n\t});\n};\n\nmodule.exports = Promise;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcGlua2llL2luZGV4LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IscUJBQU0sMkJBQTJCLHFCQUFNLG1DQUFtQyxxQkFBTTs7QUFFcEc7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsdUJBQXVCO0FBQ3hDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxxQkFBTTtBQUNSO0FBQ0E7O0FBRUE7QUFDQSxDQUFDLHFCQUFNO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkIscUJBQXFCO0FBQ2hEOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQixxQkFBcUI7QUFDaEQ7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90b2RvLWxpc3QvLi9ub2RlX21vZHVsZXMvcGlua2llL2luZGV4LmpzPzk2NDciXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgUEVORElORyA9ICdwZW5kaW5nJztcbnZhciBTRVRUTEVEID0gJ3NldHRsZWQnO1xudmFyIEZVTEZJTExFRCA9ICdmdWxmaWxsZWQnO1xudmFyIFJFSkVDVEVEID0gJ3JlamVjdGVkJztcbnZhciBOT09QID0gZnVuY3Rpb24gKCkge307XG52YXIgaXNOb2RlID0gdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGdsb2JhbC5wcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgZ2xvYmFsLnByb2Nlc3MuZW1pdCA9PT0gJ2Z1bmN0aW9uJztcblxudmFyIGFzeW5jU2V0VGltZXIgPSB0eXBlb2Ygc2V0SW1tZWRpYXRlID09PSAndW5kZWZpbmVkJyA/IHNldFRpbWVvdXQgOiBzZXRJbW1lZGlhdGU7XG52YXIgYXN5bmNRdWV1ZSA9IFtdO1xudmFyIGFzeW5jVGltZXI7XG5cbmZ1bmN0aW9uIGFzeW5jRmx1c2goKSB7XG5cdC8vIHJ1biBwcm9taXNlIGNhbGxiYWNrc1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IGFzeW5jUXVldWUubGVuZ3RoOyBpKyspIHtcblx0XHRhc3luY1F1ZXVlW2ldWzBdKGFzeW5jUXVldWVbaV1bMV0pO1xuXHR9XG5cblx0Ly8gcmVzZXQgYXN5bmMgYXN5bmNRdWV1ZVxuXHRhc3luY1F1ZXVlID0gW107XG5cdGFzeW5jVGltZXIgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gYXN5bmNDYWxsKGNhbGxiYWNrLCBhcmcpIHtcblx0YXN5bmNRdWV1ZS5wdXNoKFtjYWxsYmFjaywgYXJnXSk7XG5cblx0aWYgKCFhc3luY1RpbWVyKSB7XG5cdFx0YXN5bmNUaW1lciA9IHRydWU7XG5cdFx0YXN5bmNTZXRUaW1lcihhc3luY0ZsdXNoLCAwKTtcblx0fVxufVxuXG5mdW5jdGlvbiBpbnZva2VSZXNvbHZlcihyZXNvbHZlciwgcHJvbWlzZSkge1xuXHRmdW5jdGlvbiByZXNvbHZlUHJvbWlzZSh2YWx1ZSkge1xuXHRcdHJlc29sdmUocHJvbWlzZSwgdmFsdWUpO1xuXHR9XG5cblx0ZnVuY3Rpb24gcmVqZWN0UHJvbWlzZShyZWFzb24pIHtcblx0XHRyZWplY3QocHJvbWlzZSwgcmVhc29uKTtcblx0fVxuXG5cdHRyeSB7XG5cdFx0cmVzb2x2ZXIocmVzb2x2ZVByb21pc2UsIHJlamVjdFByb21pc2UpO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0cmVqZWN0UHJvbWlzZShlKTtcblx0fVxufVxuXG5mdW5jdGlvbiBpbnZva2VDYWxsYmFjayhzdWJzY3JpYmVyKSB7XG5cdHZhciBvd25lciA9IHN1YnNjcmliZXIub3duZXI7XG5cdHZhciBzZXR0bGVkID0gb3duZXIuX3N0YXRlO1xuXHR2YXIgdmFsdWUgPSBvd25lci5fZGF0YTtcblx0dmFyIGNhbGxiYWNrID0gc3Vic2NyaWJlcltzZXR0bGVkXTtcblx0dmFyIHByb21pc2UgPSBzdWJzY3JpYmVyLnRoZW47XG5cblx0aWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdHNldHRsZWQgPSBGVUxGSUxMRUQ7XG5cdFx0dHJ5IHtcblx0XHRcdHZhbHVlID0gY2FsbGJhY2sodmFsdWUpO1xuXHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdHJlamVjdChwcm9taXNlLCBlKTtcblx0XHR9XG5cdH1cblxuXHRpZiAoIWhhbmRsZVRoZW5hYmxlKHByb21pc2UsIHZhbHVlKSkge1xuXHRcdGlmIChzZXR0bGVkID09PSBGVUxGSUxMRUQpIHtcblx0XHRcdHJlc29sdmUocHJvbWlzZSwgdmFsdWUpO1xuXHRcdH1cblxuXHRcdGlmIChzZXR0bGVkID09PSBSRUpFQ1RFRCkge1xuXHRcdFx0cmVqZWN0KHByb21pc2UsIHZhbHVlKTtcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gaGFuZGxlVGhlbmFibGUocHJvbWlzZSwgdmFsdWUpIHtcblx0dmFyIHJlc29sdmVkO1xuXG5cdHRyeSB7XG5cdFx0aWYgKHByb21pc2UgPT09IHZhbHVlKSB7XG5cdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdBIHByb21pc2VzIGNhbGxiYWNrIGNhbm5vdCByZXR1cm4gdGhhdCBzYW1lIHByb21pc2UuJyk7XG5cdFx0fVxuXG5cdFx0aWYgKHZhbHVlICYmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JykpIHtcblx0XHRcdC8vIHRoZW4gc2hvdWxkIGJlIHJldHJpZXZlZCBvbmx5IG9uY2Vcblx0XHRcdHZhciB0aGVuID0gdmFsdWUudGhlbjtcblxuXHRcdFx0aWYgKHR5cGVvZiB0aGVuID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdHRoZW4uY2FsbCh2YWx1ZSwgZnVuY3Rpb24gKHZhbCkge1xuXHRcdFx0XHRcdGlmICghcmVzb2x2ZWQpIHtcblx0XHRcdFx0XHRcdHJlc29sdmVkID0gdHJ1ZTtcblxuXHRcdFx0XHRcdFx0aWYgKHZhbHVlID09PSB2YWwpIHtcblx0XHRcdFx0XHRcdFx0ZnVsZmlsbChwcm9taXNlLCB2YWwpO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0cmVzb2x2ZShwcm9taXNlLCB2YWwpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSwgZnVuY3Rpb24gKHJlYXNvbikge1xuXHRcdFx0XHRcdGlmICghcmVzb2x2ZWQpIHtcblx0XHRcdFx0XHRcdHJlc29sdmVkID0gdHJ1ZTtcblxuXHRcdFx0XHRcdFx0cmVqZWN0KHByb21pc2UsIHJlYXNvbik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRpZiAoIXJlc29sdmVkKSB7XG5cdFx0XHRyZWplY3QocHJvbWlzZSwgZSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHRyZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIHJlc29sdmUocHJvbWlzZSwgdmFsdWUpIHtcblx0aWYgKHByb21pc2UgPT09IHZhbHVlIHx8ICFoYW5kbGVUaGVuYWJsZShwcm9taXNlLCB2YWx1ZSkpIHtcblx0XHRmdWxmaWxsKHByb21pc2UsIHZhbHVlKTtcblx0fVxufVxuXG5mdW5jdGlvbiBmdWxmaWxsKHByb21pc2UsIHZhbHVlKSB7XG5cdGlmIChwcm9taXNlLl9zdGF0ZSA9PT0gUEVORElORykge1xuXHRcdHByb21pc2UuX3N0YXRlID0gU0VUVExFRDtcblx0XHRwcm9taXNlLl9kYXRhID0gdmFsdWU7XG5cblx0XHRhc3luY0NhbGwocHVibGlzaEZ1bGZpbGxtZW50LCBwcm9taXNlKTtcblx0fVxufVxuXG5mdW5jdGlvbiByZWplY3QocHJvbWlzZSwgcmVhc29uKSB7XG5cdGlmIChwcm9taXNlLl9zdGF0ZSA9PT0gUEVORElORykge1xuXHRcdHByb21pc2UuX3N0YXRlID0gU0VUVExFRDtcblx0XHRwcm9taXNlLl9kYXRhID0gcmVhc29uO1xuXG5cdFx0YXN5bmNDYWxsKHB1Ymxpc2hSZWplY3Rpb24sIHByb21pc2UpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIHB1Ymxpc2gocHJvbWlzZSkge1xuXHRwcm9taXNlLl90aGVuID0gcHJvbWlzZS5fdGhlbi5mb3JFYWNoKGludm9rZUNhbGxiYWNrKTtcbn1cblxuZnVuY3Rpb24gcHVibGlzaEZ1bGZpbGxtZW50KHByb21pc2UpIHtcblx0cHJvbWlzZS5fc3RhdGUgPSBGVUxGSUxMRUQ7XG5cdHB1Ymxpc2gocHJvbWlzZSk7XG59XG5cbmZ1bmN0aW9uIHB1Ymxpc2hSZWplY3Rpb24ocHJvbWlzZSkge1xuXHRwcm9taXNlLl9zdGF0ZSA9IFJFSkVDVEVEO1xuXHRwdWJsaXNoKHByb21pc2UpO1xuXHRpZiAoIXByb21pc2UuX2hhbmRsZWQgJiYgaXNOb2RlKSB7XG5cdFx0Z2xvYmFsLnByb2Nlc3MuZW1pdCgndW5oYW5kbGVkUmVqZWN0aW9uJywgcHJvbWlzZS5fZGF0YSwgcHJvbWlzZSk7XG5cdH1cbn1cblxuZnVuY3Rpb24gbm90aWZ5UmVqZWN0aW9uSGFuZGxlZChwcm9taXNlKSB7XG5cdGdsb2JhbC5wcm9jZXNzLmVtaXQoJ3JlamVjdGlvbkhhbmRsZWQnLCBwcm9taXNlKTtcbn1cblxuLyoqXG4gKiBAY2xhc3NcbiAqL1xuZnVuY3Rpb24gUHJvbWlzZShyZXNvbHZlcikge1xuXHRpZiAodHlwZW9mIHJlc29sdmVyICE9PSAnZnVuY3Rpb24nKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignUHJvbWlzZSByZXNvbHZlciAnICsgcmVzb2x2ZXIgKyAnIGlzIG5vdCBhIGZ1bmN0aW9uJyk7XG5cdH1cblxuXHRpZiAodGhpcyBpbnN0YW5jZW9mIFByb21pc2UgPT09IGZhbHNlKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignRmFpbGVkIHRvIGNvbnN0cnVjdCBcXCdQcm9taXNlXFwnOiBQbGVhc2UgdXNlIHRoZSBcXCduZXdcXCcgb3BlcmF0b3IsIHRoaXMgb2JqZWN0IGNvbnN0cnVjdG9yIGNhbm5vdCBiZSBjYWxsZWQgYXMgYSBmdW5jdGlvbi4nKTtcblx0fVxuXG5cdHRoaXMuX3RoZW4gPSBbXTtcblxuXHRpbnZva2VSZXNvbHZlcihyZXNvbHZlciwgdGhpcyk7XG59XG5cblByb21pc2UucHJvdG90eXBlID0ge1xuXHRjb25zdHJ1Y3RvcjogUHJvbWlzZSxcblxuXHRfc3RhdGU6IFBFTkRJTkcsXG5cdF90aGVuOiBudWxsLFxuXHRfZGF0YTogdW5kZWZpbmVkLFxuXHRfaGFuZGxlZDogZmFsc2UsXG5cblx0dGhlbjogZnVuY3Rpb24gKG9uRnVsZmlsbG1lbnQsIG9uUmVqZWN0aW9uKSB7XG5cdFx0dmFyIHN1YnNjcmliZXIgPSB7XG5cdFx0XHRvd25lcjogdGhpcyxcblx0XHRcdHRoZW46IG5ldyB0aGlzLmNvbnN0cnVjdG9yKE5PT1ApLFxuXHRcdFx0ZnVsZmlsbGVkOiBvbkZ1bGZpbGxtZW50LFxuXHRcdFx0cmVqZWN0ZWQ6IG9uUmVqZWN0aW9uXG5cdFx0fTtcblxuXHRcdGlmICgob25SZWplY3Rpb24gfHwgb25GdWxmaWxsbWVudCkgJiYgIXRoaXMuX2hhbmRsZWQpIHtcblx0XHRcdHRoaXMuX2hhbmRsZWQgPSB0cnVlO1xuXHRcdFx0aWYgKHRoaXMuX3N0YXRlID09PSBSRUpFQ1RFRCAmJiBpc05vZGUpIHtcblx0XHRcdFx0YXN5bmNDYWxsKG5vdGlmeVJlamVjdGlvbkhhbmRsZWQsIHRoaXMpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICh0aGlzLl9zdGF0ZSA9PT0gRlVMRklMTEVEIHx8IHRoaXMuX3N0YXRlID09PSBSRUpFQ1RFRCkge1xuXHRcdFx0Ly8gYWxyZWFkeSByZXNvbHZlZCwgY2FsbCBjYWxsYmFjayBhc3luY1xuXHRcdFx0YXN5bmNDYWxsKGludm9rZUNhbGxiYWNrLCBzdWJzY3JpYmVyKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gc3Vic2NyaWJlXG5cdFx0XHR0aGlzLl90aGVuLnB1c2goc3Vic2NyaWJlcik7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHN1YnNjcmliZXIudGhlbjtcblx0fSxcblxuXHRjYXRjaDogZnVuY3Rpb24gKG9uUmVqZWN0aW9uKSB7XG5cdFx0cmV0dXJuIHRoaXMudGhlbihudWxsLCBvblJlamVjdGlvbik7XG5cdH1cbn07XG5cblByb21pc2UuYWxsID0gZnVuY3Rpb24gKHByb21pc2VzKSB7XG5cdGlmICghQXJyYXkuaXNBcnJheShwcm9taXNlcykpIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdZb3UgbXVzdCBwYXNzIGFuIGFycmF5IHRvIFByb21pc2UuYWxsKCkuJyk7XG5cdH1cblxuXHRyZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuXHRcdHZhciByZXN1bHRzID0gW107XG5cdFx0dmFyIHJlbWFpbmluZyA9IDA7XG5cblx0XHRmdW5jdGlvbiByZXNvbHZlcihpbmRleCkge1xuXHRcdFx0cmVtYWluaW5nKys7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdFx0XHRcdHJlc3VsdHNbaW5kZXhdID0gdmFsdWU7XG5cdFx0XHRcdGlmICghLS1yZW1haW5pbmcpIHtcblx0XHRcdFx0XHRyZXNvbHZlKHJlc3VsdHMpO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdGZvciAodmFyIGkgPSAwLCBwcm9taXNlOyBpIDwgcHJvbWlzZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHByb21pc2UgPSBwcm9taXNlc1tpXTtcblxuXHRcdFx0aWYgKHByb21pc2UgJiYgdHlwZW9mIHByb21pc2UudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHRwcm9taXNlLnRoZW4ocmVzb2x2ZXIoaSksIHJlamVjdCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXN1bHRzW2ldID0gcHJvbWlzZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoIXJlbWFpbmluZykge1xuXHRcdFx0cmVzb2x2ZShyZXN1bHRzKTtcblx0XHR9XG5cdH0pO1xufTtcblxuUHJvbWlzZS5yYWNlID0gZnVuY3Rpb24gKHByb21pc2VzKSB7XG5cdGlmICghQXJyYXkuaXNBcnJheShwcm9taXNlcykpIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdZb3UgbXVzdCBwYXNzIGFuIGFycmF5IHRvIFByb21pc2UucmFjZSgpLicpO1xuXHR9XG5cblx0cmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcblx0XHRmb3IgKHZhciBpID0gMCwgcHJvbWlzZTsgaSA8IHByb21pc2VzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRwcm9taXNlID0gcHJvbWlzZXNbaV07XG5cblx0XHRcdGlmIChwcm9taXNlICYmIHR5cGVvZiBwcm9taXNlLnRoZW4gPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0cHJvbWlzZS50aGVuKHJlc29sdmUsIHJlamVjdCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXNvbHZlKHByb21pc2UpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSk7XG59O1xuXG5Qcm9taXNlLnJlc29sdmUgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0aWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUuY29uc3RydWN0b3IgPT09IFByb21pc2UpIHtcblx0XHRyZXR1cm4gdmFsdWU7XG5cdH1cblxuXHRyZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcblx0XHRyZXNvbHZlKHZhbHVlKTtcblx0fSk7XG59O1xuXG5Qcm9taXNlLnJlamVjdCA9IGZ1bmN0aW9uIChyZWFzb24pIHtcblx0cmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcblx0XHRyZWplY3QocmVhc29uKTtcblx0fSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFByb21pc2U7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/pinkie/index.js\n");

/***/ }),

/***/ "./node_modules/pkg-dir/index.js":
/*!***************************************!*\
  !*** ./node_modules/pkg-dir/index.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst path = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'path'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\nconst findUp = __webpack_require__(/*! find-up */ \"./node_modules/find-up/index.js\");\n\nconst pkgDir = async cwd => {\n\tconst filePath = await findUp('package.json', {cwd});\n\treturn filePath && path.dirname(filePath);\n};\n\nmodule.exports = pkgDir;\n// TODO: Remove this for the next major release\nmodule.exports[\"default\"] = pkgDir;\n\nmodule.exports.sync = cwd => {\n\tconst filePath = findUp.sync('package.json', {cwd});\n\treturn filePath && path.dirname(filePath);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcGtnLWRpci9pbmRleC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLGFBQWEsbUJBQU8sQ0FBQyxtSUFBTTtBQUMzQixlQUFlLG1CQUFPLENBQUMsZ0RBQVM7O0FBRWhDO0FBQ0EsZ0RBQWdELElBQUk7QUFDcEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseUJBQXNCOztBQUV0QixtQkFBbUI7QUFDbkIsK0NBQStDLElBQUk7QUFDbkQ7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3RvZG8tbGlzdC8uL25vZGVfbW9kdWxlcy9wa2ctZGlyL2luZGV4LmpzPzIxZTQiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcbmNvbnN0IGZpbmRVcCA9IHJlcXVpcmUoJ2ZpbmQtdXAnKTtcblxuY29uc3QgcGtnRGlyID0gYXN5bmMgY3dkID0+IHtcblx0Y29uc3QgZmlsZVBhdGggPSBhd2FpdCBmaW5kVXAoJ3BhY2thZ2UuanNvbicsIHtjd2R9KTtcblx0cmV0dXJuIGZpbGVQYXRoICYmIHBhdGguZGlybmFtZShmaWxlUGF0aCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHBrZ0Rpcjtcbi8vIFRPRE86IFJlbW92ZSB0aGlzIGZvciB0aGUgbmV4dCBtYWpvciByZWxlYXNlXG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gcGtnRGlyO1xuXG5tb2R1bGUuZXhwb3J0cy5zeW5jID0gY3dkID0+IHtcblx0Y29uc3QgZmlsZVBhdGggPSBmaW5kVXAuc3luYygncGFja2FnZS5qc29uJywge2N3ZH0pO1xuXHRyZXR1cm4gZmlsZVBhdGggJiYgcGF0aC5kaXJuYW1lKGZpbGVQYXRoKTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/pkg-dir/index.js\n");

/***/ }),

/***/ "./node_modules/strip-outer/index.js":
/*!*******************************************!*\
  !*** ./node_modules/strip-outer/index.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nvar escapeStringRegexp = __webpack_require__(/*! escape-string-regexp */ \"./node_modules/escape-string-regexp/index.js\");\n\nmodule.exports = function (str, sub) {\n\tif (typeof str !== 'string' || typeof sub !== 'string') {\n\t\tthrow new TypeError();\n\t}\n\n\tsub = escapeStringRegexp(sub);\n\treturn str.replace(new RegExp('^' + sub + '|' + sub + '$', 'g'), '');\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc3RyaXAtb3V0ZXIvaW5kZXguanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYix5QkFBeUIsbUJBQU8sQ0FBQywwRUFBc0I7O0FBRXZEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3RvZG8tbGlzdC8uL25vZGVfbW9kdWxlcy9zdHJpcC1vdXRlci9pbmRleC5qcz82ZDFjIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcbnZhciBlc2NhcGVTdHJpbmdSZWdleHAgPSByZXF1aXJlKCdlc2NhcGUtc3RyaW5nLXJlZ2V4cCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChzdHIsIHN1Yikge1xuXHRpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycgfHwgdHlwZW9mIHN1YiAhPT0gJ3N0cmluZycpIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCk7XG5cdH1cblxuXHRzdWIgPSBlc2NhcGVTdHJpbmdSZWdleHAoc3ViKTtcblx0cmV0dXJuIHN0ci5yZXBsYWNlKG5ldyBSZWdFeHAoJ14nICsgc3ViICsgJ3wnICsgc3ViICsgJyQnLCAnZycpLCAnJyk7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/strip-outer/index.js\n");

/***/ }),

/***/ "./src/style.scss":
/*!************************!*\
  !*** ./src/style.scss ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/styleDomAPI.js */ \"./node_modules/style-loader/dist/runtime/styleDomAPI.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/insertBySelector.js */ \"./node_modules/style-loader/dist/runtime/insertBySelector.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js */ \"./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/insertStyleElement.js */ \"./node_modules/style-loader/dist/runtime/insertStyleElement.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/styleTagTransform.js */ \"./node_modules/style-loader/dist/runtime/styleTagTransform.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var _node_modules_css_loader_dist_cjs_js_node_modules_sass_loader_dist_cjs_js_style_scss__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../node_modules/css-loader/dist/cjs.js!../node_modules/sass-loader/dist/cjs.js!./style.scss */ \"./node_modules/css-loader/dist/cjs.js!./node_modules/sass-loader/dist/cjs.js!./src/style.scss\");\n\n      \n      \n      \n      \n      \n      \n      \n      \n      \n\nvar options = {};\n\noptions.styleTagTransform = (_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());\noptions.setAttributes = (_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());\n\n      options.insert = _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, \"head\");\n    \noptions.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());\noptions.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());\n\nvar update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_node_modules_sass_loader_dist_cjs_js_style_scss__WEBPACK_IMPORTED_MODULE_6__[\"default\"], options);\n\n\n\n\n       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_node_modules_sass_loader_dist_cjs_js_style_scss__WEBPACK_IMPORTED_MODULE_6__[\"default\"] && _node_modules_css_loader_dist_cjs_js_node_modules_sass_loader_dist_cjs_js_style_scss__WEBPACK_IMPORTED_MODULE_6__[\"default\"].locals ? _node_modules_css_loader_dist_cjs_js_node_modules_sass_loader_dist_cjs_js_style_scss__WEBPACK_IMPORTED_MODULE_6__[\"default\"].locals : undefined);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvc3R5bGUuc2Nzcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFDQSxNQUErRjtBQUMvRixNQUFxRjtBQUNyRixNQUE0RjtBQUM1RixNQUErRztBQUMvRyxNQUF3RztBQUN4RyxNQUF3RztBQUN4RyxNQUE0STtBQUM1STtBQUNBOztBQUVBOztBQUVBLDRCQUE0QixxR0FBbUI7QUFDL0Msd0JBQXdCLGtIQUFhOztBQUVyQyx1QkFBdUIsdUdBQWE7QUFDcEM7QUFDQSxpQkFBaUIsK0ZBQU07QUFDdkIsNkJBQTZCLHNHQUFrQjs7QUFFL0MsYUFBYSwwR0FBRyxDQUFDLDRIQUFPOzs7O0FBSXNGO0FBQzlHLE9BQU8saUVBQWUsNEhBQU8sSUFBSSxtSUFBYyxHQUFHLG1JQUFjLFlBQVksRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3RvZG8tbGlzdC8uL3NyYy9zdHlsZS5zY3NzPzc1YmEiXSwic291cmNlc0NvbnRlbnQiOlsiXG4gICAgICBpbXBvcnQgQVBJIGZyb20gXCIhLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5qZWN0U3R5bGVzSW50b1N0eWxlVGFnLmpzXCI7XG4gICAgICBpbXBvcnQgZG9tQVBJIGZyb20gXCIhLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvc3R5bGVEb21BUEkuanNcIjtcbiAgICAgIGltcG9ydCBpbnNlcnRGbiBmcm9tIFwiIS4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luc2VydEJ5U2VsZWN0b3IuanNcIjtcbiAgICAgIGltcG9ydCBzZXRBdHRyaWJ1dGVzIGZyb20gXCIhLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvc2V0QXR0cmlidXRlc1dpdGhvdXRBdHRyaWJ1dGVzLmpzXCI7XG4gICAgICBpbXBvcnQgaW5zZXJ0U3R5bGVFbGVtZW50IGZyb20gXCIhLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5zZXJ0U3R5bGVFbGVtZW50LmpzXCI7XG4gICAgICBpbXBvcnQgc3R5bGVUYWdUcmFuc2Zvcm1GbiBmcm9tIFwiIS4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL3N0eWxlVGFnVHJhbnNmb3JtLmpzXCI7XG4gICAgICBpbXBvcnQgY29udGVudCwgKiBhcyBuYW1lZEV4cG9ydCBmcm9tIFwiISEuLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcyEuLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvZGlzdC9janMuanMhLi9zdHlsZS5zY3NzXCI7XG4gICAgICBcbiAgICAgIFxuXG52YXIgb3B0aW9ucyA9IHt9O1xuXG5vcHRpb25zLnN0eWxlVGFnVHJhbnNmb3JtID0gc3R5bGVUYWdUcmFuc2Zvcm1Gbjtcbm9wdGlvbnMuc2V0QXR0cmlidXRlcyA9IHNldEF0dHJpYnV0ZXM7XG5cbiAgICAgIG9wdGlvbnMuaW5zZXJ0ID0gaW5zZXJ0Rm4uYmluZChudWxsLCBcImhlYWRcIik7XG4gICAgXG5vcHRpb25zLmRvbUFQSSA9IGRvbUFQSTtcbm9wdGlvbnMuaW5zZXJ0U3R5bGVFbGVtZW50ID0gaW5zZXJ0U3R5bGVFbGVtZW50O1xuXG52YXIgdXBkYXRlID0gQVBJKGNvbnRlbnQsIG9wdGlvbnMpO1xuXG5cblxuZXhwb3J0ICogZnJvbSBcIiEhLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanMhLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vc3R5bGUuc2Nzc1wiO1xuICAgICAgIGV4cG9ydCBkZWZhdWx0IGNvbnRlbnQgJiYgY29udGVudC5sb2NhbHMgPyBjb250ZW50LmxvY2FscyA6IHVuZGVmaW5lZDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/style.scss\n");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js":
/*!****************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js ***!
  \****************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nvar stylesInDOM = [];\n\nfunction getIndexByIdentifier(identifier) {\n  var result = -1;\n\n  for (var i = 0; i < stylesInDOM.length; i++) {\n    if (stylesInDOM[i].identifier === identifier) {\n      result = i;\n      break;\n    }\n  }\n\n  return result;\n}\n\nfunction modulesToDom(list, options) {\n  var idCountMap = {};\n  var identifiers = [];\n\n  for (var i = 0; i < list.length; i++) {\n    var item = list[i];\n    var id = options.base ? item[0] + options.base : item[0];\n    var count = idCountMap[id] || 0;\n    var identifier = \"\".concat(id, \" \").concat(count);\n    idCountMap[id] = count + 1;\n    var indexByIdentifier = getIndexByIdentifier(identifier);\n    var obj = {\n      css: item[1],\n      media: item[2],\n      sourceMap: item[3],\n      supports: item[4],\n      layer: item[5]\n    };\n\n    if (indexByIdentifier !== -1) {\n      stylesInDOM[indexByIdentifier].references++;\n      stylesInDOM[indexByIdentifier].updater(obj);\n    } else {\n      var updater = addElementStyle(obj, options);\n      options.byIndex = i;\n      stylesInDOM.splice(i, 0, {\n        identifier: identifier,\n        updater: updater,\n        references: 1\n      });\n    }\n\n    identifiers.push(identifier);\n  }\n\n  return identifiers;\n}\n\nfunction addElementStyle(obj, options) {\n  var api = options.domAPI(options);\n  api.update(obj);\n\n  var updater = function updater(newObj) {\n    if (newObj) {\n      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap && newObj.supports === obj.supports && newObj.layer === obj.layer) {\n        return;\n      }\n\n      api.update(obj = newObj);\n    } else {\n      api.remove();\n    }\n  };\n\n  return updater;\n}\n\nmodule.exports = function (list, options) {\n  options = options || {};\n  list = list || [];\n  var lastIdentifiers = modulesToDom(list, options);\n  return function update(newList) {\n    newList = newList || [];\n\n    for (var i = 0; i < lastIdentifiers.length; i++) {\n      var identifier = lastIdentifiers[i];\n      var index = getIndexByIdentifier(identifier);\n      stylesInDOM[index].references--;\n    }\n\n    var newLastIdentifiers = modulesToDom(newList, options);\n\n    for (var _i = 0; _i < lastIdentifiers.length; _i++) {\n      var _identifier = lastIdentifiers[_i];\n\n      var _index = getIndexByIdentifier(_identifier);\n\n      if (stylesInDOM[_index].references === 0) {\n        stylesInDOM[_index].updater();\n\n        stylesInDOM.splice(_index, 1);\n      }\n    }\n\n    lastIdentifiers = newLastIdentifiers;\n  };\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbmplY3RTdHlsZXNJbnRvU3R5bGVUYWcuanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7O0FBRUE7QUFDQTs7QUFFQSxrQkFBa0Isd0JBQXdCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLGlCQUFpQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLDRCQUE0QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxxQkFBcUIsNkJBQTZCO0FBQ2xEOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3RvZG8tbGlzdC8uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qcz8yZGJhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG52YXIgc3R5bGVzSW5ET00gPSBbXTtcblxuZnVuY3Rpb24gZ2V0SW5kZXhCeUlkZW50aWZpZXIoaWRlbnRpZmllcikge1xuICB2YXIgcmVzdWx0ID0gLTE7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHlsZXNJbkRPTS5sZW5ndGg7IGkrKykge1xuICAgIGlmIChzdHlsZXNJbkRPTVtpXS5pZGVudGlmaWVyID09PSBpZGVudGlmaWVyKSB7XG4gICAgICByZXN1bHQgPSBpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gbW9kdWxlc1RvRG9tKGxpc3QsIG9wdGlvbnMpIHtcbiAgdmFyIGlkQ291bnRNYXAgPSB7fTtcbiAgdmFyIGlkZW50aWZpZXJzID0gW107XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGl0ZW0gPSBsaXN0W2ldO1xuICAgIHZhciBpZCA9IG9wdGlvbnMuYmFzZSA/IGl0ZW1bMF0gKyBvcHRpb25zLmJhc2UgOiBpdGVtWzBdO1xuICAgIHZhciBjb3VudCA9IGlkQ291bnRNYXBbaWRdIHx8IDA7XG4gICAgdmFyIGlkZW50aWZpZXIgPSBcIlwiLmNvbmNhdChpZCwgXCIgXCIpLmNvbmNhdChjb3VudCk7XG4gICAgaWRDb3VudE1hcFtpZF0gPSBjb3VudCArIDE7XG4gICAgdmFyIGluZGV4QnlJZGVudGlmaWVyID0gZ2V0SW5kZXhCeUlkZW50aWZpZXIoaWRlbnRpZmllcik7XG4gICAgdmFyIG9iaiA9IHtcbiAgICAgIGNzczogaXRlbVsxXSxcbiAgICAgIG1lZGlhOiBpdGVtWzJdLFxuICAgICAgc291cmNlTWFwOiBpdGVtWzNdLFxuICAgICAgc3VwcG9ydHM6IGl0ZW1bNF0sXG4gICAgICBsYXllcjogaXRlbVs1XVxuICAgIH07XG5cbiAgICBpZiAoaW5kZXhCeUlkZW50aWZpZXIgIT09IC0xKSB7XG4gICAgICBzdHlsZXNJbkRPTVtpbmRleEJ5SWRlbnRpZmllcl0ucmVmZXJlbmNlcysrO1xuICAgICAgc3R5bGVzSW5ET01baW5kZXhCeUlkZW50aWZpZXJdLnVwZGF0ZXIob2JqKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHVwZGF0ZXIgPSBhZGRFbGVtZW50U3R5bGUob2JqLCBvcHRpb25zKTtcbiAgICAgIG9wdGlvbnMuYnlJbmRleCA9IGk7XG4gICAgICBzdHlsZXNJbkRPTS5zcGxpY2UoaSwgMCwge1xuICAgICAgICBpZGVudGlmaWVyOiBpZGVudGlmaWVyLFxuICAgICAgICB1cGRhdGVyOiB1cGRhdGVyLFxuICAgICAgICByZWZlcmVuY2VzOiAxXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZGVudGlmaWVycy5wdXNoKGlkZW50aWZpZXIpO1xuICB9XG5cbiAgcmV0dXJuIGlkZW50aWZpZXJzO1xufVxuXG5mdW5jdGlvbiBhZGRFbGVtZW50U3R5bGUob2JqLCBvcHRpb25zKSB7XG4gIHZhciBhcGkgPSBvcHRpb25zLmRvbUFQSShvcHRpb25zKTtcbiAgYXBpLnVwZGF0ZShvYmopO1xuXG4gIHZhciB1cGRhdGVyID0gZnVuY3Rpb24gdXBkYXRlcihuZXdPYmopIHtcbiAgICBpZiAobmV3T2JqKSB7XG4gICAgICBpZiAobmV3T2JqLmNzcyA9PT0gb2JqLmNzcyAmJiBuZXdPYmoubWVkaWEgPT09IG9iai5tZWRpYSAmJiBuZXdPYmouc291cmNlTWFwID09PSBvYmouc291cmNlTWFwICYmIG5ld09iai5zdXBwb3J0cyA9PT0gb2JqLnN1cHBvcnRzICYmIG5ld09iai5sYXllciA9PT0gb2JqLmxheWVyKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgYXBpLnVwZGF0ZShvYmogPSBuZXdPYmopO1xuICAgIH0gZWxzZSB7XG4gICAgICBhcGkucmVtb3ZlKCk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiB1cGRhdGVyO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChsaXN0LCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBsaXN0ID0gbGlzdCB8fCBbXTtcbiAgdmFyIGxhc3RJZGVudGlmaWVycyA9IG1vZHVsZXNUb0RvbShsaXN0LCBvcHRpb25zKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZShuZXdMaXN0KSB7XG4gICAgbmV3TGlzdCA9IG5ld0xpc3QgfHwgW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxhc3RJZGVudGlmaWVycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGlkZW50aWZpZXIgPSBsYXN0SWRlbnRpZmllcnNbaV07XG4gICAgICB2YXIgaW5kZXggPSBnZXRJbmRleEJ5SWRlbnRpZmllcihpZGVudGlmaWVyKTtcbiAgICAgIHN0eWxlc0luRE9NW2luZGV4XS5yZWZlcmVuY2VzLS07XG4gICAgfVxuXG4gICAgdmFyIG5ld0xhc3RJZGVudGlmaWVycyA9IG1vZHVsZXNUb0RvbShuZXdMaXN0LCBvcHRpb25zKTtcblxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBsYXN0SWRlbnRpZmllcnMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICB2YXIgX2lkZW50aWZpZXIgPSBsYXN0SWRlbnRpZmllcnNbX2ldO1xuXG4gICAgICB2YXIgX2luZGV4ID0gZ2V0SW5kZXhCeUlkZW50aWZpZXIoX2lkZW50aWZpZXIpO1xuXG4gICAgICBpZiAoc3R5bGVzSW5ET01bX2luZGV4XS5yZWZlcmVuY2VzID09PSAwKSB7XG4gICAgICAgIHN0eWxlc0luRE9NW19pbmRleF0udXBkYXRlcigpO1xuXG4gICAgICAgIHN0eWxlc0luRE9NLnNwbGljZShfaW5kZXgsIDEpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGxhc3RJZGVudGlmaWVycyA9IG5ld0xhc3RJZGVudGlmaWVycztcbiAgfTtcbn07Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\n");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertBySelector.js":
/*!********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertBySelector.js ***!
  \********************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nvar memo = {};\n/* istanbul ignore next  */\n\nfunction getTarget(target) {\n  if (typeof memo[target] === \"undefined\") {\n    var styleTarget = document.querySelector(target); // Special case to return head of iframe instead of iframe itself\n\n    if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n      try {\n        // This will throw an exception if access to iframe is blocked\n        // due to cross-origin restrictions\n        styleTarget = styleTarget.contentDocument.head;\n      } catch (e) {\n        // istanbul ignore next\n        styleTarget = null;\n      }\n    }\n\n    memo[target] = styleTarget;\n  }\n\n  return memo[target];\n}\n/* istanbul ignore next  */\n\n\nfunction insertBySelector(insert, style) {\n  var target = getTarget(insert);\n\n  if (!target) {\n    throw new Error(\"Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.\");\n  }\n\n  target.appendChild(style);\n}\n\nmodule.exports = insertBySelector;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbnNlcnRCeVNlbGVjdG9yLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNEQUFzRDs7QUFFdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3RvZG8tbGlzdC8uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luc2VydEJ5U2VsZWN0b3IuanM/YjIxNCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxudmFyIG1lbW8gPSB7fTtcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICAqL1xuXG5mdW5jdGlvbiBnZXRUYXJnZXQodGFyZ2V0KSB7XG4gIGlmICh0eXBlb2YgbWVtb1t0YXJnZXRdID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgdmFyIHN0eWxlVGFyZ2V0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0YXJnZXQpOyAvLyBTcGVjaWFsIGNhc2UgdG8gcmV0dXJuIGhlYWQgb2YgaWZyYW1lIGluc3RlYWQgb2YgaWZyYW1lIGl0c2VsZlxuXG4gICAgaWYgKHdpbmRvdy5IVE1MSUZyYW1lRWxlbWVudCAmJiBzdHlsZVRhcmdldCBpbnN0YW5jZW9mIHdpbmRvdy5IVE1MSUZyYW1lRWxlbWVudCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gVGhpcyB3aWxsIHRocm93IGFuIGV4Y2VwdGlvbiBpZiBhY2Nlc3MgdG8gaWZyYW1lIGlzIGJsb2NrZWRcbiAgICAgICAgLy8gZHVlIHRvIGNyb3NzLW9yaWdpbiByZXN0cmljdGlvbnNcbiAgICAgICAgc3R5bGVUYXJnZXQgPSBzdHlsZVRhcmdldC5jb250ZW50RG9jdW1lbnQuaGVhZDtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gaXN0YW5idWwgaWdub3JlIG5leHRcbiAgICAgICAgc3R5bGVUYXJnZXQgPSBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIG1lbW9bdGFyZ2V0XSA9IHN0eWxlVGFyZ2V0O1xuICB9XG5cbiAgcmV0dXJuIG1lbW9bdGFyZ2V0XTtcbn1cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICAqL1xuXG5cbmZ1bmN0aW9uIGluc2VydEJ5U2VsZWN0b3IoaW5zZXJ0LCBzdHlsZSkge1xuICB2YXIgdGFyZ2V0ID0gZ2V0VGFyZ2V0KGluc2VydCk7XG5cbiAgaWYgKCF0YXJnZXQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZG4ndCBmaW5kIGEgc3R5bGUgdGFyZ2V0LiBUaGlzIHByb2JhYmx5IG1lYW5zIHRoYXQgdGhlIHZhbHVlIGZvciB0aGUgJ2luc2VydCcgcGFyYW1ldGVyIGlzIGludmFsaWQuXCIpO1xuICB9XG5cbiAgdGFyZ2V0LmFwcGVuZENoaWxkKHN0eWxlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpbnNlcnRCeVNlbGVjdG9yOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/style-loader/dist/runtime/insertBySelector.js\n");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertStyleElement.js":
/*!**********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertStyleElement.js ***!
  \**********************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/* istanbul ignore next  */\nfunction insertStyleElement(options) {\n  var element = document.createElement(\"style\");\n  options.setAttributes(element, options.attributes);\n  options.insert(element, options.options);\n  return element;\n}\n\nmodule.exports = insertStyleElement;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbnNlcnRTdHlsZUVsZW1lbnQuanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90b2RvLWxpc3QvLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbnNlcnRTdHlsZUVsZW1lbnQuanM/ZGU2YyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgICovXG5mdW5jdGlvbiBpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucykge1xuICB2YXIgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtcbiAgb3B0aW9ucy5zZXRBdHRyaWJ1dGVzKGVsZW1lbnQsIG9wdGlvbnMuYXR0cmlidXRlcyk7XG4gIG9wdGlvbnMuaW5zZXJ0KGVsZW1lbnQsIG9wdGlvbnMub3B0aW9ucyk7XG4gIHJldHVybiBlbGVtZW50O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGluc2VydFN0eWxlRWxlbWVudDsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/style-loader/dist/runtime/insertStyleElement.js\n");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n/* istanbul ignore next  */\nfunction setAttributesWithoutAttributes(styleElement) {\n  var nonce =  true ? __webpack_require__.nc : 0;\n\n  if (nonce) {\n    styleElement.setAttribute(\"nonce\", nonce);\n  }\n}\n\nmodule.exports = setAttributesWithoutAttributes;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9zZXRBdHRyaWJ1dGVzV2l0aG91dEF0dHJpYnV0ZXMuanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBLGNBQWMsS0FBd0MsR0FBRyxzQkFBaUIsR0FBRyxDQUFJOztBQUVqRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3RvZG8tbGlzdC8uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL3NldEF0dHJpYnV0ZXNXaXRob3V0QXR0cmlidXRlcy5qcz9kZGNlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAgKi9cbmZ1bmN0aW9uIHNldEF0dHJpYnV0ZXNXaXRob3V0QXR0cmlidXRlcyhzdHlsZUVsZW1lbnQpIHtcbiAgdmFyIG5vbmNlID0gdHlwZW9mIF9fd2VicGFja19ub25jZV9fICE9PSBcInVuZGVmaW5lZFwiID8gX193ZWJwYWNrX25vbmNlX18gOiBudWxsO1xuXG4gIGlmIChub25jZSkge1xuICAgIHN0eWxlRWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJub25jZVwiLCBub25jZSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzZXRBdHRyaWJ1dGVzV2l0aG91dEF0dHJpYnV0ZXM7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js\n");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleDomAPI.js":
/*!***************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleDomAPI.js ***!
  \***************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/* istanbul ignore next  */\nfunction apply(styleElement, options, obj) {\n  var css = \"\";\n\n  if (obj.supports) {\n    css += \"@supports (\".concat(obj.supports, \") {\");\n  }\n\n  if (obj.media) {\n    css += \"@media \".concat(obj.media, \" {\");\n  }\n\n  var needLayer = typeof obj.layer !== \"undefined\";\n\n  if (needLayer) {\n    css += \"@layer\".concat(obj.layer.length > 0 ? \" \".concat(obj.layer) : \"\", \" {\");\n  }\n\n  css += obj.css;\n\n  if (needLayer) {\n    css += \"}\";\n  }\n\n  if (obj.media) {\n    css += \"}\";\n  }\n\n  if (obj.supports) {\n    css += \"}\";\n  }\n\n  var sourceMap = obj.sourceMap;\n\n  if (sourceMap && typeof btoa !== \"undefined\") {\n    css += \"\\n/*# sourceMappingURL=data:application/json;base64,\".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), \" */\");\n  } // For old IE\n\n  /* istanbul ignore if  */\n\n\n  options.styleTagTransform(css, styleElement, options.options);\n}\n\nfunction removeStyleElement(styleElement) {\n  // istanbul ignore if\n  if (styleElement.parentNode === null) {\n    return false;\n  }\n\n  styleElement.parentNode.removeChild(styleElement);\n}\n/* istanbul ignore next  */\n\n\nfunction domAPI(options) {\n  var styleElement = options.insertStyleElement(options);\n  return {\n    update: function update(obj) {\n      apply(styleElement, options, obj);\n    },\n    remove: function remove() {\n      removeStyleElement(styleElement);\n    }\n  };\n}\n\nmodule.exports = domAPI;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9zdHlsZURvbUFQSS5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrREFBa0Q7QUFDbEQ7O0FBRUE7QUFDQSwwQ0FBMEM7QUFDMUM7O0FBRUE7O0FBRUE7QUFDQSxpRkFBaUY7QUFDakY7O0FBRUE7O0FBRUE7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7O0FBRUE7QUFDQSx5REFBeUQ7QUFDekQsSUFBSTs7QUFFSjs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdG9kby1saXN0Ly4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvc3R5bGVEb21BUEkuanM/ZTQ3OSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgICovXG5mdW5jdGlvbiBhcHBseShzdHlsZUVsZW1lbnQsIG9wdGlvbnMsIG9iaikge1xuICB2YXIgY3NzID0gXCJcIjtcblxuICBpZiAob2JqLnN1cHBvcnRzKSB7XG4gICAgY3NzICs9IFwiQHN1cHBvcnRzIChcIi5jb25jYXQob2JqLnN1cHBvcnRzLCBcIikge1wiKTtcbiAgfVxuXG4gIGlmIChvYmoubWVkaWEpIHtcbiAgICBjc3MgKz0gXCJAbWVkaWEgXCIuY29uY2F0KG9iai5tZWRpYSwgXCIge1wiKTtcbiAgfVxuXG4gIHZhciBuZWVkTGF5ZXIgPSB0eXBlb2Ygb2JqLmxheWVyICE9PSBcInVuZGVmaW5lZFwiO1xuXG4gIGlmIChuZWVkTGF5ZXIpIHtcbiAgICBjc3MgKz0gXCJAbGF5ZXJcIi5jb25jYXQob2JqLmxheWVyLmxlbmd0aCA+IDAgPyBcIiBcIi5jb25jYXQob2JqLmxheWVyKSA6IFwiXCIsIFwiIHtcIik7XG4gIH1cblxuICBjc3MgKz0gb2JqLmNzcztcblxuICBpZiAobmVlZExheWVyKSB7XG4gICAgY3NzICs9IFwifVwiO1xuICB9XG5cbiAgaWYgKG9iai5tZWRpYSkge1xuICAgIGNzcyArPSBcIn1cIjtcbiAgfVxuXG4gIGlmIChvYmouc3VwcG9ydHMpIHtcbiAgICBjc3MgKz0gXCJ9XCI7XG4gIH1cblxuICB2YXIgc291cmNlTWFwID0gb2JqLnNvdXJjZU1hcDtcblxuICBpZiAoc291cmNlTWFwICYmIHR5cGVvZiBidG9hICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgY3NzICs9IFwiXFxuLyojIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxcIi5jb25jYXQoYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkpKSwgXCIgKi9cIik7XG4gIH0gLy8gRm9yIG9sZCBJRVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAgKi9cblxuXG4gIG9wdGlvbnMuc3R5bGVUYWdUcmFuc2Zvcm0oY3NzLCBzdHlsZUVsZW1lbnQsIG9wdGlvbnMub3B0aW9ucyk7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZUVsZW1lbnQpIHtcbiAgLy8gaXN0YW5idWwgaWdub3JlIGlmXG4gIGlmIChzdHlsZUVsZW1lbnQucGFyZW50Tm9kZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHN0eWxlRWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHN0eWxlRWxlbWVudCk7XG59XG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAgKi9cblxuXG5mdW5jdGlvbiBkb21BUEkob3B0aW9ucykge1xuICB2YXIgc3R5bGVFbGVtZW50ID0gb3B0aW9ucy5pbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucyk7XG4gIHJldHVybiB7XG4gICAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUob2JqKSB7XG4gICAgICBhcHBseShzdHlsZUVsZW1lbnQsIG9wdGlvbnMsIG9iaik7XG4gICAgfSxcbiAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZSgpIHtcbiAgICAgIHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZUVsZW1lbnQpO1xuICAgIH1cbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBkb21BUEk7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/style-loader/dist/runtime/styleDomAPI.js\n");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleTagTransform.js":
/*!*********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleTagTransform.js ***!
  \*********************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/* istanbul ignore next  */\nfunction styleTagTransform(css, styleElement) {\n  if (styleElement.styleSheet) {\n    styleElement.styleSheet.cssText = css;\n  } else {\n    while (styleElement.firstChild) {\n      styleElement.removeChild(styleElement.firstChild);\n    }\n\n    styleElement.appendChild(document.createTextNode(css));\n  }\n}\n\nmodule.exports = styleTagTransform;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9zdHlsZVRhZ1RyYW5zZm9ybS5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdG9kby1saXN0Ly4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvc3R5bGVUYWdUcmFuc2Zvcm0uanM/MWRkZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgICovXG5mdW5jdGlvbiBzdHlsZVRhZ1RyYW5zZm9ybShjc3MsIHN0eWxlRWxlbWVudCkge1xuICBpZiAoc3R5bGVFbGVtZW50LnN0eWxlU2hlZXQpIHtcbiAgICBzdHlsZUVsZW1lbnQuc3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzO1xuICB9IGVsc2Uge1xuICAgIHdoaWxlIChzdHlsZUVsZW1lbnQuZmlyc3RDaGlsZCkge1xuICAgICAgc3R5bGVFbGVtZW50LnJlbW92ZUNoaWxkKHN0eWxlRWxlbWVudC5maXJzdENoaWxkKTtcbiAgICB9XG5cbiAgICBzdHlsZUVsZW1lbnQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdHlsZVRhZ1RyYW5zZm9ybTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/style-loader/dist/runtime/styleTagTransform.js\n");

/***/ }),

/***/ "./node_modules/trim-repeated/index.js":
/*!*********************************************!*\
  !*** ./node_modules/trim-repeated/index.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nvar escapeStringRegexp = __webpack_require__(/*! escape-string-regexp */ \"./node_modules/escape-string-regexp/index.js\");\n\nmodule.exports = function (str, target) {\n\tif (typeof str !== 'string' || typeof target !== 'string') {\n\t\tthrow new TypeError('Expected a string');\n\t}\n\n\treturn str.replace(new RegExp('(?:' + escapeStringRegexp(target) + '){2,}', 'g'), target);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdHJpbS1yZXBlYXRlZC9pbmRleC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLHlCQUF5QixtQkFBTyxDQUFDLDBFQUFzQjs7QUFFdkQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUVBQXVFLEdBQUc7QUFDMUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90b2RvLWxpc3QvLi9ub2RlX21vZHVsZXMvdHJpbS1yZXBlYXRlZC9pbmRleC5qcz80ODQ1Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcbnZhciBlc2NhcGVTdHJpbmdSZWdleHAgPSByZXF1aXJlKCdlc2NhcGUtc3RyaW5nLXJlZ2V4cCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChzdHIsIHRhcmdldCkge1xuXHRpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycgfHwgdHlwZW9mIHRhcmdldCAhPT0gJ3N0cmluZycpIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBhIHN0cmluZycpO1xuXHR9XG5cblx0cmV0dXJuIHN0ci5yZXBsYWNlKG5ldyBSZWdFeHAoJyg/OicgKyBlc2NhcGVTdHJpbmdSZWdleHAodGFyZ2V0KSArICcpezIsfScsICdnJyksIHRhcmdldCk7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/trim-repeated/index.js\n");

/***/ }),

/***/ "./node_modules/universalify/index.js":
/*!********************************************!*\
  !*** ./node_modules/universalify/index.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nexports.fromCallback = function (fn) {\n  return Object.defineProperty(function () {\n    if (typeof arguments[arguments.length - 1] === 'function') fn.apply(this, arguments)\n    else {\n      return new Promise((resolve, reject) => {\n        arguments[arguments.length] = (err, res) => {\n          if (err) return reject(err)\n          resolve(res)\n        }\n        arguments.length++\n        fn.apply(this, arguments)\n      })\n    }\n  }, 'name', { value: fn.name })\n}\n\nexports.fromPromise = function (fn) {\n  return Object.defineProperty(function () {\n    const cb = arguments[arguments.length - 1]\n    if (typeof cb !== 'function') return fn.apply(this, arguments)\n    else fn.apply(this, arguments).then(r => cb(null, r), cb)\n  }, 'name', { value: fn.name })\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdW5pdmVyc2FsaWZ5L2luZGV4LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUcsWUFBWSxnQkFBZ0I7QUFDL0I7O0FBRUEsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxZQUFZLGdCQUFnQjtBQUMvQiIsInNvdXJjZXMiOlsid2VicGFjazovL3RvZG8tbGlzdC8uL25vZGVfbW9kdWxlcy91bml2ZXJzYWxpZnkvaW5kZXguanM/NjQyZSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuZXhwb3J0cy5mcm9tQ2FsbGJhY2sgPSBmdW5jdGlvbiAoZm4pIHtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHR5cGVvZiBhcmd1bWVudHNbYXJndW1lbnRzLmxlbmd0aCAtIDFdID09PSAnZnVuY3Rpb24nKSBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gICAgZWxzZSB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBhcmd1bWVudHNbYXJndW1lbnRzLmxlbmd0aF0gPSAoZXJyLCByZXMpID0+IHtcbiAgICAgICAgICBpZiAoZXJyKSByZXR1cm4gcmVqZWN0KGVycilcbiAgICAgICAgICByZXNvbHZlKHJlcylcbiAgICAgICAgfVxuICAgICAgICBhcmd1bWVudHMubGVuZ3RoKytcbiAgICAgICAgZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICAgICAgfSlcbiAgICB9XG4gIH0sICduYW1lJywgeyB2YWx1ZTogZm4ubmFtZSB9KVxufVxuXG5leHBvcnRzLmZyb21Qcm9taXNlID0gZnVuY3Rpb24gKGZuKSB7XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoZnVuY3Rpb24gKCkge1xuICAgIGNvbnN0IGNiID0gYXJndW1lbnRzW2FyZ3VtZW50cy5sZW5ndGggLSAxXVxuICAgIGlmICh0eXBlb2YgY2IgIT09ICdmdW5jdGlvbicpIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gICAgZWxzZSBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpLnRoZW4ociA9PiBjYihudWxsLCByKSwgY2IpXG4gIH0sICduYW1lJywgeyB2YWx1ZTogZm4ubmFtZSB9KVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/universalify/index.js\n");

/***/ }),

/***/ "./node_modules/wrappy/wrappy.js":
/*!***************************************!*\
  !*** ./node_modules/wrappy/wrappy.js ***!
  \***************************************/
/***/ ((module) => {

eval("// Returns a wrapper function that returns a wrapped callback\n// The wrapper function should do some stuff, and return a\n// presumably different callback function.\n// This makes sure that own properties are retained, so that\n// decorations and such are not lost along the way.\nmodule.exports = wrappy\nfunction wrappy (fn, cb) {\n  if (fn && cb) return wrappy(fn)(cb)\n\n  if (typeof fn !== 'function')\n    throw new TypeError('need wrapper function')\n\n  Object.keys(fn).forEach(function (k) {\n    wrapper[k] = fn[k]\n  })\n\n  return wrapper\n\n  function wrapper() {\n    var args = new Array(arguments.length)\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i]\n    }\n    var ret = fn.apply(this, args)\n    var cb = args[args.length-1]\n    if (typeof ret === 'function' && ret !== cb) {\n      Object.keys(cb).forEach(function (k) {\n        ret[k] = cb[k]\n      })\n    }\n    return ret\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvd3JhcHB5L3dyYXBweS5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90b2RvLWxpc3QvLi9ub2RlX21vZHVsZXMvd3JhcHB5L3dyYXBweS5qcz9kNjMzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIFJldHVybnMgYSB3cmFwcGVyIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIHdyYXBwZWQgY2FsbGJhY2tcbi8vIFRoZSB3cmFwcGVyIGZ1bmN0aW9uIHNob3VsZCBkbyBzb21lIHN0dWZmLCBhbmQgcmV0dXJuIGFcbi8vIHByZXN1bWFibHkgZGlmZmVyZW50IGNhbGxiYWNrIGZ1bmN0aW9uLlxuLy8gVGhpcyBtYWtlcyBzdXJlIHRoYXQgb3duIHByb3BlcnRpZXMgYXJlIHJldGFpbmVkLCBzbyB0aGF0XG4vLyBkZWNvcmF0aW9ucyBhbmQgc3VjaCBhcmUgbm90IGxvc3QgYWxvbmcgdGhlIHdheS5cbm1vZHVsZS5leHBvcnRzID0gd3JhcHB5XG5mdW5jdGlvbiB3cmFwcHkgKGZuLCBjYikge1xuICBpZiAoZm4gJiYgY2IpIHJldHVybiB3cmFwcHkoZm4pKGNiKVxuXG4gIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbmVlZCB3cmFwcGVyIGZ1bmN0aW9uJylcblxuICBPYmplY3Qua2V5cyhmbikuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICAgIHdyYXBwZXJba10gPSBmbltrXVxuICB9KVxuXG4gIHJldHVybiB3cmFwcGVyXG5cbiAgZnVuY3Rpb24gd3JhcHBlcigpIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoKVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXVxuICAgIH1cbiAgICB2YXIgcmV0ID0gZm4uYXBwbHkodGhpcywgYXJncylcbiAgICB2YXIgY2IgPSBhcmdzW2FyZ3MubGVuZ3RoLTFdXG4gICAgaWYgKHR5cGVvZiByZXQgPT09ICdmdW5jdGlvbicgJiYgcmV0ICE9PSBjYikge1xuICAgICAgT2JqZWN0LmtleXMoY2IpLmZvckVhY2goZnVuY3Rpb24gKGspIHtcbiAgICAgICAgcmV0W2tdID0gY2Jba11cbiAgICAgIH0pXG4gICAgfVxuICAgIHJldHVybiByZXRcbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/wrappy/wrappy.js\n");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _style_scss__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./style.scss */ \"./src/style.scss\");\n/* harmony import */ var _js_addToDo__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./js/addToDo */ \"./src/js/addToDo.js\");\n/* harmony import */ var _js_documentParts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./js/documentParts */ \"./src/js/documentParts.js\");\n/* harmony import */ var _js_projectPageGeneration__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./js/projectPageGeneration */ \"./src/js/projectPageGeneration.js\");\n/* harmony import */ var _js_addListeners__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./js/addListeners */ \"./src/js/addListeners.js\");\n\n\n\n\n\n\n\n\n(0,_js_addListeners__WEBPACK_IMPORTED_MODULE_4__.addEventListeners)();\n\n\nconst ghpages = __webpack_require__(/*! gh-pages */ \"./node_modules/gh-pages/lib/index.js\");\n\nghpages.publish('dist', function(err) {});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvaW5kZXguanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQXNCO0FBQ0E7QUFDYTtBQUNDO0FBQ2tCOzs7O0FBSXRELG1FQUFpQjs7O0FBR2pCLGdCQUFnQixtQkFBTyxDQUFDLHNEQUFVOztBQUVsQyx3Q0FBd0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90b2RvLWxpc3QvLi9zcmMvaW5kZXguanM/YjYzNSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgJy4vc3R5bGUuc2Nzcyc7XG5pbXBvcnQgJy4vanMvYWRkVG9Ebyc7XG5pbXBvcnQgXyBmcm9tICcuL2pzL2RvY3VtZW50UGFydHMnO1xuaW1wb3J0ICcuL2pzL3Byb2plY3RQYWdlR2VuZXJhdGlvbic7XG5pbXBvcnQgeyBhZGRFdmVudExpc3RlbmVycyB9IGZyb20gJy4vanMvYWRkTGlzdGVuZXJzJztcblxuXG5cbmFkZEV2ZW50TGlzdGVuZXJzKCk7XG5cblxuY29uc3QgZ2hwYWdlcyA9IHJlcXVpcmUoJ2doLXBhZ2VzJyk7XG5cbmdocGFnZXMucHVibGlzaCgnZGlzdCcsIGZ1bmN0aW9uKGVycikge30pO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/index.js\n");

/***/ }),

/***/ "./src/js/addListeners.js":
/*!********************************!*\
  !*** ./src/js/addListeners.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"addEventListeners\": () => (/* binding */ addEventListeners),\n/* harmony export */   \"loadProject\": () => (/* binding */ loadProject)\n/* harmony export */ });\n/* harmony import */ var _documentParts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./documentParts */ \"./src/js/documentParts.js\");\n/* harmony import */ var _defaultProjects__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./defaultProjects */ \"./src/js/defaultProjects.js\");\n/* harmony import */ var _addToDo__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./addToDo */ \"./src/js/addToDo.js\");\n/* harmony import */ var _createModals__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./createModals */ \"./src/js/createModals.js\");\n/* harmony import */ var _time__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./time */ \"./src/js/time.js\");\n/* harmony import */ var _project__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./project */ \"./src/js/project.js\");\n\n\n\n\n\n\n\nconst addEventListeners = () => {\n    // remove toDo\n    const trashBtns = document.querySelectorAll('.fa-trash-can');\n    for (let i = 0; i < trashBtns.length; i++) {\n        trashBtns[i].addEventListener('click', deleteToDo);\n    }\n    // mark complete\n    const uncheckedBoxes = document.querySelectorAll('.fa-square');\n    for (let i = 0; i < uncheckedBoxes.length; i++) {\n        uncheckedBoxes[i].addEventListener('click', completeToDo);\n    }\n    // mark incomplete\n    const checkedBoxes = document.querySelectorAll('.fa-square-check');\n    for (let i = 0; i < checkedBoxes.length; i++) {\n        checkedBoxes[i].addEventListener('click', undoToDoCompletion);\n    }\n    // edit toDo modal\n    const editModalBtns = document.querySelectorAll('.fa-pen-to-square');\n    for (let i = 0; i < editModalBtns.length; i++) {\n        editModalBtns[i].addEventListener('click', instantiateEditModal);\n    }\n    // create toDo modal\n    _documentParts__WEBPACK_IMPORTED_MODULE_0__[\"default\"].addToDoBtn.addEventListener('click', instantiateCreationModal);\n    // create project modal\n    _documentParts__WEBPACK_IMPORTED_MODULE_0__[\"default\"].addProjectBtn.addEventListener('click', instantiateProjectModal);\n    // remove project modal\n    const removeProjectBtns = document.querySelectorAll('.fa-circle-minus');\n    for (let i = 0; i < removeProjectBtns.length; i++) {\n        removeProjectBtns[i].addEventListener('click', removeProject);\n    }\n    \n};\n\n\n// selectedProject ex. defaults.listOfProjects[defaults.currentProjectIndex]\n_documentParts__WEBPACK_IMPORTED_MODULE_0__[\"default\"].sidebar.addEventListener('click', loadProject);\n\nfunction loadProject (e) {\n    if(e.target.classList.contains('otherProjects')){\n        // setup\n        const projIndex = e.target.getAttribute('data-index');\n        _defaultProjects__WEBPACK_IMPORTED_MODULE_1__[\"default\"].currentProjectIndex = projIndex;\n        _documentParts__WEBPACK_IMPORTED_MODULE_0__[\"default\"].table.textContent = '';\n        // generateTableHeader \n        let tr = document.createElement('tr');\n        tr.classList.add('titles');\n        let thProjName = document.createElement('th');\n        thProjName.classList.add('projName');\n\n        if (_defaultProjects__WEBPACK_IMPORTED_MODULE_1__[\"default\"].listOfProjects[_defaultProjects__WEBPACK_IMPORTED_MODULE_1__[\"default\"].currentProjectIndex].getTitle().length > 0){\n            thProjName.textContent = _defaultProjects__WEBPACK_IMPORTED_MODULE_1__[\"default\"].listOfProjects[_defaultProjects__WEBPACK_IMPORTED_MODULE_1__[\"default\"].currentProjectIndex].getTitle().substring(0,30);\n        }\n        else{\n            thProjName.textContent = 'Unnamed';\n        }\n        let thDueDate = document.createElement('th');\n        thDueDate.classList.add('dueDate');\n        thDueDate.innerHTML = `Due Date <i class=\"fa-solid fa-calendar-day\"></i>`;\n        tr.appendChild(thProjName);\n        tr.appendChild(thDueDate);\n        _documentParts__WEBPACK_IMPORTED_MODULE_0__[\"default\"].table.appendChild(tr);\n        // generate rows\n        const makeRow = (row) => {\n            const tr = document.createElement('tr');\n            tr.classList.add('createdRow');\n            tr.setAttribute('data-index', `${row.getID()}`);\n            const td1 = document.createElement('td');\n            const td2 = document.createElement('td');\n            td1.classList.add('column1');\n            td2.classList.add('column2');\n\n            _documentParts__WEBPACK_IMPORTED_MODULE_0__[\"default\"].setPriorityColors(row.getPriority(), td1);\n    \n            td1.innerHTML = `<i class=\"fa-regular fa-square\"></i> ${row.getTitle()}`;\n            td2.innerHTML = `${(0,_time__WEBPACK_IMPORTED_MODULE_4__.dateFilter)(row.getDueDate())} <i class=\"fa-regular fa-pen-to-square\"></i><i class=\"fa-regular fa-trash-can\"></i>`;\n    \n            tr.appendChild(td1);\n            tr.appendChild(td2);\n    \n            return tr;\n        };\n    \n        for (let i = 0; i < _defaultProjects__WEBPACK_IMPORTED_MODULE_1__[\"default\"].listOfProjects[_defaultProjects__WEBPACK_IMPORTED_MODULE_1__[\"default\"].currentProjectIndex].arr.length; i++) {\n            _documentParts__WEBPACK_IMPORTED_MODULE_0__[\"default\"].table.appendChild(makeRow(_defaultProjects__WEBPACK_IMPORTED_MODULE_1__[\"default\"].listOfProjects[_defaultProjects__WEBPACK_IMPORTED_MODULE_1__[\"default\"].currentProjectIndex].arr[i]));\n        }\n\n        if(!_documentParts__WEBPACK_IMPORTED_MODULE_0__[\"default\"].toDoList.contains(_documentParts__WEBPACK_IMPORTED_MODULE_0__[\"default\"].addToDoBtn)){\n            _documentParts__WEBPACK_IMPORTED_MODULE_0__[\"default\"].toDoList.appendChild(_documentParts__WEBPACK_IMPORTED_MODULE_0__[\"default\"].addToDoBtn);\n        }\n\n        // addEventListeners()\n        addEventListeners();\n    }\n};\n\nconst deleteToDo = (e) => {\n    const item = e.target;\n    const todo = item.parentElement.parentElement;\n    todo.remove();\n\n    const removeFromArray = () => {\n        let targetIndex = todo.getAttribute('data-index');\n        let list = _defaultProjects__WEBPACK_IMPORTED_MODULE_1__[\"default\"].listOfProjects;\n        let index = _defaultProjects__WEBPACK_IMPORTED_MODULE_1__[\"default\"].currentProjectIndex;\n\n        for (let i = 0; i < list[index].arr.length; i++) {\n            let id = list[index].arr[i].getID();\n            if (id == targetIndex) {\n                list[index].removeFromList(id);\n                list[1].removeFromList(id);\n            }\n        }\n        \n    };\n    removeFromArray();\n};\n\nconst completeToDo = (e) => {\n    const item = e.target;\n    const todo = item.parentElement.parentElement;\n    todo.classList.add('completed');\n    todo.innerHTML = todo.innerHTML.replace('<i class=\"fa-regular fa-square\"></i>', '<i class=\"fa-regular fa-square-check\"></i>');\n    addEventListeners();\n};\n\nconst undoToDoCompletion = (e) => {\n    const item = e.target;\n    const todo = item.parentElement.parentElement;\n    todo.classList.remove('completed');\n    todo.innerHTML = todo.innerHTML.replace('<i class=\"fa-regular fa-square-check\"></i>', '<i class=\"fa-regular fa-square\"></i>');\n    addEventListeners();\n};\n\nconst instantiateEditModal = (e) => {\n\n    const item = e.target;\n    const todo = item.parentElement.parentElement;\n    const targetIndex = todo.getAttribute('data-index');\n    const shortHand = _defaultProjects__WEBPACK_IMPORTED_MODULE_1__[\"default\"].listOfProjects[_defaultProjects__WEBPACK_IMPORTED_MODULE_1__[\"default\"].currentProjectIndex];\n\n    const getToDoInfo = () => {\n        for (let i = 0; i < shortHand.arr.length; i++) {\n            if (shortHand.arr[i].getID() == targetIndex) {\n                let name = shortHand.arr[i].getTitle();\n                let description = shortHand.arr[i].getDescription();\n                let dueDate = shortHand.arr[i].getDueDate();\n                let priority = shortHand.arr[i].getPriority();\n                let id = i;\n                return { name, description, dueDate, priority, id };\n            }\n        }\n    };\n\n    const toDoInfo = getToDoInfo();\n    const form = (0,_createModals__WEBPACK_IMPORTED_MODULE_3__.createEditModal)(toDoInfo.name, toDoInfo.description,\n        toDoInfo.dueDate, toDoInfo.priority);\n\n    _documentParts__WEBPACK_IMPORTED_MODULE_0__[\"default\"].body.appendChild(form.newModal);\n    form.newModal.showModal();\n\n    const submitEditBtn = document.querySelector('.submitEditBtn');\n    const cancelEditBtn = document.querySelector('.cancelEditBtn');\n\n    cancelEditBtn.addEventListener('click', function cancelEditModal(e) {\n        e.preventDefault();\n        form.newModal.close();\n        _documentParts__WEBPACK_IMPORTED_MODULE_0__[\"default\"].body.removeChild(form.newModal);\n        addEventListeners();\n    });\n\n    submitEditBtn.addEventListener('click', function submitEditModal(e) {\n        e.preventDefault();\n\n        // update Arr values\n\n        shortHand.arr[toDoInfo.id].setTitle(form.taskName.value);\n        shortHand.arr[toDoInfo.id].setDescription(form.taskDescription.value);\n        shortHand.arr[toDoInfo.id].setDueDate(form.taskDueDate.value);\n        shortHand.arr[toDoInfo.id].setPriority(form.taskPriority.value);\n\n        // update table values\n        todo.children[0].innerHTML = `<i class=\"fa-regular fa-square\"></i> ${form.taskName.value}`;\n        \n        _documentParts__WEBPACK_IMPORTED_MODULE_0__[\"default\"].setPriorityColors(form.taskPriority.value, todo.children[0]);\n\n        if (form.taskDueDate.value !== '') {\n            let filteredDueDate = (0,_time__WEBPACK_IMPORTED_MODULE_4__.dateFilter)(form.taskDueDate.value);\n            todo.children[1].innerHTML = `${filteredDueDate} <i class=\"fa-regular fa-pen-to-square\"></i><i class=\"fa-regular fa-trash-can\"></i>`;\n        }\n        else {\n            todo.children[1].innerHTML = `<i class=\"fa-regular fa-pen-to-square\"></i><i class=\"fa-regular fa-trash-can\"></i>`;\n        }\n\n        _documentParts__WEBPACK_IMPORTED_MODULE_0__[\"default\"].body.removeChild(form.newModal);\n        addEventListeners();\n    });\n};\n\nconst instantiateCreationModal = (e) => {\n    e.preventDefault();\n\n    _documentParts__WEBPACK_IMPORTED_MODULE_0__[\"default\"].modal.showModal();\n\n    // set default date value to now\n    let dueDate = document.querySelector('#createTaskDueDate');\n    dueDate.setAttribute(\"value\", `${(0,_time__WEBPACK_IMPORTED_MODULE_4__.now)()}`);\n\n    _documentParts__WEBPACK_IMPORTED_MODULE_0__[\"default\"].modalCancelBtn.addEventListener('click', function cancelCreationModal() {\n        _documentParts__WEBPACK_IMPORTED_MODULE_0__[\"default\"].modal.close();\n    });\n\n    _documentParts__WEBPACK_IMPORTED_MODULE_0__[\"default\"].modalSubmitBtn.addEventListener('click', _addToDo__WEBPACK_IMPORTED_MODULE_2__.addToDoToTable);\n    addEventListeners();\n};\n\nconst instantiateProjectModal = (e) => {\n\n    e.preventDefault();\n\n    const proj = (0,_createModals__WEBPACK_IMPORTED_MODULE_3__.createProjectModal)();\n    _documentParts__WEBPACK_IMPORTED_MODULE_0__[\"default\"].body.appendChild(proj.newModal);\n\n    proj.newModal.showModal();\n\n    const submitProjectBtn = document.querySelector('.submitProjectBtn');\n    const cancelProjectBtn = document.querySelector('.cancelProjectBtn');\n\n    cancelProjectBtn.addEventListener('click', function cancelProjectModal(e) {\n        e.preventDefault();\n        proj.newModal.close();\n        _documentParts__WEBPACK_IMPORTED_MODULE_0__[\"default\"].body.removeChild(proj.newModal);\n        addEventListeners();\n    });\n\n    submitProjectBtn.addEventListener('click', function submitProjectModal(e) {\n        e.preventDefault();\n\n        // create new project\n        const newProj = (0,_project__WEBPACK_IMPORTED_MODULE_5__.Project)(proj.projectName.value, _defaultProjects__WEBPACK_IMPORTED_MODULE_1__[\"default\"].projectCount);\n        _defaultProjects__WEBPACK_IMPORTED_MODULE_1__[\"default\"].projectCount++;\n\n        proj.newModal.close();\n        _documentParts__WEBPACK_IMPORTED_MODULE_0__[\"default\"].body.removeChild(proj.newModal);\n\n        // add new project to projects\n\n        _defaultProjects__WEBPACK_IMPORTED_MODULE_1__[\"default\"].listOfProjects.push(newProj);\n\n        // update html to show project\n\n        const li = document.createElement('li');\n        li.classList.add('project');\n        li.classList.add('otherProjects');\n        li.setAttribute('data-index', _defaultProjects__WEBPACK_IMPORTED_MODULE_1__[\"default\"].projectCount - 1);\n\n        let name = proj.projectName.value.toLowerCase();\n        name = name.charAt(0).toUpperCase() + name.slice(1);\n        if (name.length > 12) {\n            name = name.substring(0, 10) + '...';\n        }\n        li.innerHTML = `<i class=\"fa-solid fa-masks-theater\"></i>${name} <i class=\"fa-solid fa-circle-minus\"></i>`;\n        _documentParts__WEBPACK_IMPORTED_MODULE_0__[\"default\"].projects.appendChild(li);\n\n        // update misc\n        addEventListeners();\n    });\n};\n\n\nconst removeProject = (e) => {\n    let projects = e.target.parentElement.parentElement;\n    let project = e.target.parentElement;\n    for (let i = 0; i < _defaultProjects__WEBPACK_IMPORTED_MODULE_1__[\"default\"].listOfProjects.length; i++) {\n        if (_defaultProjects__WEBPACK_IMPORTED_MODULE_1__[\"default\"].listOfProjects[i].getIndex() == project.getAttribute('data-index')) {\n            \n            // splice out project\n            let removedList = _defaultProjects__WEBPACK_IMPORTED_MODULE_1__[\"default\"].listOfProjects[i].arr;\n            let removedListIndexes = [];\n            \n            // update everythingProj to remove these toDos\n            for(let j = 0; j < removedList.length; j++){\n                removedListIndexes.push(removedList[j].getID());\n            }\n            \n            const removeFromArray = () => {\n                let list = _defaultProjects__WEBPACK_IMPORTED_MODULE_1__[\"default\"].listOfProjects;\n                let length = removedListIndexes.length;\n                for(let k = 0; k < length; k++){\n                    list[i].removeFromList(removedListIndexes[k]);\n                    list[1].removeFromList(removedListIndexes[k]);\n                }\n            };\n            removeFromArray();\n\n        }\n    }\n    projects.removeChild(project);\n    _documentParts__WEBPACK_IMPORTED_MODULE_0__[\"default\"].table.textContent = 'Please select a project';\n    if(_documentParts__WEBPACK_IMPORTED_MODULE_0__[\"default\"].toDoList.contains(_documentParts__WEBPACK_IMPORTED_MODULE_0__[\"default\"].addToDoBtn)){\n        _documentParts__WEBPACK_IMPORTED_MODULE_0__[\"default\"].toDoList.removeChild(_documentParts__WEBPACK_IMPORTED_MODULE_0__[\"default\"].addToDoBtn);\n    }\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUSx1RUFBa0I7QUFDMUI7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0IsaURBQU8seUJBQXlCLHFFQUFxQjtBQUM3RSxRQUFRLHFFQUFxQjs7QUFFN0I7QUFDQSxRQUFRLHVFQUFrQjs7QUFFMUI7O0FBRUEsUUFBUSw0RUFBNEI7O0FBRXBDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxxRUFBcUI7O0FBRTNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUUsTUFBTTtBQUN6RSxRQUFRLDJFQUFzQjs7QUFFOUI7QUFDQTtBQUNBLEtBQUs7QUFDTDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLElBQUksOEVBQThCLEVBQUU7QUFDeEQsWUFBWSx1RUFBdUI7QUFDbkM7QUFDQTtBQUNBLDhCQUE4Qix1RUFBdUI7QUFDckQ7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHdCQUF3QjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQix1RUFBdUI7QUFDbEQ7QUFDQSwrQkFBK0IsWUFBWTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUksd0VBQW1CO0FBQ3ZCLE9BQU8sd0VBQW1CLENBQUMsaUVBQVk7QUFDdkMsUUFBUSwyRUFBc0IsQ0FBQyxpRUFBWTtBQUMzQztBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdG9kby1saXN0Ly4vc3JjL2pzL2FkZExpc3RlbmVycy5qcz80NjRhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBfIGZyb20gJy4vZG9jdW1lbnRQYXJ0cyc7XG5pbXBvcnQgZGVmYXVsdHMgZnJvbSAnLi9kZWZhdWx0UHJvamVjdHMnO1xuaW1wb3J0IHsgYWRkVG9Eb1RvVGFibGUgfSBmcm9tICcuL2FkZFRvRG8nO1xuaW1wb3J0IHsgY3JlYXRlRWRpdE1vZGFsLCBjcmVhdGVQcm9qZWN0TW9kYWwgfSBmcm9tICcuL2NyZWF0ZU1vZGFscyc7XG5pbXBvcnQgeyBkYXRlRmlsdGVyLCBub3cgfSBmcm9tICcuL3RpbWUnO1xuaW1wb3J0IHsgUHJvamVjdCB9IGZyb20gJy4vcHJvamVjdCc7XG5cbmV4cG9ydCBjb25zdCBhZGRFdmVudExpc3RlbmVycyA9ICgpID0+IHtcbiAgICAvLyByZW1vdmUgdG9Eb1xuICAgIGNvbnN0IHRyYXNoQnRucyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5mYS10cmFzaC1jYW4nKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRyYXNoQnRucy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0cmFzaEJ0bnNbaV0uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBkZWxldGVUb0RvKTtcbiAgICB9XG4gICAgLy8gbWFyayBjb21wbGV0ZVxuICAgIGNvbnN0IHVuY2hlY2tlZEJveGVzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLmZhLXNxdWFyZScpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdW5jaGVja2VkQm94ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdW5jaGVja2VkQm94ZXNbaV0uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBjb21wbGV0ZVRvRG8pO1xuICAgIH1cbiAgICAvLyBtYXJrIGluY29tcGxldGVcbiAgICBjb25zdCBjaGVja2VkQm94ZXMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcuZmEtc3F1YXJlLWNoZWNrJyk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGVja2VkQm94ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY2hlY2tlZEJveGVzW2ldLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdW5kb1RvRG9Db21wbGV0aW9uKTtcbiAgICB9XG4gICAgLy8gZWRpdCB0b0RvIG1vZGFsXG4gICAgY29uc3QgZWRpdE1vZGFsQnRucyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5mYS1wZW4tdG8tc3F1YXJlJyk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlZGl0TW9kYWxCdG5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGVkaXRNb2RhbEJ0bnNbaV0uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBpbnN0YW50aWF0ZUVkaXRNb2RhbCk7XG4gICAgfVxuICAgIC8vIGNyZWF0ZSB0b0RvIG1vZGFsXG4gICAgXy5hZGRUb0RvQnRuLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgaW5zdGFudGlhdGVDcmVhdGlvbk1vZGFsKTtcbiAgICAvLyBjcmVhdGUgcHJvamVjdCBtb2RhbFxuICAgIF8uYWRkUHJvamVjdEJ0bi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGluc3RhbnRpYXRlUHJvamVjdE1vZGFsKTtcbiAgICAvLyByZW1vdmUgcHJvamVjdCBtb2RhbFxuICAgIGNvbnN0IHJlbW92ZVByb2plY3RCdG5zID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLmZhLWNpcmNsZS1taW51cycpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVtb3ZlUHJvamVjdEJ0bnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmVtb3ZlUHJvamVjdEJ0bnNbaV0uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCByZW1vdmVQcm9qZWN0KTtcbiAgICB9XG4gICAgXG59O1xuXG5cbi8vIHNlbGVjdGVkUHJvamVjdCBleC4gZGVmYXVsdHMubGlzdE9mUHJvamVjdHNbZGVmYXVsdHMuY3VycmVudFByb2plY3RJbmRleF1cbl8uc2lkZWJhci5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGxvYWRQcm9qZWN0KTtcblxuZXhwb3J0IGZ1bmN0aW9uIGxvYWRQcm9qZWN0IChlKSB7XG4gICAgaWYoZS50YXJnZXQuY2xhc3NMaXN0LmNvbnRhaW5zKCdvdGhlclByb2plY3RzJykpe1xuICAgICAgICAvLyBzZXR1cFxuICAgICAgICBjb25zdCBwcm9qSW5kZXggPSBlLnRhcmdldC5nZXRBdHRyaWJ1dGUoJ2RhdGEtaW5kZXgnKTtcbiAgICAgICAgZGVmYXVsdHMuY3VycmVudFByb2plY3RJbmRleCA9IHByb2pJbmRleDtcbiAgICAgICAgXy50YWJsZS50ZXh0Q29udGVudCA9ICcnO1xuICAgICAgICAvLyBnZW5lcmF0ZVRhYmxlSGVhZGVyIFxuICAgICAgICBsZXQgdHIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0cicpO1xuICAgICAgICB0ci5jbGFzc0xpc3QuYWRkKCd0aXRsZXMnKTtcbiAgICAgICAgbGV0IHRoUHJvak5hbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0aCcpO1xuICAgICAgICB0aFByb2pOYW1lLmNsYXNzTGlzdC5hZGQoJ3Byb2pOYW1lJyk7XG5cbiAgICAgICAgaWYgKGRlZmF1bHRzLmxpc3RPZlByb2plY3RzW2RlZmF1bHRzLmN1cnJlbnRQcm9qZWN0SW5kZXhdLmdldFRpdGxlKCkubGVuZ3RoID4gMCl7XG4gICAgICAgICAgICB0aFByb2pOYW1lLnRleHRDb250ZW50ID0gZGVmYXVsdHMubGlzdE9mUHJvamVjdHNbZGVmYXVsdHMuY3VycmVudFByb2plY3RJbmRleF0uZ2V0VGl0bGUoKS5zdWJzdHJpbmcoMCwzMCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZXtcbiAgICAgICAgICAgIHRoUHJvak5hbWUudGV4dENvbnRlbnQgPSAnVW5uYW1lZCc7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHRoRHVlRGF0ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RoJyk7XG4gICAgICAgIHRoRHVlRGF0ZS5jbGFzc0xpc3QuYWRkKCdkdWVEYXRlJyk7XG4gICAgICAgIHRoRHVlRGF0ZS5pbm5lckhUTUwgPSBgRHVlIERhdGUgPGkgY2xhc3M9XCJmYS1zb2xpZCBmYS1jYWxlbmRhci1kYXlcIj48L2k+YDtcbiAgICAgICAgdHIuYXBwZW5kQ2hpbGQodGhQcm9qTmFtZSk7XG4gICAgICAgIHRyLmFwcGVuZENoaWxkKHRoRHVlRGF0ZSk7XG4gICAgICAgIF8udGFibGUuYXBwZW5kQ2hpbGQodHIpO1xuICAgICAgICAvLyBnZW5lcmF0ZSByb3dzXG4gICAgICAgIGNvbnN0IG1ha2VSb3cgPSAocm93KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB0ciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RyJyk7XG4gICAgICAgICAgICB0ci5jbGFzc0xpc3QuYWRkKCdjcmVhdGVkUm93Jyk7XG4gICAgICAgICAgICB0ci5zZXRBdHRyaWJ1dGUoJ2RhdGEtaW5kZXgnLCBgJHtyb3cuZ2V0SUQoKX1gKTtcbiAgICAgICAgICAgIGNvbnN0IHRkMSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RkJyk7XG4gICAgICAgICAgICBjb25zdCB0ZDIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZCcpO1xuICAgICAgICAgICAgdGQxLmNsYXNzTGlzdC5hZGQoJ2NvbHVtbjEnKTtcbiAgICAgICAgICAgIHRkMi5jbGFzc0xpc3QuYWRkKCdjb2x1bW4yJyk7XG5cbiAgICAgICAgICAgIF8uc2V0UHJpb3JpdHlDb2xvcnMocm93LmdldFByaW9yaXR5KCksIHRkMSk7XG4gICAgXG4gICAgICAgICAgICB0ZDEuaW5uZXJIVE1MID0gYDxpIGNsYXNzPVwiZmEtcmVndWxhciBmYS1zcXVhcmVcIj48L2k+ICR7cm93LmdldFRpdGxlKCl9YDtcbiAgICAgICAgICAgIHRkMi5pbm5lckhUTUwgPSBgJHtkYXRlRmlsdGVyKHJvdy5nZXREdWVEYXRlKCkpfSA8aSBjbGFzcz1cImZhLXJlZ3VsYXIgZmEtcGVuLXRvLXNxdWFyZVwiPjwvaT48aSBjbGFzcz1cImZhLXJlZ3VsYXIgZmEtdHJhc2gtY2FuXCI+PC9pPmA7XG4gICAgXG4gICAgICAgICAgICB0ci5hcHBlbmRDaGlsZCh0ZDEpO1xuICAgICAgICAgICAgdHIuYXBwZW5kQ2hpbGQodGQyKTtcbiAgICBcbiAgICAgICAgICAgIHJldHVybiB0cjtcbiAgICAgICAgfTtcbiAgICBcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkZWZhdWx0cy5saXN0T2ZQcm9qZWN0c1tkZWZhdWx0cy5jdXJyZW50UHJvamVjdEluZGV4XS5hcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIF8udGFibGUuYXBwZW5kQ2hpbGQobWFrZVJvdyhkZWZhdWx0cy5saXN0T2ZQcm9qZWN0c1tkZWZhdWx0cy5jdXJyZW50UHJvamVjdEluZGV4XS5hcnJbaV0pKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCFfLnRvRG9MaXN0LmNvbnRhaW5zKF8uYWRkVG9Eb0J0bikpe1xuICAgICAgICAgICAgXy50b0RvTGlzdC5hcHBlbmRDaGlsZChfLmFkZFRvRG9CdG4pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYWRkRXZlbnRMaXN0ZW5lcnMoKVxuICAgICAgICBhZGRFdmVudExpc3RlbmVycygpO1xuICAgIH1cbn07XG5cbmNvbnN0IGRlbGV0ZVRvRG8gPSAoZSkgPT4ge1xuICAgIGNvbnN0IGl0ZW0gPSBlLnRhcmdldDtcbiAgICBjb25zdCB0b2RvID0gaXRlbS5wYXJlbnRFbGVtZW50LnBhcmVudEVsZW1lbnQ7XG4gICAgdG9kby5yZW1vdmUoKTtcblxuICAgIGNvbnN0IHJlbW92ZUZyb21BcnJheSA9ICgpID0+IHtcbiAgICAgICAgbGV0IHRhcmdldEluZGV4ID0gdG9kby5nZXRBdHRyaWJ1dGUoJ2RhdGEtaW5kZXgnKTtcbiAgICAgICAgbGV0IGxpc3QgPSBkZWZhdWx0cy5saXN0T2ZQcm9qZWN0cztcbiAgICAgICAgbGV0IGluZGV4ID0gZGVmYXVsdHMuY3VycmVudFByb2plY3RJbmRleDtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3RbaW5kZXhdLmFyci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGlkID0gbGlzdFtpbmRleF0uYXJyW2ldLmdldElEKCk7XG4gICAgICAgICAgICBpZiAoaWQgPT0gdGFyZ2V0SW5kZXgpIHtcbiAgICAgICAgICAgICAgICBsaXN0W2luZGV4XS5yZW1vdmVGcm9tTGlzdChpZCk7XG4gICAgICAgICAgICAgICAgbGlzdFsxXS5yZW1vdmVGcm9tTGlzdChpZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgfTtcbiAgICByZW1vdmVGcm9tQXJyYXkoKTtcbn07XG5cbmNvbnN0IGNvbXBsZXRlVG9EbyA9IChlKSA9PiB7XG4gICAgY29uc3QgaXRlbSA9IGUudGFyZ2V0O1xuICAgIGNvbnN0IHRvZG8gPSBpdGVtLnBhcmVudEVsZW1lbnQucGFyZW50RWxlbWVudDtcbiAgICB0b2RvLmNsYXNzTGlzdC5hZGQoJ2NvbXBsZXRlZCcpO1xuICAgIHRvZG8uaW5uZXJIVE1MID0gdG9kby5pbm5lckhUTUwucmVwbGFjZSgnPGkgY2xhc3M9XCJmYS1yZWd1bGFyIGZhLXNxdWFyZVwiPjwvaT4nLCAnPGkgY2xhc3M9XCJmYS1yZWd1bGFyIGZhLXNxdWFyZS1jaGVja1wiPjwvaT4nKTtcbiAgICBhZGRFdmVudExpc3RlbmVycygpO1xufTtcblxuY29uc3QgdW5kb1RvRG9Db21wbGV0aW9uID0gKGUpID0+IHtcbiAgICBjb25zdCBpdGVtID0gZS50YXJnZXQ7XG4gICAgY29uc3QgdG9kbyA9IGl0ZW0ucGFyZW50RWxlbWVudC5wYXJlbnRFbGVtZW50O1xuICAgIHRvZG8uY2xhc3NMaXN0LnJlbW92ZSgnY29tcGxldGVkJyk7XG4gICAgdG9kby5pbm5lckhUTUwgPSB0b2RvLmlubmVySFRNTC5yZXBsYWNlKCc8aSBjbGFzcz1cImZhLXJlZ3VsYXIgZmEtc3F1YXJlLWNoZWNrXCI+PC9pPicsICc8aSBjbGFzcz1cImZhLXJlZ3VsYXIgZmEtc3F1YXJlXCI+PC9pPicpO1xuICAgIGFkZEV2ZW50TGlzdGVuZXJzKCk7XG59O1xuXG5jb25zdCBpbnN0YW50aWF0ZUVkaXRNb2RhbCA9IChlKSA9PiB7XG5cbiAgICBjb25zdCBpdGVtID0gZS50YXJnZXQ7XG4gICAgY29uc3QgdG9kbyA9IGl0ZW0ucGFyZW50RWxlbWVudC5wYXJlbnRFbGVtZW50O1xuICAgIGNvbnN0IHRhcmdldEluZGV4ID0gdG9kby5nZXRBdHRyaWJ1dGUoJ2RhdGEtaW5kZXgnKTtcbiAgICBjb25zdCBzaG9ydEhhbmQgPSBkZWZhdWx0cy5saXN0T2ZQcm9qZWN0c1tkZWZhdWx0cy5jdXJyZW50UHJvamVjdEluZGV4XTtcblxuICAgIGNvbnN0IGdldFRvRG9JbmZvID0gKCkgPT4ge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNob3J0SGFuZC5hcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChzaG9ydEhhbmQuYXJyW2ldLmdldElEKCkgPT0gdGFyZ2V0SW5kZXgpIHtcbiAgICAgICAgICAgICAgICBsZXQgbmFtZSA9IHNob3J0SGFuZC5hcnJbaV0uZ2V0VGl0bGUoKTtcbiAgICAgICAgICAgICAgICBsZXQgZGVzY3JpcHRpb24gPSBzaG9ydEhhbmQuYXJyW2ldLmdldERlc2NyaXB0aW9uKCk7XG4gICAgICAgICAgICAgICAgbGV0IGR1ZURhdGUgPSBzaG9ydEhhbmQuYXJyW2ldLmdldER1ZURhdGUoKTtcbiAgICAgICAgICAgICAgICBsZXQgcHJpb3JpdHkgPSBzaG9ydEhhbmQuYXJyW2ldLmdldFByaW9yaXR5KCk7XG4gICAgICAgICAgICAgICAgbGV0IGlkID0gaTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBuYW1lLCBkZXNjcmlwdGlvbiwgZHVlRGF0ZSwgcHJpb3JpdHksIGlkIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgY29uc3QgdG9Eb0luZm8gPSBnZXRUb0RvSW5mbygpO1xuICAgIGNvbnN0IGZvcm0gPSBjcmVhdGVFZGl0TW9kYWwodG9Eb0luZm8ubmFtZSwgdG9Eb0luZm8uZGVzY3JpcHRpb24sXG4gICAgICAgIHRvRG9JbmZvLmR1ZURhdGUsIHRvRG9JbmZvLnByaW9yaXR5KTtcblxuICAgIF8uYm9keS5hcHBlbmRDaGlsZChmb3JtLm5ld01vZGFsKTtcbiAgICBmb3JtLm5ld01vZGFsLnNob3dNb2RhbCgpO1xuXG4gICAgY29uc3Qgc3VibWl0RWRpdEJ0biA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5zdWJtaXRFZGl0QnRuJyk7XG4gICAgY29uc3QgY2FuY2VsRWRpdEJ0biA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5jYW5jZWxFZGl0QnRuJyk7XG5cbiAgICBjYW5jZWxFZGl0QnRuLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24gY2FuY2VsRWRpdE1vZGFsKGUpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBmb3JtLm5ld01vZGFsLmNsb3NlKCk7XG4gICAgICAgIF8uYm9keS5yZW1vdmVDaGlsZChmb3JtLm5ld01vZGFsKTtcbiAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICB9KTtcblxuICAgIHN1Ym1pdEVkaXRCdG4uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbiBzdWJtaXRFZGl0TW9kYWwoZSkge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgLy8gdXBkYXRlIEFyciB2YWx1ZXNcblxuICAgICAgICBzaG9ydEhhbmQuYXJyW3RvRG9JbmZvLmlkXS5zZXRUaXRsZShmb3JtLnRhc2tOYW1lLnZhbHVlKTtcbiAgICAgICAgc2hvcnRIYW5kLmFyclt0b0RvSW5mby5pZF0uc2V0RGVzY3JpcHRpb24oZm9ybS50YXNrRGVzY3JpcHRpb24udmFsdWUpO1xuICAgICAgICBzaG9ydEhhbmQuYXJyW3RvRG9JbmZvLmlkXS5zZXREdWVEYXRlKGZvcm0udGFza0R1ZURhdGUudmFsdWUpO1xuICAgICAgICBzaG9ydEhhbmQuYXJyW3RvRG9JbmZvLmlkXS5zZXRQcmlvcml0eShmb3JtLnRhc2tQcmlvcml0eS52YWx1ZSk7XG5cbiAgICAgICAgLy8gdXBkYXRlIHRhYmxlIHZhbHVlc1xuICAgICAgICB0b2RvLmNoaWxkcmVuWzBdLmlubmVySFRNTCA9IGA8aSBjbGFzcz1cImZhLXJlZ3VsYXIgZmEtc3F1YXJlXCI+PC9pPiAke2Zvcm0udGFza05hbWUudmFsdWV9YDtcbiAgICAgICAgXG4gICAgICAgIF8uc2V0UHJpb3JpdHlDb2xvcnMoZm9ybS50YXNrUHJpb3JpdHkudmFsdWUsIHRvZG8uY2hpbGRyZW5bMF0pO1xuXG4gICAgICAgIGlmIChmb3JtLnRhc2tEdWVEYXRlLnZhbHVlICE9PSAnJykge1xuICAgICAgICAgICAgbGV0IGZpbHRlcmVkRHVlRGF0ZSA9IGRhdGVGaWx0ZXIoZm9ybS50YXNrRHVlRGF0ZS52YWx1ZSk7XG4gICAgICAgICAgICB0b2RvLmNoaWxkcmVuWzFdLmlubmVySFRNTCA9IGAke2ZpbHRlcmVkRHVlRGF0ZX0gPGkgY2xhc3M9XCJmYS1yZWd1bGFyIGZhLXBlbi10by1zcXVhcmVcIj48L2k+PGkgY2xhc3M9XCJmYS1yZWd1bGFyIGZhLXRyYXNoLWNhblwiPjwvaT5gO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdG9kby5jaGlsZHJlblsxXS5pbm5lckhUTUwgPSBgPGkgY2xhc3M9XCJmYS1yZWd1bGFyIGZhLXBlbi10by1zcXVhcmVcIj48L2k+PGkgY2xhc3M9XCJmYS1yZWd1bGFyIGZhLXRyYXNoLWNhblwiPjwvaT5gO1xuICAgICAgICB9XG5cbiAgICAgICAgXy5ib2R5LnJlbW92ZUNoaWxkKGZvcm0ubmV3TW9kYWwpO1xuICAgICAgICBhZGRFdmVudExpc3RlbmVycygpO1xuICAgIH0pO1xufTtcblxuY29uc3QgaW5zdGFudGlhdGVDcmVhdGlvbk1vZGFsID0gKGUpID0+IHtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICBfLm1vZGFsLnNob3dNb2RhbCgpO1xuXG4gICAgLy8gc2V0IGRlZmF1bHQgZGF0ZSB2YWx1ZSB0byBub3dcbiAgICBsZXQgZHVlRGF0ZSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNjcmVhdGVUYXNrRHVlRGF0ZScpO1xuICAgIGR1ZURhdGUuc2V0QXR0cmlidXRlKFwidmFsdWVcIiwgYCR7bm93KCl9YCk7XG5cbiAgICBfLm1vZGFsQ2FuY2VsQnRuLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24gY2FuY2VsQ3JlYXRpb25Nb2RhbCgpIHtcbiAgICAgICAgXy5tb2RhbC5jbG9zZSgpO1xuICAgIH0pO1xuXG4gICAgXy5tb2RhbFN1Ym1pdEJ0bi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGFkZFRvRG9Ub1RhYmxlKTtcbiAgICBhZGRFdmVudExpc3RlbmVycygpO1xufTtcblxuY29uc3QgaW5zdGFudGlhdGVQcm9qZWN0TW9kYWwgPSAoZSkgPT4ge1xuXG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgY29uc3QgcHJvaiA9IGNyZWF0ZVByb2plY3RNb2RhbCgpO1xuICAgIF8uYm9keS5hcHBlbmRDaGlsZChwcm9qLm5ld01vZGFsKTtcblxuICAgIHByb2oubmV3TW9kYWwuc2hvd01vZGFsKCk7XG5cbiAgICBjb25zdCBzdWJtaXRQcm9qZWN0QnRuID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLnN1Ym1pdFByb2plY3RCdG4nKTtcbiAgICBjb25zdCBjYW5jZWxQcm9qZWN0QnRuID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmNhbmNlbFByb2plY3RCdG4nKTtcblxuICAgIGNhbmNlbFByb2plY3RCdG4uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbiBjYW5jZWxQcm9qZWN0TW9kYWwoZSkge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHByb2oubmV3TW9kYWwuY2xvc2UoKTtcbiAgICAgICAgXy5ib2R5LnJlbW92ZUNoaWxkKHByb2oubmV3TW9kYWwpO1xuICAgICAgICBhZGRFdmVudExpc3RlbmVycygpO1xuICAgIH0pO1xuXG4gICAgc3VibWl0UHJvamVjdEJ0bi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uIHN1Ym1pdFByb2plY3RNb2RhbChlKSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAvLyBjcmVhdGUgbmV3IHByb2plY3RcbiAgICAgICAgY29uc3QgbmV3UHJvaiA9IFByb2plY3QocHJvai5wcm9qZWN0TmFtZS52YWx1ZSwgZGVmYXVsdHMucHJvamVjdENvdW50KTtcbiAgICAgICAgZGVmYXVsdHMucHJvamVjdENvdW50Kys7XG5cbiAgICAgICAgcHJvai5uZXdNb2RhbC5jbG9zZSgpO1xuICAgICAgICBfLmJvZHkucmVtb3ZlQ2hpbGQocHJvai5uZXdNb2RhbCk7XG5cbiAgICAgICAgLy8gYWRkIG5ldyBwcm9qZWN0IHRvIHByb2plY3RzXG5cbiAgICAgICAgZGVmYXVsdHMubGlzdE9mUHJvamVjdHMucHVzaChuZXdQcm9qKTtcblxuICAgICAgICAvLyB1cGRhdGUgaHRtbCB0byBzaG93IHByb2plY3RcblxuICAgICAgICBjb25zdCBsaSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xpJyk7XG4gICAgICAgIGxpLmNsYXNzTGlzdC5hZGQoJ3Byb2plY3QnKTtcbiAgICAgICAgbGkuY2xhc3NMaXN0LmFkZCgnb3RoZXJQcm9qZWN0cycpO1xuICAgICAgICBsaS5zZXRBdHRyaWJ1dGUoJ2RhdGEtaW5kZXgnLCBkZWZhdWx0cy5wcm9qZWN0Q291bnQgLSAxKTtcblxuICAgICAgICBsZXQgbmFtZSA9IHByb2oucHJvamVjdE5hbWUudmFsdWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgbmFtZSA9IG5hbWUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBuYW1lLnNsaWNlKDEpO1xuICAgICAgICBpZiAobmFtZS5sZW5ndGggPiAxMikge1xuICAgICAgICAgICAgbmFtZSA9IG5hbWUuc3Vic3RyaW5nKDAsIDEwKSArICcuLi4nO1xuICAgICAgICB9XG4gICAgICAgIGxpLmlubmVySFRNTCA9IGA8aSBjbGFzcz1cImZhLXNvbGlkIGZhLW1hc2tzLXRoZWF0ZXJcIj48L2k+JHtuYW1lfSA8aSBjbGFzcz1cImZhLXNvbGlkIGZhLWNpcmNsZS1taW51c1wiPjwvaT5gO1xuICAgICAgICBfLnByb2plY3RzLmFwcGVuZENoaWxkKGxpKTtcblxuICAgICAgICAvLyB1cGRhdGUgbWlzY1xuICAgICAgICBhZGRFdmVudExpc3RlbmVycygpO1xuICAgIH0pO1xufTtcblxuXG5jb25zdCByZW1vdmVQcm9qZWN0ID0gKGUpID0+IHtcbiAgICBsZXQgcHJvamVjdHMgPSBlLnRhcmdldC5wYXJlbnRFbGVtZW50LnBhcmVudEVsZW1lbnQ7XG4gICAgbGV0IHByb2plY3QgPSBlLnRhcmdldC5wYXJlbnRFbGVtZW50O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGVmYXVsdHMubGlzdE9mUHJvamVjdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGRlZmF1bHRzLmxpc3RPZlByb2plY3RzW2ldLmdldEluZGV4KCkgPT0gcHJvamVjdC5nZXRBdHRyaWJ1dGUoJ2RhdGEtaW5kZXgnKSkge1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBzcGxpY2Ugb3V0IHByb2plY3RcbiAgICAgICAgICAgIGxldCByZW1vdmVkTGlzdCA9IGRlZmF1bHRzLmxpc3RPZlByb2plY3RzW2ldLmFycjtcbiAgICAgICAgICAgIGxldCByZW1vdmVkTGlzdEluZGV4ZXMgPSBbXTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gdXBkYXRlIGV2ZXJ5dGhpbmdQcm9qIHRvIHJlbW92ZSB0aGVzZSB0b0Rvc1xuICAgICAgICAgICAgZm9yKGxldCBqID0gMDsgaiA8IHJlbW92ZWRMaXN0Lmxlbmd0aDsgaisrKXtcbiAgICAgICAgICAgICAgICByZW1vdmVkTGlzdEluZGV4ZXMucHVzaChyZW1vdmVkTGlzdFtqXS5nZXRJRCgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgY29uc3QgcmVtb3ZlRnJvbUFycmF5ID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBsaXN0ID0gZGVmYXVsdHMubGlzdE9mUHJvamVjdHM7XG4gICAgICAgICAgICAgICAgbGV0IGxlbmd0aCA9IHJlbW92ZWRMaXN0SW5kZXhlcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgZm9yKGxldCBrID0gMDsgayA8IGxlbmd0aDsgaysrKXtcbiAgICAgICAgICAgICAgICAgICAgbGlzdFtpXS5yZW1vdmVGcm9tTGlzdChyZW1vdmVkTGlzdEluZGV4ZXNba10pO1xuICAgICAgICAgICAgICAgICAgICBsaXN0WzFdLnJlbW92ZUZyb21MaXN0KHJlbW92ZWRMaXN0SW5kZXhlc1trXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJlbW92ZUZyb21BcnJheSgpO1xuXG4gICAgICAgIH1cbiAgICB9XG4gICAgcHJvamVjdHMucmVtb3ZlQ2hpbGQocHJvamVjdCk7XG4gICAgXy50YWJsZS50ZXh0Q29udGVudCA9ICdQbGVhc2Ugc2VsZWN0IGEgcHJvamVjdCc7XG4gICAgaWYoXy50b0RvTGlzdC5jb250YWlucyhfLmFkZFRvRG9CdG4pKXtcbiAgICAgICAgXy50b0RvTGlzdC5yZW1vdmVDaGlsZChfLmFkZFRvRG9CdG4pO1xuICAgIH1cbn07Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/js/addListeners.js\n");

/***/ }),

/***/ "./src/js/addToDo.js":
/*!***************************!*\
  !*** ./src/js/addToDo.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"addToDoToTable\": () => (/* binding */ addToDoToTable)\n/* harmony export */ });\n/* harmony import */ var _documentParts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./documentParts */ \"./src/js/documentParts.js\");\n/* harmony import */ var _todo__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./todo */ \"./src/js/todo.js\");\n/* harmony import */ var _defaultProjects__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./defaultProjects */ \"./src/js/defaultProjects.js\");\n/* harmony import */ var _time__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./time */ \"./src/js/time.js\");\n/* harmony import */ var _addListeners__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./addListeners */ \"./src/js/addListeners.js\");\n\n\n\n\n\n\nconst addToDoToTable = () => {\n\n    const makeRow = () => {\n        const tr = document.createElement('tr');\n        tr.classList.add('createdRow');\n        tr.setAttribute('data-index', `${_documentParts__WEBPACK_IMPORTED_MODULE_0__[\"default\"].toDoCounter}`);\n        const td1 = document.createElement('td');\n        const td2 = document.createElement('td');\n        td1.classList.add('column1');\n        td2.classList.add('column2');\n\n        _documentParts__WEBPACK_IMPORTED_MODULE_0__[\"default\"].setPriorityColors(createTaskPriority.value, td1);\n\n        td1.innerHTML = `<i class=\"fa-regular fa-square\"></i> ${createTaskName.value}`;\n        if (createTaskDueDate.value !== '') {\n            let filteredDueDate = (0,_time__WEBPACK_IMPORTED_MODULE_3__.dateFilter)(createTaskDueDate.value);\n            td2.innerHTML = `${filteredDueDate} <i class=\"fa-regular fa-pen-to-square\"></i><i class=\"fa-regular fa-trash-can\"></i>`;\n        }\n        else {\n            td2.innerHTML = `<i class=\"fa-regular fa-pen-to-square\"></i><i class=\"fa-regular fa-trash-can\"></i>`;\n        }\n\n        tr.appendChild(td1);\n        tr.appendChild(td2);\n\n        return tr;\n    };\n\n    const row = makeRow();\n\n    // create an object to store the values and push into defaultProj later\n    let toDoObj = (0,_todo__WEBPACK_IMPORTED_MODULE_1__.Todo)(createTaskName.value, createTaskDescription.value, createTaskDueDate.value,\n        createTaskPriority.value, _documentParts__WEBPACK_IMPORTED_MODULE_0__[\"default\"].toDoCounter);\n    \n    _documentParts__WEBPACK_IMPORTED_MODULE_0__[\"default\"].toDoCounter++;\n\n    _defaultProjects__WEBPACK_IMPORTED_MODULE_2__[\"default\"].listOfProjects[_defaultProjects__WEBPACK_IMPORTED_MODULE_2__[\"default\"].currentProjectIndex].addToList(toDoObj);\n    _defaultProjects__WEBPACK_IMPORTED_MODULE_2__[\"default\"].listOfProjects[1].addToList(toDoObj);\n\n    _documentParts__WEBPACK_IMPORTED_MODULE_0__[\"default\"].table.appendChild(row);\n    // set default values\n    createTaskName.value = '';\n    createTaskDescription.value = '';\n    createTaskDueDate.value = (0,_time__WEBPACK_IMPORTED_MODULE_3__.now)();\n    createTaskPriority.value = 'Normal';\n    (0,_addListeners__WEBPACK_IMPORTED_MODULE_4__.addEventListeners)();\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvanMvYWRkVG9Eby5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBZ0M7QUFDRjtBQUNXO0FBQ0E7QUFDVTs7QUFFNUM7O0FBRVA7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLGtFQUFhLENBQUM7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsUUFBUSx3RUFBbUI7O0FBRTNCLGdFQUFnRSxxQkFBcUI7QUFDckY7QUFDQSxrQ0FBa0MsaURBQVU7QUFDNUMsK0JBQStCLGlCQUFpQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxrQkFBa0IsMkNBQUk7QUFDdEIsa0NBQWtDLGtFQUFhO0FBQy9DO0FBQ0EsSUFBSSxrRUFBYTs7QUFFakIsSUFBSSx1RUFBdUIsQ0FBQyw0RUFBNEI7QUFDeEQsSUFBSSxvRkFBb0M7O0FBRXhDLElBQUksd0VBQW1CO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QiwwQ0FBRztBQUNqQztBQUNBLElBQUksZ0VBQWlCO0FBQ3JCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdG9kby1saXN0Ly4vc3JjL2pzL2FkZFRvRG8uanM/MThmNCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgXyBmcm9tICcuL2RvY3VtZW50UGFydHMnO1xuaW1wb3J0IHsgVG9kbyB9IGZyb20gJy4vdG9kbyc7XG5pbXBvcnQgZGVmYXVsdHMgZnJvbSAnLi9kZWZhdWx0UHJvamVjdHMnO1xuaW1wb3J0IHsgZGF0ZUZpbHRlciwgbm93IH0gZnJvbSAnLi90aW1lJztcbmltcG9ydCB7IGFkZEV2ZW50TGlzdGVuZXJzIH0gZnJvbSAnLi9hZGRMaXN0ZW5lcnMnO1xuXG5leHBvcnQgY29uc3QgYWRkVG9Eb1RvVGFibGUgPSAoKSA9PiB7XG5cbiAgICBjb25zdCBtYWtlUm93ID0gKCkgPT4ge1xuICAgICAgICBjb25zdCB0ciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RyJyk7XG4gICAgICAgIHRyLmNsYXNzTGlzdC5hZGQoJ2NyZWF0ZWRSb3cnKTtcbiAgICAgICAgdHIuc2V0QXR0cmlidXRlKCdkYXRhLWluZGV4JywgYCR7Xy50b0RvQ291bnRlcn1gKTtcbiAgICAgICAgY29uc3QgdGQxID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGQnKTtcbiAgICAgICAgY29uc3QgdGQyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGQnKTtcbiAgICAgICAgdGQxLmNsYXNzTGlzdC5hZGQoJ2NvbHVtbjEnKTtcbiAgICAgICAgdGQyLmNsYXNzTGlzdC5hZGQoJ2NvbHVtbjInKTtcblxuICAgICAgICBfLnNldFByaW9yaXR5Q29sb3JzKGNyZWF0ZVRhc2tQcmlvcml0eS52YWx1ZSwgdGQxKTtcblxuICAgICAgICB0ZDEuaW5uZXJIVE1MID0gYDxpIGNsYXNzPVwiZmEtcmVndWxhciBmYS1zcXVhcmVcIj48L2k+ICR7Y3JlYXRlVGFza05hbWUudmFsdWV9YDtcbiAgICAgICAgaWYgKGNyZWF0ZVRhc2tEdWVEYXRlLnZhbHVlICE9PSAnJykge1xuICAgICAgICAgICAgbGV0IGZpbHRlcmVkRHVlRGF0ZSA9IGRhdGVGaWx0ZXIoY3JlYXRlVGFza0R1ZURhdGUudmFsdWUpO1xuICAgICAgICAgICAgdGQyLmlubmVySFRNTCA9IGAke2ZpbHRlcmVkRHVlRGF0ZX0gPGkgY2xhc3M9XCJmYS1yZWd1bGFyIGZhLXBlbi10by1zcXVhcmVcIj48L2k+PGkgY2xhc3M9XCJmYS1yZWd1bGFyIGZhLXRyYXNoLWNhblwiPjwvaT5gO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGQyLmlubmVySFRNTCA9IGA8aSBjbGFzcz1cImZhLXJlZ3VsYXIgZmEtcGVuLXRvLXNxdWFyZVwiPjwvaT48aSBjbGFzcz1cImZhLXJlZ3VsYXIgZmEtdHJhc2gtY2FuXCI+PC9pPmA7XG4gICAgICAgIH1cblxuICAgICAgICB0ci5hcHBlbmRDaGlsZCh0ZDEpO1xuICAgICAgICB0ci5hcHBlbmRDaGlsZCh0ZDIpO1xuXG4gICAgICAgIHJldHVybiB0cjtcbiAgICB9O1xuXG4gICAgY29uc3Qgcm93ID0gbWFrZVJvdygpO1xuXG4gICAgLy8gY3JlYXRlIGFuIG9iamVjdCB0byBzdG9yZSB0aGUgdmFsdWVzIGFuZCBwdXNoIGludG8gZGVmYXVsdFByb2ogbGF0ZXJcbiAgICBsZXQgdG9Eb09iaiA9IFRvZG8oY3JlYXRlVGFza05hbWUudmFsdWUsIGNyZWF0ZVRhc2tEZXNjcmlwdGlvbi52YWx1ZSwgY3JlYXRlVGFza0R1ZURhdGUudmFsdWUsXG4gICAgICAgIGNyZWF0ZVRhc2tQcmlvcml0eS52YWx1ZSwgXy50b0RvQ291bnRlcik7XG4gICAgXG4gICAgXy50b0RvQ291bnRlcisrO1xuXG4gICAgZGVmYXVsdHMubGlzdE9mUHJvamVjdHNbZGVmYXVsdHMuY3VycmVudFByb2plY3RJbmRleF0uYWRkVG9MaXN0KHRvRG9PYmopO1xuICAgIGRlZmF1bHRzLmxpc3RPZlByb2plY3RzWzFdLmFkZFRvTGlzdCh0b0RvT2JqKTtcblxuICAgIF8udGFibGUuYXBwZW5kQ2hpbGQocm93KTtcbiAgICAvLyBzZXQgZGVmYXVsdCB2YWx1ZXNcbiAgICBjcmVhdGVUYXNrTmFtZS52YWx1ZSA9ICcnO1xuICAgIGNyZWF0ZVRhc2tEZXNjcmlwdGlvbi52YWx1ZSA9ICcnO1xuICAgIGNyZWF0ZVRhc2tEdWVEYXRlLnZhbHVlID0gbm93KCk7XG4gICAgY3JlYXRlVGFza1ByaW9yaXR5LnZhbHVlID0gJ05vcm1hbCc7XG4gICAgYWRkRXZlbnRMaXN0ZW5lcnMoKTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/js/addToDo.js\n");

/***/ }),

/***/ "./src/js/createModals.js":
/*!********************************!*\
  !*** ./src/js/createModals.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"createEditModal\": () => (/* binding */ createEditModal),\n/* harmony export */   \"createProjectModal\": () => (/* binding */ createProjectModal)\n/* harmony export */ });\nconst createProjectModal = () => {\n    \n    const newModal = document.createElement('dialog');\n    newModal.classList.add('projectModal');\n    newModal.setAttribute('id', 'projectModal');\n\n    const projectModalHeader = document.createElement('h2');\n    projectModalHeader.textContent = 'New Project';\n\n    const projectModalForm = document.createElement('form');\n    projectModalForm.classList.add('projectForm');\n    projectModalForm.setAttribute('method', 'dialog');\n\n    const projectNameDiv = document.createElement('div');\n    const projectName = document.createElement('input');\n    const projectNameLabel = document.createElement('label');\n    projectName.setAttribute('type', 'text');\n    projectName.setAttribute('name', 'projectName');\n    projectName.setAttribute('id', 'projectName');\n    projectName.setAttribute('placeholder', 'Fitness');\n    projectNameLabel.setAttribute('for', 'projectName');\n    projectNameLabel.textContent = 'Title';\n    projectNameDiv.appendChild(projectNameLabel);\n    projectNameDiv.appendChild(projectName);\n\n    const btns = document.createElement('div');\n    btns.classList.add('btns');\n    const submitBtn = document.createElement('button');\n    submitBtn.innerHTML = `<i class=\"fa-solid fa-check\"></i>`;\n    submitBtn.classList.add('submitProjectBtn');\n    submitBtn.setAttribute('type', 'button');\n    const cancelBtn = document.createElement('button');\n    cancelBtn.innerHTML = `<i class=\"fa-solid fa-ban\"></i>`;\n    cancelBtn.classList.add('cancelProjectBtn');\n    submitBtn.setAttribute('type', 'button');\n    btns.appendChild(submitBtn);\n    btns.appendChild(cancelBtn);\n\n    newModal.appendChild(projectModalHeader);\n    projectModalForm.appendChild(projectNameDiv);\n    projectModalForm.appendChild(btns);\n    newModal.appendChild(projectModalForm);\n\n    return {newModal, projectModalForm, projectName, submitBtn, cancelBtn};\n};\n\n\nconst createEditModal = (name, description, dueDate, priority) => {\n    \n    const newModal = document.createElement('dialog');\n    newModal.classList.add('editModal');\n    newModal.setAttribute('id', 'editModal');\n\n    const editModalHeader = document.createElement('h2');\n    editModalHeader.textContent = 'Edit Task';\n\n    const editModalForm = document.createElement('form');\n    editModalForm.classList.add('editForm');\n    editModalForm.setAttribute('method', 'dialog');\n\n    const taskNameDiv = document.createElement('div');\n    const taskName = document.createElement('input');\n    const taskNameLabel = document.createElement('label');\n    taskName.setAttribute('type', 'text');\n    taskName.setAttribute('name', 'taskName');\n    taskName.setAttribute('id', 'taskName');\n    taskName.setAttribute('placeholder', 'Take out the trash');\n    taskName.setAttribute('value', name);\n    taskNameLabel.setAttribute('for', 'taskName');\n    taskNameLabel.textContent = 'Title';\n    taskNameDiv.appendChild(taskNameLabel);\n    taskNameDiv.appendChild(taskName);\n\n    const taskDescriptionDiv = document.createElement('div');\n    const taskDescription = document.createElement('textarea');\n    const taskDescriptionLabel = document.createElement('label');\n    taskDescription.setAttribute('name', 'taskDescription');\n    taskDescription.setAttribute('id', 'taskDescription');\n    taskDescription.setAttribute('placeholder', 'I avoid the acumulation of trash by performing the sacred art of removing said trash...');\n    taskDescription.value = description;\n    taskDescriptionLabel.setAttribute('for', 'taskDescription');\n    taskDescriptionLabel.textContent = 'Description';\n    taskDescriptionDiv.appendChild(taskDescriptionLabel);\n    taskDescriptionDiv.appendChild(taskDescription);\n\n    const taskDueDateDiv = document.createElement('div');\n    const taskDueDate = document.createElement('input');\n    const taskDueDateLabel = document.createElement('label');\n    taskDueDate.setAttribute('type', 'datetime-local');\n    taskDueDate.setAttribute('name', 'taskDueDate');\n    taskDueDate.setAttribute('id', 'taskDueDate');\n    taskDueDate.setAttribute('value', dueDate);\n    taskDueDateLabel.setAttribute('for', 'taskDueDate');\n    taskDueDateLabel.textContent = 'Due Date';\n    taskDueDateDiv.appendChild(taskDueDateLabel);\n    taskDueDateDiv.appendChild(taskDueDate);\n\n    const taskPriorityDiv = document.createElement('div');\n    const taskPriority = document.createElement('select');\n    const taskPriorityLabel = document.createElement('label');\n    taskPriority.setAttribute('name', 'taskPriority');\n    taskPriority.setAttribute('id', 'taskPriorityEdit');\n    taskPriorityLabel.setAttribute('for', 'taskPriority');\n    taskPriorityLabel.textContent = 'Priority';\n    const highPriority = document.createElement('option');\n    highPriority.textContent = 'High';\n    const normalPriority = document.createElement('option');\n    normalPriority.textContent = 'Normal';\n    const lowPriority = document.createElement('option');\n    lowPriority.textContent = 'Low';\n\n    taskPriority.appendChild(highPriority);\n    taskPriority.appendChild(normalPriority);\n    taskPriority.appendChild(lowPriority);\n\n    taskPriority.value = priority;\n    \n    taskPriorityDiv.appendChild(taskPriorityLabel);\n    taskPriorityDiv.appendChild(taskPriority);\n\n    const btns = document.createElement('div');\n    btns.classList.add('btns');\n    const submitBtn = document.createElement('button');\n    submitBtn.innerHTML = `<i class=\"fa-solid fa-check\"></i>`;\n    submitBtn.classList.add('submitEditBtn');\n    submitBtn.setAttribute('type', 'button');\n    const cancelBtn = document.createElement('button');\n    cancelBtn.innerHTML = `<i class=\"fa-solid fa-ban\"></i>`;\n    cancelBtn.classList.add('cancelEditBtn');\n    submitBtn.setAttribute('type', 'button');\n    btns.appendChild(submitBtn);\n    btns.appendChild(cancelBtn);\n\n    newModal.appendChild(editModalHeader);\n    editModalForm.appendChild(taskNameDiv);\n    editModalForm.appendChild(taskDescriptionDiv);\n    editModalForm.appendChild(taskDueDateDiv);\n    editModalForm.appendChild(taskPriorityDiv);\n    editModalForm.appendChild(btns);\n    newModal.appendChild(editModalForm);\n\n    return {newModal, editModalForm, taskName, taskDueDate, taskPriority, \n        taskDescription, submitBtn, cancelBtn};\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvanMvY3JlYXRlTW9kYWxzLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxZQUFZO0FBQ1o7OztBQUdPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFlBQVk7QUFDWjtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdG9kby1saXN0Ly4vc3JjL2pzL2NyZWF0ZU1vZGFscy5qcz8zYWE4Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjb25zdCBjcmVhdGVQcm9qZWN0TW9kYWwgPSAoKSA9PiB7XG4gICAgXG4gICAgY29uc3QgbmV3TW9kYWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaWFsb2cnKTtcbiAgICBuZXdNb2RhbC5jbGFzc0xpc3QuYWRkKCdwcm9qZWN0TW9kYWwnKTtcbiAgICBuZXdNb2RhbC5zZXRBdHRyaWJ1dGUoJ2lkJywgJ3Byb2plY3RNb2RhbCcpO1xuXG4gICAgY29uc3QgcHJvamVjdE1vZGFsSGVhZGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaDInKTtcbiAgICBwcm9qZWN0TW9kYWxIZWFkZXIudGV4dENvbnRlbnQgPSAnTmV3IFByb2plY3QnO1xuXG4gICAgY29uc3QgcHJvamVjdE1vZGFsRm9ybSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2Zvcm0nKTtcbiAgICBwcm9qZWN0TW9kYWxGb3JtLmNsYXNzTGlzdC5hZGQoJ3Byb2plY3RGb3JtJyk7XG4gICAgcHJvamVjdE1vZGFsRm9ybS5zZXRBdHRyaWJ1dGUoJ21ldGhvZCcsICdkaWFsb2cnKTtcblxuICAgIGNvbnN0IHByb2plY3ROYW1lRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgY29uc3QgcHJvamVjdE5hbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpO1xuICAgIGNvbnN0IHByb2plY3ROYW1lTGFiZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsYWJlbCcpO1xuICAgIHByb2plY3ROYW1lLnNldEF0dHJpYnV0ZSgndHlwZScsICd0ZXh0Jyk7XG4gICAgcHJvamVjdE5hbWUuc2V0QXR0cmlidXRlKCduYW1lJywgJ3Byb2plY3ROYW1lJyk7XG4gICAgcHJvamVjdE5hbWUuc2V0QXR0cmlidXRlKCdpZCcsICdwcm9qZWN0TmFtZScpO1xuICAgIHByb2plY3ROYW1lLnNldEF0dHJpYnV0ZSgncGxhY2Vob2xkZXInLCAnRml0bmVzcycpO1xuICAgIHByb2plY3ROYW1lTGFiZWwuc2V0QXR0cmlidXRlKCdmb3InLCAncHJvamVjdE5hbWUnKTtcbiAgICBwcm9qZWN0TmFtZUxhYmVsLnRleHRDb250ZW50ID0gJ1RpdGxlJztcbiAgICBwcm9qZWN0TmFtZURpdi5hcHBlbmRDaGlsZChwcm9qZWN0TmFtZUxhYmVsKTtcbiAgICBwcm9qZWN0TmFtZURpdi5hcHBlbmRDaGlsZChwcm9qZWN0TmFtZSk7XG5cbiAgICBjb25zdCBidG5zID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgYnRucy5jbGFzc0xpc3QuYWRkKCdidG5zJyk7XG4gICAgY29uc3Qgc3VibWl0QnRuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYnV0dG9uJyk7XG4gICAgc3VibWl0QnRuLmlubmVySFRNTCA9IGA8aSBjbGFzcz1cImZhLXNvbGlkIGZhLWNoZWNrXCI+PC9pPmA7XG4gICAgc3VibWl0QnRuLmNsYXNzTGlzdC5hZGQoJ3N1Ym1pdFByb2plY3RCdG4nKTtcbiAgICBzdWJtaXRCdG4uc2V0QXR0cmlidXRlKCd0eXBlJywgJ2J1dHRvbicpO1xuICAgIGNvbnN0IGNhbmNlbEJ0biA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2J1dHRvbicpO1xuICAgIGNhbmNlbEJ0bi5pbm5lckhUTUwgPSBgPGkgY2xhc3M9XCJmYS1zb2xpZCBmYS1iYW5cIj48L2k+YDtcbiAgICBjYW5jZWxCdG4uY2xhc3NMaXN0LmFkZCgnY2FuY2VsUHJvamVjdEJ0bicpO1xuICAgIHN1Ym1pdEJ0bi5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCAnYnV0dG9uJyk7XG4gICAgYnRucy5hcHBlbmRDaGlsZChzdWJtaXRCdG4pO1xuICAgIGJ0bnMuYXBwZW5kQ2hpbGQoY2FuY2VsQnRuKTtcblxuICAgIG5ld01vZGFsLmFwcGVuZENoaWxkKHByb2plY3RNb2RhbEhlYWRlcik7XG4gICAgcHJvamVjdE1vZGFsRm9ybS5hcHBlbmRDaGlsZChwcm9qZWN0TmFtZURpdik7XG4gICAgcHJvamVjdE1vZGFsRm9ybS5hcHBlbmRDaGlsZChidG5zKTtcbiAgICBuZXdNb2RhbC5hcHBlbmRDaGlsZChwcm9qZWN0TW9kYWxGb3JtKTtcblxuICAgIHJldHVybiB7bmV3TW9kYWwsIHByb2plY3RNb2RhbEZvcm0sIHByb2plY3ROYW1lLCBzdWJtaXRCdG4sIGNhbmNlbEJ0bn07XG59O1xuXG5cbmV4cG9ydCBjb25zdCBjcmVhdGVFZGl0TW9kYWwgPSAobmFtZSwgZGVzY3JpcHRpb24sIGR1ZURhdGUsIHByaW9yaXR5KSA9PiB7XG4gICAgXG4gICAgY29uc3QgbmV3TW9kYWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaWFsb2cnKTtcbiAgICBuZXdNb2RhbC5jbGFzc0xpc3QuYWRkKCdlZGl0TW9kYWwnKTtcbiAgICBuZXdNb2RhbC5zZXRBdHRyaWJ1dGUoJ2lkJywgJ2VkaXRNb2RhbCcpO1xuXG4gICAgY29uc3QgZWRpdE1vZGFsSGVhZGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaDInKTtcbiAgICBlZGl0TW9kYWxIZWFkZXIudGV4dENvbnRlbnQgPSAnRWRpdCBUYXNrJztcblxuICAgIGNvbnN0IGVkaXRNb2RhbEZvcm0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdmb3JtJyk7XG4gICAgZWRpdE1vZGFsRm9ybS5jbGFzc0xpc3QuYWRkKCdlZGl0Rm9ybScpO1xuICAgIGVkaXRNb2RhbEZvcm0uc2V0QXR0cmlidXRlKCdtZXRob2QnLCAnZGlhbG9nJyk7XG5cbiAgICBjb25zdCB0YXNrTmFtZURpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGNvbnN0IHRhc2tOYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcbiAgICBjb25zdCB0YXNrTmFtZUxhYmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGFiZWwnKTtcbiAgICB0YXNrTmFtZS5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCAndGV4dCcpO1xuICAgIHRhc2tOYW1lLnNldEF0dHJpYnV0ZSgnbmFtZScsICd0YXNrTmFtZScpO1xuICAgIHRhc2tOYW1lLnNldEF0dHJpYnV0ZSgnaWQnLCAndGFza05hbWUnKTtcbiAgICB0YXNrTmFtZS5zZXRBdHRyaWJ1dGUoJ3BsYWNlaG9sZGVyJywgJ1Rha2Ugb3V0IHRoZSB0cmFzaCcpO1xuICAgIHRhc2tOYW1lLnNldEF0dHJpYnV0ZSgndmFsdWUnLCBuYW1lKTtcbiAgICB0YXNrTmFtZUxhYmVsLnNldEF0dHJpYnV0ZSgnZm9yJywgJ3Rhc2tOYW1lJyk7XG4gICAgdGFza05hbWVMYWJlbC50ZXh0Q29udGVudCA9ICdUaXRsZSc7XG4gICAgdGFza05hbWVEaXYuYXBwZW5kQ2hpbGQodGFza05hbWVMYWJlbCk7XG4gICAgdGFza05hbWVEaXYuYXBwZW5kQ2hpbGQodGFza05hbWUpO1xuXG4gICAgY29uc3QgdGFza0Rlc2NyaXB0aW9uRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgY29uc3QgdGFza0Rlc2NyaXB0aW9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGV4dGFyZWEnKTtcbiAgICBjb25zdCB0YXNrRGVzY3JpcHRpb25MYWJlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xhYmVsJyk7XG4gICAgdGFza0Rlc2NyaXB0aW9uLnNldEF0dHJpYnV0ZSgnbmFtZScsICd0YXNrRGVzY3JpcHRpb24nKTtcbiAgICB0YXNrRGVzY3JpcHRpb24uc2V0QXR0cmlidXRlKCdpZCcsICd0YXNrRGVzY3JpcHRpb24nKTtcbiAgICB0YXNrRGVzY3JpcHRpb24uc2V0QXR0cmlidXRlKCdwbGFjZWhvbGRlcicsICdJIGF2b2lkIHRoZSBhY3VtdWxhdGlvbiBvZiB0cmFzaCBieSBwZXJmb3JtaW5nIHRoZSBzYWNyZWQgYXJ0IG9mIHJlbW92aW5nIHNhaWQgdHJhc2guLi4nKTtcbiAgICB0YXNrRGVzY3JpcHRpb24udmFsdWUgPSBkZXNjcmlwdGlvbjtcbiAgICB0YXNrRGVzY3JpcHRpb25MYWJlbC5zZXRBdHRyaWJ1dGUoJ2ZvcicsICd0YXNrRGVzY3JpcHRpb24nKTtcbiAgICB0YXNrRGVzY3JpcHRpb25MYWJlbC50ZXh0Q29udGVudCA9ICdEZXNjcmlwdGlvbic7XG4gICAgdGFza0Rlc2NyaXB0aW9uRGl2LmFwcGVuZENoaWxkKHRhc2tEZXNjcmlwdGlvbkxhYmVsKTtcbiAgICB0YXNrRGVzY3JpcHRpb25EaXYuYXBwZW5kQ2hpbGQodGFza0Rlc2NyaXB0aW9uKTtcblxuICAgIGNvbnN0IHRhc2tEdWVEYXRlRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgY29uc3QgdGFza0R1ZURhdGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpO1xuICAgIGNvbnN0IHRhc2tEdWVEYXRlTGFiZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsYWJlbCcpO1xuICAgIHRhc2tEdWVEYXRlLnNldEF0dHJpYnV0ZSgndHlwZScsICdkYXRldGltZS1sb2NhbCcpO1xuICAgIHRhc2tEdWVEYXRlLnNldEF0dHJpYnV0ZSgnbmFtZScsICd0YXNrRHVlRGF0ZScpO1xuICAgIHRhc2tEdWVEYXRlLnNldEF0dHJpYnV0ZSgnaWQnLCAndGFza0R1ZURhdGUnKTtcbiAgICB0YXNrRHVlRGF0ZS5zZXRBdHRyaWJ1dGUoJ3ZhbHVlJywgZHVlRGF0ZSk7XG4gICAgdGFza0R1ZURhdGVMYWJlbC5zZXRBdHRyaWJ1dGUoJ2ZvcicsICd0YXNrRHVlRGF0ZScpO1xuICAgIHRhc2tEdWVEYXRlTGFiZWwudGV4dENvbnRlbnQgPSAnRHVlIERhdGUnO1xuICAgIHRhc2tEdWVEYXRlRGl2LmFwcGVuZENoaWxkKHRhc2tEdWVEYXRlTGFiZWwpO1xuICAgIHRhc2tEdWVEYXRlRGl2LmFwcGVuZENoaWxkKHRhc2tEdWVEYXRlKTtcblxuICAgIGNvbnN0IHRhc2tQcmlvcml0eURpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGNvbnN0IHRhc2tQcmlvcml0eSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NlbGVjdCcpO1xuICAgIGNvbnN0IHRhc2tQcmlvcml0eUxhYmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGFiZWwnKTtcbiAgICB0YXNrUHJpb3JpdHkuc2V0QXR0cmlidXRlKCduYW1lJywgJ3Rhc2tQcmlvcml0eScpO1xuICAgIHRhc2tQcmlvcml0eS5zZXRBdHRyaWJ1dGUoJ2lkJywgJ3Rhc2tQcmlvcml0eUVkaXQnKTtcbiAgICB0YXNrUHJpb3JpdHlMYWJlbC5zZXRBdHRyaWJ1dGUoJ2ZvcicsICd0YXNrUHJpb3JpdHknKTtcbiAgICB0YXNrUHJpb3JpdHlMYWJlbC50ZXh0Q29udGVudCA9ICdQcmlvcml0eSc7XG4gICAgY29uc3QgaGlnaFByaW9yaXR5ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnb3B0aW9uJyk7XG4gICAgaGlnaFByaW9yaXR5LnRleHRDb250ZW50ID0gJ0hpZ2gnO1xuICAgIGNvbnN0IG5vcm1hbFByaW9yaXR5ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnb3B0aW9uJyk7XG4gICAgbm9ybWFsUHJpb3JpdHkudGV4dENvbnRlbnQgPSAnTm9ybWFsJztcbiAgICBjb25zdCBsb3dQcmlvcml0eSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ29wdGlvbicpO1xuICAgIGxvd1ByaW9yaXR5LnRleHRDb250ZW50ID0gJ0xvdyc7XG5cbiAgICB0YXNrUHJpb3JpdHkuYXBwZW5kQ2hpbGQoaGlnaFByaW9yaXR5KTtcbiAgICB0YXNrUHJpb3JpdHkuYXBwZW5kQ2hpbGQobm9ybWFsUHJpb3JpdHkpO1xuICAgIHRhc2tQcmlvcml0eS5hcHBlbmRDaGlsZChsb3dQcmlvcml0eSk7XG5cbiAgICB0YXNrUHJpb3JpdHkudmFsdWUgPSBwcmlvcml0eTtcbiAgICBcbiAgICB0YXNrUHJpb3JpdHlEaXYuYXBwZW5kQ2hpbGQodGFza1ByaW9yaXR5TGFiZWwpO1xuICAgIHRhc2tQcmlvcml0eURpdi5hcHBlbmRDaGlsZCh0YXNrUHJpb3JpdHkpO1xuXG4gICAgY29uc3QgYnRucyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGJ0bnMuY2xhc3NMaXN0LmFkZCgnYnRucycpO1xuICAgIGNvbnN0IHN1Ym1pdEJ0biA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2J1dHRvbicpO1xuICAgIHN1Ym1pdEJ0bi5pbm5lckhUTUwgPSBgPGkgY2xhc3M9XCJmYS1zb2xpZCBmYS1jaGVja1wiPjwvaT5gO1xuICAgIHN1Ym1pdEJ0bi5jbGFzc0xpc3QuYWRkKCdzdWJtaXRFZGl0QnRuJyk7XG4gICAgc3VibWl0QnRuLnNldEF0dHJpYnV0ZSgndHlwZScsICdidXR0b24nKTtcbiAgICBjb25zdCBjYW5jZWxCdG4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdidXR0b24nKTtcbiAgICBjYW5jZWxCdG4uaW5uZXJIVE1MID0gYDxpIGNsYXNzPVwiZmEtc29saWQgZmEtYmFuXCI+PC9pPmA7XG4gICAgY2FuY2VsQnRuLmNsYXNzTGlzdC5hZGQoJ2NhbmNlbEVkaXRCdG4nKTtcbiAgICBzdWJtaXRCdG4uc2V0QXR0cmlidXRlKCd0eXBlJywgJ2J1dHRvbicpO1xuICAgIGJ0bnMuYXBwZW5kQ2hpbGQoc3VibWl0QnRuKTtcbiAgICBidG5zLmFwcGVuZENoaWxkKGNhbmNlbEJ0bik7XG5cbiAgICBuZXdNb2RhbC5hcHBlbmRDaGlsZChlZGl0TW9kYWxIZWFkZXIpO1xuICAgIGVkaXRNb2RhbEZvcm0uYXBwZW5kQ2hpbGQodGFza05hbWVEaXYpO1xuICAgIGVkaXRNb2RhbEZvcm0uYXBwZW5kQ2hpbGQodGFza0Rlc2NyaXB0aW9uRGl2KTtcbiAgICBlZGl0TW9kYWxGb3JtLmFwcGVuZENoaWxkKHRhc2tEdWVEYXRlRGl2KTtcbiAgICBlZGl0TW9kYWxGb3JtLmFwcGVuZENoaWxkKHRhc2tQcmlvcml0eURpdik7XG4gICAgZWRpdE1vZGFsRm9ybS5hcHBlbmRDaGlsZChidG5zKTtcbiAgICBuZXdNb2RhbC5hcHBlbmRDaGlsZChlZGl0TW9kYWxGb3JtKTtcblxuICAgIHJldHVybiB7bmV3TW9kYWwsIGVkaXRNb2RhbEZvcm0sIHRhc2tOYW1lLCB0YXNrRHVlRGF0ZSwgdGFza1ByaW9yaXR5LCBcbiAgICAgICAgdGFza0Rlc2NyaXB0aW9uLCBzdWJtaXRCdG4sIGNhbmNlbEJ0bn07XG59OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/js/createModals.js\n");

/***/ }),

/***/ "./src/js/defaultProjects.js":
/*!***********************************!*\
  !*** ./src/js/defaultProjects.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _project__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./project */ \"./src/js/project.js\");\n/* harmony import */ var _todo__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./todo */ \"./src/js/todo.js\");\n\n\n\n\n// localStorage.clear();\n\n// const listOfProjects = JSON.parse(localStorage.getItem('lists')) || [];\n// let currentProjectIndex = localStorage.getItem('listID') || 0;\n\nlet a=(0,_todo__WEBPACK_IMPORTED_MODULE_1__.Todo)('hi', 'hi', '2022-03-22T03:45', 'High', 10);\n\nlet projectCount = 0;\n\nconst defaultProj = (0,_project__WEBPACK_IMPORTED_MODULE_0__.Project)(\"General\", projectCount);\nprojectCount++;\nlistOfProjects.push(defaultProj);\n\nconst everythingProj = (0,_project__WEBPACK_IMPORTED_MODULE_0__.Project)(\"Everything\", projectCount);\nprojectCount++;\neverythingProj.addToList(a);\nlistOfProjects.push(everythingProj);\n\nconst todaysToDos = (0,_project__WEBPACK_IMPORTED_MODULE_0__.Project)(\"Today's 2Dos\", projectCount);\nprojectCount++;\nlistOfProjects.push(todaysToDos);\n\nconst thisWeeksToDos = (0,_project__WEBPACK_IMPORTED_MODULE_0__.Project)(\"Week's 2Dos\", projectCount);\nprojectCount++;\nlistOfProjects.push(thisWeeksToDos);\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({ listOfProjects, currentProjectIndex, projectCount,\n    defaultProj, todaysToDos, thisWeeksToDos });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvanMvZGVmYXVsdFByb2plY3RzLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFvQztBQUNOOzs7QUFHOUI7O0FBRUE7QUFDQTs7QUFFQSxNQUFNLDJDQUFJOztBQUVWOztBQUVBLG9CQUFvQixpREFBTztBQUMzQjtBQUNBOztBQUVBLHVCQUF1QixpREFBTztBQUM5QjtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLGlEQUFPO0FBQzNCO0FBQ0E7O0FBRUEsdUJBQXVCLGlEQUFPO0FBQzlCO0FBQ0E7OztBQUdBLGlFQUFlLEVBQUU7QUFDakIsOENBQThDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdG9kby1saXN0Ly4vc3JjL2pzL2RlZmF1bHRQcm9qZWN0cy5qcz82N2E1Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFByb2plY3QgfSBmcm9tICcuL3Byb2plY3QnO1xuaW1wb3J0IHsgVG9kbyB9IGZyb20gJy4vdG9kbyc7XG5cblxuLy8gbG9jYWxTdG9yYWdlLmNsZWFyKCk7XG5cbi8vIGNvbnN0IGxpc3RPZlByb2plY3RzID0gSlNPTi5wYXJzZShsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnbGlzdHMnKSkgfHwgW107XG4vLyBsZXQgY3VycmVudFByb2plY3RJbmRleCA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdsaXN0SUQnKSB8fCAwO1xuXG5sZXQgYT1Ub2RvKCdoaScsICdoaScsICcyMDIyLTAzLTIyVDAzOjQ1JywgJ0hpZ2gnLCAxMCk7XG5cbmxldCBwcm9qZWN0Q291bnQgPSAwO1xuXG5jb25zdCBkZWZhdWx0UHJvaiA9IFByb2plY3QoXCJHZW5lcmFsXCIsIHByb2plY3RDb3VudCk7XG5wcm9qZWN0Q291bnQrKztcbmxpc3RPZlByb2plY3RzLnB1c2goZGVmYXVsdFByb2opO1xuXG5jb25zdCBldmVyeXRoaW5nUHJvaiA9IFByb2plY3QoXCJFdmVyeXRoaW5nXCIsIHByb2plY3RDb3VudCk7XG5wcm9qZWN0Q291bnQrKztcbmV2ZXJ5dGhpbmdQcm9qLmFkZFRvTGlzdChhKTtcbmxpc3RPZlByb2plY3RzLnB1c2goZXZlcnl0aGluZ1Byb2opO1xuXG5jb25zdCB0b2RheXNUb0RvcyA9IFByb2plY3QoXCJUb2RheSdzIDJEb3NcIiwgcHJvamVjdENvdW50KTtcbnByb2plY3RDb3VudCsrO1xubGlzdE9mUHJvamVjdHMucHVzaCh0b2RheXNUb0Rvcyk7XG5cbmNvbnN0IHRoaXNXZWVrc1RvRG9zID0gUHJvamVjdChcIldlZWsncyAyRG9zXCIsIHByb2plY3RDb3VudCk7XG5wcm9qZWN0Q291bnQrKztcbmxpc3RPZlByb2plY3RzLnB1c2godGhpc1dlZWtzVG9Eb3MpO1xuXG5cbmV4cG9ydCBkZWZhdWx0IHsgbGlzdE9mUHJvamVjdHMsIGN1cnJlbnRQcm9qZWN0SW5kZXgsIHByb2plY3RDb3VudCxcbiAgICBkZWZhdWx0UHJvaiwgdG9kYXlzVG9Eb3MsIHRoaXNXZWVrc1RvRG9zIH07Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/js/defaultProjects.js\n");

/***/ }),

/***/ "./src/js/documentParts.js":
/*!*********************************!*\
  !*** ./src/js/documentParts.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nconst body = document.querySelector('body');\n\nconst sidebar = document.querySelector('.sidebar');\nconst todaysToDos = document.querySelector('.today');\nconst thisWeeksToDos = document.querySelector('.week');\nconst defaultProject = document.querySelector('.defaultProject');\nconst projects = document.querySelector('#projectsContainer');\n\nconst addProjectBtn = document.querySelector('.addProjectBtn');\nconst addToDoBtn = document.querySelector('.addToDoBtn');\n\nconst toDoList = document.querySelector('.todoList');\nconst table = document.querySelector('table');\nconst tableTitle = document.querySelector('.titles.projName');\nconst tableDueDate = document.querySelector('.titles.dueDate');\n\n\nconst modal = document.querySelector('#modal');\nconst editModal = document.querySelector('#editModal');\nconst creationModalTaskName = document.querySelector('.createTaskName');\nconst creationModalTaskDescription = document.querySelector('.createTaskDescription');\nconst creationModalTaskDueDate = document.querySelector('.createTaskDueDate');\nconst creationModalTaskPriority = document.querySelector('.createTaskPriority');\nconst modalCancelBtn = document.querySelector('.createModalCancelBtn');\nconst modalSubmitBtn = document.querySelector('.createModalSubmitBtn');\n\nconst toDoCounter = 0;\n\nconst setPriorityColors = (value, el) => {\n  if(value === 'High'){\n    el.style = 'border-left: 10px solid red; border-radius: 5px;';\n  }\n  else if(value === 'Normal'){\n    el.style = 'border-left: 10px solid yellow; border-radius: 5px;';\n  }\n  else if(value === 'Low'){\n      el.style = 'border-left: 10px solid green; border-radius: 5px;';\n  }\n};\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n\n  sidebar, body, todaysToDos, thisWeeksToDos, projects, defaultProject,\n  toDoList, table, tableTitle, tableDueDate, addToDoBtn, toDoCounter, modal,\n  creationModalTaskName, creationModalTaskDescription, creationModalTaskDueDate,\n  creationModalTaskPriority, editModal, modalCancelBtn, modalSubmitBtn, addProjectBtn,\n  setPriorityColors,\n\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvanMvZG9jdW1lbnRQYXJ0cy5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSw2Q0FBNkMsbUJBQW1CO0FBQ2hFO0FBQ0E7QUFDQSxnREFBZ0QsbUJBQW1CO0FBQ25FO0FBQ0E7QUFDQSxpREFBaUQsbUJBQW1CO0FBQ3BFO0FBQ0E7O0FBRUEsaUVBQWU7O0FBRWY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdG9kby1saXN0Ly4vc3JjL2pzL2RvY3VtZW50UGFydHMuanM/NjllZCJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBib2R5ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignYm9keScpO1xuXG5jb25zdCBzaWRlYmFyID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLnNpZGViYXInKTtcbmNvbnN0IHRvZGF5c1RvRG9zID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLnRvZGF5Jyk7XG5jb25zdCB0aGlzV2Vla3NUb0RvcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy53ZWVrJyk7XG5jb25zdCBkZWZhdWx0UHJvamVjdCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5kZWZhdWx0UHJvamVjdCcpO1xuY29uc3QgcHJvamVjdHMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjcHJvamVjdHNDb250YWluZXInKTtcblxuY29uc3QgYWRkUHJvamVjdEJ0biA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5hZGRQcm9qZWN0QnRuJyk7XG5jb25zdCBhZGRUb0RvQnRuID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmFkZFRvRG9CdG4nKTtcblxuY29uc3QgdG9Eb0xpc3QgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcudG9kb0xpc3QnKTtcbmNvbnN0IHRhYmxlID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcigndGFibGUnKTtcbmNvbnN0IHRhYmxlVGl0bGUgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcudGl0bGVzLnByb2pOYW1lJyk7XG5jb25zdCB0YWJsZUR1ZURhdGUgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcudGl0bGVzLmR1ZURhdGUnKTtcblxuXG5jb25zdCBtb2RhbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNtb2RhbCcpO1xuY29uc3QgZWRpdE1vZGFsID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI2VkaXRNb2RhbCcpO1xuY29uc3QgY3JlYXRpb25Nb2RhbFRhc2tOYW1lID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmNyZWF0ZVRhc2tOYW1lJyk7XG5jb25zdCBjcmVhdGlvbk1vZGFsVGFza0Rlc2NyaXB0aW9uID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmNyZWF0ZVRhc2tEZXNjcmlwdGlvbicpO1xuY29uc3QgY3JlYXRpb25Nb2RhbFRhc2tEdWVEYXRlID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmNyZWF0ZVRhc2tEdWVEYXRlJyk7XG5jb25zdCBjcmVhdGlvbk1vZGFsVGFza1ByaW9yaXR5ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmNyZWF0ZVRhc2tQcmlvcml0eScpO1xuY29uc3QgbW9kYWxDYW5jZWxCdG4gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuY3JlYXRlTW9kYWxDYW5jZWxCdG4nKTtcbmNvbnN0IG1vZGFsU3VibWl0QnRuID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmNyZWF0ZU1vZGFsU3VibWl0QnRuJyk7XG5cbmNvbnN0IHRvRG9Db3VudGVyID0gMDtcblxuY29uc3Qgc2V0UHJpb3JpdHlDb2xvcnMgPSAodmFsdWUsIGVsKSA9PiB7XG4gIGlmKHZhbHVlID09PSAnSGlnaCcpe1xuICAgIGVsLnN0eWxlID0gJ2JvcmRlci1sZWZ0OiAxMHB4IHNvbGlkIHJlZDsgYm9yZGVyLXJhZGl1czogNXB4Oyc7XG4gIH1cbiAgZWxzZSBpZih2YWx1ZSA9PT0gJ05vcm1hbCcpe1xuICAgIGVsLnN0eWxlID0gJ2JvcmRlci1sZWZ0OiAxMHB4IHNvbGlkIHllbGxvdzsgYm9yZGVyLXJhZGl1czogNXB4Oyc7XG4gIH1cbiAgZWxzZSBpZih2YWx1ZSA9PT0gJ0xvdycpe1xuICAgICAgZWwuc3R5bGUgPSAnYm9yZGVyLWxlZnQ6IDEwcHggc29saWQgZ3JlZW47IGJvcmRlci1yYWRpdXM6IDVweDsnO1xuICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCB7XG5cbiAgc2lkZWJhciwgYm9keSwgdG9kYXlzVG9Eb3MsIHRoaXNXZWVrc1RvRG9zLCBwcm9qZWN0cywgZGVmYXVsdFByb2plY3QsXG4gIHRvRG9MaXN0LCB0YWJsZSwgdGFibGVUaXRsZSwgdGFibGVEdWVEYXRlLCBhZGRUb0RvQnRuLCB0b0RvQ291bnRlciwgbW9kYWwsXG4gIGNyZWF0aW9uTW9kYWxUYXNrTmFtZSwgY3JlYXRpb25Nb2RhbFRhc2tEZXNjcmlwdGlvbiwgY3JlYXRpb25Nb2RhbFRhc2tEdWVEYXRlLFxuICBjcmVhdGlvbk1vZGFsVGFza1ByaW9yaXR5LCBlZGl0TW9kYWwsIG1vZGFsQ2FuY2VsQnRuLCBtb2RhbFN1Ym1pdEJ0biwgYWRkUHJvamVjdEJ0bixcbiAgc2V0UHJpb3JpdHlDb2xvcnMsXG5cbn07Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/js/documentParts.js\n");

/***/ }),

/***/ "./src/js/project.js":
/*!***************************!*\
  !*** ./src/js/project.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Project\": () => (/* binding */ Project)\n/* harmony export */ });\nconst Project = (title, index) => {\n\n    let arr = [];\n\n    const getTitle = () => title;\n    const getIndex = () => index;\n    \n    const setTitle = (newTitle) => title = newTitle; \n    const setIndex = (newIndex) => index = newIndex;\n\n    const addToList = (obj) => arr.push(obj);\n    const removeFromList = (targetID) => {\n        let index;\n        for(let i = 0; i < arr.length; i++){\n            if (arr[i].getID() == targetID){\n                index = i;\n            }\n            if(index > -1){\n                arr.splice(index, 1);\n            }\n        }\n    };\n\n    const filterTodaysToDos = () => {\n        const todaysToDos = arr.filter(toDo => toDo.isTodayCheck(toDo.convertedDate(toDo.getDueDate())));\n        return todaysToDos;\n    };\n    const filterThisWeeksToDos = () => {\n        const thisWeeksToDos = arr.filter(toDo => toDo.isThisWeekCheck(toDo.convertedDate(toDo.getDueDate())));\n        return thisWeeksToDos;\n    }\n\n    return {getTitle, getIndex, setTitle, \n        setIndex, arr, addToList, removeFromList,\n        filterTodaysToDos, filterThisWeeksToDos,\n    };\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvanMvcHJvamVjdC5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQU87O0FBRVA7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsZ0JBQWdCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90b2RvLWxpc3QvLi9zcmMvanMvcHJvamVjdC5qcz9lZjU4Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjb25zdCBQcm9qZWN0ID0gKHRpdGxlLCBpbmRleCkgPT4ge1xuXG4gICAgbGV0IGFyciA9IFtdO1xuXG4gICAgY29uc3QgZ2V0VGl0bGUgPSAoKSA9PiB0aXRsZTtcbiAgICBjb25zdCBnZXRJbmRleCA9ICgpID0+IGluZGV4O1xuICAgIFxuICAgIGNvbnN0IHNldFRpdGxlID0gKG5ld1RpdGxlKSA9PiB0aXRsZSA9IG5ld1RpdGxlOyBcbiAgICBjb25zdCBzZXRJbmRleCA9IChuZXdJbmRleCkgPT4gaW5kZXggPSBuZXdJbmRleDtcblxuICAgIGNvbnN0IGFkZFRvTGlzdCA9IChvYmopID0+IGFyci5wdXNoKG9iaik7XG4gICAgY29uc3QgcmVtb3ZlRnJvbUxpc3QgPSAodGFyZ2V0SUQpID0+IHtcbiAgICAgICAgbGV0IGluZGV4O1xuICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgIGlmIChhcnJbaV0uZ2V0SUQoKSA9PSB0YXJnZXRJRCl7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYoaW5kZXggPiAtMSl7XG4gICAgICAgICAgICAgICAgYXJyLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgY29uc3QgZmlsdGVyVG9kYXlzVG9Eb3MgPSAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHRvZGF5c1RvRG9zID0gYXJyLmZpbHRlcih0b0RvID0+IHRvRG8uaXNUb2RheUNoZWNrKHRvRG8uY29udmVydGVkRGF0ZSh0b0RvLmdldER1ZURhdGUoKSkpKTtcbiAgICAgICAgcmV0dXJuIHRvZGF5c1RvRG9zO1xuICAgIH07XG4gICAgY29uc3QgZmlsdGVyVGhpc1dlZWtzVG9Eb3MgPSAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHRoaXNXZWVrc1RvRG9zID0gYXJyLmZpbHRlcih0b0RvID0+IHRvRG8uaXNUaGlzV2Vla0NoZWNrKHRvRG8uY29udmVydGVkRGF0ZSh0b0RvLmdldER1ZURhdGUoKSkpKTtcbiAgICAgICAgcmV0dXJuIHRoaXNXZWVrc1RvRG9zO1xuICAgIH1cblxuICAgIHJldHVybiB7Z2V0VGl0bGUsIGdldEluZGV4LCBzZXRUaXRsZSwgXG4gICAgICAgIHNldEluZGV4LCBhcnIsIGFkZFRvTGlzdCwgcmVtb3ZlRnJvbUxpc3QsXG4gICAgICAgIGZpbHRlclRvZGF5c1RvRG9zLCBmaWx0ZXJUaGlzV2Vla3NUb0RvcyxcbiAgICB9O1xufTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/js/project.js\n");

/***/ }),

/***/ "./src/js/projectPageGeneration.js":
/*!*****************************************!*\
  !*** ./src/js/projectPageGeneration.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"generateDefaultToDos\": () => (/* binding */ generateDefaultToDos),\n/* harmony export */   \"generateProject\": () => (/* binding */ generateProject),\n/* harmony export */   \"generateThisWeeksToDos\": () => (/* binding */ generateThisWeeksToDos),\n/* harmony export */   \"generateTodaysToDos\": () => (/* binding */ generateTodaysToDos)\n/* harmony export */ });\n/* harmony import */ var _documentParts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./documentParts */ \"./src/js/documentParts.js\");\n/* harmony import */ var _defaultProjects__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./defaultProjects */ \"./src/js/defaultProjects.js\");\n/* harmony import */ var _addListeners__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./addListeners */ \"./src/js/addListeners.js\");\n/* harmony import */ var _time__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./time */ \"./src/js/time.js\");\n\n\n\n\n\nconst generateProject = (selectedProject) => {\n    _defaultProjects__WEBPACK_IMPORTED_MODULE_1__[\"default\"].currentProjectIndex = selectedProject.getIndex();\n    clearOldProject();\n    generateTableHeader(selectedProject);\n    generateRows(selectedProject);\n    (0,_addListeners__WEBPACK_IMPORTED_MODULE_2__.addEventListeners)();\n};\n\nconst clearOldProject = () => {\n    _documentParts__WEBPACK_IMPORTED_MODULE_0__[\"default\"].table.textContent = '';\n};\n\nconst generateTableHeader = (selectedProject) => {\n    let tr = document.createElement('tr');\n    tr.classList.add('titles');\n    let thProjName = document.createElement('th');\n    thProjName.classList.add('projName');\n    thProjName.textContent = selectedProject.getTitle().substring(0,30);\n    let thDueDate = document.createElement('th');\n    thDueDate.classList.add('dueDate');\n    thDueDate.innerHTML = `Due Date <i class=\"fa-solid fa-calendar-day\"></i>`;\n    tr.appendChild(thProjName);\n    tr.appendChild(thDueDate);\n    _documentParts__WEBPACK_IMPORTED_MODULE_0__[\"default\"].table.appendChild(tr);\n};\n\nconst generateRows = (selectedProject) => {\n\n    if(selectedProject.getIndex() == 2 || selectedProject.getIndex() == 3){\n        const makeRow = (row) => {\n            const tr = document.createElement('tr');\n            tr.classList.add('viewOnly');\n            tr.setAttribute('data-index', `${row.getID()}`);\n            const td1 = document.createElement('td');\n            const td2 = document.createElement('td');\n            td1.classList.add('column1');\n            td2.classList.add('column2');\n\n            _documentParts__WEBPACK_IMPORTED_MODULE_0__[\"default\"].setPriorityColors(row.getPriority(), td1);\n    \n            td1.innerHTML = `${row.getTitle()}`;\n            td2.innerHTML = `${(0,_time__WEBPACK_IMPORTED_MODULE_3__.dateFilter)(row.getDueDate())}`;\n    \n            tr.appendChild(td1);\n            tr.appendChild(td2);\n    \n            return tr;\n        };\n    \n        for (let i = 0; i < selectedProject.arr.length; i++) {\n            _documentParts__WEBPACK_IMPORTED_MODULE_0__[\"default\"].table.appendChild(makeRow(selectedProject.arr[i]));\n        }\n        if(_documentParts__WEBPACK_IMPORTED_MODULE_0__[\"default\"].toDoList.contains(_documentParts__WEBPACK_IMPORTED_MODULE_0__[\"default\"].addToDoBtn)){\n            _documentParts__WEBPACK_IMPORTED_MODULE_0__[\"default\"].toDoList.removeChild(_documentParts__WEBPACK_IMPORTED_MODULE_0__[\"default\"].addToDoBtn);\n        }\n    }\n    else{\n        const makeRow = (row) => {\n            const tr = document.createElement('tr');\n            tr.classList.add('createdRow');\n            tr.setAttribute('data-index', `${row.getID()}`);\n            const td1 = document.createElement('td');\n            const td2 = document.createElement('td');\n            td1.classList.add('column1');\n            td2.classList.add('column2');\n\n            _documentParts__WEBPACK_IMPORTED_MODULE_0__[\"default\"].setPriorityColors(row.getPriority(), td1);\n    \n            td1.innerHTML = `<i class=\"fa-regular fa-square\"></i> ${row.getTitle()}`;\n            td2.innerHTML = `${(0,_time__WEBPACK_IMPORTED_MODULE_3__.dateFilter)(row.getDueDate())} <i class=\"fa-regular fa-pen-to-square\"></i><i class=\"fa-regular fa-trash-can\"></i>`;\n    \n            tr.appendChild(td1);\n            tr.appendChild(td2);\n    \n            return tr;\n        };\n    \n        for (let i = 0; i < selectedProject.arr.length; i++) {\n            _documentParts__WEBPACK_IMPORTED_MODULE_0__[\"default\"].table.appendChild(makeRow(selectedProject.arr[i]));\n        }\n        \n        if(!_documentParts__WEBPACK_IMPORTED_MODULE_0__[\"default\"].toDoList.contains(_documentParts__WEBPACK_IMPORTED_MODULE_0__[\"default\"].addToDoBtn)){\n            _documentParts__WEBPACK_IMPORTED_MODULE_0__[\"default\"].toDoList.appendChild(_documentParts__WEBPACK_IMPORTED_MODULE_0__[\"default\"].addToDoBtn);\n        }\n    }            \n\n};\n\nconst generateTodaysToDos = () => {\n    _defaultProjects__WEBPACK_IMPORTED_MODULE_1__[\"default\"].listOfProjects[2].arr.splice(0, _defaultProjects__WEBPACK_IMPORTED_MODULE_1__[\"default\"].listOfProjects[2].arr.length, ..._defaultProjects__WEBPACK_IMPORTED_MODULE_1__[\"default\"].listOfProjects[1].filterTodaysToDos());\n    generateProject(_defaultProjects__WEBPACK_IMPORTED_MODULE_1__[\"default\"].todaysToDos);\n};\n\nconst generateThisWeeksToDos = () => {\n    _defaultProjects__WEBPACK_IMPORTED_MODULE_1__[\"default\"].listOfProjects[3].arr.splice(0, _defaultProjects__WEBPACK_IMPORTED_MODULE_1__[\"default\"].listOfProjects[3].arr.length, ..._defaultProjects__WEBPACK_IMPORTED_MODULE_1__[\"default\"].listOfProjects[1].filterThisWeeksToDos());\n    generateProject(_defaultProjects__WEBPACK_IMPORTED_MODULE_1__[\"default\"].thisWeeksToDos);\n};\n\nconst generateDefaultToDos = () => {\n    generateProject(_defaultProjects__WEBPACK_IMPORTED_MODULE_1__[\"default\"].defaultProj);\n};\n\nconst setupDefaultProjects = () => {\n    _documentParts__WEBPACK_IMPORTED_MODULE_0__[\"default\"].todaysToDos.addEventListener('click', generateTodaysToDos);\n    _documentParts__WEBPACK_IMPORTED_MODULE_0__[\"default\"].thisWeeksToDos.addEventListener('click', generateThisWeeksToDos);\n    _documentParts__WEBPACK_IMPORTED_MODULE_0__[\"default\"].defaultProject.addEventListener('click', generateDefaultToDos);\n    generateProject(_defaultProjects__WEBPACK_IMPORTED_MODULE_1__[\"default\"].listOfProjects[_defaultProjects__WEBPACK_IMPORTED_MODULE_1__[\"default\"].currentProjectIndex]);\n};\n\nsetupDefaultProjects();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvanMvcHJvamVjdFBhZ2VHZW5lcmF0aW9uLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQWdDO0FBQ1M7QUFDVTtBQUNmOztBQUU3QjtBQUNQLElBQUksNEVBQTRCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLElBQUksZ0VBQWlCO0FBQ3JCOztBQUVBO0FBQ0EsSUFBSSx3RUFBbUI7QUFDdkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksd0VBQW1CO0FBQ3ZCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLFlBQVk7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsWUFBWSx3RUFBbUI7QUFDL0I7QUFDQSwrQkFBK0IsZUFBZTtBQUM5QywrQkFBK0IsaURBQVUsbUJBQW1CO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdDQUFnQztBQUN4RCxZQUFZLHdFQUFtQjtBQUMvQjtBQUNBLFdBQVcsd0VBQW1CLENBQUMsaUVBQVk7QUFDM0MsWUFBWSwyRUFBc0IsQ0FBQyxpRUFBWTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsWUFBWTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxZQUFZLHdFQUFtQjtBQUMvQjtBQUNBLG9FQUFvRSxlQUFlO0FBQ25GLCtCQUErQixpREFBVSxvQkFBb0I7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0NBQWdDO0FBQ3hELFlBQVksd0VBQW1CO0FBQy9CO0FBQ0E7QUFDQSxZQUFZLHdFQUFtQixDQUFDLGlFQUFZO0FBQzVDLFlBQVksMkVBQXNCLENBQUMsaUVBQVk7QUFDL0M7QUFDQTs7QUFFQTs7QUFFTztBQUNQLElBQUkscUZBQXFDLElBQUkscUZBQXFDLEtBQUssNEZBQTRDO0FBQ25JLG9CQUFvQixvRUFBb0I7QUFDeEM7O0FBRU87QUFDUCxJQUFJLHFGQUFxQyxJQUFJLHFGQUFxQyxLQUFLLCtGQUErQztBQUN0SSxvQkFBb0IsdUVBQXVCO0FBQzNDOztBQUVPO0FBQ1Asb0JBQW9CLG9FQUFvQjtBQUN4Qzs7QUFFQTtBQUNBLElBQUksbUZBQThCO0FBQ2xDLElBQUksc0ZBQWlDO0FBQ3JDLElBQUksc0ZBQWlDO0FBQ3JDLG9CQUFvQix1RUFBdUIsQ0FBQyw0RUFBNEI7QUFDeEU7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90b2RvLWxpc3QvLi9zcmMvanMvcHJvamVjdFBhZ2VHZW5lcmF0aW9uLmpzPzY3MjMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IF8gZnJvbSAnLi9kb2N1bWVudFBhcnRzJztcbmltcG9ydCBkZWZhdWx0cyBmcm9tICcuL2RlZmF1bHRQcm9qZWN0cyc7XG5pbXBvcnQgeyBhZGRFdmVudExpc3RlbmVycyB9IGZyb20gJy4vYWRkTGlzdGVuZXJzJztcbmltcG9ydCB7IGRhdGVGaWx0ZXIgfSBmcm9tICcuL3RpbWUnO1xuXG5leHBvcnQgY29uc3QgZ2VuZXJhdGVQcm9qZWN0ID0gKHNlbGVjdGVkUHJvamVjdCkgPT4ge1xuICAgIGRlZmF1bHRzLmN1cnJlbnRQcm9qZWN0SW5kZXggPSBzZWxlY3RlZFByb2plY3QuZ2V0SW5kZXgoKTtcbiAgICBjbGVhck9sZFByb2plY3QoKTtcbiAgICBnZW5lcmF0ZVRhYmxlSGVhZGVyKHNlbGVjdGVkUHJvamVjdCk7XG4gICAgZ2VuZXJhdGVSb3dzKHNlbGVjdGVkUHJvamVjdCk7XG4gICAgYWRkRXZlbnRMaXN0ZW5lcnMoKTtcbn07XG5cbmNvbnN0IGNsZWFyT2xkUHJvamVjdCA9ICgpID0+IHtcbiAgICBfLnRhYmxlLnRleHRDb250ZW50ID0gJyc7XG59O1xuXG5jb25zdCBnZW5lcmF0ZVRhYmxlSGVhZGVyID0gKHNlbGVjdGVkUHJvamVjdCkgPT4ge1xuICAgIGxldCB0ciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RyJyk7XG4gICAgdHIuY2xhc3NMaXN0LmFkZCgndGl0bGVzJyk7XG4gICAgbGV0IHRoUHJvak5hbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0aCcpO1xuICAgIHRoUHJvak5hbWUuY2xhc3NMaXN0LmFkZCgncHJvak5hbWUnKTtcbiAgICB0aFByb2pOYW1lLnRleHRDb250ZW50ID0gc2VsZWN0ZWRQcm9qZWN0LmdldFRpdGxlKCkuc3Vic3RyaW5nKDAsMzApO1xuICAgIGxldCB0aER1ZURhdGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0aCcpO1xuICAgIHRoRHVlRGF0ZS5jbGFzc0xpc3QuYWRkKCdkdWVEYXRlJyk7XG4gICAgdGhEdWVEYXRlLmlubmVySFRNTCA9IGBEdWUgRGF0ZSA8aSBjbGFzcz1cImZhLXNvbGlkIGZhLWNhbGVuZGFyLWRheVwiPjwvaT5gO1xuICAgIHRyLmFwcGVuZENoaWxkKHRoUHJvak5hbWUpO1xuICAgIHRyLmFwcGVuZENoaWxkKHRoRHVlRGF0ZSk7XG4gICAgXy50YWJsZS5hcHBlbmRDaGlsZCh0cik7XG59O1xuXG5jb25zdCBnZW5lcmF0ZVJvd3MgPSAoc2VsZWN0ZWRQcm9qZWN0KSA9PiB7XG5cbiAgICBpZihzZWxlY3RlZFByb2plY3QuZ2V0SW5kZXgoKSA9PSAyIHx8IHNlbGVjdGVkUHJvamVjdC5nZXRJbmRleCgpID09IDMpe1xuICAgICAgICBjb25zdCBtYWtlUm93ID0gKHJvdykgPT4ge1xuICAgICAgICAgICAgY29uc3QgdHIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0cicpO1xuICAgICAgICAgICAgdHIuY2xhc3NMaXN0LmFkZCgndmlld09ubHknKTtcbiAgICAgICAgICAgIHRyLnNldEF0dHJpYnV0ZSgnZGF0YS1pbmRleCcsIGAke3Jvdy5nZXRJRCgpfWApO1xuICAgICAgICAgICAgY29uc3QgdGQxID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGQnKTtcbiAgICAgICAgICAgIGNvbnN0IHRkMiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RkJyk7XG4gICAgICAgICAgICB0ZDEuY2xhc3NMaXN0LmFkZCgnY29sdW1uMScpO1xuICAgICAgICAgICAgdGQyLmNsYXNzTGlzdC5hZGQoJ2NvbHVtbjInKTtcblxuICAgICAgICAgICAgXy5zZXRQcmlvcml0eUNvbG9ycyhyb3cuZ2V0UHJpb3JpdHkoKSwgdGQxKTtcbiAgICBcbiAgICAgICAgICAgIHRkMS5pbm5lckhUTUwgPSBgJHtyb3cuZ2V0VGl0bGUoKX1gO1xuICAgICAgICAgICAgdGQyLmlubmVySFRNTCA9IGAke2RhdGVGaWx0ZXIocm93LmdldER1ZURhdGUoKSl9YDtcbiAgICBcbiAgICAgICAgICAgIHRyLmFwcGVuZENoaWxkKHRkMSk7XG4gICAgICAgICAgICB0ci5hcHBlbmRDaGlsZCh0ZDIpO1xuICAgIFxuICAgICAgICAgICAgcmV0dXJuIHRyO1xuICAgICAgICB9O1xuICAgIFxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNlbGVjdGVkUHJvamVjdC5hcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIF8udGFibGUuYXBwZW5kQ2hpbGQobWFrZVJvdyhzZWxlY3RlZFByb2plY3QuYXJyW2ldKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYoXy50b0RvTGlzdC5jb250YWlucyhfLmFkZFRvRG9CdG4pKXtcbiAgICAgICAgICAgIF8udG9Eb0xpc3QucmVtb3ZlQ2hpbGQoXy5hZGRUb0RvQnRuKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNle1xuICAgICAgICBjb25zdCBtYWtlUm93ID0gKHJvdykgPT4ge1xuICAgICAgICAgICAgY29uc3QgdHIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0cicpO1xuICAgICAgICAgICAgdHIuY2xhc3NMaXN0LmFkZCgnY3JlYXRlZFJvdycpO1xuICAgICAgICAgICAgdHIuc2V0QXR0cmlidXRlKCdkYXRhLWluZGV4JywgYCR7cm93LmdldElEKCl9YCk7XG4gICAgICAgICAgICBjb25zdCB0ZDEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZCcpO1xuICAgICAgICAgICAgY29uc3QgdGQyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGQnKTtcbiAgICAgICAgICAgIHRkMS5jbGFzc0xpc3QuYWRkKCdjb2x1bW4xJyk7XG4gICAgICAgICAgICB0ZDIuY2xhc3NMaXN0LmFkZCgnY29sdW1uMicpO1xuXG4gICAgICAgICAgICBfLnNldFByaW9yaXR5Q29sb3JzKHJvdy5nZXRQcmlvcml0eSgpLCB0ZDEpO1xuICAgIFxuICAgICAgICAgICAgdGQxLmlubmVySFRNTCA9IGA8aSBjbGFzcz1cImZhLXJlZ3VsYXIgZmEtc3F1YXJlXCI+PC9pPiAke3Jvdy5nZXRUaXRsZSgpfWA7XG4gICAgICAgICAgICB0ZDIuaW5uZXJIVE1MID0gYCR7ZGF0ZUZpbHRlcihyb3cuZ2V0RHVlRGF0ZSgpKX0gPGkgY2xhc3M9XCJmYS1yZWd1bGFyIGZhLXBlbi10by1zcXVhcmVcIj48L2k+PGkgY2xhc3M9XCJmYS1yZWd1bGFyIGZhLXRyYXNoLWNhblwiPjwvaT5gO1xuICAgIFxuICAgICAgICAgICAgdHIuYXBwZW5kQ2hpbGQodGQxKTtcbiAgICAgICAgICAgIHRyLmFwcGVuZENoaWxkKHRkMik7XG4gICAgXG4gICAgICAgICAgICByZXR1cm4gdHI7XG4gICAgICAgIH07XG4gICAgXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2VsZWN0ZWRQcm9qZWN0LmFyci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgXy50YWJsZS5hcHBlbmRDaGlsZChtYWtlUm93KHNlbGVjdGVkUHJvamVjdC5hcnJbaV0pKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYoIV8udG9Eb0xpc3QuY29udGFpbnMoXy5hZGRUb0RvQnRuKSl7XG4gICAgICAgICAgICBfLnRvRG9MaXN0LmFwcGVuZENoaWxkKF8uYWRkVG9Eb0J0bik7XG4gICAgICAgIH1cbiAgICB9ICAgICAgICAgICAgXG5cbn07XG5cbmV4cG9ydCBjb25zdCBnZW5lcmF0ZVRvZGF5c1RvRG9zID0gKCkgPT4ge1xuICAgIGRlZmF1bHRzLmxpc3RPZlByb2plY3RzWzJdLmFyci5zcGxpY2UoMCwgZGVmYXVsdHMubGlzdE9mUHJvamVjdHNbMl0uYXJyLmxlbmd0aCwgLi4uZGVmYXVsdHMubGlzdE9mUHJvamVjdHNbMV0uZmlsdGVyVG9kYXlzVG9Eb3MoKSk7XG4gICAgZ2VuZXJhdGVQcm9qZWN0KGRlZmF1bHRzLnRvZGF5c1RvRG9zKTtcbn07XG5cbmV4cG9ydCBjb25zdCBnZW5lcmF0ZVRoaXNXZWVrc1RvRG9zID0gKCkgPT4ge1xuICAgIGRlZmF1bHRzLmxpc3RPZlByb2plY3RzWzNdLmFyci5zcGxpY2UoMCwgZGVmYXVsdHMubGlzdE9mUHJvamVjdHNbM10uYXJyLmxlbmd0aCwgLi4uZGVmYXVsdHMubGlzdE9mUHJvamVjdHNbMV0uZmlsdGVyVGhpc1dlZWtzVG9Eb3MoKSk7XG4gICAgZ2VuZXJhdGVQcm9qZWN0KGRlZmF1bHRzLnRoaXNXZWVrc1RvRG9zKTtcbn07XG5cbmV4cG9ydCBjb25zdCBnZW5lcmF0ZURlZmF1bHRUb0RvcyA9ICgpID0+IHtcbiAgICBnZW5lcmF0ZVByb2plY3QoZGVmYXVsdHMuZGVmYXVsdFByb2opO1xufTtcblxuY29uc3Qgc2V0dXBEZWZhdWx0UHJvamVjdHMgPSAoKSA9PiB7XG4gICAgXy50b2RheXNUb0Rvcy5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGdlbmVyYXRlVG9kYXlzVG9Eb3MpO1xuICAgIF8udGhpc1dlZWtzVG9Eb3MuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBnZW5lcmF0ZVRoaXNXZWVrc1RvRG9zKTtcbiAgICBfLmRlZmF1bHRQcm9qZWN0LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZ2VuZXJhdGVEZWZhdWx0VG9Eb3MpO1xuICAgIGdlbmVyYXRlUHJvamVjdChkZWZhdWx0cy5saXN0T2ZQcm9qZWN0c1tkZWZhdWx0cy5jdXJyZW50UHJvamVjdEluZGV4XSk7XG59O1xuXG5zZXR1cERlZmF1bHRQcm9qZWN0cygpOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/js/projectPageGeneration.js\n");

/***/ }),

/***/ "./src/js/time.js":
/*!************************!*\
  !*** ./src/js/time.js ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"convertDate\": () => (/* binding */ convertDate),\n/* harmony export */   \"dateFilter\": () => (/* binding */ dateFilter),\n/* harmony export */   \"now\": () => (/* binding */ now),\n/* harmony export */   \"thisWeek\": () => (/* binding */ thisWeek),\n/* harmony export */   \"thisWeekCheck\": () => (/* binding */ thisWeekCheck),\n/* harmony export */   \"today\": () => (/* binding */ today),\n/* harmony export */   \"todayCheck\": () => (/* binding */ todayCheck)\n/* harmony export */ });\n/* harmony import */ var _js_temporal_polyfill__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @js-temporal/polyfill */ \"./node_modules/@js-temporal/polyfill/dist/index.esm.js\");\n\n\n// 2022-03-16T03:52 => 03/16/2022 @ 03:52 AM\nconst dateFilter = (date) => {\n    let splitTimeAndDate = date.split('T');\n    let splitDate = splitTimeAndDate[0].split('-');\n    let splitTime = splitTimeAndDate[1].split(':');\n    let fixedHour = 0;\n    if(splitTime[0] >= 0 && splitTime[0] < 12){\n        fixedHour = splitTime[0]+ ':' + splitTime[1]+'AM';\n    }\n    else{\n        fixedHour = splitTime[0]+ ':' + splitTime[1]+'PM';  \n    }\n    let fixedDate = splitDate[1] + '/' + splitDate[2] + '/' + splitDate[0];\n    let fixedTimeAndDate =  fixedDate + ' @ ' + fixedHour;\n    return fixedTimeAndDate;\n}\nconst convertDate = (date) => {\n    let dd_date = date.value.substring(0, 10);\n\n    let dd_year = dd_date.substring(0, 4);\n    let dd_month = dd_date.substring(5, 7);\n    let dd_day = dd_date.substring(8, 10);\n    \n    return { dd_date, dd_year, dd_month, dd_day };\n};\n\n// Temporal\n\nconst now = () => {\n    return _js_temporal_polyfill__WEBPACK_IMPORTED_MODULE_0__.Temporal.Now.zonedDateTimeISO().toPlainDateTime().round({smallestUnit: \"minute\", roundingMode: \"floor\"}).toString();\n};\n\nconst today = () => {\n    return _js_temporal_polyfill__WEBPACK_IMPORTED_MODULE_0__.Temporal.Now.zonedDateTimeISO().toPlainDate().toString();\n};\n\nconst thisWeek = () => {\n    let today = _js_temporal_polyfill__WEBPACK_IMPORTED_MODULE_0__.Temporal.Now.zonedDateTimeISO()\n    let oneWeekFromToday = today.add({ days: 7});\n    return oneWeekFromToday.toPlainDate();\n};\n\nconst todayCheck = (yearCheck, monthCheck, dayCheck) => {\n    return _js_temporal_polyfill__WEBPACK_IMPORTED_MODULE_0__.Temporal.PlainDate.from({year: yearCheck, month: monthCheck, day: dayCheck}).equals(today());\n};\n\nconst thisWeekCheck = (yearCheck, monthCheck, dayCheck) => {\n\n    let convertedDate = _js_temporal_polyfill__WEBPACK_IMPORTED_MODULE_0__.Temporal.PlainDate.from({year: yearCheck, month: monthCheck, day: dayCheck});\n    let difference = convertedDate.until(thisWeek()).days;\n\n    if (+difference <= 7 && +difference >= 0){\n        return true;\n    }\n    else{\n        return false;\n    }\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvanMvdGltZS5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFpRDs7QUFFakQ7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBOztBQUVPO0FBQ1AsV0FBVyxnRkFBNkIsNEJBQTRCLDhDQUE4QztBQUNsSDs7QUFFTztBQUNQLFdBQVcsZ0ZBQTZCO0FBQ3hDOztBQUVPO0FBQ1AsZ0JBQWdCLGdGQUE2QjtBQUM3Qyx1Q0FBdUMsUUFBUTtBQUMvQztBQUNBOztBQUVPO0FBQ1AsV0FBVywwRUFBdUIsRUFBRSxrREFBa0Q7QUFDdEY7O0FBRU87O0FBRVAsd0JBQXdCLDBFQUF1QixFQUFFLGtEQUFrRDtBQUNuRzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3RvZG8tbGlzdC8uL3NyYy9qcy90aW1lLmpzPzVmZmQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgVGVtcG9yYWwgfSBmcm9tIFwiQGpzLXRlbXBvcmFsL3BvbHlmaWxsXCI7XG5cbi8vIDIwMjItMDMtMTZUMDM6NTIgPT4gMDMvMTYvMjAyMiBAIDAzOjUyIEFNXG5leHBvcnQgY29uc3QgZGF0ZUZpbHRlciA9IChkYXRlKSA9PiB7XG4gICAgbGV0IHNwbGl0VGltZUFuZERhdGUgPSBkYXRlLnNwbGl0KCdUJyk7XG4gICAgbGV0IHNwbGl0RGF0ZSA9IHNwbGl0VGltZUFuZERhdGVbMF0uc3BsaXQoJy0nKTtcbiAgICBsZXQgc3BsaXRUaW1lID0gc3BsaXRUaW1lQW5kRGF0ZVsxXS5zcGxpdCgnOicpO1xuICAgIGxldCBmaXhlZEhvdXIgPSAwO1xuICAgIGlmKHNwbGl0VGltZVswXSA+PSAwICYmIHNwbGl0VGltZVswXSA8IDEyKXtcbiAgICAgICAgZml4ZWRIb3VyID0gc3BsaXRUaW1lWzBdKyAnOicgKyBzcGxpdFRpbWVbMV0rJ0FNJztcbiAgICB9XG4gICAgZWxzZXtcbiAgICAgICAgZml4ZWRIb3VyID0gc3BsaXRUaW1lWzBdKyAnOicgKyBzcGxpdFRpbWVbMV0rJ1BNJzsgIFxuICAgIH1cbiAgICBsZXQgZml4ZWREYXRlID0gc3BsaXREYXRlWzFdICsgJy8nICsgc3BsaXREYXRlWzJdICsgJy8nICsgc3BsaXREYXRlWzBdO1xuICAgIGxldCBmaXhlZFRpbWVBbmREYXRlID0gIGZpeGVkRGF0ZSArICcgQCAnICsgZml4ZWRIb3VyO1xuICAgIHJldHVybiBmaXhlZFRpbWVBbmREYXRlO1xufVxuZXhwb3J0IGNvbnN0IGNvbnZlcnREYXRlID0gKGRhdGUpID0+IHtcbiAgICBsZXQgZGRfZGF0ZSA9IGRhdGUudmFsdWUuc3Vic3RyaW5nKDAsIDEwKTtcblxuICAgIGxldCBkZF95ZWFyID0gZGRfZGF0ZS5zdWJzdHJpbmcoMCwgNCk7XG4gICAgbGV0IGRkX21vbnRoID0gZGRfZGF0ZS5zdWJzdHJpbmcoNSwgNyk7XG4gICAgbGV0IGRkX2RheSA9IGRkX2RhdGUuc3Vic3RyaW5nKDgsIDEwKTtcbiAgICBcbiAgICByZXR1cm4geyBkZF9kYXRlLCBkZF95ZWFyLCBkZF9tb250aCwgZGRfZGF5IH07XG59O1xuXG4vLyBUZW1wb3JhbFxuXG5leHBvcnQgY29uc3Qgbm93ID0gKCkgPT4ge1xuICAgIHJldHVybiBUZW1wb3JhbC5Ob3cuem9uZWREYXRlVGltZUlTTygpLnRvUGxhaW5EYXRlVGltZSgpLnJvdW5kKHtzbWFsbGVzdFVuaXQ6IFwibWludXRlXCIsIHJvdW5kaW5nTW9kZTogXCJmbG9vclwifSkudG9TdHJpbmcoKTtcbn07XG5cbmV4cG9ydCBjb25zdCB0b2RheSA9ICgpID0+IHtcbiAgICByZXR1cm4gVGVtcG9yYWwuTm93LnpvbmVkRGF0ZVRpbWVJU08oKS50b1BsYWluRGF0ZSgpLnRvU3RyaW5nKCk7XG59O1xuXG5leHBvcnQgY29uc3QgdGhpc1dlZWsgPSAoKSA9PiB7XG4gICAgbGV0IHRvZGF5ID0gVGVtcG9yYWwuTm93LnpvbmVkRGF0ZVRpbWVJU08oKVxuICAgIGxldCBvbmVXZWVrRnJvbVRvZGF5ID0gdG9kYXkuYWRkKHsgZGF5czogN30pO1xuICAgIHJldHVybiBvbmVXZWVrRnJvbVRvZGF5LnRvUGxhaW5EYXRlKCk7XG59O1xuXG5leHBvcnQgY29uc3QgdG9kYXlDaGVjayA9ICh5ZWFyQ2hlY2ssIG1vbnRoQ2hlY2ssIGRheUNoZWNrKSA9PiB7XG4gICAgcmV0dXJuIFRlbXBvcmFsLlBsYWluRGF0ZS5mcm9tKHt5ZWFyOiB5ZWFyQ2hlY2ssIG1vbnRoOiBtb250aENoZWNrLCBkYXk6IGRheUNoZWNrfSkuZXF1YWxzKHRvZGF5KCkpO1xufTtcblxuZXhwb3J0IGNvbnN0IHRoaXNXZWVrQ2hlY2sgPSAoeWVhckNoZWNrLCBtb250aENoZWNrLCBkYXlDaGVjaykgPT4ge1xuXG4gICAgbGV0IGNvbnZlcnRlZERhdGUgPSBUZW1wb3JhbC5QbGFpbkRhdGUuZnJvbSh7eWVhcjogeWVhckNoZWNrLCBtb250aDogbW9udGhDaGVjaywgZGF5OiBkYXlDaGVja30pO1xuICAgIGxldCBkaWZmZXJlbmNlID0gY29udmVydGVkRGF0ZS51bnRpbCh0aGlzV2VlaygpKS5kYXlzO1xuXG4gICAgaWYgKCtkaWZmZXJlbmNlIDw9IDcgJiYgK2RpZmZlcmVuY2UgPj0gMCl7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBlbHNle1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/js/time.js\n");

/***/ }),

/***/ "./src/js/todo.js":
/*!************************!*\
  !*** ./src/js/todo.js ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Todo\": () => (/* binding */ Todo)\n/* harmony export */ });\n/* harmony import */ var _js_temporal_polyfill__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @js-temporal/polyfill */ \"./node_modules/@js-temporal/polyfill/dist/index.esm.js\");\n/* harmony import */ var _time__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./time */ \"./src/js/time.js\");\n\n\n\nconst Todo = (title, description, dueDate, priority, id) => {\n\n    const getTitle = () => title;\n    const getDescription = () => description;\n    const getDueDate = () => dueDate;\n    const getPriority = () => priority;\n    const getID = () => id;\n\n    const setTitle = (newTitle) => title = newTitle; \n    const setDescription = (newDescription) => description = newDescription;\n    const setDueDate = (newDueDate) => dueDate = newDueDate;\n    const setPriority = (newPriority) => priority = newPriority;\n    const setID = (newID) => id = newID;\n\n    // pass in value from getDueDate() to get Temporal-friendly date format\n    const convertedDate = (calendarDate) => {\n        let dd_date = calendarDate.substring(0, 10);\n        return { dd_date };\n    };\n\n    const isTodayCheck = (convertedDate) => {\n        let dateHolder = convertedDate.dd_date;\n        let date = dateHolder.substring(0, 10);\n        let yr = date.substring(0, 4);\n        let month = date.substring(5, 7);\n        let day = date.substring(8, 10);\n        return _js_temporal_polyfill__WEBPACK_IMPORTED_MODULE_0__.Temporal.PlainDate.from({year: yr, month: month, day: day}).equals((0,_time__WEBPACK_IMPORTED_MODULE_1__.today)());\n    };\n\n    const isThisWeekCheck = (convertedDate) => {\n        let dateHolder = convertedDate.dd_date;\n        let date = dateHolder.substring(0, 10);\n        let yr = date.substring(0, 4);\n        let month = date.substring(5, 7);\n        let day = date.substring(8, 10);\n\n        let temporalDateFormat = _js_temporal_polyfill__WEBPACK_IMPORTED_MODULE_0__.Temporal.PlainDate.from({year: yr, month: month, day: day});\n        let difference = temporalDateFormat.until((0,_time__WEBPACK_IMPORTED_MODULE_1__.thisWeek)()).days;\n\n        if (+difference <= 7 && +difference >= 0){\n            return true;\n        }\n        else{\n            return false;\n        }\n    };\n\n    return { getTitle, getDescription, getDueDate, getPriority, getID, setTitle, setDescription, \n        setDueDate, setPriority, setID, convertedDate, isTodayCheck, isThisWeekCheck, \n    };\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvanMvdG9kby5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBaUQ7QUFDUjs7QUFFbEM7O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDBFQUF1QixFQUFFLGlDQUFpQyxTQUFTLDRDQUFLO0FBQ3ZGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQ0FBaUMsMEVBQXVCLEVBQUUsaUNBQWlDO0FBQzNGLGtEQUFrRCwrQ0FBUTs7QUFFMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYTtBQUNiO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3RvZG8tbGlzdC8uL3NyYy9qcy90b2RvLmpzP2VhM2QiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgVGVtcG9yYWwgfSBmcm9tIFwiQGpzLXRlbXBvcmFsL3BvbHlmaWxsXCI7XG5pbXBvcnQgeyB0b2RheSwgdGhpc1dlZWsgfSBmcm9tIFwiLi90aW1lXCI7XG5cbmV4cG9ydCBjb25zdCBUb2RvID0gKHRpdGxlLCBkZXNjcmlwdGlvbiwgZHVlRGF0ZSwgcHJpb3JpdHksIGlkKSA9PiB7XG5cbiAgICBjb25zdCBnZXRUaXRsZSA9ICgpID0+IHRpdGxlO1xuICAgIGNvbnN0IGdldERlc2NyaXB0aW9uID0gKCkgPT4gZGVzY3JpcHRpb247XG4gICAgY29uc3QgZ2V0RHVlRGF0ZSA9ICgpID0+IGR1ZURhdGU7XG4gICAgY29uc3QgZ2V0UHJpb3JpdHkgPSAoKSA9PiBwcmlvcml0eTtcbiAgICBjb25zdCBnZXRJRCA9ICgpID0+IGlkO1xuXG4gICAgY29uc3Qgc2V0VGl0bGUgPSAobmV3VGl0bGUpID0+IHRpdGxlID0gbmV3VGl0bGU7IFxuICAgIGNvbnN0IHNldERlc2NyaXB0aW9uID0gKG5ld0Rlc2NyaXB0aW9uKSA9PiBkZXNjcmlwdGlvbiA9IG5ld0Rlc2NyaXB0aW9uO1xuICAgIGNvbnN0IHNldER1ZURhdGUgPSAobmV3RHVlRGF0ZSkgPT4gZHVlRGF0ZSA9IG5ld0R1ZURhdGU7XG4gICAgY29uc3Qgc2V0UHJpb3JpdHkgPSAobmV3UHJpb3JpdHkpID0+IHByaW9yaXR5ID0gbmV3UHJpb3JpdHk7XG4gICAgY29uc3Qgc2V0SUQgPSAobmV3SUQpID0+IGlkID0gbmV3SUQ7XG5cbiAgICAvLyBwYXNzIGluIHZhbHVlIGZyb20gZ2V0RHVlRGF0ZSgpIHRvIGdldCBUZW1wb3JhbC1mcmllbmRseSBkYXRlIGZvcm1hdFxuICAgIGNvbnN0IGNvbnZlcnRlZERhdGUgPSAoY2FsZW5kYXJEYXRlKSA9PiB7XG4gICAgICAgIGxldCBkZF9kYXRlID0gY2FsZW5kYXJEYXRlLnN1YnN0cmluZygwLCAxMCk7XG4gICAgICAgIHJldHVybiB7IGRkX2RhdGUgfTtcbiAgICB9O1xuXG4gICAgY29uc3QgaXNUb2RheUNoZWNrID0gKGNvbnZlcnRlZERhdGUpID0+IHtcbiAgICAgICAgbGV0IGRhdGVIb2xkZXIgPSBjb252ZXJ0ZWREYXRlLmRkX2RhdGU7XG4gICAgICAgIGxldCBkYXRlID0gZGF0ZUhvbGRlci5zdWJzdHJpbmcoMCwgMTApO1xuICAgICAgICBsZXQgeXIgPSBkYXRlLnN1YnN0cmluZygwLCA0KTtcbiAgICAgICAgbGV0IG1vbnRoID0gZGF0ZS5zdWJzdHJpbmcoNSwgNyk7XG4gICAgICAgIGxldCBkYXkgPSBkYXRlLnN1YnN0cmluZyg4LCAxMCk7XG4gICAgICAgIHJldHVybiBUZW1wb3JhbC5QbGFpbkRhdGUuZnJvbSh7eWVhcjogeXIsIG1vbnRoOiBtb250aCwgZGF5OiBkYXl9KS5lcXVhbHModG9kYXkoKSk7XG4gICAgfTtcblxuICAgIGNvbnN0IGlzVGhpc1dlZWtDaGVjayA9IChjb252ZXJ0ZWREYXRlKSA9PiB7XG4gICAgICAgIGxldCBkYXRlSG9sZGVyID0gY29udmVydGVkRGF0ZS5kZF9kYXRlO1xuICAgICAgICBsZXQgZGF0ZSA9IGRhdGVIb2xkZXIuc3Vic3RyaW5nKDAsIDEwKTtcbiAgICAgICAgbGV0IHlyID0gZGF0ZS5zdWJzdHJpbmcoMCwgNCk7XG4gICAgICAgIGxldCBtb250aCA9IGRhdGUuc3Vic3RyaW5nKDUsIDcpO1xuICAgICAgICBsZXQgZGF5ID0gZGF0ZS5zdWJzdHJpbmcoOCwgMTApO1xuXG4gICAgICAgIGxldCB0ZW1wb3JhbERhdGVGb3JtYXQgPSBUZW1wb3JhbC5QbGFpbkRhdGUuZnJvbSh7eWVhcjogeXIsIG1vbnRoOiBtb250aCwgZGF5OiBkYXl9KTtcbiAgICAgICAgbGV0IGRpZmZlcmVuY2UgPSB0ZW1wb3JhbERhdGVGb3JtYXQudW50aWwodGhpc1dlZWsoKSkuZGF5cztcblxuICAgICAgICBpZiAoK2RpZmZlcmVuY2UgPD0gNyAmJiArZGlmZmVyZW5jZSA+PSAwKXtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2V7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIHsgZ2V0VGl0bGUsIGdldERlc2NyaXB0aW9uLCBnZXREdWVEYXRlLCBnZXRQcmlvcml0eSwgZ2V0SUQsIHNldFRpdGxlLCBzZXREZXNjcmlwdGlvbiwgXG4gICAgICAgIHNldER1ZURhdGUsIHNldFByaW9yaXR5LCBzZXRJRCwgY29udmVydGVkRGF0ZSwgaXNUb2RheUNoZWNrLCBpc1RoaXNXZWVrQ2hlY2ssIFxuICAgIH07XG59OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/js/todo.js\n");

/***/ }),

/***/ "./node_modules/@js-temporal/polyfill/dist/index.esm.js":
/*!**************************************************************!*\
  !*** ./node_modules/@js-temporal/polyfill/dist/index.esm.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Intl\": () => (/* binding */ intl),\n/* harmony export */   \"Temporal\": () => (/* binding */ temporal),\n/* harmony export */   \"toTemporalInstant\": () => (/* binding */ toTemporalInstant)\n/* harmony export */ });\n/* harmony import */ var jsbi__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jsbi */ \"./node_modules/jsbi/dist/jsbi-umd.js\");\n\n\nconst INTRINSICS = {};\nconst customUtilInspectFormatters = {\n    ['Temporal.Duration'](depth, options) {\n        const descr = options.stylize(`${this[Symbol.toStringTag]} <${this}>`, 'special');\n        if (depth < 1)\n            return descr;\n        const entries = [];\n        for (const prop of [\n            'years',\n            'months',\n            'weeks',\n            'days',\n            'hours',\n            'minutes',\n            'seconds',\n            'milliseconds',\n            'microseconds',\n            'nanoseconds'\n        ]) {\n            if (this[prop] !== 0)\n                entries.push(`  ${prop}: ${options.stylize(this[prop], 'number')}`);\n        }\n        return descr + ' {\\n' + entries.join(',\\n') + '\\n}';\n    }\n};\nfunction defaultUtilInspectFormatter(depth, options) {\n    return options.stylize(`${this[Symbol.toStringTag]} <${this}>`, 'special');\n}\nfunction MakeIntrinsicClass(Class, name) {\n    Object.defineProperty(Class.prototype, Symbol.toStringTag, {\n        value: name,\n        writable: false,\n        enumerable: false,\n        configurable: true\n    });\n    {\n        Object.defineProperty(Class.prototype, Symbol.for('nodejs.util.inspect.custom'), {\n            value: customUtilInspectFormatters[name] || defaultUtilInspectFormatter,\n            writable: false,\n            enumerable: false,\n            configurable: true\n        });\n    }\n    for (const prop of Object.getOwnPropertyNames(Class)) {\n        // we know that `prop` is present, so the descriptor is never undefined\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        const desc = Object.getOwnPropertyDescriptor(Class, prop);\n        if (!desc.configurable || !desc.enumerable)\n            continue;\n        desc.enumerable = false;\n        Object.defineProperty(Class, prop, desc);\n    }\n    for (const prop of Object.getOwnPropertyNames(Class.prototype)) {\n        // we know that `prop` is present, so the descriptor is never undefined\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        const desc = Object.getOwnPropertyDescriptor(Class.prototype, prop);\n        if (!desc.configurable || !desc.enumerable)\n            continue;\n        desc.enumerable = false;\n        Object.defineProperty(Class.prototype, prop, desc);\n    }\n    DefineIntrinsic(name, Class);\n    DefineIntrinsic(`${name}.prototype`, Class.prototype);\n}\nfunction DefineIntrinsic(name, value) {\n    const key = `%${name}%`;\n    if (INTRINSICS[key] !== undefined)\n        throw new Error(`intrinsic ${name} already exists`);\n    INTRINSICS[key] = value;\n}\nfunction GetIntrinsic(intrinsic) {\n    return INTRINSICS[intrinsic];\n}\n\n// Instant\nconst EPOCHNANOSECONDS = 'slot-epochNanoSeconds';\n// TimeZone\nconst TIMEZONE_ID = 'slot-timezone-identifier';\n// DateTime, Date, Time, YearMonth, MonthDay\nconst ISO_YEAR = 'slot-year';\nconst ISO_MONTH = 'slot-month';\nconst ISO_DAY = 'slot-day';\nconst ISO_HOUR = 'slot-hour';\nconst ISO_MINUTE = 'slot-minute';\nconst ISO_SECOND = 'slot-second';\nconst ISO_MILLISECOND = 'slot-millisecond';\nconst ISO_MICROSECOND = 'slot-microsecond';\nconst ISO_NANOSECOND = 'slot-nanosecond';\nconst CALENDAR = 'slot-calendar';\n// Date, YearMonth, and MonthDay all have the same slots, disambiguation needed:\nconst DATE_BRAND = 'slot-date-brand';\nconst YEAR_MONTH_BRAND = 'slot-year-month-brand';\nconst MONTH_DAY_BRAND = 'slot-month-day-brand';\n// ZonedDateTime\nconst INSTANT = 'slot-cached-instant';\nconst TIME_ZONE = 'slot-time-zone';\n// Duration\nconst YEARS = 'slot-years';\nconst MONTHS = 'slot-months';\nconst WEEKS = 'slot-weeks';\nconst DAYS = 'slot-days';\nconst HOURS = 'slot-hours';\nconst MINUTES = 'slot-minutes';\nconst SECONDS = 'slot-seconds';\nconst MILLISECONDS = 'slot-milliseconds';\nconst MICROSECONDS = 'slot-microseconds';\nconst NANOSECONDS = 'slot-nanoseconds';\n// Calendar\nconst CALENDAR_ID = 'slot-calendar-identifier';\nconst slots = new WeakMap();\nfunction CreateSlots(container) {\n    slots.set(container, Object.create(null));\n}\nfunction GetSlots(container) {\n    return slots.get(container);\n}\nfunction HasSlot(container, ...ids) {\n    if (!container || 'object' !== typeof container)\n        return false;\n    const myslots = GetSlots(container);\n    return !!myslots && ids.reduce((all, id) => all && id in myslots, true);\n}\nfunction GetSlot(container, id) {\n    const value = GetSlots(container)[id];\n    if (value === undefined)\n        throw new TypeError(`Missing internal slot ${id}`);\n    return value;\n}\nfunction SetSlot(container, id, value) {\n    GetSlots(container)[id] = value;\n}\n\nconst ArrayIncludes = Array.prototype.includes;\nconst ArrayPrototypePush$2 = Array.prototype.push;\nconst IntlDateTimeFormat$2 = globalThis.Intl.DateTimeFormat;\nconst ArraySort = Array.prototype.sort;\nconst MathAbs$1 = Math.abs;\nconst MathFloor$1 = Math.floor;\nconst ObjectEntries = Object.entries;\nconst ObjectKeys = Object.keys;\n/**\n * Implementations for each calendar. Non-ISO calendars have an extra `helper`\n * property that provides additional per-calendar logic.\n */\nconst impl = {};\n/**\n * Thin wrapper around the implementation of each built-in calendar. This\n * class's methods follow a similar pattern:\n * 1. Validate parameters\n * 2. Fill in default options (for methods where options are present)\n * 3. Simplify and/or normalize parameters. For example, some methods accept\n *    PlainDate, PlainDateTime, ZonedDateTime, etc. and these are normalized to\n *    PlainDate.\n * 4. Look up the ID of the built-in calendar\n * 5. Fetch the implementation object for that ID.\n * 6. Call the corresponding method in the implementation object.\n */\nclass Calendar {\n    constructor(idParam) {\n        // Note: if the argument is not passed, IsBuiltinCalendar(\"undefined\") will fail. This check\n        //       exists only to improve the error message.\n        if (arguments.length < 1) {\n            throw new RangeError('missing argument: id is required');\n        }\n        const id = ToString(idParam);\n        if (!IsBuiltinCalendar(id))\n            throw new RangeError(`invalid calendar identifier ${id}`);\n        CreateSlots(this);\n        SetSlot(this, CALENDAR_ID, id);\n        {\n            Object.defineProperty(this, '_repr_', {\n                value: `${this[Symbol.toStringTag]} <${id}>`,\n                writable: false,\n                enumerable: false,\n                configurable: false\n            });\n        }\n    }\n    get id() {\n        if (!IsTemporalCalendar(this))\n            throw new TypeError('invalid receiver');\n        return ToString(this);\n    }\n    dateFromFields(fields, optionsParam = undefined) {\n        if (!IsTemporalCalendar(this))\n            throw new TypeError('invalid receiver');\n        if (!IsObject(fields))\n            throw new TypeError('invalid fields');\n        const options = GetOptionsObject(optionsParam);\n        return impl[GetSlot(this, CALENDAR_ID)].dateFromFields(fields, options, this);\n    }\n    yearMonthFromFields(fields, optionsParam = undefined) {\n        if (!IsTemporalCalendar(this))\n            throw new TypeError('invalid receiver');\n        if (!IsObject(fields))\n            throw new TypeError('invalid fields');\n        const options = GetOptionsObject(optionsParam);\n        return impl[GetSlot(this, CALENDAR_ID)].yearMonthFromFields(fields, options, this);\n    }\n    monthDayFromFields(fields, optionsParam = undefined) {\n        if (!IsTemporalCalendar(this))\n            throw new TypeError('invalid receiver');\n        if (!IsObject(fields))\n            throw new TypeError('invalid fields');\n        const options = GetOptionsObject(optionsParam);\n        return impl[GetSlot(this, CALENDAR_ID)].monthDayFromFields(fields, options, this);\n    }\n    fields(fields) {\n        if (!IsTemporalCalendar(this))\n            throw new TypeError('invalid receiver');\n        const fieldsArray = [];\n        const allowed = new Set([\n            'year',\n            'month',\n            'monthCode',\n            'day',\n            'hour',\n            'minute',\n            'second',\n            'millisecond',\n            'microsecond',\n            'nanosecond'\n        ]);\n        for (const name of fields) {\n            if (typeof name !== 'string')\n                throw new TypeError('invalid fields');\n            if (!allowed.has(name))\n                throw new RangeError(`invalid field name ${name}`);\n            allowed.delete(name);\n            ArrayPrototypePush$2.call(fieldsArray, name);\n        }\n        return impl[GetSlot(this, CALENDAR_ID)].fields(fieldsArray);\n    }\n    mergeFields(fields, additionalFields) {\n        if (!IsTemporalCalendar(this))\n            throw new TypeError('invalid receiver');\n        return impl[GetSlot(this, CALENDAR_ID)].mergeFields(fields, additionalFields);\n    }\n    dateAdd(dateParam, durationParam, optionsParam = undefined) {\n        if (!IsTemporalCalendar(this))\n            throw new TypeError('invalid receiver');\n        const date = ToTemporalDate(dateParam);\n        const duration = ToTemporalDuration(durationParam);\n        const options = GetOptionsObject(optionsParam);\n        const overflow = ToTemporalOverflow(options);\n        const { days } = BalanceDuration(GetSlot(duration, DAYS), GetSlot(duration, HOURS), GetSlot(duration, MINUTES), GetSlot(duration, SECONDS), GetSlot(duration, MILLISECONDS), GetSlot(duration, MICROSECONDS), GetSlot(duration, NANOSECONDS), 'day');\n        return impl[GetSlot(this, CALENDAR_ID)].dateAdd(date, GetSlot(duration, YEARS), GetSlot(duration, MONTHS), GetSlot(duration, WEEKS), days, overflow, this);\n    }\n    dateUntil(oneParam, twoParam, optionsParam = undefined) {\n        if (!IsTemporalCalendar(this))\n            throw new TypeError('invalid receiver');\n        const one = ToTemporalDate(oneParam);\n        const two = ToTemporalDate(twoParam);\n        const options = GetOptionsObject(optionsParam);\n        const largestUnit = ToLargestTemporalUnit(options, 'auto', ['hour', 'minute', 'second', 'millisecond', 'microsecond', 'nanosecond'], 'day');\n        const { years, months, weeks, days } = impl[GetSlot(this, CALENDAR_ID)].dateUntil(one, two, largestUnit);\n        const Duration = GetIntrinsic('%Temporal.Duration%');\n        return new Duration(years, months, weeks, days, 0, 0, 0, 0, 0, 0);\n    }\n    year(dateParam) {\n        let date = dateParam;\n        if (!IsTemporalCalendar(this))\n            throw new TypeError('invalid receiver');\n        if (!IsTemporalYearMonth(date))\n            date = ToTemporalDate(date);\n        return impl[GetSlot(this, CALENDAR_ID)].year(date);\n    }\n    month(dateParam) {\n        let date = dateParam;\n        if (!IsTemporalCalendar(this))\n            throw new TypeError('invalid receiver');\n        if (IsTemporalMonthDay(date))\n            throw new TypeError('use monthCode on PlainMonthDay instead');\n        if (!IsTemporalYearMonth(date))\n            date = ToTemporalDate(date);\n        return impl[GetSlot(this, CALENDAR_ID)].month(date);\n    }\n    monthCode(dateParam) {\n        let date = dateParam;\n        if (!IsTemporalCalendar(this))\n            throw new TypeError('invalid receiver');\n        if (!IsTemporalYearMonth(date) && !IsTemporalMonthDay(date))\n            date = ToTemporalDate(date);\n        return impl[GetSlot(this, CALENDAR_ID)].monthCode(date);\n    }\n    day(dateParam) {\n        let date = dateParam;\n        if (!IsTemporalCalendar(this))\n            throw new TypeError('invalid receiver');\n        if (!IsTemporalMonthDay(date))\n            date = ToTemporalDate(date);\n        return impl[GetSlot(this, CALENDAR_ID)].day(date);\n    }\n    era(dateParam) {\n        let date = dateParam;\n        if (!IsTemporalCalendar(this))\n            throw new TypeError('invalid receiver');\n        if (!IsTemporalYearMonth(date))\n            date = ToTemporalDate(date);\n        return impl[GetSlot(this, CALENDAR_ID)].era(date);\n    }\n    eraYear(dateParam) {\n        let date = dateParam;\n        if (!IsTemporalCalendar(this))\n            throw new TypeError('invalid receiver');\n        if (!IsTemporalYearMonth(date))\n            date = ToTemporalDate(date);\n        return impl[GetSlot(this, CALENDAR_ID)].eraYear(date);\n    }\n    dayOfWeek(dateParam) {\n        if (!IsTemporalCalendar(this))\n            throw new TypeError('invalid receiver');\n        const date = ToTemporalDate(dateParam);\n        return impl[GetSlot(this, CALENDAR_ID)].dayOfWeek(date);\n    }\n    dayOfYear(dateParam) {\n        if (!IsTemporalCalendar(this))\n            throw new TypeError('invalid receiver');\n        const date = ToTemporalDate(dateParam);\n        return impl[GetSlot(this, CALENDAR_ID)].dayOfYear(date);\n    }\n    weekOfYear(dateParam) {\n        if (!IsTemporalCalendar(this))\n            throw new TypeError('invalid receiver');\n        const date = ToTemporalDate(dateParam);\n        return impl[GetSlot(this, CALENDAR_ID)].weekOfYear(date);\n    }\n    daysInWeek(dateParam) {\n        if (!IsTemporalCalendar(this))\n            throw new TypeError('invalid receiver');\n        const date = ToTemporalDate(dateParam);\n        return impl[GetSlot(this, CALENDAR_ID)].daysInWeek(date);\n    }\n    daysInMonth(dateParam) {\n        let date = dateParam;\n        if (!IsTemporalCalendar(this))\n            throw new TypeError('invalid receiver');\n        if (!IsTemporalYearMonth(date))\n            date = ToTemporalDate(date);\n        return impl[GetSlot(this, CALENDAR_ID)].daysInMonth(date);\n    }\n    daysInYear(dateParam) {\n        let date = dateParam;\n        if (!IsTemporalCalendar(this))\n            throw new TypeError('invalid receiver');\n        if (!IsTemporalYearMonth(date))\n            date = ToTemporalDate(date);\n        return impl[GetSlot(this, CALENDAR_ID)].daysInYear(date);\n    }\n    monthsInYear(dateParam) {\n        let date = dateParam;\n        if (!IsTemporalCalendar(this))\n            throw new TypeError('invalid receiver');\n        if (!IsTemporalYearMonth(date))\n            date = ToTemporalDate(date);\n        return impl[GetSlot(this, CALENDAR_ID)].monthsInYear(date);\n    }\n    inLeapYear(dateParam) {\n        let date = dateParam;\n        if (!IsTemporalCalendar(this))\n            throw new TypeError('invalid receiver');\n        if (!IsTemporalYearMonth(date))\n            date = ToTemporalDate(date);\n        return impl[GetSlot(this, CALENDAR_ID)].inLeapYear(date);\n    }\n    toString() {\n        if (!IsTemporalCalendar(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, CALENDAR_ID);\n    }\n    toJSON() {\n        if (!IsTemporalCalendar(this))\n            throw new TypeError('invalid receiver');\n        return ToString(this);\n    }\n    static from(item) {\n        return ToTemporalCalendar(item);\n    }\n}\nMakeIntrinsicClass(Calendar, 'Temporal.Calendar');\nDefineIntrinsic('Temporal.Calendar.from', Calendar.from);\n/**\n * Implementation for the ISO 8601 calendar. This is the only calendar that's\n * guaranteed to be supported by all ECMAScript implementations, including those\n * without Intl (ECMA-402) support.\n */\nimpl['iso8601'] = {\n    dateFromFields(fieldsParam, options, calendar) {\n        const overflow = ToTemporalOverflow(options);\n        let fields = PrepareTemporalFields(fieldsParam, [\n            ['day'],\n            ['month', undefined],\n            ['monthCode', undefined],\n            ['year']\n        ]);\n        fields = resolveNonLunisolarMonth(fields);\n        let { year, month, day } = fields;\n        ({ year, month, day } = RegulateISODate(year, month, day, overflow));\n        return CreateTemporalDate(year, month, day, calendar);\n    },\n    yearMonthFromFields(fieldsParam, options, calendar) {\n        const overflow = ToTemporalOverflow(options);\n        let fields = PrepareTemporalFields(fieldsParam, [\n            ['month', undefined],\n            ['monthCode', undefined],\n            ['year']\n        ]);\n        fields = resolveNonLunisolarMonth(fields);\n        let { year, month } = fields;\n        ({ year, month } = RegulateISOYearMonth(year, month, overflow));\n        return CreateTemporalYearMonth(year, month, calendar, /* referenceISODay = */ 1);\n    },\n    monthDayFromFields(fieldsParam, options, calendar) {\n        const overflow = ToTemporalOverflow(options);\n        let fields = PrepareTemporalFields(fieldsParam, [\n            ['day'],\n            ['month', undefined],\n            ['monthCode', undefined],\n            ['year', undefined]\n        ]);\n        if (fields.month !== undefined && fields.year === undefined && fields.monthCode === undefined) {\n            throw new TypeError('either year or monthCode required with month');\n        }\n        const useYear = fields.monthCode === undefined;\n        const referenceISOYear = 1972;\n        fields = resolveNonLunisolarMonth(fields);\n        let { month, day, year } = fields;\n        ({ month, day } = RegulateISODate(useYear ? year : referenceISOYear, month, day, overflow));\n        return CreateTemporalMonthDay(month, day, calendar, referenceISOYear);\n    },\n    fields(fields) {\n        return fields;\n    },\n    mergeFields(fields, additionalFields) {\n        const merged = {};\n        for (const nextKey of ObjectKeys(fields)) {\n            if (nextKey === 'month' || nextKey === 'monthCode')\n                continue;\n            merged[nextKey] = fields[nextKey];\n        }\n        const newKeys = ObjectKeys(additionalFields);\n        for (const nextKey of newKeys) {\n            merged[nextKey] = additionalFields[nextKey];\n        }\n        if (!ArrayIncludes.call(newKeys, 'month') && !ArrayIncludes.call(newKeys, 'monthCode')) {\n            const { month, monthCode } = fields;\n            if (month !== undefined)\n                merged.month = month;\n            if (monthCode !== undefined)\n                merged.monthCode = monthCode;\n        }\n        return merged;\n    },\n    dateAdd(date, years, months, weeks, days, overflow, calendar) {\n        let year = GetSlot(date, ISO_YEAR);\n        let month = GetSlot(date, ISO_MONTH);\n        let day = GetSlot(date, ISO_DAY);\n        ({ year, month, day } = AddISODate(year, month, day, years, months, weeks, days, overflow));\n        return CreateTemporalDate(year, month, day, calendar);\n    },\n    dateUntil(one, two, largestUnit) {\n        return DifferenceISODate(GetSlot(one, ISO_YEAR), GetSlot(one, ISO_MONTH), GetSlot(one, ISO_DAY), GetSlot(two, ISO_YEAR), GetSlot(two, ISO_MONTH), GetSlot(two, ISO_DAY), largestUnit);\n    },\n    year(date) {\n        return GetSlot(date, ISO_YEAR);\n    },\n    era() {\n        return undefined;\n    },\n    eraYear() {\n        return undefined;\n    },\n    month(date) {\n        return GetSlot(date, ISO_MONTH);\n    },\n    monthCode(date) {\n        return buildMonthCode(GetSlot(date, ISO_MONTH));\n    },\n    day(date) {\n        return GetSlot(date, ISO_DAY);\n    },\n    dayOfWeek(date) {\n        return DayOfWeek(GetSlot(date, ISO_YEAR), GetSlot(date, ISO_MONTH), GetSlot(date, ISO_DAY));\n    },\n    dayOfYear(date) {\n        return DayOfYear(GetSlot(date, ISO_YEAR), GetSlot(date, ISO_MONTH), GetSlot(date, ISO_DAY));\n    },\n    weekOfYear(date) {\n        return WeekOfYear(GetSlot(date, ISO_YEAR), GetSlot(date, ISO_MONTH), GetSlot(date, ISO_DAY));\n    },\n    daysInWeek() {\n        return 7;\n    },\n    daysInMonth(date) {\n        return ISODaysInMonth(GetSlot(date, ISO_YEAR), GetSlot(date, ISO_MONTH));\n    },\n    daysInYear(dateParam) {\n        let date = dateParam;\n        if (!HasSlot(date, ISO_YEAR))\n            date = ToTemporalDate(date);\n        return LeapYear(GetSlot(date, ISO_YEAR)) ? 366 : 365;\n    },\n    monthsInYear() {\n        return 12;\n    },\n    inLeapYear(dateParam) {\n        let date = dateParam;\n        if (!HasSlot(date, ISO_YEAR))\n            date = ToTemporalDate(date);\n        return LeapYear(GetSlot(date, ISO_YEAR));\n    }\n};\nfunction monthCodeNumberPart(monthCode) {\n    if (!monthCode.startsWith('M')) {\n        throw new RangeError(`Invalid month code: ${monthCode}.  Month codes must start with M.`);\n    }\n    const month = +monthCode.slice(1);\n    if (isNaN(month))\n        throw new RangeError(`Invalid month code: ${monthCode}`);\n    return month;\n}\nfunction buildMonthCode(month, leap = false) {\n    return `M${month.toString().padStart(2, '0')}${leap ? 'L' : ''}`;\n}\n/**\n * Safely merge a month, monthCode pair into an integer month.\n * If both are present, make sure they match.\n * This logic doesn't work for lunisolar calendars!\n * */\nfunction resolveNonLunisolarMonth(calendarDate, overflow = undefined, monthsPerYear = 12) {\n    let { month, monthCode } = calendarDate;\n    if (monthCode === undefined) {\n        if (month === undefined)\n            throw new TypeError('Either month or monthCode are required');\n        // The ISO calendar uses the default (undefined) value because it does\n        // constrain/reject after this method returns. Non-ISO calendars, however,\n        // rely on this function to constrain/reject out-of-range `month` values.\n        if (overflow === 'reject')\n            RejectToRange(month, 1, monthsPerYear);\n        if (overflow === 'constrain')\n            month = ConstrainToRange(month, 1, monthsPerYear);\n        monthCode = buildMonthCode(month);\n    }\n    else {\n        const numberPart = monthCodeNumberPart(monthCode);\n        if (month !== undefined && month !== numberPart) {\n            throw new RangeError(`monthCode ${monthCode} and month ${month} must match if both are present`);\n        }\n        if (monthCode !== buildMonthCode(numberPart)) {\n            throw new RangeError(`Invalid month code: ${monthCode}`);\n        }\n        month = numberPart;\n        if (month < 1 || month > monthsPerYear)\n            throw new RangeError(`Invalid monthCode: ${monthCode}`);\n    }\n    return { ...calendarDate, month, monthCode };\n}\n/**\n * This prototype implementation of non-ISO calendars makes many repeated calls\n * to Intl APIs which may be slow (e.g. >0.2ms). This trivial cache will speed\n * up these repeat accesses. Each cache instance is associated (via a WeakMap)\n * to a specific Temporal object, which speeds up multiple calendar calls on the\n * same Temporal object instance.  No invalidation or pruning is necessary\n * because each object's cache is thrown away when the object is GC-ed.\n */\nclass OneObjectCache {\n    constructor(cacheToClone) {\n        this.map = new Map();\n        this.calls = 0;\n        this.hits = 0;\n        this.misses = 0;\n        this.now = globalThis.performance ? globalThis.performance.now() : Date.now();\n        if (cacheToClone !== undefined) {\n            let i = 0;\n            for (const entry of cacheToClone.map.entries()) {\n                if (++i > OneObjectCache.MAX_CACHE_ENTRIES)\n                    break;\n                this.map.set(...entry);\n            }\n        }\n    }\n    get(key) {\n        const result = this.map.get(key);\n        if (result) {\n            this.hits++;\n            this.report();\n        }\n        this.calls++;\n        return result;\n    }\n    set(key, value) {\n        this.map.set(key, value);\n        this.misses++;\n        this.report();\n    }\n    report() {\n        /*\n        if (this.calls === 0) return;\n        const ms = (globalThis.performance ? globalThis.performance.now() : Date.now()) - this.now;\n        const hitRate = ((100 * this.hits) / this.calls).toFixed(0);\n        console.log(`${this.calls} calls in ${ms.toFixed(2)}ms. Hits: ${this.hits} (${hitRate}%). Misses: ${this.misses}.`);\n        */\n    }\n    setObject(obj) {\n        if (OneObjectCache.objectMap.get(obj))\n            throw new RangeError('object already cached');\n        OneObjectCache.objectMap.set(obj, this);\n        this.report();\n    }\n    /**\n     * Returns a WeakMap-backed cache that's used to store expensive results\n     * that are associated with a particular Temporal object instance.\n     *\n     * @param obj - object to associate with the cache\n     */\n    static getCacheForObject(obj) {\n        let cache = OneObjectCache.objectMap.get(obj);\n        if (!cache) {\n            cache = new OneObjectCache();\n            OneObjectCache.objectMap.set(obj, cache);\n        }\n        return cache;\n    }\n}\nOneObjectCache.objectMap = new WeakMap();\nOneObjectCache.MAX_CACHE_ENTRIES = 1000;\nfunction toUtcIsoDateString({ isoYear, isoMonth, isoDay }) {\n    const yearString = ISOYearString(isoYear);\n    const monthString = ISODateTimePartString(isoMonth);\n    const dayString = ISODateTimePartString(isoDay);\n    return `${yearString}-${monthString}-${dayString}T00:00Z`;\n}\nfunction simpleDateDiff(one, two) {\n    return {\n        years: one.year - two.year,\n        months: one.month - two.month,\n        days: one.day - two.day\n    };\n}\n/**\n * Implementation helper that's common to all non-ISO calendars\n */\nclass HelperBase {\n    constructor() {\n        // The short era format works for all calendars except Japanese, which will\n        // override.\n        this.eraLength = 'short';\n        // All built-in calendars except Chinese/Dangi and Hebrew use an era\n        this.hasEra = true;\n    }\n    getFormatter() {\n        // `new Intl.DateTimeFormat()` is amazingly slow and chews up RAM. Per\n        // https://bugs.chromium.org/p/v8/issues/detail?id=6528#c4, we cache one\n        // DateTimeFormat instance per calendar. Caching is lazy so we only pay for\n        // calendars that are used. Note that the nonIsoHelperBase object is spread\n        // into each each calendar's implementation before any cache is created, so\n        // each calendar gets its own separate cached formatter.\n        if (typeof this.formatter === 'undefined') {\n            this.formatter = new IntlDateTimeFormat$2(`en-US-u-ca-${this.id}`, {\n                day: 'numeric',\n                month: 'numeric',\n                year: 'numeric',\n                era: this.eraLength,\n                timeZone: 'UTC'\n            });\n        }\n        return this.formatter;\n    }\n    isoToCalendarDate(isoDate, cache) {\n        const { year: isoYear, month: isoMonth, day: isoDay } = isoDate;\n        const key = JSON.stringify({ func: 'isoToCalendarDate', isoYear, isoMonth, isoDay, id: this.id });\n        const cached = cache.get(key);\n        if (cached)\n            return cached;\n        const dateTimeFormat = this.getFormatter();\n        let parts, isoString;\n        try {\n            isoString = toUtcIsoDateString({ isoYear, isoMonth, isoDay });\n            parts = dateTimeFormat.formatToParts(new Date(isoString));\n        }\n        catch (e) {\n            throw new RangeError(`Invalid ISO date: ${JSON.stringify({ isoYear, isoMonth, isoDay })}`);\n        }\n        const result = {};\n        for (let { type, value } of parts) {\n            if (type === 'year')\n                result.eraYear = +value;\n            // TODO: remove this type annotation when `relatedYear` gets into TS lib types\n            if (type === 'relatedYear')\n                result.eraYear = +value;\n            if (type === 'month') {\n                const matches = /^([0-9]*)(.*?)$/.exec(value);\n                if (!matches || matches.length != 3 || (!matches[1] && !matches[2])) {\n                    throw new RangeError(`Unexpected month: ${value}`);\n                }\n                // If the month has no numeric part (should only see this for the Hebrew\n                // calendar with newer FF / Chromium versions; see\n                // https://bugzilla.mozilla.org/show_bug.cgi?id=1751833) then set a\n                // placeholder month index of `1` and rely on the derived class to\n                // calculate the correct month index from the month name stored in\n                // `monthExtra`.\n                result.month = matches[1] ? +matches[1] : 1;\n                if (result.month < 1) {\n                    throw new RangeError(`Invalid month ${value} from ${isoString}[u-ca-${this.id}]` +\n                        ' (probably due to https://bugs.chromium.org/p/v8/issues/detail?id=10527)');\n                }\n                if (result.month > 13) {\n                    throw new RangeError(`Invalid month ${value} from ${isoString}[u-ca-${this.id}]` +\n                        ' (probably due to https://bugs.chromium.org/p/v8/issues/detail?id=10529)');\n                }\n                // The ICU formats for the Hebrew calendar no longer support a numeric\n                // month format. So we'll rely on the derived class to interpret it.\n                // `monthExtra` is also used on the Chinese calendar to handle a suffix\n                // \"bis\" indicating a leap month.\n                if (matches[2])\n                    result.monthExtra = matches[2];\n            }\n            if (type === 'day')\n                result.day = +value;\n            if (this.hasEra && type === 'era' && value != null && value !== '') {\n                // The convention for Temporal era values is lowercase, so following\n                // that convention in this prototype. Punctuation is removed, accented\n                // letters are normalized, and spaces are replaced with dashes.\n                // E.g.: \"ERA0\" => \"era0\", \"Before R.O.C.\" => \"before-roc\", \"En\" => \"eno\"\n                // The call to normalize() and the replacement regex deals with era\n                // names that contain non-ASCII characters like Japanese eras. Also\n                // ignore extra content in parentheses like JPN era date ranges.\n                value = value.split(' (')[0];\n                result.era = value\n                    .normalize('NFD')\n                    .replace(/[^-0-9 \\p{L}]/gu, '')\n                    .replace(' ', '-')\n                    .toLowerCase();\n            }\n        }\n        if (result.eraYear === undefined) {\n            // Node 12 has outdated ICU data that lacks the `relatedYear` field in the\n            // output of Intl.DateTimeFormat.formatToParts.\n            throw new RangeError(`Intl.DateTimeFormat.formatToParts lacks relatedYear in ${this.id} calendar. Try Node 14+ or modern browsers.`);\n        }\n        // Translate eras that may be handled differently by Temporal vs. by Intl\n        // (e.g. Japanese pre-Meiji eras). See https://github.com/tc39/proposal-temporal/issues/526.\n        if (this.reviseIntlEra) {\n            const { era, eraYear } = this.reviseIntlEra(result, isoDate);\n            result.era = era;\n            result.eraYear = eraYear;\n        }\n        if (this.checkIcuBugs)\n            this.checkIcuBugs(isoDate);\n        const calendarDate = this.adjustCalendarDate(result, cache, 'constrain', true);\n        if (calendarDate.year === undefined)\n            throw new RangeError(`Missing year converting ${JSON.stringify(isoDate)}`);\n        if (calendarDate.month === undefined)\n            throw new RangeError(`Missing month converting ${JSON.stringify(isoDate)}`);\n        if (calendarDate.day === undefined)\n            throw new RangeError(`Missing day converting ${JSON.stringify(isoDate)}`);\n        cache.set(key, calendarDate);\n        // Also cache the reverse mapping\n        ['constrain', 'reject'].forEach((overflow) => {\n            const keyReverse = JSON.stringify({\n                func: 'calendarToIsoDate',\n                year: calendarDate.year,\n                month: calendarDate.month,\n                day: calendarDate.day,\n                overflow,\n                id: this.id\n            });\n            cache.set(keyReverse, isoDate);\n        });\n        return calendarDate;\n    }\n    validateCalendarDate(calendarDate) {\n        const { era, month, year, day, eraYear, monthCode, monthExtra } = calendarDate;\n        // When there's a suffix (e.g. \"5bis\" for a leap month in Chinese calendar)\n        // the derived class must deal with it.\n        if (monthExtra !== undefined)\n            throw new RangeError('Unexpected `monthExtra` value');\n        if (year === undefined && eraYear === undefined)\n            throw new TypeError('year or eraYear is required');\n        if (month === undefined && monthCode === undefined)\n            throw new TypeError('month or monthCode is required');\n        if (day === undefined)\n            throw new RangeError('Missing day');\n        if (monthCode !== undefined) {\n            if (typeof monthCode !== 'string') {\n                throw new RangeError(`monthCode must be a string, not ${typeof monthCode}`);\n            }\n            if (!/^M([01]?\\d)(L?)$/.test(monthCode))\n                throw new RangeError(`Invalid monthCode: ${monthCode}`);\n        }\n        if (this.constantEra) {\n            if (era !== undefined && era !== this.constantEra) {\n                throw new RangeError(`era must be ${this.constantEra}, not ${era}`);\n            }\n            if (eraYear !== undefined && year !== undefined && eraYear !== year) {\n                throw new RangeError(`eraYear ${eraYear} does not match year ${year}`);\n            }\n        }\n    }\n    /**\n     * Allows derived calendars to add additional fields and/or to make\n     * adjustments e.g. to set the era based on the date or to revise the month\n     * number in lunisolar calendars per\n     * https://github.com/tc39/proposal-temporal/issues/1203.\n     *\n     * The base implementation fills in missing values by assuming the simplest\n     * possible calendar:\n     * - no eras or a constant era defined in `.constantEra`\n     * - non-lunisolar calendar (no leap months)\n     * */\n    adjustCalendarDate(calendarDateParam, cache = undefined, overflow = 'constrain', \n    // This param is only used by derived classes\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    fromLegacyDate = false) {\n        if (this.calendarType === 'lunisolar')\n            throw new RangeError('Override required for lunisolar calendars');\n        let calendarDate = calendarDateParam;\n        this.validateCalendarDate(calendarDate);\n        // For calendars that always use the same era, set it here so that derived\n        // calendars won't need to implement this method simply to set the era.\n        if (this.constantEra) {\n            // year and eraYear always match when there's only one possible era\n            const { year, eraYear } = calendarDate;\n            calendarDate = {\n                ...calendarDate,\n                era: this.constantEra,\n                year: year !== undefined ? year : eraYear,\n                eraYear: eraYear !== undefined ? eraYear : year\n            };\n        }\n        const largestMonth = this.monthsInYear(calendarDate, cache);\n        let { month, monthCode } = calendarDate;\n        ({ month, monthCode } = resolveNonLunisolarMonth(calendarDate, overflow, largestMonth));\n        return { ...calendarDate, month, monthCode };\n    }\n    regulateMonthDayNaive(calendarDate, overflow, cache) {\n        const largestMonth = this.monthsInYear(calendarDate, cache);\n        let { month, day } = calendarDate;\n        if (overflow === 'reject') {\n            RejectToRange(month, 1, largestMonth);\n            RejectToRange(day, 1, this.maximumMonthLength(calendarDate));\n        }\n        else {\n            month = ConstrainToRange(month, 1, largestMonth);\n            day = ConstrainToRange(day, 1, this.maximumMonthLength({ ...calendarDate, month }));\n        }\n        return { ...calendarDate, month, day };\n    }\n    calendarToIsoDate(dateParam, overflow = 'constrain', cache) {\n        const originalDate = dateParam;\n        // First, normalize the calendar date to ensure that (year, month, day)\n        // are all present, converting monthCode and eraYear if needed.\n        let date = this.adjustCalendarDate(dateParam, cache, overflow, false);\n        // Fix obviously out-of-bounds values. Values that are valid generally, but\n        // not in this particular year, may not be caught here for some calendars.\n        // If so, these will be handled lower below.\n        date = this.regulateMonthDayNaive(date, overflow, cache);\n        const { year, month, day } = date;\n        const key = JSON.stringify({ func: 'calendarToIsoDate', year, month, day, overflow, id: this.id });\n        let cached = cache.get(key);\n        if (cached)\n            return cached;\n        // If YMD are present in the input but the input has been constrained\n        // already, then cache both the original value and the constrained value.\n        let keyOriginal;\n        if (originalDate.year !== undefined &&\n            originalDate.month !== undefined &&\n            originalDate.day !== undefined &&\n            (originalDate.year !== date.year || originalDate.month !== date.month || originalDate.day !== date.day)) {\n            keyOriginal = JSON.stringify({\n                func: 'calendarToIsoDate',\n                year: originalDate.year,\n                month: originalDate.month,\n                day: originalDate.day,\n                overflow,\n                id: this.id\n            });\n            cached = cache.get(keyOriginal);\n            if (cached)\n                return cached;\n        }\n        // First, try to roughly guess the result\n        let isoEstimate = this.estimateIsoDate({ year, month, day });\n        const calculateSameMonthResult = (diffDays) => {\n            // If the estimate is in the same year & month as the target, then we can\n            // calculate the result exactly and short-circuit any additional logic.\n            // This optimization assumes that months are continuous. It would break if\n            // a calendar skipped days, like the Julian->Gregorian switchover. But the\n            // only ICU calendars that currently skip days (japanese/roc/buddhist) is\n            // a bug (https://bugs.chromium.org/p/chromium/issues/detail?id=1173158)\n            // that's currently detected by `checkIcuBugs()` which will throw. So\n            // this optimization should be safe for all ICU calendars.\n            let testIsoEstimate = this.addDaysIso(isoEstimate, diffDays);\n            if (date.day > this.minimumMonthLength(date)) {\n                // There's a chance that the calendar date is out of range. Throw or\n                // constrain if so.\n                let testCalendarDate = this.isoToCalendarDate(testIsoEstimate, cache);\n                while (testCalendarDate.month !== month || testCalendarDate.year !== year) {\n                    if (overflow === 'reject') {\n                        throw new RangeError(`day ${day} does not exist in month ${month} of year ${year}`);\n                    }\n                    // Back up a day at a time until we're not hanging over the month end\n                    testIsoEstimate = this.addDaysIso(testIsoEstimate, -1);\n                    testCalendarDate = this.isoToCalendarDate(testIsoEstimate, cache);\n                }\n            }\n            return testIsoEstimate;\n        };\n        let sign = 0;\n        let roundtripEstimate = this.isoToCalendarDate(isoEstimate, cache);\n        let diff = simpleDateDiff(date, roundtripEstimate);\n        if (diff.years !== 0 || diff.months !== 0 || diff.days !== 0) {\n            const diffTotalDaysEstimate = diff.years * 365 + diff.months * 30 + diff.days;\n            isoEstimate = this.addDaysIso(isoEstimate, diffTotalDaysEstimate);\n            roundtripEstimate = this.isoToCalendarDate(isoEstimate, cache);\n            diff = simpleDateDiff(date, roundtripEstimate);\n            if (diff.years === 0 && diff.months === 0) {\n                isoEstimate = calculateSameMonthResult(diff.days);\n            }\n            else {\n                sign = this.compareCalendarDates(date, roundtripEstimate);\n            }\n        }\n        // If the initial guess is not in the same month, then then bisect the\n        // distance to the target, starting with 8 days per step.\n        let increment = 8;\n        let maybeConstrained = false;\n        while (sign) {\n            isoEstimate = this.addDaysIso(isoEstimate, sign * increment);\n            const oldRoundtripEstimate = roundtripEstimate;\n            roundtripEstimate = this.isoToCalendarDate(isoEstimate, cache);\n            const oldSign = sign;\n            sign = this.compareCalendarDates(date, roundtripEstimate);\n            if (sign) {\n                diff = simpleDateDiff(date, roundtripEstimate);\n                if (diff.years === 0 && diff.months === 0) {\n                    isoEstimate = calculateSameMonthResult(diff.days);\n                    // Signal the loop condition that there's a match.\n                    sign = 0;\n                    // If the calendar day is larger than the minimal length for this\n                    // month, then it might be larger than the actual length of the month.\n                    // So we won't cache it as the correct calendar date for this ISO\n                    // date.\n                    maybeConstrained = date.day > this.minimumMonthLength(date);\n                }\n                else if (oldSign && sign !== oldSign) {\n                    if (increment > 1) {\n                        // If the estimate overshot the target, try again with a smaller increment\n                        // in the reverse direction.\n                        increment /= 2;\n                    }\n                    else {\n                        // Increment is 1, and neither the previous estimate nor the new\n                        // estimate is correct. The only way that can happen is if the\n                        // original date was an invalid value that will be constrained or\n                        // rejected here.\n                        if (overflow === 'reject') {\n                            throw new RangeError(`Can't find ISO date from calendar date: ${JSON.stringify({ ...originalDate })}`);\n                        }\n                        else {\n                            // To constrain, pick the earliest value\n                            const order = this.compareCalendarDates(roundtripEstimate, oldRoundtripEstimate);\n                            // If current value is larger, then back up to the previous value.\n                            if (order > 0)\n                                isoEstimate = this.addDaysIso(isoEstimate, -1);\n                            maybeConstrained = true;\n                            sign = 0;\n                        }\n                    }\n                }\n            }\n        }\n        cache.set(key, isoEstimate);\n        if (keyOriginal)\n            cache.set(keyOriginal, isoEstimate);\n        if (date.year === undefined ||\n            date.month === undefined ||\n            date.day === undefined ||\n            date.monthCode === undefined ||\n            (this.hasEra && (date.era === undefined || date.eraYear === undefined))) {\n            throw new RangeError('Unexpected missing property');\n        }\n        if (!maybeConstrained) {\n            // Also cache the reverse mapping\n            const keyReverse = JSON.stringify({\n                func: 'isoToCalendarDate',\n                isoYear: isoEstimate.year,\n                isoMonth: isoEstimate.month,\n                isoDay: isoEstimate.day,\n                id: this.id\n            });\n            cache.set(keyReverse, date);\n        }\n        return isoEstimate;\n    }\n    temporalToCalendarDate(date, cache) {\n        const isoDate = { year: GetSlot(date, ISO_YEAR), month: GetSlot(date, ISO_MONTH), day: GetSlot(date, ISO_DAY) };\n        const result = this.isoToCalendarDate(isoDate, cache);\n        return result;\n    }\n    compareCalendarDates(date1Param, date2Param) {\n        // `date1` and `date2` are already records. The calls below simply validate\n        // that all three required fields are present.\n        const date1 = PrepareTemporalFields(date1Param, [['day'], ['month'], ['year']]);\n        const date2 = PrepareTemporalFields(date2Param, [['day'], ['month'], ['year']]);\n        if (date1.year !== date2.year)\n            return ComparisonResult(date1.year - date2.year);\n        if (date1.month !== date2.month)\n            return ComparisonResult(date1.month - date2.month);\n        if (date1.day !== date2.day)\n            return ComparisonResult(date1.day - date2.day);\n        return 0;\n    }\n    /** Ensure that a calendar date actually exists. If not, return the closest earlier date. */\n    regulateDate(calendarDate, overflow = 'constrain', cache) {\n        const isoDate = this.calendarToIsoDate(calendarDate, overflow, cache);\n        return this.isoToCalendarDate(isoDate, cache);\n    }\n    addDaysIso(isoDate, days) {\n        const added = AddISODate(isoDate.year, isoDate.month, isoDate.day, 0, 0, 0, days, 'constrain');\n        return added;\n    }\n    addDaysCalendar(calendarDate, days, cache) {\n        const isoDate = this.calendarToIsoDate(calendarDate, 'constrain', cache);\n        const addedIso = this.addDaysIso(isoDate, days);\n        const addedCalendar = this.isoToCalendarDate(addedIso, cache);\n        return addedCalendar;\n    }\n    addMonthsCalendar(calendarDateParam, months, overflow, cache) {\n        let calendarDate = calendarDateParam;\n        const { day } = calendarDate;\n        for (let i = 0, absMonths = MathAbs$1(months); i < absMonths; i++) {\n            const { month } = calendarDate;\n            const oldCalendarDate = calendarDate;\n            const days = months < 0\n                ? -Math.max(day, this.daysInPreviousMonth(calendarDate, cache))\n                : this.daysInMonth(calendarDate, cache);\n            const isoDate = this.calendarToIsoDate(calendarDate, 'constrain', cache);\n            let addedIso = this.addDaysIso(isoDate, days);\n            calendarDate = this.isoToCalendarDate(addedIso, cache);\n            // Normally, we can advance one month by adding the number of days in the\n            // current month. However, if we're at the end of the current month and\n            // the next month has fewer days, then we rolled over to the after-next\n            // month. Below we detect this condition and back up until we're back in\n            // the desired month.\n            if (months > 0) {\n                const monthsInOldYear = this.monthsInYear(oldCalendarDate, cache);\n                while (calendarDate.month - 1 !== month % monthsInOldYear) {\n                    addedIso = this.addDaysIso(addedIso, -1);\n                    calendarDate = this.isoToCalendarDate(addedIso, cache);\n                }\n            }\n            if (calendarDate.day !== day) {\n                // try to retain the original day-of-month, if possible\n                calendarDate = this.regulateDate({ ...calendarDate, day }, 'constrain', cache);\n            }\n        }\n        if (overflow === 'reject' && calendarDate.day !== day) {\n            throw new RangeError(`Day ${day} does not exist in resulting calendar month`);\n        }\n        return calendarDate;\n    }\n    addCalendar(calendarDate, { years = 0, months = 0, weeks = 0, days = 0 }, overflow, cache) {\n        const { year, month, day } = calendarDate;\n        const addedMonths = this.addMonthsCalendar({ year: year + years, month, day }, months, overflow, cache);\n        const initialDays = days + weeks * 7;\n        const addedDays = this.addDaysCalendar(addedMonths, initialDays, cache);\n        return addedDays;\n    }\n    untilCalendar(calendarOne, calendarTwo, largestUnit, cache) {\n        let days = 0;\n        let weeks = 0;\n        let months = 0;\n        let years = 0;\n        switch (largestUnit) {\n            case 'day':\n                days = this.calendarDaysUntil(calendarOne, calendarTwo, cache);\n                break;\n            case 'week': {\n                const totalDays = this.calendarDaysUntil(calendarOne, calendarTwo, cache);\n                days = totalDays % 7;\n                weeks = (totalDays - days) / 7;\n                break;\n            }\n            case 'month':\n            case 'year': {\n                const diffYears = calendarTwo.year - calendarOne.year;\n                const diffMonths = calendarTwo.month - calendarOne.month;\n                const diffDays = calendarTwo.day - calendarOne.day;\n                const sign = this.compareCalendarDates(calendarTwo, calendarOne);\n                if (largestUnit === 'year' && diffYears) {\n                    const isOneFurtherInYear = diffMonths * sign < 0 || (diffMonths === 0 && diffDays * sign < 0);\n                    years = isOneFurtherInYear ? diffYears - sign : diffYears;\n                }\n                const yearsAdded = years ? this.addCalendar(calendarOne, { years }, 'constrain', cache) : calendarOne;\n                // Now we have less than one year remaining. Add one month at a time\n                // until we go over the target, then back up one month and calculate\n                // remaining days and weeks.\n                let current;\n                let next = yearsAdded;\n                do {\n                    months += sign;\n                    current = next;\n                    next = this.addMonthsCalendar(current, sign, 'constrain', cache);\n                    if (next.day !== calendarOne.day) {\n                        // In case the day was constrained down, try to un-constrain it\n                        next = this.regulateDate({ ...next, day: calendarOne.day }, 'constrain', cache);\n                    }\n                } while (this.compareCalendarDates(calendarTwo, next) * sign >= 0);\n                months -= sign; // correct for loop above which overshoots by 1\n                const remainingDays = this.calendarDaysUntil(current, calendarTwo, cache);\n                days = remainingDays;\n                break;\n            }\n        }\n        return { years, months, weeks, days };\n    }\n    daysInMonth(calendarDate, cache) {\n        // Add enough days to roll over to the next month. One we're in the next\n        // month, we can calculate the length of the current month. NOTE: This\n        // algorithm assumes that months are continuous. It would break if a\n        // calendar skipped days, like the Julian->Gregorian switchover. But the\n        // only ICU calendars that currently skip days (japanese/roc/buddhist) is a\n        // bug (https://bugs.chromium.org/p/chromium/issues/detail?id=1173158)\n        // that's currently detected by `checkIcuBugs()` which will throw. So this\n        // code should be safe for all ICU calendars.\n        const { day } = calendarDate;\n        const max = this.maximumMonthLength(calendarDate);\n        const min = this.minimumMonthLength(calendarDate);\n        // easiest case: we already know the month length if min and max are the same.\n        if (min === max)\n            return min;\n        // Add enough days to get into the next month, without skipping it\n        const increment = day <= max - min ? max : min;\n        const isoDate = this.calendarToIsoDate(calendarDate, 'constrain', cache);\n        const addedIsoDate = this.addDaysIso(isoDate, increment);\n        const addedCalendarDate = this.isoToCalendarDate(addedIsoDate, cache);\n        // Now back up to the last day of the original month\n        const endOfMonthIso = this.addDaysIso(addedIsoDate, -addedCalendarDate.day);\n        const endOfMonthCalendar = this.isoToCalendarDate(endOfMonthIso, cache);\n        return endOfMonthCalendar.day;\n    }\n    daysInPreviousMonth(calendarDate, cache) {\n        const { day, month, year } = calendarDate;\n        // Check to see if we already know the month length, and return it if so\n        const previousMonthYear = month > 1 ? year : year - 1;\n        let previousMonthDate = { year: previousMonthYear, month, day: 1 };\n        const previousMonth = month > 1 ? month - 1 : this.monthsInYear(previousMonthDate, cache);\n        previousMonthDate = { ...previousMonthDate, month: previousMonth };\n        const min = this.minimumMonthLength(previousMonthDate);\n        const max = this.maximumMonthLength(previousMonthDate);\n        if (min === max)\n            return max;\n        const isoDate = this.calendarToIsoDate(calendarDate, 'constrain', cache);\n        const lastDayOfPreviousMonthIso = this.addDaysIso(isoDate, -day);\n        const lastDayOfPreviousMonthCalendar = this.isoToCalendarDate(lastDayOfPreviousMonthIso, cache);\n        return lastDayOfPreviousMonthCalendar.day;\n    }\n    startOfCalendarYear(calendarDate) {\n        return { year: calendarDate.year, month: 1, day: 1 };\n    }\n    startOfCalendarMonth(calendarDate) {\n        return { year: calendarDate.year, month: calendarDate.month, day: 1 };\n    }\n    calendarDaysUntil(calendarOne, calendarTwo, cache) {\n        const oneIso = this.calendarToIsoDate(calendarOne, 'constrain', cache);\n        const twoIso = this.calendarToIsoDate(calendarTwo, 'constrain', cache);\n        return this.isoDaysUntil(oneIso, twoIso);\n    }\n    isoDaysUntil(oneIso, twoIso) {\n        const duration = DifferenceISODate(oneIso.year, oneIso.month, oneIso.day, twoIso.year, twoIso.month, twoIso.day, 'day');\n        return duration.days;\n    }\n    monthDayFromFields(fields, overflow, cache) {\n        let { year, month, monthCode, day, era, eraYear } = fields;\n        if (monthCode === undefined) {\n            if (year === undefined && (era === undefined || eraYear === undefined)) {\n                throw new TypeError('`monthCode`, `year`, or `era` and `eraYear` is required');\n            }\n            ({ monthCode, year } = this.adjustCalendarDate({ year, month, monthCode, day, era, eraYear }, cache, overflow));\n        }\n        let isoYear, isoMonth, isoDay;\n        let closestCalendar, closestIso;\n        // Look backwards starting from the calendar year of 1972-01-01 up to 100\n        // calendar years to find a year that has this month and day. Normal months\n        // and days will match immediately, but for leap days and leap months we may\n        // have to look for a while.\n        const startDateIso = { year: 1972, month: 1, day: 1 };\n        const { year: calendarYear } = this.isoToCalendarDate(startDateIso, cache);\n        for (let i = 0; i < 100; i++) {\n            const testCalendarDate = this.adjustCalendarDate({ day, monthCode, year: calendarYear - i }, cache);\n            const isoDate = this.calendarToIsoDate(testCalendarDate, 'constrain', cache);\n            const roundTripCalendarDate = this.isoToCalendarDate(isoDate, cache);\n            ({ year: isoYear, month: isoMonth, day: isoDay } = isoDate);\n            if (roundTripCalendarDate.monthCode === monthCode && roundTripCalendarDate.day === day) {\n                return { month: isoMonth, day: isoDay, year: isoYear };\n            }\n            else if (overflow === 'constrain') {\n                // non-ISO constrain algorithm tries to find the closest date in a matching month\n                if (closestCalendar === undefined ||\n                    (roundTripCalendarDate.monthCode === closestCalendar.monthCode &&\n                        roundTripCalendarDate.day > closestCalendar.day)) {\n                    closestCalendar = roundTripCalendarDate;\n                    closestIso = isoDate;\n                }\n            }\n        }\n        if (overflow === 'constrain' && closestIso !== undefined)\n            return closestIso;\n        throw new RangeError(`No recent ${this.id} year with monthCode ${monthCode} and day ${day}`);\n    }\n}\nclass HebrewHelper extends HelperBase {\n    constructor() {\n        super(...arguments);\n        this.id = 'hebrew';\n        this.calendarType = 'lunisolar';\n        this.months = {\n            Tishri: { leap: 1, regular: 1, monthCode: 'M01', days: 30 },\n            Heshvan: { leap: 2, regular: 2, monthCode: 'M02', days: { min: 29, max: 30 } },\n            Kislev: { leap: 3, regular: 3, monthCode: 'M03', days: { min: 29, max: 30 } },\n            Tevet: { leap: 4, regular: 4, monthCode: 'M04', days: 29 },\n            Shevat: { leap: 5, regular: 5, monthCode: 'M05', days: 30 },\n            Adar: { leap: undefined, regular: 6, monthCode: 'M06', days: 29 },\n            'Adar I': { leap: 6, regular: undefined, monthCode: 'M05L', days: 30 },\n            'Adar II': { leap: 7, regular: undefined, monthCode: 'M06', days: 29 },\n            Nisan: { leap: 8, regular: 7, monthCode: 'M07', days: 30 },\n            Iyar: { leap: 9, regular: 8, monthCode: 'M08', days: 29 },\n            Sivan: { leap: 10, regular: 9, monthCode: 'M09', days: 30 },\n            Tamuz: { leap: 11, regular: 10, monthCode: 'M10', days: 29 },\n            Av: { leap: 12, regular: 11, monthCode: 'M11', days: 30 },\n            Elul: { leap: 13, regular: 12, monthCode: 'M12', days: 29 }\n        };\n        // All built-in calendars except Chinese/Dangi and Hebrew use an era\n        this.hasEra = false;\n    }\n    inLeapYear(calendarDate) {\n        const { year } = calendarDate;\n        // FYI: In addition to adding a month in leap years, the Hebrew calendar\n        // also has per-year changes to the number of days of Heshvan and Kislev.\n        // Given that these can be calculated by counting the number of days in\n        // those months, I assume that these DO NOT need to be exposed as\n        // Hebrew-only prototype fields or methods.\n        return (7 * year + 1) % 19 < 7;\n    }\n    monthsInYear(calendarDate) {\n        return this.inLeapYear(calendarDate) ? 13 : 12;\n    }\n    minimumMonthLength(calendarDate) {\n        return this.minMaxMonthLength(calendarDate, 'min');\n    }\n    maximumMonthLength(calendarDate) {\n        return this.minMaxMonthLength(calendarDate, 'max');\n    }\n    minMaxMonthLength(calendarDate, minOrMax) {\n        const { month, year } = calendarDate;\n        const monthCode = this.getMonthCode(year, month);\n        const monthInfo = ObjectEntries(this.months).find((m) => m[1].monthCode === monthCode);\n        if (monthInfo === undefined)\n            throw new RangeError(`unmatched Hebrew month: ${month}`);\n        const daysInMonth = monthInfo[1].days;\n        return typeof daysInMonth === 'number' ? daysInMonth : daysInMonth[minOrMax];\n    }\n    /** Take a guess at what ISO date a particular calendar date corresponds to */\n    estimateIsoDate(calendarDate) {\n        const { year } = calendarDate;\n        return { year: year - 3760, month: 1, day: 1 };\n    }\n    getMonthCode(year, month) {\n        if (this.inLeapYear({ year })) {\n            return month === 6 ? buildMonthCode(5, true) : buildMonthCode(month < 6 ? month : month - 1);\n        }\n        else {\n            return buildMonthCode(month);\n        }\n    }\n    adjustCalendarDate(calendarDate, cache, overflow = 'constrain', fromLegacyDate = false) {\n        // The incoming type is actually CalendarDate (same as args to\n        // Calendar.dateFromParams) but TS isn't smart enough to follow all the\n        // reassignments below, so as an alternative to 10+ type casts, we'll lie\n        // here and claim that the type has `day` and `year` filled in already.\n        let { year, eraYear, month, monthCode, day, monthExtra } = calendarDate;\n        if (year === undefined && eraYear !== undefined)\n            year = eraYear;\n        if (eraYear === undefined && year !== undefined)\n            eraYear = year;\n        if (fromLegacyDate) {\n            // In Pre Node-14 V8, DateTimeFormat.formatToParts `month: 'numeric'`\n            // output returns the numeric equivalent of `month` as a string, meaning\n            // that `'6'` in a leap year is Adar I, while `'6'` in a non-leap year\n            // means Adar. In this case, `month` will already be correct and no action\n            // is needed. However, in Node 14 and later formatToParts returns the name\n            // of the Hebrew month (e.g. \"Tevet\"), so we'll need to look up the\n            // correct `month` using the string name as a key.\n            if (monthExtra) {\n                const monthInfo = this.months[monthExtra];\n                if (!monthInfo)\n                    throw new RangeError(`Unrecognized month from formatToParts: ${monthExtra}`);\n                month = this.inLeapYear({ year }) ? monthInfo.leap : monthInfo.regular;\n            }\n            // Because we're getting data from legacy Date, then `month` will always be present\n            monthCode = this.getMonthCode(year, month);\n            const result = { year, month: month, day, era: undefined, eraYear, monthCode };\n            return result;\n        }\n        else {\n            // When called without input coming from legacy Date output, simply ensure\n            // that all fields are present.\n            this.validateCalendarDate(calendarDate);\n            if (month === undefined) {\n                if (monthCode.endsWith('L')) {\n                    if (monthCode !== 'M05L') {\n                        throw new RangeError(`Hebrew leap month must have monthCode M05L, not ${monthCode}`);\n                    }\n                    month = 6;\n                    if (!this.inLeapYear({ year })) {\n                        if (overflow === 'reject') {\n                            throw new RangeError(`Hebrew monthCode M05L is invalid in year ${year} which is not a leap year`);\n                        }\n                        else {\n                            // constrain to last day of previous month (Av)\n                            month = 5;\n                            day = 30;\n                            monthCode = 'M05';\n                        }\n                    }\n                }\n                else {\n                    month = monthCodeNumberPart(monthCode);\n                    // if leap month is before this one, the month index is one more than the month code\n                    if (this.inLeapYear({ year }) && month > 6)\n                        month++;\n                    const largestMonth = this.monthsInYear({ year });\n                    if (month < 1 || month > largestMonth)\n                        throw new RangeError(`Invalid monthCode: ${monthCode}`);\n                }\n            }\n            else {\n                if (overflow === 'reject') {\n                    RejectToRange(month, 1, this.monthsInYear({ year }));\n                    RejectToRange(day, 1, this.maximumMonthLength({ year, month }));\n                }\n                else {\n                    month = ConstrainToRange(month, 1, this.monthsInYear({ year }));\n                    day = ConstrainToRange(day, 1, this.maximumMonthLength({ year, month }));\n                }\n                if (monthCode === undefined) {\n                    monthCode = this.getMonthCode(year, month);\n                }\n                else {\n                    const calculatedMonthCode = this.getMonthCode(year, month);\n                    if (calculatedMonthCode !== monthCode) {\n                        throw new RangeError(`monthCode ${monthCode} doesn't correspond to month ${month} in Hebrew year ${year}`);\n                    }\n                }\n            }\n            return { ...calendarDate, day, month, monthCode: monthCode, year, eraYear };\n        }\n    }\n}\n/**\n * For Temporal purposes, the Islamic calendar is simple because it's always the\n * same 12 months in the same order.\n */\nclass IslamicBaseHelper extends HelperBase {\n    constructor() {\n        super(...arguments);\n        this.calendarType = 'lunar';\n        this.DAYS_PER_ISLAMIC_YEAR = 354 + 11 / 30;\n        this.DAYS_PER_ISO_YEAR = 365.2425;\n        this.constantEra = 'ah';\n    }\n    inLeapYear(calendarDate, cache) {\n        // In leap years, the 12th month has 30 days. In non-leap years: 29.\n        const days = this.daysInMonth({ year: calendarDate.year, month: 12, day: 1 }, cache);\n        return days === 30;\n    }\n    monthsInYear( /* calendarYear, cache */) {\n        return 12;\n    }\n    minimumMonthLength( /* calendarDate */) {\n        return 29;\n    }\n    maximumMonthLength( /* calendarDate */) {\n        return 30;\n    }\n    estimateIsoDate(calendarDate) {\n        const { year } = this.adjustCalendarDate(calendarDate);\n        return { year: MathFloor$1((year * this.DAYS_PER_ISLAMIC_YEAR) / this.DAYS_PER_ISO_YEAR) + 622, month: 1, day: 1 };\n    }\n}\n// There are 6 Islamic calendars with the same implementation in this polyfill.\n// They vary only in their ID. They do emit different output from the underlying\n// Intl implementation, but our code for each of them is identical.\nclass IslamicHelper extends IslamicBaseHelper {\n    constructor() {\n        super(...arguments);\n        this.id = 'islamic';\n    }\n}\nclass IslamicUmalquraHelper extends IslamicBaseHelper {\n    constructor() {\n        super(...arguments);\n        this.id = 'islamic-umalqura';\n    }\n}\nclass IslamicTblaHelper extends IslamicBaseHelper {\n    constructor() {\n        super(...arguments);\n        this.id = 'islamic-tbla';\n    }\n}\nclass IslamicCivilHelper extends IslamicBaseHelper {\n    constructor() {\n        super(...arguments);\n        this.id = 'islamic-civil';\n    }\n}\nclass IslamicRgsaHelper extends IslamicBaseHelper {\n    constructor() {\n        super(...arguments);\n        this.id = 'islamic-rgsa';\n    }\n}\nclass IslamicCcHelper extends IslamicBaseHelper {\n    constructor() {\n        super(...arguments);\n        this.id = 'islamicc';\n    }\n}\nclass PersianHelper extends HelperBase {\n    constructor() {\n        super(...arguments);\n        this.id = 'persian';\n        this.calendarType = 'solar';\n        this.constantEra = 'ap';\n    }\n    inLeapYear(calendarDate, cache) {\n        // Same logic (count days in the last month) for Persian as for Islamic,\n        // even though Persian is solar and Islamic is lunar.\n        return IslamicHelper.prototype.inLeapYear.call(this, calendarDate, cache);\n    }\n    monthsInYear( /* calendarYear, cache */) {\n        return 12;\n    }\n    minimumMonthLength(calendarDate) {\n        const { month } = calendarDate;\n        if (month === 12)\n            return 29;\n        return month <= 6 ? 31 : 30;\n    }\n    maximumMonthLength(calendarDate) {\n        const { month } = calendarDate;\n        if (month === 12)\n            return 30;\n        return month <= 6 ? 31 : 30;\n    }\n    estimateIsoDate(calendarDate) {\n        const { year } = this.adjustCalendarDate(calendarDate);\n        return { year: year + 621, month: 1, day: 1 };\n    }\n}\nclass IndianHelper extends HelperBase {\n    constructor() {\n        super(...arguments);\n        this.id = 'indian';\n        this.calendarType = 'solar';\n        this.constantEra = 'saka';\n        // Indian months always start at the same well-known Gregorian month and\n        // day. So this conversion is easy and fast. See\n        // https://en.wikipedia.org/wiki/Indian_national_calendar\n        this.months = {\n            1: { length: 30, month: 3, day: 22, leap: { length: 31, month: 3, day: 21 } },\n            2: { length: 31, month: 4, day: 21 },\n            3: { length: 31, month: 5, day: 22 },\n            4: { length: 31, month: 6, day: 22 },\n            5: { length: 31, month: 7, day: 23 },\n            6: { length: 31, month: 8, day: 23 },\n            7: { length: 30, month: 9, day: 23 },\n            8: { length: 30, month: 10, day: 23 },\n            9: { length: 30, month: 11, day: 22 },\n            10: { length: 30, month: 12, day: 22 },\n            11: { length: 30, month: 1, nextYear: true, day: 21 },\n            12: { length: 30, month: 2, nextYear: true, day: 20 }\n        };\n        // https://bugs.chromium.org/p/v8/issues/detail?id=10529 causes Intl's Indian\n        // calendar output to fail for all dates before 0001-01-01 ISO.  For example,\n        // in Node 12 0000-01-01 is calculated as 6146/12/-583 instead of 10/11/-79 as\n        // expected.\n        this.vulnerableToBceBug = new Date('0000-01-01T00:00Z').toLocaleDateString('en-US-u-ca-indian', { timeZone: 'UTC' }) !== '10/11/-79 Saka';\n    }\n    inLeapYear(calendarDate) {\n        // From https://en.wikipedia.org/wiki/Indian_national_calendar:\n        // Years are counted in the Saka era, which starts its year 0 in the year 78\n        // of the Common Era. To determine leap years, add 78 to the Saka year  if\n        // the result is a leap year in the Gregorian calendar, then the Saka year\n        // is a leap year as well.\n        return isGregorianLeapYear(calendarDate.year + 78);\n    }\n    monthsInYear( /* calendarYear, cache */) {\n        return 12;\n    }\n    minimumMonthLength(calendarDate) {\n        return this.getMonthInfo(calendarDate).length;\n    }\n    maximumMonthLength(calendarDate) {\n        return this.getMonthInfo(calendarDate).length;\n    }\n    getMonthInfo(calendarDate) {\n        const { month } = calendarDate;\n        let monthInfo = this.months[month];\n        if (monthInfo === undefined)\n            throw new RangeError(`Invalid month: ${month}`);\n        if (this.inLeapYear(calendarDate) && monthInfo.leap)\n            monthInfo = monthInfo.leap;\n        return monthInfo;\n    }\n    estimateIsoDate(calendarDateParam) {\n        // FYI, this \"estimate\" is always the exact ISO date, which makes the Indian\n        // calendar fast!\n        const calendarDate = this.adjustCalendarDate(calendarDateParam);\n        const monthInfo = this.getMonthInfo(calendarDate);\n        const isoYear = calendarDate.year + 78 + (monthInfo.nextYear ? 1 : 0);\n        const isoMonth = monthInfo.month;\n        const isoDay = monthInfo.day;\n        const isoDate = AddISODate(isoYear, isoMonth, isoDay, 0, 0, 0, calendarDate.day - 1, 'constrain');\n        return isoDate;\n    }\n    checkIcuBugs(isoDate) {\n        if (this.vulnerableToBceBug && isoDate.year < 1) {\n            throw new RangeError(`calendar '${this.id}' is broken for ISO dates before 0001-01-01` +\n                ' (see https://bugs.chromium.org/p/v8/issues/detail?id=10529)');\n        }\n    }\n}\n/**\n * This function adds additional metadata that makes it easier to work with\n * eras. Note that it mutates and normalizes the original era objects, which is\n * OK because this is non-observable, internal-only metadata.\n *\n * The result is an array of eras with the shape defined above.\n * */\nfunction adjustEras(erasParam) {\n    let eras = erasParam;\n    if (eras.length === 0) {\n        throw new RangeError('Invalid era data: eras are required');\n    }\n    if (eras.length === 1 && eras[0].reverseOf) {\n        throw new RangeError('Invalid era data: anchor era cannot count years backwards');\n    }\n    if (eras.length === 1 && !eras[0].name) {\n        throw new RangeError('Invalid era data: at least one named era is required');\n    }\n    if (eras.filter((e) => e.reverseOf != null).length > 1) {\n        throw new RangeError('Invalid era data: only one era can count years backwards');\n    }\n    // Find the \"anchor era\" which is the era used for (era-less) `year`. Reversed\n    // eras can never be anchors. The era without an `anchorEpoch` property is the\n    // anchor.\n    let anchorEra;\n    eras.forEach((e) => {\n        if (e.isAnchor || (!e.anchorEpoch && !e.reverseOf)) {\n            if (anchorEra)\n                throw new RangeError('Invalid era data: cannot have multiple anchor eras');\n            anchorEra = e;\n            e.anchorEpoch = { year: e.hasYearZero ? 0 : 1 };\n        }\n        else if (!e.name) {\n            throw new RangeError('If era name is blank, it must be the anchor era');\n        }\n    });\n    // If the era name is undefined, then it's an anchor that doesn't interact\n    // with eras at all. For example, Japanese `year` is always the same as ISO\n    // `year`.  So this \"era\" is the anchor era but isn't used for era matching.\n    // Strip it from the list that's returned.\n    eras = eras.filter((e) => e.name);\n    eras.forEach((e) => {\n        // Some eras are mirror images of another era e.g. B.C. is the reverse of A.D.\n        // Replace the string-valued \"reverseOf\" property with the actual era object\n        // that's reversed.\n        const { reverseOf } = e;\n        if (reverseOf) {\n            const reversedEra = eras.find((era) => era.name === reverseOf);\n            if (reversedEra === undefined)\n                throw new RangeError(`Invalid era data: unmatched reverseOf era: ${reverseOf}`);\n            e.reverseOf = reversedEra;\n            e.anchorEpoch = reversedEra.anchorEpoch;\n            e.isoEpoch = reversedEra.isoEpoch;\n        }\n        if (e.anchorEpoch.month === undefined)\n            e.anchorEpoch.month = 1;\n        if (e.anchorEpoch.day === undefined)\n            e.anchorEpoch.day = 1;\n    });\n    // Ensure that the latest epoch is first in the array. This lets us try to\n    // match eras in index order, with the last era getting the remaining older\n    // years. Any reverse-signed era must be at the end.\n    ArraySort.call(eras, (e1, e2) => {\n        if (e1.reverseOf)\n            return 1;\n        if (e2.reverseOf)\n            return -1;\n        if (!e1.isoEpoch || !e2.isoEpoch)\n            throw new RangeError('Invalid era data: missing ISO epoch');\n        return e2.isoEpoch.year - e1.isoEpoch.year;\n    });\n    // If there's a reversed era, then the one before it must be the era that's\n    // being reversed.\n    const lastEraReversed = eras[eras.length - 1].reverseOf;\n    if (lastEraReversed) {\n        if (lastEraReversed !== eras[eras.length - 2])\n            throw new RangeError('Invalid era data: invalid reverse-sign era');\n    }\n    // Finally, add a \"genericName\" property in the format \"era{n} where `n` is\n    // zero-based index, with the oldest era being zero. This format is used by\n    // older versions of ICU data.\n    eras.forEach((e, i) => {\n        e.genericName = `era${eras.length - 1 - i}`;\n    });\n    return { eras: eras, anchorEra: (anchorEra || eras[0]) };\n}\nfunction isGregorianLeapYear(year) {\n    return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);\n}\n/** Base for all Gregorian-like calendars. */\nclass GregorianBaseHelper extends HelperBase {\n    constructor(id, originalEras) {\n        super();\n        this.calendarType = 'solar';\n        // Several calendars based on the Gregorian calendar use Julian dates (not\n        // proleptic Gregorian dates) before the Julian switchover in Oct 1582. See\n        // https://bugs.chromium.org/p/chromium/issues/detail?id=1173158.\n        this.v8IsVulnerableToJulianBug = new Date('+001001-01-01T00:00Z')\n            .toLocaleDateString('en-US-u-ca-japanese', { timeZone: 'UTC' })\n            .startsWith('12');\n        this.calendarIsVulnerableToJulianBug = false;\n        this.id = id;\n        const { eras, anchorEra } = adjustEras(originalEras);\n        this.anchorEra = anchorEra;\n        this.eras = eras;\n    }\n    inLeapYear(calendarDate) {\n        // Calendars that don't override this method use the same months and leap\n        // years as Gregorian. Once we know the ISO year corresponding to the\n        // calendar year, we'll know if it's a leap year or not.\n        const { year } = this.estimateIsoDate({ month: 1, day: 1, year: calendarDate.year });\n        return isGregorianLeapYear(year);\n    }\n    monthsInYear( /* calendarDate */) {\n        return 12;\n    }\n    minimumMonthLength(calendarDate) {\n        const { month } = calendarDate;\n        if (month === 2)\n            return this.inLeapYear(calendarDate) ? 29 : 28;\n        return [4, 6, 9, 11].indexOf(month) >= 0 ? 30 : 31;\n    }\n    maximumMonthLength(calendarDate) {\n        return this.minimumMonthLength(calendarDate);\n    }\n    /** Fill in missing parts of the (year, era, eraYear) tuple */\n    completeEraYear(calendarDate) {\n        const checkField = (name, value) => {\n            const currentValue = calendarDate[name];\n            if (currentValue != null && currentValue != value) {\n                throw new RangeError(`Input ${name} ${currentValue} doesn't match calculated value ${value}`);\n            }\n        };\n        const eraFromYear = (year) => {\n            let eraYear;\n            const adjustedCalendarDate = { ...calendarDate, year };\n            const matchingEra = this.eras.find((e, i) => {\n                if (i === this.eras.length - 1) {\n                    if (e.reverseOf) {\n                        // This is a reverse-sign era (like BCE) which must be the oldest\n                        // era. Count years backwards.\n                        if (year > 0)\n                            throw new RangeError(`Signed year ${year} is invalid for era ${e.name}`);\n                        eraYear = e.anchorEpoch.year - year;\n                        return true;\n                    }\n                    // last era always gets all \"leftover\" (older than epoch) years,\n                    // so no need for a comparison like below.\n                    eraYear = year - e.anchorEpoch.year + (e.hasYearZero ? 0 : 1);\n                    return true;\n                }\n                const comparison = this.compareCalendarDates(adjustedCalendarDate, e.anchorEpoch);\n                if (comparison >= 0) {\n                    eraYear = year - e.anchorEpoch.year + (e.hasYearZero ? 0 : 1);\n                    return true;\n                }\n                return false;\n            });\n            if (!matchingEra)\n                throw new RangeError(`Year ${year} was not matched by any era`);\n            return { eraYear: eraYear, era: matchingEra.name };\n        };\n        let { year, eraYear, era } = calendarDate;\n        if (year != null) {\n            ({ eraYear, era } = eraFromYear(year));\n            checkField('era', era);\n            checkField('eraYear', eraYear);\n        }\n        else if (eraYear != null) {\n            const matchingEra = era === undefined ? undefined : this.eras.find((e) => e.name === era || e.genericName === era);\n            if (!matchingEra)\n                throw new RangeError(`Era ${era} (ISO year ${eraYear}) was not matched by any era`);\n            if (eraYear < 1 && matchingEra.reverseOf) {\n                throw new RangeError(`Years in ${era} era must be positive, not ${year}`);\n            }\n            if (matchingEra.reverseOf) {\n                year = matchingEra.anchorEpoch.year - eraYear;\n            }\n            else {\n                year = eraYear + matchingEra.anchorEpoch.year - (matchingEra.hasYearZero ? 0 : 1);\n            }\n            checkField('year', year);\n            // We'll accept dates where the month/day is earlier than the start of\n            // the era or after its end as long as it's in the same year. If that\n            // happens, we'll adjust the era/eraYear pair to be the correct era for\n            // the `year`.\n            ({ eraYear, era } = eraFromYear(year));\n        }\n        else {\n            throw new RangeError('Either `year` or `eraYear` and `era` are required');\n        }\n        return { ...calendarDate, year, eraYear, era };\n    }\n    adjustCalendarDate(calendarDateParam, cache, overflow = 'constrain') {\n        let calendarDate = calendarDateParam;\n        // Because this is not a lunisolar calendar, it's safe to convert monthCode to a number\n        const { month, monthCode } = calendarDate;\n        if (month === undefined)\n            calendarDate = { ...calendarDate, month: monthCodeNumberPart(monthCode) };\n        this.validateCalendarDate(calendarDate);\n        calendarDate = this.completeEraYear(calendarDate);\n        return super.adjustCalendarDate(calendarDate, cache, overflow);\n    }\n    estimateIsoDate(calendarDateParam) {\n        const calendarDate = this.adjustCalendarDate(calendarDateParam);\n        const { year, month, day } = calendarDate;\n        const { anchorEra } = this;\n        const isoYearEstimate = year + anchorEra.isoEpoch.year - (anchorEra.hasYearZero ? 0 : 1);\n        return RegulateISODate(isoYearEstimate, month, day, 'constrain');\n    }\n    checkIcuBugs(isoDate) {\n        if (this.calendarIsVulnerableToJulianBug && this.v8IsVulnerableToJulianBug) {\n            const beforeJulianSwitch = CompareISODate(isoDate.year, isoDate.month, isoDate.day, 1582, 10, 15) < 0;\n            if (beforeJulianSwitch) {\n                throw new RangeError(`calendar '${this.id}' is broken for ISO dates before 1582-10-15` +\n                    ' (see https://bugs.chromium.org/p/chromium/issues/detail?id=1173158)');\n            }\n        }\n    }\n}\nclass OrthodoxBaseHelper extends GregorianBaseHelper {\n    constructor(id, originalEras) {\n        super(id, originalEras);\n    }\n    inLeapYear(calendarDate) {\n        // Leap years happen one year before the Julian leap year. Note that this\n        // calendar is based on the Julian calendar which has a leap year every 4\n        // years, unlike the Gregorian calendar which doesn't have leap years on\n        // years divisible by 100 except years divisible by 400.\n        //\n        // Note that we're assuming that leap years in before-epoch times match\n        // how leap years are defined now. This is probably not accurate but I'm\n        // not sure how better to do it.\n        const { year } = calendarDate;\n        return (year + 1) % 4 === 0;\n    }\n    monthsInYear( /* calendarDate */) {\n        return 13;\n    }\n    minimumMonthLength(calendarDate) {\n        const { month } = calendarDate;\n        // Ethiopian/Coptic calendars have 12 30-day months and an extra 5-6 day 13th month.\n        if (month === 13)\n            return this.inLeapYear(calendarDate) ? 6 : 5;\n        return 30;\n    }\n    maximumMonthLength(calendarDate) {\n        return this.minimumMonthLength(calendarDate);\n    }\n}\n// `coptic` and `ethiopic` calendars are very similar to `ethioaa` calendar,\n// with the following differences:\n// - Coptic uses BCE-like positive numbers for years before its epoch (the other\n//   two use negative year numbers before epoch)\n// - Coptic has a different epoch date\n// - Ethiopic has an additional second era that starts at the same date as the\n//   zero era of ethioaa.\nclass EthioaaHelper extends OrthodoxBaseHelper {\n    constructor() {\n        super('ethioaa', [{ name: 'era0', isoEpoch: { year: -5492, month: 7, day: 17 } }]);\n    }\n}\nclass CopticHelper extends OrthodoxBaseHelper {\n    constructor() {\n        super('coptic', [\n            { name: 'era1', isoEpoch: { year: 284, month: 8, day: 29 } },\n            { name: 'era0', reverseOf: 'era1' }\n        ]);\n    }\n}\n// Anchor is currently the older era to match ethioaa, but should it be the newer era?\n// See https://github.com/tc39/ecma402/issues/534 for discussion.\nclass EthiopicHelper extends OrthodoxBaseHelper {\n    constructor() {\n        super('ethiopic', [\n            { name: 'era0', isoEpoch: { year: -5492, month: 7, day: 17 } },\n            { name: 'era1', isoEpoch: { year: 8, month: 8, day: 27 }, anchorEpoch: { year: 5501 } }\n        ]);\n    }\n}\nclass RocHelper extends GregorianBaseHelper {\n    constructor() {\n        super('roc', [\n            { name: 'minguo', isoEpoch: { year: 1912, month: 1, day: 1 } },\n            { name: 'before-roc', reverseOf: 'minguo' }\n        ]);\n        this.calendarIsVulnerableToJulianBug = true;\n    }\n}\nclass BuddhistHelper extends GregorianBaseHelper {\n    constructor() {\n        super('buddhist', [{ name: 'be', hasYearZero: true, isoEpoch: { year: -543, month: 1, day: 1 } }]);\n        this.calendarIsVulnerableToJulianBug = true;\n    }\n}\nclass GregoryHelper extends GregorianBaseHelper {\n    constructor() {\n        super('gregory', [\n            { name: 'ce', isoEpoch: { year: 1, month: 1, day: 1 } },\n            { name: 'bce', reverseOf: 'ce' }\n        ]);\n    }\n    reviseIntlEra(calendarDate /*, isoDate: IsoDate*/) {\n        let { era, eraYear } = calendarDate;\n        // Firefox 96 introduced a bug where the `'short'` format of the era\n        // option mistakenly returns the one-letter (narrow) format instead. The\n        // code below handles either the correct or Firefox-buggy format. See\n        // https://bugzilla.mozilla.org/show_bug.cgi?id=1752253\n        if (era === 'bc' || era === 'b')\n            era = 'bce';\n        if (era === 'ad' || era === 'a')\n            era = 'ce';\n        return { era, eraYear };\n    }\n}\n// NOTE: Only the 5 modern eras (Meiji and later) are included. For dates\n// before Meiji 1, the `ce` and `bce` eras are used. Challenges with pre-Meiji\n// eras include:\n// - Start/end dates of older eras are not precisely defined, which is\n//   challenging given Temporal's need for precision\n// - Some era dates and/or names are disputed by historians\n// - As historical research proceeds, new eras are discovered and existing era\n//   dates are modified, leading to considerable churn which is not good for\n//   Temporal use.\n//  - The earliest era (in 645 CE) may not end up being the earliest depending\n//    on future historical scholarship\n//  - Before Meiji, Japan used a lunar (or lunisolar?) calendar but AFAIK\n//    that's not reflected in the ICU implementation.\n//\n// For more discussion: https://github.com/tc39/proposal-temporal/issues/526.\n//\n// Here's a full list of CLDR/ICU eras:\n// https://github.com/unicode-org/icu/blob/master/icu4c/source/data/locales/root.txt#L1582-L1818\n// https://github.com/unicode-org/cldr/blob/master/common/supplemental/supplementalData.xml#L4310-L4546\n//\n// NOTE: Japan started using the Gregorian calendar in 6 Meiji, replacing a\n// lunisolar calendar. So the day before January 1 of 6 Meiji (1873) was not\n// December 31, but December 2, of 5 Meiji (1872). The existing Ecma-402\n// Japanese calendar doesn't seem to take this into account, so neither do we:\n// > args = ['en-ca-u-ca-japanese', { era: 'short' }]\n// > new Date('1873-01-01T12:00').toLocaleString(...args)\n// '1 1, 6 Meiji, 12:00:00 PM'\n// > new Date('1872-12-31T12:00').toLocaleString(...args)\n// '12 31, 5 Meiji, 12:00:00 PM'\nclass JapaneseHelper extends GregorianBaseHelper {\n    constructor() {\n        super('japanese', [\n            // The Japanese calendar `year` is just the ISO year, because (unlike other\n            // ICU calendars) there's no obvious \"default era\", we use the ISO year.\n            { name: 'reiwa', isoEpoch: { year: 2019, month: 5, day: 1 }, anchorEpoch: { year: 2019, month: 5, day: 1 } },\n            { name: 'heisei', isoEpoch: { year: 1989, month: 1, day: 8 }, anchorEpoch: { year: 1989, month: 1, day: 8 } },\n            { name: 'showa', isoEpoch: { year: 1926, month: 12, day: 25 }, anchorEpoch: { year: 1926, month: 12, day: 25 } },\n            { name: 'taisho', isoEpoch: { year: 1912, month: 7, day: 30 }, anchorEpoch: { year: 1912, month: 7, day: 30 } },\n            { name: 'meiji', isoEpoch: { year: 1868, month: 9, day: 8 }, anchorEpoch: { year: 1868, month: 9, day: 8 } },\n            { name: 'ce', isoEpoch: { year: 1, month: 1, day: 1 } },\n            { name: 'bce', reverseOf: 'ce' }\n        ]);\n        this.calendarIsVulnerableToJulianBug = true;\n        // The last 3 Japanese eras confusingly return only one character in the\n        // default \"short\" era, so need to use the long format.\n        this.eraLength = 'long';\n    }\n    reviseIntlEra(calendarDate, isoDate) {\n        const { era, eraYear } = calendarDate;\n        const { year: isoYear } = isoDate;\n        if (this.eras.find((e) => e.name === era))\n            return { era, eraYear };\n        return (isoYear < 1 ? { era: 'bce', eraYear: 1 - isoYear } : { era: 'ce', eraYear: isoYear });\n    }\n}\nclass ChineseBaseHelper extends HelperBase {\n    constructor() {\n        super(...arguments);\n        this.calendarType = 'lunisolar';\n        // All built-in calendars except Chinese/Dangi and Hebrew use an era\n        this.hasEra = false;\n    }\n    inLeapYear(calendarDate, cache) {\n        const months = this.getMonthList(calendarDate.year, cache);\n        return ObjectEntries(months).length === 13;\n    }\n    monthsInYear(calendarDate, cache) {\n        return this.inLeapYear(calendarDate, cache) ? 13 : 12;\n    }\n    minimumMonthLength( /* calendarDate */) {\n        return 29;\n    }\n    maximumMonthLength( /* calendarDate */) {\n        return 30;\n    }\n    getMonthList(calendarYear, cache) {\n        if (calendarYear === undefined) {\n            throw new TypeError('Missing year');\n        }\n        const key = JSON.stringify({ func: 'getMonthList', calendarYear, id: this.id });\n        const cached = cache.get(key);\n        if (cached)\n            return cached;\n        const dateTimeFormat = this.getFormatter();\n        const getCalendarDate = (isoYear, daysPastFeb1) => {\n            const isoStringFeb1 = toUtcIsoDateString({ isoYear, isoMonth: 2, isoDay: 1 });\n            const legacyDate = new Date(isoStringFeb1);\n            // Now add the requested number of days, which may wrap to the next month.\n            legacyDate.setUTCDate(daysPastFeb1 + 1);\n            const newYearGuess = dateTimeFormat.formatToParts(legacyDate);\n            const calendarMonthString = newYearGuess.find((tv) => tv.type === 'month').value;\n            const calendarDay = +newYearGuess.find((tv) => tv.type === 'day').value;\n            let calendarYearToVerify = newYearGuess.find((tv) => tv.type === 'relatedYear');\n            if (calendarYearToVerify !== undefined) {\n                calendarYearToVerify = +calendarYearToVerify.value;\n            }\n            else {\n                // Node 12 has outdated ICU data that lacks the `relatedYear` field in the\n                // output of Intl.DateTimeFormat.formatToParts.\n                throw new RangeError(`Intl.DateTimeFormat.formatToParts lacks relatedYear in ${this.id} calendar. Try Node 14+ or modern browsers.`);\n            }\n            return { calendarMonthString, calendarDay, calendarYearToVerify };\n        };\n        // First, find a date close to Chinese New Year. Feb 17 will either be in\n        // the first month or near the end of the last month of the previous year.\n        let isoDaysDelta = 17;\n        let { calendarMonthString, calendarDay, calendarYearToVerify } = getCalendarDate(calendarYear, isoDaysDelta);\n        // If we didn't guess the first month correctly, add (almost in some months)\n        // a lunar month\n        if (calendarMonthString !== '1') {\n            isoDaysDelta += 29;\n            ({ calendarMonthString, calendarDay } = getCalendarDate(calendarYear, isoDaysDelta));\n        }\n        // Now back up to near the start of the first month, but not too near that\n        // off-by-one issues matter.\n        isoDaysDelta -= calendarDay - 5;\n        const result = {};\n        let monthIndex = 1;\n        let oldCalendarDay;\n        let oldMonthString;\n        let done = false;\n        do {\n            ({ calendarMonthString, calendarDay, calendarYearToVerify } = getCalendarDate(calendarYear, isoDaysDelta));\n            if (oldCalendarDay) {\n                result[oldMonthString].daysInMonth = oldCalendarDay + 30 - calendarDay;\n            }\n            if (calendarYearToVerify !== calendarYear) {\n                done = true;\n            }\n            else {\n                result[calendarMonthString] = { monthIndex: monthIndex++ };\n                // Move to the next month. Because months are sometimes 29 days, the day of the\n                // calendar month will move forward slowly but not enough to flip over to a new\n                // month before the loop ends at 12-13 months.\n                isoDaysDelta += 30;\n            }\n            oldCalendarDay = calendarDay;\n            oldMonthString = calendarMonthString;\n        } while (!done);\n        result[oldMonthString].daysInMonth = oldCalendarDay + 30 - calendarDay;\n        cache.set(key, result);\n        return result;\n    }\n    estimateIsoDate(calendarDate) {\n        const { year, month } = calendarDate;\n        return { year, month: month >= 12 ? 12 : month + 1, day: 1 };\n    }\n    adjustCalendarDate(calendarDate, cache, overflow = 'constrain', fromLegacyDate = false) {\n        let { year, month, monthExtra, day, monthCode, eraYear } = calendarDate;\n        if (fromLegacyDate) {\n            // Legacy Date output returns a string that's an integer with an optional\n            // \"bis\" suffix used only by the Chinese/Dangi calendar to indicate a leap\n            // month. Below we'll normalize the output.\n            year = eraYear;\n            if (monthExtra && monthExtra !== 'bis')\n                throw new RangeError(`Unexpected leap month suffix: ${monthExtra}`);\n            const monthCode = buildMonthCode(month, monthExtra !== undefined);\n            const monthString = `${month}${monthExtra || ''}`;\n            const months = this.getMonthList(year, cache);\n            const monthInfo = months[monthString];\n            if (monthInfo === undefined)\n                throw new RangeError(`Unmatched month ${monthString} in Chinese year ${year}`);\n            month = monthInfo.monthIndex;\n            return { year: year, month, day: day, era: undefined, eraYear, monthCode };\n        }\n        else {\n            // When called without input coming from legacy Date output,\n            // simply ensure that all fields are present.\n            this.validateCalendarDate(calendarDate);\n            if (year === undefined)\n                year = eraYear;\n            if (eraYear === undefined)\n                eraYear = year;\n            if (month === undefined) {\n                const months = this.getMonthList(year, cache);\n                let numberPart = monthCode.replace('L', 'bis').slice(1);\n                if (numberPart[0] === '0')\n                    numberPart = numberPart.slice(1);\n                let monthInfo = months[numberPart];\n                month = monthInfo && monthInfo.monthIndex;\n                // If this leap month isn't present in this year, constrain down to the last day of the previous month.\n                if (month === undefined &&\n                    monthCode.endsWith('L') &&\n                    !ArrayIncludes.call(['M01L', 'M12L', 'M13L'], monthCode) &&\n                    overflow === 'constrain') {\n                    let withoutML = monthCode.slice(1, -1);\n                    if (withoutML[0] === '0')\n                        withoutML = withoutML.slice(1);\n                    monthInfo = months[withoutML];\n                    if (monthInfo) {\n                        ({ daysInMonth: day, monthIndex: month } = monthInfo);\n                        monthCode = buildMonthCode(withoutML);\n                    }\n                }\n                if (month === undefined) {\n                    throw new RangeError(`Unmatched month ${monthCode} in Chinese year ${year}`);\n                }\n            }\n            else if (monthCode === undefined) {\n                const months = this.getMonthList(year, cache);\n                const monthEntries = ObjectEntries(months);\n                const largestMonth = monthEntries.length;\n                if (overflow === 'reject') {\n                    RejectToRange(month, 1, largestMonth);\n                    RejectToRange(day, 1, this.maximumMonthLength());\n                }\n                else {\n                    month = ConstrainToRange(month, 1, largestMonth);\n                    day = ConstrainToRange(day, 1, this.maximumMonthLength());\n                }\n                const matchingMonthEntry = monthEntries.find(([, v]) => v.monthIndex === month);\n                if (matchingMonthEntry === undefined) {\n                    throw new RangeError(`Invalid month ${month} in Chinese year ${year}`);\n                }\n                monthCode = buildMonthCode(matchingMonthEntry[0].replace('bis', ''), matchingMonthEntry[0].indexOf('bis') !== -1);\n            }\n            else {\n                // Both month and monthCode are present. Make sure they don't conflict.\n                const months = this.getMonthList(year, cache);\n                let numberPart = monthCode.replace('L', 'bis').slice(1);\n                if (numberPart[0] === '0')\n                    numberPart = numberPart.slice(1);\n                const monthInfo = months[numberPart];\n                if (!monthInfo)\n                    throw new RangeError(`Unmatched monthCode ${monthCode} in Chinese year ${year}`);\n                if (month !== monthInfo.monthIndex) {\n                    throw new RangeError(`monthCode ${monthCode} doesn't correspond to month ${month} in Chinese year ${year}`);\n                }\n            }\n            return {\n                ...calendarDate,\n                year: year,\n                eraYear,\n                month,\n                monthCode: monthCode,\n                day: day\n            };\n        }\n    }\n}\nclass ChineseHelper extends ChineseBaseHelper {\n    constructor() {\n        super(...arguments);\n        this.id = 'chinese';\n    }\n}\n// Dangi (Korean) calendar has same implementation as Chinese\nclass DangiHelper extends ChineseBaseHelper {\n    constructor() {\n        super(...arguments);\n        this.id = 'dangi';\n    }\n}\n/**\n * Common implementation of all non-ISO calendars.\n * Per-calendar id and logic live in `id` and `helper` properties attached later.\n * This split allowed an easy separation between code that was similar between\n * ISO and non-ISO implementations vs. code that was very different.\n */\nconst nonIsoImpl = {\n    // `helper` is added when this object is spread into each calendar's\n    // implementation\n    helper: undefined,\n    dateFromFields(fieldsParam, options, calendar) {\n        const overflow = ToTemporalOverflow(options);\n        const cache = new OneObjectCache();\n        // Intentionally alphabetical\n        const fields = PrepareTemporalFields(fieldsParam, [\n            ['day'],\n            ['era', undefined],\n            ['eraYear', undefined],\n            ['month', undefined],\n            ['monthCode', undefined],\n            ['year', undefined]\n        ]);\n        const { year, month, day } = this.helper.calendarToIsoDate(fields, overflow, cache);\n        const result = CreateTemporalDate(year, month, day, calendar);\n        cache.setObject(result);\n        return result;\n    },\n    yearMonthFromFields(fieldsParam, options, calendar) {\n        const overflow = ToTemporalOverflow(options);\n        const cache = new OneObjectCache();\n        // Intentionally alphabetical\n        const fields = PrepareTemporalFields(fieldsParam, [\n            ['era', undefined],\n            ['eraYear', undefined],\n            ['month', undefined],\n            ['monthCode', undefined],\n            ['year', undefined]\n        ]);\n        const { year, month, day } = this.helper.calendarToIsoDate({ ...fields, day: 1 }, overflow, cache);\n        const result = CreateTemporalYearMonth(year, month, calendar, /* referenceISODay = */ day);\n        cache.setObject(result);\n        return result;\n    },\n    monthDayFromFields(fieldsParam, options, calendar) {\n        const overflow = ToTemporalOverflow(options);\n        // All built-in calendars require `day`, but some allow other fields to be\n        // substituted for `month`. And for lunisolar calendars, either `monthCode`\n        // or `year` must be provided because `month` is ambiguous without a year or\n        // a code.\n        const cache = new OneObjectCache();\n        const fields = PrepareTemporalFields(fieldsParam, [\n            ['day'],\n            ['era', undefined],\n            ['eraYear', undefined],\n            ['month', undefined],\n            ['monthCode', undefined],\n            ['year', undefined]\n        ]);\n        const { year, month, day } = this.helper.monthDayFromFields(fields, overflow, cache);\n        // `year` is a reference year where this month/day exists in this calendar\n        const result = CreateTemporalMonthDay(month, day, calendar, /* referenceISOYear = */ year);\n        cache.setObject(result);\n        return result;\n    },\n    fields(fieldsParam) {\n        let fields = fieldsParam;\n        if (ArrayIncludes.call(fields, 'year'))\n            fields = [...fields, 'era', 'eraYear'];\n        return fields;\n    },\n    mergeFields(fields, additionalFields) {\n        const fieldsCopy = { ...fields };\n        const additionalFieldsCopy = { ...additionalFields };\n        // era and eraYear are intentionally unused\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        const { month, monthCode, year, era, eraYear, ...original } = fieldsCopy;\n        const { month: newMonth, monthCode: newMonthCode, year: newYear, era: newEra, eraYear: newEraYear } = additionalFieldsCopy;\n        if (newMonth === undefined && newMonthCode === undefined) {\n            original.month = month;\n            original.monthCode = monthCode;\n        }\n        if (newYear === undefined && newEra === undefined && newEraYear === undefined) {\n            // Only `year` is needed. We don't set era and eraYear because it's\n            // possible to create a conflict for eras that start or end mid-year. See\n            // https://github.com/tc39/proposal-temporal/issues/1784.\n            original.year = year;\n        }\n        return { ...original, ...additionalFieldsCopy };\n    },\n    dateAdd(date, years, months, weeks, days, overflow, calendar) {\n        const cache = OneObjectCache.getCacheForObject(date);\n        const calendarDate = this.helper.temporalToCalendarDate(date, cache);\n        const added = this.helper.addCalendar(calendarDate, { years, months, weeks, days }, overflow, cache);\n        const isoAdded = this.helper.calendarToIsoDate(added, 'constrain', cache);\n        const { year, month, day } = isoAdded;\n        const newTemporalObject = CreateTemporalDate(year, month, day, calendar);\n        // The new object's cache starts with the cache of the old object\n        const newCache = new OneObjectCache(cache);\n        newCache.setObject(newTemporalObject);\n        return newTemporalObject;\n    },\n    dateUntil(one, two, largestUnit) {\n        const cacheOne = OneObjectCache.getCacheForObject(one);\n        const cacheTwo = OneObjectCache.getCacheForObject(two);\n        const calendarOne = this.helper.temporalToCalendarDate(one, cacheOne);\n        const calendarTwo = this.helper.temporalToCalendarDate(two, cacheTwo);\n        const result = this.helper.untilCalendar(calendarOne, calendarTwo, largestUnit, cacheOne);\n        return result;\n    },\n    year(date) {\n        const cache = OneObjectCache.getCacheForObject(date);\n        const calendarDate = this.helper.temporalToCalendarDate(date, cache);\n        return calendarDate.year;\n    },\n    month(date) {\n        const cache = OneObjectCache.getCacheForObject(date);\n        const calendarDate = this.helper.temporalToCalendarDate(date, cache);\n        return calendarDate.month;\n    },\n    day(date) {\n        const cache = OneObjectCache.getCacheForObject(date);\n        const calendarDate = this.helper.temporalToCalendarDate(date, cache);\n        return calendarDate.day;\n    },\n    era(date) {\n        if (!this.helper.hasEra)\n            return undefined;\n        const cache = OneObjectCache.getCacheForObject(date);\n        const calendarDate = this.helper.temporalToCalendarDate(date, cache);\n        return calendarDate.era;\n    },\n    eraYear(date) {\n        if (!this.helper.hasEra)\n            return undefined;\n        const cache = OneObjectCache.getCacheForObject(date);\n        const calendarDate = this.helper.temporalToCalendarDate(date, cache);\n        return calendarDate.eraYear;\n    },\n    monthCode(date) {\n        const cache = OneObjectCache.getCacheForObject(date);\n        const calendarDate = this.helper.temporalToCalendarDate(date, cache);\n        return calendarDate.monthCode;\n    },\n    dayOfWeek(date) {\n        return impl['iso8601'].dayOfWeek(date);\n    },\n    dayOfYear(date) {\n        const cache = OneObjectCache.getCacheForObject(date);\n        const calendarDate = this.helper.isoToCalendarDate(date, cache);\n        const startOfYear = this.helper.startOfCalendarYear(calendarDate);\n        const diffDays = this.helper.calendarDaysUntil(startOfYear, calendarDate, cache);\n        return diffDays + 1;\n    },\n    weekOfYear(date) {\n        return impl['iso8601'].weekOfYear(date);\n    },\n    daysInWeek(date) {\n        return impl['iso8601'].daysInWeek(date);\n    },\n    daysInMonth(date) {\n        const cache = OneObjectCache.getCacheForObject(date);\n        const calendarDate = this.helper.temporalToCalendarDate(date, cache);\n        // Easy case: if the helper knows the length without any heavy calculation.\n        const max = this.helper.maximumMonthLength(calendarDate);\n        const min = this.helper.minimumMonthLength(calendarDate);\n        if (max === min)\n            return max;\n        // The harder case is where months vary every year, e.g. islamic calendars.\n        // Find the answer by calculating the difference in days between the first\n        // day of the current month and the first day of the next month.\n        const startOfMonthCalendar = this.helper.startOfCalendarMonth(calendarDate);\n        const startOfNextMonthCalendar = this.helper.addMonthsCalendar(startOfMonthCalendar, 1, 'constrain', cache);\n        const result = this.helper.calendarDaysUntil(startOfMonthCalendar, startOfNextMonthCalendar, cache);\n        return result;\n    },\n    daysInYear(dateParam) {\n        let date = dateParam;\n        if (!HasSlot(date, ISO_YEAR))\n            date = ToTemporalDate(date);\n        const cache = OneObjectCache.getCacheForObject(date);\n        const calendarDate = this.helper.temporalToCalendarDate(date, cache);\n        const startOfYearCalendar = this.helper.startOfCalendarYear(calendarDate);\n        const startOfNextYearCalendar = this.helper.addCalendar(startOfYearCalendar, { years: 1 }, 'constrain', cache);\n        const result = this.helper.calendarDaysUntil(startOfYearCalendar, startOfNextYearCalendar, cache);\n        return result;\n    },\n    monthsInYear(date) {\n        const cache = OneObjectCache.getCacheForObject(date);\n        const calendarDate = this.helper.temporalToCalendarDate(date, cache);\n        const result = this.helper.monthsInYear(calendarDate, cache);\n        return result;\n    },\n    inLeapYear(dateParam) {\n        let date = dateParam;\n        if (!HasSlot(date, ISO_YEAR))\n            date = ToTemporalDate(date);\n        const cache = OneObjectCache.getCacheForObject(date);\n        const calendarDate = this.helper.temporalToCalendarDate(date, cache);\n        const result = this.helper.inLeapYear(calendarDate, cache);\n        return result;\n    }\n};\nfor (const Helper of [\n    HebrewHelper,\n    PersianHelper,\n    EthiopicHelper,\n    EthioaaHelper,\n    CopticHelper,\n    ChineseHelper,\n    DangiHelper,\n    RocHelper,\n    IndianHelper,\n    BuddhistHelper,\n    GregoryHelper,\n    JapaneseHelper,\n    IslamicHelper,\n    IslamicUmalquraHelper,\n    IslamicTblaHelper,\n    IslamicCivilHelper,\n    IslamicRgsaHelper,\n    IslamicCcHelper\n]) {\n    const helper = new Helper();\n    // Clone the singleton non-ISO implementation that's the same for all\n    // calendars. The `helper` property contains per-calendar logic.\n    impl[helper.id] = { ...nonIsoImpl, helper };\n}\nconst BUILTIN_CALENDAR_IDS = Object.keys(impl);\nfunction IsBuiltinCalendar(id) {\n    return ArrayIncludes.call(BUILTIN_CALENDAR_IDS, id);\n}\n\nconst tzComponent = /\\.[-A-Za-z_]|\\.\\.[-A-Za-z._]{1,12}|\\.[-A-Za-z_][-A-Za-z._]{0,12}|[A-Za-z_][-A-Za-z._]{0,13}/;\nconst offsetNoCapture = /(?:[+\\u2212-][0-2][0-9](?::?[0-5][0-9](?::?[0-5][0-9](?:[.,]\\d{1,9})?)?)?)/;\nconst timeZoneID = new RegExp(`(?:(?:${tzComponent.source})(?:\\\\/(?:${tzComponent.source}))*|Etc/GMT[-+]\\\\d{1,2}|${offsetNoCapture.source})`);\nconst calComponent = /[A-Za-z0-9]{3,8}/;\nconst calendarID = new RegExp(`(?:${calComponent.source}(?:-${calComponent.source})*)`);\nconst yearpart = /(?:[+\\u2212-]\\d{6}|\\d{4})/;\nconst monthpart = /(?:0[1-9]|1[0-2])/;\nconst daypart = /(?:0[1-9]|[12]\\d|3[01])/;\nconst datesplit = new RegExp(`(${yearpart.source})(?:-(${monthpart.source})-(${daypart.source})|(${monthpart.source})(${daypart.source}))`);\nconst timesplit = /(\\d{2})(?::(\\d{2})(?::(\\d{2})(?:[.,](\\d{1,9}))?)?|(\\d{2})(?:(\\d{2})(?:[.,](\\d{1,9}))?)?)?/;\nconst offset = /([+\\u2212-])([01][0-9]|2[0-3])(?::?([0-5][0-9])(?::?([0-5][0-9])(?:[.,](\\d{1,9}))?)?)?/;\nconst zonesplit = new RegExp(`(?:([zZ])|(?:${offset.source})?)(?:\\\\[(${timeZoneID.source})\\\\])?`);\nconst calendar = new RegExp(`\\\\[u-ca=(${calendarID.source})\\\\]`);\nconst zoneddatetime = new RegExp(`^${datesplit.source}(?:(?:T|\\\\s+)${timesplit.source})?${zonesplit.source}(?:${calendar.source})?$`, 'i');\nconst time = new RegExp(`^T?${timesplit.source}(?:${zonesplit.source})?(?:${calendar.source})?$`, 'i');\n// The short forms of YearMonth and MonthDay are only for the ISO calendar.\n// Non-ISO calendar YearMonth and MonthDay have to parse as a Temporal.PlainDate,\n// with the reference fields.\n// YYYYMM forbidden by ISO 8601 because ambiguous with YYMMDD, but allowed by\n// RFC 3339 and we don't allow 2-digit years, so we allow it.\n// Not ambiguous with HHMMSS because that requires a 'T' prefix\nconst yearmonth = new RegExp(`^(${yearpart.source})-?(${monthpart.source})$`);\nconst monthday = new RegExp(`^(?:--)?(${monthpart.source})-?(${daypart.source})$`);\nconst fraction = /(\\d+)(?:[.,](\\d{1,9}))?/;\nconst durationDate = /(?:(\\d+)Y)?(?:(\\d+)M)?(?:(\\d+)W)?(?:(\\d+)D)?/;\nconst durationTime = new RegExp(`(?:${fraction.source}H)?(?:${fraction.source}M)?(?:${fraction.source}S)?`);\nconst duration = new RegExp(`^([+\\u2212-])?P${durationDate.source}(?:T(?!$)${durationTime.source})?$`, 'i');\n\nconst ArrayPrototypePush$1 = Array.prototype.push;\nconst IntlDateTimeFormat$1 = globalThis.Intl.DateTimeFormat;\nconst MathMin = Math.min;\nconst MathMax = Math.max;\nconst MathAbs = Math.abs;\nconst MathFloor = Math.floor;\nconst MathSign = Math.sign;\nconst MathTrunc = Math.trunc;\nconst NumberIsNaN = Number.isNaN;\nconst NumberIsFinite = Number.isFinite;\nconst NumberCtor = Number;\nconst StringCtor = String;\nconst NumberMaxSafeInteger = Number.MAX_SAFE_INTEGER;\nconst ObjectCreate$2 = Object.create;\nconst ObjectDefineProperty = Object.defineProperty;\nconst ObjectIs = Object.is;\nconst ReflectApply$1 = Reflect.apply;\nconst ZERO = jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(0);\nconst ONE = jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(1);\nconst SIXTY = jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(60);\nconst THOUSAND = jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(1e3);\nconst MILLION = jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(1e6);\nconst BILLION = jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(1e9);\nconst NEGATIVE_ONE = jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(-1);\nconst DAY_SECONDS = 86400;\nconst DAY_NANOS = jsbi__WEBPACK_IMPORTED_MODULE_0__.multiply(jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(DAY_SECONDS), BILLION);\nconst NS_MIN = jsbi__WEBPACK_IMPORTED_MODULE_0__.multiply(jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(-86400), jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(1e17));\nconst NS_MAX = jsbi__WEBPACK_IMPORTED_MODULE_0__.multiply(jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(86400), jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(1e17));\nconst YEAR_MIN = -271821;\nconst YEAR_MAX = 275760;\nconst BEFORE_FIRST_OFFSET_TRANSITION = jsbi__WEBPACK_IMPORTED_MODULE_0__.multiply(jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(-388152), jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(1e13)); // 1847-01-01T00:00:00Z\nconst ABOUT_TEN_YEARS_NANOS = jsbi__WEBPACK_IMPORTED_MODULE_0__.multiply(DAY_NANOS, jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(366 * 10));\nconst ABOUT_ONE_YEAR_NANOS = jsbi__WEBPACK_IMPORTED_MODULE_0__.multiply(DAY_NANOS, jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(366 * 1));\nconst TWO_WEEKS_NANOS = jsbi__WEBPACK_IMPORTED_MODULE_0__.multiply(DAY_NANOS, jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(2 * 7));\nfunction IsInteger(value) {\n    if (typeof value !== 'number' || !NumberIsFinite(value))\n        return false;\n    const abs = MathAbs(value);\n    return MathFloor(abs) === abs;\n}\nfunction IsObject(value) {\n    return (typeof value === 'object' && value !== null) || typeof value === 'function';\n}\nfunction ToNumber(value) {\n    if (typeof value === 'bigint')\n        throw new TypeError('Cannot convert BigInt to number');\n    return NumberCtor(value);\n}\nfunction ToInteger(value) {\n    const num = ToNumber(value);\n    if (NumberIsNaN(num))\n        return 0;\n    const integer = MathTrunc(num);\n    if (num === 0)\n        return 0;\n    return integer;\n}\nfunction ToString(value) {\n    if (typeof value === 'symbol') {\n        throw new TypeError('Cannot convert a Symbol value to a String');\n    }\n    return StringCtor(value);\n}\nfunction ToIntegerThrowOnInfinity(value) {\n    const integer = ToInteger(value);\n    if (!NumberIsFinite(integer)) {\n        throw new RangeError('infinity is out of range');\n    }\n    return integer;\n}\nfunction ToPositiveInteger(valueParam, property) {\n    const value = ToInteger(valueParam);\n    if (!NumberIsFinite(value)) {\n        throw new RangeError('infinity is out of range');\n    }\n    if (value < 1) {\n        if (property !== undefined) {\n            throw new RangeError(`property '${property}' cannot be a a number less than one`);\n        }\n        throw new RangeError('Cannot convert a number less than one to a positive integer');\n    }\n    return value;\n}\nfunction ToIntegerWithoutRounding(valueParam) {\n    const value = ToNumber(valueParam);\n    if (NumberIsNaN(value))\n        return 0;\n    if (!NumberIsFinite(value)) {\n        throw new RangeError('infinity is out of range');\n    }\n    if (!IsInteger(value)) {\n        throw new RangeError(`unsupported fractional value ${value}`);\n    }\n    return ToInteger(value); // (value) in spec text; converts -0 to 0\n}\nfunction divmod(x, y) {\n    const quotient = jsbi__WEBPACK_IMPORTED_MODULE_0__.divide(x, y);\n    const remainder = jsbi__WEBPACK_IMPORTED_MODULE_0__.remainder(x, y);\n    return { quotient, remainder };\n}\nfunction abs(x) {\n    if (jsbi__WEBPACK_IMPORTED_MODULE_0__.lessThan(x, ZERO))\n        return jsbi__WEBPACK_IMPORTED_MODULE_0__.multiply(x, NEGATIVE_ONE);\n    return x;\n}\nconst BUILTIN_CASTS = new Map([\n    ['year', ToIntegerThrowOnInfinity],\n    ['month', ToPositiveInteger],\n    ['monthCode', ToString],\n    ['day', ToPositiveInteger],\n    ['hour', ToIntegerThrowOnInfinity],\n    ['minute', ToIntegerThrowOnInfinity],\n    ['second', ToIntegerThrowOnInfinity],\n    ['millisecond', ToIntegerThrowOnInfinity],\n    ['microsecond', ToIntegerThrowOnInfinity],\n    ['nanosecond', ToIntegerThrowOnInfinity],\n    ['years', ToIntegerWithoutRounding],\n    ['months', ToIntegerWithoutRounding],\n    ['weeks', ToIntegerWithoutRounding],\n    ['days', ToIntegerWithoutRounding],\n    ['hours', ToIntegerWithoutRounding],\n    ['minutes', ToIntegerWithoutRounding],\n    ['seconds', ToIntegerWithoutRounding],\n    ['milliseconds', ToIntegerWithoutRounding],\n    ['microseconds', ToIntegerWithoutRounding],\n    ['nanoseconds', ToIntegerWithoutRounding],\n    ['era', ToString],\n    ['eraYear', ToInteger],\n    ['offset', ToString]\n]);\nconst ALLOWED_UNITS = [\n    'year',\n    'month',\n    'week',\n    'day',\n    'hour',\n    'minute',\n    'second',\n    'millisecond',\n    'microsecond',\n    'nanosecond'\n];\nconst SINGULAR_PLURAL_UNITS = [\n    ['years', 'year'],\n    ['months', 'month'],\n    ['weeks', 'week'],\n    ['days', 'day'],\n    ['hours', 'hour'],\n    ['minutes', 'minute'],\n    ['seconds', 'second'],\n    ['milliseconds', 'millisecond'],\n    ['microseconds', 'microsecond'],\n    ['nanoseconds', 'nanosecond']\n];\nconst IntlDateTimeFormatEnUsCache = new Map();\nfunction getIntlDateTimeFormatEnUsForTimeZone(timeZoneIdentifier) {\n    let instance = IntlDateTimeFormatEnUsCache.get(timeZoneIdentifier);\n    if (instance === undefined) {\n        instance = new IntlDateTimeFormat$1('en-us', {\n            timeZone: StringCtor(timeZoneIdentifier),\n            hour12: false,\n            era: 'short',\n            year: 'numeric',\n            month: 'numeric',\n            day: 'numeric',\n            hour: 'numeric',\n            minute: 'numeric',\n            second: 'numeric'\n        });\n        IntlDateTimeFormatEnUsCache.set(timeZoneIdentifier, instance);\n    }\n    return instance;\n}\nfunction IsTemporalInstant(item) {\n    return HasSlot(item, EPOCHNANOSECONDS) && !HasSlot(item, TIME_ZONE, CALENDAR);\n}\nfunction IsTemporalTimeZone(item) {\n    return HasSlot(item, TIMEZONE_ID);\n}\nfunction IsTemporalCalendar(item) {\n    return HasSlot(item, CALENDAR_ID);\n}\nfunction IsTemporalDuration(item) {\n    return HasSlot(item, YEARS, MONTHS, DAYS, HOURS, MINUTES, SECONDS, MILLISECONDS, MICROSECONDS, NANOSECONDS);\n}\nfunction IsTemporalDate(item) {\n    return HasSlot(item, DATE_BRAND);\n}\nfunction IsTemporalTime(item) {\n    return (HasSlot(item, ISO_HOUR, ISO_MINUTE, ISO_SECOND, ISO_MILLISECOND, ISO_MICROSECOND, ISO_NANOSECOND) &&\n        !HasSlot(item, ISO_YEAR, ISO_MONTH, ISO_DAY));\n}\nfunction IsTemporalDateTime(item) {\n    return HasSlot(item, ISO_YEAR, ISO_MONTH, ISO_DAY, ISO_HOUR, ISO_MINUTE, ISO_SECOND, ISO_MILLISECOND, ISO_MICROSECOND, ISO_NANOSECOND);\n}\nfunction IsTemporalYearMonth(item) {\n    return HasSlot(item, YEAR_MONTH_BRAND);\n}\nfunction IsTemporalMonthDay(item) {\n    return HasSlot(item, MONTH_DAY_BRAND);\n}\nfunction IsTemporalZonedDateTime(item) {\n    return HasSlot(item, EPOCHNANOSECONDS, TIME_ZONE, CALENDAR);\n}\nfunction RejectObjectWithCalendarOrTimeZone(item) {\n    if (HasSlot(item, CALENDAR) || HasSlot(item, TIME_ZONE)) {\n        throw new TypeError('with() does not support a calendar or timeZone property');\n    }\n    if (item.calendar !== undefined) {\n        throw new TypeError('with() does not support a calendar property');\n    }\n    if (item.timeZone !== undefined) {\n        throw new TypeError('with() does not support a timeZone property');\n    }\n}\nfunction ParseTemporalTimeZone(stringIdent) {\n    let { ianaName, offset, z } = ParseTemporalTimeZoneString(stringIdent);\n    if (ianaName)\n        return ianaName;\n    if (z)\n        return 'UTC';\n    return offset; // if !ianaName && !z then offset must be present\n}\nfunction FormatCalendarAnnotation(id, showCalendar) {\n    if (showCalendar === 'never')\n        return '';\n    if (showCalendar === 'auto' && id === 'iso8601')\n        return '';\n    return `[u-ca=${id}]`;\n}\nfunction ParseISODateTime(isoString) {\n    // ZDT is the superset of fields for every other Temporal type\n    const match = zoneddatetime.exec(isoString);\n    if (!match)\n        throw new RangeError(`invalid ISO 8601 string: ${isoString}`);\n    let yearString = match[1];\n    if (yearString[0] === '\\u2212')\n        yearString = `-${yearString.slice(1)}`;\n    if (yearString === '-000000')\n        throw new RangeError(`invalid ISO 8601 string: ${isoString}`);\n    const year = ToInteger(yearString);\n    const month = ToInteger(match[2] || match[4]);\n    const day = ToInteger(match[3] || match[5]);\n    const hour = ToInteger(match[6]);\n    const hasTime = match[6] !== undefined;\n    const minute = ToInteger(match[7] || match[10]);\n    let second = ToInteger(match[8] || match[11]);\n    if (second === 60)\n        second = 59;\n    const fraction = (match[9] || match[12]) + '000000000';\n    const millisecond = ToInteger(fraction.slice(0, 3));\n    const microsecond = ToInteger(fraction.slice(3, 6));\n    const nanosecond = ToInteger(fraction.slice(6, 9));\n    let offset;\n    let z = false;\n    if (match[13]) {\n        offset = undefined;\n        z = true;\n    }\n    else if (match[14] && match[15]) {\n        const offsetSign = match[14] === '-' || match[14] === '\\u2212' ? '-' : '+';\n        const offsetHours = match[15] || '00';\n        const offsetMinutes = match[16] || '00';\n        const offsetSeconds = match[17] || '00';\n        let offsetFraction = match[18] || '0';\n        offset = `${offsetSign}${offsetHours}:${offsetMinutes}`;\n        if (+offsetFraction) {\n            while (offsetFraction.endsWith('0'))\n                offsetFraction = offsetFraction.slice(0, -1);\n            offset += `:${offsetSeconds}.${offsetFraction}`;\n        }\n        else if (+offsetSeconds) {\n            offset += `:${offsetSeconds}`;\n        }\n        if (offset === '-00:00')\n            offset = '+00:00';\n    }\n    let ianaName = match[19];\n    if (ianaName) {\n        try {\n            // Canonicalize name if it is an IANA link name or is capitalized wrong\n            ianaName = GetCanonicalTimeZoneIdentifier(ianaName).toString();\n        }\n        catch {\n            // Not an IANA name, may be a custom ID, pass through unchanged\n        }\n    }\n    const calendar = match[20];\n    return {\n        year,\n        month,\n        day,\n        hasTime,\n        hour,\n        minute,\n        second,\n        millisecond,\n        microsecond,\n        nanosecond,\n        ianaName,\n        offset,\n        z,\n        calendar\n    };\n}\nfunction ParseTemporalInstantString(isoString) {\n    const result = ParseISODateTime(isoString);\n    if (!result.z && !result.offset)\n        throw new RangeError('Temporal.Instant requires a time zone offset');\n    return result;\n}\nfunction ParseTemporalZonedDateTimeString(isoString) {\n    const result = ParseISODateTime(isoString);\n    if (!result.ianaName)\n        throw new RangeError('Temporal.ZonedDateTime requires a time zone ID in brackets');\n    return result;\n}\nfunction ParseTemporalDateTimeString(isoString) {\n    return ParseISODateTime(isoString);\n}\nfunction ParseTemporalDateString(isoString) {\n    return ParseISODateTime(isoString);\n}\nfunction ParseTemporalTimeString(isoString) {\n    const match = time.exec(isoString);\n    let hour, minute, second, millisecond, microsecond, nanosecond, calendar;\n    if (match) {\n        hour = ToInteger(match[1]);\n        minute = ToInteger(match[2] || match[5]);\n        second = ToInteger(match[3] || match[6]);\n        if (second === 60)\n            second = 59;\n        const fraction = (match[4] || match[7]) + '000000000';\n        millisecond = ToInteger(fraction.slice(0, 3));\n        microsecond = ToInteger(fraction.slice(3, 6));\n        nanosecond = ToInteger(fraction.slice(6, 9));\n        calendar = match[15];\n    }\n    else {\n        let z, hasTime;\n        ({ hasTime, hour, minute, second, millisecond, microsecond, nanosecond, calendar, z } =\n            ParseISODateTime(isoString));\n        if (!hasTime)\n            throw new RangeError(`time is missing in string: ${isoString}`);\n        if (z)\n            throw new RangeError('Z designator not supported for PlainTime');\n    }\n    // if it's a date-time string, OK\n    if (/[tT ][0-9][0-9]/.test(isoString)) {\n        return { hour, minute, second, millisecond, microsecond, nanosecond, calendar };\n    }\n    // slow but non-grammar-dependent way to ensure that time-only strings that\n    // are also valid PlainMonthDay and PlainYearMonth throw. corresponds to\n    // assertion in spec text\n    try {\n        const { month, day } = ParseTemporalMonthDayString(isoString);\n        RejectISODate(1972, month, day);\n    }\n    catch {\n        try {\n            const { year, month } = ParseTemporalYearMonthString(isoString);\n            RejectISODate(year, month, 1);\n        }\n        catch {\n            return { hour, minute, second, millisecond, microsecond, nanosecond, calendar };\n        }\n    }\n    throw new RangeError(`invalid ISO 8601 time-only string ${isoString}; may need a T prefix`);\n}\nfunction ParseTemporalYearMonthString(isoString) {\n    const match = yearmonth.exec(isoString);\n    let year, month, calendar, referenceISODay;\n    if (match) {\n        let yearString = match[1];\n        if (yearString[0] === '\\u2212')\n            yearString = `-${yearString.slice(1)}`;\n        if (yearString === '-000000')\n            throw new RangeError(`invalid ISO 8601 string: ${isoString}`);\n        year = ToInteger(yearString);\n        month = ToInteger(match[2]);\n        calendar = match[3];\n    }\n    else {\n        let z;\n        ({ year, month, calendar, day: referenceISODay, z } = ParseISODateTime(isoString));\n        if (z)\n            throw new RangeError('Z designator not supported for PlainYearMonth');\n    }\n    return { year, month, calendar, referenceISODay };\n}\nfunction ParseTemporalMonthDayString(isoString) {\n    const match = monthday.exec(isoString);\n    let month, day, calendar, referenceISOYear;\n    if (match) {\n        month = ToInteger(match[1]);\n        day = ToInteger(match[2]);\n    }\n    else {\n        let z;\n        ({ month, day, calendar, year: referenceISOYear, z } = ParseISODateTime(isoString));\n        if (z)\n            throw new RangeError('Z designator not supported for PlainMonthDay');\n    }\n    return { month, day, calendar, referenceISOYear };\n}\nfunction ParseTemporalTimeZoneString(stringIdent) {\n    try {\n        let canonicalIdent = GetCanonicalTimeZoneIdentifier(stringIdent);\n        if (canonicalIdent) {\n            canonicalIdent = canonicalIdent.toString();\n            if (TestTimeZoneOffsetString(canonicalIdent))\n                return { offset: canonicalIdent };\n            return { ianaName: canonicalIdent };\n        }\n    }\n    catch {\n        // fall through\n    }\n    try {\n        // Try parsing ISO string instead\n        const result = ParseISODateTime(stringIdent);\n        if (result.z || result.offset || result.ianaName) {\n            return result;\n        }\n    }\n    catch {\n        // fall through\n    }\n    throw new RangeError(`Invalid time zone: ${stringIdent}`);\n}\nfunction ParseTemporalDurationString(isoString) {\n    const match = duration.exec(isoString);\n    if (!match)\n        throw new RangeError(`invalid duration: ${isoString}`);\n    if (match.slice(2).every((element) => element === undefined)) {\n        throw new RangeError(`invalid duration: ${isoString}`);\n    }\n    const sign = match[1] === '-' || match[1] === '\\u2212' ? -1 : 1;\n    const years = ToInteger(match[2]) * sign;\n    const months = ToInteger(match[3]) * sign;\n    const weeks = ToInteger(match[4]) * sign;\n    const days = ToInteger(match[5]) * sign;\n    const hours = ToInteger(match[6]) * sign;\n    let fHours = match[7];\n    let minutes = ToInteger(match[8]) * sign;\n    let fMinutes = match[9];\n    let seconds = ToInteger(match[10]) * sign;\n    const fSeconds = match[11] + '000000000';\n    let milliseconds = ToInteger(fSeconds.slice(0, 3)) * sign;\n    let microseconds = ToInteger(fSeconds.slice(3, 6)) * sign;\n    let nanoseconds = ToInteger(fSeconds.slice(6, 9)) * sign;\n    fHours = fHours ? (sign * ToInteger(fHours)) / 10 ** fHours.length : 0;\n    fMinutes = fMinutes ? (sign * ToInteger(fMinutes)) / 10 ** fMinutes.length : 0;\n    ({ minutes, seconds, milliseconds, microseconds, nanoseconds } = DurationHandleFractions(fHours, minutes, fMinutes, seconds, milliseconds, microseconds, nanoseconds));\n    return { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds };\n}\nfunction ParseTemporalInstant(isoString) {\n    const { year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, offset, z } = ParseTemporalInstantString(isoString);\n    const epochNs = GetEpochFromISOParts(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond);\n    if (epochNs === null)\n        throw new RangeError('DateTime outside of supported range');\n    const offsetNs = z ? 0 : ParseTimeZoneOffsetString(offset);\n    return jsbi__WEBPACK_IMPORTED_MODULE_0__.subtract(epochNs, jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(offsetNs));\n}\nfunction RegulateISODate(yearParam, monthParam, dayParam, overflow) {\n    let year = yearParam;\n    let month = monthParam;\n    let day = dayParam;\n    switch (overflow) {\n        case 'reject':\n            RejectISODate(year, month, day);\n            break;\n        case 'constrain':\n            ({ year, month, day } = ConstrainISODate(year, month, day));\n            break;\n    }\n    return { year, month, day };\n}\nfunction RegulateTime(hourParam, minuteParam, secondParam, millisecondParam, microsecondParam, nanosecondParam, overflow) {\n    let hour = hourParam;\n    let minute = minuteParam;\n    let second = secondParam;\n    let millisecond = millisecondParam;\n    let microsecond = microsecondParam;\n    let nanosecond = nanosecondParam;\n    switch (overflow) {\n        case 'reject':\n            RejectTime(hour, minute, second, millisecond, microsecond, nanosecond);\n            break;\n        case 'constrain':\n            ({ hour, minute, second, millisecond, microsecond, nanosecond } = ConstrainTime(hour, minute, second, millisecond, microsecond, nanosecond));\n            break;\n    }\n    return { hour, minute, second, millisecond, microsecond, nanosecond };\n}\nfunction RegulateISOYearMonth(yearParam, monthParam, overflow) {\n    let year = yearParam;\n    let month = monthParam;\n    const referenceISODay = 1;\n    switch (overflow) {\n        case 'reject':\n            RejectISODate(year, month, referenceISODay);\n            break;\n        case 'constrain':\n            ({ year, month } = ConstrainISODate(year, month));\n            break;\n    }\n    return { year, month };\n}\nfunction DurationHandleFractions(fHoursParam, minutesParam, fMinutesParam, secondsParam, millisecondsParam, microsecondsParam, nanosecondsParam) {\n    let fHours = fHoursParam;\n    let minutes = minutesParam;\n    let fMinutes = fMinutesParam;\n    let seconds = secondsParam;\n    let milliseconds = millisecondsParam;\n    let microseconds = microsecondsParam;\n    let nanoseconds = nanosecondsParam;\n    if (fHours !== 0) {\n        [minutes, fMinutes, seconds, milliseconds, microseconds, nanoseconds].forEach((val) => {\n            if (val !== 0)\n                throw new RangeError('only the smallest unit can be fractional');\n        });\n        const mins = fHours * 60;\n        minutes = MathTrunc(mins);\n        fMinutes = mins % 1;\n    }\n    if (fMinutes !== 0) {\n        [seconds, milliseconds, microseconds, nanoseconds].forEach((val) => {\n            if (val !== 0)\n                throw new RangeError('only the smallest unit can be fractional');\n        });\n        const secs = fMinutes * 60;\n        seconds = MathTrunc(secs);\n        const fSeconds = secs % 1;\n        if (fSeconds !== 0) {\n            const mils = fSeconds * 1000;\n            milliseconds = MathTrunc(mils);\n            const fMilliseconds = mils % 1;\n            if (fMilliseconds !== 0) {\n                const mics = fMilliseconds * 1000;\n                microseconds = MathTrunc(mics);\n                const fMicroseconds = mics % 1;\n                if (fMicroseconds !== 0) {\n                    const nans = fMicroseconds * 1000;\n                    nanoseconds = MathTrunc(nans);\n                }\n            }\n        }\n    }\n    return { minutes, seconds, milliseconds, microseconds, nanoseconds };\n}\nfunction ToTemporalDurationRecord(item) {\n    if (IsTemporalDuration(item)) {\n        return {\n            years: GetSlot(item, YEARS),\n            months: GetSlot(item, MONTHS),\n            weeks: GetSlot(item, WEEKS),\n            days: GetSlot(item, DAYS),\n            hours: GetSlot(item, HOURS),\n            minutes: GetSlot(item, MINUTES),\n            seconds: GetSlot(item, SECONDS),\n            milliseconds: GetSlot(item, MILLISECONDS),\n            microseconds: GetSlot(item, MICROSECONDS),\n            nanoseconds: GetSlot(item, NANOSECONDS)\n        };\n    }\n    const props = ToPartialRecord(item, [\n        'days',\n        'hours',\n        'microseconds',\n        'milliseconds',\n        'minutes',\n        'months',\n        'nanoseconds',\n        'seconds',\n        'weeks',\n        'years'\n    ]);\n    if (!props)\n        throw new TypeError('invalid duration-like');\n    const { years = 0, months = 0, weeks = 0, days = 0, hours = 0, minutes = 0, seconds = 0, milliseconds = 0, microseconds = 0, nanoseconds = 0 } = props;\n    return { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds };\n}\nfunction ToLimitedTemporalDuration(item, disallowedProperties = []) {\n    let record;\n    if (IsObject(item)) {\n        record = ToTemporalDurationRecord(item);\n    }\n    else {\n        const str = ToString(item);\n        record = ParseTemporalDurationString(str);\n    }\n    const { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = record;\n    RejectDuration(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n    for (const property of disallowedProperties) {\n        if (record[property] !== 0) {\n            throw new RangeError(`Duration field ${property} not supported by Temporal.Instant. Try Temporal.ZonedDateTime instead.`);\n        }\n    }\n    return record;\n}\nfunction ToTemporalOverflow(options) {\n    return GetOption(options, 'overflow', ['constrain', 'reject'], 'constrain');\n}\nfunction ToTemporalDisambiguation(options) {\n    return GetOption(options, 'disambiguation', ['compatible', 'earlier', 'later', 'reject'], 'compatible');\n}\nfunction ToTemporalRoundingMode(options, fallback) {\n    return GetOption(options, 'roundingMode', ['ceil', 'floor', 'trunc', 'halfExpand'], fallback);\n}\nfunction NegateTemporalRoundingMode(roundingMode) {\n    switch (roundingMode) {\n        case 'ceil':\n            return 'floor';\n        case 'floor':\n            return 'ceil';\n        default:\n            return roundingMode;\n    }\n}\nfunction ToTemporalOffset(options, fallback) {\n    return GetOption(options, 'offset', ['prefer', 'use', 'ignore', 'reject'], fallback);\n}\nfunction ToShowCalendarOption(options) {\n    return GetOption(options, 'calendarName', ['auto', 'always', 'never'], 'auto');\n}\nfunction ToShowTimeZoneNameOption(options) {\n    return GetOption(options, 'timeZoneName', ['auto', 'never'], 'auto');\n}\nfunction ToShowOffsetOption(options) {\n    return GetOption(options, 'offset', ['auto', 'never'], 'auto');\n}\nfunction ToTemporalRoundingIncrement(options, dividend, inclusive) {\n    let maximum = Infinity;\n    if (dividend !== undefined)\n        maximum = dividend;\n    if (!inclusive && dividend !== undefined)\n        maximum = dividend > 1 ? dividend - 1 : 1;\n    const increment = GetNumberOption(options, 'roundingIncrement', 1, maximum, 1);\n    if (dividend !== undefined && dividend % increment !== 0) {\n        throw new RangeError(`Rounding increment must divide evenly into ${dividend}`);\n    }\n    return increment;\n}\nfunction ToTemporalDateTimeRoundingIncrement(options, smallestUnit) {\n    const maximumIncrements = {\n        year: undefined,\n        month: undefined,\n        week: undefined,\n        day: undefined,\n        hour: 24,\n        minute: 60,\n        second: 60,\n        millisecond: 1000,\n        microsecond: 1000,\n        nanosecond: 1000\n    };\n    return ToTemporalRoundingIncrement(options, maximumIncrements[smallestUnit], false);\n}\nfunction ToSecondsStringPrecision(options) {\n    const smallestUnit = ToSmallestTemporalUnit(options, undefined, ['year', 'month', 'week', 'day', 'hour']);\n    switch (smallestUnit) {\n        case 'minute':\n            return { precision: 'minute', unit: 'minute', increment: 1 };\n        case 'second':\n            return { precision: 0, unit: 'second', increment: 1 };\n        case 'millisecond':\n            return { precision: 3, unit: 'millisecond', increment: 1 };\n        case 'microsecond':\n            return { precision: 6, unit: 'microsecond', increment: 1 };\n        case 'nanosecond':\n            return { precision: 9, unit: 'nanosecond', increment: 1 };\n    }\n    let digits = options.fractionalSecondDigits;\n    if (digits === undefined)\n        digits = 'auto';\n    if (typeof digits !== 'number') {\n        const stringDigits = ToString(digits);\n        if (stringDigits === 'auto')\n            return { precision: 'auto', unit: 'nanosecond', increment: 1 };\n        throw new RangeError(`fractionalSecondDigits must be 'auto' or 0 through 9, not ${stringDigits}`);\n    }\n    if (NumberIsNaN(digits) || digits < 0 || digits > 9) {\n        throw new RangeError(`fractionalSecondDigits must be 'auto' or 0 through 9, not ${digits}`);\n    }\n    const precision = MathFloor(digits);\n    switch (precision) {\n        case 0:\n            return { precision, unit: 'second', increment: 1 };\n        case 1:\n        case 2:\n        case 3:\n            return { precision, unit: 'millisecond', increment: 10 ** (3 - precision) };\n        case 4:\n        case 5:\n        case 6:\n            return { precision, unit: 'microsecond', increment: 10 ** (6 - precision) };\n        case 7:\n        case 8:\n        case 9:\n            return { precision, unit: 'nanosecond', increment: 10 ** (9 - precision) };\n        default:\n            throw new RangeError(`fractionalSecondDigits must be 'auto' or 0 through 9, not ${digits}`);\n    }\n}\nfunction ToLargestTemporalUnit(options, fallback, disallowedStrings = [], autoValue) {\n    const singular = new Map(SINGULAR_PLURAL_UNITS.filter(([, sing]) => !disallowedStrings.includes(sing)));\n    const allowed = new Set(ALLOWED_UNITS);\n    for (const s of disallowedStrings) {\n        allowed.delete(s);\n    }\n    const retval = GetOption(options, 'largestUnit', ['auto', ...allowed, ...singular.keys()], fallback);\n    if (retval === 'auto' && autoValue !== undefined)\n        return autoValue;\n    if (singular.has(retval)) {\n        return singular.get(retval);\n    }\n    return retval;\n}\nfunction ToSmallestTemporalUnit(options, fallback, disallowedStrings = []) {\n    const singular = new Map(SINGULAR_PLURAL_UNITS.filter(([, sing]) => !disallowedStrings.includes(sing)));\n    const allowed = new Set(ALLOWED_UNITS);\n    for (const s of disallowedStrings) {\n        allowed.delete(s);\n    }\n    const value = GetOption(options, 'smallestUnit', [...allowed, ...singular.keys()], fallback);\n    if (singular.has(value)) {\n        return singular.get(value);\n    }\n    return value;\n}\nfunction ToTemporalDurationTotalUnit(options) {\n    // This AO is identical to ToSmallestTemporalUnit, except:\n    // - default is always `undefined` (caller will throw if omitted)\n    // - option is named `unit` (not `smallestUnit`)\n    // - all units are valid (no `disallowedStrings`)\n    const singular = new Map(SINGULAR_PLURAL_UNITS);\n    const value = GetOption(options, 'unit', [...singular.values(), ...singular.keys()], undefined);\n    if (singular.has(value)) {\n        return singular.get(value);\n    }\n    return value;\n}\nfunction ToRelativeTemporalObject(options) {\n    const relativeTo = options.relativeTo;\n    if (relativeTo === undefined)\n        return relativeTo;\n    let offsetBehaviour = 'option';\n    let matchMinutes = false;\n    let year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar, timeZone, offset;\n    if (IsObject(relativeTo)) {\n        if (IsTemporalZonedDateTime(relativeTo) || IsTemporalDate(relativeTo))\n            return relativeTo;\n        if (IsTemporalDateTime(relativeTo))\n            return TemporalDateTimeToDate(relativeTo);\n        calendar = GetTemporalCalendarWithISODefault(relativeTo);\n        const fieldNames = CalendarFields(calendar, [\n            'day',\n            'hour',\n            'microsecond',\n            'millisecond',\n            'minute',\n            'month',\n            'monthCode',\n            'nanosecond',\n            'second',\n            'year'\n        ]);\n        const fields = ToTemporalDateTimeFields(relativeTo, fieldNames);\n        const dateOptions = ObjectCreate$2(null);\n        dateOptions.overflow = 'constrain';\n        ({ year, month, day, hour, minute, second, millisecond, microsecond, nanosecond } = InterpretTemporalDateTimeFields(calendar, fields, dateOptions));\n        // The `offset` and `timeZone` properties only exist on ZonedDateTime (or\n        // ZonedDateTimeLike-property bags). The assertions below are used to avoid\n        // TS errors while not diverging runtime code from proposal-temporal.\n        offset = relativeTo.offset;\n        if (offset === undefined)\n            offsetBehaviour = 'wall';\n        timeZone = relativeTo.timeZone;\n    }\n    else {\n        let ianaName, z;\n        ({ year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar, ianaName, offset, z } =\n            ParseISODateTime(ToString(relativeTo)));\n        if (ianaName)\n            timeZone = ianaName;\n        if (z) {\n            offsetBehaviour = 'exact';\n        }\n        else if (!offset) {\n            offsetBehaviour = 'wall';\n        }\n        if (!calendar)\n            calendar = GetISO8601Calendar();\n        calendar = ToTemporalCalendar(calendar);\n        matchMinutes = true;\n    }\n    if (timeZone) {\n        timeZone = ToTemporalTimeZone(timeZone);\n        let offsetNs = 0;\n        if (offsetBehaviour === 'option')\n            offsetNs = ParseTimeZoneOffsetString(ToString(offset));\n        const epochNanoseconds = InterpretISODateTimeOffset(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, offsetBehaviour, offsetNs, timeZone, 'compatible', 'reject', matchMinutes);\n        return CreateTemporalZonedDateTime(epochNanoseconds, timeZone, calendar);\n    }\n    return CreateTemporalDate(year, month, day, calendar);\n}\nfunction ValidateTemporalUnitRange(largestUnit, smallestUnit) {\n    if (ALLOWED_UNITS.indexOf(largestUnit) > ALLOWED_UNITS.indexOf(smallestUnit)) {\n        throw new RangeError(`largestUnit ${largestUnit} cannot be smaller than smallestUnit ${smallestUnit}`);\n    }\n}\nfunction DefaultTemporalLargestUnit(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds) {\n    const singular = new Map(SINGULAR_PLURAL_UNITS);\n    for (const [prop, v] of [\n        ['years', years],\n        ['months', months],\n        ['weeks', weeks],\n        ['days', days],\n        ['hours', hours],\n        ['minutes', minutes],\n        ['seconds', seconds],\n        ['milliseconds', milliseconds],\n        ['microseconds', microseconds],\n        ['nanoseconds', nanoseconds]\n    ]) {\n        if (v !== 0)\n            return singular.get(prop);\n    }\n    return 'nanosecond';\n}\nfunction LargerOfTwoTemporalUnits(unit1, unit2) {\n    if (ALLOWED_UNITS.indexOf(unit1) > ALLOWED_UNITS.indexOf(unit2))\n        return unit2;\n    return unit1;\n}\nfunction ToPartialRecord(bagParam, fieldsParam) {\n    // External callers are limited to specific types, but this function's\n    // implementation uses generic property types. The casts below (and at the\n    // end) convert to/from generic records.\n    const bag = bagParam;\n    const fields = fieldsParam;\n    let any = false;\n    let result = {};\n    for (const property of fields) {\n        const value = bag[property];\n        if (value !== undefined) {\n            any = true;\n            if (BUILTIN_CASTS.has(property)) {\n                result[property] = BUILTIN_CASTS.get(property)(value);\n            }\n            else {\n                result[property] = value;\n            }\n        }\n    }\n    return any ? result : false;\n}\nfunction PrepareTemporalFields(bagParam, fieldsParam) {\n    // External callers are limited to specific types, but this function's\n    // implementation uses generic property types. The casts below (and at the\n    // end) convert to/from generic records.\n    const bag = bagParam;\n    const fields = fieldsParam;\n    const result = {};\n    let any = false;\n    for (const fieldRecord of fields) {\n        const [property, defaultValue] = fieldRecord;\n        let value = bag[property];\n        if (value === undefined) {\n            if (fieldRecord.length === 1) {\n                throw new TypeError(`required property '${property}' missing or undefined`);\n            }\n            value = defaultValue;\n        }\n        else {\n            any = true;\n            if (BUILTIN_CASTS.has(property)) {\n                value = BUILTIN_CASTS.get(property)(value);\n            }\n        }\n        result[property] = value;\n    }\n    if (!any) {\n        throw new TypeError('no supported properties found');\n    }\n    if ((result['era'] === undefined) !==\n        (result['eraYear'] === undefined)) {\n        throw new RangeError(\"properties 'era' and 'eraYear' must be provided together\");\n    }\n    return result;\n}\n// field access in the following operations is intentionally alphabetical\nfunction ToTemporalDateFields(bag, fieldNames) {\n    const entries = [\n        ['day', undefined],\n        ['month', undefined],\n        ['monthCode', undefined],\n        ['year', undefined]\n    ];\n    // Add extra fields from the calendar at the end\n    fieldNames.forEach((fieldName) => {\n        if (!entries.some(([name]) => name === fieldName)) {\n            entries.push([fieldName, undefined]);\n        }\n    });\n    return PrepareTemporalFields(bag, entries);\n}\nfunction ToTemporalDateTimeFields(bag, fieldNames) {\n    const entries = [\n        ['day', undefined],\n        ['hour', 0],\n        ['microsecond', 0],\n        ['millisecond', 0],\n        ['minute', 0],\n        ['month', undefined],\n        ['monthCode', undefined],\n        ['nanosecond', 0],\n        ['second', 0],\n        ['year', undefined]\n    ];\n    // Add extra fields from the calendar at the end\n    fieldNames.forEach((fieldName) => {\n        if (!entries.some(([name]) => name === fieldName)) {\n            entries.push([fieldName, undefined]);\n        }\n    });\n    return PrepareTemporalFields(bag, entries);\n}\nfunction ToTemporalMonthDayFields(bag, fieldNames) {\n    const entries = [\n        ['day', undefined],\n        ['month', undefined],\n        ['monthCode', undefined],\n        ['year', undefined]\n    ];\n    // Add extra fields from the calendar at the end\n    fieldNames.forEach((fieldName) => {\n        if (!entries.some(([name]) => name === fieldName)) {\n            entries.push([fieldName, undefined]);\n        }\n    });\n    return PrepareTemporalFields(bag, entries);\n}\nfunction ToTemporalTimeRecord(bag) {\n    return PrepareTemporalFields(bag, [\n        ['hour', 0],\n        ['microsecond', 0],\n        ['millisecond', 0],\n        ['minute', 0],\n        ['nanosecond', 0],\n        ['second', 0]\n    ]);\n}\nfunction ToTemporalYearMonthFields(bag, fieldNames) {\n    const entries = [\n        ['month', undefined],\n        ['monthCode', undefined],\n        ['year', undefined]\n    ];\n    // Add extra fields from the calendar at the end\n    fieldNames.forEach((fieldName) => {\n        if (!entries.some(([name]) => name === fieldName)) {\n            entries.push([fieldName, undefined]);\n        }\n    });\n    return PrepareTemporalFields(bag, entries);\n}\nfunction ToTemporalZonedDateTimeFields(bag, fieldNames) {\n    const entries = [\n        ['day', undefined],\n        ['hour', 0],\n        ['microsecond', 0],\n        ['millisecond', 0],\n        ['minute', 0],\n        ['month', undefined],\n        ['monthCode', undefined],\n        ['nanosecond', 0],\n        ['second', 0],\n        ['year', undefined],\n        ['offset', undefined],\n        ['timeZone']\n    ];\n    // Add extra fields from the calendar at the end\n    fieldNames.forEach((fieldName) => {\n        if (!entries.some(([name]) => name === fieldName)) {\n            entries.push([fieldName, undefined]);\n        }\n    });\n    return PrepareTemporalFields(bag, entries);\n}\nfunction ToTemporalDate(itemParam, options = ObjectCreate$2(null)) {\n    let item = itemParam;\n    if (IsObject(item)) {\n        if (IsTemporalDate(item))\n            return item;\n        if (IsTemporalZonedDateTime(item)) {\n            item = BuiltinTimeZoneGetPlainDateTimeFor(GetSlot(item, TIME_ZONE), GetSlot(item, INSTANT), GetSlot(item, CALENDAR));\n        }\n        if (IsTemporalDateTime(item)) {\n            return CreateTemporalDate(GetSlot(item, ISO_YEAR), GetSlot(item, ISO_MONTH), GetSlot(item, ISO_DAY), GetSlot(item, CALENDAR));\n        }\n        const calendar = GetTemporalCalendarWithISODefault(item);\n        const fieldNames = CalendarFields(calendar, ['day', 'month', 'monthCode', 'year']);\n        const fields = ToTemporalDateFields(item, fieldNames);\n        return DateFromFields(calendar, fields, options);\n    }\n    ToTemporalOverflow(options); // validate and ignore\n    const { year, month, day, calendar, z } = ParseTemporalDateString(ToString(item));\n    if (z)\n        throw new RangeError('Z designator not supported for PlainDate');\n    const TemporalPlainDate = GetIntrinsic('%Temporal.PlainDate%');\n    return new TemporalPlainDate(year, month, day, calendar); // include validation\n}\nfunction InterpretTemporalDateTimeFields(calendar, fields, options) {\n    let { hour, minute, second, millisecond, microsecond, nanosecond } = ToTemporalTimeRecord(fields);\n    const overflow = ToTemporalOverflow(options);\n    const date = DateFromFields(calendar, fields, options);\n    const year = GetSlot(date, ISO_YEAR);\n    const month = GetSlot(date, ISO_MONTH);\n    const day = GetSlot(date, ISO_DAY);\n    ({ hour, minute, second, millisecond, microsecond, nanosecond } = RegulateTime(hour, minute, second, millisecond, microsecond, nanosecond, overflow));\n    return { year, month, day, hour, minute, second, millisecond, microsecond, nanosecond };\n}\nfunction ToTemporalDateTime(item, options = ObjectCreate$2(null)) {\n    let year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar;\n    if (IsObject(item)) {\n        if (IsTemporalDateTime(item))\n            return item;\n        if (IsTemporalZonedDateTime(item)) {\n            return BuiltinTimeZoneGetPlainDateTimeFor(GetSlot(item, TIME_ZONE), GetSlot(item, INSTANT), GetSlot(item, CALENDAR));\n        }\n        if (IsTemporalDate(item)) {\n            return CreateTemporalDateTime(GetSlot(item, ISO_YEAR), GetSlot(item, ISO_MONTH), GetSlot(item, ISO_DAY), 0, 0, 0, 0, 0, 0, GetSlot(item, CALENDAR));\n        }\n        calendar = GetTemporalCalendarWithISODefault(item);\n        const fieldNames = CalendarFields(calendar, [\n            'day',\n            'hour',\n            'microsecond',\n            'millisecond',\n            'minute',\n            'month',\n            'monthCode',\n            'nanosecond',\n            'second',\n            'year'\n        ]);\n        const fields = ToTemporalDateTimeFields(item, fieldNames);\n        ({ year, month, day, hour, minute, second, millisecond, microsecond, nanosecond } = InterpretTemporalDateTimeFields(calendar, fields, options));\n    }\n    else {\n        ToTemporalOverflow(options); // validate and ignore\n        let z;\n        ({ year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar, z } =\n            ParseTemporalDateTimeString(ToString(item)));\n        if (z)\n            throw new RangeError('Z designator not supported for PlainDateTime');\n        RejectDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond);\n        if (calendar === undefined)\n            calendar = GetISO8601Calendar();\n        calendar = ToTemporalCalendar(calendar);\n    }\n    return CreateTemporalDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar);\n}\nfunction ToTemporalDuration(item) {\n    let years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds;\n    if (IsObject(item)) {\n        if (IsTemporalDuration(item))\n            return item;\n        ({ years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } =\n            ToTemporalDurationRecord(item));\n    }\n    else {\n        ({ years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } =\n            ParseTemporalDurationString(ToString(item)));\n    }\n    const TemporalDuration = GetIntrinsic('%Temporal.Duration%');\n    return new TemporalDuration(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n}\nfunction ToTemporalInstant(item) {\n    if (IsTemporalInstant(item))\n        return item;\n    if (IsTemporalZonedDateTime(item)) {\n        const TemporalInstant = GetIntrinsic('%Temporal.Instant%');\n        return new TemporalInstant(GetSlot(item, EPOCHNANOSECONDS));\n    }\n    const ns = ParseTemporalInstant(ToString(item));\n    const TemporalInstant = GetIntrinsic('%Temporal.Instant%');\n    return new TemporalInstant(ns);\n}\nfunction ToTemporalMonthDay(item, options = ObjectCreate$2(null)) {\n    if (IsObject(item)) {\n        if (IsTemporalMonthDay(item))\n            return item;\n        let calendar, calendarAbsent;\n        if (HasSlot(item, CALENDAR)) {\n            calendar = GetSlot(item, CALENDAR);\n            calendarAbsent = false;\n        }\n        else {\n            let maybeStringCalendar = item.calendar;\n            calendarAbsent = maybeStringCalendar === undefined;\n            if (maybeStringCalendar === undefined)\n                maybeStringCalendar = GetISO8601Calendar();\n            calendar = ToTemporalCalendar(maybeStringCalendar);\n        }\n        const fieldNames = CalendarFields(calendar, ['day', 'month', 'monthCode', 'year']);\n        const fields = ToTemporalMonthDayFields(item, fieldNames);\n        // Callers who omit the calendar are not writing calendar-independent\n        // code. In that case, `monthCode`/`year` can be omitted; `month` and\n        // `day` are sufficient. Add a `year` to satisfy calendar validation.\n        if (calendarAbsent && fields.month !== undefined && fields.monthCode === undefined && fields.year === undefined) {\n            fields.year = 1972;\n        }\n        return MonthDayFromFields(calendar, fields, options);\n    }\n    ToTemporalOverflow(options); // validate and ignore\n    let { month, day, referenceISOYear, calendar: maybeStringCalendar } = ParseTemporalMonthDayString(ToString(item));\n    let calendar = maybeStringCalendar;\n    if (calendar === undefined)\n        calendar = GetISO8601Calendar();\n    calendar = ToTemporalCalendar(calendar);\n    if (referenceISOYear === undefined) {\n        RejectISODate(1972, month, day);\n        return CreateTemporalMonthDay(month, day, calendar);\n    }\n    const result = CreateTemporalMonthDay(month, day, calendar, referenceISOYear);\n    const canonicalOptions = ObjectCreate$2(null);\n    return MonthDayFromFields(calendar, result, canonicalOptions);\n}\nfunction ToTemporalTime(itemParam, overflow = 'constrain') {\n    let item = itemParam;\n    let hour, minute, second, millisecond, microsecond, nanosecond, calendar;\n    if (IsObject(item)) {\n        if (IsTemporalTime(item))\n            return item;\n        if (IsTemporalZonedDateTime(item)) {\n            item = BuiltinTimeZoneGetPlainDateTimeFor(GetSlot(item, TIME_ZONE), GetSlot(item, INSTANT), GetSlot(item, CALENDAR));\n        }\n        if (IsTemporalDateTime(item)) {\n            const TemporalPlainTime = GetIntrinsic('%Temporal.PlainTime%');\n            return new TemporalPlainTime(GetSlot(item, ISO_HOUR), GetSlot(item, ISO_MINUTE), GetSlot(item, ISO_SECOND), GetSlot(item, ISO_MILLISECOND), GetSlot(item, ISO_MICROSECOND), GetSlot(item, ISO_NANOSECOND));\n        }\n        calendar = GetTemporalCalendarWithISODefault(item);\n        if (ToString(calendar) !== 'iso8601') {\n            throw new RangeError('PlainTime can only have iso8601 calendar');\n        }\n        ({ hour, minute, second, millisecond, microsecond, nanosecond } = ToTemporalTimeRecord(item));\n        ({ hour, minute, second, millisecond, microsecond, nanosecond } = RegulateTime(hour, minute, second, millisecond, microsecond, nanosecond, overflow));\n    }\n    else {\n        ({ hour, minute, second, millisecond, microsecond, nanosecond, calendar } = ParseTemporalTimeString(ToString(item)));\n        RejectTime(hour, minute, second, millisecond, microsecond, nanosecond);\n        if (calendar !== undefined && calendar !== 'iso8601') {\n            throw new RangeError('PlainTime can only have iso8601 calendar');\n        }\n    }\n    const TemporalPlainTime = GetIntrinsic('%Temporal.PlainTime%');\n    return new TemporalPlainTime(hour, minute, second, millisecond, microsecond, nanosecond);\n}\nfunction ToTemporalYearMonth(item, options = ObjectCreate$2(null)) {\n    if (IsObject(item)) {\n        if (IsTemporalYearMonth(item))\n            return item;\n        const calendar = GetTemporalCalendarWithISODefault(item);\n        const fieldNames = CalendarFields(calendar, ['month', 'monthCode', 'year']);\n        const fields = ToTemporalYearMonthFields(item, fieldNames);\n        return YearMonthFromFields(calendar, fields, options);\n    }\n    ToTemporalOverflow(options); // validate and ignore\n    let { year, month, referenceISODay, calendar: maybeStringCalendar } = ParseTemporalYearMonthString(ToString(item));\n    // TODO: replace with ternary?\n    let calendar = maybeStringCalendar;\n    if (calendar === undefined)\n        calendar = GetISO8601Calendar();\n    calendar = ToTemporalCalendar(calendar);\n    if (referenceISODay === undefined) {\n        RejectISODate(year, month, 1);\n        return CreateTemporalYearMonth(year, month, calendar);\n    }\n    const result = CreateTemporalYearMonth(year, month, calendar, referenceISODay);\n    const canonicalOptions = ObjectCreate$2(null);\n    return YearMonthFromFields(calendar, result, canonicalOptions);\n}\nfunction InterpretISODateTimeOffset(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, offsetBehaviour, offsetNs, timeZone, disambiguation, offsetOpt, matchMinute) {\n    const DateTime = GetIntrinsic('%Temporal.PlainDateTime%');\n    const dt = new DateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond);\n    if (offsetBehaviour === 'wall' || offsetOpt === 'ignore') {\n        // Simple case: ISO string without a TZ offset (or caller wants to ignore\n        // the offset), so just convert DateTime to Instant in the given time zone\n        const instant = BuiltinTimeZoneGetInstantFor(timeZone, dt, disambiguation);\n        return GetSlot(instant, EPOCHNANOSECONDS);\n    }\n    // The caller wants the offset to always win ('use') OR the caller is OK\n    // with the offset winning ('prefer' or 'reject') as long as it's valid\n    // for this timezone and date/time.\n    if (offsetBehaviour === 'exact' || offsetOpt === 'use') {\n        // Calculate the instant for the input's date/time and offset\n        const epochNs = GetEpochFromISOParts(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond);\n        if (epochNs === null)\n            throw new RangeError('ZonedDateTime outside of supported range');\n        return jsbi__WEBPACK_IMPORTED_MODULE_0__.subtract(epochNs, jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(offsetNs));\n    }\n    // \"prefer\" or \"reject\"\n    const possibleInstants = GetPossibleInstantsFor(timeZone, dt);\n    for (const candidate of possibleInstants) {\n        const candidateOffset = GetOffsetNanosecondsFor(timeZone, candidate);\n        const roundedCandidateOffset = jsbi__WEBPACK_IMPORTED_MODULE_0__.toNumber(RoundNumberToIncrement(jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(candidateOffset), 60e9, 'halfExpand'));\n        if (candidateOffset === offsetNs || (matchMinute && roundedCandidateOffset === offsetNs)) {\n            return GetSlot(candidate, EPOCHNANOSECONDS);\n        }\n    }\n    // the user-provided offset doesn't match any instants for this time\n    // zone and date/time.\n    if (offsetOpt === 'reject') {\n        const offsetStr = FormatTimeZoneOffsetString(offsetNs);\n        const timeZoneString = IsTemporalTimeZone(timeZone) ? GetSlot(timeZone, TIMEZONE_ID) : 'time zone';\n        // The tsc emit for this line rewrites to invoke the PlainDateTime's valueOf method, NOT\n        // toString (which is invoked by Node when using template literals directly).\n        // See https://github.com/microsoft/TypeScript/issues/39744 for the proposed fix in tsc emit\n        throw new RangeError(`Offset ${offsetStr} is invalid for ${dt.toString()} in ${timeZoneString}`);\n    }\n    // fall through: offsetOpt === 'prefer', but the offset doesn't match\n    // so fall back to use the time zone instead.\n    const instant = DisambiguatePossibleInstants(possibleInstants, timeZone, dt, disambiguation);\n    return GetSlot(instant, EPOCHNANOSECONDS);\n}\nfunction ToTemporalZonedDateTime(item, options = ObjectCreate$2(null)) {\n    let year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, timeZone, offset, calendar;\n    let matchMinute = false;\n    let offsetBehaviour = 'option';\n    if (IsObject(item)) {\n        if (IsTemporalZonedDateTime(item))\n            return item;\n        calendar = GetTemporalCalendarWithISODefault(item);\n        const fieldNames = CalendarFields(calendar, [\n            'day',\n            'hour',\n            'microsecond',\n            'millisecond',\n            'minute',\n            'month',\n            'monthCode',\n            'nanosecond',\n            'second',\n            'year'\n        ]);\n        const fields = ToTemporalZonedDateTimeFields(item, fieldNames);\n        ({ year, month, day, hour, minute, second, millisecond, microsecond, nanosecond } = InterpretTemporalDateTimeFields(calendar, fields, options));\n        timeZone = ToTemporalTimeZone(fields.timeZone);\n        offset = fields.offset;\n        if (offset === undefined) {\n            offsetBehaviour = 'wall';\n        }\n        else {\n            offset = ToString(offset);\n        }\n    }\n    else {\n        ToTemporalOverflow(options); // validate and ignore\n        let ianaName, z;\n        ({ year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, ianaName, offset, z, calendar } =\n            ParseTemporalZonedDateTimeString(ToString(item)));\n        if (!ianaName)\n            throw new RangeError('time zone ID required in brackets');\n        if (z) {\n            offsetBehaviour = 'exact';\n        }\n        else if (!offset) {\n            offsetBehaviour = 'wall';\n        }\n        const TemporalTimeZone = GetIntrinsic('%Temporal.TimeZone%');\n        timeZone = new TemporalTimeZone(ianaName);\n        if (!calendar)\n            calendar = GetISO8601Calendar();\n        calendar = ToTemporalCalendar(calendar);\n        matchMinute = true; // ISO strings may specify offset with less precision\n    }\n    let offsetNs = 0;\n    // The code above guarantees that if offsetBehaviour === 'option', then\n    // `offset` is not undefined.\n    if (offsetBehaviour === 'option')\n        offsetNs = ParseTimeZoneOffsetString(offset);\n    const disambiguation = ToTemporalDisambiguation(options);\n    const offsetOpt = ToTemporalOffset(options, 'reject');\n    const epochNanoseconds = InterpretISODateTimeOffset(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, offsetBehaviour, offsetNs, timeZone, disambiguation, offsetOpt, matchMinute);\n    return CreateTemporalZonedDateTime(epochNanoseconds, timeZone, calendar);\n}\nfunction CreateTemporalDateSlots(result, isoYear, isoMonth, isoDay, calendar) {\n    RejectISODate(isoYear, isoMonth, isoDay);\n    RejectDateRange(isoYear, isoMonth, isoDay);\n    CreateSlots(result);\n    SetSlot(result, ISO_YEAR, isoYear);\n    SetSlot(result, ISO_MONTH, isoMonth);\n    SetSlot(result, ISO_DAY, isoDay);\n    SetSlot(result, CALENDAR, calendar);\n    SetSlot(result, DATE_BRAND, true);\n    {\n        ObjectDefineProperty(result, '_repr_', {\n            value: `${result[Symbol.toStringTag]} <${TemporalDateToString(result)}>`,\n            writable: false,\n            enumerable: false,\n            configurable: false\n        });\n    }\n}\nfunction CreateTemporalDate(isoYear, isoMonth, isoDay, calendar = GetISO8601Calendar()) {\n    const TemporalPlainDate = GetIntrinsic('%Temporal.PlainDate%');\n    const result = ObjectCreate$2(TemporalPlainDate.prototype);\n    CreateTemporalDateSlots(result, isoYear, isoMonth, isoDay, calendar);\n    return result;\n}\nfunction CreateTemporalDateTimeSlots(result, isoYear, isoMonth, isoDay, h, min, s, ms, s, ns, calendar) {\n    RejectDateTime(isoYear, isoMonth, isoDay, h, min, s, ms, s, ns);\n    RejectDateTimeRange(isoYear, isoMonth, isoDay, h, min, s, ms, s, ns);\n    CreateSlots(result);\n    SetSlot(result, ISO_YEAR, isoYear);\n    SetSlot(result, ISO_MONTH, isoMonth);\n    SetSlot(result, ISO_DAY, isoDay);\n    SetSlot(result, ISO_HOUR, h);\n    SetSlot(result, ISO_MINUTE, min);\n    SetSlot(result, ISO_SECOND, s);\n    SetSlot(result, ISO_MILLISECOND, ms);\n    SetSlot(result, ISO_MICROSECOND, s);\n    SetSlot(result, ISO_NANOSECOND, ns);\n    SetSlot(result, CALENDAR, calendar);\n    {\n        Object.defineProperty(result, '_repr_', {\n            value: `${result[Symbol.toStringTag]} <${TemporalDateTimeToString(result, 'auto')}>`,\n            writable: false,\n            enumerable: false,\n            configurable: false\n        });\n    }\n}\nfunction CreateTemporalDateTime(isoYear, isoMonth, isoDay, h, min, s, ms, s, ns, calendar = GetISO8601Calendar()) {\n    const TemporalPlainDateTime = GetIntrinsic('%Temporal.PlainDateTime%');\n    const result = ObjectCreate$2(TemporalPlainDateTime.prototype);\n    CreateTemporalDateTimeSlots(result, isoYear, isoMonth, isoDay, h, min, s, ms, s, ns, calendar);\n    return result;\n}\nfunction CreateTemporalMonthDaySlots(result, isoMonth, isoDay, calendar, referenceISOYear) {\n    RejectISODate(referenceISOYear, isoMonth, isoDay);\n    RejectDateRange(referenceISOYear, isoMonth, isoDay);\n    CreateSlots(result);\n    SetSlot(result, ISO_MONTH, isoMonth);\n    SetSlot(result, ISO_DAY, isoDay);\n    SetSlot(result, ISO_YEAR, referenceISOYear);\n    SetSlot(result, CALENDAR, calendar);\n    SetSlot(result, MONTH_DAY_BRAND, true);\n    {\n        Object.defineProperty(result, '_repr_', {\n            value: `${result[Symbol.toStringTag]} <${TemporalMonthDayToString(result)}>`,\n            writable: false,\n            enumerable: false,\n            configurable: false\n        });\n    }\n}\nfunction CreateTemporalMonthDay(isoMonth, isoDay, calendar = GetISO8601Calendar(), referenceISOYear = 1972) {\n    const TemporalPlainMonthDay = GetIntrinsic('%Temporal.PlainMonthDay%');\n    const result = ObjectCreate$2(TemporalPlainMonthDay.prototype);\n    CreateTemporalMonthDaySlots(result, isoMonth, isoDay, calendar, referenceISOYear);\n    return result;\n}\nfunction CreateTemporalYearMonthSlots(result, isoYear, isoMonth, calendar, referenceISODay) {\n    RejectISODate(isoYear, isoMonth, referenceISODay);\n    RejectYearMonthRange(isoYear, isoMonth);\n    CreateSlots(result);\n    SetSlot(result, ISO_YEAR, isoYear);\n    SetSlot(result, ISO_MONTH, isoMonth);\n    SetSlot(result, ISO_DAY, referenceISODay);\n    SetSlot(result, CALENDAR, calendar);\n    SetSlot(result, YEAR_MONTH_BRAND, true);\n    {\n        Object.defineProperty(result, '_repr_', {\n            value: `${result[Symbol.toStringTag]} <${TemporalYearMonthToString(result)}>`,\n            writable: false,\n            enumerable: false,\n            configurable: false\n        });\n    }\n}\nfunction CreateTemporalYearMonth(isoYear, isoMonth, calendar = GetISO8601Calendar(), referenceISODay = 1) {\n    const TemporalPlainYearMonth = GetIntrinsic('%Temporal.PlainYearMonth%');\n    const result = ObjectCreate$2(TemporalPlainYearMonth.prototype);\n    CreateTemporalYearMonthSlots(result, isoYear, isoMonth, calendar, referenceISODay);\n    return result;\n}\nfunction CreateTemporalZonedDateTimeSlots(result, epochNanoseconds, timeZone, calendar) {\n    ValidateEpochNanoseconds(epochNanoseconds);\n    CreateSlots(result);\n    SetSlot(result, EPOCHNANOSECONDS, epochNanoseconds);\n    SetSlot(result, TIME_ZONE, timeZone);\n    SetSlot(result, CALENDAR, calendar);\n    const TemporalInstant = GetIntrinsic('%Temporal.Instant%');\n    const instant = new TemporalInstant(GetSlot(result, EPOCHNANOSECONDS));\n    SetSlot(result, INSTANT, instant);\n    {\n        Object.defineProperty(result, '_repr_', {\n            value: `${result[Symbol.toStringTag]} <${TemporalZonedDateTimeToString(result, 'auto')}>`,\n            writable: false,\n            enumerable: false,\n            configurable: false\n        });\n    }\n}\nfunction CreateTemporalZonedDateTime(epochNanoseconds, timeZone, calendar = GetISO8601Calendar()) {\n    const TemporalZonedDateTime = GetIntrinsic('%Temporal.ZonedDateTime%');\n    const result = ObjectCreate$2(TemporalZonedDateTime.prototype);\n    CreateTemporalZonedDateTimeSlots(result, epochNanoseconds, timeZone, calendar);\n    return result;\n}\nfunction GetISO8601Calendar() {\n    const TemporalCalendar = GetIntrinsic('%Temporal.Calendar%');\n    return new TemporalCalendar('iso8601');\n}\n// TODO: should (can?) we make this generic so the field names are checked\n// against the type that the calendar is a property of?\nfunction CalendarFields(calendar, fieldNamesParam) {\n    let fieldNames = fieldNamesParam;\n    if (calendar.fields) {\n        fieldNames = calendar.fields(fieldNames);\n    }\n    const result = [];\n    for (const name of fieldNames) {\n        if (typeof name !== 'string')\n            throw new TypeError('bad return from calendar.fields()');\n        ArrayPrototypePush$1.call(result, name);\n    }\n    return result;\n}\nfunction CalendarMergeFields(calendar, fields, additionalFields) {\n    const calMergeFields = calendar.mergeFields;\n    if (!calMergeFields) {\n        return { ...fields, ...additionalFields };\n    }\n    const result = Reflect.apply(calMergeFields, calendar, [fields, additionalFields]);\n    if (!IsObject(result))\n        throw new TypeError('bad return from calendar.mergeFields()');\n    return result;\n}\nfunction CalendarDateAdd(calendar, date, duration, options, dateAddParam) {\n    let dateAdd = dateAddParam;\n    if (dateAdd === undefined) {\n        dateAdd = calendar.dateAdd;\n    }\n    const result = ReflectApply$1(dateAdd, calendar, [date, duration, options]);\n    if (!IsTemporalDate(result))\n        throw new TypeError('invalid result');\n    return result;\n}\nfunction CalendarDateUntil(calendar, date, otherDate, options, dateUntilParam) {\n    let dateUntil = dateUntilParam;\n    if (dateUntil === undefined) {\n        dateUntil = calendar.dateUntil;\n    }\n    const result = ReflectApply$1(dateUntil, calendar, [date, otherDate, options]);\n    if (!IsTemporalDuration(result))\n        throw new TypeError('invalid result');\n    return result;\n}\nfunction CalendarYear(calendar, dateLike) {\n    const result = calendar.year(dateLike);\n    if (result === undefined) {\n        throw new RangeError('calendar year result must be an integer');\n    }\n    return ToIntegerThrowOnInfinity(result);\n}\nfunction CalendarMonth(calendar, dateLike) {\n    const result = calendar.month(dateLike);\n    if (result === undefined) {\n        throw new RangeError('calendar month result must be a positive integer');\n    }\n    return ToPositiveInteger(result);\n}\nfunction CalendarMonthCode(calendar, dateLike) {\n    const result = calendar.monthCode(dateLike);\n    if (result === undefined) {\n        throw new RangeError('calendar monthCode result must be a string');\n    }\n    return ToString(result);\n}\nfunction CalendarDay(calendar, dateLike) {\n    const result = calendar.day(dateLike);\n    if (result === undefined) {\n        throw new RangeError('calendar day result must be a positive integer');\n    }\n    return ToPositiveInteger(result);\n}\nfunction CalendarEra(calendar, dateLike) {\n    let result = calendar.era(dateLike);\n    if (result !== undefined) {\n        result = ToString(result);\n    }\n    return result;\n}\nfunction CalendarEraYear(calendar, dateLike) {\n    let result = calendar.eraYear(dateLike);\n    if (result !== undefined) {\n        result = ToIntegerThrowOnInfinity(result);\n    }\n    return result;\n}\nfunction CalendarDayOfWeek(calendar, dateLike) {\n    return calendar.dayOfWeek(dateLike);\n}\nfunction CalendarDayOfYear(calendar, dateLike) {\n    return calendar.dayOfYear(dateLike);\n}\nfunction CalendarWeekOfYear(calendar, dateLike) {\n    return calendar.weekOfYear(dateLike);\n}\nfunction CalendarDaysInWeek(calendar, dateLike) {\n    return calendar.daysInWeek(dateLike);\n}\nfunction CalendarDaysInMonth(calendar, dateLike) {\n    return calendar.daysInMonth(dateLike);\n}\nfunction CalendarDaysInYear(calendar, dateLike) {\n    return calendar.daysInYear(dateLike);\n}\nfunction CalendarMonthsInYear(calendar, dateLike) {\n    return calendar.monthsInYear(dateLike);\n}\nfunction CalendarInLeapYear(calendar, dateLike) {\n    return calendar.inLeapYear(dateLike);\n}\nfunction ToTemporalCalendar(calendarLikeParam) {\n    let calendarLike = calendarLikeParam;\n    if (IsObject(calendarLike)) {\n        if (HasSlot(calendarLike, CALENDAR))\n            return GetSlot(calendarLike, CALENDAR);\n        if (!('calendar' in calendarLike))\n            return calendarLike;\n        calendarLike = calendarLike.calendar;\n        if (IsObject(calendarLike) && !('calendar' in calendarLike))\n            return calendarLike;\n    }\n    const identifier = ToString(calendarLike);\n    const TemporalCalendar = GetIntrinsic('%Temporal.Calendar%');\n    if (IsBuiltinCalendar(identifier))\n        return new TemporalCalendar(identifier);\n    let calendar;\n    try {\n        ({ calendar } = ParseISODateTime(identifier));\n    }\n    catch {\n        throw new RangeError(`Invalid calendar: ${identifier}`);\n    }\n    if (!calendar)\n        calendar = 'iso8601';\n    return new TemporalCalendar(calendar);\n}\nfunction GetTemporalCalendarWithISODefault(item) {\n    if (HasSlot(item, CALENDAR))\n        return GetSlot(item, CALENDAR);\n    const { calendar } = item;\n    if (calendar === undefined)\n        return GetISO8601Calendar();\n    return ToTemporalCalendar(calendar);\n}\nfunction CalendarEquals(one, two) {\n    if (one === two)\n        return true;\n    const cal1 = ToString(one);\n    const cal2 = ToString(two);\n    return cal1 === cal2;\n}\nfunction ConsolidateCalendars(one, two) {\n    if (one === two)\n        return two;\n    const sOne = ToString(one);\n    const sTwo = ToString(two);\n    if (sOne === sTwo || sOne === 'iso8601') {\n        return two;\n    }\n    else if (sTwo === 'iso8601') {\n        return one;\n    }\n    else {\n        throw new RangeError('irreconcilable calendars');\n    }\n}\nfunction DateFromFields(calendar, fields, options) {\n    const result = calendar.dateFromFields(fields, options);\n    if (!IsTemporalDate(result))\n        throw new TypeError('invalid result');\n    return result;\n}\nfunction YearMonthFromFields(calendar, fields, options) {\n    const result = calendar.yearMonthFromFields(fields, options);\n    if (!IsTemporalYearMonth(result))\n        throw new TypeError('invalid result');\n    return result;\n}\nfunction MonthDayFromFields(calendar, fields, options) {\n    const result = calendar.monthDayFromFields(fields, options);\n    if (!IsTemporalMonthDay(result))\n        throw new TypeError('invalid result');\n    return result;\n}\nfunction ToTemporalTimeZone(temporalTimeZoneLikeParam) {\n    let temporalTimeZoneLike = temporalTimeZoneLikeParam;\n    if (IsObject(temporalTimeZoneLike)) {\n        if (IsTemporalZonedDateTime(temporalTimeZoneLike))\n            return GetSlot(temporalTimeZoneLike, TIME_ZONE);\n        if (!('timeZone' in temporalTimeZoneLike))\n            return temporalTimeZoneLike;\n        temporalTimeZoneLike = temporalTimeZoneLike.timeZone;\n        if (IsObject(temporalTimeZoneLike) && !('timeZone' in temporalTimeZoneLike)) {\n            return temporalTimeZoneLike;\n        }\n    }\n    const identifier = ToString(temporalTimeZoneLike);\n    const timeZone = ParseTemporalTimeZone(identifier);\n    const TemporalTimeZone = GetIntrinsic('%Temporal.TimeZone%');\n    return new TemporalTimeZone(timeZone);\n}\nfunction TimeZoneEquals(one, two) {\n    if (one === two)\n        return true;\n    const tz1 = ToString(one);\n    const tz2 = ToString(two);\n    return tz1 === tz2;\n}\nfunction TemporalDateTimeToDate(dateTime) {\n    return CreateTemporalDate(GetSlot(dateTime, ISO_YEAR), GetSlot(dateTime, ISO_MONTH), GetSlot(dateTime, ISO_DAY), GetSlot(dateTime, CALENDAR));\n}\nfunction TemporalDateTimeToTime(dateTime) {\n    const Time = GetIntrinsic('%Temporal.PlainTime%');\n    return new Time(GetSlot(dateTime, ISO_HOUR), GetSlot(dateTime, ISO_MINUTE), GetSlot(dateTime, ISO_SECOND), GetSlot(dateTime, ISO_MILLISECOND), GetSlot(dateTime, ISO_MICROSECOND), GetSlot(dateTime, ISO_NANOSECOND));\n}\nfunction GetOffsetNanosecondsFor(timeZone, instant) {\n    let getOffsetNanosecondsFor = timeZone.getOffsetNanosecondsFor;\n    if (typeof getOffsetNanosecondsFor !== 'function') {\n        throw new TypeError('getOffsetNanosecondsFor not callable');\n    }\n    const offsetNs = Reflect.apply(getOffsetNanosecondsFor, timeZone, [instant]);\n    if (typeof offsetNs !== 'number') {\n        throw new TypeError('bad return from getOffsetNanosecondsFor');\n    }\n    if (!IsInteger(offsetNs) || MathAbs(offsetNs) > 86400e9) {\n        throw new RangeError('out-of-range return from getOffsetNanosecondsFor');\n    }\n    return offsetNs;\n}\nfunction BuiltinTimeZoneGetOffsetStringFor(timeZone, instant) {\n    const offsetNs = GetOffsetNanosecondsFor(timeZone, instant);\n    return FormatTimeZoneOffsetString(offsetNs);\n}\nfunction BuiltinTimeZoneGetPlainDateTimeFor(timeZone, instant, calendar) {\n    const ns = GetSlot(instant, EPOCHNANOSECONDS);\n    const offsetNs = GetOffsetNanosecondsFor(timeZone, instant);\n    let { year, month, day, hour, minute, second, millisecond, microsecond, nanosecond } = GetISOPartsFromEpoch(ns);\n    ({ year, month, day, hour, minute, second, millisecond, microsecond, nanosecond } = BalanceISODateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond + offsetNs));\n    return CreateTemporalDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar);\n}\nfunction BuiltinTimeZoneGetInstantFor(timeZone, dateTime, disambiguation) {\n    const possibleInstants = GetPossibleInstantsFor(timeZone, dateTime);\n    return DisambiguatePossibleInstants(possibleInstants, timeZone, dateTime, disambiguation);\n}\nfunction DisambiguatePossibleInstants(possibleInstants, timeZone, dateTime, disambiguation) {\n    const Instant = GetIntrinsic('%Temporal.Instant%');\n    const numInstants = possibleInstants.length;\n    if (numInstants === 1)\n        return possibleInstants[0];\n    if (numInstants) {\n        switch (disambiguation) {\n            case 'compatible':\n            // fall through because 'compatible' means 'earlier' for \"fall back\" transitions\n            case 'earlier':\n                return possibleInstants[0];\n            case 'later':\n                return possibleInstants[numInstants - 1];\n            case 'reject': {\n                throw new RangeError('multiple instants found');\n            }\n        }\n    }\n    const year = GetSlot(dateTime, ISO_YEAR);\n    const month = GetSlot(dateTime, ISO_MONTH);\n    const day = GetSlot(dateTime, ISO_DAY);\n    const hour = GetSlot(dateTime, ISO_HOUR);\n    const minute = GetSlot(dateTime, ISO_MINUTE);\n    const second = GetSlot(dateTime, ISO_SECOND);\n    const millisecond = GetSlot(dateTime, ISO_MILLISECOND);\n    const microsecond = GetSlot(dateTime, ISO_MICROSECOND);\n    const nanosecond = GetSlot(dateTime, ISO_NANOSECOND);\n    const utcns = GetEpochFromISOParts(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond);\n    if (utcns === null)\n        throw new RangeError('DateTime outside of supported range');\n    const dayBefore = new Instant(jsbi__WEBPACK_IMPORTED_MODULE_0__.subtract(utcns, DAY_NANOS));\n    const dayAfter = new Instant(jsbi__WEBPACK_IMPORTED_MODULE_0__.add(utcns, DAY_NANOS));\n    const offsetBefore = GetOffsetNanosecondsFor(timeZone, dayBefore);\n    const offsetAfter = GetOffsetNanosecondsFor(timeZone, dayAfter);\n    const nanoseconds = offsetAfter - offsetBefore;\n    switch (disambiguation) {\n        case 'earlier': {\n            const calendar = GetSlot(dateTime, CALENDAR);\n            const PlainDateTime = GetIntrinsic('%Temporal.PlainDateTime%');\n            const earlier = AddDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar, 0, 0, 0, 0, 0, 0, 0, 0, 0, -nanoseconds, undefined);\n            const earlierPlainDateTime = new PlainDateTime(earlier.year, earlier.month, earlier.day, earlier.hour, earlier.minute, earlier.second, earlier.millisecond, earlier.microsecond, earlier.nanosecond, calendar);\n            return GetPossibleInstantsFor(timeZone, earlierPlainDateTime)[0];\n        }\n        case 'compatible':\n        // fall through because 'compatible' means 'later' for \"spring forward\" transitions\n        case 'later': {\n            const calendar = GetSlot(dateTime, CALENDAR);\n            const PlainDateTime = GetIntrinsic('%Temporal.PlainDateTime%');\n            const later = AddDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar, 0, 0, 0, 0, 0, 0, 0, 0, 0, nanoseconds, undefined);\n            const laterPlainDateTime = new PlainDateTime(later.year, later.month, later.day, later.hour, later.minute, later.second, later.millisecond, later.microsecond, later.nanosecond, calendar);\n            const possible = GetPossibleInstantsFor(timeZone, laterPlainDateTime);\n            return possible[possible.length - 1];\n        }\n        case 'reject': {\n            throw new RangeError('no such instant found');\n        }\n    }\n}\nfunction GetPossibleInstantsFor(timeZone, dateTime) {\n    const possibleInstants = timeZone.getPossibleInstantsFor(dateTime);\n    const result = [];\n    for (const instant of possibleInstants) {\n        if (!IsTemporalInstant(instant)) {\n            throw new TypeError('bad return from getPossibleInstantsFor');\n        }\n        ArrayPrototypePush$1.call(result, instant);\n    }\n    return result;\n}\nfunction ISOYearString(year) {\n    let yearString;\n    if (year < 1000 || year > 9999) {\n        const sign = year < 0 ? '-' : '+';\n        const yearNumber = MathAbs(year);\n        yearString = sign + `000000${yearNumber}`.slice(-6);\n    }\n    else {\n        yearString = `${year}`;\n    }\n    return yearString;\n}\nfunction ISODateTimePartString(part) {\n    return `00${part}`.slice(-2);\n}\nfunction FormatSecondsStringPart(second, millisecond, microsecond, nanosecond, precision) {\n    if (precision === 'minute')\n        return '';\n    const secs = `:${ISODateTimePartString(second)}`;\n    let fractionNumber = millisecond * 1e6 + microsecond * 1e3 + nanosecond;\n    let fraction;\n    if (precision === 'auto') {\n        if (fractionNumber === 0)\n            return secs;\n        fraction = `${fractionNumber}`.padStart(9, '0');\n        while (fraction[fraction.length - 1] === '0')\n            fraction = fraction.slice(0, -1);\n    }\n    else {\n        if (precision === 0)\n            return secs;\n        fraction = `${fractionNumber}`.padStart(9, '0').slice(0, precision);\n    }\n    return `${secs}.${fraction}`;\n}\nfunction TemporalInstantToString(instant, timeZone, precision) {\n    let outputTimeZone = timeZone;\n    if (outputTimeZone === undefined) {\n        const TemporalTimeZone = GetIntrinsic('%Temporal.TimeZone%');\n        outputTimeZone = new TemporalTimeZone('UTC');\n    }\n    const iso = GetISO8601Calendar();\n    const dateTime = BuiltinTimeZoneGetPlainDateTimeFor(outputTimeZone, instant, iso);\n    const year = ISOYearString(GetSlot(dateTime, ISO_YEAR));\n    const month = ISODateTimePartString(GetSlot(dateTime, ISO_MONTH));\n    const day = ISODateTimePartString(GetSlot(dateTime, ISO_DAY));\n    const hour = ISODateTimePartString(GetSlot(dateTime, ISO_HOUR));\n    const minute = ISODateTimePartString(GetSlot(dateTime, ISO_MINUTE));\n    const seconds = FormatSecondsStringPart(GetSlot(dateTime, ISO_SECOND), GetSlot(dateTime, ISO_MILLISECOND), GetSlot(dateTime, ISO_MICROSECOND), GetSlot(dateTime, ISO_NANOSECOND), precision);\n    let timeZoneString = 'Z';\n    if (timeZone !== undefined) {\n        const offsetNs = GetOffsetNanosecondsFor(outputTimeZone, instant);\n        timeZoneString = FormatISOTimeZoneOffsetString(offsetNs);\n    }\n    return `${year}-${month}-${day}T${hour}:${minute}${seconds}${timeZoneString}`;\n}\nfunction TemporalDurationToString(duration, precision = 'auto', options = undefined) {\n    function formatNumber(num) {\n        if (num <= NumberMaxSafeInteger)\n            return num.toString(10);\n        return jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(num).toString(10);\n    }\n    const years = GetSlot(duration, YEARS);\n    const months = GetSlot(duration, MONTHS);\n    const weeks = GetSlot(duration, WEEKS);\n    const days = GetSlot(duration, DAYS);\n    const hours = GetSlot(duration, HOURS);\n    const minutes = GetSlot(duration, MINUTES);\n    let seconds = GetSlot(duration, SECONDS);\n    let ms = GetSlot(duration, MILLISECONDS);\n    let s = GetSlot(duration, MICROSECONDS);\n    let ns = GetSlot(duration, NANOSECONDS);\n    const sign = DurationSign(years, months, weeks, days, hours, minutes, seconds, ms, s, ns);\n    if (options) {\n        const { unit, increment, roundingMode } = options;\n        ({\n            seconds,\n            milliseconds: ms,\n            microseconds: s,\n            nanoseconds: ns\n        } = RoundDuration(0, 0, 0, 0, 0, 0, seconds, ms, s, ns, increment, unit, roundingMode));\n    }\n    const dateParts = [];\n    if (years)\n        dateParts.push(`${formatNumber(MathAbs(years))}Y`);\n    if (months)\n        dateParts.push(`${formatNumber(MathAbs(months))}M`);\n    if (weeks)\n        dateParts.push(`${formatNumber(MathAbs(weeks))}W`);\n    if (days)\n        dateParts.push(`${formatNumber(MathAbs(days))}D`);\n    const timeParts = [];\n    if (hours)\n        timeParts.push(`${formatNumber(MathAbs(hours))}H`);\n    if (minutes)\n        timeParts.push(`${formatNumber(MathAbs(minutes))}M`);\n    const secondParts = [];\n    let total = TotalDurationNanoseconds(0, 0, 0, seconds, ms, s, ns, 0);\n    let nsBigInt, sBigInt, msBigInt, secondsBigInt;\n    ({ quotient: total, remainder: nsBigInt } = divmod(total, THOUSAND));\n    ({ quotient: total, remainder: sBigInt } = divmod(total, THOUSAND));\n    ({ quotient: secondsBigInt, remainder: msBigInt } = divmod(total, THOUSAND));\n    const fraction = MathAbs(jsbi__WEBPACK_IMPORTED_MODULE_0__.toNumber(msBigInt)) * 1e6 + MathAbs(jsbi__WEBPACK_IMPORTED_MODULE_0__.toNumber(sBigInt)) * 1e3 + MathAbs(jsbi__WEBPACK_IMPORTED_MODULE_0__.toNumber(nsBigInt));\n    let decimalPart;\n    if (precision === 'auto') {\n        if (fraction !== 0) {\n            decimalPart = `${fraction}`.padStart(9, '0');\n            while (decimalPart[decimalPart.length - 1] === '0') {\n                decimalPart = decimalPart.slice(0, -1);\n            }\n        }\n    }\n    else if (precision !== 0) {\n        decimalPart = `${fraction}`.padStart(9, '0').slice(0, precision);\n    }\n    if (decimalPart)\n        secondParts.unshift('.', decimalPart);\n    if (!jsbi__WEBPACK_IMPORTED_MODULE_0__.equal(secondsBigInt, ZERO) || secondParts.length || precision !== 'auto') {\n        secondParts.unshift(abs(secondsBigInt).toString());\n    }\n    if (secondParts.length)\n        timeParts.push(`${secondParts.join('')}S`);\n    if (timeParts.length)\n        timeParts.unshift('T');\n    if (!dateParts.length && !timeParts.length)\n        return 'PT0S';\n    return `${sign < 0 ? '-' : ''}P${dateParts.join('')}${timeParts.join('')}`;\n}\nfunction TemporalDateToString(date, showCalendar = 'auto') {\n    const year = ISOYearString(GetSlot(date, ISO_YEAR));\n    const month = ISODateTimePartString(GetSlot(date, ISO_MONTH));\n    const day = ISODateTimePartString(GetSlot(date, ISO_DAY));\n    const calendarID = ToString(GetSlot(date, CALENDAR));\n    const calendar = FormatCalendarAnnotation(calendarID, showCalendar);\n    return `${year}-${month}-${day}${calendar}`;\n}\nfunction TemporalDateTimeToString(dateTime, precision, showCalendar = 'auto', options = undefined) {\n    let year = GetSlot(dateTime, ISO_YEAR);\n    let month = GetSlot(dateTime, ISO_MONTH);\n    let day = GetSlot(dateTime, ISO_DAY);\n    let hour = GetSlot(dateTime, ISO_HOUR);\n    let minute = GetSlot(dateTime, ISO_MINUTE);\n    let second = GetSlot(dateTime, ISO_SECOND);\n    let millisecond = GetSlot(dateTime, ISO_MILLISECOND);\n    let microsecond = GetSlot(dateTime, ISO_MICROSECOND);\n    let nanosecond = GetSlot(dateTime, ISO_NANOSECOND);\n    if (options) {\n        const { unit, increment, roundingMode } = options;\n        ({ year, month, day, hour, minute, second, millisecond, microsecond, nanosecond } = RoundISODateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, increment, unit, roundingMode));\n    }\n    const yearString = ISOYearString(year);\n    const monthString = ISODateTimePartString(month);\n    const dayString = ISODateTimePartString(day);\n    const hourString = ISODateTimePartString(hour);\n    const minuteString = ISODateTimePartString(minute);\n    const secondsString = FormatSecondsStringPart(second, millisecond, microsecond, nanosecond, precision);\n    const calendarID = ToString(GetSlot(dateTime, CALENDAR));\n    const calendar = FormatCalendarAnnotation(calendarID, showCalendar);\n    return `${yearString}-${monthString}-${dayString}T${hourString}:${minuteString}${secondsString}${calendar}`;\n}\nfunction TemporalMonthDayToString(monthDay, showCalendar = 'auto') {\n    const month = ISODateTimePartString(GetSlot(monthDay, ISO_MONTH));\n    const day = ISODateTimePartString(GetSlot(monthDay, ISO_DAY));\n    let resultString = `${month}-${day}`;\n    const calendar = GetSlot(monthDay, CALENDAR);\n    const calendarID = ToString(calendar);\n    if (calendarID !== 'iso8601') {\n        const year = ISOYearString(GetSlot(monthDay, ISO_YEAR));\n        resultString = `${year}-${resultString}`;\n    }\n    const calendarString = FormatCalendarAnnotation(calendarID, showCalendar);\n    if (calendarString)\n        resultString += calendarString;\n    return resultString;\n}\nfunction TemporalYearMonthToString(yearMonth, showCalendar = 'auto') {\n    const year = ISOYearString(GetSlot(yearMonth, ISO_YEAR));\n    const month = ISODateTimePartString(GetSlot(yearMonth, ISO_MONTH));\n    let resultString = `${year}-${month}`;\n    const calendar = GetSlot(yearMonth, CALENDAR);\n    const calendarID = ToString(calendar);\n    if (calendarID !== 'iso8601') {\n        const day = ISODateTimePartString(GetSlot(yearMonth, ISO_DAY));\n        resultString += `-${day}`;\n    }\n    const calendarString = FormatCalendarAnnotation(calendarID, showCalendar);\n    if (calendarString)\n        resultString += calendarString;\n    return resultString;\n}\nfunction TemporalZonedDateTimeToString(zdt, precision, showCalendar = 'auto', showTimeZone = 'auto', showOffset = 'auto', options = undefined) {\n    let instant = GetSlot(zdt, INSTANT);\n    if (options) {\n        const { unit, increment, roundingMode } = options;\n        const ns = RoundInstant(GetSlot(zdt, EPOCHNANOSECONDS), increment, unit, roundingMode);\n        const TemporalInstant = GetIntrinsic('%Temporal.Instant%');\n        instant = new TemporalInstant(ns);\n    }\n    const tz = GetSlot(zdt, TIME_ZONE);\n    const iso = GetISO8601Calendar();\n    const dateTime = BuiltinTimeZoneGetPlainDateTimeFor(tz, instant, iso);\n    const year = ISOYearString(GetSlot(dateTime, ISO_YEAR));\n    const month = ISODateTimePartString(GetSlot(dateTime, ISO_MONTH));\n    const day = ISODateTimePartString(GetSlot(dateTime, ISO_DAY));\n    const hour = ISODateTimePartString(GetSlot(dateTime, ISO_HOUR));\n    const minute = ISODateTimePartString(GetSlot(dateTime, ISO_MINUTE));\n    const seconds = FormatSecondsStringPart(GetSlot(dateTime, ISO_SECOND), GetSlot(dateTime, ISO_MILLISECOND), GetSlot(dateTime, ISO_MICROSECOND), GetSlot(dateTime, ISO_NANOSECOND), precision);\n    let result = `${year}-${month}-${day}T${hour}:${minute}${seconds}`;\n    if (showOffset !== 'never') {\n        const offsetNs = GetOffsetNanosecondsFor(tz, instant);\n        result += FormatISOTimeZoneOffsetString(offsetNs);\n    }\n    if (showTimeZone !== 'never')\n        result += `[${tz}]`;\n    const calendarID = ToString(GetSlot(zdt, CALENDAR));\n    result += FormatCalendarAnnotation(calendarID, showCalendar);\n    return result;\n}\nfunction TestTimeZoneOffsetString(string) {\n    return OFFSET.test(StringCtor(string));\n}\nfunction ParseTimeZoneOffsetString(string) {\n    const match = OFFSET.exec(StringCtor(string));\n    if (!match) {\n        throw new RangeError(`invalid time zone offset: ${string}`);\n    }\n    const sign = match[1] === '-' || match[1] === '\\u2212' ? -1 : +1;\n    const hours = +match[2];\n    const minutes = +(match[3] || 0);\n    const seconds = +(match[4] || 0);\n    const nanoseconds = +((match[5] || 0) + '000000000').slice(0, 9);\n    return sign * (((hours * 60 + minutes) * 60 + seconds) * 1e9 + nanoseconds);\n}\nfunction GetCanonicalTimeZoneIdentifier(timeZoneIdentifier) {\n    if (TestTimeZoneOffsetString(timeZoneIdentifier)) {\n        const offsetNs = ParseTimeZoneOffsetString(timeZoneIdentifier);\n        return FormatTimeZoneOffsetString(offsetNs);\n    }\n    const formatter = getIntlDateTimeFormatEnUsForTimeZone(StringCtor(timeZoneIdentifier));\n    return formatter.resolvedOptions().timeZone;\n}\nfunction GetIANATimeZoneOffsetNanoseconds(epochNanoseconds, id) {\n    const { year, month, day, hour, minute, second, millisecond, microsecond, nanosecond } = GetIANATimeZoneDateTimeParts(epochNanoseconds, id);\n    const utc = GetEpochFromISOParts(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond);\n    if (utc === null)\n        throw new RangeError('Date outside of supported range');\n    return jsbi__WEBPACK_IMPORTED_MODULE_0__.toNumber(jsbi__WEBPACK_IMPORTED_MODULE_0__.subtract(utc, epochNanoseconds));\n}\nfunction FormatTimeZoneOffsetString(offsetNanosecondsParam) {\n    const sign = offsetNanosecondsParam < 0 ? '-' : '+';\n    const offsetNanoseconds = MathAbs(offsetNanosecondsParam);\n    const nanoseconds = offsetNanoseconds % 1e9;\n    const seconds = MathFloor(offsetNanoseconds / 1e9) % 60;\n    const minutes = MathFloor(offsetNanoseconds / 60e9) % 60;\n    const hours = MathFloor(offsetNanoseconds / 3600e9);\n    const hourString = ISODateTimePartString(hours);\n    const minuteString = ISODateTimePartString(minutes);\n    const secondString = ISODateTimePartString(seconds);\n    let post = '';\n    if (nanoseconds) {\n        let fraction = `${nanoseconds}`.padStart(9, '0');\n        while (fraction[fraction.length - 1] === '0')\n            fraction = fraction.slice(0, -1);\n        post = `:${secondString}.${fraction}`;\n    }\n    else if (seconds) {\n        post = `:${secondString}`;\n    }\n    return `${sign}${hourString}:${minuteString}${post}`;\n}\nfunction FormatISOTimeZoneOffsetString(offsetNanosecondsParam) {\n    let offsetNanoseconds = jsbi__WEBPACK_IMPORTED_MODULE_0__.toNumber(RoundNumberToIncrement(jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(offsetNanosecondsParam), 60e9, 'halfExpand'));\n    const sign = offsetNanoseconds < 0 ? '-' : '+';\n    offsetNanoseconds = MathAbs(offsetNanoseconds);\n    const minutes = (offsetNanoseconds / 60e9) % 60;\n    const hours = MathFloor(offsetNanoseconds / 3600e9);\n    const hourString = ISODateTimePartString(hours);\n    const minuteString = ISODateTimePartString(minutes);\n    return `${sign}${hourString}:${minuteString}`;\n}\nfunction GetEpochFromISOParts(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond) {\n    // Note: Date.UTC() interprets one and two-digit years as being in the\n    // 20th century, so don't use it\n    const legacyDate = new Date();\n    legacyDate.setUTCHours(hour, minute, second, millisecond);\n    legacyDate.setUTCFullYear(year, month - 1, day);\n    const ms = legacyDate.getTime();\n    if (NumberIsNaN(ms))\n        return null;\n    let ns = jsbi__WEBPACK_IMPORTED_MODULE_0__.multiply(jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(ms), MILLION);\n    ns = jsbi__WEBPACK_IMPORTED_MODULE_0__.add(ns, jsbi__WEBPACK_IMPORTED_MODULE_0__.multiply(jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(microsecond), THOUSAND));\n    ns = jsbi__WEBPACK_IMPORTED_MODULE_0__.add(ns, jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(nanosecond));\n    if (jsbi__WEBPACK_IMPORTED_MODULE_0__.lessThan(ns, NS_MIN) || jsbi__WEBPACK_IMPORTED_MODULE_0__.greaterThan(ns, NS_MAX))\n        return null;\n    return ns;\n}\nfunction GetISOPartsFromEpoch(epochNanoseconds) {\n    const { quotient, remainder } = divmod(epochNanoseconds, MILLION);\n    let epochMilliseconds = jsbi__WEBPACK_IMPORTED_MODULE_0__.toNumber(quotient);\n    let nanos = jsbi__WEBPACK_IMPORTED_MODULE_0__.toNumber(remainder);\n    if (nanos < 0) {\n        nanos += 1e6;\n        epochMilliseconds -= 1;\n    }\n    const microsecond = MathFloor(nanos / 1e3) % 1e3;\n    const nanosecond = nanos % 1e3;\n    const item = new Date(epochMilliseconds);\n    const year = item.getUTCFullYear();\n    const month = item.getUTCMonth() + 1;\n    const day = item.getUTCDate();\n    const hour = item.getUTCHours();\n    const minute = item.getUTCMinutes();\n    const second = item.getUTCSeconds();\n    const millisecond = item.getUTCMilliseconds();\n    return { epochMilliseconds, year, month, day, hour, minute, second, millisecond, microsecond, nanosecond };\n}\n// ts-prune-ignore-next TODO: remove this after tests are converted to TS\nfunction GetIANATimeZoneDateTimeParts(epochNanoseconds, id) {\n    const { epochMilliseconds, millisecond, microsecond, nanosecond } = GetISOPartsFromEpoch(epochNanoseconds);\n    const { year, month, day, hour, minute, second } = GetFormatterParts(id, epochMilliseconds);\n    return BalanceISODateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond);\n}\nfunction maxJSBI(one, two) {\n    return jsbi__WEBPACK_IMPORTED_MODULE_0__.lessThan(one, two) ? two : one;\n}\n/**\n * Our best guess at how far in advance new rules will be put into the TZDB for\n * future offset transitions. We'll pick 10 years but can always revise it if\n * we find that countries are being unusually proactive in their announcing\n * of offset changes.\n */\nfunction afterLatestPossibleTzdbRuleChange() {\n    return jsbi__WEBPACK_IMPORTED_MODULE_0__.add(SystemUTCEpochNanoSeconds(), ABOUT_TEN_YEARS_NANOS);\n}\nfunction GetIANATimeZoneNextTransition(epochNanoseconds, id) {\n    // Decide how far in the future after `epochNanoseconds` we'll look for an\n    // offset change. There are two cases:\n    // 1. If it's a past date (or a date in the near future) then it's possible\n    //    that the time zone may have newly added DST in the next few years. So\n    //    we'll have to look from the provided time until a few years after the\n    //    current system time. (Changes to DST policy are usually announced a few\n    //    years in the future.) Note that the first DST anywhere started in 1847,\n    //    so we'll start checks in 1847 instead of wasting cycles on years where\n    //    there will never be transitions.\n    // 2. If it's a future date beyond the next few years, then we'll just assume\n    //    that the latest DST policy in TZDB will still be in effect.  In this\n    //    case, we only need to look one year in the future to see if there are\n    //    any DST transitions.  We actually only need to look 9-10 months because\n    //    DST has two transitions per year, but we'll use a year just to be safe.\n    const oneYearLater = jsbi__WEBPACK_IMPORTED_MODULE_0__.add(epochNanoseconds, ABOUT_ONE_YEAR_NANOS);\n    const uppercap = maxJSBI(afterLatestPossibleTzdbRuleChange(), oneYearLater);\n    // The first transition (in any timezone) recorded in the TZDB was in 1847, so\n    // start there if an earlier date is supplied.\n    let leftNanos = maxJSBI(BEFORE_FIRST_OFFSET_TRANSITION, epochNanoseconds);\n    const leftOffsetNs = GetIANATimeZoneOffsetNanoseconds(leftNanos, id);\n    let rightNanos = leftNanos;\n    let rightOffsetNs = leftOffsetNs;\n    while (leftOffsetNs === rightOffsetNs && jsbi__WEBPACK_IMPORTED_MODULE_0__.lessThan(jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(leftNanos), uppercap)) {\n        rightNanos = jsbi__WEBPACK_IMPORTED_MODULE_0__.add(leftNanos, TWO_WEEKS_NANOS);\n        rightOffsetNs = GetIANATimeZoneOffsetNanoseconds(rightNanos, id);\n        if (leftOffsetNs === rightOffsetNs) {\n            leftNanos = rightNanos;\n        }\n    }\n    if (leftOffsetNs === rightOffsetNs)\n        return null;\n    const result = bisect((epochNs) => GetIANATimeZoneOffsetNanoseconds(epochNs, id), leftNanos, rightNanos, leftOffsetNs, rightOffsetNs);\n    return result;\n}\nfunction GetIANATimeZonePreviousTransition(epochNanoseconds, id) {\n    // If a time zone uses DST (at the time of `epochNanoseconds`), then we only\n    // have to look back one year to find a transition. But if it doesn't use DST,\n    // then we need to look all the way back to 1847 (the earliest rule in the\n    // TZDB) to see if it had other offset transitions in the past. Looping back\n    // from a far-future date to 1847 is very slow (minutes of 100% CPU!), and is\n    // also unnecessary because DST rules aren't put into the TZDB more than a few\n    // years in the future because the political changes in time zones happen with\n    // only a few years' warning. Therefore, if a far-future date is provided,\n    // then we'll run the check in two parts:\n    // 1. First, we'll look back for up to one year to see if the latest TZDB\n    //    rules have DST.\n    // 2. If not, then we'll \"fast-reverse\" back to a few years later than the\n    //    current system time, and then look back to 1847. This reduces the\n    //    worst-case loop from 273K years to 175 years, for a ~1500x improvement\n    //    in worst-case perf.\n    const afterLatestRule = afterLatestPossibleTzdbRuleChange();\n    const isFarFuture = jsbi__WEBPACK_IMPORTED_MODULE_0__.greaterThan(epochNanoseconds, afterLatestRule);\n    const lowercap = isFarFuture ? jsbi__WEBPACK_IMPORTED_MODULE_0__.subtract(epochNanoseconds, ABOUT_ONE_YEAR_NANOS) : BEFORE_FIRST_OFFSET_TRANSITION;\n    let rightNanos = jsbi__WEBPACK_IMPORTED_MODULE_0__.subtract(epochNanoseconds, ONE);\n    const rightOffsetNs = GetIANATimeZoneOffsetNanoseconds(rightNanos, id);\n    let leftNanos = rightNanos;\n    let leftOffsetNs = rightOffsetNs;\n    while (rightOffsetNs === leftOffsetNs && jsbi__WEBPACK_IMPORTED_MODULE_0__.greaterThan(rightNanos, lowercap)) {\n        leftNanos = jsbi__WEBPACK_IMPORTED_MODULE_0__.subtract(rightNanos, TWO_WEEKS_NANOS);\n        leftOffsetNs = GetIANATimeZoneOffsetNanoseconds(leftNanos, id);\n        if (rightOffsetNs === leftOffsetNs) {\n            rightNanos = leftNanos;\n        }\n    }\n    if (rightOffsetNs === leftOffsetNs) {\n        if (isFarFuture) {\n            // There was no DST after looking back one year, which means that the most\n            // recent TZDB rules don't have any recurring transitions. To check for\n            // transitions in older rules, back up to a few years after the current\n            // date and then look all the way back to 1847. Note that we move back one\n            // day from the latest possible rule so that when the recursion runs it\n            // won't consider the new time to be \"far future\" because the system clock\n            // has advanced in the meantime.\n            const newTimeToCheck = jsbi__WEBPACK_IMPORTED_MODULE_0__.subtract(afterLatestRule, DAY_NANOS);\n            return GetIANATimeZonePreviousTransition(newTimeToCheck, id);\n        }\n        return null;\n    }\n    const result = bisect((epochNs) => GetIANATimeZoneOffsetNanoseconds(epochNs, id), leftNanos, rightNanos, leftOffsetNs, rightOffsetNs);\n    return result;\n}\n// ts-prune-ignore-next TODO: remove this after tests are converted to TS\nfunction parseFromEnUsFormat(datetime) {\n    const parts = datetime.split(/[^\\w]+/);\n    if (parts.length !== 7) {\n        throw new RangeError(`expected 7 parts in \"${datetime}`);\n    }\n    const month = +parts[0];\n    const day = +parts[1];\n    let year = +parts[2];\n    const era = parts[3].toUpperCase();\n    if (era === 'B' || era === 'BC') {\n        year = -year + 1;\n    }\n    else if (era !== 'A' && era !== 'AD') {\n        throw new RangeError(`Unknown era ${era} in \"${datetime}`);\n    }\n    let hour = +parts[4];\n    if (hour === 24) {\n        // bugs.chromium.org/p/chromium/issues/detail?id=1045791\n        hour = 0;\n    }\n    const minute = +parts[5];\n    const second = +parts[6];\n    if (!NumberIsFinite(year) ||\n        !NumberIsFinite(month) ||\n        !NumberIsFinite(day) ||\n        !NumberIsFinite(hour) ||\n        !NumberIsFinite(minute) ||\n        !NumberIsFinite(second)) {\n        throw new RangeError(`Invalid number in \"${datetime}`);\n    }\n    return { year, month, day, hour, minute, second };\n}\n// ts-prune-ignore-next TODO: remove this after tests are converted to TS\nfunction GetFormatterParts(timeZone, epochMilliseconds) {\n    const formatter = getIntlDateTimeFormatEnUsForTimeZone(timeZone);\n    // Using `format` instead of `formatToParts` for compatibility with older clients\n    const datetime = formatter.format(new Date(epochMilliseconds));\n    return parseFromEnUsFormat(datetime);\n}\nfunction GetIANATimeZoneEpochValue(id, year, month, day, hour, minute, second, millisecond, microsecond, nanosecond) {\n    const ns = GetEpochFromISOParts(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond);\n    if (ns === null)\n        throw new RangeError('DateTime outside of supported range');\n    let nsEarlier = jsbi__WEBPACK_IMPORTED_MODULE_0__.subtract(ns, DAY_NANOS);\n    if (jsbi__WEBPACK_IMPORTED_MODULE_0__.lessThan(nsEarlier, NS_MIN))\n        nsEarlier = ns;\n    let nsLater = jsbi__WEBPACK_IMPORTED_MODULE_0__.add(ns, DAY_NANOS);\n    if (jsbi__WEBPACK_IMPORTED_MODULE_0__.greaterThan(nsLater, NS_MAX))\n        nsLater = ns;\n    const earliest = GetIANATimeZoneOffsetNanoseconds(nsEarlier, id);\n    const latest = GetIANATimeZoneOffsetNanoseconds(nsLater, id);\n    const found = earliest === latest ? [earliest] : [earliest, latest];\n    return found\n        .map((offsetNanoseconds) => {\n        const epochNanoseconds = jsbi__WEBPACK_IMPORTED_MODULE_0__.subtract(ns, jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(offsetNanoseconds));\n        const parts = GetIANATimeZoneDateTimeParts(epochNanoseconds, id);\n        if (year !== parts.year ||\n            month !== parts.month ||\n            day !== parts.day ||\n            hour !== parts.hour ||\n            minute !== parts.minute ||\n            second !== parts.second ||\n            millisecond !== parts.millisecond ||\n            microsecond !== parts.microsecond ||\n            nanosecond !== parts.nanosecond) {\n            return undefined;\n        }\n        return epochNanoseconds;\n    })\n        .filter((x) => x !== undefined);\n}\nfunction LeapYear(year) {\n    if (undefined === year)\n        return false;\n    const isDiv4 = year % 4 === 0;\n    const isDiv100 = year % 100 === 0;\n    const isDiv400 = year % 400 === 0;\n    return isDiv4 && (!isDiv100 || isDiv400);\n}\nfunction ISODaysInMonth(year, month) {\n    const DoM = {\n        standard: [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],\n        leapyear: [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n    };\n    return DoM[LeapYear(year) ? 'leapyear' : 'standard'][month - 1];\n}\nfunction DayOfWeek(year, month, day) {\n    const m = month + (month < 3 ? 10 : -2);\n    const Y = year - (month < 3 ? 1 : 0);\n    const c = MathFloor(Y / 100);\n    const y = Y - c * 100;\n    const d = day;\n    const pD = d;\n    const pM = MathFloor(2.6 * m - 0.2);\n    const pY = y + MathFloor(y / 4);\n    const pC = MathFloor(c / 4) - 2 * c;\n    const dow = (pD + pM + pY + pC) % 7;\n    return dow + (dow <= 0 ? 7 : 0);\n}\nfunction DayOfYear(year, month, day) {\n    let days = day;\n    for (let m = month - 1; m > 0; m--) {\n        days += ISODaysInMonth(year, m);\n    }\n    return days;\n}\nfunction WeekOfYear(year, month, day) {\n    const doy = DayOfYear(year, month, day);\n    const dow = DayOfWeek(year, month, day) || 7;\n    const doj = DayOfWeek(year, 1, 1);\n    const week = MathFloor((doy - dow + 10) / 7);\n    if (week < 1) {\n        if (doj === 5 || (doj === 6 && LeapYear(year - 1))) {\n            return 53;\n        }\n        else {\n            return 52;\n        }\n    }\n    if (week === 53) {\n        if ((LeapYear(year) ? 366 : 365) - doy < 4 - dow) {\n            return 1;\n        }\n    }\n    return week;\n}\nfunction DurationSign(y, mon, w, d, h, min, s, ms, s, ns) {\n    for (const prop of [y, mon, w, d, h, min, s, ms, s, ns]) {\n        if (prop !== 0)\n            return prop < 0 ? -1 : 1;\n    }\n    return 0;\n}\nfunction BalanceISOYearMonth(yearParam, monthParam) {\n    let year = yearParam;\n    let month = monthParam;\n    if (!NumberIsFinite(year) || !NumberIsFinite(month))\n        throw new RangeError('infinity is out of range');\n    month -= 1;\n    year += MathFloor(month / 12);\n    month %= 12;\n    if (month < 0)\n        month += 12;\n    month += 1;\n    return { year, month };\n}\nfunction BalanceISODate(yearParam, monthParam, dayParam) {\n    let year = yearParam;\n    let month = monthParam;\n    let day = dayParam;\n    if (!NumberIsFinite(day))\n        throw new RangeError('infinity is out of range');\n    ({ year, month } = BalanceISOYearMonth(year, month));\n    let daysInYear = 0;\n    let testYear = month > 2 ? year : year - 1;\n    while (((daysInYear = LeapYear(testYear) ? 366 : 365), day < -daysInYear)) {\n        year -= 1;\n        testYear -= 1;\n        day += daysInYear;\n    }\n    testYear += 1;\n    while (((daysInYear = LeapYear(testYear) ? 366 : 365), day > daysInYear)) {\n        year += 1;\n        testYear += 1;\n        day -= daysInYear;\n    }\n    while (day < 1) {\n        ({ year, month } = BalanceISOYearMonth(year, month - 1));\n        day += ISODaysInMonth(year, month);\n    }\n    while (day > ISODaysInMonth(year, month)) {\n        day -= ISODaysInMonth(year, month);\n        ({ year, month } = BalanceISOYearMonth(year, month + 1));\n    }\n    return { year, month, day };\n}\nfunction BalanceISODateTime(yearParam, monthParam, dayParam, hourParam, minuteParam, secondParam, millisecondParam, microsecondParam, nanosecondParam) {\n    const { deltaDays, hour, minute, second, millisecond, microsecond, nanosecond } = BalanceTime(hourParam, minuteParam, secondParam, millisecondParam, microsecondParam, nanosecondParam);\n    const { year, month, day } = BalanceISODate(yearParam, monthParam, dayParam + deltaDays);\n    return { year, month, day, hour, minute, second, millisecond, microsecond, nanosecond };\n}\nfunction BalanceTime(hourParam, minuteParam, secondParam, millisecondParam, microsecondParam, nanosecondParam) {\n    let hour = hourParam;\n    let minute = minuteParam;\n    let second = secondParam;\n    let millisecond = millisecondParam;\n    let microsecond = microsecondParam;\n    let nanosecond = nanosecondParam;\n    if (!NumberIsFinite(hour) ||\n        !NumberIsFinite(minute) ||\n        !NumberIsFinite(second) ||\n        !NumberIsFinite(millisecond) ||\n        !NumberIsFinite(microsecond) ||\n        !NumberIsFinite(nanosecond)) {\n        throw new RangeError('infinity is out of range');\n    }\n    microsecond += MathFloor(nanosecond / 1000);\n    nanosecond = NonNegativeModulo(nanosecond, 1000);\n    millisecond += MathFloor(microsecond / 1000);\n    microsecond = NonNegativeModulo(microsecond, 1000);\n    second += MathFloor(millisecond / 1000);\n    millisecond = NonNegativeModulo(millisecond, 1000);\n    minute += MathFloor(second / 60);\n    second = NonNegativeModulo(second, 60);\n    hour += MathFloor(minute / 60);\n    minute = NonNegativeModulo(minute, 60);\n    const deltaDays = MathFloor(hour / 24);\n    hour = NonNegativeModulo(hour, 24);\n    return { deltaDays, hour, minute, second, millisecond, microsecond, nanosecond };\n}\nfunction TotalDurationNanoseconds(daysParam, hoursParam, minutesParam, secondsParam, millisecondsParam, microsecondsParam, nanosecondsParam, offsetShift) {\n    const days = jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(daysParam);\n    let nanoseconds = jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(nanosecondsParam);\n    if (daysParam !== 0)\n        nanoseconds = jsbi__WEBPACK_IMPORTED_MODULE_0__.subtract(jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(nanosecondsParam), jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(offsetShift));\n    const hours = jsbi__WEBPACK_IMPORTED_MODULE_0__.add(jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(hoursParam), jsbi__WEBPACK_IMPORTED_MODULE_0__.multiply(days, jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(24)));\n    const minutes = jsbi__WEBPACK_IMPORTED_MODULE_0__.add(jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(minutesParam), jsbi__WEBPACK_IMPORTED_MODULE_0__.multiply(hours, SIXTY));\n    const seconds = jsbi__WEBPACK_IMPORTED_MODULE_0__.add(jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(secondsParam), jsbi__WEBPACK_IMPORTED_MODULE_0__.multiply(minutes, SIXTY));\n    const milliseconds = jsbi__WEBPACK_IMPORTED_MODULE_0__.add(jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(millisecondsParam), jsbi__WEBPACK_IMPORTED_MODULE_0__.multiply(seconds, THOUSAND));\n    const microseconds = jsbi__WEBPACK_IMPORTED_MODULE_0__.add(jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(microsecondsParam), jsbi__WEBPACK_IMPORTED_MODULE_0__.multiply(milliseconds, THOUSAND));\n    return jsbi__WEBPACK_IMPORTED_MODULE_0__.add(jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(nanoseconds), jsbi__WEBPACK_IMPORTED_MODULE_0__.multiply(microseconds, THOUSAND));\n}\nfunction NanosecondsToDays(nanosecondsParam, relativeTo) {\n    const TemporalInstant = GetIntrinsic('%Temporal.Instant%');\n    const sign = MathSign(jsbi__WEBPACK_IMPORTED_MODULE_0__.toNumber(nanosecondsParam));\n    let nanoseconds = jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(nanosecondsParam);\n    let dayLengthNs = 86400e9;\n    if (sign === 0)\n        return { days: 0, nanoseconds: ZERO, dayLengthNs };\n    if (!IsTemporalZonedDateTime(relativeTo)) {\n        let days;\n        ({ quotient: days, remainder: nanoseconds } = divmod(nanoseconds, jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(dayLengthNs)));\n        return { days: jsbi__WEBPACK_IMPORTED_MODULE_0__.toNumber(days), nanoseconds, dayLengthNs };\n    }\n    const startNs = GetSlot(relativeTo, EPOCHNANOSECONDS);\n    const start = GetSlot(relativeTo, INSTANT);\n    const endNs = jsbi__WEBPACK_IMPORTED_MODULE_0__.add(startNs, nanoseconds);\n    const end = new TemporalInstant(endNs);\n    const timeZone = GetSlot(relativeTo, TIME_ZONE);\n    const calendar = GetSlot(relativeTo, CALENDAR);\n    // Find the difference in days only.\n    const dtStart = BuiltinTimeZoneGetPlainDateTimeFor(timeZone, start, calendar);\n    const dtEnd = BuiltinTimeZoneGetPlainDateTimeFor(timeZone, end, calendar);\n    let { days } = DifferenceISODateTime(GetSlot(dtStart, ISO_YEAR), GetSlot(dtStart, ISO_MONTH), GetSlot(dtStart, ISO_DAY), GetSlot(dtStart, ISO_HOUR), GetSlot(dtStart, ISO_MINUTE), GetSlot(dtStart, ISO_SECOND), GetSlot(dtStart, ISO_MILLISECOND), GetSlot(dtStart, ISO_MICROSECOND), GetSlot(dtStart, ISO_NANOSECOND), GetSlot(dtEnd, ISO_YEAR), GetSlot(dtEnd, ISO_MONTH), GetSlot(dtEnd, ISO_DAY), GetSlot(dtEnd, ISO_HOUR), GetSlot(dtEnd, ISO_MINUTE), GetSlot(dtEnd, ISO_SECOND), GetSlot(dtEnd, ISO_MILLISECOND), GetSlot(dtEnd, ISO_MICROSECOND), GetSlot(dtEnd, ISO_NANOSECOND), calendar, 'day');\n    let intermediateNs = AddZonedDateTime(start, timeZone, calendar, 0, 0, 0, days, 0, 0, 0, 0, 0, 0);\n    // may disambiguate\n    // If clock time after addition was in the middle of a skipped period, the\n    // endpoint was disambiguated to a later clock time. So it's possible that\n    // the resulting disambiguated result is later than endNs. If so, then back\n    // up one day and try again. Repeat if necessary (some transitions are\n    // > 24 hours) until either there's zero days left or the date duration is\n    // back inside the period where it belongs. Note that this case only can\n    // happen for positive durations because the only direction that\n    // `disambiguation: 'compatible'` can change clock time is forwards.\n    if (sign === 1) {\n        while (days > 0 && jsbi__WEBPACK_IMPORTED_MODULE_0__.greaterThan(intermediateNs, endNs)) {\n            --days;\n            intermediateNs = AddZonedDateTime(start, timeZone, calendar, 0, 0, 0, days, 0, 0, 0, 0, 0, 0);\n            // may do disambiguation\n        }\n    }\n    nanoseconds = jsbi__WEBPACK_IMPORTED_MODULE_0__.subtract(endNs, intermediateNs);\n    let isOverflow = false;\n    let relativeInstant = new TemporalInstant(intermediateNs);\n    do {\n        // calculate length of the next day (day that contains the time remainder)\n        const oneDayFartherNs = AddZonedDateTime(relativeInstant, timeZone, calendar, 0, 0, 0, sign, 0, 0, 0, 0, 0, 0);\n        const relativeNs = GetSlot(relativeInstant, EPOCHNANOSECONDS);\n        dayLengthNs = jsbi__WEBPACK_IMPORTED_MODULE_0__.toNumber(jsbi__WEBPACK_IMPORTED_MODULE_0__.subtract(oneDayFartherNs, relativeNs));\n        isOverflow = jsbi__WEBPACK_IMPORTED_MODULE_0__.greaterThan(jsbi__WEBPACK_IMPORTED_MODULE_0__.multiply(jsbi__WEBPACK_IMPORTED_MODULE_0__.subtract(nanoseconds, jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(dayLengthNs)), jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(sign)), ZERO);\n        if (isOverflow) {\n            nanoseconds = jsbi__WEBPACK_IMPORTED_MODULE_0__.subtract(nanoseconds, jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(dayLengthNs));\n            relativeInstant = new TemporalInstant(oneDayFartherNs);\n            days += sign;\n        }\n    } while (isOverflow);\n    return { days, nanoseconds, dayLengthNs: MathAbs(dayLengthNs) };\n}\nfunction BalanceDuration(daysParam, hoursParam, minutesParam, secondsParam, millisecondsParam, microsecondsParam, nanosecondsParam, largestUnit, relativeTo = undefined) {\n    let days = daysParam;\n    let nanosecondsBigInt, microsecondsBigInt, millisecondsBigInt, secondsBigInt, minutesBigInt, hoursBigInt;\n    if (IsTemporalZonedDateTime(relativeTo)) {\n        const endNs = AddZonedDateTime(GetSlot(relativeTo, INSTANT), GetSlot(relativeTo, TIME_ZONE), GetSlot(relativeTo, CALENDAR), 0, 0, 0, days, hoursParam, minutesParam, secondsParam, millisecondsParam, microsecondsParam, nanosecondsParam);\n        const startNs = GetSlot(relativeTo, EPOCHNANOSECONDS);\n        nanosecondsBigInt = jsbi__WEBPACK_IMPORTED_MODULE_0__.subtract(endNs, startNs);\n    }\n    else {\n        nanosecondsBigInt = TotalDurationNanoseconds(days, hoursParam, minutesParam, secondsParam, millisecondsParam, microsecondsParam, nanosecondsParam, 0);\n    }\n    if (largestUnit === 'year' || largestUnit === 'month' || largestUnit === 'week' || largestUnit === 'day') {\n        ({ days, nanoseconds: nanosecondsBigInt } = NanosecondsToDays(nanosecondsBigInt, relativeTo));\n    }\n    else {\n        days = 0;\n    }\n    const sign = jsbi__WEBPACK_IMPORTED_MODULE_0__.lessThan(nanosecondsBigInt, ZERO) ? -1 : 1;\n    nanosecondsBigInt = abs(nanosecondsBigInt);\n    microsecondsBigInt = millisecondsBigInt = secondsBigInt = minutesBigInt = hoursBigInt = ZERO;\n    switch (largestUnit) {\n        case 'year':\n        case 'month':\n        case 'week':\n        case 'day':\n        case 'hour':\n            ({ quotient: microsecondsBigInt, remainder: nanosecondsBigInt } = divmod(nanosecondsBigInt, THOUSAND));\n            ({ quotient: millisecondsBigInt, remainder: microsecondsBigInt } = divmod(microsecondsBigInt, THOUSAND));\n            ({ quotient: secondsBigInt, remainder: millisecondsBigInt } = divmod(millisecondsBigInt, THOUSAND));\n            ({ quotient: minutesBigInt, remainder: secondsBigInt } = divmod(secondsBigInt, SIXTY));\n            ({ quotient: hoursBigInt, remainder: minutesBigInt } = divmod(minutesBigInt, SIXTY));\n            break;\n        case 'minute':\n            ({ quotient: microsecondsBigInt, remainder: nanosecondsBigInt } = divmod(nanosecondsBigInt, THOUSAND));\n            ({ quotient: millisecondsBigInt, remainder: microsecondsBigInt } = divmod(microsecondsBigInt, THOUSAND));\n            ({ quotient: secondsBigInt, remainder: millisecondsBigInt } = divmod(millisecondsBigInt, THOUSAND));\n            ({ quotient: minutesBigInt, remainder: secondsBigInt } = divmod(secondsBigInt, SIXTY));\n            break;\n        case 'second':\n            ({ quotient: microsecondsBigInt, remainder: nanosecondsBigInt } = divmod(nanosecondsBigInt, THOUSAND));\n            ({ quotient: millisecondsBigInt, remainder: microsecondsBigInt } = divmod(microsecondsBigInt, THOUSAND));\n            ({ quotient: secondsBigInt, remainder: millisecondsBigInt } = divmod(millisecondsBigInt, THOUSAND));\n            break;\n        case 'millisecond':\n            ({ quotient: microsecondsBigInt, remainder: nanosecondsBigInt } = divmod(nanosecondsBigInt, THOUSAND));\n            ({ quotient: millisecondsBigInt, remainder: microsecondsBigInt } = divmod(microsecondsBigInt, THOUSAND));\n            break;\n        case 'microsecond':\n            ({ quotient: microsecondsBigInt, remainder: nanosecondsBigInt } = divmod(nanosecondsBigInt, THOUSAND));\n            break;\n        case 'nanosecond':\n            break;\n        default:\n            throw new Error('assert not reached');\n    }\n    const hours = jsbi__WEBPACK_IMPORTED_MODULE_0__.toNumber(hoursBigInt) * sign;\n    const minutes = jsbi__WEBPACK_IMPORTED_MODULE_0__.toNumber(minutesBigInt) * sign;\n    const seconds = jsbi__WEBPACK_IMPORTED_MODULE_0__.toNumber(secondsBigInt) * sign;\n    const milliseconds = jsbi__WEBPACK_IMPORTED_MODULE_0__.toNumber(millisecondsBigInt) * sign;\n    const microseconds = jsbi__WEBPACK_IMPORTED_MODULE_0__.toNumber(microsecondsBigInt) * sign;\n    const nanoseconds = jsbi__WEBPACK_IMPORTED_MODULE_0__.toNumber(nanosecondsBigInt) * sign;\n    return { days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds };\n}\nfunction UnbalanceDurationRelative(yearsParam, monthsParam, weeksParam, daysParam, largestUnit, relativeToParam) {\n    let years = yearsParam;\n    let months = monthsParam;\n    let weeks = weeksParam;\n    let days = daysParam;\n    const TemporalDuration = GetIntrinsic('%Temporal.Duration%');\n    const sign = DurationSign(years, months, weeks, days, 0, 0, 0, 0, 0, 0);\n    let calendar;\n    let relativeTo;\n    if (relativeToParam) {\n        relativeTo = ToTemporalDate(relativeToParam);\n        calendar = GetSlot(relativeTo, CALENDAR);\n    }\n    const oneYear = new TemporalDuration(sign);\n    const oneMonth = new TemporalDuration(0, sign);\n    const oneWeek = new TemporalDuration(0, 0, sign);\n    switch (largestUnit) {\n        case 'year':\n            // no-op\n            break;\n        case 'month':\n            {\n                if (!calendar)\n                    throw new RangeError('a starting point is required for months balancing');\n                // balance years down to months\n                const dateAdd = calendar.dateAdd;\n                const dateUntil = calendar.dateUntil;\n                let relativeToDateOnly = relativeTo;\n                while (MathAbs(years) > 0) {\n                    const addOptions = ObjectCreate$2(null);\n                    const newRelativeTo = CalendarDateAdd(calendar, relativeToDateOnly, oneYear, addOptions, dateAdd);\n                    const untilOptions = ObjectCreate$2(null);\n                    untilOptions.largestUnit = 'month';\n                    const untilResult = CalendarDateUntil(calendar, relativeToDateOnly, newRelativeTo, untilOptions, dateUntil);\n                    const oneYearMonths = GetSlot(untilResult, MONTHS);\n                    relativeToDateOnly = newRelativeTo;\n                    months += oneYearMonths;\n                    years -= sign;\n                }\n            }\n            break;\n        case 'week':\n            if (!calendar)\n                throw new RangeError('a starting point is required for weeks balancing');\n            // balance years down to days\n            while (MathAbs(years) > 0) {\n                let oneYearDays;\n                ({ relativeTo, days: oneYearDays } = MoveRelativeDate(calendar, relativeTo, oneYear));\n                days += oneYearDays;\n                years -= sign;\n            }\n            // balance months down to days\n            while (MathAbs(months) > 0) {\n                let oneMonthDays;\n                ({ relativeTo, days: oneMonthDays } = MoveRelativeDate(calendar, relativeTo, oneMonth));\n                days += oneMonthDays;\n                months -= sign;\n            }\n            break;\n        default:\n            // balance years down to days\n            while (MathAbs(years) > 0) {\n                if (!calendar)\n                    throw new RangeError('a starting point is required for balancing calendar units');\n                let oneYearDays;\n                ({ relativeTo, days: oneYearDays } = MoveRelativeDate(calendar, relativeTo, oneYear));\n                days += oneYearDays;\n                years -= sign;\n            }\n            // balance months down to days\n            while (MathAbs(months) > 0) {\n                if (!calendar)\n                    throw new RangeError('a starting point is required for balancing calendar units');\n                let oneMonthDays;\n                ({ relativeTo, days: oneMonthDays } = MoveRelativeDate(calendar, relativeTo, oneMonth));\n                days += oneMonthDays;\n                months -= sign;\n            }\n            // balance weeks down to days\n            while (MathAbs(weeks) > 0) {\n                if (!calendar)\n                    throw new RangeError('a starting point is required for balancing calendar units');\n                let oneWeekDays;\n                ({ relativeTo, days: oneWeekDays } = MoveRelativeDate(calendar, relativeTo, oneWeek));\n                days += oneWeekDays;\n                weeks -= sign;\n            }\n            break;\n    }\n    return { years, months, weeks, days };\n}\nfunction BalanceDurationRelative(yearsParam, monthsParam, weeksParam, daysParam, largestUnit, relativeToParam) {\n    let years = yearsParam;\n    let months = monthsParam;\n    let weeks = weeksParam;\n    let days = daysParam;\n    const TemporalDuration = GetIntrinsic('%Temporal.Duration%');\n    const sign = DurationSign(years, months, weeks, days, 0, 0, 0, 0, 0, 0);\n    if (sign === 0)\n        return { years, months, weeks, days };\n    let calendar;\n    let relativeTo;\n    if (relativeToParam) {\n        relativeTo = ToTemporalDate(relativeToParam);\n        calendar = GetSlot(relativeTo, CALENDAR);\n    }\n    const oneYear = new TemporalDuration(sign);\n    const oneMonth = new TemporalDuration(0, sign);\n    const oneWeek = new TemporalDuration(0, 0, sign);\n    switch (largestUnit) {\n        case 'year': {\n            if (!calendar)\n                throw new RangeError('a starting point is required for years balancing');\n            // balance days up to years\n            let newRelativeTo, oneYearDays;\n            ({ relativeTo: newRelativeTo, days: oneYearDays } = MoveRelativeDate(calendar, relativeTo, oneYear));\n            while (MathAbs(days) >= MathAbs(oneYearDays)) {\n                days -= oneYearDays;\n                years += sign;\n                relativeTo = newRelativeTo;\n                ({ relativeTo: newRelativeTo, days: oneYearDays } = MoveRelativeDate(calendar, relativeTo, oneYear));\n            }\n            // balance days up to months\n            let oneMonthDays;\n            ({ relativeTo: newRelativeTo, days: oneMonthDays } = MoveRelativeDate(calendar, relativeTo, oneMonth));\n            while (MathAbs(days) >= MathAbs(oneMonthDays)) {\n                days -= oneMonthDays;\n                months += sign;\n                relativeTo = newRelativeTo;\n                ({ relativeTo: newRelativeTo, days: oneMonthDays } = MoveRelativeDate(calendar, relativeTo, oneMonth));\n            }\n            // balance months up to years\n            const dateAdd = calendar.dateAdd;\n            const addOptions = ObjectCreate$2(null);\n            newRelativeTo = CalendarDateAdd(calendar, relativeTo, oneYear, addOptions, dateAdd);\n            const dateUntil = calendar.dateUntil;\n            const untilOptions = ObjectCreate$2(null);\n            untilOptions.largestUnit = 'month';\n            let untilResult = CalendarDateUntil(calendar, relativeTo, newRelativeTo, untilOptions, dateUntil);\n            let oneYearMonths = GetSlot(untilResult, MONTHS);\n            while (MathAbs(months) >= MathAbs(oneYearMonths)) {\n                months -= oneYearMonths;\n                years += sign;\n                relativeTo = newRelativeTo;\n                const addOptions = ObjectCreate$2(null);\n                newRelativeTo = CalendarDateAdd(calendar, relativeTo, oneYear, addOptions, dateAdd);\n                const untilOptions = ObjectCreate$2(null);\n                untilOptions.largestUnit = 'month';\n                untilResult = CalendarDateUntil(calendar, relativeTo, newRelativeTo, untilOptions, dateUntil);\n                oneYearMonths = GetSlot(untilResult, MONTHS);\n            }\n            break;\n        }\n        case 'month': {\n            if (!calendar)\n                throw new RangeError('a starting point is required for months balancing');\n            // balance days up to months\n            let newRelativeTo, oneMonthDays;\n            ({ relativeTo: newRelativeTo, days: oneMonthDays } = MoveRelativeDate(calendar, relativeTo, oneMonth));\n            while (MathAbs(days) >= MathAbs(oneMonthDays)) {\n                days -= oneMonthDays;\n                months += sign;\n                relativeTo = newRelativeTo;\n                ({ relativeTo: newRelativeTo, days: oneMonthDays } = MoveRelativeDate(calendar, relativeTo, oneMonth));\n            }\n            break;\n        }\n        case 'week': {\n            if (!calendar)\n                throw new RangeError('a starting point is required for weeks balancing');\n            // balance days up to weeks\n            let newRelativeTo, oneWeekDays;\n            ({ relativeTo: newRelativeTo, days: oneWeekDays } = MoveRelativeDate(calendar, relativeTo, oneWeek));\n            while (MathAbs(days) >= MathAbs(oneWeekDays)) {\n                days -= oneWeekDays;\n                weeks += sign;\n                relativeTo = newRelativeTo;\n                ({ relativeTo: newRelativeTo, days: oneWeekDays } = MoveRelativeDate(calendar, relativeTo, oneWeek));\n            }\n            break;\n        }\n    }\n    return { years, months, weeks, days };\n}\nfunction CalculateOffsetShift(relativeTo, y, mon, w, d, h, min, s, ms, s, ns) {\n    if (IsTemporalZonedDateTime(relativeTo)) {\n        const instant = GetSlot(relativeTo, INSTANT);\n        const timeZone = GetSlot(relativeTo, TIME_ZONE);\n        const calendar = GetSlot(relativeTo, CALENDAR);\n        const offsetBefore = GetOffsetNanosecondsFor(timeZone, instant);\n        const after = AddZonedDateTime(instant, timeZone, calendar, y, mon, w, d, h, min, s, ms, s, ns);\n        const TemporalInstant = GetIntrinsic('%Temporal.Instant%');\n        const instantAfter = new TemporalInstant(after);\n        const offsetAfter = GetOffsetNanosecondsFor(timeZone, instantAfter);\n        return offsetAfter - offsetBefore;\n    }\n    return 0;\n}\nfunction CreateNegatedTemporalDuration(duration) {\n    const TemporalDuration = GetIntrinsic('%Temporal.Duration%');\n    return new TemporalDuration(-GetSlot(duration, YEARS), -GetSlot(duration, MONTHS), -GetSlot(duration, WEEKS), -GetSlot(duration, DAYS), -GetSlot(duration, HOURS), -GetSlot(duration, MINUTES), -GetSlot(duration, SECONDS), -GetSlot(duration, MILLISECONDS), -GetSlot(duration, MICROSECONDS), -GetSlot(duration, NANOSECONDS));\n}\nfunction ConstrainToRange(value, min, max) {\n    // Math.Max accepts undefined values and returns NaN. Undefined values are\n    // used for optional params in the method below.\n    return MathMin(max, MathMax(min, value));\n}\nfunction ConstrainISODate(year, monthParam, dayParam) {\n    const month = ConstrainToRange(monthParam, 1, 12);\n    const day = ConstrainToRange(dayParam, 1, ISODaysInMonth(year, month));\n    return { year, month, day };\n}\nfunction ConstrainTime(hourParam, minuteParam, secondParam, millisecondParam, microsecondParam, nanosecondParam) {\n    const hour = ConstrainToRange(hourParam, 0, 23);\n    const minute = ConstrainToRange(minuteParam, 0, 59);\n    const second = ConstrainToRange(secondParam, 0, 59);\n    const millisecond = ConstrainToRange(millisecondParam, 0, 999);\n    const microsecond = ConstrainToRange(microsecondParam, 0, 999);\n    const nanosecond = ConstrainToRange(nanosecondParam, 0, 999);\n    return { hour, minute, second, millisecond, microsecond, nanosecond };\n}\nfunction RejectToRange(value, min, max) {\n    if (value < min || value > max)\n        throw new RangeError(`value out of range: ${min} <= ${value} <= ${max}`);\n}\nfunction RejectISODate(year, month, day) {\n    RejectToRange(month, 1, 12);\n    RejectToRange(day, 1, ISODaysInMonth(year, month));\n}\nfunction RejectDateRange(year, month, day) {\n    // Noon avoids trouble at edges of DateTime range (excludes midnight)\n    RejectDateTimeRange(year, month, day, 12, 0, 0, 0, 0, 0);\n}\nfunction RejectTime(hour, minute, second, millisecond, microsecond, nanosecond) {\n    RejectToRange(hour, 0, 23);\n    RejectToRange(minute, 0, 59);\n    RejectToRange(second, 0, 59);\n    RejectToRange(millisecond, 0, 999);\n    RejectToRange(microsecond, 0, 999);\n    RejectToRange(nanosecond, 0, 999);\n}\nfunction RejectDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond) {\n    RejectISODate(year, month, day);\n    RejectTime(hour, minute, second, millisecond, microsecond, nanosecond);\n}\nfunction RejectDateTimeRange(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond) {\n    RejectToRange(year, YEAR_MIN, YEAR_MAX);\n    // Reject any DateTime 24 hours or more outside the Instant range\n    if ((year === YEAR_MIN &&\n        null ==\n            GetEpochFromISOParts(year, month, day + 1, hour, minute, second, millisecond, microsecond, nanosecond - 1)) ||\n        (year === YEAR_MAX &&\n            null ==\n                GetEpochFromISOParts(year, month, day - 1, hour, minute, second, millisecond, microsecond, nanosecond + 1))) {\n        throw new RangeError('DateTime outside of supported range');\n    }\n}\nfunction ValidateEpochNanoseconds(epochNanoseconds) {\n    if (jsbi__WEBPACK_IMPORTED_MODULE_0__.lessThan(epochNanoseconds, NS_MIN) || jsbi__WEBPACK_IMPORTED_MODULE_0__.greaterThan(epochNanoseconds, NS_MAX)) {\n        throw new RangeError('Instant outside of supported range');\n    }\n}\nfunction RejectYearMonthRange(year, month) {\n    RejectToRange(year, YEAR_MIN, YEAR_MAX);\n    if (year === YEAR_MIN) {\n        RejectToRange(month, 4, 12);\n    }\n    else if (year === YEAR_MAX) {\n        RejectToRange(month, 1, 9);\n    }\n}\nfunction RejectDuration(y, mon, w, d, h, min, s, ms, s, ns) {\n    const sign = DurationSign(y, mon, w, d, h, min, s, ms, s, ns);\n    for (const prop of [y, mon, w, d, h, min, s, ms, s, ns]) {\n        if (!NumberIsFinite(prop))\n            throw new RangeError('infinite values not allowed as duration fields');\n        const propSign = MathSign(prop);\n        if (propSign !== 0 && propSign !== sign)\n            throw new RangeError('mixed-sign values not allowed as duration fields');\n    }\n}\nfunction DifferenceISODate(y1, m1, d1, y2, m2, d2, largestUnit) {\n    switch (largestUnit) {\n        case 'year':\n        case 'month': {\n            const sign = -CompareISODate(y1, m1, d1, y2, m2, d2);\n            if (sign === 0)\n                return { years: 0, months: 0, weeks: 0, days: 0 };\n            const start = { year: y1, month: m1, day: d1 };\n            const end = { year: y2, month: m2, day: d2 };\n            let years = end.year - start.year;\n            let mid = AddISODate(y1, m1, d1, years, 0, 0, 0, 'constrain');\n            let midSign = -CompareISODate(mid.year, mid.month, mid.day, y2, m2, d2);\n            if (midSign === 0) {\n                return largestUnit === 'year'\n                    ? { years, months: 0, weeks: 0, days: 0 }\n                    : { years: 0, months: years * 12, weeks: 0, days: 0 };\n            }\n            let months = end.month - start.month;\n            if (midSign !== sign) {\n                years -= sign;\n                months += sign * 12;\n            }\n            mid = AddISODate(y1, m1, d1, years, months, 0, 0, 'constrain');\n            midSign = -CompareISODate(mid.year, mid.month, mid.day, y2, m2, d2);\n            if (midSign === 0) {\n                return largestUnit === 'year'\n                    ? { years, months, weeks: 0, days: 0 }\n                    : { years: 0, months: months + years * 12, weeks: 0, days: 0 };\n            }\n            if (midSign !== sign) {\n                // The end date is later in the month than mid date (or earlier for\n                // negative durations). Back up one month.\n                months -= sign;\n                if (months === -sign) {\n                    years -= sign;\n                    months = 11 * sign;\n                }\n                mid = AddISODate(y1, m1, d1, years, months, 0, 0, 'constrain');\n                midSign = -CompareISODate(y1, m1, d1, mid.year, mid.month, mid.day);\n            }\n            let days = 0;\n            // If we get here, months and years are correct (no overflow), and `mid`\n            // is within the range from `start` to `end`. To count the days between\n            // `mid` and `end`, there are 3 cases:\n            // 1) same month: use simple subtraction\n            // 2) end is previous month from intermediate (negative duration)\n            // 3) end is next month from intermediate (positive duration)\n            if (mid.month === end.month) {\n                // 1) same month: use simple subtraction\n                days = end.day - mid.day;\n            }\n            else if (sign < 0) {\n                // 2) end is previous month from intermediate (negative duration)\n                // Example: intermediate: Feb 1, end: Jan 30, DaysInMonth = 31, days = -2\n                days = -mid.day - (ISODaysInMonth(end.year, end.month) - end.day);\n            }\n            else {\n                // 3) end is next month from intermediate (positive duration)\n                // Example: intermediate: Jan 29, end: Feb 1, DaysInMonth = 31, days = 3\n                days = end.day + (ISODaysInMonth(mid.year, mid.month) - mid.day);\n            }\n            if (largestUnit === 'month') {\n                months += years * 12;\n                years = 0;\n            }\n            return { years, months, weeks: 0, days };\n        }\n        case 'week':\n        case 'day': {\n            let larger, smaller, sign;\n            if (CompareISODate(y1, m1, d1, y2, m2, d2) < 0) {\n                smaller = { year: y1, month: m1, day: d1 };\n                larger = { year: y2, month: m2, day: d2 };\n                sign = 1;\n            }\n            else {\n                smaller = { year: y2, month: m2, day: d2 };\n                larger = { year: y1, month: m1, day: d1 };\n                sign = -1;\n            }\n            let days = DayOfYear(larger.year, larger.month, larger.day) - DayOfYear(smaller.year, smaller.month, smaller.day);\n            for (let year = smaller.year; year < larger.year; ++year) {\n                days += LeapYear(year) ? 366 : 365;\n            }\n            let weeks = 0;\n            if (largestUnit === 'week') {\n                weeks = MathFloor(days / 7);\n                days %= 7;\n            }\n            weeks *= sign;\n            days *= sign;\n            return { years: 0, months: 0, weeks, days };\n        }\n        default:\n            throw new Error('assert not reached');\n    }\n}\nfunction DifferenceTime(h1, min1, s1, ms1, s1, ns1, h2, min2, s2, ms2, s2, ns2) {\n    let hours = h2 - h1;\n    let minutes = min2 - min1;\n    let seconds = s2 - s1;\n    let milliseconds = ms2 - ms1;\n    let microseconds = s2 - s1;\n    let nanoseconds = ns2 - ns1;\n    const sign = DurationSign(0, 0, 0, 0, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n    hours *= sign;\n    minutes *= sign;\n    seconds *= sign;\n    milliseconds *= sign;\n    microseconds *= sign;\n    nanoseconds *= sign;\n    let deltaDays = 0;\n    ({\n        deltaDays,\n        hour: hours,\n        minute: minutes,\n        second: seconds,\n        millisecond: milliseconds,\n        microsecond: microseconds,\n        nanosecond: nanoseconds\n    } = BalanceTime(hours, minutes, seconds, milliseconds, microseconds, nanoseconds));\n    deltaDays *= sign;\n    hours *= sign;\n    minutes *= sign;\n    seconds *= sign;\n    milliseconds *= sign;\n    microseconds *= sign;\n    nanoseconds *= sign;\n    return { deltaDays, hours, minutes, seconds, milliseconds, microseconds, nanoseconds };\n}\nfunction DifferenceInstant(ns1, ns2, increment, unit, roundingMode) {\n    const diff = jsbi__WEBPACK_IMPORTED_MODULE_0__.subtract(ns2, ns1);\n    const remainder = jsbi__WEBPACK_IMPORTED_MODULE_0__.remainder(diff, jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(86400e9));\n    const wholeDays = jsbi__WEBPACK_IMPORTED_MODULE_0__.subtract(diff, remainder);\n    const roundedRemainder = RoundNumberToIncrement(remainder, nsPerTimeUnit[unit] * increment, roundingMode);\n    const roundedDiff = jsbi__WEBPACK_IMPORTED_MODULE_0__.add(wholeDays, roundedRemainder);\n    const nanoseconds = jsbi__WEBPACK_IMPORTED_MODULE_0__.toNumber(jsbi__WEBPACK_IMPORTED_MODULE_0__.remainder(roundedDiff, THOUSAND));\n    const microseconds = jsbi__WEBPACK_IMPORTED_MODULE_0__.toNumber(jsbi__WEBPACK_IMPORTED_MODULE_0__.remainder(jsbi__WEBPACK_IMPORTED_MODULE_0__.divide(roundedDiff, THOUSAND), THOUSAND));\n    const milliseconds = jsbi__WEBPACK_IMPORTED_MODULE_0__.toNumber(jsbi__WEBPACK_IMPORTED_MODULE_0__.remainder(jsbi__WEBPACK_IMPORTED_MODULE_0__.divide(roundedDiff, MILLION), THOUSAND));\n    const seconds = jsbi__WEBPACK_IMPORTED_MODULE_0__.toNumber(jsbi__WEBPACK_IMPORTED_MODULE_0__.divide(roundedDiff, BILLION));\n    return { seconds, milliseconds, microseconds, nanoseconds };\n}\nfunction DifferenceISODateTime(y1Param, mon1Param, d1Param, h1, min1, s1, ms1, s1, ns1, y2, mon2, d2, h2, min2, s2, ms2, s2, ns2, calendar, largestUnit, options = ObjectCreate$2(null)) {\n    let y1 = y1Param;\n    let mon1 = mon1Param;\n    let d1 = d1Param;\n    let { deltaDays, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = DifferenceTime(h1, min1, s1, ms1, s1, ns1, h2, min2, s2, ms2, s2, ns2);\n    const timeSign = DurationSign(0, 0, 0, deltaDays, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n    ({ year: y1, month: mon1, day: d1 } = BalanceISODate(y1, mon1, d1 + deltaDays));\n    const dateSign = CompareISODate(y2, mon2, d2, y1, mon1, d1);\n    if (dateSign === -timeSign) {\n        ({ year: y1, month: mon1, day: d1 } = BalanceISODate(y1, mon1, d1 - timeSign));\n        ({ hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = BalanceDuration(-timeSign, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, largestUnit));\n    }\n    const date1 = CreateTemporalDate(y1, mon1, d1, calendar);\n    const date2 = CreateTemporalDate(y2, mon2, d2, calendar);\n    const dateLargestUnit = LargerOfTwoTemporalUnits('day', largestUnit);\n    const untilOptions = { ...options, largestUnit: dateLargestUnit };\n    let { years, months, weeks, days } = CalendarDateUntil(calendar, date1, date2, untilOptions);\n    // Signs of date part and time part may not agree; balance them together\n    ({ days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = BalanceDuration(days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, largestUnit));\n    return { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds };\n}\nfunction DifferenceZonedDateTime(ns1, ns2, timeZone, calendar, largestUnit, options) {\n    const nsDiff = jsbi__WEBPACK_IMPORTED_MODULE_0__.subtract(ns2, ns1);\n    if (jsbi__WEBPACK_IMPORTED_MODULE_0__.equal(nsDiff, ZERO)) {\n        return {\n            years: 0,\n            months: 0,\n            weeks: 0,\n            days: 0,\n            hours: 0,\n            minutes: 0,\n            seconds: 0,\n            milliseconds: 0,\n            microseconds: 0,\n            nanoseconds: 0\n        };\n    }\n    // Find the difference in dates only.\n    const TemporalInstant = GetIntrinsic('%Temporal.Instant%');\n    const start = new TemporalInstant(ns1);\n    const end = new TemporalInstant(ns2);\n    const dtStart = BuiltinTimeZoneGetPlainDateTimeFor(timeZone, start, calendar);\n    const dtEnd = BuiltinTimeZoneGetPlainDateTimeFor(timeZone, end, calendar);\n    let { years, months, weeks, days } = DifferenceISODateTime(GetSlot(dtStart, ISO_YEAR), GetSlot(dtStart, ISO_MONTH), GetSlot(dtStart, ISO_DAY), GetSlot(dtStart, ISO_HOUR), GetSlot(dtStart, ISO_MINUTE), GetSlot(dtStart, ISO_SECOND), GetSlot(dtStart, ISO_MILLISECOND), GetSlot(dtStart, ISO_MICROSECOND), GetSlot(dtStart, ISO_NANOSECOND), GetSlot(dtEnd, ISO_YEAR), GetSlot(dtEnd, ISO_MONTH), GetSlot(dtEnd, ISO_DAY), GetSlot(dtEnd, ISO_HOUR), GetSlot(dtEnd, ISO_MINUTE), GetSlot(dtEnd, ISO_SECOND), GetSlot(dtEnd, ISO_MILLISECOND), GetSlot(dtEnd, ISO_MICROSECOND), GetSlot(dtEnd, ISO_NANOSECOND), calendar, largestUnit, options);\n    const intermediateNs = AddZonedDateTime(start, timeZone, calendar, years, months, weeks, 0, 0, 0, 0, 0, 0, 0);\n    // may disambiguate\n    let timeRemainderNs = jsbi__WEBPACK_IMPORTED_MODULE_0__.subtract(ns2, intermediateNs);\n    const intermediate = CreateTemporalZonedDateTime(intermediateNs, timeZone, calendar);\n    ({ nanoseconds: timeRemainderNs, days } = NanosecondsToDays(timeRemainderNs, intermediate));\n    // Finally, merge the date and time durations and return the merged result.\n    const { hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = BalanceDuration(0, 0, 0, 0, 0, 0, jsbi__WEBPACK_IMPORTED_MODULE_0__.toNumber(timeRemainderNs), 'hour');\n    return { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds };\n}\nfunction AddISODate(yearParam, monthParam, dayParam, yearsParam, monthsParam, weeksParam, daysParam, overflow) {\n    let year = yearParam;\n    let month = monthParam;\n    let day = dayParam;\n    let years = yearsParam;\n    let months = monthsParam;\n    let weeks = weeksParam;\n    let days = daysParam;\n    year += years;\n    month += months;\n    ({ year, month } = BalanceISOYearMonth(year, month));\n    ({ year, month, day } = RegulateISODate(year, month, day, overflow));\n    days += 7 * weeks;\n    day += days;\n    ({ year, month, day } = BalanceISODate(year, month, day));\n    return { year, month, day };\n}\nfunction AddTime(hourParam, minuteParam, secondParam, millisecondParam, microsecondParam, nanosecondParam, hours, minutes, seconds, milliseconds, microseconds, nanoseconds) {\n    let hour = hourParam;\n    let minute = minuteParam;\n    let second = secondParam;\n    let millisecond = millisecondParam;\n    let microsecond = microsecondParam;\n    let nanosecond = nanosecondParam;\n    hour += hours;\n    minute += minutes;\n    second += seconds;\n    millisecond += milliseconds;\n    microsecond += microseconds;\n    nanosecond += nanoseconds;\n    let deltaDays = 0;\n    ({ deltaDays, hour, minute, second, millisecond, microsecond, nanosecond } = BalanceTime(hour, minute, second, millisecond, microsecond, nanosecond));\n    return { deltaDays, hour, minute, second, millisecond, microsecond, nanosecond };\n}\nfunction AddDuration(y1, mon1, w1, d1, h1, min1, s1, ms1, s1, ns1, y2, mon2, w2, d2, h2, min2, s2, ms2, s2, ns2, relativeTo) {\n    const largestUnit1 = DefaultTemporalLargestUnit(y1, mon1, w1, d1, h1, min1, s1, ms1, s1, ns1);\n    const largestUnit2 = DefaultTemporalLargestUnit(y2, mon2, w2, d2, h2, min2, s2, ms2, s2, ns2);\n    const largestUnit = LargerOfTwoTemporalUnits(largestUnit1, largestUnit2);\n    let years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds;\n    if (!relativeTo) {\n        if (largestUnit === 'year' || largestUnit === 'month' || largestUnit === 'week') {\n            throw new RangeError('relativeTo is required for years, months, or weeks arithmetic');\n        }\n        years = months = weeks = 0;\n        ({ days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = BalanceDuration(d1 + d2, h1 + h2, min1 + min2, s1 + s2, ms1 + ms2, s1 + s2, ns1 + ns2, largestUnit));\n    }\n    else if (IsTemporalDate(relativeTo)) {\n        const TemporalDuration = GetIntrinsic('%Temporal.Duration%');\n        const calendar = GetSlot(relativeTo, CALENDAR);\n        const dateDuration1 = new TemporalDuration(y1, mon1, w1, d1, 0, 0, 0, 0, 0, 0);\n        const dateDuration2 = new TemporalDuration(y2, mon2, w2, d2, 0, 0, 0, 0, 0, 0);\n        const dateAdd = calendar.dateAdd;\n        const firstAddOptions = ObjectCreate$2(null);\n        const intermediate = CalendarDateAdd(calendar, relativeTo, dateDuration1, firstAddOptions, dateAdd);\n        const secondAddOptions = ObjectCreate$2(null);\n        const end = CalendarDateAdd(calendar, intermediate, dateDuration2, secondAddOptions, dateAdd);\n        const dateLargestUnit = LargerOfTwoTemporalUnits('day', largestUnit);\n        const differenceOptions = ObjectCreate$2(null);\n        differenceOptions.largestUnit = dateLargestUnit;\n        ({ years, months, weeks, days } = CalendarDateUntil(calendar, relativeTo, end, differenceOptions));\n        // Signs of date part and time part may not agree; balance them together\n        ({ days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = BalanceDuration(days, h1 + h2, min1 + min2, s1 + s2, ms1 + ms2, s1 + s2, ns1 + ns2, largestUnit));\n    }\n    else {\n        // relativeTo is a ZonedDateTime\n        const TemporalInstant = GetIntrinsic('%Temporal.Instant%');\n        const timeZone = GetSlot(relativeTo, TIME_ZONE);\n        const calendar = GetSlot(relativeTo, CALENDAR);\n        const intermediateNs = AddZonedDateTime(GetSlot(relativeTo, INSTANT), timeZone, calendar, y1, mon1, w1, d1, h1, min1, s1, ms1, s1, ns1);\n        const endNs = AddZonedDateTime(new TemporalInstant(intermediateNs), timeZone, calendar, y2, mon2, w2, d2, h2, min2, s2, ms2, s2, ns2);\n        if (largestUnit !== 'year' && largestUnit !== 'month' && largestUnit !== 'week' && largestUnit !== 'day') {\n            // The user is only asking for a time difference, so return difference of instants.\n            years = 0;\n            months = 0;\n            weeks = 0;\n            days = 0;\n            ({ seconds, milliseconds, microseconds, nanoseconds } = DifferenceInstant(GetSlot(relativeTo, EPOCHNANOSECONDS), endNs, 1, 'nanosecond', 'halfExpand'));\n            ({ hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = BalanceDuration(0, 0, 0, seconds, milliseconds, microseconds, nanoseconds, largestUnit));\n        }\n        else {\n            ({ years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } =\n                DifferenceZonedDateTime(GetSlot(relativeTo, EPOCHNANOSECONDS), endNs, timeZone, calendar, largestUnit));\n        }\n    }\n    RejectDuration(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n    return { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds };\n}\nfunction AddInstant(epochNanoseconds, h, min, s, ms, s, ns) {\n    let sum = ZERO;\n    sum = jsbi__WEBPACK_IMPORTED_MODULE_0__.add(sum, jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(ns));\n    sum = jsbi__WEBPACK_IMPORTED_MODULE_0__.add(sum, jsbi__WEBPACK_IMPORTED_MODULE_0__.multiply(jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(s), THOUSAND));\n    sum = jsbi__WEBPACK_IMPORTED_MODULE_0__.add(sum, jsbi__WEBPACK_IMPORTED_MODULE_0__.multiply(jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(ms), MILLION));\n    sum = jsbi__WEBPACK_IMPORTED_MODULE_0__.add(sum, jsbi__WEBPACK_IMPORTED_MODULE_0__.multiply(jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(s), BILLION));\n    sum = jsbi__WEBPACK_IMPORTED_MODULE_0__.add(sum, jsbi__WEBPACK_IMPORTED_MODULE_0__.multiply(jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(min), jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(60 * 1e9)));\n    sum = jsbi__WEBPACK_IMPORTED_MODULE_0__.add(sum, jsbi__WEBPACK_IMPORTED_MODULE_0__.multiply(jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(h), jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(60 * 60 * 1e9)));\n    const result = jsbi__WEBPACK_IMPORTED_MODULE_0__.add(epochNanoseconds, sum);\n    ValidateEpochNanoseconds(result);\n    return result;\n}\nfunction AddDateTime(year, month, day, hourParam, minuteParam, secondParam, millisecondParam, microsecondParam, nanosecondParam, calendar, years, months, weeks, daysParam, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, options) {\n    let days = daysParam;\n    // Add the time part\n    let { deltaDays, hour, minute, second, millisecond, microsecond, nanosecond } = AddTime(hourParam, minuteParam, secondParam, millisecondParam, microsecondParam, nanosecondParam, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n    days += deltaDays;\n    // Delegate the date part addition to the calendar\n    const TemporalDuration = GetIntrinsic('%Temporal.Duration%');\n    const datePart = CreateTemporalDate(year, month, day, calendar);\n    const dateDuration = new TemporalDuration(years, months, weeks, days, 0, 0, 0, 0, 0, 0);\n    const addedDate = CalendarDateAdd(calendar, datePart, dateDuration, options);\n    return {\n        year: GetSlot(addedDate, ISO_YEAR),\n        month: GetSlot(addedDate, ISO_MONTH),\n        day: GetSlot(addedDate, ISO_DAY),\n        hour,\n        minute,\n        second,\n        millisecond,\n        microsecond,\n        nanosecond\n    };\n}\nfunction AddZonedDateTime(instant, timeZone, calendar, years, months, weeks, days, h, min, s, ms, s, ns, options) {\n    // If only time is to be added, then use Instant math. It's not OK to fall\n    // through to the date/time code below because compatible disambiguation in\n    // the PlainDateTime=>Instant conversion will change the offset of any\n    // ZonedDateTime in the repeated clock time after a backwards transition.\n    // When adding/subtracting time units and not dates, this disambiguation is\n    // not expected and so is avoided below via a fast path for time-only\n    // arithmetic.\n    // BTW, this behavior is similar in spirit to offset: 'prefer' in `with`.\n    const TemporalDuration = GetIntrinsic('%Temporal.Duration%');\n    if (DurationSign(years, months, weeks, days, 0, 0, 0, 0, 0, 0) === 0) {\n        return AddInstant(GetSlot(instant, EPOCHNANOSECONDS), h, min, s, ms, s, ns);\n    }\n    // RFC 5545 requires the date portion to be added in calendar days and the\n    // time portion to be added in exact time.\n    const dt = BuiltinTimeZoneGetPlainDateTimeFor(timeZone, instant, calendar);\n    const datePart = CreateTemporalDate(GetSlot(dt, ISO_YEAR), GetSlot(dt, ISO_MONTH), GetSlot(dt, ISO_DAY), calendar);\n    const dateDuration = new TemporalDuration(years, months, weeks, days, 0, 0, 0, 0, 0, 0);\n    const addedDate = CalendarDateAdd(calendar, datePart, dateDuration, options);\n    const dtIntermediate = CreateTemporalDateTime(GetSlot(addedDate, ISO_YEAR), GetSlot(addedDate, ISO_MONTH), GetSlot(addedDate, ISO_DAY), GetSlot(dt, ISO_HOUR), GetSlot(dt, ISO_MINUTE), GetSlot(dt, ISO_SECOND), GetSlot(dt, ISO_MILLISECOND), GetSlot(dt, ISO_MICROSECOND), GetSlot(dt, ISO_NANOSECOND), calendar);\n    // Note that 'compatible' is used below because this disambiguation behavior\n    // is required by RFC 5545.\n    const instantIntermediate = BuiltinTimeZoneGetInstantFor(timeZone, dtIntermediate, 'compatible');\n    return AddInstant(GetSlot(instantIntermediate, EPOCHNANOSECONDS), h, min, s, ms, s, ns);\n}\nfunction RoundNumberToIncrement(quantity, increment, mode) {\n    if (increment === 1)\n        return quantity;\n    let { quotient, remainder } = divmod(quantity, jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(increment));\n    if (jsbi__WEBPACK_IMPORTED_MODULE_0__.equal(remainder, ZERO))\n        return quantity;\n    const sign = jsbi__WEBPACK_IMPORTED_MODULE_0__.lessThan(remainder, ZERO) ? -1 : 1;\n    switch (mode) {\n        case 'ceil':\n            if (sign > 0)\n                quotient = jsbi__WEBPACK_IMPORTED_MODULE_0__.add(quotient, jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(sign));\n            break;\n        case 'floor':\n            if (sign < 0)\n                quotient = jsbi__WEBPACK_IMPORTED_MODULE_0__.add(quotient, jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(sign));\n            break;\n        case 'trunc':\n            // no change needed, because divmod is a truncation\n            break;\n        case 'halfExpand':\n            // \"half up away from zero\"\n            if (jsbi__WEBPACK_IMPORTED_MODULE_0__.toNumber(abs(jsbi__WEBPACK_IMPORTED_MODULE_0__.multiply(remainder, jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(2)))) >= increment) {\n                quotient = jsbi__WEBPACK_IMPORTED_MODULE_0__.add(quotient, jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(sign));\n            }\n            break;\n    }\n    return jsbi__WEBPACK_IMPORTED_MODULE_0__.multiply(quotient, jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(increment));\n}\nfunction RoundInstant(epochNs, increment, unit, roundingMode) {\n    // Note: NonNegativeModulo, but with BigInt\n    let remainder = jsbi__WEBPACK_IMPORTED_MODULE_0__.remainder(epochNs, jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(86400e9));\n    if (jsbi__WEBPACK_IMPORTED_MODULE_0__.lessThan(remainder, ZERO))\n        remainder = jsbi__WEBPACK_IMPORTED_MODULE_0__.add(remainder, jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(86400e9));\n    const wholeDays = jsbi__WEBPACK_IMPORTED_MODULE_0__.subtract(epochNs, remainder);\n    const roundedRemainder = RoundNumberToIncrement(remainder, nsPerTimeUnit[unit] * increment, roundingMode);\n    return jsbi__WEBPACK_IMPORTED_MODULE_0__.add(wholeDays, roundedRemainder);\n}\nfunction RoundISODateTime(yearParam, monthParam, dayParam, hourParam, minuteParam, secondParam, millisecondParam, microsecondParam, nanosecondParam, increment, unit, roundingMode, dayLengthNs = 86400e9) {\n    const { deltaDays, hour, minute, second, millisecond, microsecond, nanosecond } = RoundTime(hourParam, minuteParam, secondParam, millisecondParam, microsecondParam, nanosecondParam, increment, unit, roundingMode, dayLengthNs);\n    const { year, month, day } = BalanceISODate(yearParam, monthParam, dayParam + deltaDays);\n    return { year, month, day, hour, minute, second, millisecond, microsecond, nanosecond };\n}\nfunction RoundTime(hour, minute, second, millisecond, microsecond, nanosecond, increment, unit, roundingMode, dayLengthNs = 86400e9) {\n    let quantity = ZERO;\n    switch (unit) {\n        case 'day':\n        case 'hour':\n            quantity = jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(hour);\n        // fall through\n        case 'minute':\n            quantity = jsbi__WEBPACK_IMPORTED_MODULE_0__.add(jsbi__WEBPACK_IMPORTED_MODULE_0__.multiply(quantity, SIXTY), jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(minute));\n        // fall through\n        case 'second':\n            quantity = jsbi__WEBPACK_IMPORTED_MODULE_0__.add(jsbi__WEBPACK_IMPORTED_MODULE_0__.multiply(quantity, SIXTY), jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(second));\n        // fall through\n        case 'millisecond':\n            quantity = jsbi__WEBPACK_IMPORTED_MODULE_0__.add(jsbi__WEBPACK_IMPORTED_MODULE_0__.multiply(quantity, THOUSAND), jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(millisecond));\n        // fall through\n        case 'microsecond':\n            quantity = jsbi__WEBPACK_IMPORTED_MODULE_0__.add(jsbi__WEBPACK_IMPORTED_MODULE_0__.multiply(quantity, THOUSAND), jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(microsecond));\n        // fall through\n        case 'nanosecond':\n            quantity = jsbi__WEBPACK_IMPORTED_MODULE_0__.add(jsbi__WEBPACK_IMPORTED_MODULE_0__.multiply(quantity, THOUSAND), jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(nanosecond));\n    }\n    const nsPerUnit = unit === 'day' ? dayLengthNs : nsPerTimeUnit[unit];\n    const rounded = RoundNumberToIncrement(quantity, nsPerUnit * increment, roundingMode);\n    const result = jsbi__WEBPACK_IMPORTED_MODULE_0__.toNumber(jsbi__WEBPACK_IMPORTED_MODULE_0__.divide(rounded, jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(nsPerUnit)));\n    switch (unit) {\n        case 'day':\n            return { deltaDays: result, hour: 0, minute: 0, second: 0, millisecond: 0, microsecond: 0, nanosecond: 0 };\n        case 'hour':\n            return BalanceTime(result, 0, 0, 0, 0, 0);\n        case 'minute':\n            return BalanceTime(hour, result, 0, 0, 0, 0);\n        case 'second':\n            return BalanceTime(hour, minute, result, 0, 0, 0);\n        case 'millisecond':\n            return BalanceTime(hour, minute, second, result, 0, 0);\n        case 'microsecond':\n            return BalanceTime(hour, minute, second, millisecond, result, 0);\n        case 'nanosecond':\n            return BalanceTime(hour, minute, second, millisecond, microsecond, result);\n        default:\n            throw new Error(`Invalid unit ${unit}`);\n    }\n}\nfunction DaysUntil(earlier, later) {\n    return DifferenceISODate(GetSlot(earlier, ISO_YEAR), GetSlot(earlier, ISO_MONTH), GetSlot(earlier, ISO_DAY), GetSlot(later, ISO_YEAR), GetSlot(later, ISO_MONTH), GetSlot(later, ISO_DAY), 'day').days;\n}\nfunction MoveRelativeDate(calendar, relativeToParam, duration) {\n    const options = ObjectCreate$2(null);\n    const later = CalendarDateAdd(calendar, relativeToParam, duration, options);\n    const days = DaysUntil(relativeToParam, later);\n    return { relativeTo: later, days };\n}\nfunction MoveRelativeZonedDateTime(relativeTo, years, months, weeks, days) {\n    const timeZone = GetSlot(relativeTo, TIME_ZONE);\n    const calendar = GetSlot(relativeTo, CALENDAR);\n    const intermediateNs = AddZonedDateTime(GetSlot(relativeTo, INSTANT), timeZone, calendar, years, months, weeks, days, 0, 0, 0, 0, 0, 0);\n    return CreateTemporalZonedDateTime(intermediateNs, timeZone, calendar);\n}\nfunction AdjustRoundedDurationDays(yearsParam, monthsParam, weeksParam, daysParam, hoursParam, minutesParam, secondsParam, millisecondsParam, microsecondsParam, nanosecondsParam, increment, unit, roundingMode, relativeTo) {\n    let years = yearsParam;\n    let months = monthsParam;\n    let weeks = weeksParam;\n    let days = daysParam;\n    let hours = hoursParam;\n    let minutes = minutesParam;\n    let seconds = secondsParam;\n    let milliseconds = millisecondsParam;\n    let microseconds = microsecondsParam;\n    let nanoseconds = nanosecondsParam;\n    if (!IsTemporalZonedDateTime(relativeTo) ||\n        unit === 'year' ||\n        unit === 'month' ||\n        unit === 'week' ||\n        unit === 'day' ||\n        (unit === 'nanosecond' && increment === 1)) {\n        return { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds };\n    }\n    // There's one more round of rounding possible: if relativeTo is a\n    // ZonedDateTime, the time units could have rounded up into enough hours\n    // to exceed the day length. If this happens, grow the date part by a\n    // single day and re-run exact time rounding on the smaller remainder. DO\n    // NOT RECURSE, because once the extra hours are sucked up into the date\n    // duration, there's no way for another full day to come from the next\n    // round of rounding. And if it were possible (e.g. contrived calendar\n    // with 30-minute-long \"days\") then it'd risk an infinite loop.\n    let timeRemainderNs = TotalDurationNanoseconds(0, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, 0);\n    const direction = MathSign(jsbi__WEBPACK_IMPORTED_MODULE_0__.toNumber(timeRemainderNs));\n    const timeZone = GetSlot(relativeTo, TIME_ZONE);\n    const calendar = GetSlot(relativeTo, CALENDAR);\n    const dayStart = AddZonedDateTime(GetSlot(relativeTo, INSTANT), timeZone, calendar, years, months, weeks, days, 0, 0, 0, 0, 0, 0);\n    const TemporalInstant = GetIntrinsic('%Temporal.Instant%');\n    const dayEnd = AddZonedDateTime(new TemporalInstant(dayStart), timeZone, calendar, 0, 0, 0, direction, 0, 0, 0, 0, 0, 0);\n    const dayLengthNs = jsbi__WEBPACK_IMPORTED_MODULE_0__.subtract(dayEnd, dayStart);\n    if (jsbi__WEBPACK_IMPORTED_MODULE_0__.greaterThanOrEqual(jsbi__WEBPACK_IMPORTED_MODULE_0__.multiply(jsbi__WEBPACK_IMPORTED_MODULE_0__.subtract(timeRemainderNs, dayLengthNs), jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(direction)), ZERO)) {\n        ({ years, months, weeks, days } = AddDuration(years, months, weeks, days, 0, 0, 0, 0, 0, 0, 0, 0, 0, direction, 0, 0, 0, 0, 0, 0, relativeTo));\n        timeRemainderNs = RoundInstant(jsbi__WEBPACK_IMPORTED_MODULE_0__.subtract(timeRemainderNs, dayLengthNs), increment, unit, roundingMode);\n        ({ hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = BalanceDuration(0, 0, 0, 0, 0, 0, jsbi__WEBPACK_IMPORTED_MODULE_0__.toNumber(timeRemainderNs), 'hour'));\n    }\n    return { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds };\n}\nfunction RoundDuration(yearsParam, monthsParam, weeksParam, daysParam, hoursParam, minutesParam, secondsParam, millisecondsParam, microsecondsParam, nanosecondsParam, increment, unit, roundingMode, relativeToParam = undefined) {\n    let years = yearsParam;\n    let months = monthsParam;\n    let weeks = weeksParam;\n    let days = daysParam;\n    let hours = hoursParam;\n    let minutes = minutesParam;\n    let seconds = secondsParam;\n    let milliseconds = millisecondsParam;\n    let microseconds = microsecondsParam;\n    let nanoseconds = jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(nanosecondsParam);\n    const TemporalDuration = GetIntrinsic('%Temporal.Duration%');\n    let calendar, zdtRelative;\n    // A cast is used below because relativeTo will be either PlainDate or\n    // undefined for the rest of this long method (after any ZDT=>PlainDate\n    // conversion below), and TS isn't smart enough to know that the type has\n    // changed. See https://github.com/microsoft/TypeScript/issues/27706.\n    let relativeTo = relativeToParam;\n    if (relativeTo) {\n        if (IsTemporalZonedDateTime(relativeTo)) {\n            zdtRelative = relativeTo;\n            relativeTo = ToTemporalDate(relativeTo);\n        }\n        else if (!IsTemporalDate(relativeTo)) {\n            throw new TypeError('starting point must be PlainDate or ZonedDateTime');\n        }\n        calendar = GetSlot(relativeTo, CALENDAR);\n    }\n    // First convert time units up to days, if rounding to days or higher units.\n    // If rounding relative to a ZonedDateTime, then some days may not be 24h.\n    // TS doesn't know that `dayLengthNs` is only used if the unit is day or\n    // larger. We'll cast away `undefined` when it's used lower down below.\n    let dayLengthNs;\n    if (unit === 'year' || unit === 'month' || unit === 'week' || unit === 'day') {\n        nanoseconds = TotalDurationNanoseconds(0, hours, minutes, seconds, milliseconds, microseconds, nanosecondsParam, 0);\n        let intermediate;\n        if (zdtRelative) {\n            intermediate = MoveRelativeZonedDateTime(zdtRelative, years, months, weeks, days);\n        }\n        let deltaDays;\n        let dayLength;\n        ({ days: deltaDays, nanoseconds, dayLengthNs: dayLength } = NanosecondsToDays(nanoseconds, intermediate));\n        dayLengthNs = jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(dayLength);\n        days += deltaDays;\n        hours = minutes = seconds = milliseconds = microseconds = 0;\n    }\n    let total;\n    switch (unit) {\n        case 'year': {\n            if (!calendar)\n                throw new RangeError('A starting point is required for years rounding');\n            // convert months and weeks to days by calculating difference(\n            // relativeTo + years, relativeTo + { years, months, weeks })\n            const yearsDuration = new TemporalDuration(years);\n            const dateAdd = calendar.dateAdd;\n            const firstAddOptions = ObjectCreate$2(null);\n            const yearsLater = CalendarDateAdd(calendar, relativeTo, yearsDuration, firstAddOptions, dateAdd);\n            const yearsMonthsWeeks = new TemporalDuration(years, months, weeks);\n            const secondAddOptions = ObjectCreate$2(null);\n            const yearsMonthsWeeksLater = CalendarDateAdd(calendar, relativeTo, yearsMonthsWeeks, secondAddOptions, dateAdd);\n            const monthsWeeksInDays = DaysUntil(yearsLater, yearsMonthsWeeksLater);\n            relativeTo = yearsLater;\n            days += monthsWeeksInDays;\n            const thirdAddOptions = ObjectCreate$2(null);\n            const daysLater = CalendarDateAdd(calendar, relativeTo, { days }, thirdAddOptions, dateAdd);\n            const untilOptions = ObjectCreate$2(null);\n            untilOptions.largestUnit = 'year';\n            const yearsPassed = CalendarDateUntil(calendar, relativeTo, daysLater, untilOptions).years;\n            years += yearsPassed;\n            const oldRelativeTo = relativeTo;\n            const fourthAddOptions = ObjectCreate$2(null);\n            relativeTo = CalendarDateAdd(calendar, relativeTo, { years: yearsPassed }, fourthAddOptions, dateAdd);\n            const daysPassed = DaysUntil(oldRelativeTo, relativeTo);\n            days -= daysPassed;\n            const oneYear = new TemporalDuration(days < 0 ? -1 : 1);\n            let { days: oneYearDays } = MoveRelativeDate(calendar, relativeTo, oneYear);\n            // Note that `nanoseconds` below (here and in similar code for months,\n            // weeks, and days further below) isn't actually nanoseconds for the\n            // full date range.  Instead, it's a BigInt representation of total\n            // days multiplied by the number of nanoseconds in the last day of\n            // the duration. This lets us do days-or-larger rounding using BigInt\n            // math which reduces precision loss.\n            oneYearDays = MathAbs(oneYearDays);\n            // dayLengthNs is never undefined if unit is `day` or larger.\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            const divisor = jsbi__WEBPACK_IMPORTED_MODULE_0__.multiply(jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(oneYearDays), dayLengthNs);\n            nanoseconds = jsbi__WEBPACK_IMPORTED_MODULE_0__.add(\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            jsbi__WEBPACK_IMPORTED_MODULE_0__.add(jsbi__WEBPACK_IMPORTED_MODULE_0__.multiply(divisor, jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(years)), jsbi__WEBPACK_IMPORTED_MODULE_0__.multiply(jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(days), dayLengthNs)), nanoseconds);\n            const rounded = RoundNumberToIncrement(nanoseconds, jsbi__WEBPACK_IMPORTED_MODULE_0__.toNumber(jsbi__WEBPACK_IMPORTED_MODULE_0__.multiply(divisor, jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(increment))), roundingMode);\n            total = jsbi__WEBPACK_IMPORTED_MODULE_0__.toNumber(nanoseconds) / jsbi__WEBPACK_IMPORTED_MODULE_0__.toNumber(divisor);\n            years = jsbi__WEBPACK_IMPORTED_MODULE_0__.toNumber(jsbi__WEBPACK_IMPORTED_MODULE_0__.divide(rounded, divisor));\n            nanoseconds = ZERO;\n            months = weeks = days = 0;\n            break;\n        }\n        case 'month': {\n            if (!calendar)\n                throw new RangeError('A starting point is required for months rounding');\n            // convert weeks to days by calculating difference(relativeTo +\n            //   { years, months }, relativeTo + { years, months, weeks })\n            const yearsMonths = new TemporalDuration(years, months);\n            const dateAdd = calendar.dateAdd;\n            const firstAddOptions = ObjectCreate$2(null);\n            const yearsMonthsLater = CalendarDateAdd(calendar, relativeTo, yearsMonths, firstAddOptions, dateAdd);\n            const yearsMonthsWeeks = new TemporalDuration(years, months, weeks);\n            const secondAddOptions = ObjectCreate$2(null);\n            const yearsMonthsWeeksLater = CalendarDateAdd(calendar, relativeTo, yearsMonthsWeeks, secondAddOptions, dateAdd);\n            const weeksInDays = DaysUntil(yearsMonthsLater, yearsMonthsWeeksLater);\n            relativeTo = yearsMonthsLater;\n            days += weeksInDays;\n            // Months may be different lengths of days depending on the calendar,\n            // convert days to months in a loop as described above under 'years'.\n            const sign = MathSign(days);\n            const oneMonth = new TemporalDuration(0, days < 0 ? -1 : 1);\n            let oneMonthDays;\n            ({ relativeTo, days: oneMonthDays } = MoveRelativeDate(calendar, relativeTo, oneMonth));\n            while (MathAbs(days) >= MathAbs(oneMonthDays)) {\n                months += sign;\n                days -= oneMonthDays;\n                ({ relativeTo, days: oneMonthDays } = MoveRelativeDate(calendar, relativeTo, oneMonth));\n            }\n            oneMonthDays = MathAbs(oneMonthDays);\n            // dayLengthNs is never undefined if unit is `day` or larger.\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            const divisor = jsbi__WEBPACK_IMPORTED_MODULE_0__.multiply(jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(oneMonthDays), dayLengthNs);\n            nanoseconds = jsbi__WEBPACK_IMPORTED_MODULE_0__.add(\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            jsbi__WEBPACK_IMPORTED_MODULE_0__.add(jsbi__WEBPACK_IMPORTED_MODULE_0__.multiply(divisor, jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(months)), jsbi__WEBPACK_IMPORTED_MODULE_0__.multiply(jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(days), dayLengthNs)), nanoseconds);\n            const rounded = RoundNumberToIncrement(nanoseconds, jsbi__WEBPACK_IMPORTED_MODULE_0__.toNumber(jsbi__WEBPACK_IMPORTED_MODULE_0__.multiply(divisor, jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(increment))), roundingMode);\n            total = jsbi__WEBPACK_IMPORTED_MODULE_0__.toNumber(nanoseconds) / jsbi__WEBPACK_IMPORTED_MODULE_0__.toNumber(divisor);\n            months = jsbi__WEBPACK_IMPORTED_MODULE_0__.toNumber(jsbi__WEBPACK_IMPORTED_MODULE_0__.divide(rounded, divisor));\n            nanoseconds = ZERO;\n            weeks = days = 0;\n            break;\n        }\n        case 'week': {\n            if (!calendar)\n                throw new RangeError('A starting point is required for weeks rounding');\n            // Weeks may be different lengths of days depending on the calendar,\n            // convert days to weeks in a loop as described above under 'years'.\n            const sign = MathSign(days);\n            const oneWeek = new TemporalDuration(0, 0, days < 0 ? -1 : 1);\n            let oneWeekDays;\n            ({ relativeTo, days: oneWeekDays } = MoveRelativeDate(calendar, relativeTo, oneWeek));\n            while (MathAbs(days) >= MathAbs(oneWeekDays)) {\n                weeks += sign;\n                days -= oneWeekDays;\n                ({ relativeTo, days: oneWeekDays } = MoveRelativeDate(calendar, relativeTo, oneWeek));\n            }\n            oneWeekDays = MathAbs(oneWeekDays);\n            // dayLengthNs is never undefined if unit is `day` or larger.\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            const divisor = jsbi__WEBPACK_IMPORTED_MODULE_0__.multiply(jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(oneWeekDays), dayLengthNs);\n            nanoseconds = jsbi__WEBPACK_IMPORTED_MODULE_0__.add(\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            jsbi__WEBPACK_IMPORTED_MODULE_0__.add(jsbi__WEBPACK_IMPORTED_MODULE_0__.multiply(divisor, jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(weeks)), jsbi__WEBPACK_IMPORTED_MODULE_0__.multiply(jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(days), dayLengthNs)), nanoseconds);\n            const rounded = RoundNumberToIncrement(nanoseconds, jsbi__WEBPACK_IMPORTED_MODULE_0__.toNumber(jsbi__WEBPACK_IMPORTED_MODULE_0__.multiply(divisor, jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(increment))), roundingMode);\n            total = jsbi__WEBPACK_IMPORTED_MODULE_0__.toNumber(nanoseconds) / jsbi__WEBPACK_IMPORTED_MODULE_0__.toNumber(divisor);\n            weeks = jsbi__WEBPACK_IMPORTED_MODULE_0__.toNumber(jsbi__WEBPACK_IMPORTED_MODULE_0__.divide(rounded, divisor));\n            nanoseconds = ZERO;\n            days = 0;\n            break;\n        }\n        case 'day': {\n            // dayLengthNs is never undefined if unit is `day` or larger.\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            const divisor = dayLengthNs;\n            nanoseconds = jsbi__WEBPACK_IMPORTED_MODULE_0__.add(jsbi__WEBPACK_IMPORTED_MODULE_0__.multiply(divisor, jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(days)), nanoseconds);\n            const rounded = RoundNumberToIncrement(nanoseconds, jsbi__WEBPACK_IMPORTED_MODULE_0__.toNumber(jsbi__WEBPACK_IMPORTED_MODULE_0__.multiply(divisor, jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(increment))), roundingMode);\n            total = jsbi__WEBPACK_IMPORTED_MODULE_0__.toNumber(nanoseconds) / jsbi__WEBPACK_IMPORTED_MODULE_0__.toNumber(divisor);\n            days = jsbi__WEBPACK_IMPORTED_MODULE_0__.toNumber(jsbi__WEBPACK_IMPORTED_MODULE_0__.divide(rounded, divisor));\n            nanoseconds = ZERO;\n            break;\n        }\n        case 'hour': {\n            const divisor = 3600e9;\n            let allNanoseconds = jsbi__WEBPACK_IMPORTED_MODULE_0__.multiply(jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(hours), jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(3600e9));\n            allNanoseconds = jsbi__WEBPACK_IMPORTED_MODULE_0__.add(allNanoseconds, jsbi__WEBPACK_IMPORTED_MODULE_0__.multiply(jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(minutes), jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(60e9)));\n            allNanoseconds = jsbi__WEBPACK_IMPORTED_MODULE_0__.add(allNanoseconds, jsbi__WEBPACK_IMPORTED_MODULE_0__.multiply(jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(seconds), BILLION));\n            allNanoseconds = jsbi__WEBPACK_IMPORTED_MODULE_0__.add(allNanoseconds, jsbi__WEBPACK_IMPORTED_MODULE_0__.multiply(jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(milliseconds), MILLION));\n            allNanoseconds = jsbi__WEBPACK_IMPORTED_MODULE_0__.add(allNanoseconds, jsbi__WEBPACK_IMPORTED_MODULE_0__.multiply(jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(microseconds), THOUSAND));\n            allNanoseconds = jsbi__WEBPACK_IMPORTED_MODULE_0__.add(allNanoseconds, nanoseconds);\n            total = jsbi__WEBPACK_IMPORTED_MODULE_0__.toNumber(allNanoseconds) / divisor;\n            const rounded = RoundNumberToIncrement(allNanoseconds, divisor * increment, roundingMode);\n            hours = jsbi__WEBPACK_IMPORTED_MODULE_0__.toNumber(jsbi__WEBPACK_IMPORTED_MODULE_0__.divide(rounded, jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(divisor)));\n            nanoseconds = ZERO;\n            minutes = seconds = milliseconds = microseconds = 0;\n            break;\n        }\n        case 'minute': {\n            const divisor = 60e9;\n            let allNanoseconds = jsbi__WEBPACK_IMPORTED_MODULE_0__.multiply(jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(minutes), jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(60e9));\n            allNanoseconds = jsbi__WEBPACK_IMPORTED_MODULE_0__.add(allNanoseconds, jsbi__WEBPACK_IMPORTED_MODULE_0__.multiply(jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(seconds), BILLION));\n            allNanoseconds = jsbi__WEBPACK_IMPORTED_MODULE_0__.add(allNanoseconds, jsbi__WEBPACK_IMPORTED_MODULE_0__.multiply(jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(milliseconds), MILLION));\n            allNanoseconds = jsbi__WEBPACK_IMPORTED_MODULE_0__.add(allNanoseconds, jsbi__WEBPACK_IMPORTED_MODULE_0__.multiply(jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(microseconds), THOUSAND));\n            allNanoseconds = jsbi__WEBPACK_IMPORTED_MODULE_0__.add(allNanoseconds, nanoseconds);\n            total = jsbi__WEBPACK_IMPORTED_MODULE_0__.toNumber(allNanoseconds) / divisor;\n            const rounded = RoundNumberToIncrement(allNanoseconds, divisor * increment, roundingMode);\n            minutes = jsbi__WEBPACK_IMPORTED_MODULE_0__.toNumber(jsbi__WEBPACK_IMPORTED_MODULE_0__.divide(rounded, jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(divisor)));\n            nanoseconds = ZERO;\n            seconds = milliseconds = microseconds = 0;\n            break;\n        }\n        case 'second': {\n            const divisor = 1e9;\n            let allNanoseconds = jsbi__WEBPACK_IMPORTED_MODULE_0__.multiply(jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(seconds), BILLION);\n            allNanoseconds = jsbi__WEBPACK_IMPORTED_MODULE_0__.add(allNanoseconds, jsbi__WEBPACK_IMPORTED_MODULE_0__.multiply(jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(milliseconds), MILLION));\n            allNanoseconds = jsbi__WEBPACK_IMPORTED_MODULE_0__.add(allNanoseconds, jsbi__WEBPACK_IMPORTED_MODULE_0__.multiply(jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(microseconds), THOUSAND));\n            allNanoseconds = jsbi__WEBPACK_IMPORTED_MODULE_0__.add(allNanoseconds, nanoseconds);\n            total = jsbi__WEBPACK_IMPORTED_MODULE_0__.toNumber(allNanoseconds) / divisor;\n            const rounded = RoundNumberToIncrement(allNanoseconds, divisor * increment, roundingMode);\n            seconds = jsbi__WEBPACK_IMPORTED_MODULE_0__.toNumber(jsbi__WEBPACK_IMPORTED_MODULE_0__.divide(rounded, jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(divisor)));\n            nanoseconds = ZERO;\n            milliseconds = microseconds = 0;\n            break;\n        }\n        case 'millisecond': {\n            const divisor = 1e6;\n            let allNanoseconds = jsbi__WEBPACK_IMPORTED_MODULE_0__.multiply(jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(milliseconds), MILLION);\n            allNanoseconds = jsbi__WEBPACK_IMPORTED_MODULE_0__.add(allNanoseconds, jsbi__WEBPACK_IMPORTED_MODULE_0__.multiply(jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(microseconds), THOUSAND));\n            allNanoseconds = jsbi__WEBPACK_IMPORTED_MODULE_0__.add(allNanoseconds, nanoseconds);\n            total = jsbi__WEBPACK_IMPORTED_MODULE_0__.toNumber(allNanoseconds) / divisor;\n            const rounded = RoundNumberToIncrement(allNanoseconds, divisor * increment, roundingMode);\n            milliseconds = jsbi__WEBPACK_IMPORTED_MODULE_0__.toNumber(jsbi__WEBPACK_IMPORTED_MODULE_0__.divide(rounded, jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(divisor)));\n            nanoseconds = ZERO;\n            microseconds = 0;\n            break;\n        }\n        case 'microsecond': {\n            const divisor = 1e3;\n            let allNanoseconds = jsbi__WEBPACK_IMPORTED_MODULE_0__.multiply(jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(microseconds), THOUSAND);\n            allNanoseconds = jsbi__WEBPACK_IMPORTED_MODULE_0__.add(allNanoseconds, nanoseconds);\n            total = jsbi__WEBPACK_IMPORTED_MODULE_0__.toNumber(allNanoseconds) / divisor;\n            const rounded = RoundNumberToIncrement(allNanoseconds, divisor * increment, roundingMode);\n            microseconds = jsbi__WEBPACK_IMPORTED_MODULE_0__.toNumber(jsbi__WEBPACK_IMPORTED_MODULE_0__.divide(rounded, jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(divisor)));\n            nanoseconds = ZERO;\n            break;\n        }\n        case 'nanosecond': {\n            total = jsbi__WEBPACK_IMPORTED_MODULE_0__.toNumber(nanoseconds);\n            nanoseconds = RoundNumberToIncrement(nanoseconds, increment, roundingMode);\n            break;\n        }\n    }\n    return {\n        years,\n        months,\n        weeks,\n        days,\n        hours,\n        minutes,\n        seconds,\n        milliseconds,\n        microseconds,\n        nanoseconds: jsbi__WEBPACK_IMPORTED_MODULE_0__.toNumber(nanoseconds),\n        total\n    };\n}\nfunction CompareISODate(y1, m1, d1, y2, m2, d2) {\n    for (const [x, y] of [\n        [y1, y2],\n        [m1, m2],\n        [d1, d2]\n    ]) {\n        if (x !== y)\n            return ComparisonResult(x - y);\n    }\n    return 0;\n}\nfunction NonNegativeModulo(x, y) {\n    let result = x % y;\n    if (ObjectIs(result, -0))\n        return 0;\n    if (result < 0)\n        result += y;\n    return result;\n}\nfunction ToBigIntExternal(arg) {\n    const jsbiBI = ToBigInt(arg);\n    if (typeof globalThis.BigInt !== 'undefined')\n        return globalThis.BigInt(jsbiBI.toString(10));\n    return jsbiBI;\n}\nfunction ToBigInt(arg) {\n    if (arg instanceof jsbi__WEBPACK_IMPORTED_MODULE_0__) {\n        return arg;\n    }\n    let prim = arg;\n    if (typeof arg === 'object') {\n        const toPrimFn = arg[Symbol.toPrimitive];\n        if (toPrimFn && typeof toPrimFn === 'function') {\n            prim = ReflectApply$1(toPrimFn, arg, ['number']);\n        }\n    }\n    switch (typeof prim) {\n        case 'undefined':\n        case 'object':\n        case 'number':\n        case 'symbol':\n        default:\n            throw new TypeError(`cannot convert ${typeof arg} to bigint`);\n        case 'string':\n            if (!prim.match(/^\\s*(?:[+-]?\\d+\\s*)?$/)) {\n                throw new SyntaxError('invalid BigInt syntax');\n            }\n        // eslint: no-fallthrough: false\n        case 'bigint':\n            try {\n                return jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(prim.toString());\n            }\n            catch (e) {\n                if (e instanceof Error && e.message.startsWith('Invalid integer'))\n                    throw new SyntaxError(e.message);\n                throw e;\n            }\n        case 'boolean':\n            if (prim) {\n                return ONE;\n            }\n            else {\n                return ZERO;\n            }\n    }\n}\n// Note: This method returns values with bogus nanoseconds based on the previous iteration's\n// milliseconds. That way there is a guarantee that the full nanoseconds are always going to be\n// increasing at least and that the microsecond and nanosecond fields are likely to be non-zero.\nconst SystemUTCEpochNanoSeconds = (() => {\n    let ns = jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(Date.now() % 1e6);\n    return () => {\n        const ms = jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(Date.now());\n        const result = jsbi__WEBPACK_IMPORTED_MODULE_0__.add(jsbi__WEBPACK_IMPORTED_MODULE_0__.multiply(ms, MILLION), ns);\n        ns = jsbi__WEBPACK_IMPORTED_MODULE_0__.divide(ms, MILLION);\n        if (jsbi__WEBPACK_IMPORTED_MODULE_0__.greaterThan(result, NS_MAX))\n            return NS_MAX;\n        if (jsbi__WEBPACK_IMPORTED_MODULE_0__.lessThan(result, NS_MIN))\n            return NS_MIN;\n        return result;\n    };\n})();\nfunction SystemTimeZone() {\n    const fmt = new IntlDateTimeFormat$1('en-us');\n    const TemporalTimeZone = GetIntrinsic('%Temporal.TimeZone%');\n    return new TemporalTimeZone(ParseTemporalTimeZone(fmt.resolvedOptions().timeZone));\n}\nfunction ComparisonResult(value) {\n    return value < 0 ? -1 : value > 0 ? 1 : value;\n}\nfunction GetOptionsObject(options) {\n    if (options === undefined)\n        return ObjectCreate$2(null);\n    if (IsObject(options) && options !== null)\n        return options;\n    throw new TypeError(`Options parameter must be an object, not ${options === null ? 'null' : `${typeof options}`}`);\n}\nfunction CreateOnePropObject(propName, propValue) {\n    const o = ObjectCreate$2(null);\n    o[propName] = propValue;\n    return o;\n}\nfunction GetOption(options, property, allowedValues, fallback) {\n    let value = options[property];\n    if (value !== undefined) {\n        value = ToString(value);\n        if (!allowedValues.includes(value)) {\n            throw new RangeError(`${property} must be one of ${allowedValues.join(', ')}, not ${value}`);\n        }\n        return value;\n    }\n    return fallback;\n}\nfunction GetNumberOption(options, property, minimum, maximum, fallback) {\n    let valueRaw = options[property];\n    if (valueRaw === undefined)\n        return fallback;\n    const value = ToNumber(valueRaw);\n    if (NumberIsNaN(value) || value < minimum || value > maximum) {\n        throw new RangeError(`${property} must be between ${minimum} and ${maximum}, not ${value}`);\n    }\n    return MathFloor(value);\n}\nconst OFFSET = new RegExp(`^${offset.source}$`);\nfunction bisect(getState, leftParam, rightParam, lstateParam = getState(leftParam), rstateParam = getState(rightParam)) {\n    // This doesn't make much sense - why do these get converted unnecessarily?\n    let left = jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(leftParam);\n    let right = jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(rightParam);\n    let lstate = lstateParam;\n    let rstate = rstateParam;\n    while (jsbi__WEBPACK_IMPORTED_MODULE_0__.greaterThan(jsbi__WEBPACK_IMPORTED_MODULE_0__.subtract(right, left), ONE)) {\n        const middle = jsbi__WEBPACK_IMPORTED_MODULE_0__.divide(jsbi__WEBPACK_IMPORTED_MODULE_0__.add(left, right), jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(2));\n        const mstate = getState(middle);\n        if (mstate === lstate) {\n            left = middle;\n            lstate = mstate;\n        }\n        else if (mstate === rstate) {\n            right = middle;\n            rstate = mstate;\n        }\n        else {\n            throw new Error(`invalid state in bisection ${lstate} - ${mstate} - ${rstate}`);\n        }\n    }\n    return right;\n}\nconst nsPerTimeUnit = {\n    hour: 3600e9,\n    minute: 60e9,\n    second: 1e9,\n    millisecond: 1e6,\n    microsecond: 1e3,\n    nanosecond: 1\n};\n\nconst DATE = Symbol('date');\nconst YM = Symbol('ym');\nconst MD = Symbol('md');\nconst TIME = Symbol('time');\nconst DATETIME = Symbol('datetime');\nconst ZONED = Symbol('zoneddatetime');\nconst INST = Symbol('instant');\nconst ORIGINAL = Symbol('original');\nconst TZ_RESOLVED = Symbol('timezone');\nconst TZ_GIVEN = Symbol('timezone-id-given');\nconst CAL_ID = Symbol('calendar-id');\nconst LOCALE = Symbol('locale');\nconst OPTIONS = Symbol('options');\nconst descriptor = (value) => {\n    return {\n        value,\n        enumerable: true,\n        writable: false,\n        configurable: true\n    };\n};\nconst IntlDateTimeFormat = globalThis.Intl.DateTimeFormat;\nconst ObjectAssign$1 = Object.assign;\nconst ObjectHasOwnProperty = Object.prototype.hasOwnProperty;\nconst ReflectApply = Reflect.apply;\n// Construction of built-in Intl.DateTimeFormat objects is sloooooow,\n// so we'll only create those instances when we need them.\n// See https://bugs.chromium.org/p/v8/issues/detail?id=6528\nfunction getPropLazy(obj, prop) {\n    let val = obj[prop];\n    if (typeof val === 'function') {\n        // If we get here, `val` is an \"amender function\". It will take the user's\n        // options and transform them into suitable options to be passed into the\n        // built-in (non-polyfill) Intl.DateTimeFormat constructor. These options\n        // will vary depending on the Temporal type, so that's why we store separate\n        // formatters in separate props on the polyfill's DateTimeFormat instances.\n        // The efficiency happens because we don't create an (expensive) formatter\n        // until the user calls toLocaleString for that Temporal type.\n        val = new IntlDateTimeFormat(obj[LOCALE], val(obj[OPTIONS]));\n        // TODO: can this be typed more cleanly?\n        obj[prop] = val;\n    }\n    return val;\n}\n// Similarly, lazy-init TimeZone instances.\nfunction getResolvedTimeZoneLazy(obj) {\n    let val = obj[TZ_RESOLVED];\n    if (typeof val === 'string') {\n        val = ToTemporalTimeZone(val);\n        obj[TZ_RESOLVED] = val;\n    }\n    return val;\n}\nfunction DateTimeFormatImpl(locale = undefined, optionsParam = {}) {\n    if (!(this instanceof DateTimeFormatImpl)) {\n        return new DateTimeFormatImpl(locale, optionsParam);\n    }\n    const hasOptions = typeof optionsParam !== 'undefined';\n    const options = hasOptions ? ObjectAssign$1({}, optionsParam) : {};\n    // TODO: remove type assertion after Temporal types land in TS lib types\n    const original = new IntlDateTimeFormat(locale, options);\n    const ro = original.resolvedOptions();\n    // DateTimeFormat instances are very expensive to create. Therefore, they will\n    // be lazily created only when needed, using the locale and options provided.\n    // But it's possible for callers to mutate those inputs before lazy creation\n    // happens. For this reason, we clone the inputs instead of caching the\n    // original objects. To avoid the complexity of deep cloning any inputs that\n    // are themselves objects (e.g. the locales array, or options property values\n    // that will be coerced to strings), we rely on `resolvedOptions()` to do the\n    // coercion and cloning for us. Unfortunately, we can't just use the resolved\n    // options as-is because our options-amending logic adds additional fields if\n    // the user doesn't supply any unit fields like year, month, day, hour, etc.\n    // Therefore, we limit the properties in the clone to properties that were\n    // present in the original input.\n    if (hasOptions) {\n        const clonedResolved = ObjectAssign$1({}, ro);\n        for (const prop in clonedResolved) {\n            if (!ReflectApply(ObjectHasOwnProperty, options, [prop])) {\n                delete clonedResolved[prop];\n            }\n        }\n        this[OPTIONS] = clonedResolved;\n    }\n    else {\n        this[OPTIONS] = options;\n    }\n    this[TZ_GIVEN] = options.timeZone ? options.timeZone : null;\n    this[LOCALE] = ro.locale;\n    this[ORIGINAL] = original;\n    this[TZ_RESOLVED] = ro.timeZone;\n    this[CAL_ID] = ro.calendar;\n    this[DATE] = dateAmend;\n    this[YM] = yearMonthAmend;\n    this[MD] = monthDayAmend;\n    this[TIME] = timeAmend;\n    this[DATETIME] = datetimeAmend;\n    this[ZONED] = zonedDateTimeAmend;\n    this[INST] = instantAmend;\n    return undefined; // TODO: I couldn't satisfy TS without adding this. Is there another way?\n}\nObject.defineProperty(DateTimeFormatImpl, 'name', {\n    writable: true,\n    value: 'DateTimeFormat'\n});\nDateTimeFormatImpl.supportedLocalesOf = function (locales, options) {\n    return IntlDateTimeFormat.supportedLocalesOf(locales, options);\n};\nconst properties = {\n    resolvedOptions: descriptor(resolvedOptions),\n    format: descriptor(format),\n    formatRange: descriptor(formatRange)\n};\nif ('formatToParts' in IntlDateTimeFormat.prototype) {\n    properties.formatToParts = descriptor(formatToParts);\n}\nif ('formatRangeToParts' in IntlDateTimeFormat.prototype) {\n    properties.formatRangeToParts = descriptor(formatRangeToParts);\n}\nDateTimeFormatImpl.prototype = Object.create(IntlDateTimeFormat.prototype, properties);\n// Ensure that the prototype isn't writeable.\nObject.defineProperty(DateTimeFormatImpl, 'prototype', {\n    writable: false,\n    enumerable: false,\n    configurable: false\n});\nconst DateTimeFormat = DateTimeFormatImpl;\nfunction resolvedOptions() {\n    return this[ORIGINAL].resolvedOptions();\n}\nfunction adjustFormatterTimeZone(formatter, timeZone) {\n    if (!timeZone)\n        return formatter;\n    const options = formatter.resolvedOptions();\n    if (options.timeZone === timeZone)\n        return formatter;\n    // Existing Intl isn't typed to accept Temporal-specific options, but will not\n    // break at runtime if we pass them. Also, the lib types for resolved options\n    // are less restrictive than the types for options. For example, `weekday` is\n    // `'long' | 'short' | 'narrow'` in options but `string` in resolved options.\n    // TODO: investigate why, and file an issue against TS if it's a bug.\n    return new IntlDateTimeFormat(options.locale, { ...options, timeZone });\n}\n// TODO: investigate why there's a rest parameter here. Does this function really need to accept extra params?\n// And if so, why doesn't formatRange also accept extra params?\nfunction format(datetime, ...rest) {\n    let { instant, formatter, timeZone } = extractOverrides(datetime, this);\n    if (instant && formatter) {\n        formatter = adjustFormatterTimeZone(formatter, timeZone);\n        return formatter.format(instant.epochMilliseconds);\n    }\n    return this[ORIGINAL].format(datetime, ...rest);\n}\nfunction formatToParts(datetime, ...rest) {\n    let { instant, formatter, timeZone } = extractOverrides(datetime, this);\n    if (instant && formatter) {\n        formatter = adjustFormatterTimeZone(formatter, timeZone);\n        return formatter.formatToParts(instant.epochMilliseconds);\n    }\n    return this[ORIGINAL].formatToParts(datetime, ...rest);\n}\nfunction formatRange(a, b) {\n    if (isTemporalObject(a) || isTemporalObject(b)) {\n        if (!sameTemporalType(a, b)) {\n            throw new TypeError('Intl.DateTimeFormat.formatRange accepts two values of the same type');\n        }\n        const { instant: aa, formatter: aformatter, timeZone: atz } = extractOverrides(a, this);\n        const { instant: bb, formatter: bformatter, timeZone: btz } = extractOverrides(b, this);\n        if (atz && btz && atz !== btz) {\n            throw new RangeError('cannot format range between different time zones');\n        }\n        if (aa && bb && aformatter && bformatter && aformatter === bformatter) {\n            const formatter = adjustFormatterTimeZone(aformatter, atz);\n            // TODO: Remove type assertion after this method lands in TS lib types\n            return formatter.formatRange(aa.epochMilliseconds, bb.epochMilliseconds);\n        }\n    }\n    // TODO: Remove type assertion after this method lands in TS lib types\n    return this[ORIGINAL].formatRange(a, b);\n}\nfunction formatRangeToParts(a, b) {\n    if (isTemporalObject(a) || isTemporalObject(b)) {\n        if (!sameTemporalType(a, b)) {\n            throw new TypeError('Intl.DateTimeFormat.formatRangeToParts accepts two values of the same type');\n        }\n        const { instant: aa, formatter: aformatter, timeZone: atz } = extractOverrides(a, this);\n        const { instant: bb, formatter: bformatter, timeZone: btz } = extractOverrides(b, this);\n        if (atz && btz && atz !== btz) {\n            throw new RangeError('cannot format range between different time zones');\n        }\n        if (aa && bb && aformatter && bformatter && aformatter === bformatter) {\n            const formatter = adjustFormatterTimeZone(aformatter, atz);\n            // TODO: Remove type assertion after this method lands in TS lib types\n            return formatter.formatRangeToParts(aa.epochMilliseconds, bb.epochMilliseconds);\n        }\n    }\n    // TODO: Remove type assertion after this method lands in TS lib types\n    return this[ORIGINAL].formatRangeToParts(a, b);\n}\nfunction amend(optionsParam = {}, amended = {}) {\n    const options = ObjectAssign$1({}, optionsParam);\n    for (const opt of [\n        'year',\n        'month',\n        'day',\n        'hour',\n        'minute',\n        'second',\n        'weekday',\n        'dayPeriod',\n        'timeZoneName',\n        'dateStyle',\n        'timeStyle'\n    ]) {\n        options[opt] = opt in amended ? amended[opt] : options[opt];\n        if (options[opt] === false || options[opt] === undefined)\n            delete options[opt];\n    }\n    return options;\n}\nfunction timeAmend(optionsParam) {\n    let options = amend(optionsParam, {\n        year: false,\n        month: false,\n        day: false,\n        weekday: false,\n        timeZoneName: false,\n        dateStyle: false\n    });\n    if (!hasTimeOptions(options)) {\n        options = ObjectAssign$1({}, options, {\n            hour: 'numeric',\n            minute: 'numeric',\n            second: 'numeric'\n        });\n    }\n    return options;\n}\nfunction yearMonthAmend(optionsParam) {\n    let options = amend(optionsParam, {\n        day: false,\n        hour: false,\n        minute: false,\n        second: false,\n        weekday: false,\n        dayPeriod: false,\n        timeZoneName: false,\n        dateStyle: false,\n        timeStyle: false\n    });\n    if (!('year' in options || 'month' in options)) {\n        options = ObjectAssign$1(options, { year: 'numeric', month: 'numeric' });\n    }\n    return options;\n}\nfunction monthDayAmend(optionsParam) {\n    let options = amend(optionsParam, {\n        year: false,\n        hour: false,\n        minute: false,\n        second: false,\n        weekday: false,\n        dayPeriod: false,\n        timeZoneName: false,\n        dateStyle: false,\n        timeStyle: false\n    });\n    if (!('month' in options || 'day' in options)) {\n        options = ObjectAssign$1({}, options, { month: 'numeric', day: 'numeric' });\n    }\n    return options;\n}\nfunction dateAmend(optionsParam) {\n    let options = amend(optionsParam, {\n        hour: false,\n        minute: false,\n        second: false,\n        dayPeriod: false,\n        timeZoneName: false,\n        timeStyle: false\n    });\n    if (!hasDateOptions(options)) {\n        options = ObjectAssign$1({}, options, {\n            year: 'numeric',\n            month: 'numeric',\n            day: 'numeric'\n        });\n    }\n    return options;\n}\nfunction datetimeAmend(optionsParam) {\n    let options = amend(optionsParam, { timeZoneName: false });\n    if (!hasTimeOptions(options) && !hasDateOptions(options)) {\n        options = ObjectAssign$1({}, options, {\n            year: 'numeric',\n            month: 'numeric',\n            day: 'numeric',\n            hour: 'numeric',\n            minute: 'numeric',\n            second: 'numeric'\n        });\n    }\n    return options;\n}\nfunction zonedDateTimeAmend(optionsParam) {\n    let options = optionsParam;\n    if (!hasTimeOptions(options) && !hasDateOptions(options)) {\n        options = ObjectAssign$1({}, options, {\n            year: 'numeric',\n            month: 'numeric',\n            day: 'numeric',\n            hour: 'numeric',\n            minute: 'numeric',\n            second: 'numeric'\n        });\n        if (options.timeZoneName === undefined)\n            options.timeZoneName = 'short';\n    }\n    return options;\n}\nfunction instantAmend(optionsParam) {\n    let options = optionsParam;\n    if (!hasTimeOptions(options) && !hasDateOptions(options)) {\n        options = ObjectAssign$1({}, options, {\n            year: 'numeric',\n            month: 'numeric',\n            day: 'numeric',\n            hour: 'numeric',\n            minute: 'numeric',\n            second: 'numeric'\n        });\n    }\n    return options;\n}\nfunction hasDateOptions(options) {\n    return 'year' in options || 'month' in options || 'day' in options || 'weekday' in options || 'dateStyle' in options;\n}\nfunction hasTimeOptions(options) {\n    return ('hour' in options || 'minute' in options || 'second' in options || 'timeStyle' in options || 'dayPeriod' in options);\n}\nfunction isTemporalObject(obj) {\n    return (IsTemporalDate(obj) ||\n        IsTemporalTime(obj) ||\n        IsTemporalDateTime(obj) ||\n        IsTemporalZonedDateTime(obj) ||\n        IsTemporalYearMonth(obj) ||\n        IsTemporalMonthDay(obj) ||\n        IsTemporalInstant(obj));\n}\nfunction sameTemporalType(x, y) {\n    if (!isTemporalObject(x) || !isTemporalObject(y))\n        return false;\n    if (IsTemporalTime(x) && !IsTemporalTime(y))\n        return false;\n    if (IsTemporalDate(x) && !IsTemporalDate(y))\n        return false;\n    if (IsTemporalDateTime(x) && !IsTemporalDateTime(y))\n        return false;\n    if (IsTemporalZonedDateTime(x) && !IsTemporalZonedDateTime(y))\n        return false;\n    if (IsTemporalYearMonth(x) && !IsTemporalYearMonth(y))\n        return false;\n    if (IsTemporalMonthDay(x) && !IsTemporalMonthDay(y))\n        return false;\n    if (IsTemporalInstant(x) && !IsTemporalInstant(y))\n        return false;\n    return true;\n}\nfunction extractOverrides(temporalObj, main) {\n    const DateTime = GetIntrinsic('%Temporal.PlainDateTime%');\n    if (IsTemporalTime(temporalObj)) {\n        const hour = GetSlot(temporalObj, ISO_HOUR);\n        const minute = GetSlot(temporalObj, ISO_MINUTE);\n        const second = GetSlot(temporalObj, ISO_SECOND);\n        const millisecond = GetSlot(temporalObj, ISO_MILLISECOND);\n        const microsecond = GetSlot(temporalObj, ISO_MICROSECOND);\n        const nanosecond = GetSlot(temporalObj, ISO_NANOSECOND);\n        const datetime = new DateTime(1970, 1, 1, hour, minute, second, millisecond, microsecond, nanosecond, main[CAL_ID]);\n        return {\n            instant: BuiltinTimeZoneGetInstantFor(getResolvedTimeZoneLazy(main), datetime, 'compatible'),\n            formatter: getPropLazy(main, TIME)\n        };\n    }\n    if (IsTemporalYearMonth(temporalObj)) {\n        const isoYear = GetSlot(temporalObj, ISO_YEAR);\n        const isoMonth = GetSlot(temporalObj, ISO_MONTH);\n        const referenceISODay = GetSlot(temporalObj, ISO_DAY);\n        const calendar = ToString(GetSlot(temporalObj, CALENDAR));\n        if (calendar !== main[CAL_ID]) {\n            throw new RangeError(`cannot format PlainYearMonth with calendar ${calendar} in locale with calendar ${main[CAL_ID]}`);\n        }\n        const datetime = new DateTime(isoYear, isoMonth, referenceISODay, 12, 0, 0, 0, 0, 0, calendar);\n        return {\n            instant: BuiltinTimeZoneGetInstantFor(getResolvedTimeZoneLazy(main), datetime, 'compatible'),\n            formatter: getPropLazy(main, YM)\n        };\n    }\n    if (IsTemporalMonthDay(temporalObj)) {\n        const referenceISOYear = GetSlot(temporalObj, ISO_YEAR);\n        const isoMonth = GetSlot(temporalObj, ISO_MONTH);\n        const isoDay = GetSlot(temporalObj, ISO_DAY);\n        const calendar = ToString(GetSlot(temporalObj, CALENDAR));\n        if (calendar !== main[CAL_ID]) {\n            throw new RangeError(`cannot format PlainMonthDay with calendar ${calendar} in locale with calendar ${main[CAL_ID]}`);\n        }\n        const datetime = new DateTime(referenceISOYear, isoMonth, isoDay, 12, 0, 0, 0, 0, 0, calendar);\n        return {\n            instant: BuiltinTimeZoneGetInstantFor(getResolvedTimeZoneLazy(main), datetime, 'compatible'),\n            formatter: getPropLazy(main, MD)\n        };\n    }\n    if (IsTemporalDate(temporalObj)) {\n        const isoYear = GetSlot(temporalObj, ISO_YEAR);\n        const isoMonth = GetSlot(temporalObj, ISO_MONTH);\n        const isoDay = GetSlot(temporalObj, ISO_DAY);\n        const calendar = ToString(GetSlot(temporalObj, CALENDAR));\n        if (calendar !== 'iso8601' && calendar !== main[CAL_ID]) {\n            throw new RangeError(`cannot format PlainDate with calendar ${calendar} in locale with calendar ${main[CAL_ID]}`);\n        }\n        const datetime = new DateTime(isoYear, isoMonth, isoDay, 12, 0, 0, 0, 0, 0, main[CAL_ID]);\n        return {\n            instant: BuiltinTimeZoneGetInstantFor(getResolvedTimeZoneLazy(main), datetime, 'compatible'),\n            formatter: getPropLazy(main, DATE)\n        };\n    }\n    if (IsTemporalDateTime(temporalObj)) {\n        const isoYear = GetSlot(temporalObj, ISO_YEAR);\n        const isoMonth = GetSlot(temporalObj, ISO_MONTH);\n        const isoDay = GetSlot(temporalObj, ISO_DAY);\n        const hour = GetSlot(temporalObj, ISO_HOUR);\n        const minute = GetSlot(temporalObj, ISO_MINUTE);\n        const second = GetSlot(temporalObj, ISO_SECOND);\n        const millisecond = GetSlot(temporalObj, ISO_MILLISECOND);\n        const microsecond = GetSlot(temporalObj, ISO_MICROSECOND);\n        const nanosecond = GetSlot(temporalObj, ISO_NANOSECOND);\n        const calendar = ToString(GetSlot(temporalObj, CALENDAR));\n        if (calendar !== 'iso8601' && calendar !== main[CAL_ID]) {\n            throw new RangeError(`cannot format PlainDateTime with calendar ${calendar} in locale with calendar ${main[CAL_ID]}`);\n        }\n        let datetime = temporalObj;\n        if (calendar === 'iso8601') {\n            datetime = new DateTime(isoYear, isoMonth, isoDay, hour, minute, second, millisecond, microsecond, nanosecond, main[CAL_ID]);\n        }\n        return {\n            instant: BuiltinTimeZoneGetInstantFor(getResolvedTimeZoneLazy(main), datetime, 'compatible'),\n            formatter: getPropLazy(main, DATETIME)\n        };\n    }\n    if (IsTemporalZonedDateTime(temporalObj)) {\n        const calendar = ToString(GetSlot(temporalObj, CALENDAR));\n        if (calendar !== 'iso8601' && calendar !== main[CAL_ID]) {\n            throw new RangeError(`cannot format ZonedDateTime with calendar ${calendar} in locale with calendar ${main[CAL_ID]}`);\n        }\n        const timeZone = GetSlot(temporalObj, TIME_ZONE);\n        const objTimeZone = ToString(timeZone);\n        if (main[TZ_GIVEN] && main[TZ_GIVEN] !== objTimeZone) {\n            throw new RangeError(`timeZone option ${main[TZ_GIVEN]} doesn't match actual time zone ${objTimeZone}`);\n        }\n        return {\n            instant: GetSlot(temporalObj, INSTANT),\n            formatter: getPropLazy(main, ZONED),\n            timeZone: objTimeZone\n        };\n    }\n    if (IsTemporalInstant(temporalObj)) {\n        return {\n            instant: temporalObj,\n            formatter: getPropLazy(main, INST)\n        };\n    }\n    return {};\n}\n\nvar intl = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    DateTimeFormat: DateTimeFormat\n});\n\nconst DISALLOWED_UNITS$3 = ['year', 'month', 'week', 'day'];\nconst MAX_DIFFERENCE_INCREMENTS = {\n    hour: 24,\n    minute: 60,\n    second: 60,\n    millisecond: 1000,\n    microsecond: 1000,\n    nanosecond: 1000\n};\nclass Instant {\n    constructor(epochNanoseconds) {\n        // Note: if the argument is not passed, ToBigInt(undefined) will throw. This check exists only\n        //       to improve the error message.\n        if (arguments.length < 1) {\n            throw new TypeError('missing argument: epochNanoseconds is required');\n        }\n        const ns = ToBigInt(epochNanoseconds);\n        ValidateEpochNanoseconds(ns);\n        CreateSlots(this);\n        SetSlot(this, EPOCHNANOSECONDS, ns);\n        {\n            const repr = TemporalInstantToString(this, undefined, 'auto');\n            Object.defineProperty(this, '_repr_', {\n                value: `${this[Symbol.toStringTag]} <${repr}>`,\n                writable: false,\n                enumerable: false,\n                configurable: false\n            });\n        }\n    }\n    get epochSeconds() {\n        if (!IsTemporalInstant(this))\n            throw new TypeError('invalid receiver');\n        const value = GetSlot(this, EPOCHNANOSECONDS);\n        return jsbi__WEBPACK_IMPORTED_MODULE_0__.toNumber(jsbi__WEBPACK_IMPORTED_MODULE_0__.divide(value, BILLION));\n    }\n    get epochMilliseconds() {\n        if (!IsTemporalInstant(this))\n            throw new TypeError('invalid receiver');\n        const value = jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(GetSlot(this, EPOCHNANOSECONDS));\n        return jsbi__WEBPACK_IMPORTED_MODULE_0__.toNumber(jsbi__WEBPACK_IMPORTED_MODULE_0__.divide(value, MILLION));\n    }\n    get epochMicroseconds() {\n        if (!IsTemporalInstant(this))\n            throw new TypeError('invalid receiver');\n        const value = jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(GetSlot(this, EPOCHNANOSECONDS));\n        return ToBigIntExternal(jsbi__WEBPACK_IMPORTED_MODULE_0__.divide(value, THOUSAND));\n    }\n    get epochNanoseconds() {\n        if (!IsTemporalInstant(this))\n            throw new TypeError('invalid receiver');\n        return ToBigIntExternal(jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(GetSlot(this, EPOCHNANOSECONDS)));\n    }\n    add(temporalDurationLike) {\n        if (!IsTemporalInstant(this))\n            throw new TypeError('invalid receiver');\n        const { hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = ToLimitedTemporalDuration(temporalDurationLike, ['years', 'months', 'weeks', 'days']);\n        const ns = AddInstant(GetSlot(this, EPOCHNANOSECONDS), hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n        return new Instant(ns);\n    }\n    subtract(temporalDurationLike) {\n        if (!IsTemporalInstant(this))\n            throw new TypeError('invalid receiver');\n        const { hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = ToLimitedTemporalDuration(temporalDurationLike, ['years', 'months', 'weeks', 'days']);\n        const ns = AddInstant(GetSlot(this, EPOCHNANOSECONDS), -hours, -minutes, -seconds, -milliseconds, -microseconds, -nanoseconds);\n        return new Instant(ns);\n    }\n    until(otherParam, optionsParam = undefined) {\n        if (!IsTemporalInstant(this))\n            throw new TypeError('invalid receiver');\n        const other = ToTemporalInstant(otherParam);\n        const options = GetOptionsObject(optionsParam);\n        const smallestUnit = ToSmallestTemporalUnit(options, 'nanosecond', DISALLOWED_UNITS$3);\n        const defaultLargestUnit = LargerOfTwoTemporalUnits('second', smallestUnit);\n        const largestUnit = ToLargestTemporalUnit(options, 'auto', DISALLOWED_UNITS$3, defaultLargestUnit);\n        ValidateTemporalUnitRange(largestUnit, smallestUnit);\n        const roundingMode = ToTemporalRoundingMode(options, 'trunc');\n        const roundingIncrement = ToTemporalRoundingIncrement(options, MAX_DIFFERENCE_INCREMENTS[smallestUnit], false);\n        const onens = GetSlot(this, EPOCHNANOSECONDS);\n        const twons = GetSlot(other, EPOCHNANOSECONDS);\n        let { seconds, milliseconds, microseconds, nanoseconds } = DifferenceInstant(onens, twons, roundingIncrement, smallestUnit, roundingMode);\n        let hours, minutes;\n        ({ hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = BalanceDuration(0, 0, 0, seconds, milliseconds, microseconds, nanoseconds, largestUnit));\n        const Duration = GetIntrinsic('%Temporal.Duration%');\n        return new Duration(0, 0, 0, 0, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n    }\n    since(otherParam, optionsParam = undefined) {\n        if (!IsTemporalInstant(this))\n            throw new TypeError('invalid receiver');\n        const other = ToTemporalInstant(otherParam);\n        const options = GetOptionsObject(optionsParam);\n        const smallestUnit = ToSmallestTemporalUnit(options, 'nanosecond', DISALLOWED_UNITS$3);\n        const defaultLargestUnit = LargerOfTwoTemporalUnits('second', smallestUnit);\n        const largestUnit = ToLargestTemporalUnit(options, 'auto', DISALLOWED_UNITS$3, defaultLargestUnit);\n        ValidateTemporalUnitRange(largestUnit, smallestUnit);\n        const roundingMode = ToTemporalRoundingMode(options, 'trunc');\n        const roundingIncrement = ToTemporalRoundingIncrement(options, MAX_DIFFERENCE_INCREMENTS[smallestUnit], false);\n        const onens = GetSlot(other, EPOCHNANOSECONDS);\n        const twons = GetSlot(this, EPOCHNANOSECONDS);\n        let { seconds, milliseconds, microseconds, nanoseconds } = DifferenceInstant(onens, twons, roundingIncrement, smallestUnit, roundingMode);\n        let hours, minutes;\n        ({ hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = BalanceDuration(0, 0, 0, seconds, milliseconds, microseconds, nanoseconds, largestUnit));\n        const Duration = GetIntrinsic('%Temporal.Duration%');\n        return new Duration(0, 0, 0, 0, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n    }\n    round(optionsParam) {\n        if (!IsTemporalInstant(this))\n            throw new TypeError('invalid receiver');\n        if (optionsParam === undefined)\n            throw new TypeError('options parameter is required');\n        const options = typeof optionsParam === 'string'\n            ? CreateOnePropObject('smallestUnit', optionsParam)\n            : GetOptionsObject(optionsParam);\n        const smallestUnit = ToSmallestTemporalUnit(options, undefined, DISALLOWED_UNITS$3);\n        if (smallestUnit === undefined)\n            throw new RangeError('smallestUnit is required');\n        const roundingMode = ToTemporalRoundingMode(options, 'halfExpand');\n        const maximumIncrements = {\n            hour: 24,\n            minute: 1440,\n            second: 86400,\n            millisecond: 86400e3,\n            microsecond: 86400e6,\n            nanosecond: 86400e9\n        };\n        const roundingIncrement = ToTemporalRoundingIncrement(options, maximumIncrements[smallestUnit], true);\n        const ns = GetSlot(this, EPOCHNANOSECONDS);\n        const roundedNs = RoundInstant(ns, roundingIncrement, smallestUnit, roundingMode);\n        return new Instant(roundedNs);\n    }\n    equals(otherParam) {\n        if (!IsTemporalInstant(this))\n            throw new TypeError('invalid receiver');\n        const other = ToTemporalInstant(otherParam);\n        const one = GetSlot(this, EPOCHNANOSECONDS);\n        const two = GetSlot(other, EPOCHNANOSECONDS);\n        return jsbi__WEBPACK_IMPORTED_MODULE_0__.equal(jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(one), jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(two));\n    }\n    toString(optionsParam = undefined) {\n        if (!IsTemporalInstant(this))\n            throw new TypeError('invalid receiver');\n        const options = GetOptionsObject(optionsParam);\n        let timeZone = options.timeZone;\n        if (timeZone !== undefined)\n            timeZone = ToTemporalTimeZone(timeZone);\n        // Although TS doesn't acknowledge it, below here `timeZone` is a Temporal.TimeZoneProtocol\n        const { precision, unit, increment } = ToSecondsStringPrecision(options);\n        const roundingMode = ToTemporalRoundingMode(options, 'trunc');\n        const ns = GetSlot(this, EPOCHNANOSECONDS);\n        const roundedNs = RoundInstant(ns, increment, unit, roundingMode);\n        const roundedInstant = new Instant(roundedNs);\n        return TemporalInstantToString(roundedInstant, timeZone, precision);\n    }\n    toJSON() {\n        if (!IsTemporalInstant(this))\n            throw new TypeError('invalid receiver');\n        return TemporalInstantToString(this, undefined, 'auto');\n    }\n    toLocaleString(locales = undefined, options = undefined) {\n        if (!IsTemporalInstant(this))\n            throw new TypeError('invalid receiver');\n        return new DateTimeFormat(locales, options).format(this);\n    }\n    valueOf() {\n        throw new TypeError('use compare() or equals() to compare Temporal.Instant');\n    }\n    toZonedDateTime(item) {\n        if (!IsTemporalInstant(this))\n            throw new TypeError('invalid receiver');\n        if (!IsObject(item)) {\n            throw new TypeError('invalid argument in toZonedDateTime');\n        }\n        const calendarLike = item.calendar;\n        if (calendarLike === undefined) {\n            throw new TypeError('missing calendar property in toZonedDateTime');\n        }\n        const calendar = ToTemporalCalendar(calendarLike);\n        const temporalTimeZoneLike = item.timeZone;\n        if (temporalTimeZoneLike === undefined) {\n            throw new TypeError('missing timeZone property in toZonedDateTime');\n        }\n        const timeZone = ToTemporalTimeZone(temporalTimeZoneLike);\n        return CreateTemporalZonedDateTime(GetSlot(this, EPOCHNANOSECONDS), timeZone, calendar);\n    }\n    toZonedDateTimeISO(itemParam) {\n        let item = itemParam;\n        if (!IsTemporalInstant(this))\n            throw new TypeError('invalid receiver');\n        if (IsObject(item)) {\n            const timeZoneProperty = item.timeZone;\n            if (timeZoneProperty !== undefined) {\n                item = timeZoneProperty;\n            }\n        }\n        const timeZone = ToTemporalTimeZone(item);\n        const calendar = GetISO8601Calendar();\n        return CreateTemporalZonedDateTime(GetSlot(this, EPOCHNANOSECONDS), timeZone, calendar);\n    }\n    static fromEpochSeconds(epochSecondsParam) {\n        const epochSeconds = ToNumber(epochSecondsParam);\n        const epochNanoseconds = jsbi__WEBPACK_IMPORTED_MODULE_0__.multiply(jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(epochSeconds), BILLION);\n        ValidateEpochNanoseconds(epochNanoseconds);\n        return new Instant(epochNanoseconds);\n    }\n    static fromEpochMilliseconds(epochMillisecondsParam) {\n        const epochMilliseconds = ToNumber(epochMillisecondsParam);\n        const epochNanoseconds = jsbi__WEBPACK_IMPORTED_MODULE_0__.multiply(jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(epochMilliseconds), MILLION);\n        ValidateEpochNanoseconds(epochNanoseconds);\n        return new Instant(epochNanoseconds);\n    }\n    static fromEpochMicroseconds(epochMicrosecondsParam) {\n        const epochMicroseconds = ToBigInt(epochMicrosecondsParam);\n        const epochNanoseconds = jsbi__WEBPACK_IMPORTED_MODULE_0__.multiply(epochMicroseconds, THOUSAND);\n        ValidateEpochNanoseconds(epochNanoseconds);\n        return new Instant(epochNanoseconds);\n    }\n    static fromEpochNanoseconds(epochNanosecondsParam) {\n        const epochNanoseconds = ToBigInt(epochNanosecondsParam);\n        ValidateEpochNanoseconds(epochNanoseconds);\n        return new Instant(epochNanoseconds);\n    }\n    static from(item) {\n        if (IsTemporalInstant(item)) {\n            return new Instant(GetSlot(item, EPOCHNANOSECONDS));\n        }\n        return ToTemporalInstant(item);\n    }\n    static compare(oneParam, twoParam) {\n        const one = ToTemporalInstant(oneParam);\n        const two = ToTemporalInstant(twoParam);\n        const oneNs = GetSlot(one, EPOCHNANOSECONDS);\n        const twoNs = GetSlot(two, EPOCHNANOSECONDS);\n        if (jsbi__WEBPACK_IMPORTED_MODULE_0__.lessThan(oneNs, twoNs))\n            return -1;\n        if (jsbi__WEBPACK_IMPORTED_MODULE_0__.greaterThan(oneNs, twoNs))\n            return 1;\n        return 0;\n    }\n}\nMakeIntrinsicClass(Instant, 'Temporal.Instant');\n\nconst DISALLOWED_UNITS$2 = ['hour', 'minute', 'second', 'millisecond', 'microsecond', 'nanosecond'];\nclass PlainDate {\n    constructor(isoYearParam, isoMonthParam, isoDayParam, calendarParam = GetISO8601Calendar()) {\n        const isoYear = ToIntegerThrowOnInfinity(isoYearParam);\n        const isoMonth = ToIntegerThrowOnInfinity(isoMonthParam);\n        const isoDay = ToIntegerThrowOnInfinity(isoDayParam);\n        const calendar = ToTemporalCalendar(calendarParam);\n        // Note: if the arguments are not passed,\n        //       ToIntegerThrowOnInfinity(undefined) will have returned 0, which will\n        //       be rejected by RejectISODate in CreateTemporalDateSlots. This check\n        //       exists only to improve the error message.\n        if (arguments.length < 3) {\n            throw new RangeError('missing argument: isoYear, isoMonth and isoDay are required');\n        }\n        CreateTemporalDateSlots(this, isoYear, isoMonth, isoDay, calendar);\n    }\n    get calendar() {\n        if (!IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, CALENDAR);\n    }\n    get era() {\n        if (!IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        return CalendarEra(GetSlot(this, CALENDAR), this);\n    }\n    get eraYear() {\n        if (!IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        return CalendarEraYear(GetSlot(this, CALENDAR), this);\n    }\n    get year() {\n        if (!IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        return CalendarYear(GetSlot(this, CALENDAR), this);\n    }\n    get month() {\n        if (!IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        return CalendarMonth(GetSlot(this, CALENDAR), this);\n    }\n    get monthCode() {\n        if (!IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        return CalendarMonthCode(GetSlot(this, CALENDAR), this);\n    }\n    get day() {\n        if (!IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        return CalendarDay(GetSlot(this, CALENDAR), this);\n    }\n    get dayOfWeek() {\n        if (!IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        return CalendarDayOfWeek(GetSlot(this, CALENDAR), this);\n    }\n    get dayOfYear() {\n        if (!IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        return CalendarDayOfYear(GetSlot(this, CALENDAR), this);\n    }\n    get weekOfYear() {\n        if (!IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        return CalendarWeekOfYear(GetSlot(this, CALENDAR), this);\n    }\n    get daysInWeek() {\n        if (!IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        return CalendarDaysInWeek(GetSlot(this, CALENDAR), this);\n    }\n    get daysInMonth() {\n        if (!IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        return CalendarDaysInMonth(GetSlot(this, CALENDAR), this);\n    }\n    get daysInYear() {\n        if (!IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        return CalendarDaysInYear(GetSlot(this, CALENDAR), this);\n    }\n    get monthsInYear() {\n        if (!IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        return CalendarMonthsInYear(GetSlot(this, CALENDAR), this);\n    }\n    get inLeapYear() {\n        if (!IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        return CalendarInLeapYear(GetSlot(this, CALENDAR), this);\n    }\n    with(temporalDateLike, optionsParam = undefined) {\n        if (!IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        if (!IsObject(temporalDateLike)) {\n            throw new TypeError('invalid argument');\n        }\n        RejectObjectWithCalendarOrTimeZone(temporalDateLike);\n        const calendar = GetSlot(this, CALENDAR);\n        const fieldNames = CalendarFields(calendar, ['day', 'month', 'monthCode', 'year']);\n        const props = ToPartialRecord(temporalDateLike, fieldNames);\n        if (!props) {\n            throw new TypeError('invalid date-like');\n        }\n        let fields = ToTemporalDateFields(this, fieldNames);\n        fields = CalendarMergeFields(calendar, fields, props);\n        fields = ToTemporalDateFields(fields, fieldNames);\n        const options = GetOptionsObject(optionsParam);\n        return DateFromFields(calendar, fields, options);\n    }\n    withCalendar(calendarParam) {\n        if (!IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        const calendar = ToTemporalCalendar(calendarParam);\n        return new PlainDate(GetSlot(this, ISO_YEAR), GetSlot(this, ISO_MONTH), GetSlot(this, ISO_DAY), calendar);\n    }\n    add(temporalDurationLike, optionsParam = undefined) {\n        if (!IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        const duration = ToTemporalDuration(temporalDurationLike);\n        const options = GetOptionsObject(optionsParam);\n        return CalendarDateAdd(GetSlot(this, CALENDAR), this, duration, options);\n    }\n    subtract(temporalDurationLike, optionsParam = undefined) {\n        if (!IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        const duration = CreateNegatedTemporalDuration(ToTemporalDuration(temporalDurationLike));\n        const options = GetOptionsObject(optionsParam);\n        return CalendarDateAdd(GetSlot(this, CALENDAR), this, duration, options);\n    }\n    until(otherParam, optionsParam = undefined) {\n        if (!IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        const other = ToTemporalDate(otherParam);\n        const calendar = GetSlot(this, CALENDAR);\n        const otherCalendar = GetSlot(other, CALENDAR);\n        const calendarId = ToString(calendar);\n        const otherCalendarId = ToString(otherCalendar);\n        if (calendarId !== otherCalendarId) {\n            throw new RangeError(`cannot compute difference between dates of ${calendarId} and ${otherCalendarId} calendars`);\n        }\n        const options = GetOptionsObject(optionsParam);\n        const smallestUnit = ToSmallestTemporalUnit(options, 'day', DISALLOWED_UNITS$2);\n        const defaultLargestUnit = LargerOfTwoTemporalUnits('day', smallestUnit);\n        const largestUnit = ToLargestTemporalUnit(options, 'auto', DISALLOWED_UNITS$2, defaultLargestUnit);\n        ValidateTemporalUnitRange(largestUnit, smallestUnit);\n        const roundingMode = ToTemporalRoundingMode(options, 'trunc');\n        const roundingIncrement = ToTemporalRoundingIncrement(options, undefined, false);\n        const untilOptions = { ...options, largestUnit };\n        const result = CalendarDateUntil(calendar, this, other, untilOptions);\n        if (smallestUnit === 'day' && roundingIncrement === 1)\n            return result;\n        let { years, months, weeks, days } = result;\n        ({ years, months, weeks, days } = RoundDuration(years, months, weeks, days, 0, 0, 0, 0, 0, 0, roundingIncrement, smallestUnit, roundingMode, this));\n        const Duration = GetIntrinsic('%Temporal.Duration%');\n        return new Duration(years, months, weeks, days, 0, 0, 0, 0, 0, 0);\n    }\n    since(otherParam, optionsParam = undefined) {\n        if (!IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        const other = ToTemporalDate(otherParam);\n        const calendar = GetSlot(this, CALENDAR);\n        const otherCalendar = GetSlot(other, CALENDAR);\n        const calendarId = ToString(calendar);\n        const otherCalendarId = ToString(otherCalendar);\n        if (calendarId !== otherCalendarId) {\n            throw new RangeError(`cannot compute difference between dates of ${calendarId} and ${otherCalendarId} calendars`);\n        }\n        const options = GetOptionsObject(optionsParam);\n        const smallestUnit = ToSmallestTemporalUnit(options, 'day', DISALLOWED_UNITS$2);\n        const defaultLargestUnit = LargerOfTwoTemporalUnits('day', smallestUnit);\n        const largestUnit = ToLargestTemporalUnit(options, 'auto', DISALLOWED_UNITS$2, defaultLargestUnit);\n        ValidateTemporalUnitRange(largestUnit, smallestUnit);\n        const roundingMode = ToTemporalRoundingMode(options, 'trunc');\n        const roundingIncrement = ToTemporalRoundingIncrement(options, undefined, false);\n        const untilOptions = { ...options, largestUnit };\n        let { years, months, weeks, days } = CalendarDateUntil(calendar, this, other, untilOptions);\n        const Duration = GetIntrinsic('%Temporal.Duration%');\n        if (smallestUnit === 'day' && roundingIncrement === 1) {\n            return new Duration(-years, -months, -weeks, -days, 0, 0, 0, 0, 0, 0);\n        }\n        ({ years, months, weeks, days } = RoundDuration(years, months, weeks, days, 0, 0, 0, 0, 0, 0, roundingIncrement, smallestUnit, NegateTemporalRoundingMode(roundingMode), this));\n        return new Duration(-years, -months, -weeks, -days, 0, 0, 0, 0, 0, 0);\n    }\n    equals(otherParam) {\n        if (!IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        const other = ToTemporalDate(otherParam);\n        for (const slot of [ISO_YEAR, ISO_MONTH, ISO_DAY]) {\n            const val1 = GetSlot(this, slot);\n            const val2 = GetSlot(other, slot);\n            if (val1 !== val2)\n                return false;\n        }\n        return CalendarEquals(GetSlot(this, CALENDAR), GetSlot(other, CALENDAR));\n    }\n    toString(optionsParam = undefined) {\n        if (!IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        const options = GetOptionsObject(optionsParam);\n        const showCalendar = ToShowCalendarOption(options);\n        return TemporalDateToString(this, showCalendar);\n    }\n    toJSON() {\n        if (!IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        return TemporalDateToString(this);\n    }\n    toLocaleString(locales = undefined, options = undefined) {\n        if (!IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        return new DateTimeFormat(locales, options).format(this);\n    }\n    valueOf() {\n        throw new TypeError('use compare() or equals() to compare Temporal.PlainDate');\n    }\n    toPlainDateTime(temporalTimeParam = undefined) {\n        if (!IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        const year = GetSlot(this, ISO_YEAR);\n        const month = GetSlot(this, ISO_MONTH);\n        const day = GetSlot(this, ISO_DAY);\n        const calendar = GetSlot(this, CALENDAR);\n        if (temporalTimeParam === undefined)\n            return CreateTemporalDateTime(year, month, day, 0, 0, 0, 0, 0, 0, calendar);\n        const temporalTime = ToTemporalTime(temporalTimeParam);\n        const hour = GetSlot(temporalTime, ISO_HOUR);\n        const minute = GetSlot(temporalTime, ISO_MINUTE);\n        const second = GetSlot(temporalTime, ISO_SECOND);\n        const millisecond = GetSlot(temporalTime, ISO_MILLISECOND);\n        const microsecond = GetSlot(temporalTime, ISO_MICROSECOND);\n        const nanosecond = GetSlot(temporalTime, ISO_NANOSECOND);\n        return CreateTemporalDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar);\n    }\n    toZonedDateTime(item) {\n        if (!IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        let timeZone, temporalTime;\n        if (IsObject(item)) {\n            const timeZoneLike = item.timeZone;\n            if (timeZoneLike === undefined) {\n                // The cast below is needed because it's possible here for\n                // `timeZoneLike` here to be `{ plainTime: Temporal.PlainTimeLike }`,\n                // not a TimeZoneProtocol.\n                // TODO: should we check for that shape to improve on the (bad) error\n                // message that the caller will get from ToTemporalTimeZone?\n                timeZone = ToTemporalTimeZone(item);\n            }\n            else {\n                timeZone = ToTemporalTimeZone(timeZoneLike);\n                temporalTime = item.plainTime;\n            }\n        }\n        else {\n            timeZone = ToTemporalTimeZone(item);\n        }\n        const year = GetSlot(this, ISO_YEAR);\n        const month = GetSlot(this, ISO_MONTH);\n        const day = GetSlot(this, ISO_DAY);\n        const calendar = GetSlot(this, CALENDAR);\n        let hour = 0, minute = 0, second = 0, millisecond = 0, microsecond = 0, nanosecond = 0;\n        if (temporalTime !== undefined) {\n            temporalTime = ToTemporalTime(temporalTime);\n            hour = GetSlot(temporalTime, ISO_HOUR);\n            minute = GetSlot(temporalTime, ISO_MINUTE);\n            second = GetSlot(temporalTime, ISO_SECOND);\n            millisecond = GetSlot(temporalTime, ISO_MILLISECOND);\n            microsecond = GetSlot(temporalTime, ISO_MICROSECOND);\n            nanosecond = GetSlot(temporalTime, ISO_NANOSECOND);\n        }\n        const dt = CreateTemporalDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar);\n        const instant = BuiltinTimeZoneGetInstantFor(timeZone, dt, 'compatible');\n        return CreateTemporalZonedDateTime(GetSlot(instant, EPOCHNANOSECONDS), timeZone, calendar);\n    }\n    toPlainYearMonth() {\n        if (!IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        const calendar = GetSlot(this, CALENDAR);\n        const fieldNames = CalendarFields(calendar, ['monthCode', 'year']);\n        const fields = ToTemporalYearMonthFields(this, fieldNames);\n        return YearMonthFromFields(calendar, fields);\n    }\n    toPlainMonthDay() {\n        if (!IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        const calendar = GetSlot(this, CALENDAR);\n        const fieldNames = CalendarFields(calendar, ['day', 'monthCode']);\n        const fields = ToTemporalMonthDayFields(this, fieldNames);\n        return MonthDayFromFields(calendar, fields);\n    }\n    getISOFields() {\n        if (!IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        return {\n            calendar: GetSlot(this, CALENDAR),\n            isoDay: GetSlot(this, ISO_DAY),\n            isoMonth: GetSlot(this, ISO_MONTH),\n            isoYear: GetSlot(this, ISO_YEAR)\n        };\n    }\n    static from(item, optionsParam = undefined) {\n        const options = GetOptionsObject(optionsParam);\n        if (IsTemporalDate(item)) {\n            ToTemporalOverflow(options); // validate and ignore\n            return CreateTemporalDate(GetSlot(item, ISO_YEAR), GetSlot(item, ISO_MONTH), GetSlot(item, ISO_DAY), GetSlot(item, CALENDAR));\n        }\n        return ToTemporalDate(item, options);\n    }\n    static compare(oneParam, twoParam) {\n        const one = ToTemporalDate(oneParam);\n        const two = ToTemporalDate(twoParam);\n        return CompareISODate(GetSlot(one, ISO_YEAR), GetSlot(one, ISO_MONTH), GetSlot(one, ISO_DAY), GetSlot(two, ISO_YEAR), GetSlot(two, ISO_MONTH), GetSlot(two, ISO_DAY));\n    }\n}\nMakeIntrinsicClass(PlainDate, 'Temporal.PlainDate');\n\nclass PlainDateTime {\n    constructor(isoYearParam, isoMonthParam, isoDayParam, hourParam = 0, minuteParam = 0, secondParam = 0, millisecondParam = 0, microsecondParam = 0, nanosecondParam = 0, calendarParam = GetISO8601Calendar()) {\n        const isoYear = ToIntegerThrowOnInfinity(isoYearParam);\n        const isoMonth = ToIntegerThrowOnInfinity(isoMonthParam);\n        const isoDay = ToIntegerThrowOnInfinity(isoDayParam);\n        const hour = ToIntegerThrowOnInfinity(hourParam);\n        const minute = ToIntegerThrowOnInfinity(minuteParam);\n        const second = ToIntegerThrowOnInfinity(secondParam);\n        const millisecond = ToIntegerThrowOnInfinity(millisecondParam);\n        const microsecond = ToIntegerThrowOnInfinity(microsecondParam);\n        const nanosecond = ToIntegerThrowOnInfinity(nanosecondParam);\n        const calendar = ToTemporalCalendar(calendarParam);\n        // Note: if the arguments are not passed,\n        //       ToIntegerThrowOnInfinity(undefined) will have returned 0, which will\n        //       be rejected by RejectDateTime in CreateTemporalDateTimeSlots. This\n        //       check exists only to improve the error message.\n        if (arguments.length < 3) {\n            throw new RangeError('missing argument: isoYear, isoMonth and isoDay are required');\n        }\n        CreateTemporalDateTimeSlots(this, isoYear, isoMonth, isoDay, hour, minute, second, millisecond, microsecond, nanosecond, calendar);\n    }\n    get calendar() {\n        if (!IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, CALENDAR);\n    }\n    get year() {\n        if (!IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        return CalendarYear(GetSlot(this, CALENDAR), this);\n    }\n    get month() {\n        if (!IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        return CalendarMonth(GetSlot(this, CALENDAR), this);\n    }\n    get monthCode() {\n        if (!IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        return CalendarMonthCode(GetSlot(this, CALENDAR), this);\n    }\n    get day() {\n        if (!IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        return CalendarDay(GetSlot(this, CALENDAR), this);\n    }\n    get hour() {\n        if (!IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, ISO_HOUR);\n    }\n    get minute() {\n        if (!IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, ISO_MINUTE);\n    }\n    get second() {\n        if (!IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, ISO_SECOND);\n    }\n    get millisecond() {\n        if (!IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, ISO_MILLISECOND);\n    }\n    get microsecond() {\n        if (!IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, ISO_MICROSECOND);\n    }\n    get nanosecond() {\n        if (!IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, ISO_NANOSECOND);\n    }\n    get era() {\n        if (!IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        return CalendarEra(GetSlot(this, CALENDAR), this);\n    }\n    get eraYear() {\n        if (!IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        return CalendarEraYear(GetSlot(this, CALENDAR), this);\n    }\n    get dayOfWeek() {\n        if (!IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        return CalendarDayOfWeek(GetSlot(this, CALENDAR), this);\n    }\n    get dayOfYear() {\n        if (!IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        return CalendarDayOfYear(GetSlot(this, CALENDAR), this);\n    }\n    get weekOfYear() {\n        if (!IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        return CalendarWeekOfYear(GetSlot(this, CALENDAR), this);\n    }\n    get daysInWeek() {\n        if (!IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        return CalendarDaysInWeek(GetSlot(this, CALENDAR), this);\n    }\n    get daysInYear() {\n        if (!IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        return CalendarDaysInYear(GetSlot(this, CALENDAR), this);\n    }\n    get daysInMonth() {\n        if (!IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        return CalendarDaysInMonth(GetSlot(this, CALENDAR), this);\n    }\n    get monthsInYear() {\n        if (!IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        return CalendarMonthsInYear(GetSlot(this, CALENDAR), this);\n    }\n    get inLeapYear() {\n        if (!IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        return CalendarInLeapYear(GetSlot(this, CALENDAR), this);\n    }\n    with(temporalDateTimeLike, optionsParam = undefined) {\n        if (!IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        if (!IsObject(temporalDateTimeLike)) {\n            throw new TypeError('invalid argument');\n        }\n        RejectObjectWithCalendarOrTimeZone(temporalDateTimeLike);\n        const options = GetOptionsObject(optionsParam);\n        const calendar = GetSlot(this, CALENDAR);\n        const fieldNames = CalendarFields(calendar, [\n            'day',\n            'hour',\n            'microsecond',\n            'millisecond',\n            'minute',\n            'month',\n            'monthCode',\n            'nanosecond',\n            'second',\n            'year'\n        ]);\n        const props = ToPartialRecord(temporalDateTimeLike, fieldNames);\n        if (!props) {\n            throw new TypeError('invalid date-time-like');\n        }\n        let fields = ToTemporalDateTimeFields(this, fieldNames);\n        fields = CalendarMergeFields(calendar, fields, props);\n        fields = ToTemporalDateTimeFields(fields, fieldNames);\n        const { year, month, day, hour, minute, second, millisecond, microsecond, nanosecond } = InterpretTemporalDateTimeFields(calendar, fields, options);\n        return CreateTemporalDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar);\n    }\n    withPlainTime(temporalTimeParam = undefined) {\n        if (!IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        const year = GetSlot(this, ISO_YEAR);\n        const month = GetSlot(this, ISO_MONTH);\n        const day = GetSlot(this, ISO_DAY);\n        const calendar = GetSlot(this, CALENDAR);\n        if (temporalTimeParam === undefined)\n            return CreateTemporalDateTime(year, month, day, 0, 0, 0, 0, 0, 0, calendar);\n        const temporalTime = ToTemporalTime(temporalTimeParam);\n        const hour = GetSlot(temporalTime, ISO_HOUR);\n        const minute = GetSlot(temporalTime, ISO_MINUTE);\n        const second = GetSlot(temporalTime, ISO_SECOND);\n        const millisecond = GetSlot(temporalTime, ISO_MILLISECOND);\n        const microsecond = GetSlot(temporalTime, ISO_MICROSECOND);\n        const nanosecond = GetSlot(temporalTime, ISO_NANOSECOND);\n        return CreateTemporalDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar);\n    }\n    withPlainDate(temporalDateParam) {\n        if (!IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        const temporalDate = ToTemporalDate(temporalDateParam);\n        const year = GetSlot(temporalDate, ISO_YEAR);\n        const month = GetSlot(temporalDate, ISO_MONTH);\n        const day = GetSlot(temporalDate, ISO_DAY);\n        let calendar = GetSlot(temporalDate, CALENDAR);\n        const hour = GetSlot(this, ISO_HOUR);\n        const minute = GetSlot(this, ISO_MINUTE);\n        const second = GetSlot(this, ISO_SECOND);\n        const millisecond = GetSlot(this, ISO_MILLISECOND);\n        const microsecond = GetSlot(this, ISO_MICROSECOND);\n        const nanosecond = GetSlot(this, ISO_NANOSECOND);\n        calendar = ConsolidateCalendars(GetSlot(this, CALENDAR), calendar);\n        return CreateTemporalDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar);\n    }\n    withCalendar(calendarParam) {\n        if (!IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        const calendar = ToTemporalCalendar(calendarParam);\n        return new PlainDateTime(GetSlot(this, ISO_YEAR), GetSlot(this, ISO_MONTH), GetSlot(this, ISO_DAY), GetSlot(this, ISO_HOUR), GetSlot(this, ISO_MINUTE), GetSlot(this, ISO_SECOND), GetSlot(this, ISO_MILLISECOND), GetSlot(this, ISO_MICROSECOND), GetSlot(this, ISO_NANOSECOND), calendar);\n    }\n    add(temporalDurationLike, optionsParam = undefined) {\n        if (!IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        const duration = ToLimitedTemporalDuration(temporalDurationLike);\n        const { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = duration;\n        const options = GetOptionsObject(optionsParam);\n        const calendar = GetSlot(this, CALENDAR);\n        const { year, month, day, hour, minute, second, millisecond, microsecond, nanosecond } = AddDateTime(GetSlot(this, ISO_YEAR), GetSlot(this, ISO_MONTH), GetSlot(this, ISO_DAY), GetSlot(this, ISO_HOUR), GetSlot(this, ISO_MINUTE), GetSlot(this, ISO_SECOND), GetSlot(this, ISO_MILLISECOND), GetSlot(this, ISO_MICROSECOND), GetSlot(this, ISO_NANOSECOND), calendar, years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, options);\n        return CreateTemporalDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar);\n    }\n    subtract(temporalDurationLike, optionsParam = undefined) {\n        if (!IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        const duration = ToLimitedTemporalDuration(temporalDurationLike);\n        const { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = duration;\n        const options = GetOptionsObject(optionsParam);\n        const calendar = GetSlot(this, CALENDAR);\n        const { year, month, day, hour, minute, second, millisecond, microsecond, nanosecond } = AddDateTime(GetSlot(this, ISO_YEAR), GetSlot(this, ISO_MONTH), GetSlot(this, ISO_DAY), GetSlot(this, ISO_HOUR), GetSlot(this, ISO_MINUTE), GetSlot(this, ISO_SECOND), GetSlot(this, ISO_MILLISECOND), GetSlot(this, ISO_MICROSECOND), GetSlot(this, ISO_NANOSECOND), calendar, -years, -months, -weeks, -days, -hours, -minutes, -seconds, -milliseconds, -microseconds, -nanoseconds, options);\n        return CreateTemporalDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar);\n    }\n    until(otherParam, optionsParam = undefined) {\n        if (!IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        const other = ToTemporalDateTime(otherParam);\n        const calendar = GetSlot(this, CALENDAR);\n        const otherCalendar = GetSlot(other, CALENDAR);\n        const calendarId = ToString(calendar);\n        const otherCalendarId = ToString(otherCalendar);\n        if (calendarId !== otherCalendarId) {\n            throw new RangeError(`cannot compute difference between dates of ${calendarId} and ${otherCalendarId} calendars`);\n        }\n        const options = GetOptionsObject(optionsParam);\n        const smallestUnit = ToSmallestTemporalUnit(options, 'nanosecond');\n        const defaultLargestUnit = LargerOfTwoTemporalUnits('day', smallestUnit);\n        const largestUnit = ToLargestTemporalUnit(options, 'auto', [], defaultLargestUnit);\n        ValidateTemporalUnitRange(largestUnit, smallestUnit);\n        const roundingMode = ToTemporalRoundingMode(options, 'trunc');\n        const roundingIncrement = ToTemporalDateTimeRoundingIncrement(options, smallestUnit);\n        let { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = DifferenceISODateTime(GetSlot(this, ISO_YEAR), GetSlot(this, ISO_MONTH), GetSlot(this, ISO_DAY), GetSlot(this, ISO_HOUR), GetSlot(this, ISO_MINUTE), GetSlot(this, ISO_SECOND), GetSlot(this, ISO_MILLISECOND), GetSlot(this, ISO_MICROSECOND), GetSlot(this, ISO_NANOSECOND), GetSlot(other, ISO_YEAR), GetSlot(other, ISO_MONTH), GetSlot(other, ISO_DAY), GetSlot(other, ISO_HOUR), GetSlot(other, ISO_MINUTE), GetSlot(other, ISO_SECOND), GetSlot(other, ISO_MILLISECOND), GetSlot(other, ISO_MICROSECOND), GetSlot(other, ISO_NANOSECOND), calendar, largestUnit, options);\n        const relativeTo = TemporalDateTimeToDate(this);\n        ({ years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } =\n            RoundDuration(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, roundingIncrement, smallestUnit, roundingMode, relativeTo));\n        ({ days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = BalanceDuration(days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, largestUnit));\n        const Duration = GetIntrinsic('%Temporal.Duration%');\n        return new Duration(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n    }\n    since(otherParam, optionsParam = undefined) {\n        if (!IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        const other = ToTemporalDateTime(otherParam);\n        const calendar = GetSlot(this, CALENDAR);\n        const otherCalendar = GetSlot(other, CALENDAR);\n        const calendarId = ToString(calendar);\n        const otherCalendarId = ToString(otherCalendar);\n        if (calendarId !== otherCalendarId) {\n            throw new RangeError(`cannot compute difference between dates of ${calendarId} and ${otherCalendarId} calendars`);\n        }\n        const options = GetOptionsObject(optionsParam);\n        const smallestUnit = ToSmallestTemporalUnit(options, 'nanosecond');\n        const defaultLargestUnit = LargerOfTwoTemporalUnits('day', smallestUnit);\n        const largestUnit = ToLargestTemporalUnit(options, 'auto', [], defaultLargestUnit);\n        ValidateTemporalUnitRange(largestUnit, smallestUnit);\n        const roundingMode = ToTemporalRoundingMode(options, 'trunc');\n        const roundingIncrement = ToTemporalDateTimeRoundingIncrement(options, smallestUnit);\n        let { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = DifferenceISODateTime(GetSlot(this, ISO_YEAR), GetSlot(this, ISO_MONTH), GetSlot(this, ISO_DAY), GetSlot(this, ISO_HOUR), GetSlot(this, ISO_MINUTE), GetSlot(this, ISO_SECOND), GetSlot(this, ISO_MILLISECOND), GetSlot(this, ISO_MICROSECOND), GetSlot(this, ISO_NANOSECOND), GetSlot(other, ISO_YEAR), GetSlot(other, ISO_MONTH), GetSlot(other, ISO_DAY), GetSlot(other, ISO_HOUR), GetSlot(other, ISO_MINUTE), GetSlot(other, ISO_SECOND), GetSlot(other, ISO_MILLISECOND), GetSlot(other, ISO_MICROSECOND), GetSlot(other, ISO_NANOSECOND), calendar, largestUnit, options);\n        const relativeTo = TemporalDateTimeToDate(this);\n        ({ years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } =\n            RoundDuration(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, roundingIncrement, smallestUnit, NegateTemporalRoundingMode(roundingMode), relativeTo));\n        ({ days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = BalanceDuration(days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, largestUnit));\n        const Duration = GetIntrinsic('%Temporal.Duration%');\n        return new Duration(-years, -months, -weeks, -days, -hours, -minutes, -seconds, -milliseconds, -microseconds, -nanoseconds);\n    }\n    round(optionsParam) {\n        if (!IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        if (optionsParam === undefined)\n            throw new TypeError('options parameter is required');\n        const options = typeof optionsParam === 'string'\n            ? CreateOnePropObject('smallestUnit', optionsParam)\n            : GetOptionsObject(optionsParam);\n        const smallestUnit = ToSmallestTemporalUnit(options, undefined, ['year', 'month', 'week']);\n        if (smallestUnit === undefined)\n            throw new RangeError('smallestUnit is required');\n        const roundingMode = ToTemporalRoundingMode(options, 'halfExpand');\n        const maximumIncrements = {\n            day: 1,\n            hour: 24,\n            minute: 60,\n            second: 60,\n            millisecond: 1000,\n            microsecond: 1000,\n            nanosecond: 1000\n        };\n        const roundingIncrement = ToTemporalRoundingIncrement(options, maximumIncrements[smallestUnit], false);\n        let year = GetSlot(this, ISO_YEAR);\n        let month = GetSlot(this, ISO_MONTH);\n        let day = GetSlot(this, ISO_DAY);\n        let hour = GetSlot(this, ISO_HOUR);\n        let minute = GetSlot(this, ISO_MINUTE);\n        let second = GetSlot(this, ISO_SECOND);\n        let millisecond = GetSlot(this, ISO_MILLISECOND);\n        let microsecond = GetSlot(this, ISO_MICROSECOND);\n        let nanosecond = GetSlot(this, ISO_NANOSECOND);\n        ({ year, month, day, hour, minute, second, millisecond, microsecond, nanosecond } = RoundISODateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, roundingIncrement, smallestUnit, roundingMode));\n        return CreateTemporalDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, GetSlot(this, CALENDAR));\n    }\n    equals(otherParam) {\n        if (!IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        const other = ToTemporalDateTime(otherParam);\n        for (const slot of [\n            ISO_YEAR,\n            ISO_MONTH,\n            ISO_DAY,\n            ISO_HOUR,\n            ISO_MINUTE,\n            ISO_SECOND,\n            ISO_MILLISECOND,\n            ISO_MICROSECOND,\n            ISO_NANOSECOND\n        ]) {\n            const val1 = GetSlot(this, slot);\n            const val2 = GetSlot(other, slot);\n            if (val1 !== val2)\n                return false;\n        }\n        return CalendarEquals(GetSlot(this, CALENDAR), GetSlot(other, CALENDAR));\n    }\n    toString(optionsParam = undefined) {\n        if (!IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        const options = GetOptionsObject(optionsParam);\n        const { precision, unit, increment } = ToSecondsStringPrecision(options);\n        const showCalendar = ToShowCalendarOption(options);\n        const roundingMode = ToTemporalRoundingMode(options, 'trunc');\n        return TemporalDateTimeToString(this, precision, showCalendar, { unit, increment, roundingMode });\n    }\n    toJSON() {\n        if (!IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        return TemporalDateTimeToString(this, 'auto');\n    }\n    toLocaleString(locales = undefined, options = undefined) {\n        if (!IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        return new DateTimeFormat(locales, options).format(this);\n    }\n    valueOf() {\n        throw new TypeError('use compare() or equals() to compare Temporal.PlainDateTime');\n    }\n    toZonedDateTime(temporalTimeZoneLike, optionsParam = undefined) {\n        if (!IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        const timeZone = ToTemporalTimeZone(temporalTimeZoneLike);\n        const options = GetOptionsObject(optionsParam);\n        const disambiguation = ToTemporalDisambiguation(options);\n        const instant = BuiltinTimeZoneGetInstantFor(timeZone, this, disambiguation);\n        return CreateTemporalZonedDateTime(GetSlot(instant, EPOCHNANOSECONDS), timeZone, GetSlot(this, CALENDAR));\n    }\n    toPlainDate() {\n        if (!IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        return TemporalDateTimeToDate(this);\n    }\n    toPlainYearMonth() {\n        if (!IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        const calendar = GetSlot(this, CALENDAR);\n        const fieldNames = CalendarFields(calendar, ['monthCode', 'year']);\n        const fields = ToTemporalYearMonthFields(this, fieldNames);\n        return YearMonthFromFields(calendar, fields);\n    }\n    toPlainMonthDay() {\n        if (!IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        const calendar = GetSlot(this, CALENDAR);\n        const fieldNames = CalendarFields(calendar, ['day', 'monthCode']);\n        const fields = ToTemporalMonthDayFields(this, fieldNames);\n        return MonthDayFromFields(calendar, fields);\n    }\n    toPlainTime() {\n        if (!IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        return TemporalDateTimeToTime(this);\n    }\n    getISOFields() {\n        if (!IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        return {\n            calendar: GetSlot(this, CALENDAR),\n            isoDay: GetSlot(this, ISO_DAY),\n            isoHour: GetSlot(this, ISO_HOUR),\n            isoMicrosecond: GetSlot(this, ISO_MICROSECOND),\n            isoMillisecond: GetSlot(this, ISO_MILLISECOND),\n            isoMinute: GetSlot(this, ISO_MINUTE),\n            isoMonth: GetSlot(this, ISO_MONTH),\n            isoNanosecond: GetSlot(this, ISO_NANOSECOND),\n            isoSecond: GetSlot(this, ISO_SECOND),\n            isoYear: GetSlot(this, ISO_YEAR)\n        };\n    }\n    static from(item, optionsParam = undefined) {\n        const options = GetOptionsObject(optionsParam);\n        if (IsTemporalDateTime(item)) {\n            ToTemporalOverflow(options); // validate and ignore\n            return CreateTemporalDateTime(GetSlot(item, ISO_YEAR), GetSlot(item, ISO_MONTH), GetSlot(item, ISO_DAY), GetSlot(item, ISO_HOUR), GetSlot(item, ISO_MINUTE), GetSlot(item, ISO_SECOND), GetSlot(item, ISO_MILLISECOND), GetSlot(item, ISO_MICROSECOND), GetSlot(item, ISO_NANOSECOND), GetSlot(item, CALENDAR));\n        }\n        return ToTemporalDateTime(item, options);\n    }\n    static compare(oneParam, twoParam) {\n        const one = ToTemporalDateTime(oneParam);\n        const two = ToTemporalDateTime(twoParam);\n        for (const slot of [\n            ISO_YEAR,\n            ISO_MONTH,\n            ISO_DAY,\n            ISO_HOUR,\n            ISO_MINUTE,\n            ISO_SECOND,\n            ISO_MILLISECOND,\n            ISO_MICROSECOND,\n            ISO_NANOSECOND\n        ]) {\n            const val1 = GetSlot(one, slot);\n            const val2 = GetSlot(two, slot);\n            if (val1 !== val2)\n                return ComparisonResult(val1 - val2);\n        }\n        return 0;\n    }\n}\nMakeIntrinsicClass(PlainDateTime, 'Temporal.PlainDateTime');\n\nclass Duration {\n    constructor(yearsParam = 0, monthsParam = 0, weeksParam = 0, daysParam = 0, hoursParam = 0, minutesParam = 0, secondsParam = 0, millisecondsParam = 0, microsecondsParam = 0, nanosecondsParam = 0) {\n        const years = ToIntegerWithoutRounding(yearsParam);\n        const months = ToIntegerWithoutRounding(monthsParam);\n        const weeks = ToIntegerWithoutRounding(weeksParam);\n        const days = ToIntegerWithoutRounding(daysParam);\n        const hours = ToIntegerWithoutRounding(hoursParam);\n        const minutes = ToIntegerWithoutRounding(minutesParam);\n        const seconds = ToIntegerWithoutRounding(secondsParam);\n        const milliseconds = ToIntegerWithoutRounding(millisecondsParam);\n        const microseconds = ToIntegerWithoutRounding(microsecondsParam);\n        const nanoseconds = ToIntegerWithoutRounding(nanosecondsParam);\n        const sign = DurationSign(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n        for (const prop of [years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds]) {\n            if (!Number.isFinite(prop))\n                throw new RangeError('infinite values not allowed as duration fields');\n            const propSign = Math.sign(prop);\n            if (propSign !== 0 && propSign !== sign)\n                throw new RangeError('mixed-sign values not allowed as duration fields');\n        }\n        CreateSlots(this);\n        SetSlot(this, YEARS, years);\n        SetSlot(this, MONTHS, months);\n        SetSlot(this, WEEKS, weeks);\n        SetSlot(this, DAYS, days);\n        SetSlot(this, HOURS, hours);\n        SetSlot(this, MINUTES, minutes);\n        SetSlot(this, SECONDS, seconds);\n        SetSlot(this, MILLISECONDS, milliseconds);\n        SetSlot(this, MICROSECONDS, microseconds);\n        SetSlot(this, NANOSECONDS, nanoseconds);\n        {\n            Object.defineProperty(this, '_repr_', {\n                value: `${this[Symbol.toStringTag]} <${TemporalDurationToString(this)}>`,\n                writable: false,\n                enumerable: false,\n                configurable: false\n            });\n        }\n    }\n    get years() {\n        if (!IsTemporalDuration(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, YEARS);\n    }\n    get months() {\n        if (!IsTemporalDuration(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, MONTHS);\n    }\n    get weeks() {\n        if (!IsTemporalDuration(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, WEEKS);\n    }\n    get days() {\n        if (!IsTemporalDuration(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, DAYS);\n    }\n    get hours() {\n        if (!IsTemporalDuration(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, HOURS);\n    }\n    get minutes() {\n        if (!IsTemporalDuration(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, MINUTES);\n    }\n    get seconds() {\n        if (!IsTemporalDuration(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, SECONDS);\n    }\n    get milliseconds() {\n        if (!IsTemporalDuration(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, MILLISECONDS);\n    }\n    get microseconds() {\n        if (!IsTemporalDuration(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, MICROSECONDS);\n    }\n    get nanoseconds() {\n        if (!IsTemporalDuration(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, NANOSECONDS);\n    }\n    get sign() {\n        if (!IsTemporalDuration(this))\n            throw new TypeError('invalid receiver');\n        return DurationSign(GetSlot(this, YEARS), GetSlot(this, MONTHS), GetSlot(this, WEEKS), GetSlot(this, DAYS), GetSlot(this, HOURS), GetSlot(this, MINUTES), GetSlot(this, SECONDS), GetSlot(this, MILLISECONDS), GetSlot(this, MICROSECONDS), GetSlot(this, NANOSECONDS));\n    }\n    get blank() {\n        if (!IsTemporalDuration(this))\n            throw new TypeError('invalid receiver');\n        return (DurationSign(GetSlot(this, YEARS), GetSlot(this, MONTHS), GetSlot(this, WEEKS), GetSlot(this, DAYS), GetSlot(this, HOURS), GetSlot(this, MINUTES), GetSlot(this, SECONDS), GetSlot(this, MILLISECONDS), GetSlot(this, MICROSECONDS), GetSlot(this, NANOSECONDS)) === 0);\n    }\n    with(durationLike) {\n        if (!IsTemporalDuration(this))\n            throw new TypeError('invalid receiver');\n        const props = ToPartialRecord(durationLike, [\n            'days',\n            'hours',\n            'microseconds',\n            'milliseconds',\n            'minutes',\n            'months',\n            'nanoseconds',\n            'seconds',\n            'weeks',\n            'years'\n        ]);\n        if (!props) {\n            throw new TypeError('invalid duration-like');\n        }\n        const { years = GetSlot(this, YEARS), months = GetSlot(this, MONTHS), weeks = GetSlot(this, WEEKS), days = GetSlot(this, DAYS), hours = GetSlot(this, HOURS), minutes = GetSlot(this, MINUTES), seconds = GetSlot(this, SECONDS), milliseconds = GetSlot(this, MILLISECONDS), microseconds = GetSlot(this, MICROSECONDS), nanoseconds = GetSlot(this, NANOSECONDS) } = props;\n        return new Duration(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n    }\n    negated() {\n        if (!IsTemporalDuration(this))\n            throw new TypeError('invalid receiver');\n        return CreateNegatedTemporalDuration(this);\n    }\n    abs() {\n        if (!IsTemporalDuration(this))\n            throw new TypeError('invalid receiver');\n        return new Duration(Math.abs(GetSlot(this, YEARS)), Math.abs(GetSlot(this, MONTHS)), Math.abs(GetSlot(this, WEEKS)), Math.abs(GetSlot(this, DAYS)), Math.abs(GetSlot(this, HOURS)), Math.abs(GetSlot(this, MINUTES)), Math.abs(GetSlot(this, SECONDS)), Math.abs(GetSlot(this, MILLISECONDS)), Math.abs(GetSlot(this, MICROSECONDS)), Math.abs(GetSlot(this, NANOSECONDS)));\n    }\n    add(other, optionsParam = undefined) {\n        if (!IsTemporalDuration(this))\n            throw new TypeError('invalid receiver');\n        let { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = ToLimitedTemporalDuration(other);\n        const options = GetOptionsObject(optionsParam);\n        const relativeTo = ToRelativeTemporalObject(options);\n        ({ years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = AddDuration(GetSlot(this, YEARS), GetSlot(this, MONTHS), GetSlot(this, WEEKS), GetSlot(this, DAYS), GetSlot(this, HOURS), GetSlot(this, MINUTES), GetSlot(this, SECONDS), GetSlot(this, MILLISECONDS), GetSlot(this, MICROSECONDS), GetSlot(this, NANOSECONDS), years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, relativeTo));\n        return new Duration(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n    }\n    subtract(other, optionsParam = undefined) {\n        if (!IsTemporalDuration(this))\n            throw new TypeError('invalid receiver');\n        let { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = ToLimitedTemporalDuration(other);\n        const options = GetOptionsObject(optionsParam);\n        const relativeTo = ToRelativeTemporalObject(options);\n        ({ years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = AddDuration(GetSlot(this, YEARS), GetSlot(this, MONTHS), GetSlot(this, WEEKS), GetSlot(this, DAYS), GetSlot(this, HOURS), GetSlot(this, MINUTES), GetSlot(this, SECONDS), GetSlot(this, MILLISECONDS), GetSlot(this, MICROSECONDS), GetSlot(this, NANOSECONDS), -years, -months, -weeks, -days, -hours, -minutes, -seconds, -milliseconds, -microseconds, -nanoseconds, relativeTo));\n        return new Duration(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n    }\n    round(optionsParam) {\n        if (!IsTemporalDuration(this))\n            throw new TypeError('invalid receiver');\n        if (optionsParam === undefined)\n            throw new TypeError('options parameter is required');\n        let years = GetSlot(this, YEARS);\n        let months = GetSlot(this, MONTHS);\n        let weeks = GetSlot(this, WEEKS);\n        let days = GetSlot(this, DAYS);\n        let hours = GetSlot(this, HOURS);\n        let minutes = GetSlot(this, MINUTES);\n        let seconds = GetSlot(this, SECONDS);\n        let milliseconds = GetSlot(this, MILLISECONDS);\n        let microseconds = GetSlot(this, MICROSECONDS);\n        let nanoseconds = GetSlot(this, NANOSECONDS);\n        let defaultLargestUnit = DefaultTemporalLargestUnit(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n        const options = typeof optionsParam === 'string'\n            ? CreateOnePropObject('smallestUnit', optionsParam)\n            : GetOptionsObject(optionsParam);\n        let smallestUnit = ToSmallestTemporalUnit(options, undefined);\n        let smallestUnitPresent = true;\n        if (!smallestUnit) {\n            smallestUnitPresent = false;\n            smallestUnit = 'nanosecond';\n        }\n        defaultLargestUnit = LargerOfTwoTemporalUnits(defaultLargestUnit, smallestUnit);\n        let largestUnit = ToLargestTemporalUnit(options, undefined);\n        let largestUnitPresent = true;\n        if (!largestUnit) {\n            largestUnitPresent = false;\n            largestUnit = defaultLargestUnit;\n        }\n        if (largestUnit === 'auto')\n            largestUnit = defaultLargestUnit;\n        if (!smallestUnitPresent && !largestUnitPresent) {\n            throw new RangeError('at least one of smallestUnit or largestUnit is required');\n        }\n        ValidateTemporalUnitRange(largestUnit, smallestUnit);\n        const roundingMode = ToTemporalRoundingMode(options, 'halfExpand');\n        const roundingIncrement = ToTemporalDateTimeRoundingIncrement(options, smallestUnit);\n        let relativeTo = ToRelativeTemporalObject(options);\n        ({ years, months, weeks, days } = UnbalanceDurationRelative(years, months, weeks, days, largestUnit, relativeTo));\n        ({ years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } =\n            RoundDuration(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, roundingIncrement, smallestUnit, roundingMode, relativeTo));\n        ({ years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } =\n            AdjustRoundedDurationDays(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, roundingIncrement, smallestUnit, roundingMode, relativeTo));\n        ({ years, months, weeks, days } = BalanceDurationRelative(years, months, weeks, days, largestUnit, relativeTo));\n        if (IsTemporalZonedDateTime(relativeTo)) {\n            relativeTo = MoveRelativeZonedDateTime(relativeTo, years, months, weeks, 0);\n        }\n        ({ days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = BalanceDuration(days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, largestUnit, relativeTo));\n        return new Duration(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n    }\n    total(optionsParam) {\n        if (!IsTemporalDuration(this))\n            throw new TypeError('invalid receiver');\n        let years = GetSlot(this, YEARS);\n        let months = GetSlot(this, MONTHS);\n        let weeks = GetSlot(this, WEEKS);\n        let days = GetSlot(this, DAYS);\n        let hours = GetSlot(this, HOURS);\n        let minutes = GetSlot(this, MINUTES);\n        let seconds = GetSlot(this, SECONDS);\n        let milliseconds = GetSlot(this, MILLISECONDS);\n        let microseconds = GetSlot(this, MICROSECONDS);\n        let nanoseconds = GetSlot(this, NANOSECONDS);\n        if (optionsParam === undefined)\n            throw new TypeError('options argument is required');\n        const options = typeof optionsParam === 'string'\n            ? CreateOnePropObject('unit', optionsParam)\n            : GetOptionsObject(optionsParam);\n        const unit = ToTemporalDurationTotalUnit(options);\n        if (unit === undefined)\n            throw new RangeError('unit option is required');\n        const relativeTo = ToRelativeTemporalObject(options);\n        // Convert larger units down to days\n        ({ years, months, weeks, days } = UnbalanceDurationRelative(years, months, weeks, days, unit, relativeTo));\n        // If the unit we're totalling is smaller than `days`, convert days down to that unit.\n        let intermediate;\n        if (IsTemporalZonedDateTime(relativeTo)) {\n            intermediate = MoveRelativeZonedDateTime(relativeTo, years, months, weeks, 0);\n        }\n        ({ days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = BalanceDuration(days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, unit, intermediate));\n        // Finally, truncate to the correct unit and calculate remainder\n        const { total } = RoundDuration(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, 1, unit, 'trunc', relativeTo);\n        return total;\n    }\n    toString(optionsParam = undefined) {\n        if (!IsTemporalDuration(this))\n            throw new TypeError('invalid receiver');\n        const options = GetOptionsObject(optionsParam);\n        const { precision, unit, increment } = ToSecondsStringPrecision(options);\n        if (precision === 'minute')\n            throw new RangeError('smallestUnit must not be \"minute\"');\n        const roundingMode = ToTemporalRoundingMode(options, 'trunc');\n        return TemporalDurationToString(this, precision, { unit, increment, roundingMode });\n    }\n    toJSON() {\n        if (!IsTemporalDuration(this))\n            throw new TypeError('invalid receiver');\n        return TemporalDurationToString(this);\n    }\n    toLocaleString(locales = undefined, options = undefined) {\n        if (!IsTemporalDuration(this))\n            throw new TypeError('invalid receiver');\n        if (typeof Intl !== 'undefined' && typeof Intl.DurationFormat !== 'undefined') {\n            return new Intl.DurationFormat(locales, options).format(this);\n        }\n        console.warn('Temporal.Duration.prototype.toLocaleString() requires Intl.DurationFormat.');\n        return TemporalDurationToString(this);\n    }\n    valueOf() {\n        throw new TypeError('use compare() to compare Temporal.Duration');\n    }\n    static from(item) {\n        if (IsTemporalDuration(item)) {\n            return new Duration(GetSlot(item, YEARS), GetSlot(item, MONTHS), GetSlot(item, WEEKS), GetSlot(item, DAYS), GetSlot(item, HOURS), GetSlot(item, MINUTES), GetSlot(item, SECONDS), GetSlot(item, MILLISECONDS), GetSlot(item, MICROSECONDS), GetSlot(item, NANOSECONDS));\n        }\n        return ToTemporalDuration(item);\n    }\n    static compare(oneParam, twoParam, optionsParam = undefined) {\n        const one = ToTemporalDuration(oneParam);\n        const two = ToTemporalDuration(twoParam);\n        const options = GetOptionsObject(optionsParam);\n        const relativeTo = ToRelativeTemporalObject(options);\n        const y1 = GetSlot(one, YEARS);\n        const mon1 = GetSlot(one, MONTHS);\n        const w1 = GetSlot(one, WEEKS);\n        let d1 = GetSlot(one, DAYS);\n        const h1 = GetSlot(one, HOURS);\n        const min1 = GetSlot(one, MINUTES);\n        const s1 = GetSlot(one, SECONDS);\n        const ms1 = GetSlot(one, MILLISECONDS);\n        const s1 = GetSlot(one, MICROSECONDS);\n        let ns1 = GetSlot(one, NANOSECONDS);\n        const y2 = GetSlot(two, YEARS);\n        const mon2 = GetSlot(two, MONTHS);\n        const w2 = GetSlot(two, WEEKS);\n        let d2 = GetSlot(two, DAYS);\n        const h2 = GetSlot(two, HOURS);\n        const min2 = GetSlot(two, MINUTES);\n        const s2 = GetSlot(two, SECONDS);\n        const ms2 = GetSlot(two, MILLISECONDS);\n        const s2 = GetSlot(two, MICROSECONDS);\n        let ns2 = GetSlot(two, NANOSECONDS);\n        const shift1 = CalculateOffsetShift(relativeTo, y1, mon1, w1, d1, h1, min1, s1, ms1, s1, ns1);\n        const shift2 = CalculateOffsetShift(relativeTo, y2, mon2, w2, d2, h2, min2, s2, ms2, s2, ns2);\n        if (y1 !== 0 || y2 !== 0 || mon1 !== 0 || mon2 !== 0 || w1 !== 0 || w2 !== 0) {\n            ({ days: d1 } = UnbalanceDurationRelative(y1, mon1, w1, d1, 'day', relativeTo));\n            ({ days: d2 } = UnbalanceDurationRelative(y2, mon2, w2, d2, 'day', relativeTo));\n        }\n        const totalNs1 = TotalDurationNanoseconds(d1, h1, min1, s1, ms1, s1, ns1, shift1);\n        const totalNs2 = TotalDurationNanoseconds(d2, h2, min2, s2, ms2, s2, ns2, shift2);\n        return ComparisonResult(jsbi__WEBPACK_IMPORTED_MODULE_0__.toNumber(jsbi__WEBPACK_IMPORTED_MODULE_0__.subtract(totalNs1, totalNs2)));\n    }\n}\nMakeIntrinsicClass(Duration, 'Temporal.Duration');\n\nconst ObjectCreate$1 = Object.create;\nclass PlainMonthDay {\n    constructor(isoMonthParam, isoDayParam, calendarParam = GetISO8601Calendar(), referenceISOYearParam = 1972) {\n        const isoMonth = ToIntegerThrowOnInfinity(isoMonthParam);\n        const isoDay = ToIntegerThrowOnInfinity(isoDayParam);\n        const calendar = ToTemporalCalendar(calendarParam);\n        const referenceISOYear = ToIntegerThrowOnInfinity(referenceISOYearParam);\n        // Note: if the arguments are not passed,\n        //       ToIntegerThrowOnInfinity(undefined) will have returned 0, which will\n        //       be rejected by RejectISODate in CreateTemporalMonthDaySlots. This\n        //       check exists only to improve the error message.\n        if (arguments.length < 2) {\n            throw new RangeError('missing argument: isoMonth and isoDay are required');\n        }\n        CreateTemporalMonthDaySlots(this, isoMonth, isoDay, calendar, referenceISOYear);\n    }\n    get monthCode() {\n        if (!IsTemporalMonthDay(this))\n            throw new TypeError('invalid receiver');\n        return CalendarMonthCode(GetSlot(this, CALENDAR), this);\n    }\n    get day() {\n        if (!IsTemporalMonthDay(this))\n            throw new TypeError('invalid receiver');\n        return CalendarDay(GetSlot(this, CALENDAR), this);\n    }\n    get calendar() {\n        if (!IsTemporalMonthDay(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, CALENDAR);\n    }\n    with(temporalMonthDayLike, optionsParam = undefined) {\n        if (!IsTemporalMonthDay(this))\n            throw new TypeError('invalid receiver');\n        if (!IsObject(temporalMonthDayLike)) {\n            throw new TypeError('invalid argument');\n        }\n        RejectObjectWithCalendarOrTimeZone(temporalMonthDayLike);\n        const calendar = GetSlot(this, CALENDAR);\n        const fieldNames = CalendarFields(calendar, ['day', 'month', 'monthCode', 'year']);\n        const props = ToPartialRecord(temporalMonthDayLike, fieldNames);\n        if (!props) {\n            throw new TypeError('invalid month-day-like');\n        }\n        let fields = ToTemporalMonthDayFields(this, fieldNames);\n        fields = CalendarMergeFields(calendar, fields, props);\n        fields = ToTemporalMonthDayFields(fields, fieldNames);\n        const options = GetOptionsObject(optionsParam);\n        return MonthDayFromFields(calendar, fields, options);\n    }\n    equals(otherParam) {\n        if (!IsTemporalMonthDay(this))\n            throw new TypeError('invalid receiver');\n        const other = ToTemporalMonthDay(otherParam);\n        for (const slot of [ISO_MONTH, ISO_DAY, ISO_YEAR]) {\n            const val1 = GetSlot(this, slot);\n            const val2 = GetSlot(other, slot);\n            if (val1 !== val2)\n                return false;\n        }\n        return CalendarEquals(GetSlot(this, CALENDAR), GetSlot(other, CALENDAR));\n    }\n    toString(optionsParam = undefined) {\n        if (!IsTemporalMonthDay(this))\n            throw new TypeError('invalid receiver');\n        const options = GetOptionsObject(optionsParam);\n        const showCalendar = ToShowCalendarOption(options);\n        return TemporalMonthDayToString(this, showCalendar);\n    }\n    toJSON() {\n        if (!IsTemporalMonthDay(this))\n            throw new TypeError('invalid receiver');\n        return TemporalMonthDayToString(this);\n    }\n    toLocaleString(locales = undefined, options = undefined) {\n        if (!IsTemporalMonthDay(this))\n            throw new TypeError('invalid receiver');\n        return new DateTimeFormat(locales, options).format(this);\n    }\n    valueOf() {\n        throw new TypeError('use equals() to compare Temporal.PlainMonthDay');\n    }\n    toPlainDate(item) {\n        if (!IsTemporalMonthDay(this))\n            throw new TypeError('invalid receiver');\n        if (!IsObject(item))\n            throw new TypeError('argument should be an object');\n        const calendar = GetSlot(this, CALENDAR);\n        const receiverFieldNames = CalendarFields(calendar, ['day', 'monthCode']);\n        const fields = ToTemporalMonthDayFields(this, receiverFieldNames);\n        const inputFieldNames = CalendarFields(calendar, ['year']);\n        const inputEntries = [['year', undefined]];\n        // Add extra fields from the calendar at the end\n        inputFieldNames.forEach((fieldName) => {\n            if (!inputEntries.some(([name]) => name === fieldName)) {\n                inputEntries.push([fieldName, undefined]); // Make TS ignore extra fields\n            }\n        });\n        const inputFields = PrepareTemporalFields(item, inputEntries);\n        let mergedFields = CalendarMergeFields(calendar, fields, inputFields);\n        const mergedFieldNames = [...new Set([...receiverFieldNames, ...inputFieldNames])];\n        const mergedEntries = [];\n        mergedFieldNames.forEach((fieldName) => {\n            if (!mergedEntries.some(([name]) => name === fieldName)) {\n                mergedEntries.push([fieldName, undefined]);\n            }\n        });\n        mergedFields = PrepareTemporalFields(mergedFields, mergedEntries);\n        const options = ObjectCreate$1(null);\n        options.overflow = 'reject';\n        return DateFromFields(calendar, mergedFields, options);\n    }\n    getISOFields() {\n        if (!IsTemporalMonthDay(this))\n            throw new TypeError('invalid receiver');\n        return {\n            calendar: GetSlot(this, CALENDAR),\n            isoDay: GetSlot(this, ISO_DAY),\n            isoMonth: GetSlot(this, ISO_MONTH),\n            isoYear: GetSlot(this, ISO_YEAR)\n        };\n    }\n    static from(item, optionsParam = undefined) {\n        const options = GetOptionsObject(optionsParam);\n        if (IsTemporalMonthDay(item)) {\n            ToTemporalOverflow(options); // validate and ignore\n            return CreateTemporalMonthDay(GetSlot(item, ISO_MONTH), GetSlot(item, ISO_DAY), GetSlot(item, CALENDAR), GetSlot(item, ISO_YEAR));\n        }\n        return ToTemporalMonthDay(item, options);\n    }\n}\nMakeIntrinsicClass(PlainMonthDay, 'Temporal.PlainMonthDay');\n\nconst instant = () => {\n    const Instant = GetIntrinsic('%Temporal.Instant%');\n    return new Instant(SystemUTCEpochNanoSeconds());\n};\nconst plainDateTime = (calendarLike, temporalTimeZoneLike = timeZone()) => {\n    const tZ = ToTemporalTimeZone(temporalTimeZoneLike);\n    const calendar = ToTemporalCalendar(calendarLike);\n    const inst = instant();\n    return BuiltinTimeZoneGetPlainDateTimeFor(tZ, inst, calendar);\n};\nconst plainDateTimeISO = (temporalTimeZoneLike = timeZone()) => {\n    const tZ = ToTemporalTimeZone(temporalTimeZoneLike);\n    const calendar = GetISO8601Calendar();\n    const inst = instant();\n    return BuiltinTimeZoneGetPlainDateTimeFor(tZ, inst, calendar);\n};\nconst zonedDateTime = (calendarLike, temporalTimeZoneLike = timeZone()) => {\n    const tZ = ToTemporalTimeZone(temporalTimeZoneLike);\n    const calendar = ToTemporalCalendar(calendarLike);\n    return CreateTemporalZonedDateTime(SystemUTCEpochNanoSeconds(), tZ, calendar);\n};\nconst zonedDateTimeISO = (temporalTimeZoneLike = timeZone()) => {\n    return zonedDateTime(GetISO8601Calendar(), temporalTimeZoneLike);\n};\nconst plainDate = (calendarLike, temporalTimeZoneLike = timeZone()) => {\n    return TemporalDateTimeToDate(plainDateTime(calendarLike, temporalTimeZoneLike));\n};\nconst plainDateISO = (temporalTimeZoneLike = timeZone()) => {\n    return TemporalDateTimeToDate(plainDateTimeISO(temporalTimeZoneLike));\n};\nconst plainTimeISO = (temporalTimeZoneLike = timeZone()) => {\n    return TemporalDateTimeToTime(plainDateTimeISO(temporalTimeZoneLike));\n};\nconst timeZone = () => {\n    return SystemTimeZone();\n};\nconst Now = {\n    instant,\n    plainDateTime,\n    plainDateTimeISO,\n    plainDate,\n    plainDateISO,\n    plainTimeISO,\n    timeZone,\n    zonedDateTime,\n    zonedDateTimeISO,\n    [Symbol.toStringTag]: 'Temporal.Now'\n};\nObject.defineProperty(Now, Symbol.toStringTag, {\n    value: 'Temporal.Now',\n    writable: false,\n    enumerable: false,\n    configurable: true\n});\n\nconst ObjectAssign = Object.assign;\nconst DISALLOWED_UNITS$1 = ['year', 'month', 'week', 'day'];\nconst MAX_INCREMENTS = {\n    hour: 24,\n    minute: 60,\n    second: 60,\n    millisecond: 1000,\n    microsecond: 1000,\n    nanosecond: 1000\n};\nfunction TemporalTimeToString(time, precision, options = undefined) {\n    let hour = GetSlot(time, ISO_HOUR);\n    let minute = GetSlot(time, ISO_MINUTE);\n    let second = GetSlot(time, ISO_SECOND);\n    let millisecond = GetSlot(time, ISO_MILLISECOND);\n    let microsecond = GetSlot(time, ISO_MICROSECOND);\n    let nanosecond = GetSlot(time, ISO_NANOSECOND);\n    if (options) {\n        const { unit, increment, roundingMode } = options;\n        ({ hour, minute, second, millisecond, microsecond, nanosecond } = RoundTime(hour, minute, second, millisecond, microsecond, nanosecond, increment, unit, roundingMode));\n    }\n    const hourString = ISODateTimePartString(hour);\n    const minuteString = ISODateTimePartString(minute);\n    const seconds = FormatSecondsStringPart(second, millisecond, microsecond, nanosecond, precision);\n    return `${hourString}:${minuteString}${seconds}`;\n}\nclass PlainTime {\n    constructor(isoHourParam = 0, isoMinuteParam = 0, isoSecondParam = 0, isoMillisecondParam = 0, isoMicrosecondParam = 0, isoNanosecondParam = 0) {\n        const isoHour = ToIntegerThrowOnInfinity(isoHourParam);\n        const isoMinute = ToIntegerThrowOnInfinity(isoMinuteParam);\n        const isoSecond = ToIntegerThrowOnInfinity(isoSecondParam);\n        const isoMillisecond = ToIntegerThrowOnInfinity(isoMillisecondParam);\n        const isoMicrosecond = ToIntegerThrowOnInfinity(isoMicrosecondParam);\n        const isoNanosecond = ToIntegerThrowOnInfinity(isoNanosecondParam);\n        RejectTime(isoHour, isoMinute, isoSecond, isoMillisecond, isoMicrosecond, isoNanosecond);\n        CreateSlots(this);\n        SetSlot(this, ISO_HOUR, isoHour);\n        SetSlot(this, ISO_MINUTE, isoMinute);\n        SetSlot(this, ISO_SECOND, isoSecond);\n        SetSlot(this, ISO_MILLISECOND, isoMillisecond);\n        SetSlot(this, ISO_MICROSECOND, isoMicrosecond);\n        SetSlot(this, ISO_NANOSECOND, isoNanosecond);\n        SetSlot(this, CALENDAR, GetISO8601Calendar());\n        {\n            Object.defineProperty(this, '_repr_', {\n                value: `${this[Symbol.toStringTag]} <${TemporalTimeToString(this, 'auto')}>`,\n                writable: false,\n                enumerable: false,\n                configurable: false\n            });\n        }\n    }\n    get calendar() {\n        if (!IsTemporalTime(this))\n            throw new TypeError('invalid receiver');\n        // PlainTime's calendar isn't settable, so can't be a userland calendar\n        return GetSlot(this, CALENDAR);\n    }\n    get hour() {\n        if (!IsTemporalTime(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, ISO_HOUR);\n    }\n    get minute() {\n        if (!IsTemporalTime(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, ISO_MINUTE);\n    }\n    get second() {\n        if (!IsTemporalTime(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, ISO_SECOND);\n    }\n    get millisecond() {\n        if (!IsTemporalTime(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, ISO_MILLISECOND);\n    }\n    get microsecond() {\n        if (!IsTemporalTime(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, ISO_MICROSECOND);\n    }\n    get nanosecond() {\n        if (!IsTemporalTime(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, ISO_NANOSECOND);\n    }\n    with(temporalTimeLike, optionsParam = undefined) {\n        if (!IsTemporalTime(this))\n            throw new TypeError('invalid receiver');\n        if (!IsObject(temporalTimeLike)) {\n            throw new TypeError('invalid argument');\n        }\n        RejectObjectWithCalendarOrTimeZone(temporalTimeLike);\n        const options = GetOptionsObject(optionsParam);\n        const overflow = ToTemporalOverflow(options);\n        const props = ToPartialRecord(temporalTimeLike, [\n            'hour',\n            'microsecond',\n            'millisecond',\n            'minute',\n            'nanosecond',\n            'second'\n        ]);\n        if (!props) {\n            throw new TypeError('invalid time-like');\n        }\n        const fields = ToTemporalTimeRecord(this);\n        let { hour, minute, second, millisecond, microsecond, nanosecond } = ObjectAssign(fields, props);\n        ({ hour, minute, second, millisecond, microsecond, nanosecond } = RegulateTime(hour, minute, second, millisecond, microsecond, nanosecond, overflow));\n        return new PlainTime(hour, minute, second, millisecond, microsecond, nanosecond);\n    }\n    add(temporalDurationLike) {\n        if (!IsTemporalTime(this))\n            throw new TypeError('invalid receiver');\n        const duration = ToLimitedTemporalDuration(temporalDurationLike);\n        const { hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = duration;\n        let hour = GetSlot(this, ISO_HOUR);\n        let minute = GetSlot(this, ISO_MINUTE);\n        let second = GetSlot(this, ISO_SECOND);\n        let millisecond = GetSlot(this, ISO_MILLISECOND);\n        let microsecond = GetSlot(this, ISO_MICROSECOND);\n        let nanosecond = GetSlot(this, ISO_NANOSECOND);\n        ({ hour, minute, second, millisecond, microsecond, nanosecond } = AddTime(hour, minute, second, millisecond, microsecond, nanosecond, hours, minutes, seconds, milliseconds, microseconds, nanoseconds));\n        ({ hour, minute, second, millisecond, microsecond, nanosecond } = RegulateTime(hour, minute, second, millisecond, microsecond, nanosecond, 'reject'));\n        return new PlainTime(hour, minute, second, millisecond, microsecond, nanosecond);\n    }\n    subtract(temporalDurationLike) {\n        if (!IsTemporalTime(this))\n            throw new TypeError('invalid receiver');\n        const duration = ToLimitedTemporalDuration(temporalDurationLike);\n        const { hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = duration;\n        let hour = GetSlot(this, ISO_HOUR);\n        let minute = GetSlot(this, ISO_MINUTE);\n        let second = GetSlot(this, ISO_SECOND);\n        let millisecond = GetSlot(this, ISO_MILLISECOND);\n        let microsecond = GetSlot(this, ISO_MICROSECOND);\n        let nanosecond = GetSlot(this, ISO_NANOSECOND);\n        ({ hour, minute, second, millisecond, microsecond, nanosecond } = AddTime(hour, minute, second, millisecond, microsecond, nanosecond, -hours, -minutes, -seconds, -milliseconds, -microseconds, -nanoseconds));\n        ({ hour, minute, second, millisecond, microsecond, nanosecond } = RegulateTime(hour, minute, second, millisecond, microsecond, nanosecond, 'reject'));\n        return new PlainTime(hour, minute, second, millisecond, microsecond, nanosecond);\n    }\n    until(otherParam, optionsParam = undefined) {\n        if (!IsTemporalTime(this))\n            throw new TypeError('invalid receiver');\n        const other = ToTemporalTime(otherParam);\n        const options = GetOptionsObject(optionsParam);\n        const largestUnit = ToLargestTemporalUnit(options, 'auto', DISALLOWED_UNITS$1, 'hour');\n        const smallestUnit = ToSmallestTemporalUnit(options, 'nanosecond', DISALLOWED_UNITS$1);\n        ValidateTemporalUnitRange(largestUnit, smallestUnit);\n        const roundingMode = ToTemporalRoundingMode(options, 'trunc');\n        const roundingIncrement = ToTemporalRoundingIncrement(options, MAX_INCREMENTS[smallestUnit], false);\n        let { hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = DifferenceTime(GetSlot(this, ISO_HOUR), GetSlot(this, ISO_MINUTE), GetSlot(this, ISO_SECOND), GetSlot(this, ISO_MILLISECOND), GetSlot(this, ISO_MICROSECOND), GetSlot(this, ISO_NANOSECOND), GetSlot(other, ISO_HOUR), GetSlot(other, ISO_MINUTE), GetSlot(other, ISO_SECOND), GetSlot(other, ISO_MILLISECOND), GetSlot(other, ISO_MICROSECOND), GetSlot(other, ISO_NANOSECOND));\n        ({ hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = RoundDuration(0, 0, 0, 0, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, roundingIncrement, smallestUnit, roundingMode));\n        ({ hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = BalanceDuration(0, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, largestUnit));\n        const Duration = GetIntrinsic('%Temporal.Duration%');\n        return new Duration(0, 0, 0, 0, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n    }\n    since(otherParam, optionsParam = undefined) {\n        if (!IsTemporalTime(this))\n            throw new TypeError('invalid receiver');\n        const other = ToTemporalTime(otherParam);\n        const options = GetOptionsObject(optionsParam);\n        const largestUnit = ToLargestTemporalUnit(options, 'auto', DISALLOWED_UNITS$1, 'hour');\n        const smallestUnit = ToSmallestTemporalUnit(options, 'nanosecond', DISALLOWED_UNITS$1);\n        ValidateTemporalUnitRange(largestUnit, smallestUnit);\n        const roundingMode = ToTemporalRoundingMode(options, 'trunc');\n        const roundingIncrement = ToTemporalRoundingIncrement(options, MAX_INCREMENTS[smallestUnit], false);\n        let { hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = DifferenceTime(GetSlot(other, ISO_HOUR), GetSlot(other, ISO_MINUTE), GetSlot(other, ISO_SECOND), GetSlot(other, ISO_MILLISECOND), GetSlot(other, ISO_MICROSECOND), GetSlot(other, ISO_NANOSECOND), GetSlot(this, ISO_HOUR), GetSlot(this, ISO_MINUTE), GetSlot(this, ISO_SECOND), GetSlot(this, ISO_MILLISECOND), GetSlot(this, ISO_MICROSECOND), GetSlot(this, ISO_NANOSECOND));\n        ({ hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = RoundDuration(0, 0, 0, 0, -hours, -minutes, -seconds, -milliseconds, -microseconds, -nanoseconds, roundingIncrement, smallestUnit, NegateTemporalRoundingMode(roundingMode)));\n        hours = -hours;\n        minutes = -minutes;\n        seconds = -seconds;\n        milliseconds = -milliseconds;\n        microseconds = -microseconds;\n        nanoseconds = -nanoseconds;\n        ({ hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = BalanceDuration(0, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, largestUnit));\n        const Duration = GetIntrinsic('%Temporal.Duration%');\n        return new Duration(0, 0, 0, 0, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n    }\n    round(optionsParam) {\n        if (!IsTemporalTime(this))\n            throw new TypeError('invalid receiver');\n        if (optionsParam === undefined)\n            throw new TypeError('options parameter is required');\n        const options = typeof optionsParam === 'string'\n            ? CreateOnePropObject('smallestUnit', optionsParam)\n            : GetOptionsObject(optionsParam);\n        const smallestUnit = ToSmallestTemporalUnit(options, undefined, DISALLOWED_UNITS$1);\n        if (smallestUnit === undefined)\n            throw new RangeError('smallestUnit is required');\n        const roundingMode = ToTemporalRoundingMode(options, 'halfExpand');\n        const roundingIncrement = ToTemporalRoundingIncrement(options, MAX_INCREMENTS[smallestUnit], false);\n        let hour = GetSlot(this, ISO_HOUR);\n        let minute = GetSlot(this, ISO_MINUTE);\n        let second = GetSlot(this, ISO_SECOND);\n        let millisecond = GetSlot(this, ISO_MILLISECOND);\n        let microsecond = GetSlot(this, ISO_MICROSECOND);\n        let nanosecond = GetSlot(this, ISO_NANOSECOND);\n        ({ hour, minute, second, millisecond, microsecond, nanosecond } = RoundTime(hour, minute, second, millisecond, microsecond, nanosecond, roundingIncrement, smallestUnit, roundingMode));\n        return new PlainTime(hour, minute, second, millisecond, microsecond, nanosecond);\n    }\n    equals(otherParam) {\n        if (!IsTemporalTime(this))\n            throw new TypeError('invalid receiver');\n        const other = ToTemporalTime(otherParam);\n        for (const slot of [ISO_HOUR, ISO_MINUTE, ISO_SECOND, ISO_MILLISECOND, ISO_MICROSECOND, ISO_NANOSECOND]) {\n            const val1 = GetSlot(this, slot);\n            const val2 = GetSlot(other, slot);\n            if (val1 !== val2)\n                return false;\n        }\n        return true;\n    }\n    toString(optionsParam = undefined) {\n        if (!IsTemporalTime(this))\n            throw new TypeError('invalid receiver');\n        const options = GetOptionsObject(optionsParam);\n        const { precision, unit, increment } = ToSecondsStringPrecision(options);\n        const roundingMode = ToTemporalRoundingMode(options, 'trunc');\n        return TemporalTimeToString(this, precision, { unit, increment, roundingMode });\n    }\n    toJSON() {\n        if (!IsTemporalTime(this))\n            throw new TypeError('invalid receiver');\n        return TemporalTimeToString(this, 'auto');\n    }\n    toLocaleString(locales = undefined, options = undefined) {\n        if (!IsTemporalTime(this))\n            throw new TypeError('invalid receiver');\n        return new DateTimeFormat(locales, options).format(this);\n    }\n    valueOf() {\n        throw new TypeError('use compare() or equals() to compare Temporal.PlainTime');\n    }\n    toPlainDateTime(temporalDateParam) {\n        if (!IsTemporalTime(this))\n            throw new TypeError('invalid receiver');\n        const temporalDate = ToTemporalDate(temporalDateParam);\n        const year = GetSlot(temporalDate, ISO_YEAR);\n        const month = GetSlot(temporalDate, ISO_MONTH);\n        const day = GetSlot(temporalDate, ISO_DAY);\n        const calendar = GetSlot(temporalDate, CALENDAR);\n        const hour = GetSlot(this, ISO_HOUR);\n        const minute = GetSlot(this, ISO_MINUTE);\n        const second = GetSlot(this, ISO_SECOND);\n        const millisecond = GetSlot(this, ISO_MILLISECOND);\n        const microsecond = GetSlot(this, ISO_MICROSECOND);\n        const nanosecond = GetSlot(this, ISO_NANOSECOND);\n        return CreateTemporalDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar);\n    }\n    toZonedDateTime(item) {\n        if (!IsTemporalTime(this))\n            throw new TypeError('invalid receiver');\n        if (!IsObject(item)) {\n            throw new TypeError('invalid argument');\n        }\n        const dateLike = item.plainDate;\n        if (dateLike === undefined) {\n            throw new TypeError('missing date property');\n        }\n        const temporalDate = ToTemporalDate(dateLike);\n        const timeZoneLike = item.timeZone;\n        if (timeZoneLike === undefined) {\n            throw new TypeError('missing timeZone property');\n        }\n        const timeZone = ToTemporalTimeZone(timeZoneLike);\n        const year = GetSlot(temporalDate, ISO_YEAR);\n        const month = GetSlot(temporalDate, ISO_MONTH);\n        const day = GetSlot(temporalDate, ISO_DAY);\n        const calendar = GetSlot(temporalDate, CALENDAR);\n        const hour = GetSlot(this, ISO_HOUR);\n        const minute = GetSlot(this, ISO_MINUTE);\n        const second = GetSlot(this, ISO_SECOND);\n        const millisecond = GetSlot(this, ISO_MILLISECOND);\n        const microsecond = GetSlot(this, ISO_MICROSECOND);\n        const nanosecond = GetSlot(this, ISO_NANOSECOND);\n        const PlainDateTime = GetIntrinsic('%Temporal.PlainDateTime%');\n        const dt = new PlainDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar);\n        const instant = BuiltinTimeZoneGetInstantFor(timeZone, dt, 'compatible');\n        return CreateTemporalZonedDateTime(GetSlot(instant, EPOCHNANOSECONDS), timeZone, calendar);\n    }\n    getISOFields() {\n        if (!IsTemporalTime(this))\n            throw new TypeError('invalid receiver');\n        return {\n            calendar: GetSlot(this, CALENDAR),\n            isoHour: GetSlot(this, ISO_HOUR),\n            isoMicrosecond: GetSlot(this, ISO_MICROSECOND),\n            isoMillisecond: GetSlot(this, ISO_MILLISECOND),\n            isoMinute: GetSlot(this, ISO_MINUTE),\n            isoNanosecond: GetSlot(this, ISO_NANOSECOND),\n            isoSecond: GetSlot(this, ISO_SECOND)\n        };\n    }\n    static from(item, optionsParam = undefined) {\n        const options = GetOptionsObject(optionsParam);\n        const overflow = ToTemporalOverflow(options);\n        if (IsTemporalTime(item)) {\n            return new PlainTime(GetSlot(item, ISO_HOUR), GetSlot(item, ISO_MINUTE), GetSlot(item, ISO_SECOND), GetSlot(item, ISO_MILLISECOND), GetSlot(item, ISO_MICROSECOND), GetSlot(item, ISO_NANOSECOND));\n        }\n        return ToTemporalTime(item, overflow);\n    }\n    static compare(oneParam, twoParam) {\n        const one = ToTemporalTime(oneParam);\n        const two = ToTemporalTime(twoParam);\n        for (const slot of [ISO_HOUR, ISO_MINUTE, ISO_SECOND, ISO_MILLISECOND, ISO_MICROSECOND, ISO_NANOSECOND]) {\n            const val1 = GetSlot(one, slot);\n            const val2 = GetSlot(two, slot);\n            if (val1 !== val2)\n                return ComparisonResult(val1 - val2);\n        }\n        return 0;\n    }\n}\nMakeIntrinsicClass(PlainTime, 'Temporal.PlainTime');\n\nclass TimeZone {\n    constructor(timeZoneIdentifierParam) {\n        // Note: if the argument is not passed, GetCanonicalTimeZoneIdentifier(undefined) will throw.\n        //       This check exists only to improve the error message.\n        if (arguments.length < 1) {\n            throw new RangeError('missing argument: identifier is required');\n        }\n        const timeZoneIdentifier = GetCanonicalTimeZoneIdentifier(timeZoneIdentifierParam);\n        CreateSlots(this);\n        SetSlot(this, TIMEZONE_ID, timeZoneIdentifier);\n        {\n            Object.defineProperty(this, '_repr_', {\n                value: `${this[Symbol.toStringTag]} <${timeZoneIdentifier}>`,\n                writable: false,\n                enumerable: false,\n                configurable: false\n            });\n        }\n    }\n    get id() {\n        if (!IsTemporalTimeZone(this))\n            throw new TypeError('invalid receiver');\n        return ToString(this);\n    }\n    getOffsetNanosecondsFor(instantParam) {\n        if (!IsTemporalTimeZone(this))\n            throw new TypeError('invalid receiver');\n        const instant = ToTemporalInstant(instantParam);\n        const id = GetSlot(this, TIMEZONE_ID);\n        if (TestTimeZoneOffsetString(id)) {\n            return ParseTimeZoneOffsetString(id);\n        }\n        return GetIANATimeZoneOffsetNanoseconds(GetSlot(instant, EPOCHNANOSECONDS), id);\n    }\n    getOffsetStringFor(instantParam) {\n        if (!IsTemporalTimeZone(this))\n            throw new TypeError('invalid receiver');\n        const instant = ToTemporalInstant(instantParam);\n        return BuiltinTimeZoneGetOffsetStringFor(this, instant);\n    }\n    getPlainDateTimeFor(instantParam, calendarParam = GetISO8601Calendar()) {\n        const instant = ToTemporalInstant(instantParam);\n        const calendar = ToTemporalCalendar(calendarParam);\n        return BuiltinTimeZoneGetPlainDateTimeFor(this, instant, calendar);\n    }\n    getInstantFor(dateTimeParam, optionsParam = undefined) {\n        if (!IsTemporalTimeZone(this))\n            throw new TypeError('invalid receiver');\n        const dateTime = ToTemporalDateTime(dateTimeParam);\n        const options = GetOptionsObject(optionsParam);\n        const disambiguation = ToTemporalDisambiguation(options);\n        return BuiltinTimeZoneGetInstantFor(this, dateTime, disambiguation);\n    }\n    getPossibleInstantsFor(dateTimeParam) {\n        if (!IsTemporalTimeZone(this))\n            throw new TypeError('invalid receiver');\n        const dateTime = ToTemporalDateTime(dateTimeParam);\n        const Instant = GetIntrinsic('%Temporal.Instant%');\n        const id = GetSlot(this, TIMEZONE_ID);\n        if (TestTimeZoneOffsetString(id)) {\n            const epochNs = GetEpochFromISOParts(GetSlot(dateTime, ISO_YEAR), GetSlot(dateTime, ISO_MONTH), GetSlot(dateTime, ISO_DAY), GetSlot(dateTime, ISO_HOUR), GetSlot(dateTime, ISO_MINUTE), GetSlot(dateTime, ISO_SECOND), GetSlot(dateTime, ISO_MILLISECOND), GetSlot(dateTime, ISO_MICROSECOND), GetSlot(dateTime, ISO_NANOSECOND));\n            if (epochNs === null)\n                throw new RangeError('DateTime outside of supported range');\n            const offsetNs = ParseTimeZoneOffsetString(id);\n            return [new Instant(jsbi__WEBPACK_IMPORTED_MODULE_0__.subtract(epochNs, jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(offsetNs)))];\n        }\n        const possibleEpochNs = GetIANATimeZoneEpochValue(id, GetSlot(dateTime, ISO_YEAR), GetSlot(dateTime, ISO_MONTH), GetSlot(dateTime, ISO_DAY), GetSlot(dateTime, ISO_HOUR), GetSlot(dateTime, ISO_MINUTE), GetSlot(dateTime, ISO_SECOND), GetSlot(dateTime, ISO_MILLISECOND), GetSlot(dateTime, ISO_MICROSECOND), GetSlot(dateTime, ISO_NANOSECOND));\n        return possibleEpochNs.map((ns) => new Instant(ns));\n    }\n    getNextTransition(startingPointParam) {\n        if (!IsTemporalTimeZone(this))\n            throw new TypeError('invalid receiver');\n        const startingPoint = ToTemporalInstant(startingPointParam);\n        const id = GetSlot(this, TIMEZONE_ID);\n        // Offset time zones or UTC have no transitions\n        if (TestTimeZoneOffsetString(id) || id === 'UTC') {\n            return null;\n        }\n        let epochNanoseconds = GetSlot(startingPoint, EPOCHNANOSECONDS);\n        const Instant = GetIntrinsic('%Temporal.Instant%');\n        epochNanoseconds = GetIANATimeZoneNextTransition(epochNanoseconds, id);\n        return epochNanoseconds === null ? null : new Instant(epochNanoseconds);\n    }\n    getPreviousTransition(startingPointParam) {\n        if (!IsTemporalTimeZone(this))\n            throw new TypeError('invalid receiver');\n        const startingPoint = ToTemporalInstant(startingPointParam);\n        const id = GetSlot(this, TIMEZONE_ID);\n        // Offset time zones or UTC have no transitions\n        if (TestTimeZoneOffsetString(id) || id === 'UTC') {\n            return null;\n        }\n        let epochNanoseconds = GetSlot(startingPoint, EPOCHNANOSECONDS);\n        const Instant = GetIntrinsic('%Temporal.Instant%');\n        epochNanoseconds = GetIANATimeZonePreviousTransition(epochNanoseconds, id);\n        return epochNanoseconds === null ? null : new Instant(epochNanoseconds);\n    }\n    toString() {\n        if (!IsTemporalTimeZone(this))\n            throw new TypeError('invalid receiver');\n        return ToString(GetSlot(this, TIMEZONE_ID));\n    }\n    toJSON() {\n        if (!IsTemporalTimeZone(this))\n            throw new TypeError('invalid receiver');\n        return ToString(this);\n    }\n    static from(item) {\n        return ToTemporalTimeZone(item);\n    }\n}\nMakeIntrinsicClass(TimeZone, 'Temporal.TimeZone');\n\nconst ObjectCreate = Object.create;\nconst DISALLOWED_UNITS = [\n    'week',\n    'day',\n    'hour',\n    'minute',\n    'second',\n    'millisecond',\n    'microsecond',\n    'nanosecond'\n];\nclass PlainYearMonth {\n    constructor(isoYearParam, isoMonthParam, calendarParam = GetISO8601Calendar(), referenceISODayParam = 1) {\n        const isoYear = ToIntegerThrowOnInfinity(isoYearParam);\n        const isoMonth = ToIntegerThrowOnInfinity(isoMonthParam);\n        const calendar = ToTemporalCalendar(calendarParam);\n        const referenceISODay = ToIntegerThrowOnInfinity(referenceISODayParam);\n        // Note: if the arguments are not passed,\n        //       ToIntegerThrowOnInfinity(undefined) will have returned 0, which will\n        //       be rejected by RejectISODate in CreateTemporalYearMonthSlots. This\n        //       check exists only to improve the error message.\n        if (arguments.length < 2) {\n            throw new RangeError('missing argument: isoYear and isoMonth are required');\n        }\n        CreateTemporalYearMonthSlots(this, isoYear, isoMonth, calendar, referenceISODay);\n    }\n    get year() {\n        if (!IsTemporalYearMonth(this))\n            throw new TypeError('invalid receiver');\n        return CalendarYear(GetSlot(this, CALENDAR), this);\n    }\n    get month() {\n        if (!IsTemporalYearMonth(this))\n            throw new TypeError('invalid receiver');\n        return CalendarMonth(GetSlot(this, CALENDAR), this);\n    }\n    get monthCode() {\n        if (!IsTemporalYearMonth(this))\n            throw new TypeError('invalid receiver');\n        return CalendarMonthCode(GetSlot(this, CALENDAR), this);\n    }\n    get calendar() {\n        if (!IsTemporalYearMonth(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, CALENDAR);\n    }\n    get era() {\n        if (!IsTemporalYearMonth(this))\n            throw new TypeError('invalid receiver');\n        return CalendarEra(GetSlot(this, CALENDAR), this);\n    }\n    get eraYear() {\n        if (!IsTemporalYearMonth(this))\n            throw new TypeError('invalid receiver');\n        return CalendarEraYear(GetSlot(this, CALENDAR), this);\n    }\n    get daysInMonth() {\n        if (!IsTemporalYearMonth(this))\n            throw new TypeError('invalid receiver');\n        return CalendarDaysInMonth(GetSlot(this, CALENDAR), this);\n    }\n    get daysInYear() {\n        if (!IsTemporalYearMonth(this))\n            throw new TypeError('invalid receiver');\n        return CalendarDaysInYear(GetSlot(this, CALENDAR), this);\n    }\n    get monthsInYear() {\n        if (!IsTemporalYearMonth(this))\n            throw new TypeError('invalid receiver');\n        return CalendarMonthsInYear(GetSlot(this, CALENDAR), this);\n    }\n    get inLeapYear() {\n        if (!IsTemporalYearMonth(this))\n            throw new TypeError('invalid receiver');\n        return CalendarInLeapYear(GetSlot(this, CALENDAR), this);\n    }\n    with(temporalYearMonthLike, optionsParam = undefined) {\n        if (!IsTemporalYearMonth(this))\n            throw new TypeError('invalid receiver');\n        if (!IsObject(temporalYearMonthLike)) {\n            throw new TypeError('invalid argument');\n        }\n        RejectObjectWithCalendarOrTimeZone(temporalYearMonthLike);\n        const calendar = GetSlot(this, CALENDAR);\n        const fieldNames = CalendarFields(calendar, ['month', 'monthCode', 'year']);\n        const props = ToPartialRecord(temporalYearMonthLike, fieldNames);\n        if (!props) {\n            throw new TypeError('invalid year-month-like');\n        }\n        let fields = ToTemporalYearMonthFields(this, fieldNames);\n        fields = CalendarMergeFields(calendar, fields, props);\n        fields = ToTemporalYearMonthFields(fields, fieldNames);\n        const options = GetOptionsObject(optionsParam);\n        return YearMonthFromFields(calendar, fields, options);\n    }\n    add(temporalDurationLike, optionsParam = undefined) {\n        if (!IsTemporalYearMonth(this))\n            throw new TypeError('invalid receiver');\n        const duration = ToLimitedTemporalDuration(temporalDurationLike);\n        let { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = duration;\n        ({ days } = BalanceDuration(days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, 'day'));\n        const options = GetOptionsObject(optionsParam);\n        const calendar = GetSlot(this, CALENDAR);\n        const fieldNames = CalendarFields(calendar, ['monthCode', 'year']);\n        const fields = ToTemporalYearMonthFields(this, fieldNames);\n        const sign = DurationSign(years, months, weeks, days, 0, 0, 0, 0, 0, 0);\n        const day = sign < 0 ? ToPositiveInteger(CalendarDaysInMonth(calendar, this)) : 1;\n        const startDate = DateFromFields(calendar, { ...fields, day });\n        const optionsCopy = { ...options };\n        const addedDate = CalendarDateAdd(calendar, startDate, { ...duration, days }, options);\n        const addedDateFields = ToTemporalYearMonthFields(addedDate, fieldNames);\n        return YearMonthFromFields(calendar, addedDateFields, optionsCopy);\n    }\n    subtract(temporalDurationLike, optionsParam = undefined) {\n        if (!IsTemporalYearMonth(this))\n            throw new TypeError('invalid receiver');\n        let duration = ToLimitedTemporalDuration(temporalDurationLike);\n        duration = {\n            years: -duration.years,\n            months: -duration.months,\n            weeks: -duration.weeks,\n            days: -duration.days,\n            hours: -duration.hours,\n            minutes: -duration.minutes,\n            seconds: -duration.seconds,\n            milliseconds: -duration.milliseconds,\n            microseconds: -duration.microseconds,\n            nanoseconds: -duration.nanoseconds\n        };\n        let { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = duration;\n        ({ days } = BalanceDuration(days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, 'day'));\n        const options = GetOptionsObject(optionsParam);\n        const calendar = GetSlot(this, CALENDAR);\n        const fieldNames = CalendarFields(calendar, ['monthCode', 'year']);\n        const fields = ToTemporalYearMonthFields(this, fieldNames);\n        const sign = DurationSign(years, months, weeks, days, 0, 0, 0, 0, 0, 0);\n        const day = sign < 0 ? ToPositiveInteger(CalendarDaysInMonth(calendar, this)) : 1;\n        const startDate = DateFromFields(calendar, { ...fields, day });\n        const optionsCopy = { ...options };\n        const addedDate = CalendarDateAdd(calendar, startDate, { ...duration, days }, options);\n        const addedDateFields = ToTemporalYearMonthFields(addedDate, fieldNames);\n        return YearMonthFromFields(calendar, addedDateFields, optionsCopy);\n    }\n    until(otherParam, optionsParam = undefined) {\n        if (!IsTemporalYearMonth(this))\n            throw new TypeError('invalid receiver');\n        const other = ToTemporalYearMonth(otherParam);\n        const calendar = GetSlot(this, CALENDAR);\n        const otherCalendar = GetSlot(other, CALENDAR);\n        const calendarID = ToString(calendar);\n        const otherCalendarID = ToString(otherCalendar);\n        if (calendarID !== otherCalendarID) {\n            throw new RangeError(`cannot compute difference between months of ${calendarID} and ${otherCalendarID} calendars`);\n        }\n        const options = GetOptionsObject(optionsParam);\n        const smallestUnit = ToSmallestTemporalUnit(options, 'month', DISALLOWED_UNITS);\n        const largestUnit = ToLargestTemporalUnit(options, 'auto', DISALLOWED_UNITS, 'year');\n        ValidateTemporalUnitRange(largestUnit, smallestUnit);\n        const roundingMode = ToTemporalRoundingMode(options, 'trunc');\n        const roundingIncrement = ToTemporalRoundingIncrement(options, undefined, false);\n        const fieldNames = CalendarFields(calendar, ['monthCode', 'year']);\n        const otherFields = ToTemporalYearMonthFields(other, fieldNames);\n        const thisFields = ToTemporalYearMonthFields(this, fieldNames);\n        const otherDate = DateFromFields(calendar, { ...otherFields, day: 1 });\n        const thisDate = DateFromFields(calendar, { ...thisFields, day: 1 });\n        const untilOptions = { ...options, largestUnit };\n        const result = CalendarDateUntil(calendar, thisDate, otherDate, untilOptions);\n        if (smallestUnit === 'month' && roundingIncrement === 1)\n            return result;\n        let { years, months } = result;\n        ({ years, months } = RoundDuration(years, months, 0, 0, 0, 0, 0, 0, 0, 0, roundingIncrement, smallestUnit, roundingMode, thisDate));\n        const Duration = GetIntrinsic('%Temporal.Duration%');\n        return new Duration(years, months, 0, 0, 0, 0, 0, 0, 0, 0);\n    }\n    since(otherParam, optionsParam = undefined) {\n        if (!IsTemporalYearMonth(this))\n            throw new TypeError('invalid receiver');\n        const other = ToTemporalYearMonth(otherParam);\n        const calendar = GetSlot(this, CALENDAR);\n        const otherCalendar = GetSlot(other, CALENDAR);\n        const calendarID = ToString(calendar);\n        const otherCalendarID = ToString(otherCalendar);\n        if (calendarID !== otherCalendarID) {\n            throw new RangeError(`cannot compute difference between months of ${calendarID} and ${otherCalendarID} calendars`);\n        }\n        const options = GetOptionsObject(optionsParam);\n        const smallestUnit = ToSmallestTemporalUnit(options, 'month', DISALLOWED_UNITS);\n        const largestUnit = ToLargestTemporalUnit(options, 'auto', DISALLOWED_UNITS, 'year');\n        ValidateTemporalUnitRange(largestUnit, smallestUnit);\n        const roundingMode = ToTemporalRoundingMode(options, 'trunc');\n        const roundingIncrement = ToTemporalRoundingIncrement(options, undefined, false);\n        const fieldNames = CalendarFields(calendar, ['monthCode', 'year']);\n        const otherFields = ToTemporalYearMonthFields(other, fieldNames);\n        const thisFields = ToTemporalYearMonthFields(this, fieldNames);\n        const otherDate = DateFromFields(calendar, { ...otherFields, day: 1 });\n        const thisDate = DateFromFields(calendar, { ...thisFields, day: 1 });\n        const untilOptions = { ...options, largestUnit };\n        let { years, months } = CalendarDateUntil(calendar, thisDate, otherDate, untilOptions);\n        const Duration = GetIntrinsic('%Temporal.Duration%');\n        if (smallestUnit === 'month' && roundingIncrement === 1) {\n            return new Duration(-years, -months, 0, 0, 0, 0, 0, 0, 0, 0);\n        }\n        ({ years, months } = RoundDuration(years, months, 0, 0, 0, 0, 0, 0, 0, 0, roundingIncrement, smallestUnit, NegateTemporalRoundingMode(roundingMode), thisDate));\n        return new Duration(-years, -months, 0, 0, 0, 0, 0, 0, 0, 0);\n    }\n    equals(otherParam) {\n        if (!IsTemporalYearMonth(this))\n            throw new TypeError('invalid receiver');\n        const other = ToTemporalYearMonth(otherParam);\n        for (const slot of [ISO_YEAR, ISO_MONTH, ISO_DAY]) {\n            const val1 = GetSlot(this, slot);\n            const val2 = GetSlot(other, slot);\n            if (val1 !== val2)\n                return false;\n        }\n        return CalendarEquals(GetSlot(this, CALENDAR), GetSlot(other, CALENDAR));\n    }\n    toString(optionsParam = undefined) {\n        if (!IsTemporalYearMonth(this))\n            throw new TypeError('invalid receiver');\n        const options = GetOptionsObject(optionsParam);\n        const showCalendar = ToShowCalendarOption(options);\n        return TemporalYearMonthToString(this, showCalendar);\n    }\n    toJSON() {\n        if (!IsTemporalYearMonth(this))\n            throw new TypeError('invalid receiver');\n        return TemporalYearMonthToString(this);\n    }\n    toLocaleString(locales = undefined, options = undefined) {\n        if (!IsTemporalYearMonth(this))\n            throw new TypeError('invalid receiver');\n        return new DateTimeFormat(locales, options).format(this);\n    }\n    valueOf() {\n        throw new TypeError('use compare() or equals() to compare Temporal.PlainYearMonth');\n    }\n    toPlainDate(item) {\n        if (!IsTemporalYearMonth(this))\n            throw new TypeError('invalid receiver');\n        if (!IsObject(item))\n            throw new TypeError('argument should be an object');\n        const calendar = GetSlot(this, CALENDAR);\n        const receiverFieldNames = CalendarFields(calendar, ['monthCode', 'year']);\n        const fields = ToTemporalYearMonthFields(this, receiverFieldNames);\n        const inputFieldNames = CalendarFields(calendar, ['day']);\n        const inputEntries = [['day']];\n        // Add extra fields from the calendar at the end\n        inputFieldNames.forEach((fieldName) => {\n            if (!inputEntries.some(([name]) => name === fieldName)) {\n                inputEntries.push([\n                    fieldName,\n                    undefined\n                ]); // Make TS ignore extra fields\n            }\n        });\n        const inputFields = PrepareTemporalFields(item, inputEntries);\n        let mergedFields = CalendarMergeFields(calendar, fields, inputFields);\n        const mergedFieldNames = [...new Set([...receiverFieldNames, ...inputFieldNames])];\n        const mergedEntries = [];\n        mergedFieldNames.forEach((fieldName) => {\n            if (!mergedEntries.some(([name]) => name === fieldName)) {\n                mergedEntries.push([fieldName, undefined]);\n            }\n        });\n        mergedFields = PrepareTemporalFields(mergedFields, mergedEntries);\n        const options = ObjectCreate(null);\n        options.overflow = 'reject';\n        return DateFromFields(calendar, mergedFields, options);\n    }\n    getISOFields() {\n        if (!IsTemporalYearMonth(this))\n            throw new TypeError('invalid receiver');\n        return {\n            calendar: GetSlot(this, CALENDAR),\n            isoDay: GetSlot(this, ISO_DAY),\n            isoMonth: GetSlot(this, ISO_MONTH),\n            isoYear: GetSlot(this, ISO_YEAR)\n        };\n    }\n    static from(item, optionsParam = undefined) {\n        const options = GetOptionsObject(optionsParam);\n        if (IsTemporalYearMonth(item)) {\n            ToTemporalOverflow(options); // validate and ignore\n            return CreateTemporalYearMonth(GetSlot(item, ISO_YEAR), GetSlot(item, ISO_MONTH), GetSlot(item, CALENDAR), GetSlot(item, ISO_DAY));\n        }\n        return ToTemporalYearMonth(item, options);\n    }\n    static compare(oneParam, twoParam) {\n        const one = ToTemporalYearMonth(oneParam);\n        const two = ToTemporalYearMonth(twoParam);\n        return CompareISODate(GetSlot(one, ISO_YEAR), GetSlot(one, ISO_MONTH), GetSlot(one, ISO_DAY), GetSlot(two, ISO_YEAR), GetSlot(two, ISO_MONTH), GetSlot(two, ISO_DAY));\n    }\n}\nMakeIntrinsicClass(PlainYearMonth, 'Temporal.PlainYearMonth');\n\nconst ArrayPrototypePush = Array.prototype.push;\nclass ZonedDateTime {\n    constructor(epochNanosecondsParam, timeZoneParam, calendarParam = GetISO8601Calendar()) {\n        // Note: if the argument is not passed, ToBigInt(undefined) will throw. This check exists only\n        //       to improve the error message.\n        //       ToTemporalTimeZone(undefined) will end up calling TimeZone.from(\"undefined\"), which\n        //       could succeed.\n        if (arguments.length < 1) {\n            throw new TypeError('missing argument: epochNanoseconds is required');\n        }\n        const epochNanoseconds = ToBigInt(epochNanosecondsParam);\n        const timeZone = ToTemporalTimeZone(timeZoneParam);\n        const calendar = ToTemporalCalendar(calendarParam);\n        CreateTemporalZonedDateTimeSlots(this, epochNanoseconds, timeZone, calendar);\n    }\n    get calendar() {\n        if (!IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, CALENDAR);\n    }\n    get timeZone() {\n        if (!IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, TIME_ZONE);\n    }\n    get year() {\n        if (!IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return CalendarYear(GetSlot(this, CALENDAR), dateTime(this));\n    }\n    get month() {\n        if (!IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return CalendarMonth(GetSlot(this, CALENDAR), dateTime(this));\n    }\n    get monthCode() {\n        if (!IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return CalendarMonthCode(GetSlot(this, CALENDAR), dateTime(this));\n    }\n    get day() {\n        if (!IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return CalendarDay(GetSlot(this, CALENDAR), dateTime(this));\n    }\n    get hour() {\n        if (!IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(dateTime(this), ISO_HOUR);\n    }\n    get minute() {\n        if (!IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(dateTime(this), ISO_MINUTE);\n    }\n    get second() {\n        if (!IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(dateTime(this), ISO_SECOND);\n    }\n    get millisecond() {\n        if (!IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(dateTime(this), ISO_MILLISECOND);\n    }\n    get microsecond() {\n        if (!IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(dateTime(this), ISO_MICROSECOND);\n    }\n    get nanosecond() {\n        if (!IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(dateTime(this), ISO_NANOSECOND);\n    }\n    get era() {\n        if (!IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return CalendarEra(GetSlot(this, CALENDAR), dateTime(this));\n    }\n    get eraYear() {\n        if (!IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return CalendarEraYear(GetSlot(this, CALENDAR), dateTime(this));\n    }\n    get epochSeconds() {\n        if (!IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        const value = GetSlot(this, EPOCHNANOSECONDS);\n        return jsbi__WEBPACK_IMPORTED_MODULE_0__.toNumber(jsbi__WEBPACK_IMPORTED_MODULE_0__.divide(value, BILLION));\n    }\n    get epochMilliseconds() {\n        if (!IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        const value = GetSlot(this, EPOCHNANOSECONDS);\n        return jsbi__WEBPACK_IMPORTED_MODULE_0__.toNumber(jsbi__WEBPACK_IMPORTED_MODULE_0__.divide(value, MILLION));\n    }\n    get epochMicroseconds() {\n        if (!IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        const value = GetSlot(this, EPOCHNANOSECONDS);\n        return ToBigIntExternal(jsbi__WEBPACK_IMPORTED_MODULE_0__.divide(value, THOUSAND));\n    }\n    get epochNanoseconds() {\n        if (!IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return ToBigIntExternal(GetSlot(this, EPOCHNANOSECONDS));\n    }\n    get dayOfWeek() {\n        if (!IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return CalendarDayOfWeek(GetSlot(this, CALENDAR), dateTime(this));\n    }\n    get dayOfYear() {\n        if (!IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return CalendarDayOfYear(GetSlot(this, CALENDAR), dateTime(this));\n    }\n    get weekOfYear() {\n        if (!IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return CalendarWeekOfYear(GetSlot(this, CALENDAR), dateTime(this));\n    }\n    get hoursInDay() {\n        if (!IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        const dt = dateTime(this);\n        const DateTime = GetIntrinsic('%Temporal.PlainDateTime%');\n        const year = GetSlot(dt, ISO_YEAR);\n        const month = GetSlot(dt, ISO_MONTH);\n        const day = GetSlot(dt, ISO_DAY);\n        const today = new DateTime(year, month, day, 0, 0, 0, 0, 0, 0);\n        const tomorrowFields = AddISODate(year, month, day, 0, 0, 0, 1, 'reject');\n        const tomorrow = new DateTime(tomorrowFields.year, tomorrowFields.month, tomorrowFields.day, 0, 0, 0, 0, 0, 0);\n        const timeZone = GetSlot(this, TIME_ZONE);\n        const todayNs = GetSlot(BuiltinTimeZoneGetInstantFor(timeZone, today, 'compatible'), EPOCHNANOSECONDS);\n        const tomorrowNs = GetSlot(BuiltinTimeZoneGetInstantFor(timeZone, tomorrow, 'compatible'), EPOCHNANOSECONDS);\n        return jsbi__WEBPACK_IMPORTED_MODULE_0__.toNumber(jsbi__WEBPACK_IMPORTED_MODULE_0__.subtract(tomorrowNs, todayNs)) / 3.6e12;\n    }\n    get daysInWeek() {\n        if (!IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return CalendarDaysInWeek(GetSlot(this, CALENDAR), dateTime(this));\n    }\n    get daysInMonth() {\n        if (!IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return CalendarDaysInMonth(GetSlot(this, CALENDAR), dateTime(this));\n    }\n    get daysInYear() {\n        if (!IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return CalendarDaysInYear(GetSlot(this, CALENDAR), dateTime(this));\n    }\n    get monthsInYear() {\n        if (!IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return CalendarMonthsInYear(GetSlot(this, CALENDAR), dateTime(this));\n    }\n    get inLeapYear() {\n        if (!IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return CalendarInLeapYear(GetSlot(this, CALENDAR), dateTime(this));\n    }\n    get offset() {\n        if (!IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return BuiltinTimeZoneGetOffsetStringFor(GetSlot(this, TIME_ZONE), GetSlot(this, INSTANT));\n    }\n    get offsetNanoseconds() {\n        if (!IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return GetOffsetNanosecondsFor(GetSlot(this, TIME_ZONE), GetSlot(this, INSTANT));\n    }\n    with(temporalZonedDateTimeLike, optionsParam = undefined) {\n        if (!IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        if (!IsObject(temporalZonedDateTimeLike)) {\n            throw new TypeError('invalid zoned-date-time-like');\n        }\n        RejectObjectWithCalendarOrTimeZone(temporalZonedDateTimeLike);\n        const options = GetOptionsObject(optionsParam);\n        const disambiguation = ToTemporalDisambiguation(options);\n        const offset = ToTemporalOffset(options, 'prefer');\n        const timeZone = GetSlot(this, TIME_ZONE);\n        const calendar = GetSlot(this, CALENDAR);\n        const fieldNames = CalendarFields(calendar, [\n            'day',\n            'hour',\n            'microsecond',\n            'millisecond',\n            'minute',\n            'month',\n            'monthCode',\n            'nanosecond',\n            'second',\n            'year'\n        ]);\n        ArrayPrototypePush.call(fieldNames, 'offset');\n        const props = ToPartialRecord(temporalZonedDateTimeLike, fieldNames);\n        if (!props) {\n            throw new TypeError('invalid zoned-date-time-like');\n        }\n        // Unlike ToTemporalZonedDateTimeFields, the offset property will be required.\n        const entries = [\n            ['day', undefined],\n            ['hour', 0],\n            ['microsecond', 0],\n            ['millisecond', 0],\n            ['minute', 0],\n            ['month', undefined],\n            ['monthCode', undefined],\n            ['nanosecond', 0],\n            ['second', 0],\n            ['year', undefined],\n            ['offset'],\n            ['timeZone']\n        ];\n        // Add extra fields from the calendar at the end\n        fieldNames.forEach((fieldName) => {\n            if (!entries.some(([name]) => name === fieldName)) {\n                entries.push([fieldName, undefined]);\n            }\n        });\n        let fields = PrepareTemporalFields(this, entries);\n        fields = CalendarMergeFields(calendar, fields, props);\n        fields = PrepareTemporalFields(fields, entries);\n        const { year, month, day, hour, minute, second, millisecond, microsecond, nanosecond } = InterpretTemporalDateTimeFields(calendar, fields, options);\n        const offsetNs = ParseTimeZoneOffsetString(fields.offset);\n        const epochNanoseconds = InterpretISODateTimeOffset(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, 'option', offsetNs, timeZone, disambiguation, offset, \n        /* matchMinute = */ false);\n        return CreateTemporalZonedDateTime(epochNanoseconds, GetSlot(this, TIME_ZONE), calendar);\n    }\n    withPlainDate(temporalDateParam) {\n        if (!IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        const temporalDate = ToTemporalDate(temporalDateParam);\n        const year = GetSlot(temporalDate, ISO_YEAR);\n        const month = GetSlot(temporalDate, ISO_MONTH);\n        const day = GetSlot(temporalDate, ISO_DAY);\n        let calendar = GetSlot(temporalDate, CALENDAR);\n        const thisDt = dateTime(this);\n        const hour = GetSlot(thisDt, ISO_HOUR);\n        const minute = GetSlot(thisDt, ISO_MINUTE);\n        const second = GetSlot(thisDt, ISO_SECOND);\n        const millisecond = GetSlot(thisDt, ISO_MILLISECOND);\n        const microsecond = GetSlot(thisDt, ISO_MICROSECOND);\n        const nanosecond = GetSlot(thisDt, ISO_NANOSECOND);\n        calendar = ConsolidateCalendars(GetSlot(this, CALENDAR), calendar);\n        const timeZone = GetSlot(this, TIME_ZONE);\n        const PlainDateTime = GetIntrinsic('%Temporal.PlainDateTime%');\n        const dt = new PlainDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar);\n        const instant = BuiltinTimeZoneGetInstantFor(timeZone, dt, 'compatible');\n        return CreateTemporalZonedDateTime(GetSlot(instant, EPOCHNANOSECONDS), timeZone, calendar);\n    }\n    withPlainTime(temporalTimeParam = undefined) {\n        if (!IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        const PlainTime = GetIntrinsic('%Temporal.PlainTime%');\n        const temporalTime = temporalTimeParam == undefined ? new PlainTime() : ToTemporalTime(temporalTimeParam);\n        const thisDt = dateTime(this);\n        const year = GetSlot(thisDt, ISO_YEAR);\n        const month = GetSlot(thisDt, ISO_MONTH);\n        const day = GetSlot(thisDt, ISO_DAY);\n        const calendar = GetSlot(this, CALENDAR);\n        const hour = GetSlot(temporalTime, ISO_HOUR);\n        const minute = GetSlot(temporalTime, ISO_MINUTE);\n        const second = GetSlot(temporalTime, ISO_SECOND);\n        const millisecond = GetSlot(temporalTime, ISO_MILLISECOND);\n        const microsecond = GetSlot(temporalTime, ISO_MICROSECOND);\n        const nanosecond = GetSlot(temporalTime, ISO_NANOSECOND);\n        const timeZone = GetSlot(this, TIME_ZONE);\n        const PlainDateTime = GetIntrinsic('%Temporal.PlainDateTime%');\n        const dt = new PlainDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar);\n        const instant = BuiltinTimeZoneGetInstantFor(timeZone, dt, 'compatible');\n        return CreateTemporalZonedDateTime(GetSlot(instant, EPOCHNANOSECONDS), timeZone, calendar);\n    }\n    withTimeZone(timeZoneParam) {\n        if (!IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        const timeZone = ToTemporalTimeZone(timeZoneParam);\n        return CreateTemporalZonedDateTime(GetSlot(this, EPOCHNANOSECONDS), timeZone, GetSlot(this, CALENDAR));\n    }\n    withCalendar(calendarParam) {\n        if (!IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        const calendar = ToTemporalCalendar(calendarParam);\n        return CreateTemporalZonedDateTime(GetSlot(this, EPOCHNANOSECONDS), GetSlot(this, TIME_ZONE), calendar);\n    }\n    add(temporalDurationLike, optionsParam = undefined) {\n        if (!IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        const duration = ToLimitedTemporalDuration(temporalDurationLike);\n        const { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = duration;\n        const options = GetOptionsObject(optionsParam);\n        const timeZone = GetSlot(this, TIME_ZONE);\n        const calendar = GetSlot(this, CALENDAR);\n        const epochNanoseconds = AddZonedDateTime(GetSlot(this, INSTANT), timeZone, calendar, years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, options);\n        return CreateTemporalZonedDateTime(epochNanoseconds, timeZone, calendar);\n    }\n    subtract(temporalDurationLike, optionsParam = undefined) {\n        if (!IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        const duration = ToLimitedTemporalDuration(temporalDurationLike);\n        const { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = duration;\n        const options = GetOptionsObject(optionsParam);\n        const timeZone = GetSlot(this, TIME_ZONE);\n        const calendar = GetSlot(this, CALENDAR);\n        const epochNanoseconds = AddZonedDateTime(GetSlot(this, INSTANT), timeZone, calendar, -years, -months, -weeks, -days, -hours, -minutes, -seconds, -milliseconds, -microseconds, -nanoseconds, options);\n        return CreateTemporalZonedDateTime(epochNanoseconds, timeZone, calendar);\n    }\n    until(otherParam, optionsParam = undefined) {\n        if (!IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        const other = ToTemporalZonedDateTime(otherParam);\n        const calendar = GetSlot(this, CALENDAR);\n        const otherCalendar = GetSlot(other, CALENDAR);\n        const calendarId = ToString(calendar);\n        const otherCalendarId = ToString(otherCalendar);\n        if (calendarId !== otherCalendarId) {\n            throw new RangeError(`cannot compute difference between dates of ${calendarId} and ${otherCalendarId} calendars`);\n        }\n        const options = GetOptionsObject(optionsParam);\n        const smallestUnit = ToSmallestTemporalUnit(options, 'nanosecond');\n        const defaultLargestUnit = LargerOfTwoTemporalUnits('hour', smallestUnit);\n        const largestUnit = ToLargestTemporalUnit(options, 'auto', [], defaultLargestUnit);\n        ValidateTemporalUnitRange(largestUnit, smallestUnit);\n        const roundingMode = ToTemporalRoundingMode(options, 'trunc');\n        const roundingIncrement = ToTemporalDateTimeRoundingIncrement(options, smallestUnit);\n        const ns1 = GetSlot(this, EPOCHNANOSECONDS);\n        const ns2 = GetSlot(other, EPOCHNANOSECONDS);\n        let years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds;\n        if (largestUnit !== 'year' && largestUnit !== 'month' && largestUnit !== 'week' && largestUnit !== 'day') {\n            // The user is only asking for a time difference, so return difference of instants.\n            years = 0;\n            months = 0;\n            weeks = 0;\n            days = 0;\n            ({ seconds, milliseconds, microseconds, nanoseconds } = DifferenceInstant(ns1, ns2, roundingIncrement, smallestUnit, roundingMode));\n            ({ hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = BalanceDuration(0, 0, 0, seconds, milliseconds, microseconds, nanoseconds, largestUnit));\n        }\n        else {\n            const timeZone = GetSlot(this, TIME_ZONE);\n            if (!TimeZoneEquals(timeZone, GetSlot(other, TIME_ZONE))) {\n                throw new RangeError(\"When calculating difference between time zones, largestUnit must be 'hours' \" +\n                    'or smaller because day lengths can vary between time zones due to DST or time zone offset changes.');\n            }\n            const untilOptions = { ...options, largestUnit };\n            ({ years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } =\n                DifferenceZonedDateTime(ns1, ns2, timeZone, calendar, largestUnit, untilOptions));\n            ({ years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } =\n                RoundDuration(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, roundingIncrement, smallestUnit, roundingMode, this));\n            ({ years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } =\n                AdjustRoundedDurationDays(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, roundingIncrement, smallestUnit, roundingMode, this));\n        }\n        const Duration = GetIntrinsic('%Temporal.Duration%');\n        return new Duration(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n    }\n    since(otherParam, optionsParam = undefined) {\n        if (!IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        const other = ToTemporalZonedDateTime(otherParam);\n        const calendar = GetSlot(this, CALENDAR);\n        const otherCalendar = GetSlot(other, CALENDAR);\n        const calendarId = ToString(calendar);\n        const otherCalendarId = ToString(otherCalendar);\n        if (calendarId !== otherCalendarId) {\n            throw new RangeError(`cannot compute difference between dates of ${calendarId} and ${otherCalendarId} calendars`);\n        }\n        const options = GetOptionsObject(optionsParam);\n        const smallestUnit = ToSmallestTemporalUnit(options, 'nanosecond');\n        const defaultLargestUnit = LargerOfTwoTemporalUnits('hour', smallestUnit);\n        const largestUnit = ToLargestTemporalUnit(options, 'auto', [], defaultLargestUnit);\n        ValidateTemporalUnitRange(largestUnit, smallestUnit);\n        let roundingMode = ToTemporalRoundingMode(options, 'trunc');\n        roundingMode = NegateTemporalRoundingMode(roundingMode);\n        const roundingIncrement = ToTemporalDateTimeRoundingIncrement(options, smallestUnit);\n        const ns1 = GetSlot(this, EPOCHNANOSECONDS);\n        const ns2 = GetSlot(other, EPOCHNANOSECONDS);\n        let years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds;\n        if (largestUnit !== 'year' && largestUnit !== 'month' && largestUnit !== 'week' && largestUnit !== 'day') {\n            // The user is only asking for a time difference, so return difference of instants.\n            years = 0;\n            months = 0;\n            weeks = 0;\n            days = 0;\n            ({ seconds, milliseconds, microseconds, nanoseconds } = DifferenceInstant(ns1, ns2, roundingIncrement, smallestUnit, roundingMode));\n            ({ hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = BalanceDuration(0, 0, 0, seconds, milliseconds, microseconds, nanoseconds, largestUnit));\n        }\n        else {\n            const timeZone = GetSlot(this, TIME_ZONE);\n            if (!TimeZoneEquals(timeZone, GetSlot(other, TIME_ZONE))) {\n                throw new RangeError(\"When calculating difference between time zones, largestUnit must be 'hours' \" +\n                    'or smaller because day lengths can vary between time zones due to DST or time zone offset changes.');\n            }\n            const untilOptions = { ...options, largestUnit };\n            ({ years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } =\n                DifferenceZonedDateTime(ns1, ns2, timeZone, calendar, largestUnit, untilOptions));\n            ({ years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } =\n                RoundDuration(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, roundingIncrement, smallestUnit, roundingMode, this));\n            ({ years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } =\n                AdjustRoundedDurationDays(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, roundingIncrement, smallestUnit, roundingMode, this));\n        }\n        const Duration = GetIntrinsic('%Temporal.Duration%');\n        return new Duration(-years, -months, -weeks, -days, -hours, -minutes, -seconds, -milliseconds, -microseconds, -nanoseconds);\n    }\n    round(optionsParam) {\n        if (!IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        if (optionsParam === undefined)\n            throw new TypeError('options parameter is required');\n        const options = typeof optionsParam === 'string'\n            ? CreateOnePropObject('smallestUnit', optionsParam)\n            : GetOptionsObject(optionsParam);\n        const smallestUnit = ToSmallestTemporalUnit(options, undefined, ['year', 'month', 'week']);\n        if (smallestUnit === undefined)\n            throw new RangeError('smallestUnit is required');\n        const roundingMode = ToTemporalRoundingMode(options, 'halfExpand');\n        const maximumIncrements = {\n            day: 1,\n            hour: 24,\n            minute: 60,\n            second: 60,\n            millisecond: 1000,\n            microsecond: 1000,\n            nanosecond: 1000\n        };\n        const roundingIncrement = ToTemporalRoundingIncrement(options, maximumIncrements[smallestUnit], false);\n        // first, round the underlying DateTime fields\n        const dt = dateTime(this);\n        let year = GetSlot(dt, ISO_YEAR);\n        let month = GetSlot(dt, ISO_MONTH);\n        let day = GetSlot(dt, ISO_DAY);\n        let hour = GetSlot(dt, ISO_HOUR);\n        let minute = GetSlot(dt, ISO_MINUTE);\n        let second = GetSlot(dt, ISO_SECOND);\n        let millisecond = GetSlot(dt, ISO_MILLISECOND);\n        let microsecond = GetSlot(dt, ISO_MICROSECOND);\n        let nanosecond = GetSlot(dt, ISO_NANOSECOND);\n        const DateTime = GetIntrinsic('%Temporal.PlainDateTime%');\n        const timeZone = GetSlot(this, TIME_ZONE);\n        const calendar = GetSlot(this, CALENDAR);\n        const dtStart = new DateTime(GetSlot(dt, ISO_YEAR), GetSlot(dt, ISO_MONTH), GetSlot(dt, ISO_DAY), 0, 0, 0, 0, 0, 0);\n        const instantStart = BuiltinTimeZoneGetInstantFor(timeZone, dtStart, 'compatible');\n        const endNs = AddZonedDateTime(instantStart, timeZone, calendar, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0);\n        const dayLengthNs = jsbi__WEBPACK_IMPORTED_MODULE_0__.subtract(endNs, jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(GetSlot(instantStart, EPOCHNANOSECONDS)));\n        if (jsbi__WEBPACK_IMPORTED_MODULE_0__.equal(dayLengthNs, ZERO)) {\n            throw new RangeError('cannot round a ZonedDateTime in a calendar with zero-length days');\n        }\n        ({ year, month, day, hour, minute, second, millisecond, microsecond, nanosecond } = RoundISODateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, roundingIncrement, smallestUnit, roundingMode, \n        // Days are guaranteed to be shorter than Number.MAX_SAFE_INTEGER\n        // (which can hold up to 104 days in nanoseconds)\n        jsbi__WEBPACK_IMPORTED_MODULE_0__.toNumber(dayLengthNs)));\n        // Now reset all DateTime fields but leave the TimeZone. The offset will\n        // also be retained if the new date/time values are still OK with the old\n        // offset. Otherwise the offset will be changed to be compatible with the\n        // new date/time values. If DST disambiguation is required, the `compatible`\n        // disambiguation algorithm will be used.\n        const offsetNs = GetOffsetNanosecondsFor(timeZone, GetSlot(this, INSTANT));\n        const epochNanoseconds = InterpretISODateTimeOffset(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, 'option', offsetNs, timeZone, 'compatible', 'prefer', \n        /* matchMinute = */ false);\n        return CreateTemporalZonedDateTime(epochNanoseconds, timeZone, GetSlot(this, CALENDAR));\n    }\n    equals(otherParam) {\n        if (!IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        const other = ToTemporalZonedDateTime(otherParam);\n        const one = GetSlot(this, EPOCHNANOSECONDS);\n        const two = GetSlot(other, EPOCHNANOSECONDS);\n        if (!jsbi__WEBPACK_IMPORTED_MODULE_0__.equal(jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(one), jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(two)))\n            return false;\n        if (!TimeZoneEquals(GetSlot(this, TIME_ZONE), GetSlot(other, TIME_ZONE)))\n            return false;\n        return CalendarEquals(GetSlot(this, CALENDAR), GetSlot(other, CALENDAR));\n    }\n    toString(optionsParam = undefined) {\n        if (!IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        const options = GetOptionsObject(optionsParam);\n        const { precision, unit, increment } = ToSecondsStringPrecision(options);\n        const roundingMode = ToTemporalRoundingMode(options, 'trunc');\n        const showCalendar = ToShowCalendarOption(options);\n        const showTimeZone = ToShowTimeZoneNameOption(options);\n        const showOffset = ToShowOffsetOption(options);\n        return TemporalZonedDateTimeToString(this, precision, showCalendar, showTimeZone, showOffset, {\n            unit,\n            increment,\n            roundingMode\n        });\n    }\n    toLocaleString(locales = undefined, options = undefined) {\n        if (!IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return new DateTimeFormat(locales, options).format(this);\n    }\n    toJSON() {\n        if (!IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return TemporalZonedDateTimeToString(this, 'auto');\n    }\n    valueOf() {\n        throw new TypeError('use compare() or equals() to compare Temporal.ZonedDateTime');\n    }\n    startOfDay() {\n        if (!IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        const dt = dateTime(this);\n        const DateTime = GetIntrinsic('%Temporal.PlainDateTime%');\n        const calendar = GetSlot(this, CALENDAR);\n        const dtStart = new DateTime(GetSlot(dt, ISO_YEAR), GetSlot(dt, ISO_MONTH), GetSlot(dt, ISO_DAY), 0, 0, 0, 0, 0, 0, calendar);\n        const timeZone = GetSlot(this, TIME_ZONE);\n        const instant = BuiltinTimeZoneGetInstantFor(timeZone, dtStart, 'compatible');\n        return CreateTemporalZonedDateTime(GetSlot(instant, EPOCHNANOSECONDS), timeZone, calendar);\n    }\n    toInstant() {\n        if (!IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        const TemporalInstant = GetIntrinsic('%Temporal.Instant%');\n        return new TemporalInstant(GetSlot(this, EPOCHNANOSECONDS));\n    }\n    toPlainDate() {\n        if (!IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return TemporalDateTimeToDate(dateTime(this));\n    }\n    toPlainTime() {\n        if (!IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return TemporalDateTimeToTime(dateTime(this));\n    }\n    toPlainDateTime() {\n        if (!IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return dateTime(this);\n    }\n    toPlainYearMonth() {\n        if (!IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        const calendar = GetSlot(this, CALENDAR);\n        const fieldNames = CalendarFields(calendar, ['monthCode', 'year']);\n        const fields = ToTemporalYearMonthFields(this, fieldNames);\n        return YearMonthFromFields(calendar, fields);\n    }\n    toPlainMonthDay() {\n        if (!IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        const calendar = GetSlot(this, CALENDAR);\n        const fieldNames = CalendarFields(calendar, ['day', 'monthCode']);\n        const fields = ToTemporalMonthDayFields(this, fieldNames);\n        return MonthDayFromFields(calendar, fields);\n    }\n    getISOFields() {\n        if (!IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        const dt = dateTime(this);\n        const tz = GetSlot(this, TIME_ZONE);\n        return {\n            calendar: GetSlot(this, CALENDAR),\n            isoDay: GetSlot(dt, ISO_DAY),\n            isoHour: GetSlot(dt, ISO_HOUR),\n            isoMicrosecond: GetSlot(dt, ISO_MICROSECOND),\n            isoMillisecond: GetSlot(dt, ISO_MILLISECOND),\n            isoMinute: GetSlot(dt, ISO_MINUTE),\n            isoMonth: GetSlot(dt, ISO_MONTH),\n            isoNanosecond: GetSlot(dt, ISO_NANOSECOND),\n            isoSecond: GetSlot(dt, ISO_SECOND),\n            isoYear: GetSlot(dt, ISO_YEAR),\n            offset: BuiltinTimeZoneGetOffsetStringFor(tz, GetSlot(this, INSTANT)),\n            timeZone: tz\n        };\n    }\n    static from(item, optionsParam = undefined) {\n        const options = GetOptionsObject(optionsParam);\n        if (IsTemporalZonedDateTime(item)) {\n            ToTemporalOverflow(options); // validate and ignore\n            ToTemporalDisambiguation(options);\n            ToTemporalOffset(options, 'reject');\n            return CreateTemporalZonedDateTime(GetSlot(item, EPOCHNANOSECONDS), GetSlot(item, TIME_ZONE), GetSlot(item, CALENDAR));\n        }\n        return ToTemporalZonedDateTime(item, options);\n    }\n    static compare(oneParam, twoParam) {\n        const one = ToTemporalZonedDateTime(oneParam);\n        const two = ToTemporalZonedDateTime(twoParam);\n        const ns1 = GetSlot(one, EPOCHNANOSECONDS);\n        const ns2 = GetSlot(two, EPOCHNANOSECONDS);\n        if (jsbi__WEBPACK_IMPORTED_MODULE_0__.lessThan(jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(ns1), jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(ns2)))\n            return -1;\n        if (jsbi__WEBPACK_IMPORTED_MODULE_0__.greaterThan(jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(ns1), jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(ns2)))\n            return 1;\n        return 0;\n    }\n}\nMakeIntrinsicClass(ZonedDateTime, 'Temporal.ZonedDateTime');\nfunction dateTime(zdt) {\n    return BuiltinTimeZoneGetPlainDateTimeFor(GetSlot(zdt, TIME_ZONE), GetSlot(zdt, INSTANT), GetSlot(zdt, CALENDAR));\n}\n\nvar temporal = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    Instant: Instant,\n    Calendar: Calendar,\n    PlainDate: PlainDate,\n    PlainDateTime: PlainDateTime,\n    Duration: Duration,\n    PlainMonthDay: PlainMonthDay,\n    Now: Now,\n    PlainTime: PlainTime,\n    TimeZone: TimeZone,\n    PlainYearMonth: PlainYearMonth,\n    ZonedDateTime: ZonedDateTime\n});\n\nfunction toTemporalInstant() {\n    // Observable access to valueOf is not correct here, but unavoidable\n    const epochNanoseconds = jsbi__WEBPACK_IMPORTED_MODULE_0__.multiply(jsbi__WEBPACK_IMPORTED_MODULE_0__.BigInt(+this), MILLION);\n    return new Instant(ToBigInt(epochNanoseconds));\n}\n\n// This entry point treats Temporal as a library, and does not polyfill it onto\n// Work around https://github.com/babel/babel/issues/2025.\nconst types = [\n    Instant,\n    Calendar,\n    PlainDate,\n    PlainDateTime,\n    Duration,\n    PlainMonthDay,\n    // Temporal.Now, // plain object (not a constructor), so no `prototype`\n    PlainTime,\n    TimeZone,\n    PlainYearMonth,\n    ZonedDateTime\n];\nfor (const type of types) {\n    const descriptor = Object.getOwnPropertyDescriptor(type, 'prototype');\n    if (descriptor.configurable || descriptor.enumerable || descriptor.writable) {\n        descriptor.configurable = false;\n        descriptor.enumerable = false;\n        descriptor.writable = false;\n        Object.defineProperty(type, 'prototype', descriptor);\n    }\n}\n\n\n//# sourceMappingURL=index.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGpzLXRlbXBvcmFsL3BvbHlmaWxsL2Rpc3QvaW5kZXguZXNtLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBd0I7O0FBRXhCO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QywwQkFBMEIsR0FBRyxLQUFLO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLEtBQUssSUFBSSxzQ0FBc0M7QUFDakY7QUFDQSwwQkFBMEIsZ0NBQWdDO0FBQzFEO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QiwwQkFBMEIsR0FBRyxLQUFLO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLEtBQUs7QUFDNUI7QUFDQTtBQUNBLG9CQUFvQixLQUFLO0FBQ3pCO0FBQ0EscUNBQXFDLE1BQU07QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsR0FBRztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLEdBQUc7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsMEJBQTBCLEdBQUcsR0FBRztBQUMxRDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELEtBQUs7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw2QkFBNkI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx1SUFBdUk7QUFDbkosYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSwrRkFBK0Y7QUFDM0c7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELFVBQVU7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRUFBMkUsU0FBUztBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQiwwRkFBMEYsYUFBYTtBQUN2RztBQUNBO0FBQ0EsMEZBQTBGLE9BQU87QUFDakc7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSw4RkFBOEYsT0FBTztBQUNyRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVywrRUFBK0U7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDhHQUE4RztBQUN6SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLGFBQWEsc0NBQXNDLGFBQWE7QUFDNUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsU0FBUztBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsV0FBVztBQUN0QjtBQUNBO0FBQ0Esa0RBQWtELFdBQVc7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksV0FBVztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsNENBQTRDLG1DQUFtQztBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsbUNBQW1DLGFBQWEsa0NBQWtDO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLHFCQUFxQjtBQUM3RDtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQywwQ0FBYSxDQUFDLHdDQUFXO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsMENBQWEsQ0FBQyx3Q0FBVztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLDBDQUFhO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSwwQ0FBYTtBQUN6QjtBQUNBLFlBQVksNkNBQWdCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRUFBK0UsWUFBWSxNQUFNLGlCQUFpQjtBQUNsSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLGNBQWMsNkJBQTZCO0FBQzNDLFdBQVcsNkJBQTZCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtFQUErRSxZQUFZLE1BQU0saUJBQWlCO0FBQ2xIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0IsY0FBYyw2QkFBNkI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDZCQUE2QjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsbUNBQW1DO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFdBQVc7QUFDMUIsZUFBZSxXQUFXO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQywwQ0FBYSxDQUFDLDBDQUFhO0FBQzNEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNEO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsZ0NBQWdDO0FBQ2hELFdBQVcsNkRBQTZEO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxXQUFXLEdBQUcsYUFBYSxFQUFFLFFBQVE7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiwwQkFBMEIsR0FBRyxtQ0FBbUM7QUFDMUY7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDZEQUE2RDtBQUMzRSxXQUFXLDZEQUE2RDtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsbUVBQW1FO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsNkRBQTZEO0FBQ3hFLFdBQVcsNkRBQTZEO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixtRUFBbUU7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyw2REFBNkQ7QUFDeEUsV0FBVyw2REFBNkQ7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxtRUFBbUU7QUFDakYsV0FBVyxtRUFBbUU7QUFDOUUsV0FBVyxtRUFBbUU7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLG1FQUFtRTtBQUNqRixXQUFXLG1FQUFtRTtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLG1FQUFtRTtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsNkRBQTZEO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw2QkFBNkI7QUFDN0M7QUFDQSx1REFBdUQsK0JBQStCO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDBCQUEwQixHQUFHLG1CQUFtQjtBQUMxRTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQywwQ0FBYSxVQUFVLHdDQUFXO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDBDQUFhLENBQUMsd0NBQVc7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsMENBQWEsQ0FBQyx3Q0FBVztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHdDQUFXO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDBDQUFhLENBQUMsMENBQWE7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLCtFQUErRTtBQUMvRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLCtGQUErRjtBQUMvRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwrRkFBK0Y7QUFDL0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0VBQStFLFlBQVksTUFBTSxpQkFBaUI7QUFDbEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbURBQW1EO0FBQ2xFLGVBQWUsbUVBQW1FO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DLGVBQWUsK0ZBQStGO0FBQzlHO0FBQ0EsZUFBZSwrRkFBK0Y7QUFDOUc7QUFDQSxlQUFlLCtGQUErRjtBQUM5RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0VBQStFLFlBQVksTUFBTSxpQkFBaUI7QUFDbEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxtREFBbUQ7QUFDbEUsZUFBZSxtRUFBbUU7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkMsZUFBZSwrRkFBK0Y7QUFDOUc7QUFDQSxlQUFlLCtGQUErRjtBQUM5RztBQUNBLGVBQWUsK0ZBQStGO0FBQzlHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsMENBQWEsUUFBUSx3Q0FBVztBQUM1RCxZQUFZLHVDQUFVO0FBQ3RCO0FBQ0E7QUFDQSxXQUFXLCtFQUErRTtBQUMxRjtBQUNBO0FBQ0EsUUFBUSwwQ0FBYTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsdUNBQVUsQ0FBQyx3Q0FBVyxPQUFPLHdDQUFXO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw2QkFBNkI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSwwQ0FBYSxDQUFDLHdDQUFXLE9BQU8sd0NBQVc7QUFDdkQ7QUFDQSxZQUFZLDZDQUFnQixDQUFDLHdDQUFXLE9BQU8sd0NBQVc7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLDZCQUE2QiwwQ0FBYSxDQUFDLHdDQUFXO0FBQ3REO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVpRTtBQUNqRSIsInNvdXJjZXMiOlsid2VicGFjazovL3RvZG8tbGlzdC8uL25vZGVfbW9kdWxlcy9AanMtdGVtcG9yYWwvcG9seWZpbGwvZGlzdC9pbmRleC5lc20uanM/NWI2MSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgSlNCSSBmcm9tICdqc2JpJztcblxuY29uc3QgSU5UUklOU0lDUyA9IHt9O1xuY29uc3QgY3VzdG9tVXRpbEluc3BlY3RGb3JtYXR0ZXJzID0ge1xuICAgIFsnVGVtcG9yYWwuRHVyYXRpb24nXShkZXB0aCwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBkZXNjciA9IG9wdGlvbnMuc3R5bGl6ZShgJHt0aGlzW1N5bWJvbC50b1N0cmluZ1RhZ119IDwke3RoaXN9PmAsICdzcGVjaWFsJyk7XG4gICAgICAgIGlmIChkZXB0aCA8IDEpXG4gICAgICAgICAgICByZXR1cm4gZGVzY3I7XG4gICAgICAgIGNvbnN0IGVudHJpZXMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBwcm9wIG9mIFtcbiAgICAgICAgICAgICd5ZWFycycsXG4gICAgICAgICAgICAnbW9udGhzJyxcbiAgICAgICAgICAgICd3ZWVrcycsXG4gICAgICAgICAgICAnZGF5cycsXG4gICAgICAgICAgICAnaG91cnMnLFxuICAgICAgICAgICAgJ21pbnV0ZXMnLFxuICAgICAgICAgICAgJ3NlY29uZHMnLFxuICAgICAgICAgICAgJ21pbGxpc2Vjb25kcycsXG4gICAgICAgICAgICAnbWljcm9zZWNvbmRzJyxcbiAgICAgICAgICAgICduYW5vc2Vjb25kcydcbiAgICAgICAgXSkge1xuICAgICAgICAgICAgaWYgKHRoaXNbcHJvcF0gIT09IDApXG4gICAgICAgICAgICAgICAgZW50cmllcy5wdXNoKGAgICR7cHJvcH06ICR7b3B0aW9ucy5zdHlsaXplKHRoaXNbcHJvcF0sICdudW1iZXInKX1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVzY3IgKyAnIHtcXG4nICsgZW50cmllcy5qb2luKCcsXFxuJykgKyAnXFxufSc7XG4gICAgfVxufTtcbmZ1bmN0aW9uIGRlZmF1bHRVdGlsSW5zcGVjdEZvcm1hdHRlcihkZXB0aCwgb3B0aW9ucykge1xuICAgIHJldHVybiBvcHRpb25zLnN0eWxpemUoYCR7dGhpc1tTeW1ib2wudG9TdHJpbmdUYWddfSA8JHt0aGlzfT5gLCAnc3BlY2lhbCcpO1xufVxuZnVuY3Rpb24gTWFrZUludHJpbnNpY0NsYXNzKENsYXNzLCBuYW1lKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENsYXNzLnByb3RvdHlwZSwgU3ltYm9sLnRvU3RyaW5nVGFnLCB7XG4gICAgICAgIHZhbHVlOiBuYW1lLFxuICAgICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDbGFzcy5wcm90b3R5cGUsIFN5bWJvbC5mb3IoJ25vZGVqcy51dGlsLmluc3BlY3QuY3VzdG9tJyksIHtcbiAgICAgICAgICAgIHZhbHVlOiBjdXN0b21VdGlsSW5zcGVjdEZvcm1hdHRlcnNbbmFtZV0gfHwgZGVmYXVsdFV0aWxJbnNwZWN0Rm9ybWF0dGVyLFxuICAgICAgICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgcHJvcCBvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhDbGFzcykpIHtcbiAgICAgICAgLy8gd2Uga25vdyB0aGF0IGBwcm9wYCBpcyBwcmVzZW50LCBzbyB0aGUgZGVzY3JpcHRvciBpcyBuZXZlciB1bmRlZmluZWRcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICAgICAgY29uc3QgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoQ2xhc3MsIHByb3ApO1xuICAgICAgICBpZiAoIWRlc2MuY29uZmlndXJhYmxlIHx8ICFkZXNjLmVudW1lcmFibGUpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgZGVzYy5lbnVtZXJhYmxlID0gZmFsc2U7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDbGFzcywgcHJvcCwgZGVzYyk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgcHJvcCBvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhDbGFzcy5wcm90b3R5cGUpKSB7XG4gICAgICAgIC8vIHdlIGtub3cgdGhhdCBgcHJvcGAgaXMgcHJlc2VudCwgc28gdGhlIGRlc2NyaXB0b3IgaXMgbmV2ZXIgdW5kZWZpbmVkXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICAgIGNvbnN0IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKENsYXNzLnByb3RvdHlwZSwgcHJvcCk7XG4gICAgICAgIGlmICghZGVzYy5jb25maWd1cmFibGUgfHwgIWRlc2MuZW51bWVyYWJsZSlcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBkZXNjLmVudW1lcmFibGUgPSBmYWxzZTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENsYXNzLnByb3RvdHlwZSwgcHJvcCwgZGVzYyk7XG4gICAgfVxuICAgIERlZmluZUludHJpbnNpYyhuYW1lLCBDbGFzcyk7XG4gICAgRGVmaW5lSW50cmluc2ljKGAke25hbWV9LnByb3RvdHlwZWAsIENsYXNzLnByb3RvdHlwZSk7XG59XG5mdW5jdGlvbiBEZWZpbmVJbnRyaW5zaWMobmFtZSwgdmFsdWUpIHtcbiAgICBjb25zdCBrZXkgPSBgJSR7bmFtZX0lYDtcbiAgICBpZiAoSU5UUklOU0lDU1trZXldICE9PSB1bmRlZmluZWQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgaW50cmluc2ljICR7bmFtZX0gYWxyZWFkeSBleGlzdHNgKTtcbiAgICBJTlRSSU5TSUNTW2tleV0gPSB2YWx1ZTtcbn1cbmZ1bmN0aW9uIEdldEludHJpbnNpYyhpbnRyaW5zaWMpIHtcbiAgICByZXR1cm4gSU5UUklOU0lDU1tpbnRyaW5zaWNdO1xufVxuXG4vLyBJbnN0YW50XG5jb25zdCBFUE9DSE5BTk9TRUNPTkRTID0gJ3Nsb3QtZXBvY2hOYW5vU2Vjb25kcyc7XG4vLyBUaW1lWm9uZVxuY29uc3QgVElNRVpPTkVfSUQgPSAnc2xvdC10aW1lem9uZS1pZGVudGlmaWVyJztcbi8vIERhdGVUaW1lLCBEYXRlLCBUaW1lLCBZZWFyTW9udGgsIE1vbnRoRGF5XG5jb25zdCBJU09fWUVBUiA9ICdzbG90LXllYXInO1xuY29uc3QgSVNPX01PTlRIID0gJ3Nsb3QtbW9udGgnO1xuY29uc3QgSVNPX0RBWSA9ICdzbG90LWRheSc7XG5jb25zdCBJU09fSE9VUiA9ICdzbG90LWhvdXInO1xuY29uc3QgSVNPX01JTlVURSA9ICdzbG90LW1pbnV0ZSc7XG5jb25zdCBJU09fU0VDT05EID0gJ3Nsb3Qtc2Vjb25kJztcbmNvbnN0IElTT19NSUxMSVNFQ09ORCA9ICdzbG90LW1pbGxpc2Vjb25kJztcbmNvbnN0IElTT19NSUNST1NFQ09ORCA9ICdzbG90LW1pY3Jvc2Vjb25kJztcbmNvbnN0IElTT19OQU5PU0VDT05EID0gJ3Nsb3QtbmFub3NlY29uZCc7XG5jb25zdCBDQUxFTkRBUiA9ICdzbG90LWNhbGVuZGFyJztcbi8vIERhdGUsIFllYXJNb250aCwgYW5kIE1vbnRoRGF5IGFsbCBoYXZlIHRoZSBzYW1lIHNsb3RzLCBkaXNhbWJpZ3VhdGlvbiBuZWVkZWQ6XG5jb25zdCBEQVRFX0JSQU5EID0gJ3Nsb3QtZGF0ZS1icmFuZCc7XG5jb25zdCBZRUFSX01PTlRIX0JSQU5EID0gJ3Nsb3QteWVhci1tb250aC1icmFuZCc7XG5jb25zdCBNT05USF9EQVlfQlJBTkQgPSAnc2xvdC1tb250aC1kYXktYnJhbmQnO1xuLy8gWm9uZWREYXRlVGltZVxuY29uc3QgSU5TVEFOVCA9ICdzbG90LWNhY2hlZC1pbnN0YW50JztcbmNvbnN0IFRJTUVfWk9ORSA9ICdzbG90LXRpbWUtem9uZSc7XG4vLyBEdXJhdGlvblxuY29uc3QgWUVBUlMgPSAnc2xvdC15ZWFycyc7XG5jb25zdCBNT05USFMgPSAnc2xvdC1tb250aHMnO1xuY29uc3QgV0VFS1MgPSAnc2xvdC13ZWVrcyc7XG5jb25zdCBEQVlTID0gJ3Nsb3QtZGF5cyc7XG5jb25zdCBIT1VSUyA9ICdzbG90LWhvdXJzJztcbmNvbnN0IE1JTlVURVMgPSAnc2xvdC1taW51dGVzJztcbmNvbnN0IFNFQ09ORFMgPSAnc2xvdC1zZWNvbmRzJztcbmNvbnN0IE1JTExJU0VDT05EUyA9ICdzbG90LW1pbGxpc2Vjb25kcyc7XG5jb25zdCBNSUNST1NFQ09ORFMgPSAnc2xvdC1taWNyb3NlY29uZHMnO1xuY29uc3QgTkFOT1NFQ09ORFMgPSAnc2xvdC1uYW5vc2Vjb25kcyc7XG4vLyBDYWxlbmRhclxuY29uc3QgQ0FMRU5EQVJfSUQgPSAnc2xvdC1jYWxlbmRhci1pZGVudGlmaWVyJztcbmNvbnN0IHNsb3RzID0gbmV3IFdlYWtNYXAoKTtcbmZ1bmN0aW9uIENyZWF0ZVNsb3RzKGNvbnRhaW5lcikge1xuICAgIHNsb3RzLnNldChjb250YWluZXIsIE9iamVjdC5jcmVhdGUobnVsbCkpO1xufVxuZnVuY3Rpb24gR2V0U2xvdHMoY29udGFpbmVyKSB7XG4gICAgcmV0dXJuIHNsb3RzLmdldChjb250YWluZXIpO1xufVxuZnVuY3Rpb24gSGFzU2xvdChjb250YWluZXIsIC4uLmlkcykge1xuICAgIGlmICghY29udGFpbmVyIHx8ICdvYmplY3QnICE9PSB0eXBlb2YgY29udGFpbmVyKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgY29uc3QgbXlzbG90cyA9IEdldFNsb3RzKGNvbnRhaW5lcik7XG4gICAgcmV0dXJuICEhbXlzbG90cyAmJiBpZHMucmVkdWNlKChhbGwsIGlkKSA9PiBhbGwgJiYgaWQgaW4gbXlzbG90cywgdHJ1ZSk7XG59XG5mdW5jdGlvbiBHZXRTbG90KGNvbnRhaW5lciwgaWQpIHtcbiAgICBjb25zdCB2YWx1ZSA9IEdldFNsb3RzKGNvbnRhaW5lcilbaWRdO1xuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBNaXNzaW5nIGludGVybmFsIHNsb3QgJHtpZH1gKTtcbiAgICByZXR1cm4gdmFsdWU7XG59XG5mdW5jdGlvbiBTZXRTbG90KGNvbnRhaW5lciwgaWQsIHZhbHVlKSB7XG4gICAgR2V0U2xvdHMoY29udGFpbmVyKVtpZF0gPSB2YWx1ZTtcbn1cblxuY29uc3QgQXJyYXlJbmNsdWRlcyA9IEFycmF5LnByb3RvdHlwZS5pbmNsdWRlcztcbmNvbnN0IEFycmF5UHJvdG90eXBlUHVzaCQyID0gQXJyYXkucHJvdG90eXBlLnB1c2g7XG5jb25zdCBJbnRsRGF0ZVRpbWVGb3JtYXQkMiA9IGdsb2JhbFRoaXMuSW50bC5EYXRlVGltZUZvcm1hdDtcbmNvbnN0IEFycmF5U29ydCA9IEFycmF5LnByb3RvdHlwZS5zb3J0O1xuY29uc3QgTWF0aEFicyQxID0gTWF0aC5hYnM7XG5jb25zdCBNYXRoRmxvb3IkMSA9IE1hdGguZmxvb3I7XG5jb25zdCBPYmplY3RFbnRyaWVzID0gT2JqZWN0LmVudHJpZXM7XG5jb25zdCBPYmplY3RLZXlzID0gT2JqZWN0LmtleXM7XG4vKipcbiAqIEltcGxlbWVudGF0aW9ucyBmb3IgZWFjaCBjYWxlbmRhci4gTm9uLUlTTyBjYWxlbmRhcnMgaGF2ZSBhbiBleHRyYSBgaGVscGVyYFxuICogcHJvcGVydHkgdGhhdCBwcm92aWRlcyBhZGRpdGlvbmFsIHBlci1jYWxlbmRhciBsb2dpYy5cbiAqL1xuY29uc3QgaW1wbCA9IHt9O1xuLyoqXG4gKiBUaGluIHdyYXBwZXIgYXJvdW5kIHRoZSBpbXBsZW1lbnRhdGlvbiBvZiBlYWNoIGJ1aWx0LWluIGNhbGVuZGFyLiBUaGlzXG4gKiBjbGFzcydzIG1ldGhvZHMgZm9sbG93IGEgc2ltaWxhciBwYXR0ZXJuOlxuICogMS4gVmFsaWRhdGUgcGFyYW1ldGVyc1xuICogMi4gRmlsbCBpbiBkZWZhdWx0IG9wdGlvbnMgKGZvciBtZXRob2RzIHdoZXJlIG9wdGlvbnMgYXJlIHByZXNlbnQpXG4gKiAzLiBTaW1wbGlmeSBhbmQvb3Igbm9ybWFsaXplIHBhcmFtZXRlcnMuIEZvciBleGFtcGxlLCBzb21lIG1ldGhvZHMgYWNjZXB0XG4gKiAgICBQbGFpbkRhdGUsIFBsYWluRGF0ZVRpbWUsIFpvbmVkRGF0ZVRpbWUsIGV0Yy4gYW5kIHRoZXNlIGFyZSBub3JtYWxpemVkIHRvXG4gKiAgICBQbGFpbkRhdGUuXG4gKiA0LiBMb29rIHVwIHRoZSBJRCBvZiB0aGUgYnVpbHQtaW4gY2FsZW5kYXJcbiAqIDUuIEZldGNoIHRoZSBpbXBsZW1lbnRhdGlvbiBvYmplY3QgZm9yIHRoYXQgSUQuXG4gKiA2LiBDYWxsIHRoZSBjb3JyZXNwb25kaW5nIG1ldGhvZCBpbiB0aGUgaW1wbGVtZW50YXRpb24gb2JqZWN0LlxuICovXG5jbGFzcyBDYWxlbmRhciB7XG4gICAgY29uc3RydWN0b3IoaWRQYXJhbSkge1xuICAgICAgICAvLyBOb3RlOiBpZiB0aGUgYXJndW1lbnQgaXMgbm90IHBhc3NlZCwgSXNCdWlsdGluQ2FsZW5kYXIoXCJ1bmRlZmluZWRcIikgd2lsbCBmYWlsLiBUaGlzIGNoZWNrXG4gICAgICAgIC8vICAgICAgIGV4aXN0cyBvbmx5IHRvIGltcHJvdmUgdGhlIGVycm9yIG1lc3NhZ2UuXG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ21pc3NpbmcgYXJndW1lbnQ6IGlkIGlzIHJlcXVpcmVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaWQgPSBUb1N0cmluZyhpZFBhcmFtKTtcbiAgICAgICAgaWYgKCFJc0J1aWx0aW5DYWxlbmRhcihpZCkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgaW52YWxpZCBjYWxlbmRhciBpZGVudGlmaWVyICR7aWR9YCk7XG4gICAgICAgIENyZWF0ZVNsb3RzKHRoaXMpO1xuICAgICAgICBTZXRTbG90KHRoaXMsIENBTEVOREFSX0lELCBpZCk7XG4gICAgICAgIHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnX3JlcHJfJywge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBgJHt0aGlzW1N5bWJvbC50b1N0cmluZ1RhZ119IDwke2lkfT5gLFxuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgaWQoKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbENhbGVuZGFyKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICByZXR1cm4gVG9TdHJpbmcodGhpcyk7XG4gICAgfVxuICAgIGRhdGVGcm9tRmllbGRzKGZpZWxkcywgb3B0aW9uc1BhcmFtID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbENhbGVuZGFyKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICBpZiAoIUlzT2JqZWN0KGZpZWxkcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIGZpZWxkcycpO1xuICAgICAgICBjb25zdCBvcHRpb25zID0gR2V0T3B0aW9uc09iamVjdChvcHRpb25zUGFyYW0pO1xuICAgICAgICByZXR1cm4gaW1wbFtHZXRTbG90KHRoaXMsIENBTEVOREFSX0lEKV0uZGF0ZUZyb21GaWVsZHMoZmllbGRzLCBvcHRpb25zLCB0aGlzKTtcbiAgICB9XG4gICAgeWVhck1vbnRoRnJvbUZpZWxkcyhmaWVsZHMsIG9wdGlvbnNQYXJhbSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxDYWxlbmRhcih0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgaWYgKCFJc09iamVjdChmaWVsZHMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBmaWVsZHMnKTtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IEdldE9wdGlvbnNPYmplY3Qob3B0aW9uc1BhcmFtKTtcbiAgICAgICAgcmV0dXJuIGltcGxbR2V0U2xvdCh0aGlzLCBDQUxFTkRBUl9JRCldLnllYXJNb250aEZyb21GaWVsZHMoZmllbGRzLCBvcHRpb25zLCB0aGlzKTtcbiAgICB9XG4gICAgbW9udGhEYXlGcm9tRmllbGRzKGZpZWxkcywgb3B0aW9uc1BhcmFtID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbENhbGVuZGFyKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICBpZiAoIUlzT2JqZWN0KGZpZWxkcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIGZpZWxkcycpO1xuICAgICAgICBjb25zdCBvcHRpb25zID0gR2V0T3B0aW9uc09iamVjdChvcHRpb25zUGFyYW0pO1xuICAgICAgICByZXR1cm4gaW1wbFtHZXRTbG90KHRoaXMsIENBTEVOREFSX0lEKV0ubW9udGhEYXlGcm9tRmllbGRzKGZpZWxkcywgb3B0aW9ucywgdGhpcyk7XG4gICAgfVxuICAgIGZpZWxkcyhmaWVsZHMpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsQ2FsZW5kYXIodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIGNvbnN0IGZpZWxkc0FycmF5ID0gW107XG4gICAgICAgIGNvbnN0IGFsbG93ZWQgPSBuZXcgU2V0KFtcbiAgICAgICAgICAgICd5ZWFyJyxcbiAgICAgICAgICAgICdtb250aCcsXG4gICAgICAgICAgICAnbW9udGhDb2RlJyxcbiAgICAgICAgICAgICdkYXknLFxuICAgICAgICAgICAgJ2hvdXInLFxuICAgICAgICAgICAgJ21pbnV0ZScsXG4gICAgICAgICAgICAnc2Vjb25kJyxcbiAgICAgICAgICAgICdtaWxsaXNlY29uZCcsXG4gICAgICAgICAgICAnbWljcm9zZWNvbmQnLFxuICAgICAgICAgICAgJ25hbm9zZWNvbmQnXG4gICAgICAgIF0pO1xuICAgICAgICBmb3IgKGNvbnN0IG5hbWUgb2YgZmllbGRzKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG5hbWUgIT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgZmllbGRzJyk7XG4gICAgICAgICAgICBpZiAoIWFsbG93ZWQuaGFzKG5hbWUpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBpbnZhbGlkIGZpZWxkIG5hbWUgJHtuYW1lfWApO1xuICAgICAgICAgICAgYWxsb3dlZC5kZWxldGUobmFtZSk7XG4gICAgICAgICAgICBBcnJheVByb3RvdHlwZVB1c2gkMi5jYWxsKGZpZWxkc0FycmF5LCBuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW1wbFtHZXRTbG90KHRoaXMsIENBTEVOREFSX0lEKV0uZmllbGRzKGZpZWxkc0FycmF5KTtcbiAgICB9XG4gICAgbWVyZ2VGaWVsZHMoZmllbGRzLCBhZGRpdGlvbmFsRmllbGRzKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbENhbGVuZGFyKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICByZXR1cm4gaW1wbFtHZXRTbG90KHRoaXMsIENBTEVOREFSX0lEKV0ubWVyZ2VGaWVsZHMoZmllbGRzLCBhZGRpdGlvbmFsRmllbGRzKTtcbiAgICB9XG4gICAgZGF0ZUFkZChkYXRlUGFyYW0sIGR1cmF0aW9uUGFyYW0sIG9wdGlvbnNQYXJhbSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxDYWxlbmRhcih0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgY29uc3QgZGF0ZSA9IFRvVGVtcG9yYWxEYXRlKGRhdGVQYXJhbSk7XG4gICAgICAgIGNvbnN0IGR1cmF0aW9uID0gVG9UZW1wb3JhbER1cmF0aW9uKGR1cmF0aW9uUGFyYW0pO1xuICAgICAgICBjb25zdCBvcHRpb25zID0gR2V0T3B0aW9uc09iamVjdChvcHRpb25zUGFyYW0pO1xuICAgICAgICBjb25zdCBvdmVyZmxvdyA9IFRvVGVtcG9yYWxPdmVyZmxvdyhvcHRpb25zKTtcbiAgICAgICAgY29uc3QgeyBkYXlzIH0gPSBCYWxhbmNlRHVyYXRpb24oR2V0U2xvdChkdXJhdGlvbiwgREFZUyksIEdldFNsb3QoZHVyYXRpb24sIEhPVVJTKSwgR2V0U2xvdChkdXJhdGlvbiwgTUlOVVRFUyksIEdldFNsb3QoZHVyYXRpb24sIFNFQ09ORFMpLCBHZXRTbG90KGR1cmF0aW9uLCBNSUxMSVNFQ09ORFMpLCBHZXRTbG90KGR1cmF0aW9uLCBNSUNST1NFQ09ORFMpLCBHZXRTbG90KGR1cmF0aW9uLCBOQU5PU0VDT05EUyksICdkYXknKTtcbiAgICAgICAgcmV0dXJuIGltcGxbR2V0U2xvdCh0aGlzLCBDQUxFTkRBUl9JRCldLmRhdGVBZGQoZGF0ZSwgR2V0U2xvdChkdXJhdGlvbiwgWUVBUlMpLCBHZXRTbG90KGR1cmF0aW9uLCBNT05USFMpLCBHZXRTbG90KGR1cmF0aW9uLCBXRUVLUyksIGRheXMsIG92ZXJmbG93LCB0aGlzKTtcbiAgICB9XG4gICAgZGF0ZVVudGlsKG9uZVBhcmFtLCB0d29QYXJhbSwgb3B0aW9uc1BhcmFtID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbENhbGVuZGFyKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICBjb25zdCBvbmUgPSBUb1RlbXBvcmFsRGF0ZShvbmVQYXJhbSk7XG4gICAgICAgIGNvbnN0IHR3byA9IFRvVGVtcG9yYWxEYXRlKHR3b1BhcmFtKTtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IEdldE9wdGlvbnNPYmplY3Qob3B0aW9uc1BhcmFtKTtcbiAgICAgICAgY29uc3QgbGFyZ2VzdFVuaXQgPSBUb0xhcmdlc3RUZW1wb3JhbFVuaXQob3B0aW9ucywgJ2F1dG8nLCBbJ2hvdXInLCAnbWludXRlJywgJ3NlY29uZCcsICdtaWxsaXNlY29uZCcsICdtaWNyb3NlY29uZCcsICduYW5vc2Vjb25kJ10sICdkYXknKTtcbiAgICAgICAgY29uc3QgeyB5ZWFycywgbW9udGhzLCB3ZWVrcywgZGF5cyB9ID0gaW1wbFtHZXRTbG90KHRoaXMsIENBTEVOREFSX0lEKV0uZGF0ZVVudGlsKG9uZSwgdHdvLCBsYXJnZXN0VW5pdCk7XG4gICAgICAgIGNvbnN0IER1cmF0aW9uID0gR2V0SW50cmluc2ljKCclVGVtcG9yYWwuRHVyYXRpb24lJyk7XG4gICAgICAgIHJldHVybiBuZXcgRHVyYXRpb24oeWVhcnMsIG1vbnRocywgd2Vla3MsIGRheXMsIDAsIDAsIDAsIDAsIDAsIDApO1xuICAgIH1cbiAgICB5ZWFyKGRhdGVQYXJhbSkge1xuICAgICAgICBsZXQgZGF0ZSA9IGRhdGVQYXJhbTtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsQ2FsZW5kYXIodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbFllYXJNb250aChkYXRlKSlcbiAgICAgICAgICAgIGRhdGUgPSBUb1RlbXBvcmFsRGF0ZShkYXRlKTtcbiAgICAgICAgcmV0dXJuIGltcGxbR2V0U2xvdCh0aGlzLCBDQUxFTkRBUl9JRCldLnllYXIoZGF0ZSk7XG4gICAgfVxuICAgIG1vbnRoKGRhdGVQYXJhbSkge1xuICAgICAgICBsZXQgZGF0ZSA9IGRhdGVQYXJhbTtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsQ2FsZW5kYXIodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIGlmIChJc1RlbXBvcmFsTW9udGhEYXkoZGF0ZSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd1c2UgbW9udGhDb2RlIG9uIFBsYWluTW9udGhEYXkgaW5zdGVhZCcpO1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxZZWFyTW9udGgoZGF0ZSkpXG4gICAgICAgICAgICBkYXRlID0gVG9UZW1wb3JhbERhdGUoZGF0ZSk7XG4gICAgICAgIHJldHVybiBpbXBsW0dldFNsb3QodGhpcywgQ0FMRU5EQVJfSUQpXS5tb250aChkYXRlKTtcbiAgICB9XG4gICAgbW9udGhDb2RlKGRhdGVQYXJhbSkge1xuICAgICAgICBsZXQgZGF0ZSA9IGRhdGVQYXJhbTtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsQ2FsZW5kYXIodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbFllYXJNb250aChkYXRlKSAmJiAhSXNUZW1wb3JhbE1vbnRoRGF5KGRhdGUpKVxuICAgICAgICAgICAgZGF0ZSA9IFRvVGVtcG9yYWxEYXRlKGRhdGUpO1xuICAgICAgICByZXR1cm4gaW1wbFtHZXRTbG90KHRoaXMsIENBTEVOREFSX0lEKV0ubW9udGhDb2RlKGRhdGUpO1xuICAgIH1cbiAgICBkYXkoZGF0ZVBhcmFtKSB7XG4gICAgICAgIGxldCBkYXRlID0gZGF0ZVBhcmFtO1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxDYWxlbmRhcih0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsTW9udGhEYXkoZGF0ZSkpXG4gICAgICAgICAgICBkYXRlID0gVG9UZW1wb3JhbERhdGUoZGF0ZSk7XG4gICAgICAgIHJldHVybiBpbXBsW0dldFNsb3QodGhpcywgQ0FMRU5EQVJfSUQpXS5kYXkoZGF0ZSk7XG4gICAgfVxuICAgIGVyYShkYXRlUGFyYW0pIHtcbiAgICAgICAgbGV0IGRhdGUgPSBkYXRlUGFyYW07XG4gICAgICAgIGlmICghSXNUZW1wb3JhbENhbGVuZGFyKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxZZWFyTW9udGgoZGF0ZSkpXG4gICAgICAgICAgICBkYXRlID0gVG9UZW1wb3JhbERhdGUoZGF0ZSk7XG4gICAgICAgIHJldHVybiBpbXBsW0dldFNsb3QodGhpcywgQ0FMRU5EQVJfSUQpXS5lcmEoZGF0ZSk7XG4gICAgfVxuICAgIGVyYVllYXIoZGF0ZVBhcmFtKSB7XG4gICAgICAgIGxldCBkYXRlID0gZGF0ZVBhcmFtO1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxDYWxlbmRhcih0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsWWVhck1vbnRoKGRhdGUpKVxuICAgICAgICAgICAgZGF0ZSA9IFRvVGVtcG9yYWxEYXRlKGRhdGUpO1xuICAgICAgICByZXR1cm4gaW1wbFtHZXRTbG90KHRoaXMsIENBTEVOREFSX0lEKV0uZXJhWWVhcihkYXRlKTtcbiAgICB9XG4gICAgZGF5T2ZXZWVrKGRhdGVQYXJhbSkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxDYWxlbmRhcih0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgY29uc3QgZGF0ZSA9IFRvVGVtcG9yYWxEYXRlKGRhdGVQYXJhbSk7XG4gICAgICAgIHJldHVybiBpbXBsW0dldFNsb3QodGhpcywgQ0FMRU5EQVJfSUQpXS5kYXlPZldlZWsoZGF0ZSk7XG4gICAgfVxuICAgIGRheU9mWWVhcihkYXRlUGFyYW0pIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsQ2FsZW5kYXIodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIGNvbnN0IGRhdGUgPSBUb1RlbXBvcmFsRGF0ZShkYXRlUGFyYW0pO1xuICAgICAgICByZXR1cm4gaW1wbFtHZXRTbG90KHRoaXMsIENBTEVOREFSX0lEKV0uZGF5T2ZZZWFyKGRhdGUpO1xuICAgIH1cbiAgICB3ZWVrT2ZZZWFyKGRhdGVQYXJhbSkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxDYWxlbmRhcih0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgY29uc3QgZGF0ZSA9IFRvVGVtcG9yYWxEYXRlKGRhdGVQYXJhbSk7XG4gICAgICAgIHJldHVybiBpbXBsW0dldFNsb3QodGhpcywgQ0FMRU5EQVJfSUQpXS53ZWVrT2ZZZWFyKGRhdGUpO1xuICAgIH1cbiAgICBkYXlzSW5XZWVrKGRhdGVQYXJhbSkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxDYWxlbmRhcih0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgY29uc3QgZGF0ZSA9IFRvVGVtcG9yYWxEYXRlKGRhdGVQYXJhbSk7XG4gICAgICAgIHJldHVybiBpbXBsW0dldFNsb3QodGhpcywgQ0FMRU5EQVJfSUQpXS5kYXlzSW5XZWVrKGRhdGUpO1xuICAgIH1cbiAgICBkYXlzSW5Nb250aChkYXRlUGFyYW0pIHtcbiAgICAgICAgbGV0IGRhdGUgPSBkYXRlUGFyYW07XG4gICAgICAgIGlmICghSXNUZW1wb3JhbENhbGVuZGFyKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxZZWFyTW9udGgoZGF0ZSkpXG4gICAgICAgICAgICBkYXRlID0gVG9UZW1wb3JhbERhdGUoZGF0ZSk7XG4gICAgICAgIHJldHVybiBpbXBsW0dldFNsb3QodGhpcywgQ0FMRU5EQVJfSUQpXS5kYXlzSW5Nb250aChkYXRlKTtcbiAgICB9XG4gICAgZGF5c0luWWVhcihkYXRlUGFyYW0pIHtcbiAgICAgICAgbGV0IGRhdGUgPSBkYXRlUGFyYW07XG4gICAgICAgIGlmICghSXNUZW1wb3JhbENhbGVuZGFyKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxZZWFyTW9udGgoZGF0ZSkpXG4gICAgICAgICAgICBkYXRlID0gVG9UZW1wb3JhbERhdGUoZGF0ZSk7XG4gICAgICAgIHJldHVybiBpbXBsW0dldFNsb3QodGhpcywgQ0FMRU5EQVJfSUQpXS5kYXlzSW5ZZWFyKGRhdGUpO1xuICAgIH1cbiAgICBtb250aHNJblllYXIoZGF0ZVBhcmFtKSB7XG4gICAgICAgIGxldCBkYXRlID0gZGF0ZVBhcmFtO1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxDYWxlbmRhcih0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsWWVhck1vbnRoKGRhdGUpKVxuICAgICAgICAgICAgZGF0ZSA9IFRvVGVtcG9yYWxEYXRlKGRhdGUpO1xuICAgICAgICByZXR1cm4gaW1wbFtHZXRTbG90KHRoaXMsIENBTEVOREFSX0lEKV0ubW9udGhzSW5ZZWFyKGRhdGUpO1xuICAgIH1cbiAgICBpbkxlYXBZZWFyKGRhdGVQYXJhbSkge1xuICAgICAgICBsZXQgZGF0ZSA9IGRhdGVQYXJhbTtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsQ2FsZW5kYXIodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbFllYXJNb250aChkYXRlKSlcbiAgICAgICAgICAgIGRhdGUgPSBUb1RlbXBvcmFsRGF0ZShkYXRlKTtcbiAgICAgICAgcmV0dXJuIGltcGxbR2V0U2xvdCh0aGlzLCBDQUxFTkRBUl9JRCldLmluTGVhcFllYXIoZGF0ZSk7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxDYWxlbmRhcih0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgcmV0dXJuIEdldFNsb3QodGhpcywgQ0FMRU5EQVJfSUQpO1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbENhbGVuZGFyKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICByZXR1cm4gVG9TdHJpbmcodGhpcyk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tKGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIFRvVGVtcG9yYWxDYWxlbmRhcihpdGVtKTtcbiAgICB9XG59XG5NYWtlSW50cmluc2ljQ2xhc3MoQ2FsZW5kYXIsICdUZW1wb3JhbC5DYWxlbmRhcicpO1xuRGVmaW5lSW50cmluc2ljKCdUZW1wb3JhbC5DYWxlbmRhci5mcm9tJywgQ2FsZW5kYXIuZnJvbSk7XG4vKipcbiAqIEltcGxlbWVudGF0aW9uIGZvciB0aGUgSVNPIDg2MDEgY2FsZW5kYXIuIFRoaXMgaXMgdGhlIG9ubHkgY2FsZW5kYXIgdGhhdCdzXG4gKiBndWFyYW50ZWVkIHRvIGJlIHN1cHBvcnRlZCBieSBhbGwgRUNNQVNjcmlwdCBpbXBsZW1lbnRhdGlvbnMsIGluY2x1ZGluZyB0aG9zZVxuICogd2l0aG91dCBJbnRsIChFQ01BLTQwMikgc3VwcG9ydC5cbiAqL1xuaW1wbFsnaXNvODYwMSddID0ge1xuICAgIGRhdGVGcm9tRmllbGRzKGZpZWxkc1BhcmFtLCBvcHRpb25zLCBjYWxlbmRhcikge1xuICAgICAgICBjb25zdCBvdmVyZmxvdyA9IFRvVGVtcG9yYWxPdmVyZmxvdyhvcHRpb25zKTtcbiAgICAgICAgbGV0IGZpZWxkcyA9IFByZXBhcmVUZW1wb3JhbEZpZWxkcyhmaWVsZHNQYXJhbSwgW1xuICAgICAgICAgICAgWydkYXknXSxcbiAgICAgICAgICAgIFsnbW9udGgnLCB1bmRlZmluZWRdLFxuICAgICAgICAgICAgWydtb250aENvZGUnLCB1bmRlZmluZWRdLFxuICAgICAgICAgICAgWyd5ZWFyJ11cbiAgICAgICAgXSk7XG4gICAgICAgIGZpZWxkcyA9IHJlc29sdmVOb25MdW5pc29sYXJNb250aChmaWVsZHMpO1xuICAgICAgICBsZXQgeyB5ZWFyLCBtb250aCwgZGF5IH0gPSBmaWVsZHM7XG4gICAgICAgICh7IHllYXIsIG1vbnRoLCBkYXkgfSA9IFJlZ3VsYXRlSVNPRGF0ZSh5ZWFyLCBtb250aCwgZGF5LCBvdmVyZmxvdykpO1xuICAgICAgICByZXR1cm4gQ3JlYXRlVGVtcG9yYWxEYXRlKHllYXIsIG1vbnRoLCBkYXksIGNhbGVuZGFyKTtcbiAgICB9LFxuICAgIHllYXJNb250aEZyb21GaWVsZHMoZmllbGRzUGFyYW0sIG9wdGlvbnMsIGNhbGVuZGFyKSB7XG4gICAgICAgIGNvbnN0IG92ZXJmbG93ID0gVG9UZW1wb3JhbE92ZXJmbG93KG9wdGlvbnMpO1xuICAgICAgICBsZXQgZmllbGRzID0gUHJlcGFyZVRlbXBvcmFsRmllbGRzKGZpZWxkc1BhcmFtLCBbXG4gICAgICAgICAgICBbJ21vbnRoJywgdW5kZWZpbmVkXSxcbiAgICAgICAgICAgIFsnbW9udGhDb2RlJywgdW5kZWZpbmVkXSxcbiAgICAgICAgICAgIFsneWVhciddXG4gICAgICAgIF0pO1xuICAgICAgICBmaWVsZHMgPSByZXNvbHZlTm9uTHVuaXNvbGFyTW9udGgoZmllbGRzKTtcbiAgICAgICAgbGV0IHsgeWVhciwgbW9udGggfSA9IGZpZWxkcztcbiAgICAgICAgKHsgeWVhciwgbW9udGggfSA9IFJlZ3VsYXRlSVNPWWVhck1vbnRoKHllYXIsIG1vbnRoLCBvdmVyZmxvdykpO1xuICAgICAgICByZXR1cm4gQ3JlYXRlVGVtcG9yYWxZZWFyTW9udGgoeWVhciwgbW9udGgsIGNhbGVuZGFyLCAvKiByZWZlcmVuY2VJU09EYXkgPSAqLyAxKTtcbiAgICB9LFxuICAgIG1vbnRoRGF5RnJvbUZpZWxkcyhmaWVsZHNQYXJhbSwgb3B0aW9ucywgY2FsZW5kYXIpIHtcbiAgICAgICAgY29uc3Qgb3ZlcmZsb3cgPSBUb1RlbXBvcmFsT3ZlcmZsb3cob3B0aW9ucyk7XG4gICAgICAgIGxldCBmaWVsZHMgPSBQcmVwYXJlVGVtcG9yYWxGaWVsZHMoZmllbGRzUGFyYW0sIFtcbiAgICAgICAgICAgIFsnZGF5J10sXG4gICAgICAgICAgICBbJ21vbnRoJywgdW5kZWZpbmVkXSxcbiAgICAgICAgICAgIFsnbW9udGhDb2RlJywgdW5kZWZpbmVkXSxcbiAgICAgICAgICAgIFsneWVhcicsIHVuZGVmaW5lZF1cbiAgICAgICAgXSk7XG4gICAgICAgIGlmIChmaWVsZHMubW9udGggIT09IHVuZGVmaW5lZCAmJiBmaWVsZHMueWVhciA9PT0gdW5kZWZpbmVkICYmIGZpZWxkcy5tb250aENvZGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZWl0aGVyIHllYXIgb3IgbW9udGhDb2RlIHJlcXVpcmVkIHdpdGggbW9udGgnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1c2VZZWFyID0gZmllbGRzLm1vbnRoQ29kZSA9PT0gdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCByZWZlcmVuY2VJU09ZZWFyID0gMTk3MjtcbiAgICAgICAgZmllbGRzID0gcmVzb2x2ZU5vbkx1bmlzb2xhck1vbnRoKGZpZWxkcyk7XG4gICAgICAgIGxldCB7IG1vbnRoLCBkYXksIHllYXIgfSA9IGZpZWxkcztcbiAgICAgICAgKHsgbW9udGgsIGRheSB9ID0gUmVndWxhdGVJU09EYXRlKHVzZVllYXIgPyB5ZWFyIDogcmVmZXJlbmNlSVNPWWVhciwgbW9udGgsIGRheSwgb3ZlcmZsb3cpKTtcbiAgICAgICAgcmV0dXJuIENyZWF0ZVRlbXBvcmFsTW9udGhEYXkobW9udGgsIGRheSwgY2FsZW5kYXIsIHJlZmVyZW5jZUlTT1llYXIpO1xuICAgIH0sXG4gICAgZmllbGRzKGZpZWxkcykge1xuICAgICAgICByZXR1cm4gZmllbGRzO1xuICAgIH0sXG4gICAgbWVyZ2VGaWVsZHMoZmllbGRzLCBhZGRpdGlvbmFsRmllbGRzKSB7XG4gICAgICAgIGNvbnN0IG1lcmdlZCA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IG5leHRLZXkgb2YgT2JqZWN0S2V5cyhmaWVsZHMpKSB7XG4gICAgICAgICAgICBpZiAobmV4dEtleSA9PT0gJ21vbnRoJyB8fCBuZXh0S2V5ID09PSAnbW9udGhDb2RlJylcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIG1lcmdlZFtuZXh0S2V5XSA9IGZpZWxkc1tuZXh0S2V5XTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuZXdLZXlzID0gT2JqZWN0S2V5cyhhZGRpdGlvbmFsRmllbGRzKTtcbiAgICAgICAgZm9yIChjb25zdCBuZXh0S2V5IG9mIG5ld0tleXMpIHtcbiAgICAgICAgICAgIG1lcmdlZFtuZXh0S2V5XSA9IGFkZGl0aW9uYWxGaWVsZHNbbmV4dEtleV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFBcnJheUluY2x1ZGVzLmNhbGwobmV3S2V5cywgJ21vbnRoJykgJiYgIUFycmF5SW5jbHVkZXMuY2FsbChuZXdLZXlzLCAnbW9udGhDb2RlJykpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgbW9udGgsIG1vbnRoQ29kZSB9ID0gZmllbGRzO1xuICAgICAgICAgICAgaWYgKG1vbnRoICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgbWVyZ2VkLm1vbnRoID0gbW9udGg7XG4gICAgICAgICAgICBpZiAobW9udGhDb2RlICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgbWVyZ2VkLm1vbnRoQ29kZSA9IG1vbnRoQ29kZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVyZ2VkO1xuICAgIH0sXG4gICAgZGF0ZUFkZChkYXRlLCB5ZWFycywgbW9udGhzLCB3ZWVrcywgZGF5cywgb3ZlcmZsb3csIGNhbGVuZGFyKSB7XG4gICAgICAgIGxldCB5ZWFyID0gR2V0U2xvdChkYXRlLCBJU09fWUVBUik7XG4gICAgICAgIGxldCBtb250aCA9IEdldFNsb3QoZGF0ZSwgSVNPX01PTlRIKTtcbiAgICAgICAgbGV0IGRheSA9IEdldFNsb3QoZGF0ZSwgSVNPX0RBWSk7XG4gICAgICAgICh7IHllYXIsIG1vbnRoLCBkYXkgfSA9IEFkZElTT0RhdGUoeWVhciwgbW9udGgsIGRheSwgeWVhcnMsIG1vbnRocywgd2Vla3MsIGRheXMsIG92ZXJmbG93KSk7XG4gICAgICAgIHJldHVybiBDcmVhdGVUZW1wb3JhbERhdGUoeWVhciwgbW9udGgsIGRheSwgY2FsZW5kYXIpO1xuICAgIH0sXG4gICAgZGF0ZVVudGlsKG9uZSwgdHdvLCBsYXJnZXN0VW5pdCkge1xuICAgICAgICByZXR1cm4gRGlmZmVyZW5jZUlTT0RhdGUoR2V0U2xvdChvbmUsIElTT19ZRUFSKSwgR2V0U2xvdChvbmUsIElTT19NT05USCksIEdldFNsb3Qob25lLCBJU09fREFZKSwgR2V0U2xvdCh0d28sIElTT19ZRUFSKSwgR2V0U2xvdCh0d28sIElTT19NT05USCksIEdldFNsb3QodHdvLCBJU09fREFZKSwgbGFyZ2VzdFVuaXQpO1xuICAgIH0sXG4gICAgeWVhcihkYXRlKSB7XG4gICAgICAgIHJldHVybiBHZXRTbG90KGRhdGUsIElTT19ZRUFSKTtcbiAgICB9LFxuICAgIGVyYSgpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9LFxuICAgIGVyYVllYXIoKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfSxcbiAgICBtb250aChkYXRlKSB7XG4gICAgICAgIHJldHVybiBHZXRTbG90KGRhdGUsIElTT19NT05USCk7XG4gICAgfSxcbiAgICBtb250aENvZGUoZGF0ZSkge1xuICAgICAgICByZXR1cm4gYnVpbGRNb250aENvZGUoR2V0U2xvdChkYXRlLCBJU09fTU9OVEgpKTtcbiAgICB9LFxuICAgIGRheShkYXRlKSB7XG4gICAgICAgIHJldHVybiBHZXRTbG90KGRhdGUsIElTT19EQVkpO1xuICAgIH0sXG4gICAgZGF5T2ZXZWVrKGRhdGUpIHtcbiAgICAgICAgcmV0dXJuIERheU9mV2VlayhHZXRTbG90KGRhdGUsIElTT19ZRUFSKSwgR2V0U2xvdChkYXRlLCBJU09fTU9OVEgpLCBHZXRTbG90KGRhdGUsIElTT19EQVkpKTtcbiAgICB9LFxuICAgIGRheU9mWWVhcihkYXRlKSB7XG4gICAgICAgIHJldHVybiBEYXlPZlllYXIoR2V0U2xvdChkYXRlLCBJU09fWUVBUiksIEdldFNsb3QoZGF0ZSwgSVNPX01PTlRIKSwgR2V0U2xvdChkYXRlLCBJU09fREFZKSk7XG4gICAgfSxcbiAgICB3ZWVrT2ZZZWFyKGRhdGUpIHtcbiAgICAgICAgcmV0dXJuIFdlZWtPZlllYXIoR2V0U2xvdChkYXRlLCBJU09fWUVBUiksIEdldFNsb3QoZGF0ZSwgSVNPX01PTlRIKSwgR2V0U2xvdChkYXRlLCBJU09fREFZKSk7XG4gICAgfSxcbiAgICBkYXlzSW5XZWVrKCkge1xuICAgICAgICByZXR1cm4gNztcbiAgICB9LFxuICAgIGRheXNJbk1vbnRoKGRhdGUpIHtcbiAgICAgICAgcmV0dXJuIElTT0RheXNJbk1vbnRoKEdldFNsb3QoZGF0ZSwgSVNPX1lFQVIpLCBHZXRTbG90KGRhdGUsIElTT19NT05USCkpO1xuICAgIH0sXG4gICAgZGF5c0luWWVhcihkYXRlUGFyYW0pIHtcbiAgICAgICAgbGV0IGRhdGUgPSBkYXRlUGFyYW07XG4gICAgICAgIGlmICghSGFzU2xvdChkYXRlLCBJU09fWUVBUikpXG4gICAgICAgICAgICBkYXRlID0gVG9UZW1wb3JhbERhdGUoZGF0ZSk7XG4gICAgICAgIHJldHVybiBMZWFwWWVhcihHZXRTbG90KGRhdGUsIElTT19ZRUFSKSkgPyAzNjYgOiAzNjU7XG4gICAgfSxcbiAgICBtb250aHNJblllYXIoKSB7XG4gICAgICAgIHJldHVybiAxMjtcbiAgICB9LFxuICAgIGluTGVhcFllYXIoZGF0ZVBhcmFtKSB7XG4gICAgICAgIGxldCBkYXRlID0gZGF0ZVBhcmFtO1xuICAgICAgICBpZiAoIUhhc1Nsb3QoZGF0ZSwgSVNPX1lFQVIpKVxuICAgICAgICAgICAgZGF0ZSA9IFRvVGVtcG9yYWxEYXRlKGRhdGUpO1xuICAgICAgICByZXR1cm4gTGVhcFllYXIoR2V0U2xvdChkYXRlLCBJU09fWUVBUikpO1xuICAgIH1cbn07XG5mdW5jdGlvbiBtb250aENvZGVOdW1iZXJQYXJ0KG1vbnRoQ29kZSkge1xuICAgIGlmICghbW9udGhDb2RlLnN0YXJ0c1dpdGgoJ00nKSkge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgSW52YWxpZCBtb250aCBjb2RlOiAke21vbnRoQ29kZX0uICBNb250aCBjb2RlcyBtdXN0IHN0YXJ0IHdpdGggTS5gKTtcbiAgICB9XG4gICAgY29uc3QgbW9udGggPSArbW9udGhDb2RlLnNsaWNlKDEpO1xuICAgIGlmIChpc05hTihtb250aCkpXG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBJbnZhbGlkIG1vbnRoIGNvZGU6ICR7bW9udGhDb2RlfWApO1xuICAgIHJldHVybiBtb250aDtcbn1cbmZ1bmN0aW9uIGJ1aWxkTW9udGhDb2RlKG1vbnRoLCBsZWFwID0gZmFsc2UpIHtcbiAgICByZXR1cm4gYE0ke21vbnRoLnRvU3RyaW5nKCkucGFkU3RhcnQoMiwgJzAnKX0ke2xlYXAgPyAnTCcgOiAnJ31gO1xufVxuLyoqXG4gKiBTYWZlbHkgbWVyZ2UgYSBtb250aCwgbW9udGhDb2RlIHBhaXIgaW50byBhbiBpbnRlZ2VyIG1vbnRoLlxuICogSWYgYm90aCBhcmUgcHJlc2VudCwgbWFrZSBzdXJlIHRoZXkgbWF0Y2guXG4gKiBUaGlzIGxvZ2ljIGRvZXNuJ3Qgd29yayBmb3IgbHVuaXNvbGFyIGNhbGVuZGFycyFcbiAqICovXG5mdW5jdGlvbiByZXNvbHZlTm9uTHVuaXNvbGFyTW9udGgoY2FsZW5kYXJEYXRlLCBvdmVyZmxvdyA9IHVuZGVmaW5lZCwgbW9udGhzUGVyWWVhciA9IDEyKSB7XG4gICAgbGV0IHsgbW9udGgsIG1vbnRoQ29kZSB9ID0gY2FsZW5kYXJEYXRlO1xuICAgIGlmIChtb250aENvZGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAobW9udGggPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0VpdGhlciBtb250aCBvciBtb250aENvZGUgYXJlIHJlcXVpcmVkJyk7XG4gICAgICAgIC8vIFRoZSBJU08gY2FsZW5kYXIgdXNlcyB0aGUgZGVmYXVsdCAodW5kZWZpbmVkKSB2YWx1ZSBiZWNhdXNlIGl0IGRvZXNcbiAgICAgICAgLy8gY29uc3RyYWluL3JlamVjdCBhZnRlciB0aGlzIG1ldGhvZCByZXR1cm5zLiBOb24tSVNPIGNhbGVuZGFycywgaG93ZXZlcixcbiAgICAgICAgLy8gcmVseSBvbiB0aGlzIGZ1bmN0aW9uIHRvIGNvbnN0cmFpbi9yZWplY3Qgb3V0LW9mLXJhbmdlIGBtb250aGAgdmFsdWVzLlxuICAgICAgICBpZiAob3ZlcmZsb3cgPT09ICdyZWplY3QnKVxuICAgICAgICAgICAgUmVqZWN0VG9SYW5nZShtb250aCwgMSwgbW9udGhzUGVyWWVhcik7XG4gICAgICAgIGlmIChvdmVyZmxvdyA9PT0gJ2NvbnN0cmFpbicpXG4gICAgICAgICAgICBtb250aCA9IENvbnN0cmFpblRvUmFuZ2UobW9udGgsIDEsIG1vbnRoc1BlclllYXIpO1xuICAgICAgICBtb250aENvZGUgPSBidWlsZE1vbnRoQ29kZShtb250aCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBudW1iZXJQYXJ0ID0gbW9udGhDb2RlTnVtYmVyUGFydChtb250aENvZGUpO1xuICAgICAgICBpZiAobW9udGggIT09IHVuZGVmaW5lZCAmJiBtb250aCAhPT0gbnVtYmVyUGFydCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYG1vbnRoQ29kZSAke21vbnRoQ29kZX0gYW5kIG1vbnRoICR7bW9udGh9IG11c3QgbWF0Y2ggaWYgYm90aCBhcmUgcHJlc2VudGApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtb250aENvZGUgIT09IGJ1aWxkTW9udGhDb2RlKG51bWJlclBhcnQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgSW52YWxpZCBtb250aCBjb2RlOiAke21vbnRoQ29kZX1gKTtcbiAgICAgICAgfVxuICAgICAgICBtb250aCA9IG51bWJlclBhcnQ7XG4gICAgICAgIGlmIChtb250aCA8IDEgfHwgbW9udGggPiBtb250aHNQZXJZZWFyKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYEludmFsaWQgbW9udGhDb2RlOiAke21vbnRoQ29kZX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgLi4uY2FsZW5kYXJEYXRlLCBtb250aCwgbW9udGhDb2RlIH07XG59XG4vKipcbiAqIFRoaXMgcHJvdG90eXBlIGltcGxlbWVudGF0aW9uIG9mIG5vbi1JU08gY2FsZW5kYXJzIG1ha2VzIG1hbnkgcmVwZWF0ZWQgY2FsbHNcbiAqIHRvIEludGwgQVBJcyB3aGljaCBtYXkgYmUgc2xvdyAoZS5nLiA+MC4ybXMpLiBUaGlzIHRyaXZpYWwgY2FjaGUgd2lsbCBzcGVlZFxuICogdXAgdGhlc2UgcmVwZWF0IGFjY2Vzc2VzLiBFYWNoIGNhY2hlIGluc3RhbmNlIGlzIGFzc29jaWF0ZWQgKHZpYSBhIFdlYWtNYXApXG4gKiB0byBhIHNwZWNpZmljIFRlbXBvcmFsIG9iamVjdCwgd2hpY2ggc3BlZWRzIHVwIG11bHRpcGxlIGNhbGVuZGFyIGNhbGxzIG9uIHRoZVxuICogc2FtZSBUZW1wb3JhbCBvYmplY3QgaW5zdGFuY2UuICBObyBpbnZhbGlkYXRpb24gb3IgcHJ1bmluZyBpcyBuZWNlc3NhcnlcbiAqIGJlY2F1c2UgZWFjaCBvYmplY3QncyBjYWNoZSBpcyB0aHJvd24gYXdheSB3aGVuIHRoZSBvYmplY3QgaXMgR0MtZWQuXG4gKi9cbmNsYXNzIE9uZU9iamVjdENhY2hlIHtcbiAgICBjb25zdHJ1Y3RvcihjYWNoZVRvQ2xvbmUpIHtcbiAgICAgICAgdGhpcy5tYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuY2FsbHMgPSAwO1xuICAgICAgICB0aGlzLmhpdHMgPSAwO1xuICAgICAgICB0aGlzLm1pc3NlcyA9IDA7XG4gICAgICAgIHRoaXMubm93ID0gZ2xvYmFsVGhpcy5wZXJmb3JtYW5jZSA/IGdsb2JhbFRoaXMucGVyZm9ybWFuY2Uubm93KCkgOiBEYXRlLm5vdygpO1xuICAgICAgICBpZiAoY2FjaGVUb0Nsb25lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZW50cnkgb2YgY2FjaGVUb0Nsb25lLm1hcC5lbnRyaWVzKCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoKytpID4gT25lT2JqZWN0Q2FjaGUuTUFYX0NBQ0hFX0VOVFJJRVMpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIHRoaXMubWFwLnNldCguLi5lbnRyeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0KGtleSkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLm1hcC5nZXQoa2V5KTtcbiAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgdGhpcy5oaXRzKys7XG4gICAgICAgICAgICB0aGlzLnJlcG9ydCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2FsbHMrKztcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgc2V0KGtleSwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5tYXAuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICB0aGlzLm1pc3NlcysrO1xuICAgICAgICB0aGlzLnJlcG9ydCgpO1xuICAgIH1cbiAgICByZXBvcnQoKSB7XG4gICAgICAgIC8qXG4gICAgICAgIGlmICh0aGlzLmNhbGxzID09PSAwKSByZXR1cm47XG4gICAgICAgIGNvbnN0IG1zID0gKGdsb2JhbFRoaXMucGVyZm9ybWFuY2UgPyBnbG9iYWxUaGlzLnBlcmZvcm1hbmNlLm5vdygpIDogRGF0ZS5ub3coKSkgLSB0aGlzLm5vdztcbiAgICAgICAgY29uc3QgaGl0UmF0ZSA9ICgoMTAwICogdGhpcy5oaXRzKSAvIHRoaXMuY2FsbHMpLnRvRml4ZWQoMCk7XG4gICAgICAgIGNvbnNvbGUubG9nKGAke3RoaXMuY2FsbHN9IGNhbGxzIGluICR7bXMudG9GaXhlZCgyKX1tcy4gSGl0czogJHt0aGlzLmhpdHN9ICgke2hpdFJhdGV9JSkuIE1pc3NlczogJHt0aGlzLm1pc3Nlc30uYCk7XG4gICAgICAgICovXG4gICAgfVxuICAgIHNldE9iamVjdChvYmopIHtcbiAgICAgICAgaWYgKE9uZU9iamVjdENhY2hlLm9iamVjdE1hcC5nZXQob2JqKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdvYmplY3QgYWxyZWFkeSBjYWNoZWQnKTtcbiAgICAgICAgT25lT2JqZWN0Q2FjaGUub2JqZWN0TWFwLnNldChvYmosIHRoaXMpO1xuICAgICAgICB0aGlzLnJlcG9ydCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgV2Vha01hcC1iYWNrZWQgY2FjaGUgdGhhdCdzIHVzZWQgdG8gc3RvcmUgZXhwZW5zaXZlIHJlc3VsdHNcbiAgICAgKiB0aGF0IGFyZSBhc3NvY2lhdGVkIHdpdGggYSBwYXJ0aWN1bGFyIFRlbXBvcmFsIG9iamVjdCBpbnN0YW5jZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvYmogLSBvYmplY3QgdG8gYXNzb2NpYXRlIHdpdGggdGhlIGNhY2hlXG4gICAgICovXG4gICAgc3RhdGljIGdldENhY2hlRm9yT2JqZWN0KG9iaikge1xuICAgICAgICBsZXQgY2FjaGUgPSBPbmVPYmplY3RDYWNoZS5vYmplY3RNYXAuZ2V0KG9iaik7XG4gICAgICAgIGlmICghY2FjaGUpIHtcbiAgICAgICAgICAgIGNhY2hlID0gbmV3IE9uZU9iamVjdENhY2hlKCk7XG4gICAgICAgICAgICBPbmVPYmplY3RDYWNoZS5vYmplY3RNYXAuc2V0KG9iaiwgY2FjaGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjYWNoZTtcbiAgICB9XG59XG5PbmVPYmplY3RDYWNoZS5vYmplY3RNYXAgPSBuZXcgV2Vha01hcCgpO1xuT25lT2JqZWN0Q2FjaGUuTUFYX0NBQ0hFX0VOVFJJRVMgPSAxMDAwO1xuZnVuY3Rpb24gdG9VdGNJc29EYXRlU3RyaW5nKHsgaXNvWWVhciwgaXNvTW9udGgsIGlzb0RheSB9KSB7XG4gICAgY29uc3QgeWVhclN0cmluZyA9IElTT1llYXJTdHJpbmcoaXNvWWVhcik7XG4gICAgY29uc3QgbW9udGhTdHJpbmcgPSBJU09EYXRlVGltZVBhcnRTdHJpbmcoaXNvTW9udGgpO1xuICAgIGNvbnN0IGRheVN0cmluZyA9IElTT0RhdGVUaW1lUGFydFN0cmluZyhpc29EYXkpO1xuICAgIHJldHVybiBgJHt5ZWFyU3RyaW5nfS0ke21vbnRoU3RyaW5nfS0ke2RheVN0cmluZ31UMDA6MDBaYDtcbn1cbmZ1bmN0aW9uIHNpbXBsZURhdGVEaWZmKG9uZSwgdHdvKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgeWVhcnM6IG9uZS55ZWFyIC0gdHdvLnllYXIsXG4gICAgICAgIG1vbnRoczogb25lLm1vbnRoIC0gdHdvLm1vbnRoLFxuICAgICAgICBkYXlzOiBvbmUuZGF5IC0gdHdvLmRheVxuICAgIH07XG59XG4vKipcbiAqIEltcGxlbWVudGF0aW9uIGhlbHBlciB0aGF0J3MgY29tbW9uIHRvIGFsbCBub24tSVNPIGNhbGVuZGFyc1xuICovXG5jbGFzcyBIZWxwZXJCYXNlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgLy8gVGhlIHNob3J0IGVyYSBmb3JtYXQgd29ya3MgZm9yIGFsbCBjYWxlbmRhcnMgZXhjZXB0IEphcGFuZXNlLCB3aGljaCB3aWxsXG4gICAgICAgIC8vIG92ZXJyaWRlLlxuICAgICAgICB0aGlzLmVyYUxlbmd0aCA9ICdzaG9ydCc7XG4gICAgICAgIC8vIEFsbCBidWlsdC1pbiBjYWxlbmRhcnMgZXhjZXB0IENoaW5lc2UvRGFuZ2kgYW5kIEhlYnJldyB1c2UgYW4gZXJhXG4gICAgICAgIHRoaXMuaGFzRXJhID0gdHJ1ZTtcbiAgICB9XG4gICAgZ2V0Rm9ybWF0dGVyKCkge1xuICAgICAgICAvLyBgbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQoKWAgaXMgYW1hemluZ2x5IHNsb3cgYW5kIGNoZXdzIHVwIFJBTS4gUGVyXG4gICAgICAgIC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTY1MjgjYzQsIHdlIGNhY2hlIG9uZVxuICAgICAgICAvLyBEYXRlVGltZUZvcm1hdCBpbnN0YW5jZSBwZXIgY2FsZW5kYXIuIENhY2hpbmcgaXMgbGF6eSBzbyB3ZSBvbmx5IHBheSBmb3JcbiAgICAgICAgLy8gY2FsZW5kYXJzIHRoYXQgYXJlIHVzZWQuIE5vdGUgdGhhdCB0aGUgbm9uSXNvSGVscGVyQmFzZSBvYmplY3QgaXMgc3ByZWFkXG4gICAgICAgIC8vIGludG8gZWFjaCBlYWNoIGNhbGVuZGFyJ3MgaW1wbGVtZW50YXRpb24gYmVmb3JlIGFueSBjYWNoZSBpcyBjcmVhdGVkLCBzb1xuICAgICAgICAvLyBlYWNoIGNhbGVuZGFyIGdldHMgaXRzIG93biBzZXBhcmF0ZSBjYWNoZWQgZm9ybWF0dGVyLlxuICAgICAgICBpZiAodHlwZW9mIHRoaXMuZm9ybWF0dGVyID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhpcy5mb3JtYXR0ZXIgPSBuZXcgSW50bERhdGVUaW1lRm9ybWF0JDIoYGVuLVVTLXUtY2EtJHt0aGlzLmlkfWAsIHtcbiAgICAgICAgICAgICAgICBkYXk6ICdudW1lcmljJyxcbiAgICAgICAgICAgICAgICBtb250aDogJ251bWVyaWMnLFxuICAgICAgICAgICAgICAgIHllYXI6ICdudW1lcmljJyxcbiAgICAgICAgICAgICAgICBlcmE6IHRoaXMuZXJhTGVuZ3RoLFxuICAgICAgICAgICAgICAgIHRpbWVab25lOiAnVVRDJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZm9ybWF0dGVyO1xuICAgIH1cbiAgICBpc29Ub0NhbGVuZGFyRGF0ZShpc29EYXRlLCBjYWNoZSkge1xuICAgICAgICBjb25zdCB7IHllYXI6IGlzb1llYXIsIG1vbnRoOiBpc29Nb250aCwgZGF5OiBpc29EYXkgfSA9IGlzb0RhdGU7XG4gICAgICAgIGNvbnN0IGtleSA9IEpTT04uc3RyaW5naWZ5KHsgZnVuYzogJ2lzb1RvQ2FsZW5kYXJEYXRlJywgaXNvWWVhciwgaXNvTW9udGgsIGlzb0RheSwgaWQ6IHRoaXMuaWQgfSk7XG4gICAgICAgIGNvbnN0IGNhY2hlZCA9IGNhY2hlLmdldChrZXkpO1xuICAgICAgICBpZiAoY2FjaGVkKVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZDtcbiAgICAgICAgY29uc3QgZGF0ZVRpbWVGb3JtYXQgPSB0aGlzLmdldEZvcm1hdHRlcigpO1xuICAgICAgICBsZXQgcGFydHMsIGlzb1N0cmluZztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlzb1N0cmluZyA9IHRvVXRjSXNvRGF0ZVN0cmluZyh7IGlzb1llYXIsIGlzb01vbnRoLCBpc29EYXkgfSk7XG4gICAgICAgICAgICBwYXJ0cyA9IGRhdGVUaW1lRm9ybWF0LmZvcm1hdFRvUGFydHMobmV3IERhdGUoaXNvU3RyaW5nKSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBJbnZhbGlkIElTTyBkYXRlOiAke0pTT04uc3RyaW5naWZ5KHsgaXNvWWVhciwgaXNvTW9udGgsIGlzb0RheSB9KX1gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICAgICAgZm9yIChsZXQgeyB0eXBlLCB2YWx1ZSB9IG9mIHBhcnRzKSB7XG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gJ3llYXInKVxuICAgICAgICAgICAgICAgIHJlc3VsdC5lcmFZZWFyID0gK3ZhbHVlO1xuICAgICAgICAgICAgLy8gVE9ETzogcmVtb3ZlIHRoaXMgdHlwZSBhbm5vdGF0aW9uIHdoZW4gYHJlbGF0ZWRZZWFyYCBnZXRzIGludG8gVFMgbGliIHR5cGVzXG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gJ3JlbGF0ZWRZZWFyJylcbiAgICAgICAgICAgICAgICByZXN1bHQuZXJhWWVhciA9ICt2YWx1ZTtcbiAgICAgICAgICAgIGlmICh0eXBlID09PSAnbW9udGgnKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWF0Y2hlcyA9IC9eKFswLTldKikoLio/KSQvLmV4ZWModmFsdWUpO1xuICAgICAgICAgICAgICAgIGlmICghbWF0Y2hlcyB8fCBtYXRjaGVzLmxlbmd0aCAhPSAzIHx8ICghbWF0Y2hlc1sxXSAmJiAhbWF0Y2hlc1syXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYFVuZXhwZWN0ZWQgbW9udGg6ICR7dmFsdWV9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBtb250aCBoYXMgbm8gbnVtZXJpYyBwYXJ0IChzaG91bGQgb25seSBzZWUgdGhpcyBmb3IgdGhlIEhlYnJld1xuICAgICAgICAgICAgICAgIC8vIGNhbGVuZGFyIHdpdGggbmV3ZXIgRkYgLyBDaHJvbWl1bSB2ZXJzaW9uczsgc2VlXG4gICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTc1MTgzMykgdGhlbiBzZXQgYVxuICAgICAgICAgICAgICAgIC8vIHBsYWNlaG9sZGVyIG1vbnRoIGluZGV4IG9mIGAxYCBhbmQgcmVseSBvbiB0aGUgZGVyaXZlZCBjbGFzcyB0b1xuICAgICAgICAgICAgICAgIC8vIGNhbGN1bGF0ZSB0aGUgY29ycmVjdCBtb250aCBpbmRleCBmcm9tIHRoZSBtb250aCBuYW1lIHN0b3JlZCBpblxuICAgICAgICAgICAgICAgIC8vIGBtb250aEV4dHJhYC5cbiAgICAgICAgICAgICAgICByZXN1bHQubW9udGggPSBtYXRjaGVzWzFdID8gK21hdGNoZXNbMV0gOiAxO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQubW9udGggPCAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBJbnZhbGlkIG1vbnRoICR7dmFsdWV9IGZyb20gJHtpc29TdHJpbmd9W3UtY2EtJHt0aGlzLmlkfV1gICtcbiAgICAgICAgICAgICAgICAgICAgICAgICcgKHByb2JhYmx5IGR1ZSB0byBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0xMDUyNyknKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5tb250aCA+IDEzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBJbnZhbGlkIG1vbnRoICR7dmFsdWV9IGZyb20gJHtpc29TdHJpbmd9W3UtY2EtJHt0aGlzLmlkfV1gICtcbiAgICAgICAgICAgICAgICAgICAgICAgICcgKHByb2JhYmx5IGR1ZSB0byBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0xMDUyOSknKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gVGhlIElDVSBmb3JtYXRzIGZvciB0aGUgSGVicmV3IGNhbGVuZGFyIG5vIGxvbmdlciBzdXBwb3J0IGEgbnVtZXJpY1xuICAgICAgICAgICAgICAgIC8vIG1vbnRoIGZvcm1hdC4gU28gd2UnbGwgcmVseSBvbiB0aGUgZGVyaXZlZCBjbGFzcyB0byBpbnRlcnByZXQgaXQuXG4gICAgICAgICAgICAgICAgLy8gYG1vbnRoRXh0cmFgIGlzIGFsc28gdXNlZCBvbiB0aGUgQ2hpbmVzZSBjYWxlbmRhciB0byBoYW5kbGUgYSBzdWZmaXhcbiAgICAgICAgICAgICAgICAvLyBcImJpc1wiIGluZGljYXRpbmcgYSBsZWFwIG1vbnRoLlxuICAgICAgICAgICAgICAgIGlmIChtYXRjaGVzWzJdKVxuICAgICAgICAgICAgICAgICAgICByZXN1bHQubW9udGhFeHRyYSA9IG1hdGNoZXNbMl07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gJ2RheScpXG4gICAgICAgICAgICAgICAgcmVzdWx0LmRheSA9ICt2YWx1ZTtcbiAgICAgICAgICAgIGlmICh0aGlzLmhhc0VyYSAmJiB0eXBlID09PSAnZXJhJyAmJiB2YWx1ZSAhPSBudWxsICYmIHZhbHVlICE9PSAnJykge1xuICAgICAgICAgICAgICAgIC8vIFRoZSBjb252ZW50aW9uIGZvciBUZW1wb3JhbCBlcmEgdmFsdWVzIGlzIGxvd2VyY2FzZSwgc28gZm9sbG93aW5nXG4gICAgICAgICAgICAgICAgLy8gdGhhdCBjb252ZW50aW9uIGluIHRoaXMgcHJvdG90eXBlLiBQdW5jdHVhdGlvbiBpcyByZW1vdmVkLCBhY2NlbnRlZFxuICAgICAgICAgICAgICAgIC8vIGxldHRlcnMgYXJlIG5vcm1hbGl6ZWQsIGFuZCBzcGFjZXMgYXJlIHJlcGxhY2VkIHdpdGggZGFzaGVzLlxuICAgICAgICAgICAgICAgIC8vIEUuZy46IFwiRVJBMFwiID0+IFwiZXJhMFwiLCBcIkJlZm9yZSBSLk8uQy5cIiA9PiBcImJlZm9yZS1yb2NcIiwgXCJFbuKAmcWNXCIgPT4gXCJlbm9cIlxuICAgICAgICAgICAgICAgIC8vIFRoZSBjYWxsIHRvIG5vcm1hbGl6ZSgpIGFuZCB0aGUgcmVwbGFjZW1lbnQgcmVnZXggZGVhbHMgd2l0aCBlcmFcbiAgICAgICAgICAgICAgICAvLyBuYW1lcyB0aGF0IGNvbnRhaW4gbm9uLUFTQ0lJIGNoYXJhY3RlcnMgbGlrZSBKYXBhbmVzZSBlcmFzLiBBbHNvXG4gICAgICAgICAgICAgICAgLy8gaWdub3JlIGV4dHJhIGNvbnRlbnQgaW4gcGFyZW50aGVzZXMgbGlrZSBKUE4gZXJhIGRhdGUgcmFuZ2VzLlxuICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuc3BsaXQoJyAoJylbMF07XG4gICAgICAgICAgICAgICAgcmVzdWx0LmVyYSA9IHZhbHVlXG4gICAgICAgICAgICAgICAgICAgIC5ub3JtYWxpemUoJ05GRCcpXG4gICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9bXi0wLTkgXFxwe0x9XS9ndSwgJycpXG4gICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKCcgJywgJy0nKVxuICAgICAgICAgICAgICAgICAgICAudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0LmVyYVllYXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gTm9kZSAxMiBoYXMgb3V0ZGF0ZWQgSUNVIGRhdGEgdGhhdCBsYWNrcyB0aGUgYHJlbGF0ZWRZZWFyYCBmaWVsZCBpbiB0aGVcbiAgICAgICAgICAgIC8vIG91dHB1dCBvZiBJbnRsLkRhdGVUaW1lRm9ybWF0LmZvcm1hdFRvUGFydHMuXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgSW50bC5EYXRlVGltZUZvcm1hdC5mb3JtYXRUb1BhcnRzIGxhY2tzIHJlbGF0ZWRZZWFyIGluICR7dGhpcy5pZH0gY2FsZW5kYXIuIFRyeSBOb2RlIDE0KyBvciBtb2Rlcm4gYnJvd3NlcnMuYCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVHJhbnNsYXRlIGVyYXMgdGhhdCBtYXkgYmUgaGFuZGxlZCBkaWZmZXJlbnRseSBieSBUZW1wb3JhbCB2cy4gYnkgSW50bFxuICAgICAgICAvLyAoZS5nLiBKYXBhbmVzZSBwcmUtTWVpamkgZXJhcykuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC10ZW1wb3JhbC9pc3N1ZXMvNTI2LlxuICAgICAgICBpZiAodGhpcy5yZXZpc2VJbnRsRXJhKSB7XG4gICAgICAgICAgICBjb25zdCB7IGVyYSwgZXJhWWVhciB9ID0gdGhpcy5yZXZpc2VJbnRsRXJhKHJlc3VsdCwgaXNvRGF0ZSk7XG4gICAgICAgICAgICByZXN1bHQuZXJhID0gZXJhO1xuICAgICAgICAgICAgcmVzdWx0LmVyYVllYXIgPSBlcmFZZWFyO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNoZWNrSWN1QnVncylcbiAgICAgICAgICAgIHRoaXMuY2hlY2tJY3VCdWdzKGlzb0RhdGUpO1xuICAgICAgICBjb25zdCBjYWxlbmRhckRhdGUgPSB0aGlzLmFkanVzdENhbGVuZGFyRGF0ZShyZXN1bHQsIGNhY2hlLCAnY29uc3RyYWluJywgdHJ1ZSk7XG4gICAgICAgIGlmIChjYWxlbmRhckRhdGUueWVhciA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYE1pc3NpbmcgeWVhciBjb252ZXJ0aW5nICR7SlNPTi5zdHJpbmdpZnkoaXNvRGF0ZSl9YCk7XG4gICAgICAgIGlmIChjYWxlbmRhckRhdGUubW9udGggPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBNaXNzaW5nIG1vbnRoIGNvbnZlcnRpbmcgJHtKU09OLnN0cmluZ2lmeShpc29EYXRlKX1gKTtcbiAgICAgICAgaWYgKGNhbGVuZGFyRGF0ZS5kYXkgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBNaXNzaW5nIGRheSBjb252ZXJ0aW5nICR7SlNPTi5zdHJpbmdpZnkoaXNvRGF0ZSl9YCk7XG4gICAgICAgIGNhY2hlLnNldChrZXksIGNhbGVuZGFyRGF0ZSk7XG4gICAgICAgIC8vIEFsc28gY2FjaGUgdGhlIHJldmVyc2UgbWFwcGluZ1xuICAgICAgICBbJ2NvbnN0cmFpbicsICdyZWplY3QnXS5mb3JFYWNoKChvdmVyZmxvdykgPT4ge1xuICAgICAgICAgICAgY29uc3Qga2V5UmV2ZXJzZSA9IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICBmdW5jOiAnY2FsZW5kYXJUb0lzb0RhdGUnLFxuICAgICAgICAgICAgICAgIHllYXI6IGNhbGVuZGFyRGF0ZS55ZWFyLFxuICAgICAgICAgICAgICAgIG1vbnRoOiBjYWxlbmRhckRhdGUubW9udGgsXG4gICAgICAgICAgICAgICAgZGF5OiBjYWxlbmRhckRhdGUuZGF5LFxuICAgICAgICAgICAgICAgIG92ZXJmbG93LFxuICAgICAgICAgICAgICAgIGlkOiB0aGlzLmlkXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNhY2hlLnNldChrZXlSZXZlcnNlLCBpc29EYXRlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjYWxlbmRhckRhdGU7XG4gICAgfVxuICAgIHZhbGlkYXRlQ2FsZW5kYXJEYXRlKGNhbGVuZGFyRGF0ZSkge1xuICAgICAgICBjb25zdCB7IGVyYSwgbW9udGgsIHllYXIsIGRheSwgZXJhWWVhciwgbW9udGhDb2RlLCBtb250aEV4dHJhIH0gPSBjYWxlbmRhckRhdGU7XG4gICAgICAgIC8vIFdoZW4gdGhlcmUncyBhIHN1ZmZpeCAoZS5nLiBcIjViaXNcIiBmb3IgYSBsZWFwIG1vbnRoIGluIENoaW5lc2UgY2FsZW5kYXIpXG4gICAgICAgIC8vIHRoZSBkZXJpdmVkIGNsYXNzIG11c3QgZGVhbCB3aXRoIGl0LlxuICAgICAgICBpZiAobW9udGhFeHRyYSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1VuZXhwZWN0ZWQgYG1vbnRoRXh0cmFgIHZhbHVlJyk7XG4gICAgICAgIGlmICh5ZWFyID09PSB1bmRlZmluZWQgJiYgZXJhWWVhciA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigneWVhciBvciBlcmFZZWFyIGlzIHJlcXVpcmVkJyk7XG4gICAgICAgIGlmIChtb250aCA9PT0gdW5kZWZpbmVkICYmIG1vbnRoQ29kZSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbW9udGggb3IgbW9udGhDb2RlIGlzIHJlcXVpcmVkJyk7XG4gICAgICAgIGlmIChkYXkgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdNaXNzaW5nIGRheScpO1xuICAgICAgICBpZiAobW9udGhDb2RlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbW9udGhDb2RlICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBtb250aENvZGUgbXVzdCBiZSBhIHN0cmluZywgbm90ICR7dHlwZW9mIG1vbnRoQ29kZX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghL15NKFswMV0/XFxkKShMPykkLy50ZXN0KG1vbnRoQ29kZSkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYEludmFsaWQgbW9udGhDb2RlOiAke21vbnRoQ29kZX1gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jb25zdGFudEVyYSkge1xuICAgICAgICAgICAgaWYgKGVyYSAhPT0gdW5kZWZpbmVkICYmIGVyYSAhPT0gdGhpcy5jb25zdGFudEVyYSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBlcmEgbXVzdCBiZSAke3RoaXMuY29uc3RhbnRFcmF9LCBub3QgJHtlcmF9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZXJhWWVhciAhPT0gdW5kZWZpbmVkICYmIHllYXIgIT09IHVuZGVmaW5lZCAmJiBlcmFZZWFyICE9PSB5ZWFyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYGVyYVllYXIgJHtlcmFZZWFyfSBkb2VzIG5vdCBtYXRjaCB5ZWFyICR7eWVhcn1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBbGxvd3MgZGVyaXZlZCBjYWxlbmRhcnMgdG8gYWRkIGFkZGl0aW9uYWwgZmllbGRzIGFuZC9vciB0byBtYWtlXG4gICAgICogYWRqdXN0bWVudHMgZS5nLiB0byBzZXQgdGhlIGVyYSBiYXNlZCBvbiB0aGUgZGF0ZSBvciB0byByZXZpc2UgdGhlIG1vbnRoXG4gICAgICogbnVtYmVyIGluIGx1bmlzb2xhciBjYWxlbmRhcnMgcGVyXG4gICAgICogaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtdGVtcG9yYWwvaXNzdWVzLzEyMDMuXG4gICAgICpcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBmaWxscyBpbiBtaXNzaW5nIHZhbHVlcyBieSBhc3N1bWluZyB0aGUgc2ltcGxlc3RcbiAgICAgKiBwb3NzaWJsZSBjYWxlbmRhcjpcbiAgICAgKiAtIG5vIGVyYXMgb3IgYSBjb25zdGFudCBlcmEgZGVmaW5lZCBpbiBgLmNvbnN0YW50RXJhYFxuICAgICAqIC0gbm9uLWx1bmlzb2xhciBjYWxlbmRhciAobm8gbGVhcCBtb250aHMpXG4gICAgICogKi9cbiAgICBhZGp1c3RDYWxlbmRhckRhdGUoY2FsZW5kYXJEYXRlUGFyYW0sIGNhY2hlID0gdW5kZWZpbmVkLCBvdmVyZmxvdyA9ICdjb25zdHJhaW4nLCBcbiAgICAvLyBUaGlzIHBhcmFtIGlzIG9ubHkgdXNlZCBieSBkZXJpdmVkIGNsYXNzZXNcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgZnJvbUxlZ2FjeURhdGUgPSBmYWxzZSkge1xuICAgICAgICBpZiAodGhpcy5jYWxlbmRhclR5cGUgPT09ICdsdW5pc29sYXInKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ092ZXJyaWRlIHJlcXVpcmVkIGZvciBsdW5pc29sYXIgY2FsZW5kYXJzJyk7XG4gICAgICAgIGxldCBjYWxlbmRhckRhdGUgPSBjYWxlbmRhckRhdGVQYXJhbTtcbiAgICAgICAgdGhpcy52YWxpZGF0ZUNhbGVuZGFyRGF0ZShjYWxlbmRhckRhdGUpO1xuICAgICAgICAvLyBGb3IgY2FsZW5kYXJzIHRoYXQgYWx3YXlzIHVzZSB0aGUgc2FtZSBlcmEsIHNldCBpdCBoZXJlIHNvIHRoYXQgZGVyaXZlZFxuICAgICAgICAvLyBjYWxlbmRhcnMgd29uJ3QgbmVlZCB0byBpbXBsZW1lbnQgdGhpcyBtZXRob2Qgc2ltcGx5IHRvIHNldCB0aGUgZXJhLlxuICAgICAgICBpZiAodGhpcy5jb25zdGFudEVyYSkge1xuICAgICAgICAgICAgLy8geWVhciBhbmQgZXJhWWVhciBhbHdheXMgbWF0Y2ggd2hlbiB0aGVyZSdzIG9ubHkgb25lIHBvc3NpYmxlIGVyYVxuICAgICAgICAgICAgY29uc3QgeyB5ZWFyLCBlcmFZZWFyIH0gPSBjYWxlbmRhckRhdGU7XG4gICAgICAgICAgICBjYWxlbmRhckRhdGUgPSB7XG4gICAgICAgICAgICAgICAgLi4uY2FsZW5kYXJEYXRlLFxuICAgICAgICAgICAgICAgIGVyYTogdGhpcy5jb25zdGFudEVyYSxcbiAgICAgICAgICAgICAgICB5ZWFyOiB5ZWFyICE9PSB1bmRlZmluZWQgPyB5ZWFyIDogZXJhWWVhcixcbiAgICAgICAgICAgICAgICBlcmFZZWFyOiBlcmFZZWFyICE9PSB1bmRlZmluZWQgPyBlcmFZZWFyIDogeWVhclxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsYXJnZXN0TW9udGggPSB0aGlzLm1vbnRoc0luWWVhcihjYWxlbmRhckRhdGUsIGNhY2hlKTtcbiAgICAgICAgbGV0IHsgbW9udGgsIG1vbnRoQ29kZSB9ID0gY2FsZW5kYXJEYXRlO1xuICAgICAgICAoeyBtb250aCwgbW9udGhDb2RlIH0gPSByZXNvbHZlTm9uTHVuaXNvbGFyTW9udGgoY2FsZW5kYXJEYXRlLCBvdmVyZmxvdywgbGFyZ2VzdE1vbnRoKSk7XG4gICAgICAgIHJldHVybiB7IC4uLmNhbGVuZGFyRGF0ZSwgbW9udGgsIG1vbnRoQ29kZSB9O1xuICAgIH1cbiAgICByZWd1bGF0ZU1vbnRoRGF5TmFpdmUoY2FsZW5kYXJEYXRlLCBvdmVyZmxvdywgY2FjaGUpIHtcbiAgICAgICAgY29uc3QgbGFyZ2VzdE1vbnRoID0gdGhpcy5tb250aHNJblllYXIoY2FsZW5kYXJEYXRlLCBjYWNoZSk7XG4gICAgICAgIGxldCB7IG1vbnRoLCBkYXkgfSA9IGNhbGVuZGFyRGF0ZTtcbiAgICAgICAgaWYgKG92ZXJmbG93ID09PSAncmVqZWN0Jykge1xuICAgICAgICAgICAgUmVqZWN0VG9SYW5nZShtb250aCwgMSwgbGFyZ2VzdE1vbnRoKTtcbiAgICAgICAgICAgIFJlamVjdFRvUmFuZ2UoZGF5LCAxLCB0aGlzLm1heGltdW1Nb250aExlbmd0aChjYWxlbmRhckRhdGUpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1vbnRoID0gQ29uc3RyYWluVG9SYW5nZShtb250aCwgMSwgbGFyZ2VzdE1vbnRoKTtcbiAgICAgICAgICAgIGRheSA9IENvbnN0cmFpblRvUmFuZ2UoZGF5LCAxLCB0aGlzLm1heGltdW1Nb250aExlbmd0aCh7IC4uLmNhbGVuZGFyRGF0ZSwgbW9udGggfSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IC4uLmNhbGVuZGFyRGF0ZSwgbW9udGgsIGRheSB9O1xuICAgIH1cbiAgICBjYWxlbmRhclRvSXNvRGF0ZShkYXRlUGFyYW0sIG92ZXJmbG93ID0gJ2NvbnN0cmFpbicsIGNhY2hlKSB7XG4gICAgICAgIGNvbnN0IG9yaWdpbmFsRGF0ZSA9IGRhdGVQYXJhbTtcbiAgICAgICAgLy8gRmlyc3QsIG5vcm1hbGl6ZSB0aGUgY2FsZW5kYXIgZGF0ZSB0byBlbnN1cmUgdGhhdCAoeWVhciwgbW9udGgsIGRheSlcbiAgICAgICAgLy8gYXJlIGFsbCBwcmVzZW50LCBjb252ZXJ0aW5nIG1vbnRoQ29kZSBhbmQgZXJhWWVhciBpZiBuZWVkZWQuXG4gICAgICAgIGxldCBkYXRlID0gdGhpcy5hZGp1c3RDYWxlbmRhckRhdGUoZGF0ZVBhcmFtLCBjYWNoZSwgb3ZlcmZsb3csIGZhbHNlKTtcbiAgICAgICAgLy8gRml4IG9idmlvdXNseSBvdXQtb2YtYm91bmRzIHZhbHVlcy4gVmFsdWVzIHRoYXQgYXJlIHZhbGlkIGdlbmVyYWxseSwgYnV0XG4gICAgICAgIC8vIG5vdCBpbiB0aGlzIHBhcnRpY3VsYXIgeWVhciwgbWF5IG5vdCBiZSBjYXVnaHQgaGVyZSBmb3Igc29tZSBjYWxlbmRhcnMuXG4gICAgICAgIC8vIElmIHNvLCB0aGVzZSB3aWxsIGJlIGhhbmRsZWQgbG93ZXIgYmVsb3cuXG4gICAgICAgIGRhdGUgPSB0aGlzLnJlZ3VsYXRlTW9udGhEYXlOYWl2ZShkYXRlLCBvdmVyZmxvdywgY2FjaGUpO1xuICAgICAgICBjb25zdCB7IHllYXIsIG1vbnRoLCBkYXkgfSA9IGRhdGU7XG4gICAgICAgIGNvbnN0IGtleSA9IEpTT04uc3RyaW5naWZ5KHsgZnVuYzogJ2NhbGVuZGFyVG9Jc29EYXRlJywgeWVhciwgbW9udGgsIGRheSwgb3ZlcmZsb3csIGlkOiB0aGlzLmlkIH0pO1xuICAgICAgICBsZXQgY2FjaGVkID0gY2FjaGUuZ2V0KGtleSk7XG4gICAgICAgIGlmIChjYWNoZWQpXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkO1xuICAgICAgICAvLyBJZiBZTUQgYXJlIHByZXNlbnQgaW4gdGhlIGlucHV0IGJ1dCB0aGUgaW5wdXQgaGFzIGJlZW4gY29uc3RyYWluZWRcbiAgICAgICAgLy8gYWxyZWFkeSwgdGhlbiBjYWNoZSBib3RoIHRoZSBvcmlnaW5hbCB2YWx1ZSBhbmQgdGhlIGNvbnN0cmFpbmVkIHZhbHVlLlxuICAgICAgICBsZXQga2V5T3JpZ2luYWw7XG4gICAgICAgIGlmIChvcmlnaW5hbERhdGUueWVhciAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICBvcmlnaW5hbERhdGUubW9udGggIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgb3JpZ2luYWxEYXRlLmRheSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob3JpZ2luYWxEYXRlLnllYXIgIT09IGRhdGUueWVhciB8fCBvcmlnaW5hbERhdGUubW9udGggIT09IGRhdGUubW9udGggfHwgb3JpZ2luYWxEYXRlLmRheSAhPT0gZGF0ZS5kYXkpKSB7XG4gICAgICAgICAgICBrZXlPcmlnaW5hbCA9IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICBmdW5jOiAnY2FsZW5kYXJUb0lzb0RhdGUnLFxuICAgICAgICAgICAgICAgIHllYXI6IG9yaWdpbmFsRGF0ZS55ZWFyLFxuICAgICAgICAgICAgICAgIG1vbnRoOiBvcmlnaW5hbERhdGUubW9udGgsXG4gICAgICAgICAgICAgICAgZGF5OiBvcmlnaW5hbERhdGUuZGF5LFxuICAgICAgICAgICAgICAgIG92ZXJmbG93LFxuICAgICAgICAgICAgICAgIGlkOiB0aGlzLmlkXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNhY2hlZCA9IGNhY2hlLmdldChrZXlPcmlnaW5hbCk7XG4gICAgICAgICAgICBpZiAoY2FjaGVkKVxuICAgICAgICAgICAgICAgIHJldHVybiBjYWNoZWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRmlyc3QsIHRyeSB0byByb3VnaGx5IGd1ZXNzIHRoZSByZXN1bHRcbiAgICAgICAgbGV0IGlzb0VzdGltYXRlID0gdGhpcy5lc3RpbWF0ZUlzb0RhdGUoeyB5ZWFyLCBtb250aCwgZGF5IH0pO1xuICAgICAgICBjb25zdCBjYWxjdWxhdGVTYW1lTW9udGhSZXN1bHQgPSAoZGlmZkRheXMpID0+IHtcbiAgICAgICAgICAgIC8vIElmIHRoZSBlc3RpbWF0ZSBpcyBpbiB0aGUgc2FtZSB5ZWFyICYgbW9udGggYXMgdGhlIHRhcmdldCwgdGhlbiB3ZSBjYW5cbiAgICAgICAgICAgIC8vIGNhbGN1bGF0ZSB0aGUgcmVzdWx0IGV4YWN0bHkgYW5kIHNob3J0LWNpcmN1aXQgYW55IGFkZGl0aW9uYWwgbG9naWMuXG4gICAgICAgICAgICAvLyBUaGlzIG9wdGltaXphdGlvbiBhc3N1bWVzIHRoYXQgbW9udGhzIGFyZSBjb250aW51b3VzLiBJdCB3b3VsZCBicmVhayBpZlxuICAgICAgICAgICAgLy8gYSBjYWxlbmRhciBza2lwcGVkIGRheXMsIGxpa2UgdGhlIEp1bGlhbi0+R3JlZ29yaWFuIHN3aXRjaG92ZXIuIEJ1dCB0aGVcbiAgICAgICAgICAgIC8vIG9ubHkgSUNVIGNhbGVuZGFycyB0aGF0IGN1cnJlbnRseSBza2lwIGRheXMgKGphcGFuZXNlL3JvYy9idWRkaGlzdCkgaXNcbiAgICAgICAgICAgIC8vIGEgYnVnIChodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0xMTczMTU4KVxuICAgICAgICAgICAgLy8gdGhhdCdzIGN1cnJlbnRseSBkZXRlY3RlZCBieSBgY2hlY2tJY3VCdWdzKClgIHdoaWNoIHdpbGwgdGhyb3cuIFNvXG4gICAgICAgICAgICAvLyB0aGlzIG9wdGltaXphdGlvbiBzaG91bGQgYmUgc2FmZSBmb3IgYWxsIElDVSBjYWxlbmRhcnMuXG4gICAgICAgICAgICBsZXQgdGVzdElzb0VzdGltYXRlID0gdGhpcy5hZGREYXlzSXNvKGlzb0VzdGltYXRlLCBkaWZmRGF5cyk7XG4gICAgICAgICAgICBpZiAoZGF0ZS5kYXkgPiB0aGlzLm1pbmltdW1Nb250aExlbmd0aChkYXRlKSkge1xuICAgICAgICAgICAgICAgIC8vIFRoZXJlJ3MgYSBjaGFuY2UgdGhhdCB0aGUgY2FsZW5kYXIgZGF0ZSBpcyBvdXQgb2YgcmFuZ2UuIFRocm93IG9yXG4gICAgICAgICAgICAgICAgLy8gY29uc3RyYWluIGlmIHNvLlxuICAgICAgICAgICAgICAgIGxldCB0ZXN0Q2FsZW5kYXJEYXRlID0gdGhpcy5pc29Ub0NhbGVuZGFyRGF0ZSh0ZXN0SXNvRXN0aW1hdGUsIGNhY2hlKTtcbiAgICAgICAgICAgICAgICB3aGlsZSAodGVzdENhbGVuZGFyRGF0ZS5tb250aCAhPT0gbW9udGggfHwgdGVzdENhbGVuZGFyRGF0ZS55ZWFyICE9PSB5ZWFyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvdmVyZmxvdyA9PT0gJ3JlamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBkYXkgJHtkYXl9IGRvZXMgbm90IGV4aXN0IGluIG1vbnRoICR7bW9udGh9IG9mIHllYXIgJHt5ZWFyfWApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIEJhY2sgdXAgYSBkYXkgYXQgYSB0aW1lIHVudGlsIHdlJ3JlIG5vdCBoYW5naW5nIG92ZXIgdGhlIG1vbnRoIGVuZFxuICAgICAgICAgICAgICAgICAgICB0ZXN0SXNvRXN0aW1hdGUgPSB0aGlzLmFkZERheXNJc28odGVzdElzb0VzdGltYXRlLCAtMSk7XG4gICAgICAgICAgICAgICAgICAgIHRlc3RDYWxlbmRhckRhdGUgPSB0aGlzLmlzb1RvQ2FsZW5kYXJEYXRlKHRlc3RJc29Fc3RpbWF0ZSwgY2FjaGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0ZXN0SXNvRXN0aW1hdGU7XG4gICAgICAgIH07XG4gICAgICAgIGxldCBzaWduID0gMDtcbiAgICAgICAgbGV0IHJvdW5kdHJpcEVzdGltYXRlID0gdGhpcy5pc29Ub0NhbGVuZGFyRGF0ZShpc29Fc3RpbWF0ZSwgY2FjaGUpO1xuICAgICAgICBsZXQgZGlmZiA9IHNpbXBsZURhdGVEaWZmKGRhdGUsIHJvdW5kdHJpcEVzdGltYXRlKTtcbiAgICAgICAgaWYgKGRpZmYueWVhcnMgIT09IDAgfHwgZGlmZi5tb250aHMgIT09IDAgfHwgZGlmZi5kYXlzICE9PSAwKSB7XG4gICAgICAgICAgICBjb25zdCBkaWZmVG90YWxEYXlzRXN0aW1hdGUgPSBkaWZmLnllYXJzICogMzY1ICsgZGlmZi5tb250aHMgKiAzMCArIGRpZmYuZGF5cztcbiAgICAgICAgICAgIGlzb0VzdGltYXRlID0gdGhpcy5hZGREYXlzSXNvKGlzb0VzdGltYXRlLCBkaWZmVG90YWxEYXlzRXN0aW1hdGUpO1xuICAgICAgICAgICAgcm91bmR0cmlwRXN0aW1hdGUgPSB0aGlzLmlzb1RvQ2FsZW5kYXJEYXRlKGlzb0VzdGltYXRlLCBjYWNoZSk7XG4gICAgICAgICAgICBkaWZmID0gc2ltcGxlRGF0ZURpZmYoZGF0ZSwgcm91bmR0cmlwRXN0aW1hdGUpO1xuICAgICAgICAgICAgaWYgKGRpZmYueWVhcnMgPT09IDAgJiYgZGlmZi5tb250aHMgPT09IDApIHtcbiAgICAgICAgICAgICAgICBpc29Fc3RpbWF0ZSA9IGNhbGN1bGF0ZVNhbWVNb250aFJlc3VsdChkaWZmLmRheXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc2lnbiA9IHRoaXMuY29tcGFyZUNhbGVuZGFyRGF0ZXMoZGF0ZSwgcm91bmR0cmlwRXN0aW1hdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoZSBpbml0aWFsIGd1ZXNzIGlzIG5vdCBpbiB0aGUgc2FtZSBtb250aCwgdGhlbiB0aGVuIGJpc2VjdCB0aGVcbiAgICAgICAgLy8gZGlzdGFuY2UgdG8gdGhlIHRhcmdldCwgc3RhcnRpbmcgd2l0aCA4IGRheXMgcGVyIHN0ZXAuXG4gICAgICAgIGxldCBpbmNyZW1lbnQgPSA4O1xuICAgICAgICBsZXQgbWF5YmVDb25zdHJhaW5lZCA9IGZhbHNlO1xuICAgICAgICB3aGlsZSAoc2lnbikge1xuICAgICAgICAgICAgaXNvRXN0aW1hdGUgPSB0aGlzLmFkZERheXNJc28oaXNvRXN0aW1hdGUsIHNpZ24gKiBpbmNyZW1lbnQpO1xuICAgICAgICAgICAgY29uc3Qgb2xkUm91bmR0cmlwRXN0aW1hdGUgPSByb3VuZHRyaXBFc3RpbWF0ZTtcbiAgICAgICAgICAgIHJvdW5kdHJpcEVzdGltYXRlID0gdGhpcy5pc29Ub0NhbGVuZGFyRGF0ZShpc29Fc3RpbWF0ZSwgY2FjaGUpO1xuICAgICAgICAgICAgY29uc3Qgb2xkU2lnbiA9IHNpZ247XG4gICAgICAgICAgICBzaWduID0gdGhpcy5jb21wYXJlQ2FsZW5kYXJEYXRlcyhkYXRlLCByb3VuZHRyaXBFc3RpbWF0ZSk7XG4gICAgICAgICAgICBpZiAoc2lnbikge1xuICAgICAgICAgICAgICAgIGRpZmYgPSBzaW1wbGVEYXRlRGlmZihkYXRlLCByb3VuZHRyaXBFc3RpbWF0ZSk7XG4gICAgICAgICAgICAgICAgaWYgKGRpZmYueWVhcnMgPT09IDAgJiYgZGlmZi5tb250aHMgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgaXNvRXN0aW1hdGUgPSBjYWxjdWxhdGVTYW1lTW9udGhSZXN1bHQoZGlmZi5kYXlzKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2lnbmFsIHRoZSBsb29wIGNvbmRpdGlvbiB0aGF0IHRoZXJlJ3MgYSBtYXRjaC5cbiAgICAgICAgICAgICAgICAgICAgc2lnbiA9IDA7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBjYWxlbmRhciBkYXkgaXMgbGFyZ2VyIHRoYW4gdGhlIG1pbmltYWwgbGVuZ3RoIGZvciB0aGlzXG4gICAgICAgICAgICAgICAgICAgIC8vIG1vbnRoLCB0aGVuIGl0IG1pZ2h0IGJlIGxhcmdlciB0aGFuIHRoZSBhY3R1YWwgbGVuZ3RoIG9mIHRoZSBtb250aC5cbiAgICAgICAgICAgICAgICAgICAgLy8gU28gd2Ugd29uJ3QgY2FjaGUgaXQgYXMgdGhlIGNvcnJlY3QgY2FsZW5kYXIgZGF0ZSBmb3IgdGhpcyBJU09cbiAgICAgICAgICAgICAgICAgICAgLy8gZGF0ZS5cbiAgICAgICAgICAgICAgICAgICAgbWF5YmVDb25zdHJhaW5lZCA9IGRhdGUuZGF5ID4gdGhpcy5taW5pbXVtTW9udGhMZW5ndGgoZGF0ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG9sZFNpZ24gJiYgc2lnbiAhPT0gb2xkU2lnbikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5jcmVtZW50ID4gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIGVzdGltYXRlIG92ZXJzaG90IHRoZSB0YXJnZXQsIHRyeSBhZ2FpbiB3aXRoIGEgc21hbGxlciBpbmNyZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGluIHRoZSByZXZlcnNlIGRpcmVjdGlvbi5cbiAgICAgICAgICAgICAgICAgICAgICAgIGluY3JlbWVudCAvPSAyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSW5jcmVtZW50IGlzIDEsIGFuZCBuZWl0aGVyIHRoZSBwcmV2aW91cyBlc3RpbWF0ZSBub3IgdGhlIG5ld1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXN0aW1hdGUgaXMgY29ycmVjdC4gVGhlIG9ubHkgd2F5IHRoYXQgY2FuIGhhcHBlbiBpcyBpZiB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9yaWdpbmFsIGRhdGUgd2FzIGFuIGludmFsaWQgdmFsdWUgdGhhdCB3aWxsIGJlIGNvbnN0cmFpbmVkIG9yXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyByZWplY3RlZCBoZXJlLlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG92ZXJmbG93ID09PSAncmVqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBDYW4ndCBmaW5kIElTTyBkYXRlIGZyb20gY2FsZW5kYXIgZGF0ZTogJHtKU09OLnN0cmluZ2lmeSh7IC4uLm9yaWdpbmFsRGF0ZSB9KX1gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRvIGNvbnN0cmFpbiwgcGljayB0aGUgZWFybGllc3QgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBvcmRlciA9IHRoaXMuY29tcGFyZUNhbGVuZGFyRGF0ZXMocm91bmR0cmlwRXN0aW1hdGUsIG9sZFJvdW5kdHJpcEVzdGltYXRlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBjdXJyZW50IHZhbHVlIGlzIGxhcmdlciwgdGhlbiBiYWNrIHVwIHRvIHRoZSBwcmV2aW91cyB2YWx1ZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob3JkZXIgPiAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc29Fc3RpbWF0ZSA9IHRoaXMuYWRkRGF5c0lzbyhpc29Fc3RpbWF0ZSwgLTEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1heWJlQ29uc3RyYWluZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpZ24gPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhY2hlLnNldChrZXksIGlzb0VzdGltYXRlKTtcbiAgICAgICAgaWYgKGtleU9yaWdpbmFsKVxuICAgICAgICAgICAgY2FjaGUuc2V0KGtleU9yaWdpbmFsLCBpc29Fc3RpbWF0ZSk7XG4gICAgICAgIGlmIChkYXRlLnllYXIgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgZGF0ZS5tb250aCA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICBkYXRlLmRheSA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICBkYXRlLm1vbnRoQ29kZSA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICAodGhpcy5oYXNFcmEgJiYgKGRhdGUuZXJhID09PSB1bmRlZmluZWQgfHwgZGF0ZS5lcmFZZWFyID09PSB1bmRlZmluZWQpKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1VuZXhwZWN0ZWQgbWlzc2luZyBwcm9wZXJ0eScpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghbWF5YmVDb25zdHJhaW5lZCkge1xuICAgICAgICAgICAgLy8gQWxzbyBjYWNoZSB0aGUgcmV2ZXJzZSBtYXBwaW5nXG4gICAgICAgICAgICBjb25zdCBrZXlSZXZlcnNlID0gSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgIGZ1bmM6ICdpc29Ub0NhbGVuZGFyRGF0ZScsXG4gICAgICAgICAgICAgICAgaXNvWWVhcjogaXNvRXN0aW1hdGUueWVhcixcbiAgICAgICAgICAgICAgICBpc29Nb250aDogaXNvRXN0aW1hdGUubW9udGgsXG4gICAgICAgICAgICAgICAgaXNvRGF5OiBpc29Fc3RpbWF0ZS5kYXksXG4gICAgICAgICAgICAgICAgaWQ6IHRoaXMuaWRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY2FjaGUuc2V0KGtleVJldmVyc2UsIGRhdGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpc29Fc3RpbWF0ZTtcbiAgICB9XG4gICAgdGVtcG9yYWxUb0NhbGVuZGFyRGF0ZShkYXRlLCBjYWNoZSkge1xuICAgICAgICBjb25zdCBpc29EYXRlID0geyB5ZWFyOiBHZXRTbG90KGRhdGUsIElTT19ZRUFSKSwgbW9udGg6IEdldFNsb3QoZGF0ZSwgSVNPX01PTlRIKSwgZGF5OiBHZXRTbG90KGRhdGUsIElTT19EQVkpIH07XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuaXNvVG9DYWxlbmRhckRhdGUoaXNvRGF0ZSwgY2FjaGUpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBjb21wYXJlQ2FsZW5kYXJEYXRlcyhkYXRlMVBhcmFtLCBkYXRlMlBhcmFtKSB7XG4gICAgICAgIC8vIGBkYXRlMWAgYW5kIGBkYXRlMmAgYXJlIGFscmVhZHkgcmVjb3Jkcy4gVGhlIGNhbGxzIGJlbG93IHNpbXBseSB2YWxpZGF0ZVxuICAgICAgICAvLyB0aGF0IGFsbCB0aHJlZSByZXF1aXJlZCBmaWVsZHMgYXJlIHByZXNlbnQuXG4gICAgICAgIGNvbnN0IGRhdGUxID0gUHJlcGFyZVRlbXBvcmFsRmllbGRzKGRhdGUxUGFyYW0sIFtbJ2RheSddLCBbJ21vbnRoJ10sIFsneWVhciddXSk7XG4gICAgICAgIGNvbnN0IGRhdGUyID0gUHJlcGFyZVRlbXBvcmFsRmllbGRzKGRhdGUyUGFyYW0sIFtbJ2RheSddLCBbJ21vbnRoJ10sIFsneWVhciddXSk7XG4gICAgICAgIGlmIChkYXRlMS55ZWFyICE9PSBkYXRlMi55ZWFyKVxuICAgICAgICAgICAgcmV0dXJuIENvbXBhcmlzb25SZXN1bHQoZGF0ZTEueWVhciAtIGRhdGUyLnllYXIpO1xuICAgICAgICBpZiAoZGF0ZTEubW9udGggIT09IGRhdGUyLm1vbnRoKVxuICAgICAgICAgICAgcmV0dXJuIENvbXBhcmlzb25SZXN1bHQoZGF0ZTEubW9udGggLSBkYXRlMi5tb250aCk7XG4gICAgICAgIGlmIChkYXRlMS5kYXkgIT09IGRhdGUyLmRheSlcbiAgICAgICAgICAgIHJldHVybiBDb21wYXJpc29uUmVzdWx0KGRhdGUxLmRheSAtIGRhdGUyLmRheSk7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICAvKiogRW5zdXJlIHRoYXQgYSBjYWxlbmRhciBkYXRlIGFjdHVhbGx5IGV4aXN0cy4gSWYgbm90LCByZXR1cm4gdGhlIGNsb3Nlc3QgZWFybGllciBkYXRlLiAqL1xuICAgIHJlZ3VsYXRlRGF0ZShjYWxlbmRhckRhdGUsIG92ZXJmbG93ID0gJ2NvbnN0cmFpbicsIGNhY2hlKSB7XG4gICAgICAgIGNvbnN0IGlzb0RhdGUgPSB0aGlzLmNhbGVuZGFyVG9Jc29EYXRlKGNhbGVuZGFyRGF0ZSwgb3ZlcmZsb3csIGNhY2hlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNvVG9DYWxlbmRhckRhdGUoaXNvRGF0ZSwgY2FjaGUpO1xuICAgIH1cbiAgICBhZGREYXlzSXNvKGlzb0RhdGUsIGRheXMpIHtcbiAgICAgICAgY29uc3QgYWRkZWQgPSBBZGRJU09EYXRlKGlzb0RhdGUueWVhciwgaXNvRGF0ZS5tb250aCwgaXNvRGF0ZS5kYXksIDAsIDAsIDAsIGRheXMsICdjb25zdHJhaW4nKTtcbiAgICAgICAgcmV0dXJuIGFkZGVkO1xuICAgIH1cbiAgICBhZGREYXlzQ2FsZW5kYXIoY2FsZW5kYXJEYXRlLCBkYXlzLCBjYWNoZSkge1xuICAgICAgICBjb25zdCBpc29EYXRlID0gdGhpcy5jYWxlbmRhclRvSXNvRGF0ZShjYWxlbmRhckRhdGUsICdjb25zdHJhaW4nLCBjYWNoZSk7XG4gICAgICAgIGNvbnN0IGFkZGVkSXNvID0gdGhpcy5hZGREYXlzSXNvKGlzb0RhdGUsIGRheXMpO1xuICAgICAgICBjb25zdCBhZGRlZENhbGVuZGFyID0gdGhpcy5pc29Ub0NhbGVuZGFyRGF0ZShhZGRlZElzbywgY2FjaGUpO1xuICAgICAgICByZXR1cm4gYWRkZWRDYWxlbmRhcjtcbiAgICB9XG4gICAgYWRkTW9udGhzQ2FsZW5kYXIoY2FsZW5kYXJEYXRlUGFyYW0sIG1vbnRocywgb3ZlcmZsb3csIGNhY2hlKSB7XG4gICAgICAgIGxldCBjYWxlbmRhckRhdGUgPSBjYWxlbmRhckRhdGVQYXJhbTtcbiAgICAgICAgY29uc3QgeyBkYXkgfSA9IGNhbGVuZGFyRGF0ZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGFic01vbnRocyA9IE1hdGhBYnMkMShtb250aHMpOyBpIDwgYWJzTW9udGhzOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHsgbW9udGggfSA9IGNhbGVuZGFyRGF0ZTtcbiAgICAgICAgICAgIGNvbnN0IG9sZENhbGVuZGFyRGF0ZSA9IGNhbGVuZGFyRGF0ZTtcbiAgICAgICAgICAgIGNvbnN0IGRheXMgPSBtb250aHMgPCAwXG4gICAgICAgICAgICAgICAgPyAtTWF0aC5tYXgoZGF5LCB0aGlzLmRheXNJblByZXZpb3VzTW9udGgoY2FsZW5kYXJEYXRlLCBjYWNoZSkpXG4gICAgICAgICAgICAgICAgOiB0aGlzLmRheXNJbk1vbnRoKGNhbGVuZGFyRGF0ZSwgY2FjaGUpO1xuICAgICAgICAgICAgY29uc3QgaXNvRGF0ZSA9IHRoaXMuY2FsZW5kYXJUb0lzb0RhdGUoY2FsZW5kYXJEYXRlLCAnY29uc3RyYWluJywgY2FjaGUpO1xuICAgICAgICAgICAgbGV0IGFkZGVkSXNvID0gdGhpcy5hZGREYXlzSXNvKGlzb0RhdGUsIGRheXMpO1xuICAgICAgICAgICAgY2FsZW5kYXJEYXRlID0gdGhpcy5pc29Ub0NhbGVuZGFyRGF0ZShhZGRlZElzbywgY2FjaGUpO1xuICAgICAgICAgICAgLy8gTm9ybWFsbHksIHdlIGNhbiBhZHZhbmNlIG9uZSBtb250aCBieSBhZGRpbmcgdGhlIG51bWJlciBvZiBkYXlzIGluIHRoZVxuICAgICAgICAgICAgLy8gY3VycmVudCBtb250aC4gSG93ZXZlciwgaWYgd2UncmUgYXQgdGhlIGVuZCBvZiB0aGUgY3VycmVudCBtb250aCBhbmRcbiAgICAgICAgICAgIC8vIHRoZSBuZXh0IG1vbnRoIGhhcyBmZXdlciBkYXlzLCB0aGVuIHdlIHJvbGxlZCBvdmVyIHRvIHRoZSBhZnRlci1uZXh0XG4gICAgICAgICAgICAvLyBtb250aC4gQmVsb3cgd2UgZGV0ZWN0IHRoaXMgY29uZGl0aW9uIGFuZCBiYWNrIHVwIHVudGlsIHdlJ3JlIGJhY2sgaW5cbiAgICAgICAgICAgIC8vIHRoZSBkZXNpcmVkIG1vbnRoLlxuICAgICAgICAgICAgaWYgKG1vbnRocyA+IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtb250aHNJbk9sZFllYXIgPSB0aGlzLm1vbnRoc0luWWVhcihvbGRDYWxlbmRhckRhdGUsIGNhY2hlKTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoY2FsZW5kYXJEYXRlLm1vbnRoIC0gMSAhPT0gbW9udGggJSBtb250aHNJbk9sZFllYXIpIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkZWRJc28gPSB0aGlzLmFkZERheXNJc28oYWRkZWRJc28sIC0xKTtcbiAgICAgICAgICAgICAgICAgICAgY2FsZW5kYXJEYXRlID0gdGhpcy5pc29Ub0NhbGVuZGFyRGF0ZShhZGRlZElzbywgY2FjaGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjYWxlbmRhckRhdGUuZGF5ICE9PSBkYXkpIHtcbiAgICAgICAgICAgICAgICAvLyB0cnkgdG8gcmV0YWluIHRoZSBvcmlnaW5hbCBkYXktb2YtbW9udGgsIGlmIHBvc3NpYmxlXG4gICAgICAgICAgICAgICAgY2FsZW5kYXJEYXRlID0gdGhpcy5yZWd1bGF0ZURhdGUoeyAuLi5jYWxlbmRhckRhdGUsIGRheSB9LCAnY29uc3RyYWluJywgY2FjaGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChvdmVyZmxvdyA9PT0gJ3JlamVjdCcgJiYgY2FsZW5kYXJEYXRlLmRheSAhPT0gZGF5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgRGF5ICR7ZGF5fSBkb2VzIG5vdCBleGlzdCBpbiByZXN1bHRpbmcgY2FsZW5kYXIgbW9udGhgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2FsZW5kYXJEYXRlO1xuICAgIH1cbiAgICBhZGRDYWxlbmRhcihjYWxlbmRhckRhdGUsIHsgeWVhcnMgPSAwLCBtb250aHMgPSAwLCB3ZWVrcyA9IDAsIGRheXMgPSAwIH0sIG92ZXJmbG93LCBjYWNoZSkge1xuICAgICAgICBjb25zdCB7IHllYXIsIG1vbnRoLCBkYXkgfSA9IGNhbGVuZGFyRGF0ZTtcbiAgICAgICAgY29uc3QgYWRkZWRNb250aHMgPSB0aGlzLmFkZE1vbnRoc0NhbGVuZGFyKHsgeWVhcjogeWVhciArIHllYXJzLCBtb250aCwgZGF5IH0sIG1vbnRocywgb3ZlcmZsb3csIGNhY2hlKTtcbiAgICAgICAgY29uc3QgaW5pdGlhbERheXMgPSBkYXlzICsgd2Vla3MgKiA3O1xuICAgICAgICBjb25zdCBhZGRlZERheXMgPSB0aGlzLmFkZERheXNDYWxlbmRhcihhZGRlZE1vbnRocywgaW5pdGlhbERheXMsIGNhY2hlKTtcbiAgICAgICAgcmV0dXJuIGFkZGVkRGF5cztcbiAgICB9XG4gICAgdW50aWxDYWxlbmRhcihjYWxlbmRhck9uZSwgY2FsZW5kYXJUd28sIGxhcmdlc3RVbml0LCBjYWNoZSkge1xuICAgICAgICBsZXQgZGF5cyA9IDA7XG4gICAgICAgIGxldCB3ZWVrcyA9IDA7XG4gICAgICAgIGxldCBtb250aHMgPSAwO1xuICAgICAgICBsZXQgeWVhcnMgPSAwO1xuICAgICAgICBzd2l0Y2ggKGxhcmdlc3RVbml0KSB7XG4gICAgICAgICAgICBjYXNlICdkYXknOlxuICAgICAgICAgICAgICAgIGRheXMgPSB0aGlzLmNhbGVuZGFyRGF5c1VudGlsKGNhbGVuZGFyT25lLCBjYWxlbmRhclR3bywgY2FjaGUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnd2Vlayc6IHtcbiAgICAgICAgICAgICAgICBjb25zdCB0b3RhbERheXMgPSB0aGlzLmNhbGVuZGFyRGF5c1VudGlsKGNhbGVuZGFyT25lLCBjYWxlbmRhclR3bywgY2FjaGUpO1xuICAgICAgICAgICAgICAgIGRheXMgPSB0b3RhbERheXMgJSA3O1xuICAgICAgICAgICAgICAgIHdlZWtzID0gKHRvdGFsRGF5cyAtIGRheXMpIC8gNztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ21vbnRoJzpcbiAgICAgICAgICAgIGNhc2UgJ3llYXInOiB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGlmZlllYXJzID0gY2FsZW5kYXJUd28ueWVhciAtIGNhbGVuZGFyT25lLnllYXI7XG4gICAgICAgICAgICAgICAgY29uc3QgZGlmZk1vbnRocyA9IGNhbGVuZGFyVHdvLm1vbnRoIC0gY2FsZW5kYXJPbmUubW9udGg7XG4gICAgICAgICAgICAgICAgY29uc3QgZGlmZkRheXMgPSBjYWxlbmRhclR3by5kYXkgLSBjYWxlbmRhck9uZS5kYXk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2lnbiA9IHRoaXMuY29tcGFyZUNhbGVuZGFyRGF0ZXMoY2FsZW5kYXJUd28sIGNhbGVuZGFyT25lKTtcbiAgICAgICAgICAgICAgICBpZiAobGFyZ2VzdFVuaXQgPT09ICd5ZWFyJyAmJiBkaWZmWWVhcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaXNPbmVGdXJ0aGVySW5ZZWFyID0gZGlmZk1vbnRocyAqIHNpZ24gPCAwIHx8IChkaWZmTW9udGhzID09PSAwICYmIGRpZmZEYXlzICogc2lnbiA8IDApO1xuICAgICAgICAgICAgICAgICAgICB5ZWFycyA9IGlzT25lRnVydGhlckluWWVhciA/IGRpZmZZZWFycyAtIHNpZ24gOiBkaWZmWWVhcnM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHllYXJzQWRkZWQgPSB5ZWFycyA/IHRoaXMuYWRkQ2FsZW5kYXIoY2FsZW5kYXJPbmUsIHsgeWVhcnMgfSwgJ2NvbnN0cmFpbicsIGNhY2hlKSA6IGNhbGVuZGFyT25lO1xuICAgICAgICAgICAgICAgIC8vIE5vdyB3ZSBoYXZlIGxlc3MgdGhhbiBvbmUgeWVhciByZW1haW5pbmcuIEFkZCBvbmUgbW9udGggYXQgYSB0aW1lXG4gICAgICAgICAgICAgICAgLy8gdW50aWwgd2UgZ28gb3ZlciB0aGUgdGFyZ2V0LCB0aGVuIGJhY2sgdXAgb25lIG1vbnRoIGFuZCBjYWxjdWxhdGVcbiAgICAgICAgICAgICAgICAvLyByZW1haW5pbmcgZGF5cyBhbmQgd2Vla3MuXG4gICAgICAgICAgICAgICAgbGV0IGN1cnJlbnQ7XG4gICAgICAgICAgICAgICAgbGV0IG5leHQgPSB5ZWFyc0FkZGVkO1xuICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgbW9udGhzICs9IHNpZ247XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBuZXh0O1xuICAgICAgICAgICAgICAgICAgICBuZXh0ID0gdGhpcy5hZGRNb250aHNDYWxlbmRhcihjdXJyZW50LCBzaWduLCAnY29uc3RyYWluJywgY2FjaGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dC5kYXkgIT09IGNhbGVuZGFyT25lLmRheSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSW4gY2FzZSB0aGUgZGF5IHdhcyBjb25zdHJhaW5lZCBkb3duLCB0cnkgdG8gdW4tY29uc3RyYWluIGl0XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0ID0gdGhpcy5yZWd1bGF0ZURhdGUoeyAuLi5uZXh0LCBkYXk6IGNhbGVuZGFyT25lLmRheSB9LCAnY29uc3RyYWluJywgY2FjaGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSB3aGlsZSAodGhpcy5jb21wYXJlQ2FsZW5kYXJEYXRlcyhjYWxlbmRhclR3bywgbmV4dCkgKiBzaWduID49IDApO1xuICAgICAgICAgICAgICAgIG1vbnRocyAtPSBzaWduOyAvLyBjb3JyZWN0IGZvciBsb29wIGFib3ZlIHdoaWNoIG92ZXJzaG9vdHMgYnkgMVxuICAgICAgICAgICAgICAgIGNvbnN0IHJlbWFpbmluZ0RheXMgPSB0aGlzLmNhbGVuZGFyRGF5c1VudGlsKGN1cnJlbnQsIGNhbGVuZGFyVHdvLCBjYWNoZSk7XG4gICAgICAgICAgICAgICAgZGF5cyA9IHJlbWFpbmluZ0RheXM7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgeWVhcnMsIG1vbnRocywgd2Vla3MsIGRheXMgfTtcbiAgICB9XG4gICAgZGF5c0luTW9udGgoY2FsZW5kYXJEYXRlLCBjYWNoZSkge1xuICAgICAgICAvLyBBZGQgZW5vdWdoIGRheXMgdG8gcm9sbCBvdmVyIHRvIHRoZSBuZXh0IG1vbnRoLiBPbmUgd2UncmUgaW4gdGhlIG5leHRcbiAgICAgICAgLy8gbW9udGgsIHdlIGNhbiBjYWxjdWxhdGUgdGhlIGxlbmd0aCBvZiB0aGUgY3VycmVudCBtb250aC4gTk9URTogVGhpc1xuICAgICAgICAvLyBhbGdvcml0aG0gYXNzdW1lcyB0aGF0IG1vbnRocyBhcmUgY29udGludW91cy4gSXQgd291bGQgYnJlYWsgaWYgYVxuICAgICAgICAvLyBjYWxlbmRhciBza2lwcGVkIGRheXMsIGxpa2UgdGhlIEp1bGlhbi0+R3JlZ29yaWFuIHN3aXRjaG92ZXIuIEJ1dCB0aGVcbiAgICAgICAgLy8gb25seSBJQ1UgY2FsZW5kYXJzIHRoYXQgY3VycmVudGx5IHNraXAgZGF5cyAoamFwYW5lc2Uvcm9jL2J1ZGRoaXN0KSBpcyBhXG4gICAgICAgIC8vIGJ1ZyAoaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MTE3MzE1OClcbiAgICAgICAgLy8gdGhhdCdzIGN1cnJlbnRseSBkZXRlY3RlZCBieSBgY2hlY2tJY3VCdWdzKClgIHdoaWNoIHdpbGwgdGhyb3cuIFNvIHRoaXNcbiAgICAgICAgLy8gY29kZSBzaG91bGQgYmUgc2FmZSBmb3IgYWxsIElDVSBjYWxlbmRhcnMuXG4gICAgICAgIGNvbnN0IHsgZGF5IH0gPSBjYWxlbmRhckRhdGU7XG4gICAgICAgIGNvbnN0IG1heCA9IHRoaXMubWF4aW11bU1vbnRoTGVuZ3RoKGNhbGVuZGFyRGF0ZSk7XG4gICAgICAgIGNvbnN0IG1pbiA9IHRoaXMubWluaW11bU1vbnRoTGVuZ3RoKGNhbGVuZGFyRGF0ZSk7XG4gICAgICAgIC8vIGVhc2llc3QgY2FzZTogd2UgYWxyZWFkeSBrbm93IHRoZSBtb250aCBsZW5ndGggaWYgbWluIGFuZCBtYXggYXJlIHRoZSBzYW1lLlxuICAgICAgICBpZiAobWluID09PSBtYXgpXG4gICAgICAgICAgICByZXR1cm4gbWluO1xuICAgICAgICAvLyBBZGQgZW5vdWdoIGRheXMgdG8gZ2V0IGludG8gdGhlIG5leHQgbW9udGgsIHdpdGhvdXQgc2tpcHBpbmcgaXRcbiAgICAgICAgY29uc3QgaW5jcmVtZW50ID0gZGF5IDw9IG1heCAtIG1pbiA/IG1heCA6IG1pbjtcbiAgICAgICAgY29uc3QgaXNvRGF0ZSA9IHRoaXMuY2FsZW5kYXJUb0lzb0RhdGUoY2FsZW5kYXJEYXRlLCAnY29uc3RyYWluJywgY2FjaGUpO1xuICAgICAgICBjb25zdCBhZGRlZElzb0RhdGUgPSB0aGlzLmFkZERheXNJc28oaXNvRGF0ZSwgaW5jcmVtZW50KTtcbiAgICAgICAgY29uc3QgYWRkZWRDYWxlbmRhckRhdGUgPSB0aGlzLmlzb1RvQ2FsZW5kYXJEYXRlKGFkZGVkSXNvRGF0ZSwgY2FjaGUpO1xuICAgICAgICAvLyBOb3cgYmFjayB1cCB0byB0aGUgbGFzdCBkYXkgb2YgdGhlIG9yaWdpbmFsIG1vbnRoXG4gICAgICAgIGNvbnN0IGVuZE9mTW9udGhJc28gPSB0aGlzLmFkZERheXNJc28oYWRkZWRJc29EYXRlLCAtYWRkZWRDYWxlbmRhckRhdGUuZGF5KTtcbiAgICAgICAgY29uc3QgZW5kT2ZNb250aENhbGVuZGFyID0gdGhpcy5pc29Ub0NhbGVuZGFyRGF0ZShlbmRPZk1vbnRoSXNvLCBjYWNoZSk7XG4gICAgICAgIHJldHVybiBlbmRPZk1vbnRoQ2FsZW5kYXIuZGF5O1xuICAgIH1cbiAgICBkYXlzSW5QcmV2aW91c01vbnRoKGNhbGVuZGFyRGF0ZSwgY2FjaGUpIHtcbiAgICAgICAgY29uc3QgeyBkYXksIG1vbnRoLCB5ZWFyIH0gPSBjYWxlbmRhckRhdGU7XG4gICAgICAgIC8vIENoZWNrIHRvIHNlZSBpZiB3ZSBhbHJlYWR5IGtub3cgdGhlIG1vbnRoIGxlbmd0aCwgYW5kIHJldHVybiBpdCBpZiBzb1xuICAgICAgICBjb25zdCBwcmV2aW91c01vbnRoWWVhciA9IG1vbnRoID4gMSA/IHllYXIgOiB5ZWFyIC0gMTtcbiAgICAgICAgbGV0IHByZXZpb3VzTW9udGhEYXRlID0geyB5ZWFyOiBwcmV2aW91c01vbnRoWWVhciwgbW9udGgsIGRheTogMSB9O1xuICAgICAgICBjb25zdCBwcmV2aW91c01vbnRoID0gbW9udGggPiAxID8gbW9udGggLSAxIDogdGhpcy5tb250aHNJblllYXIocHJldmlvdXNNb250aERhdGUsIGNhY2hlKTtcbiAgICAgICAgcHJldmlvdXNNb250aERhdGUgPSB7IC4uLnByZXZpb3VzTW9udGhEYXRlLCBtb250aDogcHJldmlvdXNNb250aCB9O1xuICAgICAgICBjb25zdCBtaW4gPSB0aGlzLm1pbmltdW1Nb250aExlbmd0aChwcmV2aW91c01vbnRoRGF0ZSk7XG4gICAgICAgIGNvbnN0IG1heCA9IHRoaXMubWF4aW11bU1vbnRoTGVuZ3RoKHByZXZpb3VzTW9udGhEYXRlKTtcbiAgICAgICAgaWYgKG1pbiA9PT0gbWF4KVxuICAgICAgICAgICAgcmV0dXJuIG1heDtcbiAgICAgICAgY29uc3QgaXNvRGF0ZSA9IHRoaXMuY2FsZW5kYXJUb0lzb0RhdGUoY2FsZW5kYXJEYXRlLCAnY29uc3RyYWluJywgY2FjaGUpO1xuICAgICAgICBjb25zdCBsYXN0RGF5T2ZQcmV2aW91c01vbnRoSXNvID0gdGhpcy5hZGREYXlzSXNvKGlzb0RhdGUsIC1kYXkpO1xuICAgICAgICBjb25zdCBsYXN0RGF5T2ZQcmV2aW91c01vbnRoQ2FsZW5kYXIgPSB0aGlzLmlzb1RvQ2FsZW5kYXJEYXRlKGxhc3REYXlPZlByZXZpb3VzTW9udGhJc28sIGNhY2hlKTtcbiAgICAgICAgcmV0dXJuIGxhc3REYXlPZlByZXZpb3VzTW9udGhDYWxlbmRhci5kYXk7XG4gICAgfVxuICAgIHN0YXJ0T2ZDYWxlbmRhclllYXIoY2FsZW5kYXJEYXRlKSB7XG4gICAgICAgIHJldHVybiB7IHllYXI6IGNhbGVuZGFyRGF0ZS55ZWFyLCBtb250aDogMSwgZGF5OiAxIH07XG4gICAgfVxuICAgIHN0YXJ0T2ZDYWxlbmRhck1vbnRoKGNhbGVuZGFyRGF0ZSkge1xuICAgICAgICByZXR1cm4geyB5ZWFyOiBjYWxlbmRhckRhdGUueWVhciwgbW9udGg6IGNhbGVuZGFyRGF0ZS5tb250aCwgZGF5OiAxIH07XG4gICAgfVxuICAgIGNhbGVuZGFyRGF5c1VudGlsKGNhbGVuZGFyT25lLCBjYWxlbmRhclR3bywgY2FjaGUpIHtcbiAgICAgICAgY29uc3Qgb25lSXNvID0gdGhpcy5jYWxlbmRhclRvSXNvRGF0ZShjYWxlbmRhck9uZSwgJ2NvbnN0cmFpbicsIGNhY2hlKTtcbiAgICAgICAgY29uc3QgdHdvSXNvID0gdGhpcy5jYWxlbmRhclRvSXNvRGF0ZShjYWxlbmRhclR3bywgJ2NvbnN0cmFpbicsIGNhY2hlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNvRGF5c1VudGlsKG9uZUlzbywgdHdvSXNvKTtcbiAgICB9XG4gICAgaXNvRGF5c1VudGlsKG9uZUlzbywgdHdvSXNvKSB7XG4gICAgICAgIGNvbnN0IGR1cmF0aW9uID0gRGlmZmVyZW5jZUlTT0RhdGUob25lSXNvLnllYXIsIG9uZUlzby5tb250aCwgb25lSXNvLmRheSwgdHdvSXNvLnllYXIsIHR3b0lzby5tb250aCwgdHdvSXNvLmRheSwgJ2RheScpO1xuICAgICAgICByZXR1cm4gZHVyYXRpb24uZGF5cztcbiAgICB9XG4gICAgbW9udGhEYXlGcm9tRmllbGRzKGZpZWxkcywgb3ZlcmZsb3csIGNhY2hlKSB7XG4gICAgICAgIGxldCB7IHllYXIsIG1vbnRoLCBtb250aENvZGUsIGRheSwgZXJhLCBlcmFZZWFyIH0gPSBmaWVsZHM7XG4gICAgICAgIGlmIChtb250aENvZGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKHllYXIgPT09IHVuZGVmaW5lZCAmJiAoZXJhID09PSB1bmRlZmluZWQgfHwgZXJhWWVhciA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2Btb250aENvZGVgLCBgeWVhcmAsIG9yIGBlcmFgIGFuZCBgZXJhWWVhcmAgaXMgcmVxdWlyZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICh7IG1vbnRoQ29kZSwgeWVhciB9ID0gdGhpcy5hZGp1c3RDYWxlbmRhckRhdGUoeyB5ZWFyLCBtb250aCwgbW9udGhDb2RlLCBkYXksIGVyYSwgZXJhWWVhciB9LCBjYWNoZSwgb3ZlcmZsb3cpKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgaXNvWWVhciwgaXNvTW9udGgsIGlzb0RheTtcbiAgICAgICAgbGV0IGNsb3Nlc3RDYWxlbmRhciwgY2xvc2VzdElzbztcbiAgICAgICAgLy8gTG9vayBiYWNrd2FyZHMgc3RhcnRpbmcgZnJvbSB0aGUgY2FsZW5kYXIgeWVhciBvZiAxOTcyLTAxLTAxIHVwIHRvIDEwMFxuICAgICAgICAvLyBjYWxlbmRhciB5ZWFycyB0byBmaW5kIGEgeWVhciB0aGF0IGhhcyB0aGlzIG1vbnRoIGFuZCBkYXkuIE5vcm1hbCBtb250aHNcbiAgICAgICAgLy8gYW5kIGRheXMgd2lsbCBtYXRjaCBpbW1lZGlhdGVseSwgYnV0IGZvciBsZWFwIGRheXMgYW5kIGxlYXAgbW9udGhzIHdlIG1heVxuICAgICAgICAvLyBoYXZlIHRvIGxvb2sgZm9yIGEgd2hpbGUuXG4gICAgICAgIGNvbnN0IHN0YXJ0RGF0ZUlzbyA9IHsgeWVhcjogMTk3MiwgbW9udGg6IDEsIGRheTogMSB9O1xuICAgICAgICBjb25zdCB7IHllYXI6IGNhbGVuZGFyWWVhciB9ID0gdGhpcy5pc29Ub0NhbGVuZGFyRGF0ZShzdGFydERhdGVJc28sIGNhY2hlKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxMDA7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgdGVzdENhbGVuZGFyRGF0ZSA9IHRoaXMuYWRqdXN0Q2FsZW5kYXJEYXRlKHsgZGF5LCBtb250aENvZGUsIHllYXI6IGNhbGVuZGFyWWVhciAtIGkgfSwgY2FjaGUpO1xuICAgICAgICAgICAgY29uc3QgaXNvRGF0ZSA9IHRoaXMuY2FsZW5kYXJUb0lzb0RhdGUodGVzdENhbGVuZGFyRGF0ZSwgJ2NvbnN0cmFpbicsIGNhY2hlKTtcbiAgICAgICAgICAgIGNvbnN0IHJvdW5kVHJpcENhbGVuZGFyRGF0ZSA9IHRoaXMuaXNvVG9DYWxlbmRhckRhdGUoaXNvRGF0ZSwgY2FjaGUpO1xuICAgICAgICAgICAgKHsgeWVhcjogaXNvWWVhciwgbW9udGg6IGlzb01vbnRoLCBkYXk6IGlzb0RheSB9ID0gaXNvRGF0ZSk7XG4gICAgICAgICAgICBpZiAocm91bmRUcmlwQ2FsZW5kYXJEYXRlLm1vbnRoQ29kZSA9PT0gbW9udGhDb2RlICYmIHJvdW5kVHJpcENhbGVuZGFyRGF0ZS5kYXkgPT09IGRheSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IG1vbnRoOiBpc29Nb250aCwgZGF5OiBpc29EYXksIHllYXI6IGlzb1llYXIgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG92ZXJmbG93ID09PSAnY29uc3RyYWluJykge1xuICAgICAgICAgICAgICAgIC8vIG5vbi1JU08gY29uc3RyYWluIGFsZ29yaXRobSB0cmllcyB0byBmaW5kIHRoZSBjbG9zZXN0IGRhdGUgaW4gYSBtYXRjaGluZyBtb250aFxuICAgICAgICAgICAgICAgIGlmIChjbG9zZXN0Q2FsZW5kYXIgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgICAgICAgICAocm91bmRUcmlwQ2FsZW5kYXJEYXRlLm1vbnRoQ29kZSA9PT0gY2xvc2VzdENhbGVuZGFyLm1vbnRoQ29kZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgcm91bmRUcmlwQ2FsZW5kYXJEYXRlLmRheSA+IGNsb3Nlc3RDYWxlbmRhci5kYXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsb3Nlc3RDYWxlbmRhciA9IHJvdW5kVHJpcENhbGVuZGFyRGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgY2xvc2VzdElzbyA9IGlzb0RhdGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChvdmVyZmxvdyA9PT0gJ2NvbnN0cmFpbicgJiYgY2xvc2VzdElzbyAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmV0dXJuIGNsb3Nlc3RJc287XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBObyByZWNlbnQgJHt0aGlzLmlkfSB5ZWFyIHdpdGggbW9udGhDb2RlICR7bW9udGhDb2RlfSBhbmQgZGF5ICR7ZGF5fWApO1xuICAgIH1cbn1cbmNsYXNzIEhlYnJld0hlbHBlciBleHRlbmRzIEhlbHBlckJhc2Uge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLmlkID0gJ2hlYnJldyc7XG4gICAgICAgIHRoaXMuY2FsZW5kYXJUeXBlID0gJ2x1bmlzb2xhcic7XG4gICAgICAgIHRoaXMubW9udGhzID0ge1xuICAgICAgICAgICAgVGlzaHJpOiB7IGxlYXA6IDEsIHJlZ3VsYXI6IDEsIG1vbnRoQ29kZTogJ00wMScsIGRheXM6IDMwIH0sXG4gICAgICAgICAgICBIZXNodmFuOiB7IGxlYXA6IDIsIHJlZ3VsYXI6IDIsIG1vbnRoQ29kZTogJ00wMicsIGRheXM6IHsgbWluOiAyOSwgbWF4OiAzMCB9IH0sXG4gICAgICAgICAgICBLaXNsZXY6IHsgbGVhcDogMywgcmVndWxhcjogMywgbW9udGhDb2RlOiAnTTAzJywgZGF5czogeyBtaW46IDI5LCBtYXg6IDMwIH0gfSxcbiAgICAgICAgICAgIFRldmV0OiB7IGxlYXA6IDQsIHJlZ3VsYXI6IDQsIG1vbnRoQ29kZTogJ00wNCcsIGRheXM6IDI5IH0sXG4gICAgICAgICAgICBTaGV2YXQ6IHsgbGVhcDogNSwgcmVndWxhcjogNSwgbW9udGhDb2RlOiAnTTA1JywgZGF5czogMzAgfSxcbiAgICAgICAgICAgIEFkYXI6IHsgbGVhcDogdW5kZWZpbmVkLCByZWd1bGFyOiA2LCBtb250aENvZGU6ICdNMDYnLCBkYXlzOiAyOSB9LFxuICAgICAgICAgICAgJ0FkYXIgSSc6IHsgbGVhcDogNiwgcmVndWxhcjogdW5kZWZpbmVkLCBtb250aENvZGU6ICdNMDVMJywgZGF5czogMzAgfSxcbiAgICAgICAgICAgICdBZGFyIElJJzogeyBsZWFwOiA3LCByZWd1bGFyOiB1bmRlZmluZWQsIG1vbnRoQ29kZTogJ00wNicsIGRheXM6IDI5IH0sXG4gICAgICAgICAgICBOaXNhbjogeyBsZWFwOiA4LCByZWd1bGFyOiA3LCBtb250aENvZGU6ICdNMDcnLCBkYXlzOiAzMCB9LFxuICAgICAgICAgICAgSXlhcjogeyBsZWFwOiA5LCByZWd1bGFyOiA4LCBtb250aENvZGU6ICdNMDgnLCBkYXlzOiAyOSB9LFxuICAgICAgICAgICAgU2l2YW46IHsgbGVhcDogMTAsIHJlZ3VsYXI6IDksIG1vbnRoQ29kZTogJ00wOScsIGRheXM6IDMwIH0sXG4gICAgICAgICAgICBUYW11ejogeyBsZWFwOiAxMSwgcmVndWxhcjogMTAsIG1vbnRoQ29kZTogJ00xMCcsIGRheXM6IDI5IH0sXG4gICAgICAgICAgICBBdjogeyBsZWFwOiAxMiwgcmVndWxhcjogMTEsIG1vbnRoQ29kZTogJ00xMScsIGRheXM6IDMwIH0sXG4gICAgICAgICAgICBFbHVsOiB7IGxlYXA6IDEzLCByZWd1bGFyOiAxMiwgbW9udGhDb2RlOiAnTTEyJywgZGF5czogMjkgfVxuICAgICAgICB9O1xuICAgICAgICAvLyBBbGwgYnVpbHQtaW4gY2FsZW5kYXJzIGV4Y2VwdCBDaGluZXNlL0RhbmdpIGFuZCBIZWJyZXcgdXNlIGFuIGVyYVxuICAgICAgICB0aGlzLmhhc0VyYSA9IGZhbHNlO1xuICAgIH1cbiAgICBpbkxlYXBZZWFyKGNhbGVuZGFyRGF0ZSkge1xuICAgICAgICBjb25zdCB7IHllYXIgfSA9IGNhbGVuZGFyRGF0ZTtcbiAgICAgICAgLy8gRllJOiBJbiBhZGRpdGlvbiB0byBhZGRpbmcgYSBtb250aCBpbiBsZWFwIHllYXJzLCB0aGUgSGVicmV3IGNhbGVuZGFyXG4gICAgICAgIC8vIGFsc28gaGFzIHBlci15ZWFyIGNoYW5nZXMgdG8gdGhlIG51bWJlciBvZiBkYXlzIG9mIEhlc2h2YW4gYW5kIEtpc2xldi5cbiAgICAgICAgLy8gR2l2ZW4gdGhhdCB0aGVzZSBjYW4gYmUgY2FsY3VsYXRlZCBieSBjb3VudGluZyB0aGUgbnVtYmVyIG9mIGRheXMgaW5cbiAgICAgICAgLy8gdGhvc2UgbW9udGhzLCBJIGFzc3VtZSB0aGF0IHRoZXNlIERPIE5PVCBuZWVkIHRvIGJlIGV4cG9zZWQgYXNcbiAgICAgICAgLy8gSGVicmV3LW9ubHkgcHJvdG90eXBlIGZpZWxkcyBvciBtZXRob2RzLlxuICAgICAgICByZXR1cm4gKDcgKiB5ZWFyICsgMSkgJSAxOSA8IDc7XG4gICAgfVxuICAgIG1vbnRoc0luWWVhcihjYWxlbmRhckRhdGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5MZWFwWWVhcihjYWxlbmRhckRhdGUpID8gMTMgOiAxMjtcbiAgICB9XG4gICAgbWluaW11bU1vbnRoTGVuZ3RoKGNhbGVuZGFyRGF0ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5taW5NYXhNb250aExlbmd0aChjYWxlbmRhckRhdGUsICdtaW4nKTtcbiAgICB9XG4gICAgbWF4aW11bU1vbnRoTGVuZ3RoKGNhbGVuZGFyRGF0ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5taW5NYXhNb250aExlbmd0aChjYWxlbmRhckRhdGUsICdtYXgnKTtcbiAgICB9XG4gICAgbWluTWF4TW9udGhMZW5ndGgoY2FsZW5kYXJEYXRlLCBtaW5Pck1heCkge1xuICAgICAgICBjb25zdCB7IG1vbnRoLCB5ZWFyIH0gPSBjYWxlbmRhckRhdGU7XG4gICAgICAgIGNvbnN0IG1vbnRoQ29kZSA9IHRoaXMuZ2V0TW9udGhDb2RlKHllYXIsIG1vbnRoKTtcbiAgICAgICAgY29uc3QgbW9udGhJbmZvID0gT2JqZWN0RW50cmllcyh0aGlzLm1vbnRocykuZmluZCgobSkgPT4gbVsxXS5tb250aENvZGUgPT09IG1vbnRoQ29kZSk7XG4gICAgICAgIGlmIChtb250aEluZm8gPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGB1bm1hdGNoZWQgSGVicmV3IG1vbnRoOiAke21vbnRofWApO1xuICAgICAgICBjb25zdCBkYXlzSW5Nb250aCA9IG1vbnRoSW5mb1sxXS5kYXlzO1xuICAgICAgICByZXR1cm4gdHlwZW9mIGRheXNJbk1vbnRoID09PSAnbnVtYmVyJyA/IGRheXNJbk1vbnRoIDogZGF5c0luTW9udGhbbWluT3JNYXhdO1xuICAgIH1cbiAgICAvKiogVGFrZSBhIGd1ZXNzIGF0IHdoYXQgSVNPIGRhdGUgYSBwYXJ0aWN1bGFyIGNhbGVuZGFyIGRhdGUgY29ycmVzcG9uZHMgdG8gKi9cbiAgICBlc3RpbWF0ZUlzb0RhdGUoY2FsZW5kYXJEYXRlKSB7XG4gICAgICAgIGNvbnN0IHsgeWVhciB9ID0gY2FsZW5kYXJEYXRlO1xuICAgICAgICByZXR1cm4geyB5ZWFyOiB5ZWFyIC0gMzc2MCwgbW9udGg6IDEsIGRheTogMSB9O1xuICAgIH1cbiAgICBnZXRNb250aENvZGUoeWVhciwgbW9udGgpIHtcbiAgICAgICAgaWYgKHRoaXMuaW5MZWFwWWVhcih7IHllYXIgfSkpIHtcbiAgICAgICAgICAgIHJldHVybiBtb250aCA9PT0gNiA/IGJ1aWxkTW9udGhDb2RlKDUsIHRydWUpIDogYnVpbGRNb250aENvZGUobW9udGggPCA2ID8gbW9udGggOiBtb250aCAtIDEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGJ1aWxkTW9udGhDb2RlKG1vbnRoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhZGp1c3RDYWxlbmRhckRhdGUoY2FsZW5kYXJEYXRlLCBjYWNoZSwgb3ZlcmZsb3cgPSAnY29uc3RyYWluJywgZnJvbUxlZ2FjeURhdGUgPSBmYWxzZSkge1xuICAgICAgICAvLyBUaGUgaW5jb21pbmcgdHlwZSBpcyBhY3R1YWxseSBDYWxlbmRhckRhdGUgKHNhbWUgYXMgYXJncyB0b1xuICAgICAgICAvLyBDYWxlbmRhci5kYXRlRnJvbVBhcmFtcykgYnV0IFRTIGlzbid0IHNtYXJ0IGVub3VnaCB0byBmb2xsb3cgYWxsIHRoZVxuICAgICAgICAvLyByZWFzc2lnbm1lbnRzIGJlbG93LCBzbyBhcyBhbiBhbHRlcm5hdGl2ZSB0byAxMCsgdHlwZSBjYXN0cywgd2UnbGwgbGllXG4gICAgICAgIC8vIGhlcmUgYW5kIGNsYWltIHRoYXQgdGhlIHR5cGUgaGFzIGBkYXlgIGFuZCBgeWVhcmAgZmlsbGVkIGluIGFscmVhZHkuXG4gICAgICAgIGxldCB7IHllYXIsIGVyYVllYXIsIG1vbnRoLCBtb250aENvZGUsIGRheSwgbW9udGhFeHRyYSB9ID0gY2FsZW5kYXJEYXRlO1xuICAgICAgICBpZiAoeWVhciA9PT0gdW5kZWZpbmVkICYmIGVyYVllYXIgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHllYXIgPSBlcmFZZWFyO1xuICAgICAgICBpZiAoZXJhWWVhciA9PT0gdW5kZWZpbmVkICYmIHllYXIgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIGVyYVllYXIgPSB5ZWFyO1xuICAgICAgICBpZiAoZnJvbUxlZ2FjeURhdGUpIHtcbiAgICAgICAgICAgIC8vIEluIFByZSBOb2RlLTE0IFY4LCBEYXRlVGltZUZvcm1hdC5mb3JtYXRUb1BhcnRzIGBtb250aDogJ251bWVyaWMnYFxuICAgICAgICAgICAgLy8gb3V0cHV0IHJldHVybnMgdGhlIG51bWVyaWMgZXF1aXZhbGVudCBvZiBgbW9udGhgIGFzIGEgc3RyaW5nLCBtZWFuaW5nXG4gICAgICAgICAgICAvLyB0aGF0IGAnNidgIGluIGEgbGVhcCB5ZWFyIGlzIEFkYXIgSSwgd2hpbGUgYCc2J2AgaW4gYSBub24tbGVhcCB5ZWFyXG4gICAgICAgICAgICAvLyBtZWFucyBBZGFyLiBJbiB0aGlzIGNhc2UsIGBtb250aGAgd2lsbCBhbHJlYWR5IGJlIGNvcnJlY3QgYW5kIG5vIGFjdGlvblxuICAgICAgICAgICAgLy8gaXMgbmVlZGVkLiBIb3dldmVyLCBpbiBOb2RlIDE0IGFuZCBsYXRlciBmb3JtYXRUb1BhcnRzIHJldHVybnMgdGhlIG5hbWVcbiAgICAgICAgICAgIC8vIG9mIHRoZSBIZWJyZXcgbW9udGggKGUuZy4gXCJUZXZldFwiKSwgc28gd2UnbGwgbmVlZCB0byBsb29rIHVwIHRoZVxuICAgICAgICAgICAgLy8gY29ycmVjdCBgbW9udGhgIHVzaW5nIHRoZSBzdHJpbmcgbmFtZSBhcyBhIGtleS5cbiAgICAgICAgICAgIGlmIChtb250aEV4dHJhKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbW9udGhJbmZvID0gdGhpcy5tb250aHNbbW9udGhFeHRyYV07XG4gICAgICAgICAgICAgICAgaWYgKCFtb250aEluZm8pXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBVbnJlY29nbml6ZWQgbW9udGggZnJvbSBmb3JtYXRUb1BhcnRzOiAke21vbnRoRXh0cmF9YCk7XG4gICAgICAgICAgICAgICAgbW9udGggPSB0aGlzLmluTGVhcFllYXIoeyB5ZWFyIH0pID8gbW9udGhJbmZvLmxlYXAgOiBtb250aEluZm8ucmVndWxhcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEJlY2F1c2Ugd2UncmUgZ2V0dGluZyBkYXRhIGZyb20gbGVnYWN5IERhdGUsIHRoZW4gYG1vbnRoYCB3aWxsIGFsd2F5cyBiZSBwcmVzZW50XG4gICAgICAgICAgICBtb250aENvZGUgPSB0aGlzLmdldE1vbnRoQ29kZSh5ZWFyLCBtb250aCk7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSB7IHllYXIsIG1vbnRoOiBtb250aCwgZGF5LCBlcmE6IHVuZGVmaW5lZCwgZXJhWWVhciwgbW9udGhDb2RlIH07XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gV2hlbiBjYWxsZWQgd2l0aG91dCBpbnB1dCBjb21pbmcgZnJvbSBsZWdhY3kgRGF0ZSBvdXRwdXQsIHNpbXBseSBlbnN1cmVcbiAgICAgICAgICAgIC8vIHRoYXQgYWxsIGZpZWxkcyBhcmUgcHJlc2VudC5cbiAgICAgICAgICAgIHRoaXMudmFsaWRhdGVDYWxlbmRhckRhdGUoY2FsZW5kYXJEYXRlKTtcbiAgICAgICAgICAgIGlmIChtb250aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1vbnRoQ29kZS5lbmRzV2l0aCgnTCcpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtb250aENvZGUgIT09ICdNMDVMJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYEhlYnJldyBsZWFwIG1vbnRoIG11c3QgaGF2ZSBtb250aENvZGUgTTA1TCwgbm90ICR7bW9udGhDb2RlfWApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG1vbnRoID0gNjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmluTGVhcFllYXIoeyB5ZWFyIH0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3ZlcmZsb3cgPT09ICdyZWplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYEhlYnJldyBtb250aENvZGUgTTA1TCBpcyBpbnZhbGlkIGluIHllYXIgJHt5ZWFyfSB3aGljaCBpcyBub3QgYSBsZWFwIHllYXJgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbnN0cmFpbiB0byBsYXN0IGRheSBvZiBwcmV2aW91cyBtb250aCAoQXYpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9udGggPSA1O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRheSA9IDMwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vbnRoQ29kZSA9ICdNMDUnO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtb250aCA9IG1vbnRoQ29kZU51bWJlclBhcnQobW9udGhDb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgbGVhcCBtb250aCBpcyBiZWZvcmUgdGhpcyBvbmUsIHRoZSBtb250aCBpbmRleCBpcyBvbmUgbW9yZSB0aGFuIHRoZSBtb250aCBjb2RlXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmluTGVhcFllYXIoeyB5ZWFyIH0pICYmIG1vbnRoID4gNilcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vbnRoKys7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxhcmdlc3RNb250aCA9IHRoaXMubW9udGhzSW5ZZWFyKHsgeWVhciB9KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1vbnRoIDwgMSB8fCBtb250aCA+IGxhcmdlc3RNb250aClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBJbnZhbGlkIG1vbnRoQ29kZTogJHttb250aENvZGV9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKG92ZXJmbG93ID09PSAncmVqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICBSZWplY3RUb1JhbmdlKG1vbnRoLCAxLCB0aGlzLm1vbnRoc0luWWVhcih7IHllYXIgfSkpO1xuICAgICAgICAgICAgICAgICAgICBSZWplY3RUb1JhbmdlKGRheSwgMSwgdGhpcy5tYXhpbXVtTW9udGhMZW5ndGgoeyB5ZWFyLCBtb250aCB9KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtb250aCA9IENvbnN0cmFpblRvUmFuZ2UobW9udGgsIDEsIHRoaXMubW9udGhzSW5ZZWFyKHsgeWVhciB9KSk7XG4gICAgICAgICAgICAgICAgICAgIGRheSA9IENvbnN0cmFpblRvUmFuZ2UoZGF5LCAxLCB0aGlzLm1heGltdW1Nb250aExlbmd0aCh7IHllYXIsIG1vbnRoIH0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG1vbnRoQ29kZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIG1vbnRoQ29kZSA9IHRoaXMuZ2V0TW9udGhDb2RlKHllYXIsIG1vbnRoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNhbGN1bGF0ZWRNb250aENvZGUgPSB0aGlzLmdldE1vbnRoQ29kZSh5ZWFyLCBtb250aCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjYWxjdWxhdGVkTW9udGhDb2RlICE9PSBtb250aENvZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBtb250aENvZGUgJHttb250aENvZGV9IGRvZXNuJ3QgY29ycmVzcG9uZCB0byBtb250aCAke21vbnRofSBpbiBIZWJyZXcgeWVhciAke3llYXJ9YCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyAuLi5jYWxlbmRhckRhdGUsIGRheSwgbW9udGgsIG1vbnRoQ29kZTogbW9udGhDb2RlLCB5ZWFyLCBlcmFZZWFyIH07XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIEZvciBUZW1wb3JhbCBwdXJwb3NlcywgdGhlIElzbGFtaWMgY2FsZW5kYXIgaXMgc2ltcGxlIGJlY2F1c2UgaXQncyBhbHdheXMgdGhlXG4gKiBzYW1lIDEyIG1vbnRocyBpbiB0aGUgc2FtZSBvcmRlci5cbiAqL1xuY2xhc3MgSXNsYW1pY0Jhc2VIZWxwZXIgZXh0ZW5kcyBIZWxwZXJCYXNlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5jYWxlbmRhclR5cGUgPSAnbHVuYXInO1xuICAgICAgICB0aGlzLkRBWVNfUEVSX0lTTEFNSUNfWUVBUiA9IDM1NCArIDExIC8gMzA7XG4gICAgICAgIHRoaXMuREFZU19QRVJfSVNPX1lFQVIgPSAzNjUuMjQyNTtcbiAgICAgICAgdGhpcy5jb25zdGFudEVyYSA9ICdhaCc7XG4gICAgfVxuICAgIGluTGVhcFllYXIoY2FsZW5kYXJEYXRlLCBjYWNoZSkge1xuICAgICAgICAvLyBJbiBsZWFwIHllYXJzLCB0aGUgMTJ0aCBtb250aCBoYXMgMzAgZGF5cy4gSW4gbm9uLWxlYXAgeWVhcnM6IDI5LlxuICAgICAgICBjb25zdCBkYXlzID0gdGhpcy5kYXlzSW5Nb250aCh7IHllYXI6IGNhbGVuZGFyRGF0ZS55ZWFyLCBtb250aDogMTIsIGRheTogMSB9LCBjYWNoZSk7XG4gICAgICAgIHJldHVybiBkYXlzID09PSAzMDtcbiAgICB9XG4gICAgbW9udGhzSW5ZZWFyKCAvKiBjYWxlbmRhclllYXIsIGNhY2hlICovKSB7XG4gICAgICAgIHJldHVybiAxMjtcbiAgICB9XG4gICAgbWluaW11bU1vbnRoTGVuZ3RoKCAvKiBjYWxlbmRhckRhdGUgKi8pIHtcbiAgICAgICAgcmV0dXJuIDI5O1xuICAgIH1cbiAgICBtYXhpbXVtTW9udGhMZW5ndGgoIC8qIGNhbGVuZGFyRGF0ZSAqLykge1xuICAgICAgICByZXR1cm4gMzA7XG4gICAgfVxuICAgIGVzdGltYXRlSXNvRGF0ZShjYWxlbmRhckRhdGUpIHtcbiAgICAgICAgY29uc3QgeyB5ZWFyIH0gPSB0aGlzLmFkanVzdENhbGVuZGFyRGF0ZShjYWxlbmRhckRhdGUpO1xuICAgICAgICByZXR1cm4geyB5ZWFyOiBNYXRoRmxvb3IkMSgoeWVhciAqIHRoaXMuREFZU19QRVJfSVNMQU1JQ19ZRUFSKSAvIHRoaXMuREFZU19QRVJfSVNPX1lFQVIpICsgNjIyLCBtb250aDogMSwgZGF5OiAxIH07XG4gICAgfVxufVxuLy8gVGhlcmUgYXJlIDYgSXNsYW1pYyBjYWxlbmRhcnMgd2l0aCB0aGUgc2FtZSBpbXBsZW1lbnRhdGlvbiBpbiB0aGlzIHBvbHlmaWxsLlxuLy8gVGhleSB2YXJ5IG9ubHkgaW4gdGhlaXIgSUQuIFRoZXkgZG8gZW1pdCBkaWZmZXJlbnQgb3V0cHV0IGZyb20gdGhlIHVuZGVybHlpbmdcbi8vIEludGwgaW1wbGVtZW50YXRpb24sIGJ1dCBvdXIgY29kZSBmb3IgZWFjaCBvZiB0aGVtIGlzIGlkZW50aWNhbC5cbmNsYXNzIElzbGFtaWNIZWxwZXIgZXh0ZW5kcyBJc2xhbWljQmFzZUhlbHBlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuaWQgPSAnaXNsYW1pYyc7XG4gICAgfVxufVxuY2xhc3MgSXNsYW1pY1VtYWxxdXJhSGVscGVyIGV4dGVuZHMgSXNsYW1pY0Jhc2VIZWxwZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLmlkID0gJ2lzbGFtaWMtdW1hbHF1cmEnO1xuICAgIH1cbn1cbmNsYXNzIElzbGFtaWNUYmxhSGVscGVyIGV4dGVuZHMgSXNsYW1pY0Jhc2VIZWxwZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLmlkID0gJ2lzbGFtaWMtdGJsYSc7XG4gICAgfVxufVxuY2xhc3MgSXNsYW1pY0NpdmlsSGVscGVyIGV4dGVuZHMgSXNsYW1pY0Jhc2VIZWxwZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLmlkID0gJ2lzbGFtaWMtY2l2aWwnO1xuICAgIH1cbn1cbmNsYXNzIElzbGFtaWNSZ3NhSGVscGVyIGV4dGVuZHMgSXNsYW1pY0Jhc2VIZWxwZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLmlkID0gJ2lzbGFtaWMtcmdzYSc7XG4gICAgfVxufVxuY2xhc3MgSXNsYW1pY0NjSGVscGVyIGV4dGVuZHMgSXNsYW1pY0Jhc2VIZWxwZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLmlkID0gJ2lzbGFtaWNjJztcbiAgICB9XG59XG5jbGFzcyBQZXJzaWFuSGVscGVyIGV4dGVuZHMgSGVscGVyQmFzZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuaWQgPSAncGVyc2lhbic7XG4gICAgICAgIHRoaXMuY2FsZW5kYXJUeXBlID0gJ3NvbGFyJztcbiAgICAgICAgdGhpcy5jb25zdGFudEVyYSA9ICdhcCc7XG4gICAgfVxuICAgIGluTGVhcFllYXIoY2FsZW5kYXJEYXRlLCBjYWNoZSkge1xuICAgICAgICAvLyBTYW1lIGxvZ2ljIChjb3VudCBkYXlzIGluIHRoZSBsYXN0IG1vbnRoKSBmb3IgUGVyc2lhbiBhcyBmb3IgSXNsYW1pYyxcbiAgICAgICAgLy8gZXZlbiB0aG91Z2ggUGVyc2lhbiBpcyBzb2xhciBhbmQgSXNsYW1pYyBpcyBsdW5hci5cbiAgICAgICAgcmV0dXJuIElzbGFtaWNIZWxwZXIucHJvdG90eXBlLmluTGVhcFllYXIuY2FsbCh0aGlzLCBjYWxlbmRhckRhdGUsIGNhY2hlKTtcbiAgICB9XG4gICAgbW9udGhzSW5ZZWFyKCAvKiBjYWxlbmRhclllYXIsIGNhY2hlICovKSB7XG4gICAgICAgIHJldHVybiAxMjtcbiAgICB9XG4gICAgbWluaW11bU1vbnRoTGVuZ3RoKGNhbGVuZGFyRGF0ZSkge1xuICAgICAgICBjb25zdCB7IG1vbnRoIH0gPSBjYWxlbmRhckRhdGU7XG4gICAgICAgIGlmIChtb250aCA9PT0gMTIpXG4gICAgICAgICAgICByZXR1cm4gMjk7XG4gICAgICAgIHJldHVybiBtb250aCA8PSA2ID8gMzEgOiAzMDtcbiAgICB9XG4gICAgbWF4aW11bU1vbnRoTGVuZ3RoKGNhbGVuZGFyRGF0ZSkge1xuICAgICAgICBjb25zdCB7IG1vbnRoIH0gPSBjYWxlbmRhckRhdGU7XG4gICAgICAgIGlmIChtb250aCA9PT0gMTIpXG4gICAgICAgICAgICByZXR1cm4gMzA7XG4gICAgICAgIHJldHVybiBtb250aCA8PSA2ID8gMzEgOiAzMDtcbiAgICB9XG4gICAgZXN0aW1hdGVJc29EYXRlKGNhbGVuZGFyRGF0ZSkge1xuICAgICAgICBjb25zdCB7IHllYXIgfSA9IHRoaXMuYWRqdXN0Q2FsZW5kYXJEYXRlKGNhbGVuZGFyRGF0ZSk7XG4gICAgICAgIHJldHVybiB7IHllYXI6IHllYXIgKyA2MjEsIG1vbnRoOiAxLCBkYXk6IDEgfTtcbiAgICB9XG59XG5jbGFzcyBJbmRpYW5IZWxwZXIgZXh0ZW5kcyBIZWxwZXJCYXNlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5pZCA9ICdpbmRpYW4nO1xuICAgICAgICB0aGlzLmNhbGVuZGFyVHlwZSA9ICdzb2xhcic7XG4gICAgICAgIHRoaXMuY29uc3RhbnRFcmEgPSAnc2FrYSc7XG4gICAgICAgIC8vIEluZGlhbiBtb250aHMgYWx3YXlzIHN0YXJ0IGF0IHRoZSBzYW1lIHdlbGwta25vd24gR3JlZ29yaWFuIG1vbnRoIGFuZFxuICAgICAgICAvLyBkYXkuIFNvIHRoaXMgY29udmVyc2lvbiBpcyBlYXN5IGFuZCBmYXN0LiBTZWVcbiAgICAgICAgLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSW5kaWFuX25hdGlvbmFsX2NhbGVuZGFyXG4gICAgICAgIHRoaXMubW9udGhzID0ge1xuICAgICAgICAgICAgMTogeyBsZW5ndGg6IDMwLCBtb250aDogMywgZGF5OiAyMiwgbGVhcDogeyBsZW5ndGg6IDMxLCBtb250aDogMywgZGF5OiAyMSB9IH0sXG4gICAgICAgICAgICAyOiB7IGxlbmd0aDogMzEsIG1vbnRoOiA0LCBkYXk6IDIxIH0sXG4gICAgICAgICAgICAzOiB7IGxlbmd0aDogMzEsIG1vbnRoOiA1LCBkYXk6IDIyIH0sXG4gICAgICAgICAgICA0OiB7IGxlbmd0aDogMzEsIG1vbnRoOiA2LCBkYXk6IDIyIH0sXG4gICAgICAgICAgICA1OiB7IGxlbmd0aDogMzEsIG1vbnRoOiA3LCBkYXk6IDIzIH0sXG4gICAgICAgICAgICA2OiB7IGxlbmd0aDogMzEsIG1vbnRoOiA4LCBkYXk6IDIzIH0sXG4gICAgICAgICAgICA3OiB7IGxlbmd0aDogMzAsIG1vbnRoOiA5LCBkYXk6IDIzIH0sXG4gICAgICAgICAgICA4OiB7IGxlbmd0aDogMzAsIG1vbnRoOiAxMCwgZGF5OiAyMyB9LFxuICAgICAgICAgICAgOTogeyBsZW5ndGg6IDMwLCBtb250aDogMTEsIGRheTogMjIgfSxcbiAgICAgICAgICAgIDEwOiB7IGxlbmd0aDogMzAsIG1vbnRoOiAxMiwgZGF5OiAyMiB9LFxuICAgICAgICAgICAgMTE6IHsgbGVuZ3RoOiAzMCwgbW9udGg6IDEsIG5leHRZZWFyOiB0cnVlLCBkYXk6IDIxIH0sXG4gICAgICAgICAgICAxMjogeyBsZW5ndGg6IDMwLCBtb250aDogMiwgbmV4dFllYXI6IHRydWUsIGRheTogMjAgfVxuICAgICAgICB9O1xuICAgICAgICAvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0xMDUyOSBjYXVzZXMgSW50bCdzIEluZGlhblxuICAgICAgICAvLyBjYWxlbmRhciBvdXRwdXQgdG8gZmFpbCBmb3IgYWxsIGRhdGVzIGJlZm9yZSAwMDAxLTAxLTAxIElTTy4gIEZvciBleGFtcGxlLFxuICAgICAgICAvLyBpbiBOb2RlIDEyIDAwMDAtMDEtMDEgaXMgY2FsY3VsYXRlZCBhcyA2MTQ2LzEyLy01ODMgaW5zdGVhZCBvZiAxMC8xMS8tNzkgYXNcbiAgICAgICAgLy8gZXhwZWN0ZWQuXG4gICAgICAgIHRoaXMudnVsbmVyYWJsZVRvQmNlQnVnID0gbmV3IERhdGUoJzAwMDAtMDEtMDFUMDA6MDBaJykudG9Mb2NhbGVEYXRlU3RyaW5nKCdlbi1VUy11LWNhLWluZGlhbicsIHsgdGltZVpvbmU6ICdVVEMnIH0pICE9PSAnMTAvMTEvLTc5IFNha2EnO1xuICAgIH1cbiAgICBpbkxlYXBZZWFyKGNhbGVuZGFyRGF0ZSkge1xuICAgICAgICAvLyBGcm9tIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0luZGlhbl9uYXRpb25hbF9jYWxlbmRhcjpcbiAgICAgICAgLy8gWWVhcnMgYXJlIGNvdW50ZWQgaW4gdGhlIFNha2EgZXJhLCB3aGljaCBzdGFydHMgaXRzIHllYXIgMCBpbiB0aGUgeWVhciA3OFxuICAgICAgICAvLyBvZiB0aGUgQ29tbW9uIEVyYS4gVG8gZGV0ZXJtaW5lIGxlYXAgeWVhcnMsIGFkZCA3OCB0byB0aGUgU2FrYSB5ZWFyIOKAkyBpZlxuICAgICAgICAvLyB0aGUgcmVzdWx0IGlzIGEgbGVhcCB5ZWFyIGluIHRoZSBHcmVnb3JpYW4gY2FsZW5kYXIsIHRoZW4gdGhlIFNha2EgeWVhclxuICAgICAgICAvLyBpcyBhIGxlYXAgeWVhciBhcyB3ZWxsLlxuICAgICAgICByZXR1cm4gaXNHcmVnb3JpYW5MZWFwWWVhcihjYWxlbmRhckRhdGUueWVhciArIDc4KTtcbiAgICB9XG4gICAgbW9udGhzSW5ZZWFyKCAvKiBjYWxlbmRhclllYXIsIGNhY2hlICovKSB7XG4gICAgICAgIHJldHVybiAxMjtcbiAgICB9XG4gICAgbWluaW11bU1vbnRoTGVuZ3RoKGNhbGVuZGFyRGF0ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRNb250aEluZm8oY2FsZW5kYXJEYXRlKS5sZW5ndGg7XG4gICAgfVxuICAgIG1heGltdW1Nb250aExlbmd0aChjYWxlbmRhckRhdGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TW9udGhJbmZvKGNhbGVuZGFyRGF0ZSkubGVuZ3RoO1xuICAgIH1cbiAgICBnZXRNb250aEluZm8oY2FsZW5kYXJEYXRlKSB7XG4gICAgICAgIGNvbnN0IHsgbW9udGggfSA9IGNhbGVuZGFyRGF0ZTtcbiAgICAgICAgbGV0IG1vbnRoSW5mbyA9IHRoaXMubW9udGhzW21vbnRoXTtcbiAgICAgICAgaWYgKG1vbnRoSW5mbyA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYEludmFsaWQgbW9udGg6ICR7bW9udGh9YCk7XG4gICAgICAgIGlmICh0aGlzLmluTGVhcFllYXIoY2FsZW5kYXJEYXRlKSAmJiBtb250aEluZm8ubGVhcClcbiAgICAgICAgICAgIG1vbnRoSW5mbyA9IG1vbnRoSW5mby5sZWFwO1xuICAgICAgICByZXR1cm4gbW9udGhJbmZvO1xuICAgIH1cbiAgICBlc3RpbWF0ZUlzb0RhdGUoY2FsZW5kYXJEYXRlUGFyYW0pIHtcbiAgICAgICAgLy8gRllJLCB0aGlzIFwiZXN0aW1hdGVcIiBpcyBhbHdheXMgdGhlIGV4YWN0IElTTyBkYXRlLCB3aGljaCBtYWtlcyB0aGUgSW5kaWFuXG4gICAgICAgIC8vIGNhbGVuZGFyIGZhc3QhXG4gICAgICAgIGNvbnN0IGNhbGVuZGFyRGF0ZSA9IHRoaXMuYWRqdXN0Q2FsZW5kYXJEYXRlKGNhbGVuZGFyRGF0ZVBhcmFtKTtcbiAgICAgICAgY29uc3QgbW9udGhJbmZvID0gdGhpcy5nZXRNb250aEluZm8oY2FsZW5kYXJEYXRlKTtcbiAgICAgICAgY29uc3QgaXNvWWVhciA9IGNhbGVuZGFyRGF0ZS55ZWFyICsgNzggKyAobW9udGhJbmZvLm5leHRZZWFyID8gMSA6IDApO1xuICAgICAgICBjb25zdCBpc29Nb250aCA9IG1vbnRoSW5mby5tb250aDtcbiAgICAgICAgY29uc3QgaXNvRGF5ID0gbW9udGhJbmZvLmRheTtcbiAgICAgICAgY29uc3QgaXNvRGF0ZSA9IEFkZElTT0RhdGUoaXNvWWVhciwgaXNvTW9udGgsIGlzb0RheSwgMCwgMCwgMCwgY2FsZW5kYXJEYXRlLmRheSAtIDEsICdjb25zdHJhaW4nKTtcbiAgICAgICAgcmV0dXJuIGlzb0RhdGU7XG4gICAgfVxuICAgIGNoZWNrSWN1QnVncyhpc29EYXRlKSB7XG4gICAgICAgIGlmICh0aGlzLnZ1bG5lcmFibGVUb0JjZUJ1ZyAmJiBpc29EYXRlLnllYXIgPCAxKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgY2FsZW5kYXIgJyR7dGhpcy5pZH0nIGlzIGJyb2tlbiBmb3IgSVNPIGRhdGVzIGJlZm9yZSAwMDAxLTAxLTAxYCArXG4gICAgICAgICAgICAgICAgJyAoc2VlIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTEwNTI5KScpO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGFkZHMgYWRkaXRpb25hbCBtZXRhZGF0YSB0aGF0IG1ha2VzIGl0IGVhc2llciB0byB3b3JrIHdpdGhcbiAqIGVyYXMuIE5vdGUgdGhhdCBpdCBtdXRhdGVzIGFuZCBub3JtYWxpemVzIHRoZSBvcmlnaW5hbCBlcmEgb2JqZWN0cywgd2hpY2ggaXNcbiAqIE9LIGJlY2F1c2UgdGhpcyBpcyBub24tb2JzZXJ2YWJsZSwgaW50ZXJuYWwtb25seSBtZXRhZGF0YS5cbiAqXG4gKiBUaGUgcmVzdWx0IGlzIGFuIGFycmF5IG9mIGVyYXMgd2l0aCB0aGUgc2hhcGUgZGVmaW5lZCBhYm92ZS5cbiAqICovXG5mdW5jdGlvbiBhZGp1c3RFcmFzKGVyYXNQYXJhbSkge1xuICAgIGxldCBlcmFzID0gZXJhc1BhcmFtO1xuICAgIGlmIChlcmFzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW52YWxpZCBlcmEgZGF0YTogZXJhcyBhcmUgcmVxdWlyZWQnKTtcbiAgICB9XG4gICAgaWYgKGVyYXMubGVuZ3RoID09PSAxICYmIGVyYXNbMF0ucmV2ZXJzZU9mKSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbnZhbGlkIGVyYSBkYXRhOiBhbmNob3IgZXJhIGNhbm5vdCBjb3VudCB5ZWFycyBiYWNrd2FyZHMnKTtcbiAgICB9XG4gICAgaWYgKGVyYXMubGVuZ3RoID09PSAxICYmICFlcmFzWzBdLm5hbWUpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0ludmFsaWQgZXJhIGRhdGE6IGF0IGxlYXN0IG9uZSBuYW1lZCBlcmEgaXMgcmVxdWlyZWQnKTtcbiAgICB9XG4gICAgaWYgKGVyYXMuZmlsdGVyKChlKSA9PiBlLnJldmVyc2VPZiAhPSBudWxsKS5sZW5ndGggPiAxKSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbnZhbGlkIGVyYSBkYXRhOiBvbmx5IG9uZSBlcmEgY2FuIGNvdW50IHllYXJzIGJhY2t3YXJkcycpO1xuICAgIH1cbiAgICAvLyBGaW5kIHRoZSBcImFuY2hvciBlcmFcIiB3aGljaCBpcyB0aGUgZXJhIHVzZWQgZm9yIChlcmEtbGVzcykgYHllYXJgLiBSZXZlcnNlZFxuICAgIC8vIGVyYXMgY2FuIG5ldmVyIGJlIGFuY2hvcnMuIFRoZSBlcmEgd2l0aG91dCBhbiBgYW5jaG9yRXBvY2hgIHByb3BlcnR5IGlzIHRoZVxuICAgIC8vIGFuY2hvci5cbiAgICBsZXQgYW5jaG9yRXJhO1xuICAgIGVyYXMuZm9yRWFjaCgoZSkgPT4ge1xuICAgICAgICBpZiAoZS5pc0FuY2hvciB8fCAoIWUuYW5jaG9yRXBvY2ggJiYgIWUucmV2ZXJzZU9mKSkge1xuICAgICAgICAgICAgaWYgKGFuY2hvckVyYSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW52YWxpZCBlcmEgZGF0YTogY2Fubm90IGhhdmUgbXVsdGlwbGUgYW5jaG9yIGVyYXMnKTtcbiAgICAgICAgICAgIGFuY2hvckVyYSA9IGU7XG4gICAgICAgICAgICBlLmFuY2hvckVwb2NoID0geyB5ZWFyOiBlLmhhc1llYXJaZXJvID8gMCA6IDEgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghZS5uYW1lKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSWYgZXJhIG5hbWUgaXMgYmxhbmssIGl0IG11c3QgYmUgdGhlIGFuY2hvciBlcmEnKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIC8vIElmIHRoZSBlcmEgbmFtZSBpcyB1bmRlZmluZWQsIHRoZW4gaXQncyBhbiBhbmNob3IgdGhhdCBkb2Vzbid0IGludGVyYWN0XG4gICAgLy8gd2l0aCBlcmFzIGF0IGFsbC4gRm9yIGV4YW1wbGUsIEphcGFuZXNlIGB5ZWFyYCBpcyBhbHdheXMgdGhlIHNhbWUgYXMgSVNPXG4gICAgLy8gYHllYXJgLiAgU28gdGhpcyBcImVyYVwiIGlzIHRoZSBhbmNob3IgZXJhIGJ1dCBpc24ndCB1c2VkIGZvciBlcmEgbWF0Y2hpbmcuXG4gICAgLy8gU3RyaXAgaXQgZnJvbSB0aGUgbGlzdCB0aGF0J3MgcmV0dXJuZWQuXG4gICAgZXJhcyA9IGVyYXMuZmlsdGVyKChlKSA9PiBlLm5hbWUpO1xuICAgIGVyYXMuZm9yRWFjaCgoZSkgPT4ge1xuICAgICAgICAvLyBTb21lIGVyYXMgYXJlIG1pcnJvciBpbWFnZXMgb2YgYW5vdGhlciBlcmEgZS5nLiBCLkMuIGlzIHRoZSByZXZlcnNlIG9mIEEuRC5cbiAgICAgICAgLy8gUmVwbGFjZSB0aGUgc3RyaW5nLXZhbHVlZCBcInJldmVyc2VPZlwiIHByb3BlcnR5IHdpdGggdGhlIGFjdHVhbCBlcmEgb2JqZWN0XG4gICAgICAgIC8vIHRoYXQncyByZXZlcnNlZC5cbiAgICAgICAgY29uc3QgeyByZXZlcnNlT2YgfSA9IGU7XG4gICAgICAgIGlmIChyZXZlcnNlT2YpIHtcbiAgICAgICAgICAgIGNvbnN0IHJldmVyc2VkRXJhID0gZXJhcy5maW5kKChlcmEpID0+IGVyYS5uYW1lID09PSByZXZlcnNlT2YpO1xuICAgICAgICAgICAgaWYgKHJldmVyc2VkRXJhID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYEludmFsaWQgZXJhIGRhdGE6IHVubWF0Y2hlZCByZXZlcnNlT2YgZXJhOiAke3JldmVyc2VPZn1gKTtcbiAgICAgICAgICAgIGUucmV2ZXJzZU9mID0gcmV2ZXJzZWRFcmE7XG4gICAgICAgICAgICBlLmFuY2hvckVwb2NoID0gcmV2ZXJzZWRFcmEuYW5jaG9yRXBvY2g7XG4gICAgICAgICAgICBlLmlzb0Vwb2NoID0gcmV2ZXJzZWRFcmEuaXNvRXBvY2g7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGUuYW5jaG9yRXBvY2gubW9udGggPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIGUuYW5jaG9yRXBvY2gubW9udGggPSAxO1xuICAgICAgICBpZiAoZS5hbmNob3JFcG9jaC5kYXkgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIGUuYW5jaG9yRXBvY2guZGF5ID0gMTtcbiAgICB9KTtcbiAgICAvLyBFbnN1cmUgdGhhdCB0aGUgbGF0ZXN0IGVwb2NoIGlzIGZpcnN0IGluIHRoZSBhcnJheS4gVGhpcyBsZXRzIHVzIHRyeSB0b1xuICAgIC8vIG1hdGNoIGVyYXMgaW4gaW5kZXggb3JkZXIsIHdpdGggdGhlIGxhc3QgZXJhIGdldHRpbmcgdGhlIHJlbWFpbmluZyBvbGRlclxuICAgIC8vIHllYXJzLiBBbnkgcmV2ZXJzZS1zaWduZWQgZXJhIG11c3QgYmUgYXQgdGhlIGVuZC5cbiAgICBBcnJheVNvcnQuY2FsbChlcmFzLCAoZTEsIGUyKSA9PiB7XG4gICAgICAgIGlmIChlMS5yZXZlcnNlT2YpXG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgaWYgKGUyLnJldmVyc2VPZilcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgaWYgKCFlMS5pc29FcG9jaCB8fCAhZTIuaXNvRXBvY2gpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW52YWxpZCBlcmEgZGF0YTogbWlzc2luZyBJU08gZXBvY2gnKTtcbiAgICAgICAgcmV0dXJuIGUyLmlzb0Vwb2NoLnllYXIgLSBlMS5pc29FcG9jaC55ZWFyO1xuICAgIH0pO1xuICAgIC8vIElmIHRoZXJlJ3MgYSByZXZlcnNlZCBlcmEsIHRoZW4gdGhlIG9uZSBiZWZvcmUgaXQgbXVzdCBiZSB0aGUgZXJhIHRoYXQnc1xuICAgIC8vIGJlaW5nIHJldmVyc2VkLlxuICAgIGNvbnN0IGxhc3RFcmFSZXZlcnNlZCA9IGVyYXNbZXJhcy5sZW5ndGggLSAxXS5yZXZlcnNlT2Y7XG4gICAgaWYgKGxhc3RFcmFSZXZlcnNlZCkge1xuICAgICAgICBpZiAobGFzdEVyYVJldmVyc2VkICE9PSBlcmFzW2VyYXMubGVuZ3RoIC0gMl0pXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW52YWxpZCBlcmEgZGF0YTogaW52YWxpZCByZXZlcnNlLXNpZ24gZXJhJyk7XG4gICAgfVxuICAgIC8vIEZpbmFsbHksIGFkZCBhIFwiZ2VuZXJpY05hbWVcIiBwcm9wZXJ0eSBpbiB0aGUgZm9ybWF0IFwiZXJhe259IHdoZXJlIGBuYCBpc1xuICAgIC8vIHplcm8tYmFzZWQgaW5kZXgsIHdpdGggdGhlIG9sZGVzdCBlcmEgYmVpbmcgemVyby4gVGhpcyBmb3JtYXQgaXMgdXNlZCBieVxuICAgIC8vIG9sZGVyIHZlcnNpb25zIG9mIElDVSBkYXRhLlxuICAgIGVyYXMuZm9yRWFjaCgoZSwgaSkgPT4ge1xuICAgICAgICBlLmdlbmVyaWNOYW1lID0gYGVyYSR7ZXJhcy5sZW5ndGggLSAxIC0gaX1gO1xuICAgIH0pO1xuICAgIHJldHVybiB7IGVyYXM6IGVyYXMsIGFuY2hvckVyYTogKGFuY2hvckVyYSB8fCBlcmFzWzBdKSB9O1xufVxuZnVuY3Rpb24gaXNHcmVnb3JpYW5MZWFwWWVhcih5ZWFyKSB7XG4gICAgcmV0dXJuIHllYXIgJSA0ID09PSAwICYmICh5ZWFyICUgMTAwICE9PSAwIHx8IHllYXIgJSA0MDAgPT09IDApO1xufVxuLyoqIEJhc2UgZm9yIGFsbCBHcmVnb3JpYW4tbGlrZSBjYWxlbmRhcnMuICovXG5jbGFzcyBHcmVnb3JpYW5CYXNlSGVscGVyIGV4dGVuZHMgSGVscGVyQmFzZSB7XG4gICAgY29uc3RydWN0b3IoaWQsIG9yaWdpbmFsRXJhcykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmNhbGVuZGFyVHlwZSA9ICdzb2xhcic7XG4gICAgICAgIC8vIFNldmVyYWwgY2FsZW5kYXJzIGJhc2VkIG9uIHRoZSBHcmVnb3JpYW4gY2FsZW5kYXIgdXNlIEp1bGlhbiBkYXRlcyAobm90XG4gICAgICAgIC8vIHByb2xlcHRpYyBHcmVnb3JpYW4gZGF0ZXMpIGJlZm9yZSB0aGUgSnVsaWFuIHN3aXRjaG92ZXIgaW4gT2N0IDE1ODIuIFNlZVxuICAgICAgICAvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0xMTczMTU4LlxuICAgICAgICB0aGlzLnY4SXNWdWxuZXJhYmxlVG9KdWxpYW5CdWcgPSBuZXcgRGF0ZSgnKzAwMTAwMS0wMS0wMVQwMDowMFonKVxuICAgICAgICAgICAgLnRvTG9jYWxlRGF0ZVN0cmluZygnZW4tVVMtdS1jYS1qYXBhbmVzZScsIHsgdGltZVpvbmU6ICdVVEMnIH0pXG4gICAgICAgICAgICAuc3RhcnRzV2l0aCgnMTInKTtcbiAgICAgICAgdGhpcy5jYWxlbmRhcklzVnVsbmVyYWJsZVRvSnVsaWFuQnVnID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaWQgPSBpZDtcbiAgICAgICAgY29uc3QgeyBlcmFzLCBhbmNob3JFcmEgfSA9IGFkanVzdEVyYXMob3JpZ2luYWxFcmFzKTtcbiAgICAgICAgdGhpcy5hbmNob3JFcmEgPSBhbmNob3JFcmE7XG4gICAgICAgIHRoaXMuZXJhcyA9IGVyYXM7XG4gICAgfVxuICAgIGluTGVhcFllYXIoY2FsZW5kYXJEYXRlKSB7XG4gICAgICAgIC8vIENhbGVuZGFycyB0aGF0IGRvbid0IG92ZXJyaWRlIHRoaXMgbWV0aG9kIHVzZSB0aGUgc2FtZSBtb250aHMgYW5kIGxlYXBcbiAgICAgICAgLy8geWVhcnMgYXMgR3JlZ29yaWFuLiBPbmNlIHdlIGtub3cgdGhlIElTTyB5ZWFyIGNvcnJlc3BvbmRpbmcgdG8gdGhlXG4gICAgICAgIC8vIGNhbGVuZGFyIHllYXIsIHdlJ2xsIGtub3cgaWYgaXQncyBhIGxlYXAgeWVhciBvciBub3QuXG4gICAgICAgIGNvbnN0IHsgeWVhciB9ID0gdGhpcy5lc3RpbWF0ZUlzb0RhdGUoeyBtb250aDogMSwgZGF5OiAxLCB5ZWFyOiBjYWxlbmRhckRhdGUueWVhciB9KTtcbiAgICAgICAgcmV0dXJuIGlzR3JlZ29yaWFuTGVhcFllYXIoeWVhcik7XG4gICAgfVxuICAgIG1vbnRoc0luWWVhciggLyogY2FsZW5kYXJEYXRlICovKSB7XG4gICAgICAgIHJldHVybiAxMjtcbiAgICB9XG4gICAgbWluaW11bU1vbnRoTGVuZ3RoKGNhbGVuZGFyRGF0ZSkge1xuICAgICAgICBjb25zdCB7IG1vbnRoIH0gPSBjYWxlbmRhckRhdGU7XG4gICAgICAgIGlmIChtb250aCA9PT0gMilcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmluTGVhcFllYXIoY2FsZW5kYXJEYXRlKSA/IDI5IDogMjg7XG4gICAgICAgIHJldHVybiBbNCwgNiwgOSwgMTFdLmluZGV4T2YobW9udGgpID49IDAgPyAzMCA6IDMxO1xuICAgIH1cbiAgICBtYXhpbXVtTW9udGhMZW5ndGgoY2FsZW5kYXJEYXRlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pbmltdW1Nb250aExlbmd0aChjYWxlbmRhckRhdGUpO1xuICAgIH1cbiAgICAvKiogRmlsbCBpbiBtaXNzaW5nIHBhcnRzIG9mIHRoZSAoeWVhciwgZXJhLCBlcmFZZWFyKSB0dXBsZSAqL1xuICAgIGNvbXBsZXRlRXJhWWVhcihjYWxlbmRhckRhdGUpIHtcbiAgICAgICAgY29uc3QgY2hlY2tGaWVsZCA9IChuYW1lLCB2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgY3VycmVudFZhbHVlID0gY2FsZW5kYXJEYXRlW25hbWVdO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRWYWx1ZSAhPSBudWxsICYmIGN1cnJlbnRWYWx1ZSAhPSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBJbnB1dCAke25hbWV9ICR7Y3VycmVudFZhbHVlfSBkb2Vzbid0IG1hdGNoIGNhbGN1bGF0ZWQgdmFsdWUgJHt2YWx1ZX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgZXJhRnJvbVllYXIgPSAoeWVhcikgPT4ge1xuICAgICAgICAgICAgbGV0IGVyYVllYXI7XG4gICAgICAgICAgICBjb25zdCBhZGp1c3RlZENhbGVuZGFyRGF0ZSA9IHsgLi4uY2FsZW5kYXJEYXRlLCB5ZWFyIH07XG4gICAgICAgICAgICBjb25zdCBtYXRjaGluZ0VyYSA9IHRoaXMuZXJhcy5maW5kKChlLCBpKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGkgPT09IHRoaXMuZXJhcy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlLnJldmVyc2VPZikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBpcyBhIHJldmVyc2Utc2lnbiBlcmEgKGxpa2UgQkNFKSB3aGljaCBtdXN0IGJlIHRoZSBvbGRlc3RcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVyYS4gQ291bnQgeWVhcnMgYmFja3dhcmRzLlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHllYXIgPiAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBTaWduZWQgeWVhciAke3llYXJ9IGlzIGludmFsaWQgZm9yIGVyYSAke2UubmFtZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVyYVllYXIgPSBlLmFuY2hvckVwb2NoLnllYXIgLSB5ZWFyO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gbGFzdCBlcmEgYWx3YXlzIGdldHMgYWxsIFwibGVmdG92ZXJcIiAob2xkZXIgdGhhbiBlcG9jaCkgeWVhcnMsXG4gICAgICAgICAgICAgICAgICAgIC8vIHNvIG5vIG5lZWQgZm9yIGEgY29tcGFyaXNvbiBsaWtlIGJlbG93LlxuICAgICAgICAgICAgICAgICAgICBlcmFZZWFyID0geWVhciAtIGUuYW5jaG9yRXBvY2gueWVhciArIChlLmhhc1llYXJaZXJvID8gMCA6IDEpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgY29tcGFyaXNvbiA9IHRoaXMuY29tcGFyZUNhbGVuZGFyRGF0ZXMoYWRqdXN0ZWRDYWxlbmRhckRhdGUsIGUuYW5jaG9yRXBvY2gpO1xuICAgICAgICAgICAgICAgIGlmIChjb21wYXJpc29uID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZXJhWWVhciA9IHllYXIgLSBlLmFuY2hvckVwb2NoLnllYXIgKyAoZS5oYXNZZWFyWmVybyA/IDAgOiAxKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKCFtYXRjaGluZ0VyYSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgWWVhciAke3llYXJ9IHdhcyBub3QgbWF0Y2hlZCBieSBhbnkgZXJhYCk7XG4gICAgICAgICAgICByZXR1cm4geyBlcmFZZWFyOiBlcmFZZWFyLCBlcmE6IG1hdGNoaW5nRXJhLm5hbWUgfTtcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IHsgeWVhciwgZXJhWWVhciwgZXJhIH0gPSBjYWxlbmRhckRhdGU7XG4gICAgICAgIGlmICh5ZWFyICE9IG51bGwpIHtcbiAgICAgICAgICAgICh7IGVyYVllYXIsIGVyYSB9ID0gZXJhRnJvbVllYXIoeWVhcikpO1xuICAgICAgICAgICAgY2hlY2tGaWVsZCgnZXJhJywgZXJhKTtcbiAgICAgICAgICAgIGNoZWNrRmllbGQoJ2VyYVllYXInLCBlcmFZZWFyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChlcmFZZWFyICE9IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IG1hdGNoaW5nRXJhID0gZXJhID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiB0aGlzLmVyYXMuZmluZCgoZSkgPT4gZS5uYW1lID09PSBlcmEgfHwgZS5nZW5lcmljTmFtZSA9PT0gZXJhKTtcbiAgICAgICAgICAgIGlmICghbWF0Y2hpbmdFcmEpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYEVyYSAke2VyYX0gKElTTyB5ZWFyICR7ZXJhWWVhcn0pIHdhcyBub3QgbWF0Y2hlZCBieSBhbnkgZXJhYCk7XG4gICAgICAgICAgICBpZiAoZXJhWWVhciA8IDEgJiYgbWF0Y2hpbmdFcmEucmV2ZXJzZU9mKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYFllYXJzIGluICR7ZXJhfSBlcmEgbXVzdCBiZSBwb3NpdGl2ZSwgbm90ICR7eWVhcn1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtYXRjaGluZ0VyYS5yZXZlcnNlT2YpIHtcbiAgICAgICAgICAgICAgICB5ZWFyID0gbWF0Y2hpbmdFcmEuYW5jaG9yRXBvY2gueWVhciAtIGVyYVllYXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB5ZWFyID0gZXJhWWVhciArIG1hdGNoaW5nRXJhLmFuY2hvckVwb2NoLnllYXIgLSAobWF0Y2hpbmdFcmEuaGFzWWVhclplcm8gPyAwIDogMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjaGVja0ZpZWxkKCd5ZWFyJywgeWVhcik7XG4gICAgICAgICAgICAvLyBXZSdsbCBhY2NlcHQgZGF0ZXMgd2hlcmUgdGhlIG1vbnRoL2RheSBpcyBlYXJsaWVyIHRoYW4gdGhlIHN0YXJ0IG9mXG4gICAgICAgICAgICAvLyB0aGUgZXJhIG9yIGFmdGVyIGl0cyBlbmQgYXMgbG9uZyBhcyBpdCdzIGluIHRoZSBzYW1lIHllYXIuIElmIHRoYXRcbiAgICAgICAgICAgIC8vIGhhcHBlbnMsIHdlJ2xsIGFkanVzdCB0aGUgZXJhL2VyYVllYXIgcGFpciB0byBiZSB0aGUgY29ycmVjdCBlcmEgZm9yXG4gICAgICAgICAgICAvLyB0aGUgYHllYXJgLlxuICAgICAgICAgICAgKHsgZXJhWWVhciwgZXJhIH0gPSBlcmFGcm9tWWVhcih5ZWFyKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignRWl0aGVyIGB5ZWFyYCBvciBgZXJhWWVhcmAgYW5kIGBlcmFgIGFyZSByZXF1aXJlZCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IC4uLmNhbGVuZGFyRGF0ZSwgeWVhciwgZXJhWWVhciwgZXJhIH07XG4gICAgfVxuICAgIGFkanVzdENhbGVuZGFyRGF0ZShjYWxlbmRhckRhdGVQYXJhbSwgY2FjaGUsIG92ZXJmbG93ID0gJ2NvbnN0cmFpbicpIHtcbiAgICAgICAgbGV0IGNhbGVuZGFyRGF0ZSA9IGNhbGVuZGFyRGF0ZVBhcmFtO1xuICAgICAgICAvLyBCZWNhdXNlIHRoaXMgaXMgbm90IGEgbHVuaXNvbGFyIGNhbGVuZGFyLCBpdCdzIHNhZmUgdG8gY29udmVydCBtb250aENvZGUgdG8gYSBudW1iZXJcbiAgICAgICAgY29uc3QgeyBtb250aCwgbW9udGhDb2RlIH0gPSBjYWxlbmRhckRhdGU7XG4gICAgICAgIGlmIChtb250aCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgY2FsZW5kYXJEYXRlID0geyAuLi5jYWxlbmRhckRhdGUsIG1vbnRoOiBtb250aENvZGVOdW1iZXJQYXJ0KG1vbnRoQ29kZSkgfTtcbiAgICAgICAgdGhpcy52YWxpZGF0ZUNhbGVuZGFyRGF0ZShjYWxlbmRhckRhdGUpO1xuICAgICAgICBjYWxlbmRhckRhdGUgPSB0aGlzLmNvbXBsZXRlRXJhWWVhcihjYWxlbmRhckRhdGUpO1xuICAgICAgICByZXR1cm4gc3VwZXIuYWRqdXN0Q2FsZW5kYXJEYXRlKGNhbGVuZGFyRGF0ZSwgY2FjaGUsIG92ZXJmbG93KTtcbiAgICB9XG4gICAgZXN0aW1hdGVJc29EYXRlKGNhbGVuZGFyRGF0ZVBhcmFtKSB7XG4gICAgICAgIGNvbnN0IGNhbGVuZGFyRGF0ZSA9IHRoaXMuYWRqdXN0Q2FsZW5kYXJEYXRlKGNhbGVuZGFyRGF0ZVBhcmFtKTtcbiAgICAgICAgY29uc3QgeyB5ZWFyLCBtb250aCwgZGF5IH0gPSBjYWxlbmRhckRhdGU7XG4gICAgICAgIGNvbnN0IHsgYW5jaG9yRXJhIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCBpc29ZZWFyRXN0aW1hdGUgPSB5ZWFyICsgYW5jaG9yRXJhLmlzb0Vwb2NoLnllYXIgLSAoYW5jaG9yRXJhLmhhc1llYXJaZXJvID8gMCA6IDEpO1xuICAgICAgICByZXR1cm4gUmVndWxhdGVJU09EYXRlKGlzb1llYXJFc3RpbWF0ZSwgbW9udGgsIGRheSwgJ2NvbnN0cmFpbicpO1xuICAgIH1cbiAgICBjaGVja0ljdUJ1Z3MoaXNvRGF0ZSkge1xuICAgICAgICBpZiAodGhpcy5jYWxlbmRhcklzVnVsbmVyYWJsZVRvSnVsaWFuQnVnICYmIHRoaXMudjhJc1Z1bG5lcmFibGVUb0p1bGlhbkJ1Zykge1xuICAgICAgICAgICAgY29uc3QgYmVmb3JlSnVsaWFuU3dpdGNoID0gQ29tcGFyZUlTT0RhdGUoaXNvRGF0ZS55ZWFyLCBpc29EYXRlLm1vbnRoLCBpc29EYXRlLmRheSwgMTU4MiwgMTAsIDE1KSA8IDA7XG4gICAgICAgICAgICBpZiAoYmVmb3JlSnVsaWFuU3dpdGNoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYGNhbGVuZGFyICcke3RoaXMuaWR9JyBpcyBicm9rZW4gZm9yIElTTyBkYXRlcyBiZWZvcmUgMTU4Mi0xMC0xNWAgK1xuICAgICAgICAgICAgICAgICAgICAnIChzZWUgaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MTE3MzE1OCknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmNsYXNzIE9ydGhvZG94QmFzZUhlbHBlciBleHRlbmRzIEdyZWdvcmlhbkJhc2VIZWxwZXIge1xuICAgIGNvbnN0cnVjdG9yKGlkLCBvcmlnaW5hbEVyYXMpIHtcbiAgICAgICAgc3VwZXIoaWQsIG9yaWdpbmFsRXJhcyk7XG4gICAgfVxuICAgIGluTGVhcFllYXIoY2FsZW5kYXJEYXRlKSB7XG4gICAgICAgIC8vIExlYXAgeWVhcnMgaGFwcGVuIG9uZSB5ZWFyIGJlZm9yZSB0aGUgSnVsaWFuIGxlYXAgeWVhci4gTm90ZSB0aGF0IHRoaXNcbiAgICAgICAgLy8gY2FsZW5kYXIgaXMgYmFzZWQgb24gdGhlIEp1bGlhbiBjYWxlbmRhciB3aGljaCBoYXMgYSBsZWFwIHllYXIgZXZlcnkgNFxuICAgICAgICAvLyB5ZWFycywgdW5saWtlIHRoZSBHcmVnb3JpYW4gY2FsZW5kYXIgd2hpY2ggZG9lc24ndCBoYXZlIGxlYXAgeWVhcnMgb25cbiAgICAgICAgLy8geWVhcnMgZGl2aXNpYmxlIGJ5IDEwMCBleGNlcHQgeWVhcnMgZGl2aXNpYmxlIGJ5IDQwMC5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gTm90ZSB0aGF0IHdlJ3JlIGFzc3VtaW5nIHRoYXQgbGVhcCB5ZWFycyBpbiBiZWZvcmUtZXBvY2ggdGltZXMgbWF0Y2hcbiAgICAgICAgLy8gaG93IGxlYXAgeWVhcnMgYXJlIGRlZmluZWQgbm93LiBUaGlzIGlzIHByb2JhYmx5IG5vdCBhY2N1cmF0ZSBidXQgSSdtXG4gICAgICAgIC8vIG5vdCBzdXJlIGhvdyBiZXR0ZXIgdG8gZG8gaXQuXG4gICAgICAgIGNvbnN0IHsgeWVhciB9ID0gY2FsZW5kYXJEYXRlO1xuICAgICAgICByZXR1cm4gKHllYXIgKyAxKSAlIDQgPT09IDA7XG4gICAgfVxuICAgIG1vbnRoc0luWWVhciggLyogY2FsZW5kYXJEYXRlICovKSB7XG4gICAgICAgIHJldHVybiAxMztcbiAgICB9XG4gICAgbWluaW11bU1vbnRoTGVuZ3RoKGNhbGVuZGFyRGF0ZSkge1xuICAgICAgICBjb25zdCB7IG1vbnRoIH0gPSBjYWxlbmRhckRhdGU7XG4gICAgICAgIC8vIEV0aGlvcGlhbi9Db3B0aWMgY2FsZW5kYXJzIGhhdmUgMTIgMzAtZGF5IG1vbnRocyBhbmQgYW4gZXh0cmEgNS02IGRheSAxM3RoIG1vbnRoLlxuICAgICAgICBpZiAobW9udGggPT09IDEzKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5MZWFwWWVhcihjYWxlbmRhckRhdGUpID8gNiA6IDU7XG4gICAgICAgIHJldHVybiAzMDtcbiAgICB9XG4gICAgbWF4aW11bU1vbnRoTGVuZ3RoKGNhbGVuZGFyRGF0ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5taW5pbXVtTW9udGhMZW5ndGgoY2FsZW5kYXJEYXRlKTtcbiAgICB9XG59XG4vLyBgY29wdGljYCBhbmQgYGV0aGlvcGljYCBjYWxlbmRhcnMgYXJlIHZlcnkgc2ltaWxhciB0byBgZXRoaW9hYWAgY2FsZW5kYXIsXG4vLyB3aXRoIHRoZSBmb2xsb3dpbmcgZGlmZmVyZW5jZXM6XG4vLyAtIENvcHRpYyB1c2VzIEJDRS1saWtlIHBvc2l0aXZlIG51bWJlcnMgZm9yIHllYXJzIGJlZm9yZSBpdHMgZXBvY2ggKHRoZSBvdGhlclxuLy8gICB0d28gdXNlIG5lZ2F0aXZlIHllYXIgbnVtYmVycyBiZWZvcmUgZXBvY2gpXG4vLyAtIENvcHRpYyBoYXMgYSBkaWZmZXJlbnQgZXBvY2ggZGF0ZVxuLy8gLSBFdGhpb3BpYyBoYXMgYW4gYWRkaXRpb25hbCBzZWNvbmQgZXJhIHRoYXQgc3RhcnRzIGF0IHRoZSBzYW1lIGRhdGUgYXMgdGhlXG4vLyAgIHplcm8gZXJhIG9mIGV0aGlvYWEuXG5jbGFzcyBFdGhpb2FhSGVscGVyIGV4dGVuZHMgT3J0aG9kb3hCYXNlSGVscGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoJ2V0aGlvYWEnLCBbeyBuYW1lOiAnZXJhMCcsIGlzb0Vwb2NoOiB7IHllYXI6IC01NDkyLCBtb250aDogNywgZGF5OiAxNyB9IH1dKTtcbiAgICB9XG59XG5jbGFzcyBDb3B0aWNIZWxwZXIgZXh0ZW5kcyBPcnRob2RveEJhc2VIZWxwZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcignY29wdGljJywgW1xuICAgICAgICAgICAgeyBuYW1lOiAnZXJhMScsIGlzb0Vwb2NoOiB7IHllYXI6IDI4NCwgbW9udGg6IDgsIGRheTogMjkgfSB9LFxuICAgICAgICAgICAgeyBuYW1lOiAnZXJhMCcsIHJldmVyc2VPZjogJ2VyYTEnIH1cbiAgICAgICAgXSk7XG4gICAgfVxufVxuLy8gQW5jaG9yIGlzIGN1cnJlbnRseSB0aGUgb2xkZXIgZXJhIHRvIG1hdGNoIGV0aGlvYWEsIGJ1dCBzaG91bGQgaXQgYmUgdGhlIG5ld2VyIGVyYT9cbi8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9lY21hNDAyL2lzc3Vlcy81MzQgZm9yIGRpc2N1c3Npb24uXG5jbGFzcyBFdGhpb3BpY0hlbHBlciBleHRlbmRzIE9ydGhvZG94QmFzZUhlbHBlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCdldGhpb3BpYycsIFtcbiAgICAgICAgICAgIHsgbmFtZTogJ2VyYTAnLCBpc29FcG9jaDogeyB5ZWFyOiAtNTQ5MiwgbW9udGg6IDcsIGRheTogMTcgfSB9LFxuICAgICAgICAgICAgeyBuYW1lOiAnZXJhMScsIGlzb0Vwb2NoOiB7IHllYXI6IDgsIG1vbnRoOiA4LCBkYXk6IDI3IH0sIGFuY2hvckVwb2NoOiB7IHllYXI6IDU1MDEgfSB9XG4gICAgICAgIF0pO1xuICAgIH1cbn1cbmNsYXNzIFJvY0hlbHBlciBleHRlbmRzIEdyZWdvcmlhbkJhc2VIZWxwZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigncm9jJywgW1xuICAgICAgICAgICAgeyBuYW1lOiAnbWluZ3VvJywgaXNvRXBvY2g6IHsgeWVhcjogMTkxMiwgbW9udGg6IDEsIGRheTogMSB9IH0sXG4gICAgICAgICAgICB7IG5hbWU6ICdiZWZvcmUtcm9jJywgcmV2ZXJzZU9mOiAnbWluZ3VvJyB9XG4gICAgICAgIF0pO1xuICAgICAgICB0aGlzLmNhbGVuZGFySXNWdWxuZXJhYmxlVG9KdWxpYW5CdWcgPSB0cnVlO1xuICAgIH1cbn1cbmNsYXNzIEJ1ZGRoaXN0SGVscGVyIGV4dGVuZHMgR3JlZ29yaWFuQmFzZUhlbHBlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCdidWRkaGlzdCcsIFt7IG5hbWU6ICdiZScsIGhhc1llYXJaZXJvOiB0cnVlLCBpc29FcG9jaDogeyB5ZWFyOiAtNTQzLCBtb250aDogMSwgZGF5OiAxIH0gfV0pO1xuICAgICAgICB0aGlzLmNhbGVuZGFySXNWdWxuZXJhYmxlVG9KdWxpYW5CdWcgPSB0cnVlO1xuICAgIH1cbn1cbmNsYXNzIEdyZWdvcnlIZWxwZXIgZXh0ZW5kcyBHcmVnb3JpYW5CYXNlSGVscGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoJ2dyZWdvcnknLCBbXG4gICAgICAgICAgICB7IG5hbWU6ICdjZScsIGlzb0Vwb2NoOiB7IHllYXI6IDEsIG1vbnRoOiAxLCBkYXk6IDEgfSB9LFxuICAgICAgICAgICAgeyBuYW1lOiAnYmNlJywgcmV2ZXJzZU9mOiAnY2UnIH1cbiAgICAgICAgXSk7XG4gICAgfVxuICAgIHJldmlzZUludGxFcmEoY2FsZW5kYXJEYXRlIC8qLCBpc29EYXRlOiBJc29EYXRlKi8pIHtcbiAgICAgICAgbGV0IHsgZXJhLCBlcmFZZWFyIH0gPSBjYWxlbmRhckRhdGU7XG4gICAgICAgIC8vIEZpcmVmb3ggOTYgaW50cm9kdWNlZCBhIGJ1ZyB3aGVyZSB0aGUgYCdzaG9ydCdgIGZvcm1hdCBvZiB0aGUgZXJhXG4gICAgICAgIC8vIG9wdGlvbiBtaXN0YWtlbmx5IHJldHVybnMgdGhlIG9uZS1sZXR0ZXIgKG5hcnJvdykgZm9ybWF0IGluc3RlYWQuIFRoZVxuICAgICAgICAvLyBjb2RlIGJlbG93IGhhbmRsZXMgZWl0aGVyIHRoZSBjb3JyZWN0IG9yIEZpcmVmb3gtYnVnZ3kgZm9ybWF0LiBTZWVcbiAgICAgICAgLy8gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTc1MjI1M1xuICAgICAgICBpZiAoZXJhID09PSAnYmMnIHx8IGVyYSA9PT0gJ2InKVxuICAgICAgICAgICAgZXJhID0gJ2JjZSc7XG4gICAgICAgIGlmIChlcmEgPT09ICdhZCcgfHwgZXJhID09PSAnYScpXG4gICAgICAgICAgICBlcmEgPSAnY2UnO1xuICAgICAgICByZXR1cm4geyBlcmEsIGVyYVllYXIgfTtcbiAgICB9XG59XG4vLyBOT1RFOiBPbmx5IHRoZSA1IG1vZGVybiBlcmFzIChNZWlqaSBhbmQgbGF0ZXIpIGFyZSBpbmNsdWRlZC4gRm9yIGRhdGVzXG4vLyBiZWZvcmUgTWVpamkgMSwgdGhlIGBjZWAgYW5kIGBiY2VgIGVyYXMgYXJlIHVzZWQuIENoYWxsZW5nZXMgd2l0aCBwcmUtTWVpamlcbi8vIGVyYXMgaW5jbHVkZTpcbi8vIC0gU3RhcnQvZW5kIGRhdGVzIG9mIG9sZGVyIGVyYXMgYXJlIG5vdCBwcmVjaXNlbHkgZGVmaW5lZCwgd2hpY2ggaXNcbi8vICAgY2hhbGxlbmdpbmcgZ2l2ZW4gVGVtcG9yYWwncyBuZWVkIGZvciBwcmVjaXNpb25cbi8vIC0gU29tZSBlcmEgZGF0ZXMgYW5kL29yIG5hbWVzIGFyZSBkaXNwdXRlZCBieSBoaXN0b3JpYW5zXG4vLyAtIEFzIGhpc3RvcmljYWwgcmVzZWFyY2ggcHJvY2VlZHMsIG5ldyBlcmFzIGFyZSBkaXNjb3ZlcmVkIGFuZCBleGlzdGluZyBlcmFcbi8vICAgZGF0ZXMgYXJlIG1vZGlmaWVkLCBsZWFkaW5nIHRvIGNvbnNpZGVyYWJsZSBjaHVybiB3aGljaCBpcyBub3QgZ29vZCBmb3Jcbi8vICAgVGVtcG9yYWwgdXNlLlxuLy8gIC0gVGhlIGVhcmxpZXN0IGVyYSAoaW4gNjQ1IENFKSBtYXkgbm90IGVuZCB1cCBiZWluZyB0aGUgZWFybGllc3QgZGVwZW5kaW5nXG4vLyAgICBvbiBmdXR1cmUgaGlzdG9yaWNhbCBzY2hvbGFyc2hpcFxuLy8gIC0gQmVmb3JlIE1laWppLCBKYXBhbiB1c2VkIGEgbHVuYXIgKG9yIGx1bmlzb2xhcj8pIGNhbGVuZGFyIGJ1dCBBRkFJS1xuLy8gICAgdGhhdCdzIG5vdCByZWZsZWN0ZWQgaW4gdGhlIElDVSBpbXBsZW1lbnRhdGlvbi5cbi8vXG4vLyBGb3IgbW9yZSBkaXNjdXNzaW9uOiBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC10ZW1wb3JhbC9pc3N1ZXMvNTI2LlxuLy9cbi8vIEhlcmUncyBhIGZ1bGwgbGlzdCBvZiBDTERSL0lDVSBlcmFzOlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3VuaWNvZGUtb3JnL2ljdS9ibG9iL21hc3Rlci9pY3U0Yy9zb3VyY2UvZGF0YS9sb2NhbGVzL3Jvb3QudHh0I0wxNTgyLUwxODE4XG4vLyBodHRwczovL2dpdGh1Yi5jb20vdW5pY29kZS1vcmcvY2xkci9ibG9iL21hc3Rlci9jb21tb24vc3VwcGxlbWVudGFsL3N1cHBsZW1lbnRhbERhdGEueG1sI0w0MzEwLUw0NTQ2XG4vL1xuLy8gTk9URTogSmFwYW4gc3RhcnRlZCB1c2luZyB0aGUgR3JlZ29yaWFuIGNhbGVuZGFyIGluIDYgTWVpamksIHJlcGxhY2luZyBhXG4vLyBsdW5pc29sYXIgY2FsZW5kYXIuIFNvIHRoZSBkYXkgYmVmb3JlIEphbnVhcnkgMSBvZiA2IE1laWppICgxODczKSB3YXMgbm90XG4vLyBEZWNlbWJlciAzMSwgYnV0IERlY2VtYmVyIDIsIG9mIDUgTWVpamkgKDE4NzIpLiBUaGUgZXhpc3RpbmcgRWNtYS00MDJcbi8vIEphcGFuZXNlIGNhbGVuZGFyIGRvZXNuJ3Qgc2VlbSB0byB0YWtlIHRoaXMgaW50byBhY2NvdW50LCBzbyBuZWl0aGVyIGRvIHdlOlxuLy8gPiBhcmdzID0gWydlbi1jYS11LWNhLWphcGFuZXNlJywgeyBlcmE6ICdzaG9ydCcgfV1cbi8vID4gbmV3IERhdGUoJzE4NzMtMDEtMDFUMTI6MDAnKS50b0xvY2FsZVN0cmluZyguLi5hcmdzKVxuLy8gJzEgMSwgNiBNZWlqaSwgMTI6MDA6MDAgUE0nXG4vLyA+IG5ldyBEYXRlKCcxODcyLTEyLTMxVDEyOjAwJykudG9Mb2NhbGVTdHJpbmcoLi4uYXJncylcbi8vICcxMiAzMSwgNSBNZWlqaSwgMTI6MDA6MDAgUE0nXG5jbGFzcyBKYXBhbmVzZUhlbHBlciBleHRlbmRzIEdyZWdvcmlhbkJhc2VIZWxwZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcignamFwYW5lc2UnLCBbXG4gICAgICAgICAgICAvLyBUaGUgSmFwYW5lc2UgY2FsZW5kYXIgYHllYXJgIGlzIGp1c3QgdGhlIElTTyB5ZWFyLCBiZWNhdXNlICh1bmxpa2Ugb3RoZXJcbiAgICAgICAgICAgIC8vIElDVSBjYWxlbmRhcnMpIHRoZXJlJ3Mgbm8gb2J2aW91cyBcImRlZmF1bHQgZXJhXCIsIHdlIHVzZSB0aGUgSVNPIHllYXIuXG4gICAgICAgICAgICB7IG5hbWU6ICdyZWl3YScsIGlzb0Vwb2NoOiB7IHllYXI6IDIwMTksIG1vbnRoOiA1LCBkYXk6IDEgfSwgYW5jaG9yRXBvY2g6IHsgeWVhcjogMjAxOSwgbW9udGg6IDUsIGRheTogMSB9IH0sXG4gICAgICAgICAgICB7IG5hbWU6ICdoZWlzZWknLCBpc29FcG9jaDogeyB5ZWFyOiAxOTg5LCBtb250aDogMSwgZGF5OiA4IH0sIGFuY2hvckVwb2NoOiB7IHllYXI6IDE5ODksIG1vbnRoOiAxLCBkYXk6IDggfSB9LFxuICAgICAgICAgICAgeyBuYW1lOiAnc2hvd2EnLCBpc29FcG9jaDogeyB5ZWFyOiAxOTI2LCBtb250aDogMTIsIGRheTogMjUgfSwgYW5jaG9yRXBvY2g6IHsgeWVhcjogMTkyNiwgbW9udGg6IDEyLCBkYXk6IDI1IH0gfSxcbiAgICAgICAgICAgIHsgbmFtZTogJ3RhaXNobycsIGlzb0Vwb2NoOiB7IHllYXI6IDE5MTIsIG1vbnRoOiA3LCBkYXk6IDMwIH0sIGFuY2hvckVwb2NoOiB7IHllYXI6IDE5MTIsIG1vbnRoOiA3LCBkYXk6IDMwIH0gfSxcbiAgICAgICAgICAgIHsgbmFtZTogJ21laWppJywgaXNvRXBvY2g6IHsgeWVhcjogMTg2OCwgbW9udGg6IDksIGRheTogOCB9LCBhbmNob3JFcG9jaDogeyB5ZWFyOiAxODY4LCBtb250aDogOSwgZGF5OiA4IH0gfSxcbiAgICAgICAgICAgIHsgbmFtZTogJ2NlJywgaXNvRXBvY2g6IHsgeWVhcjogMSwgbW9udGg6IDEsIGRheTogMSB9IH0sXG4gICAgICAgICAgICB7IG5hbWU6ICdiY2UnLCByZXZlcnNlT2Y6ICdjZScgfVxuICAgICAgICBdKTtcbiAgICAgICAgdGhpcy5jYWxlbmRhcklzVnVsbmVyYWJsZVRvSnVsaWFuQnVnID0gdHJ1ZTtcbiAgICAgICAgLy8gVGhlIGxhc3QgMyBKYXBhbmVzZSBlcmFzIGNvbmZ1c2luZ2x5IHJldHVybiBvbmx5IG9uZSBjaGFyYWN0ZXIgaW4gdGhlXG4gICAgICAgIC8vIGRlZmF1bHQgXCJzaG9ydFwiIGVyYSwgc28gbmVlZCB0byB1c2UgdGhlIGxvbmcgZm9ybWF0LlxuICAgICAgICB0aGlzLmVyYUxlbmd0aCA9ICdsb25nJztcbiAgICB9XG4gICAgcmV2aXNlSW50bEVyYShjYWxlbmRhckRhdGUsIGlzb0RhdGUpIHtcbiAgICAgICAgY29uc3QgeyBlcmEsIGVyYVllYXIgfSA9IGNhbGVuZGFyRGF0ZTtcbiAgICAgICAgY29uc3QgeyB5ZWFyOiBpc29ZZWFyIH0gPSBpc29EYXRlO1xuICAgICAgICBpZiAodGhpcy5lcmFzLmZpbmQoKGUpID0+IGUubmFtZSA9PT0gZXJhKSlcbiAgICAgICAgICAgIHJldHVybiB7IGVyYSwgZXJhWWVhciB9O1xuICAgICAgICByZXR1cm4gKGlzb1llYXIgPCAxID8geyBlcmE6ICdiY2UnLCBlcmFZZWFyOiAxIC0gaXNvWWVhciB9IDogeyBlcmE6ICdjZScsIGVyYVllYXI6IGlzb1llYXIgfSk7XG4gICAgfVxufVxuY2xhc3MgQ2hpbmVzZUJhc2VIZWxwZXIgZXh0ZW5kcyBIZWxwZXJCYXNlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5jYWxlbmRhclR5cGUgPSAnbHVuaXNvbGFyJztcbiAgICAgICAgLy8gQWxsIGJ1aWx0LWluIGNhbGVuZGFycyBleGNlcHQgQ2hpbmVzZS9EYW5naSBhbmQgSGVicmV3IHVzZSBhbiBlcmFcbiAgICAgICAgdGhpcy5oYXNFcmEgPSBmYWxzZTtcbiAgICB9XG4gICAgaW5MZWFwWWVhcihjYWxlbmRhckRhdGUsIGNhY2hlKSB7XG4gICAgICAgIGNvbnN0IG1vbnRocyA9IHRoaXMuZ2V0TW9udGhMaXN0KGNhbGVuZGFyRGF0ZS55ZWFyLCBjYWNoZSk7XG4gICAgICAgIHJldHVybiBPYmplY3RFbnRyaWVzKG1vbnRocykubGVuZ3RoID09PSAxMztcbiAgICB9XG4gICAgbW9udGhzSW5ZZWFyKGNhbGVuZGFyRGF0ZSwgY2FjaGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5MZWFwWWVhcihjYWxlbmRhckRhdGUsIGNhY2hlKSA/IDEzIDogMTI7XG4gICAgfVxuICAgIG1pbmltdW1Nb250aExlbmd0aCggLyogY2FsZW5kYXJEYXRlICovKSB7XG4gICAgICAgIHJldHVybiAyOTtcbiAgICB9XG4gICAgbWF4aW11bU1vbnRoTGVuZ3RoKCAvKiBjYWxlbmRhckRhdGUgKi8pIHtcbiAgICAgICAgcmV0dXJuIDMwO1xuICAgIH1cbiAgICBnZXRNb250aExpc3QoY2FsZW5kYXJZZWFyLCBjYWNoZSkge1xuICAgICAgICBpZiAoY2FsZW5kYXJZZWFyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ01pc3NpbmcgeWVhcicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGtleSA9IEpTT04uc3RyaW5naWZ5KHsgZnVuYzogJ2dldE1vbnRoTGlzdCcsIGNhbGVuZGFyWWVhciwgaWQ6IHRoaXMuaWQgfSk7XG4gICAgICAgIGNvbnN0IGNhY2hlZCA9IGNhY2hlLmdldChrZXkpO1xuICAgICAgICBpZiAoY2FjaGVkKVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZDtcbiAgICAgICAgY29uc3QgZGF0ZVRpbWVGb3JtYXQgPSB0aGlzLmdldEZvcm1hdHRlcigpO1xuICAgICAgICBjb25zdCBnZXRDYWxlbmRhckRhdGUgPSAoaXNvWWVhciwgZGF5c1Bhc3RGZWIxKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBpc29TdHJpbmdGZWIxID0gdG9VdGNJc29EYXRlU3RyaW5nKHsgaXNvWWVhciwgaXNvTW9udGg6IDIsIGlzb0RheTogMSB9KTtcbiAgICAgICAgICAgIGNvbnN0IGxlZ2FjeURhdGUgPSBuZXcgRGF0ZShpc29TdHJpbmdGZWIxKTtcbiAgICAgICAgICAgIC8vIE5vdyBhZGQgdGhlIHJlcXVlc3RlZCBudW1iZXIgb2YgZGF5cywgd2hpY2ggbWF5IHdyYXAgdG8gdGhlIG5leHQgbW9udGguXG4gICAgICAgICAgICBsZWdhY3lEYXRlLnNldFVUQ0RhdGUoZGF5c1Bhc3RGZWIxICsgMSk7XG4gICAgICAgICAgICBjb25zdCBuZXdZZWFyR3Vlc3MgPSBkYXRlVGltZUZvcm1hdC5mb3JtYXRUb1BhcnRzKGxlZ2FjeURhdGUpO1xuICAgICAgICAgICAgY29uc3QgY2FsZW5kYXJNb250aFN0cmluZyA9IG5ld1llYXJHdWVzcy5maW5kKCh0dikgPT4gdHYudHlwZSA9PT0gJ21vbnRoJykudmFsdWU7XG4gICAgICAgICAgICBjb25zdCBjYWxlbmRhckRheSA9ICtuZXdZZWFyR3Vlc3MuZmluZCgodHYpID0+IHR2LnR5cGUgPT09ICdkYXknKS52YWx1ZTtcbiAgICAgICAgICAgIGxldCBjYWxlbmRhclllYXJUb1ZlcmlmeSA9IG5ld1llYXJHdWVzcy5maW5kKCh0dikgPT4gdHYudHlwZSA9PT0gJ3JlbGF0ZWRZZWFyJyk7XG4gICAgICAgICAgICBpZiAoY2FsZW5kYXJZZWFyVG9WZXJpZnkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGNhbGVuZGFyWWVhclRvVmVyaWZ5ID0gK2NhbGVuZGFyWWVhclRvVmVyaWZ5LnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gTm9kZSAxMiBoYXMgb3V0ZGF0ZWQgSUNVIGRhdGEgdGhhdCBsYWNrcyB0aGUgYHJlbGF0ZWRZZWFyYCBmaWVsZCBpbiB0aGVcbiAgICAgICAgICAgICAgICAvLyBvdXRwdXQgb2YgSW50bC5EYXRlVGltZUZvcm1hdC5mb3JtYXRUb1BhcnRzLlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBJbnRsLkRhdGVUaW1lRm9ybWF0LmZvcm1hdFRvUGFydHMgbGFja3MgcmVsYXRlZFllYXIgaW4gJHt0aGlzLmlkfSBjYWxlbmRhci4gVHJ5IE5vZGUgMTQrIG9yIG1vZGVybiBicm93c2Vycy5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7IGNhbGVuZGFyTW9udGhTdHJpbmcsIGNhbGVuZGFyRGF5LCBjYWxlbmRhclllYXJUb1ZlcmlmeSB9O1xuICAgICAgICB9O1xuICAgICAgICAvLyBGaXJzdCwgZmluZCBhIGRhdGUgY2xvc2UgdG8gQ2hpbmVzZSBOZXcgWWVhci4gRmViIDE3IHdpbGwgZWl0aGVyIGJlIGluXG4gICAgICAgIC8vIHRoZSBmaXJzdCBtb250aCBvciBuZWFyIHRoZSBlbmQgb2YgdGhlIGxhc3QgbW9udGggb2YgdGhlIHByZXZpb3VzIHllYXIuXG4gICAgICAgIGxldCBpc29EYXlzRGVsdGEgPSAxNztcbiAgICAgICAgbGV0IHsgY2FsZW5kYXJNb250aFN0cmluZywgY2FsZW5kYXJEYXksIGNhbGVuZGFyWWVhclRvVmVyaWZ5IH0gPSBnZXRDYWxlbmRhckRhdGUoY2FsZW5kYXJZZWFyLCBpc29EYXlzRGVsdGEpO1xuICAgICAgICAvLyBJZiB3ZSBkaWRuJ3QgZ3Vlc3MgdGhlIGZpcnN0IG1vbnRoIGNvcnJlY3RseSwgYWRkIChhbG1vc3QgaW4gc29tZSBtb250aHMpXG4gICAgICAgIC8vIGEgbHVuYXIgbW9udGhcbiAgICAgICAgaWYgKGNhbGVuZGFyTW9udGhTdHJpbmcgIT09ICcxJykge1xuICAgICAgICAgICAgaXNvRGF5c0RlbHRhICs9IDI5O1xuICAgICAgICAgICAgKHsgY2FsZW5kYXJNb250aFN0cmluZywgY2FsZW5kYXJEYXkgfSA9IGdldENhbGVuZGFyRGF0ZShjYWxlbmRhclllYXIsIGlzb0RheXNEZWx0YSkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5vdyBiYWNrIHVwIHRvIG5lYXIgdGhlIHN0YXJ0IG9mIHRoZSBmaXJzdCBtb250aCwgYnV0IG5vdCB0b28gbmVhciB0aGF0XG4gICAgICAgIC8vIG9mZi1ieS1vbmUgaXNzdWVzIG1hdHRlci5cbiAgICAgICAgaXNvRGF5c0RlbHRhIC09IGNhbGVuZGFyRGF5IC0gNTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgICAgIGxldCBtb250aEluZGV4ID0gMTtcbiAgICAgICAgbGV0IG9sZENhbGVuZGFyRGF5O1xuICAgICAgICBsZXQgb2xkTW9udGhTdHJpbmc7XG4gICAgICAgIGxldCBkb25lID0gZmFsc2U7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgICh7IGNhbGVuZGFyTW9udGhTdHJpbmcsIGNhbGVuZGFyRGF5LCBjYWxlbmRhclllYXJUb1ZlcmlmeSB9ID0gZ2V0Q2FsZW5kYXJEYXRlKGNhbGVuZGFyWWVhciwgaXNvRGF5c0RlbHRhKSk7XG4gICAgICAgICAgICBpZiAob2xkQ2FsZW5kYXJEYXkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRbb2xkTW9udGhTdHJpbmddLmRheXNJbk1vbnRoID0gb2xkQ2FsZW5kYXJEYXkgKyAzMCAtIGNhbGVuZGFyRGF5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNhbGVuZGFyWWVhclRvVmVyaWZ5ICE9PSBjYWxlbmRhclllYXIpIHtcbiAgICAgICAgICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdFtjYWxlbmRhck1vbnRoU3RyaW5nXSA9IHsgbW9udGhJbmRleDogbW9udGhJbmRleCsrIH07XG4gICAgICAgICAgICAgICAgLy8gTW92ZSB0byB0aGUgbmV4dCBtb250aC4gQmVjYXVzZSBtb250aHMgYXJlIHNvbWV0aW1lcyAyOSBkYXlzLCB0aGUgZGF5IG9mIHRoZVxuICAgICAgICAgICAgICAgIC8vIGNhbGVuZGFyIG1vbnRoIHdpbGwgbW92ZSBmb3J3YXJkIHNsb3dseSBidXQgbm90IGVub3VnaCB0byBmbGlwIG92ZXIgdG8gYSBuZXdcbiAgICAgICAgICAgICAgICAvLyBtb250aCBiZWZvcmUgdGhlIGxvb3AgZW5kcyBhdCAxMi0xMyBtb250aHMuXG4gICAgICAgICAgICAgICAgaXNvRGF5c0RlbHRhICs9IDMwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2xkQ2FsZW5kYXJEYXkgPSBjYWxlbmRhckRheTtcbiAgICAgICAgICAgIG9sZE1vbnRoU3RyaW5nID0gY2FsZW5kYXJNb250aFN0cmluZztcbiAgICAgICAgfSB3aGlsZSAoIWRvbmUpO1xuICAgICAgICByZXN1bHRbb2xkTW9udGhTdHJpbmddLmRheXNJbk1vbnRoID0gb2xkQ2FsZW5kYXJEYXkgKyAzMCAtIGNhbGVuZGFyRGF5O1xuICAgICAgICBjYWNoZS5zZXQoa2V5LCByZXN1bHQpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBlc3RpbWF0ZUlzb0RhdGUoY2FsZW5kYXJEYXRlKSB7XG4gICAgICAgIGNvbnN0IHsgeWVhciwgbW9udGggfSA9IGNhbGVuZGFyRGF0ZTtcbiAgICAgICAgcmV0dXJuIHsgeWVhciwgbW9udGg6IG1vbnRoID49IDEyID8gMTIgOiBtb250aCArIDEsIGRheTogMSB9O1xuICAgIH1cbiAgICBhZGp1c3RDYWxlbmRhckRhdGUoY2FsZW5kYXJEYXRlLCBjYWNoZSwgb3ZlcmZsb3cgPSAnY29uc3RyYWluJywgZnJvbUxlZ2FjeURhdGUgPSBmYWxzZSkge1xuICAgICAgICBsZXQgeyB5ZWFyLCBtb250aCwgbW9udGhFeHRyYSwgZGF5LCBtb250aENvZGUsIGVyYVllYXIgfSA9IGNhbGVuZGFyRGF0ZTtcbiAgICAgICAgaWYgKGZyb21MZWdhY3lEYXRlKSB7XG4gICAgICAgICAgICAvLyBMZWdhY3kgRGF0ZSBvdXRwdXQgcmV0dXJucyBhIHN0cmluZyB0aGF0J3MgYW4gaW50ZWdlciB3aXRoIGFuIG9wdGlvbmFsXG4gICAgICAgICAgICAvLyBcImJpc1wiIHN1ZmZpeCB1c2VkIG9ubHkgYnkgdGhlIENoaW5lc2UvRGFuZ2kgY2FsZW5kYXIgdG8gaW5kaWNhdGUgYSBsZWFwXG4gICAgICAgICAgICAvLyBtb250aC4gQmVsb3cgd2UnbGwgbm9ybWFsaXplIHRoZSBvdXRwdXQuXG4gICAgICAgICAgICB5ZWFyID0gZXJhWWVhcjtcbiAgICAgICAgICAgIGlmIChtb250aEV4dHJhICYmIG1vbnRoRXh0cmEgIT09ICdiaXMnKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBVbmV4cGVjdGVkIGxlYXAgbW9udGggc3VmZml4OiAke21vbnRoRXh0cmF9YCk7XG4gICAgICAgICAgICBjb25zdCBtb250aENvZGUgPSBidWlsZE1vbnRoQ29kZShtb250aCwgbW9udGhFeHRyYSAhPT0gdW5kZWZpbmVkKTtcbiAgICAgICAgICAgIGNvbnN0IG1vbnRoU3RyaW5nID0gYCR7bW9udGh9JHttb250aEV4dHJhIHx8ICcnfWA7XG4gICAgICAgICAgICBjb25zdCBtb250aHMgPSB0aGlzLmdldE1vbnRoTGlzdCh5ZWFyLCBjYWNoZSk7XG4gICAgICAgICAgICBjb25zdCBtb250aEluZm8gPSBtb250aHNbbW9udGhTdHJpbmddO1xuICAgICAgICAgICAgaWYgKG1vbnRoSW5mbyA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBVbm1hdGNoZWQgbW9udGggJHttb250aFN0cmluZ30gaW4gQ2hpbmVzZSB5ZWFyICR7eWVhcn1gKTtcbiAgICAgICAgICAgIG1vbnRoID0gbW9udGhJbmZvLm1vbnRoSW5kZXg7XG4gICAgICAgICAgICByZXR1cm4geyB5ZWFyOiB5ZWFyLCBtb250aCwgZGF5OiBkYXksIGVyYTogdW5kZWZpbmVkLCBlcmFZZWFyLCBtb250aENvZGUgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIFdoZW4gY2FsbGVkIHdpdGhvdXQgaW5wdXQgY29taW5nIGZyb20gbGVnYWN5IERhdGUgb3V0cHV0LFxuICAgICAgICAgICAgLy8gc2ltcGx5IGVuc3VyZSB0aGF0IGFsbCBmaWVsZHMgYXJlIHByZXNlbnQuXG4gICAgICAgICAgICB0aGlzLnZhbGlkYXRlQ2FsZW5kYXJEYXRlKGNhbGVuZGFyRGF0ZSk7XG4gICAgICAgICAgICBpZiAoeWVhciA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIHllYXIgPSBlcmFZZWFyO1xuICAgICAgICAgICAgaWYgKGVyYVllYXIgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICBlcmFZZWFyID0geWVhcjtcbiAgICAgICAgICAgIGlmIChtb250aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbW9udGhzID0gdGhpcy5nZXRNb250aExpc3QoeWVhciwgY2FjaGUpO1xuICAgICAgICAgICAgICAgIGxldCBudW1iZXJQYXJ0ID0gbW9udGhDb2RlLnJlcGxhY2UoJ0wnLCAnYmlzJykuc2xpY2UoMSk7XG4gICAgICAgICAgICAgICAgaWYgKG51bWJlclBhcnRbMF0gPT09ICcwJylcbiAgICAgICAgICAgICAgICAgICAgbnVtYmVyUGFydCA9IG51bWJlclBhcnQuc2xpY2UoMSk7XG4gICAgICAgICAgICAgICAgbGV0IG1vbnRoSW5mbyA9IG1vbnRoc1tudW1iZXJQYXJ0XTtcbiAgICAgICAgICAgICAgICBtb250aCA9IG1vbnRoSW5mbyAmJiBtb250aEluZm8ubW9udGhJbmRleDtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGlzIGxlYXAgbW9udGggaXNuJ3QgcHJlc2VudCBpbiB0aGlzIHllYXIsIGNvbnN0cmFpbiBkb3duIHRvIHRoZSBsYXN0IGRheSBvZiB0aGUgcHJldmlvdXMgbW9udGguXG4gICAgICAgICAgICAgICAgaWYgKG1vbnRoID09PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgbW9udGhDb2RlLmVuZHNXaXRoKCdMJykgJiZcbiAgICAgICAgICAgICAgICAgICAgIUFycmF5SW5jbHVkZXMuY2FsbChbJ00wMUwnLCAnTTEyTCcsICdNMTNMJ10sIG1vbnRoQ29kZSkgJiZcbiAgICAgICAgICAgICAgICAgICAgb3ZlcmZsb3cgPT09ICdjb25zdHJhaW4nKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB3aXRob3V0TUwgPSBtb250aENvZGUuc2xpY2UoMSwgLTEpO1xuICAgICAgICAgICAgICAgICAgICBpZiAod2l0aG91dE1MWzBdID09PSAnMCcpXG4gICAgICAgICAgICAgICAgICAgICAgICB3aXRob3V0TUwgPSB3aXRob3V0TUwuc2xpY2UoMSk7XG4gICAgICAgICAgICAgICAgICAgIG1vbnRoSW5mbyA9IG1vbnRoc1t3aXRob3V0TUxdO1xuICAgICAgICAgICAgICAgICAgICBpZiAobW9udGhJbmZvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAoeyBkYXlzSW5Nb250aDogZGF5LCBtb250aEluZGV4OiBtb250aCB9ID0gbW9udGhJbmZvKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vbnRoQ29kZSA9IGJ1aWxkTW9udGhDb2RlKHdpdGhvdXRNTCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG1vbnRoID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYFVubWF0Y2hlZCBtb250aCAke21vbnRoQ29kZX0gaW4gQ2hpbmVzZSB5ZWFyICR7eWVhcn1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChtb250aENvZGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1vbnRocyA9IHRoaXMuZ2V0TW9udGhMaXN0KHllYXIsIGNhY2hlKTtcbiAgICAgICAgICAgICAgICBjb25zdCBtb250aEVudHJpZXMgPSBPYmplY3RFbnRyaWVzKG1vbnRocyk7XG4gICAgICAgICAgICAgICAgY29uc3QgbGFyZ2VzdE1vbnRoID0gbW9udGhFbnRyaWVzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBpZiAob3ZlcmZsb3cgPT09ICdyZWplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgIFJlamVjdFRvUmFuZ2UobW9udGgsIDEsIGxhcmdlc3RNb250aCk7XG4gICAgICAgICAgICAgICAgICAgIFJlamVjdFRvUmFuZ2UoZGF5LCAxLCB0aGlzLm1heGltdW1Nb250aExlbmd0aCgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG1vbnRoID0gQ29uc3RyYWluVG9SYW5nZShtb250aCwgMSwgbGFyZ2VzdE1vbnRoKTtcbiAgICAgICAgICAgICAgICAgICAgZGF5ID0gQ29uc3RyYWluVG9SYW5nZShkYXksIDEsIHRoaXMubWF4aW11bU1vbnRoTGVuZ3RoKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBtYXRjaGluZ01vbnRoRW50cnkgPSBtb250aEVudHJpZXMuZmluZCgoWywgdl0pID0+IHYubW9udGhJbmRleCA9PT0gbW9udGgpO1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaGluZ01vbnRoRW50cnkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgSW52YWxpZCBtb250aCAke21vbnRofSBpbiBDaGluZXNlIHllYXIgJHt5ZWFyfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtb250aENvZGUgPSBidWlsZE1vbnRoQ29kZShtYXRjaGluZ01vbnRoRW50cnlbMF0ucmVwbGFjZSgnYmlzJywgJycpLCBtYXRjaGluZ01vbnRoRW50cnlbMF0uaW5kZXhPZignYmlzJykgIT09IC0xKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEJvdGggbW9udGggYW5kIG1vbnRoQ29kZSBhcmUgcHJlc2VudC4gTWFrZSBzdXJlIHRoZXkgZG9uJ3QgY29uZmxpY3QuXG4gICAgICAgICAgICAgICAgY29uc3QgbW9udGhzID0gdGhpcy5nZXRNb250aExpc3QoeWVhciwgY2FjaGUpO1xuICAgICAgICAgICAgICAgIGxldCBudW1iZXJQYXJ0ID0gbW9udGhDb2RlLnJlcGxhY2UoJ0wnLCAnYmlzJykuc2xpY2UoMSk7XG4gICAgICAgICAgICAgICAgaWYgKG51bWJlclBhcnRbMF0gPT09ICcwJylcbiAgICAgICAgICAgICAgICAgICAgbnVtYmVyUGFydCA9IG51bWJlclBhcnQuc2xpY2UoMSk7XG4gICAgICAgICAgICAgICAgY29uc3QgbW9udGhJbmZvID0gbW9udGhzW251bWJlclBhcnRdO1xuICAgICAgICAgICAgICAgIGlmICghbW9udGhJbmZvKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgVW5tYXRjaGVkIG1vbnRoQ29kZSAke21vbnRoQ29kZX0gaW4gQ2hpbmVzZSB5ZWFyICR7eWVhcn1gKTtcbiAgICAgICAgICAgICAgICBpZiAobW9udGggIT09IG1vbnRoSW5mby5tb250aEluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBtb250aENvZGUgJHttb250aENvZGV9IGRvZXNuJ3QgY29ycmVzcG9uZCB0byBtb250aCAke21vbnRofSBpbiBDaGluZXNlIHllYXIgJHt5ZWFyfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgLi4uY2FsZW5kYXJEYXRlLFxuICAgICAgICAgICAgICAgIHllYXI6IHllYXIsXG4gICAgICAgICAgICAgICAgZXJhWWVhcixcbiAgICAgICAgICAgICAgICBtb250aCxcbiAgICAgICAgICAgICAgICBtb250aENvZGU6IG1vbnRoQ29kZSxcbiAgICAgICAgICAgICAgICBkYXk6IGRheVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmNsYXNzIENoaW5lc2VIZWxwZXIgZXh0ZW5kcyBDaGluZXNlQmFzZUhlbHBlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuaWQgPSAnY2hpbmVzZSc7XG4gICAgfVxufVxuLy8gRGFuZ2kgKEtvcmVhbikgY2FsZW5kYXIgaGFzIHNhbWUgaW1wbGVtZW50YXRpb24gYXMgQ2hpbmVzZVxuY2xhc3MgRGFuZ2lIZWxwZXIgZXh0ZW5kcyBDaGluZXNlQmFzZUhlbHBlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuaWQgPSAnZGFuZ2knO1xuICAgIH1cbn1cbi8qKlxuICogQ29tbW9uIGltcGxlbWVudGF0aW9uIG9mIGFsbCBub24tSVNPIGNhbGVuZGFycy5cbiAqIFBlci1jYWxlbmRhciBpZCBhbmQgbG9naWMgbGl2ZSBpbiBgaWRgIGFuZCBgaGVscGVyYCBwcm9wZXJ0aWVzIGF0dGFjaGVkIGxhdGVyLlxuICogVGhpcyBzcGxpdCBhbGxvd2VkIGFuIGVhc3kgc2VwYXJhdGlvbiBiZXR3ZWVuIGNvZGUgdGhhdCB3YXMgc2ltaWxhciBiZXR3ZWVuXG4gKiBJU08gYW5kIG5vbi1JU08gaW1wbGVtZW50YXRpb25zIHZzLiBjb2RlIHRoYXQgd2FzIHZlcnkgZGlmZmVyZW50LlxuICovXG5jb25zdCBub25Jc29JbXBsID0ge1xuICAgIC8vIGBoZWxwZXJgIGlzIGFkZGVkIHdoZW4gdGhpcyBvYmplY3QgaXMgc3ByZWFkIGludG8gZWFjaCBjYWxlbmRhcidzXG4gICAgLy8gaW1wbGVtZW50YXRpb25cbiAgICBoZWxwZXI6IHVuZGVmaW5lZCxcbiAgICBkYXRlRnJvbUZpZWxkcyhmaWVsZHNQYXJhbSwgb3B0aW9ucywgY2FsZW5kYXIpIHtcbiAgICAgICAgY29uc3Qgb3ZlcmZsb3cgPSBUb1RlbXBvcmFsT3ZlcmZsb3cob3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IGNhY2hlID0gbmV3IE9uZU9iamVjdENhY2hlKCk7XG4gICAgICAgIC8vIEludGVudGlvbmFsbHkgYWxwaGFiZXRpY2FsXG4gICAgICAgIGNvbnN0IGZpZWxkcyA9IFByZXBhcmVUZW1wb3JhbEZpZWxkcyhmaWVsZHNQYXJhbSwgW1xuICAgICAgICAgICAgWydkYXknXSxcbiAgICAgICAgICAgIFsnZXJhJywgdW5kZWZpbmVkXSxcbiAgICAgICAgICAgIFsnZXJhWWVhcicsIHVuZGVmaW5lZF0sXG4gICAgICAgICAgICBbJ21vbnRoJywgdW5kZWZpbmVkXSxcbiAgICAgICAgICAgIFsnbW9udGhDb2RlJywgdW5kZWZpbmVkXSxcbiAgICAgICAgICAgIFsneWVhcicsIHVuZGVmaW5lZF1cbiAgICAgICAgXSk7XG4gICAgICAgIGNvbnN0IHsgeWVhciwgbW9udGgsIGRheSB9ID0gdGhpcy5oZWxwZXIuY2FsZW5kYXJUb0lzb0RhdGUoZmllbGRzLCBvdmVyZmxvdywgY2FjaGUpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBDcmVhdGVUZW1wb3JhbERhdGUoeWVhciwgbW9udGgsIGRheSwgY2FsZW5kYXIpO1xuICAgICAgICBjYWNoZS5zZXRPYmplY3QocmVzdWx0KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuICAgIHllYXJNb250aEZyb21GaWVsZHMoZmllbGRzUGFyYW0sIG9wdGlvbnMsIGNhbGVuZGFyKSB7XG4gICAgICAgIGNvbnN0IG92ZXJmbG93ID0gVG9UZW1wb3JhbE92ZXJmbG93KG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBjYWNoZSA9IG5ldyBPbmVPYmplY3RDYWNoZSgpO1xuICAgICAgICAvLyBJbnRlbnRpb25hbGx5IGFscGhhYmV0aWNhbFxuICAgICAgICBjb25zdCBmaWVsZHMgPSBQcmVwYXJlVGVtcG9yYWxGaWVsZHMoZmllbGRzUGFyYW0sIFtcbiAgICAgICAgICAgIFsnZXJhJywgdW5kZWZpbmVkXSxcbiAgICAgICAgICAgIFsnZXJhWWVhcicsIHVuZGVmaW5lZF0sXG4gICAgICAgICAgICBbJ21vbnRoJywgdW5kZWZpbmVkXSxcbiAgICAgICAgICAgIFsnbW9udGhDb2RlJywgdW5kZWZpbmVkXSxcbiAgICAgICAgICAgIFsneWVhcicsIHVuZGVmaW5lZF1cbiAgICAgICAgXSk7XG4gICAgICAgIGNvbnN0IHsgeWVhciwgbW9udGgsIGRheSB9ID0gdGhpcy5oZWxwZXIuY2FsZW5kYXJUb0lzb0RhdGUoeyAuLi5maWVsZHMsIGRheTogMSB9LCBvdmVyZmxvdywgY2FjaGUpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBDcmVhdGVUZW1wb3JhbFllYXJNb250aCh5ZWFyLCBtb250aCwgY2FsZW5kYXIsIC8qIHJlZmVyZW5jZUlTT0RheSA9ICovIGRheSk7XG4gICAgICAgIGNhY2hlLnNldE9iamVjdChyZXN1bHQpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG4gICAgbW9udGhEYXlGcm9tRmllbGRzKGZpZWxkc1BhcmFtLCBvcHRpb25zLCBjYWxlbmRhcikge1xuICAgICAgICBjb25zdCBvdmVyZmxvdyA9IFRvVGVtcG9yYWxPdmVyZmxvdyhvcHRpb25zKTtcbiAgICAgICAgLy8gQWxsIGJ1aWx0LWluIGNhbGVuZGFycyByZXF1aXJlIGBkYXlgLCBidXQgc29tZSBhbGxvdyBvdGhlciBmaWVsZHMgdG8gYmVcbiAgICAgICAgLy8gc3Vic3RpdHV0ZWQgZm9yIGBtb250aGAuIEFuZCBmb3IgbHVuaXNvbGFyIGNhbGVuZGFycywgZWl0aGVyIGBtb250aENvZGVgXG4gICAgICAgIC8vIG9yIGB5ZWFyYCBtdXN0IGJlIHByb3ZpZGVkIGJlY2F1c2UgYG1vbnRoYCBpcyBhbWJpZ3VvdXMgd2l0aG91dCBhIHllYXIgb3JcbiAgICAgICAgLy8gYSBjb2RlLlxuICAgICAgICBjb25zdCBjYWNoZSA9IG5ldyBPbmVPYmplY3RDYWNoZSgpO1xuICAgICAgICBjb25zdCBmaWVsZHMgPSBQcmVwYXJlVGVtcG9yYWxGaWVsZHMoZmllbGRzUGFyYW0sIFtcbiAgICAgICAgICAgIFsnZGF5J10sXG4gICAgICAgICAgICBbJ2VyYScsIHVuZGVmaW5lZF0sXG4gICAgICAgICAgICBbJ2VyYVllYXInLCB1bmRlZmluZWRdLFxuICAgICAgICAgICAgWydtb250aCcsIHVuZGVmaW5lZF0sXG4gICAgICAgICAgICBbJ21vbnRoQ29kZScsIHVuZGVmaW5lZF0sXG4gICAgICAgICAgICBbJ3llYXInLCB1bmRlZmluZWRdXG4gICAgICAgIF0pO1xuICAgICAgICBjb25zdCB7IHllYXIsIG1vbnRoLCBkYXkgfSA9IHRoaXMuaGVscGVyLm1vbnRoRGF5RnJvbUZpZWxkcyhmaWVsZHMsIG92ZXJmbG93LCBjYWNoZSk7XG4gICAgICAgIC8vIGB5ZWFyYCBpcyBhIHJlZmVyZW5jZSB5ZWFyIHdoZXJlIHRoaXMgbW9udGgvZGF5IGV4aXN0cyBpbiB0aGlzIGNhbGVuZGFyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IENyZWF0ZVRlbXBvcmFsTW9udGhEYXkobW9udGgsIGRheSwgY2FsZW5kYXIsIC8qIHJlZmVyZW5jZUlTT1llYXIgPSAqLyB5ZWFyKTtcbiAgICAgICAgY2FjaGUuc2V0T2JqZWN0KHJlc3VsdCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcbiAgICBmaWVsZHMoZmllbGRzUGFyYW0pIHtcbiAgICAgICAgbGV0IGZpZWxkcyA9IGZpZWxkc1BhcmFtO1xuICAgICAgICBpZiAoQXJyYXlJbmNsdWRlcy5jYWxsKGZpZWxkcywgJ3llYXInKSlcbiAgICAgICAgICAgIGZpZWxkcyA9IFsuLi5maWVsZHMsICdlcmEnLCAnZXJhWWVhciddO1xuICAgICAgICByZXR1cm4gZmllbGRzO1xuICAgIH0sXG4gICAgbWVyZ2VGaWVsZHMoZmllbGRzLCBhZGRpdGlvbmFsRmllbGRzKSB7XG4gICAgICAgIGNvbnN0IGZpZWxkc0NvcHkgPSB7IC4uLmZpZWxkcyB9O1xuICAgICAgICBjb25zdCBhZGRpdGlvbmFsRmllbGRzQ29weSA9IHsgLi4uYWRkaXRpb25hbEZpZWxkcyB9O1xuICAgICAgICAvLyBlcmEgYW5kIGVyYVllYXIgYXJlIGludGVudGlvbmFsbHkgdW51c2VkXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICAgICAgY29uc3QgeyBtb250aCwgbW9udGhDb2RlLCB5ZWFyLCBlcmEsIGVyYVllYXIsIC4uLm9yaWdpbmFsIH0gPSBmaWVsZHNDb3B5O1xuICAgICAgICBjb25zdCB7IG1vbnRoOiBuZXdNb250aCwgbW9udGhDb2RlOiBuZXdNb250aENvZGUsIHllYXI6IG5ld1llYXIsIGVyYTogbmV3RXJhLCBlcmFZZWFyOiBuZXdFcmFZZWFyIH0gPSBhZGRpdGlvbmFsRmllbGRzQ29weTtcbiAgICAgICAgaWYgKG5ld01vbnRoID09PSB1bmRlZmluZWQgJiYgbmV3TW9udGhDb2RlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG9yaWdpbmFsLm1vbnRoID0gbW9udGg7XG4gICAgICAgICAgICBvcmlnaW5hbC5tb250aENvZGUgPSBtb250aENvZGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5ld1llYXIgPT09IHVuZGVmaW5lZCAmJiBuZXdFcmEgPT09IHVuZGVmaW5lZCAmJiBuZXdFcmFZZWFyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIE9ubHkgYHllYXJgIGlzIG5lZWRlZC4gV2UgZG9uJ3Qgc2V0IGVyYSBhbmQgZXJhWWVhciBiZWNhdXNlIGl0J3NcbiAgICAgICAgICAgIC8vIHBvc3NpYmxlIHRvIGNyZWF0ZSBhIGNvbmZsaWN0IGZvciBlcmFzIHRoYXQgc3RhcnQgb3IgZW5kIG1pZC15ZWFyLiBTZWVcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLXRlbXBvcmFsL2lzc3Vlcy8xNzg0LlxuICAgICAgICAgICAgb3JpZ2luYWwueWVhciA9IHllYXI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgLi4ub3JpZ2luYWwsIC4uLmFkZGl0aW9uYWxGaWVsZHNDb3B5IH07XG4gICAgfSxcbiAgICBkYXRlQWRkKGRhdGUsIHllYXJzLCBtb250aHMsIHdlZWtzLCBkYXlzLCBvdmVyZmxvdywgY2FsZW5kYXIpIHtcbiAgICAgICAgY29uc3QgY2FjaGUgPSBPbmVPYmplY3RDYWNoZS5nZXRDYWNoZUZvck9iamVjdChkYXRlKTtcbiAgICAgICAgY29uc3QgY2FsZW5kYXJEYXRlID0gdGhpcy5oZWxwZXIudGVtcG9yYWxUb0NhbGVuZGFyRGF0ZShkYXRlLCBjYWNoZSk7XG4gICAgICAgIGNvbnN0IGFkZGVkID0gdGhpcy5oZWxwZXIuYWRkQ2FsZW5kYXIoY2FsZW5kYXJEYXRlLCB7IHllYXJzLCBtb250aHMsIHdlZWtzLCBkYXlzIH0sIG92ZXJmbG93LCBjYWNoZSk7XG4gICAgICAgIGNvbnN0IGlzb0FkZGVkID0gdGhpcy5oZWxwZXIuY2FsZW5kYXJUb0lzb0RhdGUoYWRkZWQsICdjb25zdHJhaW4nLCBjYWNoZSk7XG4gICAgICAgIGNvbnN0IHsgeWVhciwgbW9udGgsIGRheSB9ID0gaXNvQWRkZWQ7XG4gICAgICAgIGNvbnN0IG5ld1RlbXBvcmFsT2JqZWN0ID0gQ3JlYXRlVGVtcG9yYWxEYXRlKHllYXIsIG1vbnRoLCBkYXksIGNhbGVuZGFyKTtcbiAgICAgICAgLy8gVGhlIG5ldyBvYmplY3QncyBjYWNoZSBzdGFydHMgd2l0aCB0aGUgY2FjaGUgb2YgdGhlIG9sZCBvYmplY3RcbiAgICAgICAgY29uc3QgbmV3Q2FjaGUgPSBuZXcgT25lT2JqZWN0Q2FjaGUoY2FjaGUpO1xuICAgICAgICBuZXdDYWNoZS5zZXRPYmplY3QobmV3VGVtcG9yYWxPYmplY3QpO1xuICAgICAgICByZXR1cm4gbmV3VGVtcG9yYWxPYmplY3Q7XG4gICAgfSxcbiAgICBkYXRlVW50aWwob25lLCB0d28sIGxhcmdlc3RVbml0KSB7XG4gICAgICAgIGNvbnN0IGNhY2hlT25lID0gT25lT2JqZWN0Q2FjaGUuZ2V0Q2FjaGVGb3JPYmplY3Qob25lKTtcbiAgICAgICAgY29uc3QgY2FjaGVUd28gPSBPbmVPYmplY3RDYWNoZS5nZXRDYWNoZUZvck9iamVjdCh0d28pO1xuICAgICAgICBjb25zdCBjYWxlbmRhck9uZSA9IHRoaXMuaGVscGVyLnRlbXBvcmFsVG9DYWxlbmRhckRhdGUob25lLCBjYWNoZU9uZSk7XG4gICAgICAgIGNvbnN0IGNhbGVuZGFyVHdvID0gdGhpcy5oZWxwZXIudGVtcG9yYWxUb0NhbGVuZGFyRGF0ZSh0d28sIGNhY2hlVHdvKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5oZWxwZXIudW50aWxDYWxlbmRhcihjYWxlbmRhck9uZSwgY2FsZW5kYXJUd28sIGxhcmdlc3RVbml0LCBjYWNoZU9uZSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcbiAgICB5ZWFyKGRhdGUpIHtcbiAgICAgICAgY29uc3QgY2FjaGUgPSBPbmVPYmplY3RDYWNoZS5nZXRDYWNoZUZvck9iamVjdChkYXRlKTtcbiAgICAgICAgY29uc3QgY2FsZW5kYXJEYXRlID0gdGhpcy5oZWxwZXIudGVtcG9yYWxUb0NhbGVuZGFyRGF0ZShkYXRlLCBjYWNoZSk7XG4gICAgICAgIHJldHVybiBjYWxlbmRhckRhdGUueWVhcjtcbiAgICB9LFxuICAgIG1vbnRoKGRhdGUpIHtcbiAgICAgICAgY29uc3QgY2FjaGUgPSBPbmVPYmplY3RDYWNoZS5nZXRDYWNoZUZvck9iamVjdChkYXRlKTtcbiAgICAgICAgY29uc3QgY2FsZW5kYXJEYXRlID0gdGhpcy5oZWxwZXIudGVtcG9yYWxUb0NhbGVuZGFyRGF0ZShkYXRlLCBjYWNoZSk7XG4gICAgICAgIHJldHVybiBjYWxlbmRhckRhdGUubW9udGg7XG4gICAgfSxcbiAgICBkYXkoZGF0ZSkge1xuICAgICAgICBjb25zdCBjYWNoZSA9IE9uZU9iamVjdENhY2hlLmdldENhY2hlRm9yT2JqZWN0KGRhdGUpO1xuICAgICAgICBjb25zdCBjYWxlbmRhckRhdGUgPSB0aGlzLmhlbHBlci50ZW1wb3JhbFRvQ2FsZW5kYXJEYXRlKGRhdGUsIGNhY2hlKTtcbiAgICAgICAgcmV0dXJuIGNhbGVuZGFyRGF0ZS5kYXk7XG4gICAgfSxcbiAgICBlcmEoZGF0ZSkge1xuICAgICAgICBpZiAoIXRoaXMuaGVscGVyLmhhc0VyYSlcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IGNhY2hlID0gT25lT2JqZWN0Q2FjaGUuZ2V0Q2FjaGVGb3JPYmplY3QoZGF0ZSk7XG4gICAgICAgIGNvbnN0IGNhbGVuZGFyRGF0ZSA9IHRoaXMuaGVscGVyLnRlbXBvcmFsVG9DYWxlbmRhckRhdGUoZGF0ZSwgY2FjaGUpO1xuICAgICAgICByZXR1cm4gY2FsZW5kYXJEYXRlLmVyYTtcbiAgICB9LFxuICAgIGVyYVllYXIoZGF0ZSkge1xuICAgICAgICBpZiAoIXRoaXMuaGVscGVyLmhhc0VyYSlcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IGNhY2hlID0gT25lT2JqZWN0Q2FjaGUuZ2V0Q2FjaGVGb3JPYmplY3QoZGF0ZSk7XG4gICAgICAgIGNvbnN0IGNhbGVuZGFyRGF0ZSA9IHRoaXMuaGVscGVyLnRlbXBvcmFsVG9DYWxlbmRhckRhdGUoZGF0ZSwgY2FjaGUpO1xuICAgICAgICByZXR1cm4gY2FsZW5kYXJEYXRlLmVyYVllYXI7XG4gICAgfSxcbiAgICBtb250aENvZGUoZGF0ZSkge1xuICAgICAgICBjb25zdCBjYWNoZSA9IE9uZU9iamVjdENhY2hlLmdldENhY2hlRm9yT2JqZWN0KGRhdGUpO1xuICAgICAgICBjb25zdCBjYWxlbmRhckRhdGUgPSB0aGlzLmhlbHBlci50ZW1wb3JhbFRvQ2FsZW5kYXJEYXRlKGRhdGUsIGNhY2hlKTtcbiAgICAgICAgcmV0dXJuIGNhbGVuZGFyRGF0ZS5tb250aENvZGU7XG4gICAgfSxcbiAgICBkYXlPZldlZWsoZGF0ZSkge1xuICAgICAgICByZXR1cm4gaW1wbFsnaXNvODYwMSddLmRheU9mV2VlayhkYXRlKTtcbiAgICB9LFxuICAgIGRheU9mWWVhcihkYXRlKSB7XG4gICAgICAgIGNvbnN0IGNhY2hlID0gT25lT2JqZWN0Q2FjaGUuZ2V0Q2FjaGVGb3JPYmplY3QoZGF0ZSk7XG4gICAgICAgIGNvbnN0IGNhbGVuZGFyRGF0ZSA9IHRoaXMuaGVscGVyLmlzb1RvQ2FsZW5kYXJEYXRlKGRhdGUsIGNhY2hlKTtcbiAgICAgICAgY29uc3Qgc3RhcnRPZlllYXIgPSB0aGlzLmhlbHBlci5zdGFydE9mQ2FsZW5kYXJZZWFyKGNhbGVuZGFyRGF0ZSk7XG4gICAgICAgIGNvbnN0IGRpZmZEYXlzID0gdGhpcy5oZWxwZXIuY2FsZW5kYXJEYXlzVW50aWwoc3RhcnRPZlllYXIsIGNhbGVuZGFyRGF0ZSwgY2FjaGUpO1xuICAgICAgICByZXR1cm4gZGlmZkRheXMgKyAxO1xuICAgIH0sXG4gICAgd2Vla09mWWVhcihkYXRlKSB7XG4gICAgICAgIHJldHVybiBpbXBsWydpc284NjAxJ10ud2Vla09mWWVhcihkYXRlKTtcbiAgICB9LFxuICAgIGRheXNJbldlZWsoZGF0ZSkge1xuICAgICAgICByZXR1cm4gaW1wbFsnaXNvODYwMSddLmRheXNJbldlZWsoZGF0ZSk7XG4gICAgfSxcbiAgICBkYXlzSW5Nb250aChkYXRlKSB7XG4gICAgICAgIGNvbnN0IGNhY2hlID0gT25lT2JqZWN0Q2FjaGUuZ2V0Q2FjaGVGb3JPYmplY3QoZGF0ZSk7XG4gICAgICAgIGNvbnN0IGNhbGVuZGFyRGF0ZSA9IHRoaXMuaGVscGVyLnRlbXBvcmFsVG9DYWxlbmRhckRhdGUoZGF0ZSwgY2FjaGUpO1xuICAgICAgICAvLyBFYXN5IGNhc2U6IGlmIHRoZSBoZWxwZXIga25vd3MgdGhlIGxlbmd0aCB3aXRob3V0IGFueSBoZWF2eSBjYWxjdWxhdGlvbi5cbiAgICAgICAgY29uc3QgbWF4ID0gdGhpcy5oZWxwZXIubWF4aW11bU1vbnRoTGVuZ3RoKGNhbGVuZGFyRGF0ZSk7XG4gICAgICAgIGNvbnN0IG1pbiA9IHRoaXMuaGVscGVyLm1pbmltdW1Nb250aExlbmd0aChjYWxlbmRhckRhdGUpO1xuICAgICAgICBpZiAobWF4ID09PSBtaW4pXG4gICAgICAgICAgICByZXR1cm4gbWF4O1xuICAgICAgICAvLyBUaGUgaGFyZGVyIGNhc2UgaXMgd2hlcmUgbW9udGhzIHZhcnkgZXZlcnkgeWVhciwgZS5nLiBpc2xhbWljIGNhbGVuZGFycy5cbiAgICAgICAgLy8gRmluZCB0aGUgYW5zd2VyIGJ5IGNhbGN1bGF0aW5nIHRoZSBkaWZmZXJlbmNlIGluIGRheXMgYmV0d2VlbiB0aGUgZmlyc3RcbiAgICAgICAgLy8gZGF5IG9mIHRoZSBjdXJyZW50IG1vbnRoIGFuZCB0aGUgZmlyc3QgZGF5IG9mIHRoZSBuZXh0IG1vbnRoLlxuICAgICAgICBjb25zdCBzdGFydE9mTW9udGhDYWxlbmRhciA9IHRoaXMuaGVscGVyLnN0YXJ0T2ZDYWxlbmRhck1vbnRoKGNhbGVuZGFyRGF0ZSk7XG4gICAgICAgIGNvbnN0IHN0YXJ0T2ZOZXh0TW9udGhDYWxlbmRhciA9IHRoaXMuaGVscGVyLmFkZE1vbnRoc0NhbGVuZGFyKHN0YXJ0T2ZNb250aENhbGVuZGFyLCAxLCAnY29uc3RyYWluJywgY2FjaGUpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLmhlbHBlci5jYWxlbmRhckRheXNVbnRpbChzdGFydE9mTW9udGhDYWxlbmRhciwgc3RhcnRPZk5leHRNb250aENhbGVuZGFyLCBjYWNoZSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcbiAgICBkYXlzSW5ZZWFyKGRhdGVQYXJhbSkge1xuICAgICAgICBsZXQgZGF0ZSA9IGRhdGVQYXJhbTtcbiAgICAgICAgaWYgKCFIYXNTbG90KGRhdGUsIElTT19ZRUFSKSlcbiAgICAgICAgICAgIGRhdGUgPSBUb1RlbXBvcmFsRGF0ZShkYXRlKTtcbiAgICAgICAgY29uc3QgY2FjaGUgPSBPbmVPYmplY3RDYWNoZS5nZXRDYWNoZUZvck9iamVjdChkYXRlKTtcbiAgICAgICAgY29uc3QgY2FsZW5kYXJEYXRlID0gdGhpcy5oZWxwZXIudGVtcG9yYWxUb0NhbGVuZGFyRGF0ZShkYXRlLCBjYWNoZSk7XG4gICAgICAgIGNvbnN0IHN0YXJ0T2ZZZWFyQ2FsZW5kYXIgPSB0aGlzLmhlbHBlci5zdGFydE9mQ2FsZW5kYXJZZWFyKGNhbGVuZGFyRGF0ZSk7XG4gICAgICAgIGNvbnN0IHN0YXJ0T2ZOZXh0WWVhckNhbGVuZGFyID0gdGhpcy5oZWxwZXIuYWRkQ2FsZW5kYXIoc3RhcnRPZlllYXJDYWxlbmRhciwgeyB5ZWFyczogMSB9LCAnY29uc3RyYWluJywgY2FjaGUpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLmhlbHBlci5jYWxlbmRhckRheXNVbnRpbChzdGFydE9mWWVhckNhbGVuZGFyLCBzdGFydE9mTmV4dFllYXJDYWxlbmRhciwgY2FjaGUpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG4gICAgbW9udGhzSW5ZZWFyKGRhdGUpIHtcbiAgICAgICAgY29uc3QgY2FjaGUgPSBPbmVPYmplY3RDYWNoZS5nZXRDYWNoZUZvck9iamVjdChkYXRlKTtcbiAgICAgICAgY29uc3QgY2FsZW5kYXJEYXRlID0gdGhpcy5oZWxwZXIudGVtcG9yYWxUb0NhbGVuZGFyRGF0ZShkYXRlLCBjYWNoZSk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuaGVscGVyLm1vbnRoc0luWWVhcihjYWxlbmRhckRhdGUsIGNhY2hlKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuICAgIGluTGVhcFllYXIoZGF0ZVBhcmFtKSB7XG4gICAgICAgIGxldCBkYXRlID0gZGF0ZVBhcmFtO1xuICAgICAgICBpZiAoIUhhc1Nsb3QoZGF0ZSwgSVNPX1lFQVIpKVxuICAgICAgICAgICAgZGF0ZSA9IFRvVGVtcG9yYWxEYXRlKGRhdGUpO1xuICAgICAgICBjb25zdCBjYWNoZSA9IE9uZU9iamVjdENhY2hlLmdldENhY2hlRm9yT2JqZWN0KGRhdGUpO1xuICAgICAgICBjb25zdCBjYWxlbmRhckRhdGUgPSB0aGlzLmhlbHBlci50ZW1wb3JhbFRvQ2FsZW5kYXJEYXRlKGRhdGUsIGNhY2hlKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5oZWxwZXIuaW5MZWFwWWVhcihjYWxlbmRhckRhdGUsIGNhY2hlKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59O1xuZm9yIChjb25zdCBIZWxwZXIgb2YgW1xuICAgIEhlYnJld0hlbHBlcixcbiAgICBQZXJzaWFuSGVscGVyLFxuICAgIEV0aGlvcGljSGVscGVyLFxuICAgIEV0aGlvYWFIZWxwZXIsXG4gICAgQ29wdGljSGVscGVyLFxuICAgIENoaW5lc2VIZWxwZXIsXG4gICAgRGFuZ2lIZWxwZXIsXG4gICAgUm9jSGVscGVyLFxuICAgIEluZGlhbkhlbHBlcixcbiAgICBCdWRkaGlzdEhlbHBlcixcbiAgICBHcmVnb3J5SGVscGVyLFxuICAgIEphcGFuZXNlSGVscGVyLFxuICAgIElzbGFtaWNIZWxwZXIsXG4gICAgSXNsYW1pY1VtYWxxdXJhSGVscGVyLFxuICAgIElzbGFtaWNUYmxhSGVscGVyLFxuICAgIElzbGFtaWNDaXZpbEhlbHBlcixcbiAgICBJc2xhbWljUmdzYUhlbHBlcixcbiAgICBJc2xhbWljQ2NIZWxwZXJcbl0pIHtcbiAgICBjb25zdCBoZWxwZXIgPSBuZXcgSGVscGVyKCk7XG4gICAgLy8gQ2xvbmUgdGhlIHNpbmdsZXRvbiBub24tSVNPIGltcGxlbWVudGF0aW9uIHRoYXQncyB0aGUgc2FtZSBmb3IgYWxsXG4gICAgLy8gY2FsZW5kYXJzLiBUaGUgYGhlbHBlcmAgcHJvcGVydHkgY29udGFpbnMgcGVyLWNhbGVuZGFyIGxvZ2ljLlxuICAgIGltcGxbaGVscGVyLmlkXSA9IHsgLi4ubm9uSXNvSW1wbCwgaGVscGVyIH07XG59XG5jb25zdCBCVUlMVElOX0NBTEVOREFSX0lEUyA9IE9iamVjdC5rZXlzKGltcGwpO1xuZnVuY3Rpb24gSXNCdWlsdGluQ2FsZW5kYXIoaWQpIHtcbiAgICByZXR1cm4gQXJyYXlJbmNsdWRlcy5jYWxsKEJVSUxUSU5fQ0FMRU5EQVJfSURTLCBpZCk7XG59XG5cbmNvbnN0IHR6Q29tcG9uZW50ID0gL1xcLlstQS1aYS16X118XFwuXFwuWy1BLVphLXouX117MSwxMn18XFwuWy1BLVphLXpfXVstQS1aYS16Ll9dezAsMTJ9fFtBLVphLXpfXVstQS1aYS16Ll9dezAsMTN9LztcbmNvbnN0IG9mZnNldE5vQ2FwdHVyZSA9IC8oPzpbK1xcdTIyMTItXVswLTJdWzAtOV0oPzo6P1swLTVdWzAtOV0oPzo6P1swLTVdWzAtOV0oPzpbLixdXFxkezEsOX0pPyk/KT8pLztcbmNvbnN0IHRpbWVab25lSUQgPSBuZXcgUmVnRXhwKGAoPzooPzoke3R6Q29tcG9uZW50LnNvdXJjZX0pKD86XFxcXC8oPzoke3R6Q29tcG9uZW50LnNvdXJjZX0pKSp8RXRjL0dNVFstK11cXFxcZHsxLDJ9fCR7b2Zmc2V0Tm9DYXB0dXJlLnNvdXJjZX0pYCk7XG5jb25zdCBjYWxDb21wb25lbnQgPSAvW0EtWmEtejAtOV17Myw4fS87XG5jb25zdCBjYWxlbmRhcklEID0gbmV3IFJlZ0V4cChgKD86JHtjYWxDb21wb25lbnQuc291cmNlfSg/Oi0ke2NhbENvbXBvbmVudC5zb3VyY2V9KSopYCk7XG5jb25zdCB5ZWFycGFydCA9IC8oPzpbK1xcdTIyMTItXVxcZHs2fXxcXGR7NH0pLztcbmNvbnN0IG1vbnRocGFydCA9IC8oPzowWzEtOV18MVswLTJdKS87XG5jb25zdCBkYXlwYXJ0ID0gLyg/OjBbMS05XXxbMTJdXFxkfDNbMDFdKS87XG5jb25zdCBkYXRlc3BsaXQgPSBuZXcgUmVnRXhwKGAoJHt5ZWFycGFydC5zb3VyY2V9KSg/Oi0oJHttb250aHBhcnQuc291cmNlfSktKCR7ZGF5cGFydC5zb3VyY2V9KXwoJHttb250aHBhcnQuc291cmNlfSkoJHtkYXlwYXJ0LnNvdXJjZX0pKWApO1xuY29uc3QgdGltZXNwbGl0ID0gLyhcXGR7Mn0pKD86OihcXGR7Mn0pKD86OihcXGR7Mn0pKD86Wy4sXShcXGR7MSw5fSkpPyk/fChcXGR7Mn0pKD86KFxcZHsyfSkoPzpbLixdKFxcZHsxLDl9KSk/KT8pPy87XG5jb25zdCBvZmZzZXQgPSAvKFsrXFx1MjIxMi1dKShbMDFdWzAtOV18MlswLTNdKSg/Ojo/KFswLTVdWzAtOV0pKD86Oj8oWzAtNV1bMC05XSkoPzpbLixdKFxcZHsxLDl9KSk/KT8pPy87XG5jb25zdCB6b25lc3BsaXQgPSBuZXcgUmVnRXhwKGAoPzooW3paXSl8KD86JHtvZmZzZXQuc291cmNlfSk/KSg/OlxcXFxbKCR7dGltZVpvbmVJRC5zb3VyY2V9KVxcXFxdKT9gKTtcbmNvbnN0IGNhbGVuZGFyID0gbmV3IFJlZ0V4cChgXFxcXFt1LWNhPSgke2NhbGVuZGFySUQuc291cmNlfSlcXFxcXWApO1xuY29uc3Qgem9uZWRkYXRldGltZSA9IG5ldyBSZWdFeHAoYF4ke2RhdGVzcGxpdC5zb3VyY2V9KD86KD86VHxcXFxccyspJHt0aW1lc3BsaXQuc291cmNlfSk/JHt6b25lc3BsaXQuc291cmNlfSg/OiR7Y2FsZW5kYXIuc291cmNlfSk/JGAsICdpJyk7XG5jb25zdCB0aW1lID0gbmV3IFJlZ0V4cChgXlQ/JHt0aW1lc3BsaXQuc291cmNlfSg/OiR7em9uZXNwbGl0LnNvdXJjZX0pPyg/OiR7Y2FsZW5kYXIuc291cmNlfSk/JGAsICdpJyk7XG4vLyBUaGUgc2hvcnQgZm9ybXMgb2YgWWVhck1vbnRoIGFuZCBNb250aERheSBhcmUgb25seSBmb3IgdGhlIElTTyBjYWxlbmRhci5cbi8vIE5vbi1JU08gY2FsZW5kYXIgWWVhck1vbnRoIGFuZCBNb250aERheSBoYXZlIHRvIHBhcnNlIGFzIGEgVGVtcG9yYWwuUGxhaW5EYXRlLFxuLy8gd2l0aCB0aGUgcmVmZXJlbmNlIGZpZWxkcy5cbi8vIFlZWVlNTSBmb3JiaWRkZW4gYnkgSVNPIDg2MDEgYmVjYXVzZSBhbWJpZ3VvdXMgd2l0aCBZWU1NREQsIGJ1dCBhbGxvd2VkIGJ5XG4vLyBSRkMgMzMzOSBhbmQgd2UgZG9uJ3QgYWxsb3cgMi1kaWdpdCB5ZWFycywgc28gd2UgYWxsb3cgaXQuXG4vLyBOb3QgYW1iaWd1b3VzIHdpdGggSEhNTVNTIGJlY2F1c2UgdGhhdCByZXF1aXJlcyBhICdUJyBwcmVmaXhcbmNvbnN0IHllYXJtb250aCA9IG5ldyBSZWdFeHAoYF4oJHt5ZWFycGFydC5zb3VyY2V9KS0/KCR7bW9udGhwYXJ0LnNvdXJjZX0pJGApO1xuY29uc3QgbW9udGhkYXkgPSBuZXcgUmVnRXhwKGBeKD86LS0pPygke21vbnRocGFydC5zb3VyY2V9KS0/KCR7ZGF5cGFydC5zb3VyY2V9KSRgKTtcbmNvbnN0IGZyYWN0aW9uID0gLyhcXGQrKSg/OlsuLF0oXFxkezEsOX0pKT8vO1xuY29uc3QgZHVyYXRpb25EYXRlID0gLyg/OihcXGQrKVkpPyg/OihcXGQrKU0pPyg/OihcXGQrKVcpPyg/OihcXGQrKUQpPy87XG5jb25zdCBkdXJhdGlvblRpbWUgPSBuZXcgUmVnRXhwKGAoPzoke2ZyYWN0aW9uLnNvdXJjZX1IKT8oPzoke2ZyYWN0aW9uLnNvdXJjZX1NKT8oPzoke2ZyYWN0aW9uLnNvdXJjZX1TKT9gKTtcbmNvbnN0IGR1cmF0aW9uID0gbmV3IFJlZ0V4cChgXihbK1xcdTIyMTItXSk/UCR7ZHVyYXRpb25EYXRlLnNvdXJjZX0oPzpUKD8hJCkke2R1cmF0aW9uVGltZS5zb3VyY2V9KT8kYCwgJ2knKTtcblxuY29uc3QgQXJyYXlQcm90b3R5cGVQdXNoJDEgPSBBcnJheS5wcm90b3R5cGUucHVzaDtcbmNvbnN0IEludGxEYXRlVGltZUZvcm1hdCQxID0gZ2xvYmFsVGhpcy5JbnRsLkRhdGVUaW1lRm9ybWF0O1xuY29uc3QgTWF0aE1pbiA9IE1hdGgubWluO1xuY29uc3QgTWF0aE1heCA9IE1hdGgubWF4O1xuY29uc3QgTWF0aEFicyA9IE1hdGguYWJzO1xuY29uc3QgTWF0aEZsb29yID0gTWF0aC5mbG9vcjtcbmNvbnN0IE1hdGhTaWduID0gTWF0aC5zaWduO1xuY29uc3QgTWF0aFRydW5jID0gTWF0aC50cnVuYztcbmNvbnN0IE51bWJlcklzTmFOID0gTnVtYmVyLmlzTmFOO1xuY29uc3QgTnVtYmVySXNGaW5pdGUgPSBOdW1iZXIuaXNGaW5pdGU7XG5jb25zdCBOdW1iZXJDdG9yID0gTnVtYmVyO1xuY29uc3QgU3RyaW5nQ3RvciA9IFN0cmluZztcbmNvbnN0IE51bWJlck1heFNhZmVJbnRlZ2VyID0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVI7XG5jb25zdCBPYmplY3RDcmVhdGUkMiA9IE9iamVjdC5jcmVhdGU7XG5jb25zdCBPYmplY3REZWZpbmVQcm9wZXJ0eSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbmNvbnN0IE9iamVjdElzID0gT2JqZWN0LmlzO1xuY29uc3QgUmVmbGVjdEFwcGx5JDEgPSBSZWZsZWN0LmFwcGx5O1xuY29uc3QgWkVSTyA9IEpTQkkuQmlnSW50KDApO1xuY29uc3QgT05FID0gSlNCSS5CaWdJbnQoMSk7XG5jb25zdCBTSVhUWSA9IEpTQkkuQmlnSW50KDYwKTtcbmNvbnN0IFRIT1VTQU5EID0gSlNCSS5CaWdJbnQoMWUzKTtcbmNvbnN0IE1JTExJT04gPSBKU0JJLkJpZ0ludCgxZTYpO1xuY29uc3QgQklMTElPTiA9IEpTQkkuQmlnSW50KDFlOSk7XG5jb25zdCBORUdBVElWRV9PTkUgPSBKU0JJLkJpZ0ludCgtMSk7XG5jb25zdCBEQVlfU0VDT05EUyA9IDg2NDAwO1xuY29uc3QgREFZX05BTk9TID0gSlNCSS5tdWx0aXBseShKU0JJLkJpZ0ludChEQVlfU0VDT05EUyksIEJJTExJT04pO1xuY29uc3QgTlNfTUlOID0gSlNCSS5tdWx0aXBseShKU0JJLkJpZ0ludCgtODY0MDApLCBKU0JJLkJpZ0ludCgxZTE3KSk7XG5jb25zdCBOU19NQVggPSBKU0JJLm11bHRpcGx5KEpTQkkuQmlnSW50KDg2NDAwKSwgSlNCSS5CaWdJbnQoMWUxNykpO1xuY29uc3QgWUVBUl9NSU4gPSAtMjcxODIxO1xuY29uc3QgWUVBUl9NQVggPSAyNzU3NjA7XG5jb25zdCBCRUZPUkVfRklSU1RfT0ZGU0VUX1RSQU5TSVRJT04gPSBKU0JJLm11bHRpcGx5KEpTQkkuQmlnSW50KC0zODgxNTIpLCBKU0JJLkJpZ0ludCgxZTEzKSk7IC8vIDE4NDctMDEtMDFUMDA6MDA6MDBaXG5jb25zdCBBQk9VVF9URU5fWUVBUlNfTkFOT1MgPSBKU0JJLm11bHRpcGx5KERBWV9OQU5PUywgSlNCSS5CaWdJbnQoMzY2ICogMTApKTtcbmNvbnN0IEFCT1VUX09ORV9ZRUFSX05BTk9TID0gSlNCSS5tdWx0aXBseShEQVlfTkFOT1MsIEpTQkkuQmlnSW50KDM2NiAqIDEpKTtcbmNvbnN0IFRXT19XRUVLU19OQU5PUyA9IEpTQkkubXVsdGlwbHkoREFZX05BTk9TLCBKU0JJLkJpZ0ludCgyICogNykpO1xuZnVuY3Rpb24gSXNJbnRlZ2VyKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicgfHwgIU51bWJlcklzRmluaXRlKHZhbHVlKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGNvbnN0IGFicyA9IE1hdGhBYnModmFsdWUpO1xuICAgIHJldHVybiBNYXRoRmxvb3IoYWJzKSA9PT0gYWJzO1xufVxuZnVuY3Rpb24gSXNPYmplY3QodmFsdWUpIHtcbiAgICByZXR1cm4gKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgIT09IG51bGwpIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJztcbn1cbmZ1bmN0aW9uIFRvTnVtYmVyKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2JpZ2ludCcpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjb252ZXJ0IEJpZ0ludCB0byBudW1iZXInKTtcbiAgICByZXR1cm4gTnVtYmVyQ3Rvcih2YWx1ZSk7XG59XG5mdW5jdGlvbiBUb0ludGVnZXIodmFsdWUpIHtcbiAgICBjb25zdCBudW0gPSBUb051bWJlcih2YWx1ZSk7XG4gICAgaWYgKE51bWJlcklzTmFOKG51bSkpXG4gICAgICAgIHJldHVybiAwO1xuICAgIGNvbnN0IGludGVnZXIgPSBNYXRoVHJ1bmMobnVtKTtcbiAgICBpZiAobnVtID09PSAwKVxuICAgICAgICByZXR1cm4gMDtcbiAgICByZXR1cm4gaW50ZWdlcjtcbn1cbmZ1bmN0aW9uIFRvU3RyaW5nKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N5bWJvbCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNvbnZlcnQgYSBTeW1ib2wgdmFsdWUgdG8gYSBTdHJpbmcnKTtcbiAgICB9XG4gICAgcmV0dXJuIFN0cmluZ0N0b3IodmFsdWUpO1xufVxuZnVuY3Rpb24gVG9JbnRlZ2VyVGhyb3dPbkluZmluaXR5KHZhbHVlKSB7XG4gICAgY29uc3QgaW50ZWdlciA9IFRvSW50ZWdlcih2YWx1ZSk7XG4gICAgaWYgKCFOdW1iZXJJc0Zpbml0ZShpbnRlZ2VyKSkge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignaW5maW5pdHkgaXMgb3V0IG9mIHJhbmdlJyk7XG4gICAgfVxuICAgIHJldHVybiBpbnRlZ2VyO1xufVxuZnVuY3Rpb24gVG9Qb3NpdGl2ZUludGVnZXIodmFsdWVQYXJhbSwgcHJvcGVydHkpIHtcbiAgICBjb25zdCB2YWx1ZSA9IFRvSW50ZWdlcih2YWx1ZVBhcmFtKTtcbiAgICBpZiAoIU51bWJlcklzRmluaXRlKHZhbHVlKSkge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignaW5maW5pdHkgaXMgb3V0IG9mIHJhbmdlJyk7XG4gICAgfVxuICAgIGlmICh2YWx1ZSA8IDEpIHtcbiAgICAgICAgaWYgKHByb3BlcnR5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBwcm9wZXJ0eSAnJHtwcm9wZXJ0eX0nIGNhbm5vdCBiZSBhIGEgbnVtYmVyIGxlc3MgdGhhbiBvbmVgKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQ2Fubm90IGNvbnZlcnQgYSBudW1iZXIgbGVzcyB0aGFuIG9uZSB0byBhIHBvc2l0aXZlIGludGVnZXInKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gVG9JbnRlZ2VyV2l0aG91dFJvdW5kaW5nKHZhbHVlUGFyYW0pIHtcbiAgICBjb25zdCB2YWx1ZSA9IFRvTnVtYmVyKHZhbHVlUGFyYW0pO1xuICAgIGlmIChOdW1iZXJJc05hTih2YWx1ZSkpXG4gICAgICAgIHJldHVybiAwO1xuICAgIGlmICghTnVtYmVySXNGaW5pdGUodmFsdWUpKSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdpbmZpbml0eSBpcyBvdXQgb2YgcmFuZ2UnKTtcbiAgICB9XG4gICAgaWYgKCFJc0ludGVnZXIodmFsdWUpKSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGB1bnN1cHBvcnRlZCBmcmFjdGlvbmFsIHZhbHVlICR7dmFsdWV9YCk7XG4gICAgfVxuICAgIHJldHVybiBUb0ludGVnZXIodmFsdWUpOyAvLyDihJ0odmFsdWUpIGluIHNwZWMgdGV4dDsgY29udmVydHMgLTAgdG8gMFxufVxuZnVuY3Rpb24gZGl2bW9kKHgsIHkpIHtcbiAgICBjb25zdCBxdW90aWVudCA9IEpTQkkuZGl2aWRlKHgsIHkpO1xuICAgIGNvbnN0IHJlbWFpbmRlciA9IEpTQkkucmVtYWluZGVyKHgsIHkpO1xuICAgIHJldHVybiB7IHF1b3RpZW50LCByZW1haW5kZXIgfTtcbn1cbmZ1bmN0aW9uIGFicyh4KSB7XG4gICAgaWYgKEpTQkkubGVzc1RoYW4oeCwgWkVSTykpXG4gICAgICAgIHJldHVybiBKU0JJLm11bHRpcGx5KHgsIE5FR0FUSVZFX09ORSk7XG4gICAgcmV0dXJuIHg7XG59XG5jb25zdCBCVUlMVElOX0NBU1RTID0gbmV3IE1hcChbXG4gICAgWyd5ZWFyJywgVG9JbnRlZ2VyVGhyb3dPbkluZmluaXR5XSxcbiAgICBbJ21vbnRoJywgVG9Qb3NpdGl2ZUludGVnZXJdLFxuICAgIFsnbW9udGhDb2RlJywgVG9TdHJpbmddLFxuICAgIFsnZGF5JywgVG9Qb3NpdGl2ZUludGVnZXJdLFxuICAgIFsnaG91cicsIFRvSW50ZWdlclRocm93T25JbmZpbml0eV0sXG4gICAgWydtaW51dGUnLCBUb0ludGVnZXJUaHJvd09uSW5maW5pdHldLFxuICAgIFsnc2Vjb25kJywgVG9JbnRlZ2VyVGhyb3dPbkluZmluaXR5XSxcbiAgICBbJ21pbGxpc2Vjb25kJywgVG9JbnRlZ2VyVGhyb3dPbkluZmluaXR5XSxcbiAgICBbJ21pY3Jvc2Vjb25kJywgVG9JbnRlZ2VyVGhyb3dPbkluZmluaXR5XSxcbiAgICBbJ25hbm9zZWNvbmQnLCBUb0ludGVnZXJUaHJvd09uSW5maW5pdHldLFxuICAgIFsneWVhcnMnLCBUb0ludGVnZXJXaXRob3V0Um91bmRpbmddLFxuICAgIFsnbW9udGhzJywgVG9JbnRlZ2VyV2l0aG91dFJvdW5kaW5nXSxcbiAgICBbJ3dlZWtzJywgVG9JbnRlZ2VyV2l0aG91dFJvdW5kaW5nXSxcbiAgICBbJ2RheXMnLCBUb0ludGVnZXJXaXRob3V0Um91bmRpbmddLFxuICAgIFsnaG91cnMnLCBUb0ludGVnZXJXaXRob3V0Um91bmRpbmddLFxuICAgIFsnbWludXRlcycsIFRvSW50ZWdlcldpdGhvdXRSb3VuZGluZ10sXG4gICAgWydzZWNvbmRzJywgVG9JbnRlZ2VyV2l0aG91dFJvdW5kaW5nXSxcbiAgICBbJ21pbGxpc2Vjb25kcycsIFRvSW50ZWdlcldpdGhvdXRSb3VuZGluZ10sXG4gICAgWydtaWNyb3NlY29uZHMnLCBUb0ludGVnZXJXaXRob3V0Um91bmRpbmddLFxuICAgIFsnbmFub3NlY29uZHMnLCBUb0ludGVnZXJXaXRob3V0Um91bmRpbmddLFxuICAgIFsnZXJhJywgVG9TdHJpbmddLFxuICAgIFsnZXJhWWVhcicsIFRvSW50ZWdlcl0sXG4gICAgWydvZmZzZXQnLCBUb1N0cmluZ11cbl0pO1xuY29uc3QgQUxMT1dFRF9VTklUUyA9IFtcbiAgICAneWVhcicsXG4gICAgJ21vbnRoJyxcbiAgICAnd2VlaycsXG4gICAgJ2RheScsXG4gICAgJ2hvdXInLFxuICAgICdtaW51dGUnLFxuICAgICdzZWNvbmQnLFxuICAgICdtaWxsaXNlY29uZCcsXG4gICAgJ21pY3Jvc2Vjb25kJyxcbiAgICAnbmFub3NlY29uZCdcbl07XG5jb25zdCBTSU5HVUxBUl9QTFVSQUxfVU5JVFMgPSBbXG4gICAgWyd5ZWFycycsICd5ZWFyJ10sXG4gICAgWydtb250aHMnLCAnbW9udGgnXSxcbiAgICBbJ3dlZWtzJywgJ3dlZWsnXSxcbiAgICBbJ2RheXMnLCAnZGF5J10sXG4gICAgWydob3VycycsICdob3VyJ10sXG4gICAgWydtaW51dGVzJywgJ21pbnV0ZSddLFxuICAgIFsnc2Vjb25kcycsICdzZWNvbmQnXSxcbiAgICBbJ21pbGxpc2Vjb25kcycsICdtaWxsaXNlY29uZCddLFxuICAgIFsnbWljcm9zZWNvbmRzJywgJ21pY3Jvc2Vjb25kJ10sXG4gICAgWyduYW5vc2Vjb25kcycsICduYW5vc2Vjb25kJ11cbl07XG5jb25zdCBJbnRsRGF0ZVRpbWVGb3JtYXRFblVzQ2FjaGUgPSBuZXcgTWFwKCk7XG5mdW5jdGlvbiBnZXRJbnRsRGF0ZVRpbWVGb3JtYXRFblVzRm9yVGltZVpvbmUodGltZVpvbmVJZGVudGlmaWVyKSB7XG4gICAgbGV0IGluc3RhbmNlID0gSW50bERhdGVUaW1lRm9ybWF0RW5Vc0NhY2hlLmdldCh0aW1lWm9uZUlkZW50aWZpZXIpO1xuICAgIGlmIChpbnN0YW5jZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGluc3RhbmNlID0gbmV3IEludGxEYXRlVGltZUZvcm1hdCQxKCdlbi11cycsIHtcbiAgICAgICAgICAgIHRpbWVab25lOiBTdHJpbmdDdG9yKHRpbWVab25lSWRlbnRpZmllciksXG4gICAgICAgICAgICBob3VyMTI6IGZhbHNlLFxuICAgICAgICAgICAgZXJhOiAnc2hvcnQnLFxuICAgICAgICAgICAgeWVhcjogJ251bWVyaWMnLFxuICAgICAgICAgICAgbW9udGg6ICdudW1lcmljJyxcbiAgICAgICAgICAgIGRheTogJ251bWVyaWMnLFxuICAgICAgICAgICAgaG91cjogJ251bWVyaWMnLFxuICAgICAgICAgICAgbWludXRlOiAnbnVtZXJpYycsXG4gICAgICAgICAgICBzZWNvbmQ6ICdudW1lcmljJ1xuICAgICAgICB9KTtcbiAgICAgICAgSW50bERhdGVUaW1lRm9ybWF0RW5Vc0NhY2hlLnNldCh0aW1lWm9uZUlkZW50aWZpZXIsIGluc3RhbmNlKTtcbiAgICB9XG4gICAgcmV0dXJuIGluc3RhbmNlO1xufVxuZnVuY3Rpb24gSXNUZW1wb3JhbEluc3RhbnQoaXRlbSkge1xuICAgIHJldHVybiBIYXNTbG90KGl0ZW0sIEVQT0NITkFOT1NFQ09ORFMpICYmICFIYXNTbG90KGl0ZW0sIFRJTUVfWk9ORSwgQ0FMRU5EQVIpO1xufVxuZnVuY3Rpb24gSXNUZW1wb3JhbFRpbWVab25lKGl0ZW0pIHtcbiAgICByZXR1cm4gSGFzU2xvdChpdGVtLCBUSU1FWk9ORV9JRCk7XG59XG5mdW5jdGlvbiBJc1RlbXBvcmFsQ2FsZW5kYXIoaXRlbSkge1xuICAgIHJldHVybiBIYXNTbG90KGl0ZW0sIENBTEVOREFSX0lEKTtcbn1cbmZ1bmN0aW9uIElzVGVtcG9yYWxEdXJhdGlvbihpdGVtKSB7XG4gICAgcmV0dXJuIEhhc1Nsb3QoaXRlbSwgWUVBUlMsIE1PTlRIUywgREFZUywgSE9VUlMsIE1JTlVURVMsIFNFQ09ORFMsIE1JTExJU0VDT05EUywgTUlDUk9TRUNPTkRTLCBOQU5PU0VDT05EUyk7XG59XG5mdW5jdGlvbiBJc1RlbXBvcmFsRGF0ZShpdGVtKSB7XG4gICAgcmV0dXJuIEhhc1Nsb3QoaXRlbSwgREFURV9CUkFORCk7XG59XG5mdW5jdGlvbiBJc1RlbXBvcmFsVGltZShpdGVtKSB7XG4gICAgcmV0dXJuIChIYXNTbG90KGl0ZW0sIElTT19IT1VSLCBJU09fTUlOVVRFLCBJU09fU0VDT05ELCBJU09fTUlMTElTRUNPTkQsIElTT19NSUNST1NFQ09ORCwgSVNPX05BTk9TRUNPTkQpICYmXG4gICAgICAgICFIYXNTbG90KGl0ZW0sIElTT19ZRUFSLCBJU09fTU9OVEgsIElTT19EQVkpKTtcbn1cbmZ1bmN0aW9uIElzVGVtcG9yYWxEYXRlVGltZShpdGVtKSB7XG4gICAgcmV0dXJuIEhhc1Nsb3QoaXRlbSwgSVNPX1lFQVIsIElTT19NT05USCwgSVNPX0RBWSwgSVNPX0hPVVIsIElTT19NSU5VVEUsIElTT19TRUNPTkQsIElTT19NSUxMSVNFQ09ORCwgSVNPX01JQ1JPU0VDT05ELCBJU09fTkFOT1NFQ09ORCk7XG59XG5mdW5jdGlvbiBJc1RlbXBvcmFsWWVhck1vbnRoKGl0ZW0pIHtcbiAgICByZXR1cm4gSGFzU2xvdChpdGVtLCBZRUFSX01PTlRIX0JSQU5EKTtcbn1cbmZ1bmN0aW9uIElzVGVtcG9yYWxNb250aERheShpdGVtKSB7XG4gICAgcmV0dXJuIEhhc1Nsb3QoaXRlbSwgTU9OVEhfREFZX0JSQU5EKTtcbn1cbmZ1bmN0aW9uIElzVGVtcG9yYWxab25lZERhdGVUaW1lKGl0ZW0pIHtcbiAgICByZXR1cm4gSGFzU2xvdChpdGVtLCBFUE9DSE5BTk9TRUNPTkRTLCBUSU1FX1pPTkUsIENBTEVOREFSKTtcbn1cbmZ1bmN0aW9uIFJlamVjdE9iamVjdFdpdGhDYWxlbmRhck9yVGltZVpvbmUoaXRlbSkge1xuICAgIGlmIChIYXNTbG90KGl0ZW0sIENBTEVOREFSKSB8fCBIYXNTbG90KGl0ZW0sIFRJTUVfWk9ORSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignd2l0aCgpIGRvZXMgbm90IHN1cHBvcnQgYSBjYWxlbmRhciBvciB0aW1lWm9uZSBwcm9wZXJ0eScpO1xuICAgIH1cbiAgICBpZiAoaXRlbS5jYWxlbmRhciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3dpdGgoKSBkb2VzIG5vdCBzdXBwb3J0IGEgY2FsZW5kYXIgcHJvcGVydHknKTtcbiAgICB9XG4gICAgaWYgKGl0ZW0udGltZVpvbmUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd3aXRoKCkgZG9lcyBub3Qgc3VwcG9ydCBhIHRpbWVab25lIHByb3BlcnR5Jyk7XG4gICAgfVxufVxuZnVuY3Rpb24gUGFyc2VUZW1wb3JhbFRpbWVab25lKHN0cmluZ0lkZW50KSB7XG4gICAgbGV0IHsgaWFuYU5hbWUsIG9mZnNldCwgeiB9ID0gUGFyc2VUZW1wb3JhbFRpbWVab25lU3RyaW5nKHN0cmluZ0lkZW50KTtcbiAgICBpZiAoaWFuYU5hbWUpXG4gICAgICAgIHJldHVybiBpYW5hTmFtZTtcbiAgICBpZiAoeilcbiAgICAgICAgcmV0dXJuICdVVEMnO1xuICAgIHJldHVybiBvZmZzZXQ7IC8vIGlmICFpYW5hTmFtZSAmJiAheiB0aGVuIG9mZnNldCBtdXN0IGJlIHByZXNlbnRcbn1cbmZ1bmN0aW9uIEZvcm1hdENhbGVuZGFyQW5ub3RhdGlvbihpZCwgc2hvd0NhbGVuZGFyKSB7XG4gICAgaWYgKHNob3dDYWxlbmRhciA9PT0gJ25ldmVyJylcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIGlmIChzaG93Q2FsZW5kYXIgPT09ICdhdXRvJyAmJiBpZCA9PT0gJ2lzbzg2MDEnKVxuICAgICAgICByZXR1cm4gJyc7XG4gICAgcmV0dXJuIGBbdS1jYT0ke2lkfV1gO1xufVxuZnVuY3Rpb24gUGFyc2VJU09EYXRlVGltZShpc29TdHJpbmcpIHtcbiAgICAvLyBaRFQgaXMgdGhlIHN1cGVyc2V0IG9mIGZpZWxkcyBmb3IgZXZlcnkgb3RoZXIgVGVtcG9yYWwgdHlwZVxuICAgIGNvbnN0IG1hdGNoID0gem9uZWRkYXRldGltZS5leGVjKGlzb1N0cmluZyk7XG4gICAgaWYgKCFtYXRjaClcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYGludmFsaWQgSVNPIDg2MDEgc3RyaW5nOiAke2lzb1N0cmluZ31gKTtcbiAgICBsZXQgeWVhclN0cmluZyA9IG1hdGNoWzFdO1xuICAgIGlmICh5ZWFyU3RyaW5nWzBdID09PSAnXFx1MjIxMicpXG4gICAgICAgIHllYXJTdHJpbmcgPSBgLSR7eWVhclN0cmluZy5zbGljZSgxKX1gO1xuICAgIGlmICh5ZWFyU3RyaW5nID09PSAnLTAwMDAwMCcpXG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBpbnZhbGlkIElTTyA4NjAxIHN0cmluZzogJHtpc29TdHJpbmd9YCk7XG4gICAgY29uc3QgeWVhciA9IFRvSW50ZWdlcih5ZWFyU3RyaW5nKTtcbiAgICBjb25zdCBtb250aCA9IFRvSW50ZWdlcihtYXRjaFsyXSB8fCBtYXRjaFs0XSk7XG4gICAgY29uc3QgZGF5ID0gVG9JbnRlZ2VyKG1hdGNoWzNdIHx8IG1hdGNoWzVdKTtcbiAgICBjb25zdCBob3VyID0gVG9JbnRlZ2VyKG1hdGNoWzZdKTtcbiAgICBjb25zdCBoYXNUaW1lID0gbWF0Y2hbNl0gIT09IHVuZGVmaW5lZDtcbiAgICBjb25zdCBtaW51dGUgPSBUb0ludGVnZXIobWF0Y2hbN10gfHwgbWF0Y2hbMTBdKTtcbiAgICBsZXQgc2Vjb25kID0gVG9JbnRlZ2VyKG1hdGNoWzhdIHx8IG1hdGNoWzExXSk7XG4gICAgaWYgKHNlY29uZCA9PT0gNjApXG4gICAgICAgIHNlY29uZCA9IDU5O1xuICAgIGNvbnN0IGZyYWN0aW9uID0gKG1hdGNoWzldIHx8IG1hdGNoWzEyXSkgKyAnMDAwMDAwMDAwJztcbiAgICBjb25zdCBtaWxsaXNlY29uZCA9IFRvSW50ZWdlcihmcmFjdGlvbi5zbGljZSgwLCAzKSk7XG4gICAgY29uc3QgbWljcm9zZWNvbmQgPSBUb0ludGVnZXIoZnJhY3Rpb24uc2xpY2UoMywgNikpO1xuICAgIGNvbnN0IG5hbm9zZWNvbmQgPSBUb0ludGVnZXIoZnJhY3Rpb24uc2xpY2UoNiwgOSkpO1xuICAgIGxldCBvZmZzZXQ7XG4gICAgbGV0IHogPSBmYWxzZTtcbiAgICBpZiAobWF0Y2hbMTNdKSB7XG4gICAgICAgIG9mZnNldCA9IHVuZGVmaW5lZDtcbiAgICAgICAgeiA9IHRydWU7XG4gICAgfVxuICAgIGVsc2UgaWYgKG1hdGNoWzE0XSAmJiBtYXRjaFsxNV0pIHtcbiAgICAgICAgY29uc3Qgb2Zmc2V0U2lnbiA9IG1hdGNoWzE0XSA9PT0gJy0nIHx8IG1hdGNoWzE0XSA9PT0gJ1xcdTIyMTInID8gJy0nIDogJysnO1xuICAgICAgICBjb25zdCBvZmZzZXRIb3VycyA9IG1hdGNoWzE1XSB8fCAnMDAnO1xuICAgICAgICBjb25zdCBvZmZzZXRNaW51dGVzID0gbWF0Y2hbMTZdIHx8ICcwMCc7XG4gICAgICAgIGNvbnN0IG9mZnNldFNlY29uZHMgPSBtYXRjaFsxN10gfHwgJzAwJztcbiAgICAgICAgbGV0IG9mZnNldEZyYWN0aW9uID0gbWF0Y2hbMThdIHx8ICcwJztcbiAgICAgICAgb2Zmc2V0ID0gYCR7b2Zmc2V0U2lnbn0ke29mZnNldEhvdXJzfToke29mZnNldE1pbnV0ZXN9YDtcbiAgICAgICAgaWYgKCtvZmZzZXRGcmFjdGlvbikge1xuICAgICAgICAgICAgd2hpbGUgKG9mZnNldEZyYWN0aW9uLmVuZHNXaXRoKCcwJykpXG4gICAgICAgICAgICAgICAgb2Zmc2V0RnJhY3Rpb24gPSBvZmZzZXRGcmFjdGlvbi5zbGljZSgwLCAtMSk7XG4gICAgICAgICAgICBvZmZzZXQgKz0gYDoke29mZnNldFNlY29uZHN9LiR7b2Zmc2V0RnJhY3Rpb259YDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgrb2Zmc2V0U2Vjb25kcykge1xuICAgICAgICAgICAgb2Zmc2V0ICs9IGA6JHtvZmZzZXRTZWNvbmRzfWA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9mZnNldCA9PT0gJy0wMDowMCcpXG4gICAgICAgICAgICBvZmZzZXQgPSAnKzAwOjAwJztcbiAgICB9XG4gICAgbGV0IGlhbmFOYW1lID0gbWF0Y2hbMTldO1xuICAgIGlmIChpYW5hTmFtZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gQ2Fub25pY2FsaXplIG5hbWUgaWYgaXQgaXMgYW4gSUFOQSBsaW5rIG5hbWUgb3IgaXMgY2FwaXRhbGl6ZWQgd3JvbmdcbiAgICAgICAgICAgIGlhbmFOYW1lID0gR2V0Q2Fub25pY2FsVGltZVpvbmVJZGVudGlmaWVyKGlhbmFOYW1lKS50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIHtcbiAgICAgICAgICAgIC8vIE5vdCBhbiBJQU5BIG5hbWUsIG1heSBiZSBhIGN1c3RvbSBJRCwgcGFzcyB0aHJvdWdoIHVuY2hhbmdlZFxuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGNhbGVuZGFyID0gbWF0Y2hbMjBdO1xuICAgIHJldHVybiB7XG4gICAgICAgIHllYXIsXG4gICAgICAgIG1vbnRoLFxuICAgICAgICBkYXksXG4gICAgICAgIGhhc1RpbWUsXG4gICAgICAgIGhvdXIsXG4gICAgICAgIG1pbnV0ZSxcbiAgICAgICAgc2Vjb25kLFxuICAgICAgICBtaWxsaXNlY29uZCxcbiAgICAgICAgbWljcm9zZWNvbmQsXG4gICAgICAgIG5hbm9zZWNvbmQsXG4gICAgICAgIGlhbmFOYW1lLFxuICAgICAgICBvZmZzZXQsXG4gICAgICAgIHosXG4gICAgICAgIGNhbGVuZGFyXG4gICAgfTtcbn1cbmZ1bmN0aW9uIFBhcnNlVGVtcG9yYWxJbnN0YW50U3RyaW5nKGlzb1N0cmluZykge1xuICAgIGNvbnN0IHJlc3VsdCA9IFBhcnNlSVNPRGF0ZVRpbWUoaXNvU3RyaW5nKTtcbiAgICBpZiAoIXJlc3VsdC56ICYmICFyZXN1bHQub2Zmc2V0KVxuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGVtcG9yYWwuSW5zdGFudCByZXF1aXJlcyBhIHRpbWUgem9uZSBvZmZzZXQnKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gUGFyc2VUZW1wb3JhbFpvbmVkRGF0ZVRpbWVTdHJpbmcoaXNvU3RyaW5nKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gUGFyc2VJU09EYXRlVGltZShpc29TdHJpbmcpO1xuICAgIGlmICghcmVzdWx0LmlhbmFOYW1lKVxuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGVtcG9yYWwuWm9uZWREYXRlVGltZSByZXF1aXJlcyBhIHRpbWUgem9uZSBJRCBpbiBicmFja2V0cycpO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBQYXJzZVRlbXBvcmFsRGF0ZVRpbWVTdHJpbmcoaXNvU3RyaW5nKSB7XG4gICAgcmV0dXJuIFBhcnNlSVNPRGF0ZVRpbWUoaXNvU3RyaW5nKTtcbn1cbmZ1bmN0aW9uIFBhcnNlVGVtcG9yYWxEYXRlU3RyaW5nKGlzb1N0cmluZykge1xuICAgIHJldHVybiBQYXJzZUlTT0RhdGVUaW1lKGlzb1N0cmluZyk7XG59XG5mdW5jdGlvbiBQYXJzZVRlbXBvcmFsVGltZVN0cmluZyhpc29TdHJpbmcpIHtcbiAgICBjb25zdCBtYXRjaCA9IHRpbWUuZXhlYyhpc29TdHJpbmcpO1xuICAgIGxldCBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQsIG1pY3Jvc2Vjb25kLCBuYW5vc2Vjb25kLCBjYWxlbmRhcjtcbiAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgaG91ciA9IFRvSW50ZWdlcihtYXRjaFsxXSk7XG4gICAgICAgIG1pbnV0ZSA9IFRvSW50ZWdlcihtYXRjaFsyXSB8fCBtYXRjaFs1XSk7XG4gICAgICAgIHNlY29uZCA9IFRvSW50ZWdlcihtYXRjaFszXSB8fCBtYXRjaFs2XSk7XG4gICAgICAgIGlmIChzZWNvbmQgPT09IDYwKVxuICAgICAgICAgICAgc2Vjb25kID0gNTk7XG4gICAgICAgIGNvbnN0IGZyYWN0aW9uID0gKG1hdGNoWzRdIHx8IG1hdGNoWzddKSArICcwMDAwMDAwMDAnO1xuICAgICAgICBtaWxsaXNlY29uZCA9IFRvSW50ZWdlcihmcmFjdGlvbi5zbGljZSgwLCAzKSk7XG4gICAgICAgIG1pY3Jvc2Vjb25kID0gVG9JbnRlZ2VyKGZyYWN0aW9uLnNsaWNlKDMsIDYpKTtcbiAgICAgICAgbmFub3NlY29uZCA9IFRvSW50ZWdlcihmcmFjdGlvbi5zbGljZSg2LCA5KSk7XG4gICAgICAgIGNhbGVuZGFyID0gbWF0Y2hbMTVdO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbGV0IHosIGhhc1RpbWU7XG4gICAgICAgICh7IGhhc1RpbWUsIGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZCwgbWljcm9zZWNvbmQsIG5hbm9zZWNvbmQsIGNhbGVuZGFyLCB6IH0gPVxuICAgICAgICAgICAgUGFyc2VJU09EYXRlVGltZShpc29TdHJpbmcpKTtcbiAgICAgICAgaWYgKCFoYXNUaW1lKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYHRpbWUgaXMgbWlzc2luZyBpbiBzdHJpbmc6ICR7aXNvU3RyaW5nfWApO1xuICAgICAgICBpZiAoeilcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdaIGRlc2lnbmF0b3Igbm90IHN1cHBvcnRlZCBmb3IgUGxhaW5UaW1lJyk7XG4gICAgfVxuICAgIC8vIGlmIGl0J3MgYSBkYXRlLXRpbWUgc3RyaW5nLCBPS1xuICAgIGlmICgvW3RUIF1bMC05XVswLTldLy50ZXN0KGlzb1N0cmluZykpIHtcbiAgICAgICAgcmV0dXJuIHsgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kLCBtaWNyb3NlY29uZCwgbmFub3NlY29uZCwgY2FsZW5kYXIgfTtcbiAgICB9XG4gICAgLy8gc2xvdyBidXQgbm9uLWdyYW1tYXItZGVwZW5kZW50IHdheSB0byBlbnN1cmUgdGhhdCB0aW1lLW9ubHkgc3RyaW5ncyB0aGF0XG4gICAgLy8gYXJlIGFsc28gdmFsaWQgUGxhaW5Nb250aERheSBhbmQgUGxhaW5ZZWFyTW9udGggdGhyb3cuIGNvcnJlc3BvbmRzIHRvXG4gICAgLy8gYXNzZXJ0aW9uIGluIHNwZWMgdGV4dFxuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHsgbW9udGgsIGRheSB9ID0gUGFyc2VUZW1wb3JhbE1vbnRoRGF5U3RyaW5nKGlzb1N0cmluZyk7XG4gICAgICAgIFJlamVjdElTT0RhdGUoMTk3MiwgbW9udGgsIGRheSk7XG4gICAgfVxuICAgIGNhdGNoIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHsgeWVhciwgbW9udGggfSA9IFBhcnNlVGVtcG9yYWxZZWFyTW9udGhTdHJpbmcoaXNvU3RyaW5nKTtcbiAgICAgICAgICAgIFJlamVjdElTT0RhdGUoeWVhciwgbW9udGgsIDEpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIHtcbiAgICAgICAgICAgIHJldHVybiB7IGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZCwgbWljcm9zZWNvbmQsIG5hbm9zZWNvbmQsIGNhbGVuZGFyIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYGludmFsaWQgSVNPIDg2MDEgdGltZS1vbmx5IHN0cmluZyAke2lzb1N0cmluZ307IG1heSBuZWVkIGEgVCBwcmVmaXhgKTtcbn1cbmZ1bmN0aW9uIFBhcnNlVGVtcG9yYWxZZWFyTW9udGhTdHJpbmcoaXNvU3RyaW5nKSB7XG4gICAgY29uc3QgbWF0Y2ggPSB5ZWFybW9udGguZXhlYyhpc29TdHJpbmcpO1xuICAgIGxldCB5ZWFyLCBtb250aCwgY2FsZW5kYXIsIHJlZmVyZW5jZUlTT0RheTtcbiAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgbGV0IHllYXJTdHJpbmcgPSBtYXRjaFsxXTtcbiAgICAgICAgaWYgKHllYXJTdHJpbmdbMF0gPT09ICdcXHUyMjEyJylcbiAgICAgICAgICAgIHllYXJTdHJpbmcgPSBgLSR7eWVhclN0cmluZy5zbGljZSgxKX1gO1xuICAgICAgICBpZiAoeWVhclN0cmluZyA9PT0gJy0wMDAwMDAnKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYGludmFsaWQgSVNPIDg2MDEgc3RyaW5nOiAke2lzb1N0cmluZ31gKTtcbiAgICAgICAgeWVhciA9IFRvSW50ZWdlcih5ZWFyU3RyaW5nKTtcbiAgICAgICAgbW9udGggPSBUb0ludGVnZXIobWF0Y2hbMl0pO1xuICAgICAgICBjYWxlbmRhciA9IG1hdGNoWzNdO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbGV0IHo7XG4gICAgICAgICh7IHllYXIsIG1vbnRoLCBjYWxlbmRhciwgZGF5OiByZWZlcmVuY2VJU09EYXksIHogfSA9IFBhcnNlSVNPRGF0ZVRpbWUoaXNvU3RyaW5nKSk7XG4gICAgICAgIGlmICh6KVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1ogZGVzaWduYXRvciBub3Qgc3VwcG9ydGVkIGZvciBQbGFpblllYXJNb250aCcpO1xuICAgIH1cbiAgICByZXR1cm4geyB5ZWFyLCBtb250aCwgY2FsZW5kYXIsIHJlZmVyZW5jZUlTT0RheSB9O1xufVxuZnVuY3Rpb24gUGFyc2VUZW1wb3JhbE1vbnRoRGF5U3RyaW5nKGlzb1N0cmluZykge1xuICAgIGNvbnN0IG1hdGNoID0gbW9udGhkYXkuZXhlYyhpc29TdHJpbmcpO1xuICAgIGxldCBtb250aCwgZGF5LCBjYWxlbmRhciwgcmVmZXJlbmNlSVNPWWVhcjtcbiAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgbW9udGggPSBUb0ludGVnZXIobWF0Y2hbMV0pO1xuICAgICAgICBkYXkgPSBUb0ludGVnZXIobWF0Y2hbMl0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbGV0IHo7XG4gICAgICAgICh7IG1vbnRoLCBkYXksIGNhbGVuZGFyLCB5ZWFyOiByZWZlcmVuY2VJU09ZZWFyLCB6IH0gPSBQYXJzZUlTT0RhdGVUaW1lKGlzb1N0cmluZykpO1xuICAgICAgICBpZiAoeilcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdaIGRlc2lnbmF0b3Igbm90IHN1cHBvcnRlZCBmb3IgUGxhaW5Nb250aERheScpO1xuICAgIH1cbiAgICByZXR1cm4geyBtb250aCwgZGF5LCBjYWxlbmRhciwgcmVmZXJlbmNlSVNPWWVhciB9O1xufVxuZnVuY3Rpb24gUGFyc2VUZW1wb3JhbFRpbWVab25lU3RyaW5nKHN0cmluZ0lkZW50KSB7XG4gICAgdHJ5IHtcbiAgICAgICAgbGV0IGNhbm9uaWNhbElkZW50ID0gR2V0Q2Fub25pY2FsVGltZVpvbmVJZGVudGlmaWVyKHN0cmluZ0lkZW50KTtcbiAgICAgICAgaWYgKGNhbm9uaWNhbElkZW50KSB7XG4gICAgICAgICAgICBjYW5vbmljYWxJZGVudCA9IGNhbm9uaWNhbElkZW50LnRvU3RyaW5nKCk7XG4gICAgICAgICAgICBpZiAoVGVzdFRpbWVab25lT2Zmc2V0U3RyaW5nKGNhbm9uaWNhbElkZW50KSlcbiAgICAgICAgICAgICAgICByZXR1cm4geyBvZmZzZXQ6IGNhbm9uaWNhbElkZW50IH07XG4gICAgICAgICAgICByZXR1cm4geyBpYW5hTmFtZTogY2Fub25pY2FsSWRlbnQgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCB7XG4gICAgICAgIC8vIGZhbGwgdGhyb3VnaFxuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyBUcnkgcGFyc2luZyBJU08gc3RyaW5nIGluc3RlYWRcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gUGFyc2VJU09EYXRlVGltZShzdHJpbmdJZGVudCk7XG4gICAgICAgIGlmIChyZXN1bHQueiB8fCByZXN1bHQub2Zmc2V0IHx8IHJlc3VsdC5pYW5hTmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCB7XG4gICAgICAgIC8vIGZhbGwgdGhyb3VnaFxuICAgIH1cbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgSW52YWxpZCB0aW1lIHpvbmU6ICR7c3RyaW5nSWRlbnR9YCk7XG59XG5mdW5jdGlvbiBQYXJzZVRlbXBvcmFsRHVyYXRpb25TdHJpbmcoaXNvU3RyaW5nKSB7XG4gICAgY29uc3QgbWF0Y2ggPSBkdXJhdGlvbi5leGVjKGlzb1N0cmluZyk7XG4gICAgaWYgKCFtYXRjaClcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYGludmFsaWQgZHVyYXRpb246ICR7aXNvU3RyaW5nfWApO1xuICAgIGlmIChtYXRjaC5zbGljZSgyKS5ldmVyeSgoZWxlbWVudCkgPT4gZWxlbWVudCA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgaW52YWxpZCBkdXJhdGlvbjogJHtpc29TdHJpbmd9YCk7XG4gICAgfVxuICAgIGNvbnN0IHNpZ24gPSBtYXRjaFsxXSA9PT0gJy0nIHx8IG1hdGNoWzFdID09PSAnXFx1MjIxMicgPyAtMSA6IDE7XG4gICAgY29uc3QgeWVhcnMgPSBUb0ludGVnZXIobWF0Y2hbMl0pICogc2lnbjtcbiAgICBjb25zdCBtb250aHMgPSBUb0ludGVnZXIobWF0Y2hbM10pICogc2lnbjtcbiAgICBjb25zdCB3ZWVrcyA9IFRvSW50ZWdlcihtYXRjaFs0XSkgKiBzaWduO1xuICAgIGNvbnN0IGRheXMgPSBUb0ludGVnZXIobWF0Y2hbNV0pICogc2lnbjtcbiAgICBjb25zdCBob3VycyA9IFRvSW50ZWdlcihtYXRjaFs2XSkgKiBzaWduO1xuICAgIGxldCBmSG91cnMgPSBtYXRjaFs3XTtcbiAgICBsZXQgbWludXRlcyA9IFRvSW50ZWdlcihtYXRjaFs4XSkgKiBzaWduO1xuICAgIGxldCBmTWludXRlcyA9IG1hdGNoWzldO1xuICAgIGxldCBzZWNvbmRzID0gVG9JbnRlZ2VyKG1hdGNoWzEwXSkgKiBzaWduO1xuICAgIGNvbnN0IGZTZWNvbmRzID0gbWF0Y2hbMTFdICsgJzAwMDAwMDAwMCc7XG4gICAgbGV0IG1pbGxpc2Vjb25kcyA9IFRvSW50ZWdlcihmU2Vjb25kcy5zbGljZSgwLCAzKSkgKiBzaWduO1xuICAgIGxldCBtaWNyb3NlY29uZHMgPSBUb0ludGVnZXIoZlNlY29uZHMuc2xpY2UoMywgNikpICogc2lnbjtcbiAgICBsZXQgbmFub3NlY29uZHMgPSBUb0ludGVnZXIoZlNlY29uZHMuc2xpY2UoNiwgOSkpICogc2lnbjtcbiAgICBmSG91cnMgPSBmSG91cnMgPyAoc2lnbiAqIFRvSW50ZWdlcihmSG91cnMpKSAvIDEwICoqIGZIb3Vycy5sZW5ndGggOiAwO1xuICAgIGZNaW51dGVzID0gZk1pbnV0ZXMgPyAoc2lnbiAqIFRvSW50ZWdlcihmTWludXRlcykpIC8gMTAgKiogZk1pbnV0ZXMubGVuZ3RoIDogMDtcbiAgICAoeyBtaW51dGVzLCBzZWNvbmRzLCBtaWxsaXNlY29uZHMsIG1pY3Jvc2Vjb25kcywgbmFub3NlY29uZHMgfSA9IER1cmF0aW9uSGFuZGxlRnJhY3Rpb25zKGZIb3VycywgbWludXRlcywgZk1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc2Vjb25kcywgbWljcm9zZWNvbmRzLCBuYW5vc2Vjb25kcykpO1xuICAgIHJldHVybiB7IHllYXJzLCBtb250aHMsIHdlZWtzLCBkYXlzLCBob3VycywgbWludXRlcywgc2Vjb25kcywgbWlsbGlzZWNvbmRzLCBtaWNyb3NlY29uZHMsIG5hbm9zZWNvbmRzIH07XG59XG5mdW5jdGlvbiBQYXJzZVRlbXBvcmFsSW5zdGFudChpc29TdHJpbmcpIHtcbiAgICBjb25zdCB7IHllYXIsIG1vbnRoLCBkYXksIGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZCwgbWljcm9zZWNvbmQsIG5hbm9zZWNvbmQsIG9mZnNldCwgeiB9ID0gUGFyc2VUZW1wb3JhbEluc3RhbnRTdHJpbmcoaXNvU3RyaW5nKTtcbiAgICBjb25zdCBlcG9jaE5zID0gR2V0RXBvY2hGcm9tSVNPUGFydHMoeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kLCBtaWNyb3NlY29uZCwgbmFub3NlY29uZCk7XG4gICAgaWYgKGVwb2NoTnMgPT09IG51bGwpXG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdEYXRlVGltZSBvdXRzaWRlIG9mIHN1cHBvcnRlZCByYW5nZScpO1xuICAgIGNvbnN0IG9mZnNldE5zID0geiA/IDAgOiBQYXJzZVRpbWVab25lT2Zmc2V0U3RyaW5nKG9mZnNldCk7XG4gICAgcmV0dXJuIEpTQkkuc3VidHJhY3QoZXBvY2hOcywgSlNCSS5CaWdJbnQob2Zmc2V0TnMpKTtcbn1cbmZ1bmN0aW9uIFJlZ3VsYXRlSVNPRGF0ZSh5ZWFyUGFyYW0sIG1vbnRoUGFyYW0sIGRheVBhcmFtLCBvdmVyZmxvdykge1xuICAgIGxldCB5ZWFyID0geWVhclBhcmFtO1xuICAgIGxldCBtb250aCA9IG1vbnRoUGFyYW07XG4gICAgbGV0IGRheSA9IGRheVBhcmFtO1xuICAgIHN3aXRjaCAob3ZlcmZsb3cpIHtcbiAgICAgICAgY2FzZSAncmVqZWN0JzpcbiAgICAgICAgICAgIFJlamVjdElTT0RhdGUoeWVhciwgbW9udGgsIGRheSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnY29uc3RyYWluJzpcbiAgICAgICAgICAgICh7IHllYXIsIG1vbnRoLCBkYXkgfSA9IENvbnN0cmFpbklTT0RhdGUoeWVhciwgbW9udGgsIGRheSkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiB7IHllYXIsIG1vbnRoLCBkYXkgfTtcbn1cbmZ1bmN0aW9uIFJlZ3VsYXRlVGltZShob3VyUGFyYW0sIG1pbnV0ZVBhcmFtLCBzZWNvbmRQYXJhbSwgbWlsbGlzZWNvbmRQYXJhbSwgbWljcm9zZWNvbmRQYXJhbSwgbmFub3NlY29uZFBhcmFtLCBvdmVyZmxvdykge1xuICAgIGxldCBob3VyID0gaG91clBhcmFtO1xuICAgIGxldCBtaW51dGUgPSBtaW51dGVQYXJhbTtcbiAgICBsZXQgc2Vjb25kID0gc2Vjb25kUGFyYW07XG4gICAgbGV0IG1pbGxpc2Vjb25kID0gbWlsbGlzZWNvbmRQYXJhbTtcbiAgICBsZXQgbWljcm9zZWNvbmQgPSBtaWNyb3NlY29uZFBhcmFtO1xuICAgIGxldCBuYW5vc2Vjb25kID0gbmFub3NlY29uZFBhcmFtO1xuICAgIHN3aXRjaCAob3ZlcmZsb3cpIHtcbiAgICAgICAgY2FzZSAncmVqZWN0JzpcbiAgICAgICAgICAgIFJlamVjdFRpbWUoaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kLCBtaWNyb3NlY29uZCwgbmFub3NlY29uZCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnY29uc3RyYWluJzpcbiAgICAgICAgICAgICh7IGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZCwgbWljcm9zZWNvbmQsIG5hbm9zZWNvbmQgfSA9IENvbnN0cmFpblRpbWUoaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kLCBtaWNyb3NlY29uZCwgbmFub3NlY29uZCkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiB7IGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZCwgbWljcm9zZWNvbmQsIG5hbm9zZWNvbmQgfTtcbn1cbmZ1bmN0aW9uIFJlZ3VsYXRlSVNPWWVhck1vbnRoKHllYXJQYXJhbSwgbW9udGhQYXJhbSwgb3ZlcmZsb3cpIHtcbiAgICBsZXQgeWVhciA9IHllYXJQYXJhbTtcbiAgICBsZXQgbW9udGggPSBtb250aFBhcmFtO1xuICAgIGNvbnN0IHJlZmVyZW5jZUlTT0RheSA9IDE7XG4gICAgc3dpdGNoIChvdmVyZmxvdykge1xuICAgICAgICBjYXNlICdyZWplY3QnOlxuICAgICAgICAgICAgUmVqZWN0SVNPRGF0ZSh5ZWFyLCBtb250aCwgcmVmZXJlbmNlSVNPRGF5KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdjb25zdHJhaW4nOlxuICAgICAgICAgICAgKHsgeWVhciwgbW9udGggfSA9IENvbnN0cmFpbklTT0RhdGUoeWVhciwgbW9udGgpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4geyB5ZWFyLCBtb250aCB9O1xufVxuZnVuY3Rpb24gRHVyYXRpb25IYW5kbGVGcmFjdGlvbnMoZkhvdXJzUGFyYW0sIG1pbnV0ZXNQYXJhbSwgZk1pbnV0ZXNQYXJhbSwgc2Vjb25kc1BhcmFtLCBtaWxsaXNlY29uZHNQYXJhbSwgbWljcm9zZWNvbmRzUGFyYW0sIG5hbm9zZWNvbmRzUGFyYW0pIHtcbiAgICBsZXQgZkhvdXJzID0gZkhvdXJzUGFyYW07XG4gICAgbGV0IG1pbnV0ZXMgPSBtaW51dGVzUGFyYW07XG4gICAgbGV0IGZNaW51dGVzID0gZk1pbnV0ZXNQYXJhbTtcbiAgICBsZXQgc2Vjb25kcyA9IHNlY29uZHNQYXJhbTtcbiAgICBsZXQgbWlsbGlzZWNvbmRzID0gbWlsbGlzZWNvbmRzUGFyYW07XG4gICAgbGV0IG1pY3Jvc2Vjb25kcyA9IG1pY3Jvc2Vjb25kc1BhcmFtO1xuICAgIGxldCBuYW5vc2Vjb25kcyA9IG5hbm9zZWNvbmRzUGFyYW07XG4gICAgaWYgKGZIb3VycyAhPT0gMCkge1xuICAgICAgICBbbWludXRlcywgZk1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc2Vjb25kcywgbWljcm9zZWNvbmRzLCBuYW5vc2Vjb25kc10uZm9yRWFjaCgodmFsKSA9PiB7XG4gICAgICAgICAgICBpZiAodmFsICE9PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdvbmx5IHRoZSBzbWFsbGVzdCB1bml0IGNhbiBiZSBmcmFjdGlvbmFsJyk7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBtaW5zID0gZkhvdXJzICogNjA7XG4gICAgICAgIG1pbnV0ZXMgPSBNYXRoVHJ1bmMobWlucyk7XG4gICAgICAgIGZNaW51dGVzID0gbWlucyAlIDE7XG4gICAgfVxuICAgIGlmIChmTWludXRlcyAhPT0gMCkge1xuICAgICAgICBbc2Vjb25kcywgbWlsbGlzZWNvbmRzLCBtaWNyb3NlY29uZHMsIG5hbm9zZWNvbmRzXS5mb3JFYWNoKCh2YWwpID0+IHtcbiAgICAgICAgICAgIGlmICh2YWwgIT09IDApXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ29ubHkgdGhlIHNtYWxsZXN0IHVuaXQgY2FuIGJlIGZyYWN0aW9uYWwnKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHNlY3MgPSBmTWludXRlcyAqIDYwO1xuICAgICAgICBzZWNvbmRzID0gTWF0aFRydW5jKHNlY3MpO1xuICAgICAgICBjb25zdCBmU2Vjb25kcyA9IHNlY3MgJSAxO1xuICAgICAgICBpZiAoZlNlY29uZHMgIT09IDApIHtcbiAgICAgICAgICAgIGNvbnN0IG1pbHMgPSBmU2Vjb25kcyAqIDEwMDA7XG4gICAgICAgICAgICBtaWxsaXNlY29uZHMgPSBNYXRoVHJ1bmMobWlscyk7XG4gICAgICAgICAgICBjb25zdCBmTWlsbGlzZWNvbmRzID0gbWlscyAlIDE7XG4gICAgICAgICAgICBpZiAoZk1pbGxpc2Vjb25kcyAhPT0gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1pY3MgPSBmTWlsbGlzZWNvbmRzICogMTAwMDtcbiAgICAgICAgICAgICAgICBtaWNyb3NlY29uZHMgPSBNYXRoVHJ1bmMobWljcyk7XG4gICAgICAgICAgICAgICAgY29uc3QgZk1pY3Jvc2Vjb25kcyA9IG1pY3MgJSAxO1xuICAgICAgICAgICAgICAgIGlmIChmTWljcm9zZWNvbmRzICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5hbnMgPSBmTWljcm9zZWNvbmRzICogMTAwMDtcbiAgICAgICAgICAgICAgICAgICAgbmFub3NlY29uZHMgPSBNYXRoVHJ1bmMobmFucyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IG1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc2Vjb25kcywgbWljcm9zZWNvbmRzLCBuYW5vc2Vjb25kcyB9O1xufVxuZnVuY3Rpb24gVG9UZW1wb3JhbER1cmF0aW9uUmVjb3JkKGl0ZW0pIHtcbiAgICBpZiAoSXNUZW1wb3JhbER1cmF0aW9uKGl0ZW0pKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB5ZWFyczogR2V0U2xvdChpdGVtLCBZRUFSUyksXG4gICAgICAgICAgICBtb250aHM6IEdldFNsb3QoaXRlbSwgTU9OVEhTKSxcbiAgICAgICAgICAgIHdlZWtzOiBHZXRTbG90KGl0ZW0sIFdFRUtTKSxcbiAgICAgICAgICAgIGRheXM6IEdldFNsb3QoaXRlbSwgREFZUyksXG4gICAgICAgICAgICBob3VyczogR2V0U2xvdChpdGVtLCBIT1VSUyksXG4gICAgICAgICAgICBtaW51dGVzOiBHZXRTbG90KGl0ZW0sIE1JTlVURVMpLFxuICAgICAgICAgICAgc2Vjb25kczogR2V0U2xvdChpdGVtLCBTRUNPTkRTKSxcbiAgICAgICAgICAgIG1pbGxpc2Vjb25kczogR2V0U2xvdChpdGVtLCBNSUxMSVNFQ09ORFMpLFxuICAgICAgICAgICAgbWljcm9zZWNvbmRzOiBHZXRTbG90KGl0ZW0sIE1JQ1JPU0VDT05EUyksXG4gICAgICAgICAgICBuYW5vc2Vjb25kczogR2V0U2xvdChpdGVtLCBOQU5PU0VDT05EUylcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgcHJvcHMgPSBUb1BhcnRpYWxSZWNvcmQoaXRlbSwgW1xuICAgICAgICAnZGF5cycsXG4gICAgICAgICdob3VycycsXG4gICAgICAgICdtaWNyb3NlY29uZHMnLFxuICAgICAgICAnbWlsbGlzZWNvbmRzJyxcbiAgICAgICAgJ21pbnV0ZXMnLFxuICAgICAgICAnbW9udGhzJyxcbiAgICAgICAgJ25hbm9zZWNvbmRzJyxcbiAgICAgICAgJ3NlY29uZHMnLFxuICAgICAgICAnd2Vla3MnLFxuICAgICAgICAneWVhcnMnXG4gICAgXSk7XG4gICAgaWYgKCFwcm9wcylcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBkdXJhdGlvbi1saWtlJyk7XG4gICAgY29uc3QgeyB5ZWFycyA9IDAsIG1vbnRocyA9IDAsIHdlZWtzID0gMCwgZGF5cyA9IDAsIGhvdXJzID0gMCwgbWludXRlcyA9IDAsIHNlY29uZHMgPSAwLCBtaWxsaXNlY29uZHMgPSAwLCBtaWNyb3NlY29uZHMgPSAwLCBuYW5vc2Vjb25kcyA9IDAgfSA9IHByb3BzO1xuICAgIHJldHVybiB7IHllYXJzLCBtb250aHMsIHdlZWtzLCBkYXlzLCBob3VycywgbWludXRlcywgc2Vjb25kcywgbWlsbGlzZWNvbmRzLCBtaWNyb3NlY29uZHMsIG5hbm9zZWNvbmRzIH07XG59XG5mdW5jdGlvbiBUb0xpbWl0ZWRUZW1wb3JhbER1cmF0aW9uKGl0ZW0sIGRpc2FsbG93ZWRQcm9wZXJ0aWVzID0gW10pIHtcbiAgICBsZXQgcmVjb3JkO1xuICAgIGlmIChJc09iamVjdChpdGVtKSkge1xuICAgICAgICByZWNvcmQgPSBUb1RlbXBvcmFsRHVyYXRpb25SZWNvcmQoaXRlbSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBzdHIgPSBUb1N0cmluZyhpdGVtKTtcbiAgICAgICAgcmVjb3JkID0gUGFyc2VUZW1wb3JhbER1cmF0aW9uU3RyaW5nKHN0cik7XG4gICAgfVxuICAgIGNvbnN0IHsgeWVhcnMsIG1vbnRocywgd2Vla3MsIGRheXMsIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBtaWxsaXNlY29uZHMsIG1pY3Jvc2Vjb25kcywgbmFub3NlY29uZHMgfSA9IHJlY29yZDtcbiAgICBSZWplY3REdXJhdGlvbih5ZWFycywgbW9udGhzLCB3ZWVrcywgZGF5cywgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc2Vjb25kcywgbWljcm9zZWNvbmRzLCBuYW5vc2Vjb25kcyk7XG4gICAgZm9yIChjb25zdCBwcm9wZXJ0eSBvZiBkaXNhbGxvd2VkUHJvcGVydGllcykge1xuICAgICAgICBpZiAocmVjb3JkW3Byb3BlcnR5XSAhPT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYER1cmF0aW9uIGZpZWxkICR7cHJvcGVydHl9IG5vdCBzdXBwb3J0ZWQgYnkgVGVtcG9yYWwuSW5zdGFudC4gVHJ5IFRlbXBvcmFsLlpvbmVkRGF0ZVRpbWUgaW5zdGVhZC5gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVjb3JkO1xufVxuZnVuY3Rpb24gVG9UZW1wb3JhbE92ZXJmbG93KG9wdGlvbnMpIHtcbiAgICByZXR1cm4gR2V0T3B0aW9uKG9wdGlvbnMsICdvdmVyZmxvdycsIFsnY29uc3RyYWluJywgJ3JlamVjdCddLCAnY29uc3RyYWluJyk7XG59XG5mdW5jdGlvbiBUb1RlbXBvcmFsRGlzYW1iaWd1YXRpb24ob3B0aW9ucykge1xuICAgIHJldHVybiBHZXRPcHRpb24ob3B0aW9ucywgJ2Rpc2FtYmlndWF0aW9uJywgWydjb21wYXRpYmxlJywgJ2VhcmxpZXInLCAnbGF0ZXInLCAncmVqZWN0J10sICdjb21wYXRpYmxlJyk7XG59XG5mdW5jdGlvbiBUb1RlbXBvcmFsUm91bmRpbmdNb2RlKG9wdGlvbnMsIGZhbGxiYWNrKSB7XG4gICAgcmV0dXJuIEdldE9wdGlvbihvcHRpb25zLCAncm91bmRpbmdNb2RlJywgWydjZWlsJywgJ2Zsb29yJywgJ3RydW5jJywgJ2hhbGZFeHBhbmQnXSwgZmFsbGJhY2spO1xufVxuZnVuY3Rpb24gTmVnYXRlVGVtcG9yYWxSb3VuZGluZ01vZGUocm91bmRpbmdNb2RlKSB7XG4gICAgc3dpdGNoIChyb3VuZGluZ01vZGUpIHtcbiAgICAgICAgY2FzZSAnY2VpbCc6XG4gICAgICAgICAgICByZXR1cm4gJ2Zsb29yJztcbiAgICAgICAgY2FzZSAnZmxvb3InOlxuICAgICAgICAgICAgcmV0dXJuICdjZWlsJztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiByb3VuZGluZ01vZGU7XG4gICAgfVxufVxuZnVuY3Rpb24gVG9UZW1wb3JhbE9mZnNldChvcHRpb25zLCBmYWxsYmFjaykge1xuICAgIHJldHVybiBHZXRPcHRpb24ob3B0aW9ucywgJ29mZnNldCcsIFsncHJlZmVyJywgJ3VzZScsICdpZ25vcmUnLCAncmVqZWN0J10sIGZhbGxiYWNrKTtcbn1cbmZ1bmN0aW9uIFRvU2hvd0NhbGVuZGFyT3B0aW9uKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gR2V0T3B0aW9uKG9wdGlvbnMsICdjYWxlbmRhck5hbWUnLCBbJ2F1dG8nLCAnYWx3YXlzJywgJ25ldmVyJ10sICdhdXRvJyk7XG59XG5mdW5jdGlvbiBUb1Nob3dUaW1lWm9uZU5hbWVPcHRpb24ob3B0aW9ucykge1xuICAgIHJldHVybiBHZXRPcHRpb24ob3B0aW9ucywgJ3RpbWVab25lTmFtZScsIFsnYXV0bycsICduZXZlciddLCAnYXV0bycpO1xufVxuZnVuY3Rpb24gVG9TaG93T2Zmc2V0T3B0aW9uKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gR2V0T3B0aW9uKG9wdGlvbnMsICdvZmZzZXQnLCBbJ2F1dG8nLCAnbmV2ZXInXSwgJ2F1dG8nKTtcbn1cbmZ1bmN0aW9uIFRvVGVtcG9yYWxSb3VuZGluZ0luY3JlbWVudChvcHRpb25zLCBkaXZpZGVuZCwgaW5jbHVzaXZlKSB7XG4gICAgbGV0IG1heGltdW0gPSBJbmZpbml0eTtcbiAgICBpZiAoZGl2aWRlbmQgIT09IHVuZGVmaW5lZClcbiAgICAgICAgbWF4aW11bSA9IGRpdmlkZW5kO1xuICAgIGlmICghaW5jbHVzaXZlICYmIGRpdmlkZW5kICE9PSB1bmRlZmluZWQpXG4gICAgICAgIG1heGltdW0gPSBkaXZpZGVuZCA+IDEgPyBkaXZpZGVuZCAtIDEgOiAxO1xuICAgIGNvbnN0IGluY3JlbWVudCA9IEdldE51bWJlck9wdGlvbihvcHRpb25zLCAncm91bmRpbmdJbmNyZW1lbnQnLCAxLCBtYXhpbXVtLCAxKTtcbiAgICBpZiAoZGl2aWRlbmQgIT09IHVuZGVmaW5lZCAmJiBkaXZpZGVuZCAlIGluY3JlbWVudCAhPT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgUm91bmRpbmcgaW5jcmVtZW50IG11c3QgZGl2aWRlIGV2ZW5seSBpbnRvICR7ZGl2aWRlbmR9YCk7XG4gICAgfVxuICAgIHJldHVybiBpbmNyZW1lbnQ7XG59XG5mdW5jdGlvbiBUb1RlbXBvcmFsRGF0ZVRpbWVSb3VuZGluZ0luY3JlbWVudChvcHRpb25zLCBzbWFsbGVzdFVuaXQpIHtcbiAgICBjb25zdCBtYXhpbXVtSW5jcmVtZW50cyA9IHtcbiAgICAgICAgeWVhcjogdW5kZWZpbmVkLFxuICAgICAgICBtb250aDogdW5kZWZpbmVkLFxuICAgICAgICB3ZWVrOiB1bmRlZmluZWQsXG4gICAgICAgIGRheTogdW5kZWZpbmVkLFxuICAgICAgICBob3VyOiAyNCxcbiAgICAgICAgbWludXRlOiA2MCxcbiAgICAgICAgc2Vjb25kOiA2MCxcbiAgICAgICAgbWlsbGlzZWNvbmQ6IDEwMDAsXG4gICAgICAgIG1pY3Jvc2Vjb25kOiAxMDAwLFxuICAgICAgICBuYW5vc2Vjb25kOiAxMDAwXG4gICAgfTtcbiAgICByZXR1cm4gVG9UZW1wb3JhbFJvdW5kaW5nSW5jcmVtZW50KG9wdGlvbnMsIG1heGltdW1JbmNyZW1lbnRzW3NtYWxsZXN0VW5pdF0sIGZhbHNlKTtcbn1cbmZ1bmN0aW9uIFRvU2Vjb25kc1N0cmluZ1ByZWNpc2lvbihvcHRpb25zKSB7XG4gICAgY29uc3Qgc21hbGxlc3RVbml0ID0gVG9TbWFsbGVzdFRlbXBvcmFsVW5pdChvcHRpb25zLCB1bmRlZmluZWQsIFsneWVhcicsICdtb250aCcsICd3ZWVrJywgJ2RheScsICdob3VyJ10pO1xuICAgIHN3aXRjaCAoc21hbGxlc3RVbml0KSB7XG4gICAgICAgIGNhc2UgJ21pbnV0ZSc6XG4gICAgICAgICAgICByZXR1cm4geyBwcmVjaXNpb246ICdtaW51dGUnLCB1bml0OiAnbWludXRlJywgaW5jcmVtZW50OiAxIH07XG4gICAgICAgIGNhc2UgJ3NlY29uZCc6XG4gICAgICAgICAgICByZXR1cm4geyBwcmVjaXNpb246IDAsIHVuaXQ6ICdzZWNvbmQnLCBpbmNyZW1lbnQ6IDEgfTtcbiAgICAgICAgY2FzZSAnbWlsbGlzZWNvbmQnOlxuICAgICAgICAgICAgcmV0dXJuIHsgcHJlY2lzaW9uOiAzLCB1bml0OiAnbWlsbGlzZWNvbmQnLCBpbmNyZW1lbnQ6IDEgfTtcbiAgICAgICAgY2FzZSAnbWljcm9zZWNvbmQnOlxuICAgICAgICAgICAgcmV0dXJuIHsgcHJlY2lzaW9uOiA2LCB1bml0OiAnbWljcm9zZWNvbmQnLCBpbmNyZW1lbnQ6IDEgfTtcbiAgICAgICAgY2FzZSAnbmFub3NlY29uZCc6XG4gICAgICAgICAgICByZXR1cm4geyBwcmVjaXNpb246IDksIHVuaXQ6ICduYW5vc2Vjb25kJywgaW5jcmVtZW50OiAxIH07XG4gICAgfVxuICAgIGxldCBkaWdpdHMgPSBvcHRpb25zLmZyYWN0aW9uYWxTZWNvbmREaWdpdHM7XG4gICAgaWYgKGRpZ2l0cyA9PT0gdW5kZWZpbmVkKVxuICAgICAgICBkaWdpdHMgPSAnYXV0byc7XG4gICAgaWYgKHR5cGVvZiBkaWdpdHMgIT09ICdudW1iZXInKSB7XG4gICAgICAgIGNvbnN0IHN0cmluZ0RpZ2l0cyA9IFRvU3RyaW5nKGRpZ2l0cyk7XG4gICAgICAgIGlmIChzdHJpbmdEaWdpdHMgPT09ICdhdXRvJylcbiAgICAgICAgICAgIHJldHVybiB7IHByZWNpc2lvbjogJ2F1dG8nLCB1bml0OiAnbmFub3NlY29uZCcsIGluY3JlbWVudDogMSB9O1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgZnJhY3Rpb25hbFNlY29uZERpZ2l0cyBtdXN0IGJlICdhdXRvJyBvciAwIHRocm91Z2ggOSwgbm90ICR7c3RyaW5nRGlnaXRzfWApO1xuICAgIH1cbiAgICBpZiAoTnVtYmVySXNOYU4oZGlnaXRzKSB8fCBkaWdpdHMgPCAwIHx8IGRpZ2l0cyA+IDkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYGZyYWN0aW9uYWxTZWNvbmREaWdpdHMgbXVzdCBiZSAnYXV0bycgb3IgMCB0aHJvdWdoIDksIG5vdCAke2RpZ2l0c31gKTtcbiAgICB9XG4gICAgY29uc3QgcHJlY2lzaW9uID0gTWF0aEZsb29yKGRpZ2l0cyk7XG4gICAgc3dpdGNoIChwcmVjaXNpb24pIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgcmV0dXJuIHsgcHJlY2lzaW9uLCB1bml0OiAnc2Vjb25kJywgaW5jcmVtZW50OiAxIH07XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICByZXR1cm4geyBwcmVjaXNpb24sIHVuaXQ6ICdtaWxsaXNlY29uZCcsIGluY3JlbWVudDogMTAgKiogKDMgLSBwcmVjaXNpb24pIH07XG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgY2FzZSA1OlxuICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICByZXR1cm4geyBwcmVjaXNpb24sIHVuaXQ6ICdtaWNyb3NlY29uZCcsIGluY3JlbWVudDogMTAgKiogKDYgLSBwcmVjaXNpb24pIH07XG4gICAgICAgIGNhc2UgNzpcbiAgICAgICAgY2FzZSA4OlxuICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICByZXR1cm4geyBwcmVjaXNpb24sIHVuaXQ6ICduYW5vc2Vjb25kJywgaW5jcmVtZW50OiAxMCAqKiAoOSAtIHByZWNpc2lvbikgfTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBmcmFjdGlvbmFsU2Vjb25kRGlnaXRzIG11c3QgYmUgJ2F1dG8nIG9yIDAgdGhyb3VnaCA5LCBub3QgJHtkaWdpdHN9YCk7XG4gICAgfVxufVxuZnVuY3Rpb24gVG9MYXJnZXN0VGVtcG9yYWxVbml0KG9wdGlvbnMsIGZhbGxiYWNrLCBkaXNhbGxvd2VkU3RyaW5ncyA9IFtdLCBhdXRvVmFsdWUpIHtcbiAgICBjb25zdCBzaW5ndWxhciA9IG5ldyBNYXAoU0lOR1VMQVJfUExVUkFMX1VOSVRTLmZpbHRlcigoWywgc2luZ10pID0+ICFkaXNhbGxvd2VkU3RyaW5ncy5pbmNsdWRlcyhzaW5nKSkpO1xuICAgIGNvbnN0IGFsbG93ZWQgPSBuZXcgU2V0KEFMTE9XRURfVU5JVFMpO1xuICAgIGZvciAoY29uc3QgcyBvZiBkaXNhbGxvd2VkU3RyaW5ncykge1xuICAgICAgICBhbGxvd2VkLmRlbGV0ZShzKTtcbiAgICB9XG4gICAgY29uc3QgcmV0dmFsID0gR2V0T3B0aW9uKG9wdGlvbnMsICdsYXJnZXN0VW5pdCcsIFsnYXV0bycsIC4uLmFsbG93ZWQsIC4uLnNpbmd1bGFyLmtleXMoKV0sIGZhbGxiYWNrKTtcbiAgICBpZiAocmV0dmFsID09PSAnYXV0bycgJiYgYXV0b1ZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiBhdXRvVmFsdWU7XG4gICAgaWYgKHNpbmd1bGFyLmhhcyhyZXR2YWwpKSB7XG4gICAgICAgIHJldHVybiBzaW5ndWxhci5nZXQocmV0dmFsKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldHZhbDtcbn1cbmZ1bmN0aW9uIFRvU21hbGxlc3RUZW1wb3JhbFVuaXQob3B0aW9ucywgZmFsbGJhY2ssIGRpc2FsbG93ZWRTdHJpbmdzID0gW10pIHtcbiAgICBjb25zdCBzaW5ndWxhciA9IG5ldyBNYXAoU0lOR1VMQVJfUExVUkFMX1VOSVRTLmZpbHRlcigoWywgc2luZ10pID0+ICFkaXNhbGxvd2VkU3RyaW5ncy5pbmNsdWRlcyhzaW5nKSkpO1xuICAgIGNvbnN0IGFsbG93ZWQgPSBuZXcgU2V0KEFMTE9XRURfVU5JVFMpO1xuICAgIGZvciAoY29uc3QgcyBvZiBkaXNhbGxvd2VkU3RyaW5ncykge1xuICAgICAgICBhbGxvd2VkLmRlbGV0ZShzKTtcbiAgICB9XG4gICAgY29uc3QgdmFsdWUgPSBHZXRPcHRpb24ob3B0aW9ucywgJ3NtYWxsZXN0VW5pdCcsIFsuLi5hbGxvd2VkLCAuLi5zaW5ndWxhci5rZXlzKCldLCBmYWxsYmFjayk7XG4gICAgaWYgKHNpbmd1bGFyLmhhcyh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHNpbmd1bGFyLmdldCh2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIFRvVGVtcG9yYWxEdXJhdGlvblRvdGFsVW5pdChvcHRpb25zKSB7XG4gICAgLy8gVGhpcyBBTyBpcyBpZGVudGljYWwgdG8gVG9TbWFsbGVzdFRlbXBvcmFsVW5pdCwgZXhjZXB0OlxuICAgIC8vIC0gZGVmYXVsdCBpcyBhbHdheXMgYHVuZGVmaW5lZGAgKGNhbGxlciB3aWxsIHRocm93IGlmIG9taXR0ZWQpXG4gICAgLy8gLSBvcHRpb24gaXMgbmFtZWQgYHVuaXRgIChub3QgYHNtYWxsZXN0VW5pdGApXG4gICAgLy8gLSBhbGwgdW5pdHMgYXJlIHZhbGlkIChubyBgZGlzYWxsb3dlZFN0cmluZ3NgKVxuICAgIGNvbnN0IHNpbmd1bGFyID0gbmV3IE1hcChTSU5HVUxBUl9QTFVSQUxfVU5JVFMpO1xuICAgIGNvbnN0IHZhbHVlID0gR2V0T3B0aW9uKG9wdGlvbnMsICd1bml0JywgWy4uLnNpbmd1bGFyLnZhbHVlcygpLCAuLi5zaW5ndWxhci5rZXlzKCldLCB1bmRlZmluZWQpO1xuICAgIGlmIChzaW5ndWxhci5oYXModmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBzaW5ndWxhci5nZXQodmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59XG5mdW5jdGlvbiBUb1JlbGF0aXZlVGVtcG9yYWxPYmplY3Qob3B0aW9ucykge1xuICAgIGNvbnN0IHJlbGF0aXZlVG8gPSBvcHRpb25zLnJlbGF0aXZlVG87XG4gICAgaWYgKHJlbGF0aXZlVG8gPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIHJlbGF0aXZlVG87XG4gICAgbGV0IG9mZnNldEJlaGF2aW91ciA9ICdvcHRpb24nO1xuICAgIGxldCBtYXRjaE1pbnV0ZXMgPSBmYWxzZTtcbiAgICBsZXQgeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kLCBtaWNyb3NlY29uZCwgbmFub3NlY29uZCwgY2FsZW5kYXIsIHRpbWVab25lLCBvZmZzZXQ7XG4gICAgaWYgKElzT2JqZWN0KHJlbGF0aXZlVG8pKSB7XG4gICAgICAgIGlmIChJc1RlbXBvcmFsWm9uZWREYXRlVGltZShyZWxhdGl2ZVRvKSB8fCBJc1RlbXBvcmFsRGF0ZShyZWxhdGl2ZVRvKSlcbiAgICAgICAgICAgIHJldHVybiByZWxhdGl2ZVRvO1xuICAgICAgICBpZiAoSXNUZW1wb3JhbERhdGVUaW1lKHJlbGF0aXZlVG8pKVxuICAgICAgICAgICAgcmV0dXJuIFRlbXBvcmFsRGF0ZVRpbWVUb0RhdGUocmVsYXRpdmVUbyk7XG4gICAgICAgIGNhbGVuZGFyID0gR2V0VGVtcG9yYWxDYWxlbmRhcldpdGhJU09EZWZhdWx0KHJlbGF0aXZlVG8pO1xuICAgICAgICBjb25zdCBmaWVsZE5hbWVzID0gQ2FsZW5kYXJGaWVsZHMoY2FsZW5kYXIsIFtcbiAgICAgICAgICAgICdkYXknLFxuICAgICAgICAgICAgJ2hvdXInLFxuICAgICAgICAgICAgJ21pY3Jvc2Vjb25kJyxcbiAgICAgICAgICAgICdtaWxsaXNlY29uZCcsXG4gICAgICAgICAgICAnbWludXRlJyxcbiAgICAgICAgICAgICdtb250aCcsXG4gICAgICAgICAgICAnbW9udGhDb2RlJyxcbiAgICAgICAgICAgICduYW5vc2Vjb25kJyxcbiAgICAgICAgICAgICdzZWNvbmQnLFxuICAgICAgICAgICAgJ3llYXInXG4gICAgICAgIF0pO1xuICAgICAgICBjb25zdCBmaWVsZHMgPSBUb1RlbXBvcmFsRGF0ZVRpbWVGaWVsZHMocmVsYXRpdmVUbywgZmllbGROYW1lcyk7XG4gICAgICAgIGNvbnN0IGRhdGVPcHRpb25zID0gT2JqZWN0Q3JlYXRlJDIobnVsbCk7XG4gICAgICAgIGRhdGVPcHRpb25zLm92ZXJmbG93ID0gJ2NvbnN0cmFpbic7XG4gICAgICAgICh7IHllYXIsIG1vbnRoLCBkYXksIGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZCwgbWljcm9zZWNvbmQsIG5hbm9zZWNvbmQgfSA9IEludGVycHJldFRlbXBvcmFsRGF0ZVRpbWVGaWVsZHMoY2FsZW5kYXIsIGZpZWxkcywgZGF0ZU9wdGlvbnMpKTtcbiAgICAgICAgLy8gVGhlIGBvZmZzZXRgIGFuZCBgdGltZVpvbmVgIHByb3BlcnRpZXMgb25seSBleGlzdCBvbiBab25lZERhdGVUaW1lIChvclxuICAgICAgICAvLyBab25lZERhdGVUaW1lTGlrZS1wcm9wZXJ0eSBiYWdzKS4gVGhlIGFzc2VydGlvbnMgYmVsb3cgYXJlIHVzZWQgdG8gYXZvaWRcbiAgICAgICAgLy8gVFMgZXJyb3JzIHdoaWxlIG5vdCBkaXZlcmdpbmcgcnVudGltZSBjb2RlIGZyb20gcHJvcG9zYWwtdGVtcG9yYWwuXG4gICAgICAgIG9mZnNldCA9IHJlbGF0aXZlVG8ub2Zmc2V0O1xuICAgICAgICBpZiAob2Zmc2V0ID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICBvZmZzZXRCZWhhdmlvdXIgPSAnd2FsbCc7XG4gICAgICAgIHRpbWVab25lID0gcmVsYXRpdmVUby50aW1lWm9uZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGxldCBpYW5hTmFtZSwgejtcbiAgICAgICAgKHsgeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kLCBtaWNyb3NlY29uZCwgbmFub3NlY29uZCwgY2FsZW5kYXIsIGlhbmFOYW1lLCBvZmZzZXQsIHogfSA9XG4gICAgICAgICAgICBQYXJzZUlTT0RhdGVUaW1lKFRvU3RyaW5nKHJlbGF0aXZlVG8pKSk7XG4gICAgICAgIGlmIChpYW5hTmFtZSlcbiAgICAgICAgICAgIHRpbWVab25lID0gaWFuYU5hbWU7XG4gICAgICAgIGlmICh6KSB7XG4gICAgICAgICAgICBvZmZzZXRCZWhhdmlvdXIgPSAnZXhhY3QnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFvZmZzZXQpIHtcbiAgICAgICAgICAgIG9mZnNldEJlaGF2aW91ciA9ICd3YWxsJztcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNhbGVuZGFyKVxuICAgICAgICAgICAgY2FsZW5kYXIgPSBHZXRJU084NjAxQ2FsZW5kYXIoKTtcbiAgICAgICAgY2FsZW5kYXIgPSBUb1RlbXBvcmFsQ2FsZW5kYXIoY2FsZW5kYXIpO1xuICAgICAgICBtYXRjaE1pbnV0ZXMgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAodGltZVpvbmUpIHtcbiAgICAgICAgdGltZVpvbmUgPSBUb1RlbXBvcmFsVGltZVpvbmUodGltZVpvbmUpO1xuICAgICAgICBsZXQgb2Zmc2V0TnMgPSAwO1xuICAgICAgICBpZiAob2Zmc2V0QmVoYXZpb3VyID09PSAnb3B0aW9uJylcbiAgICAgICAgICAgIG9mZnNldE5zID0gUGFyc2VUaW1lWm9uZU9mZnNldFN0cmluZyhUb1N0cmluZyhvZmZzZXQpKTtcbiAgICAgICAgY29uc3QgZXBvY2hOYW5vc2Vjb25kcyA9IEludGVycHJldElTT0RhdGVUaW1lT2Zmc2V0KHllYXIsIG1vbnRoLCBkYXksIGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZCwgbWljcm9zZWNvbmQsIG5hbm9zZWNvbmQsIG9mZnNldEJlaGF2aW91ciwgb2Zmc2V0TnMsIHRpbWVab25lLCAnY29tcGF0aWJsZScsICdyZWplY3QnLCBtYXRjaE1pbnV0ZXMpO1xuICAgICAgICByZXR1cm4gQ3JlYXRlVGVtcG9yYWxab25lZERhdGVUaW1lKGVwb2NoTmFub3NlY29uZHMsIHRpbWVab25lLCBjYWxlbmRhcik7XG4gICAgfVxuICAgIHJldHVybiBDcmVhdGVUZW1wb3JhbERhdGUoeWVhciwgbW9udGgsIGRheSwgY2FsZW5kYXIpO1xufVxuZnVuY3Rpb24gVmFsaWRhdGVUZW1wb3JhbFVuaXRSYW5nZShsYXJnZXN0VW5pdCwgc21hbGxlc3RVbml0KSB7XG4gICAgaWYgKEFMTE9XRURfVU5JVFMuaW5kZXhPZihsYXJnZXN0VW5pdCkgPiBBTExPV0VEX1VOSVRTLmluZGV4T2Yoc21hbGxlc3RVbml0KSkge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgbGFyZ2VzdFVuaXQgJHtsYXJnZXN0VW5pdH0gY2Fubm90IGJlIHNtYWxsZXIgdGhhbiBzbWFsbGVzdFVuaXQgJHtzbWFsbGVzdFVuaXR9YCk7XG4gICAgfVxufVxuZnVuY3Rpb24gRGVmYXVsdFRlbXBvcmFsTGFyZ2VzdFVuaXQoeWVhcnMsIG1vbnRocywgd2Vla3MsIGRheXMsIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBtaWxsaXNlY29uZHMsIG1pY3Jvc2Vjb25kcywgbmFub3NlY29uZHMpIHtcbiAgICBjb25zdCBzaW5ndWxhciA9IG5ldyBNYXAoU0lOR1VMQVJfUExVUkFMX1VOSVRTKTtcbiAgICBmb3IgKGNvbnN0IFtwcm9wLCB2XSBvZiBbXG4gICAgICAgIFsneWVhcnMnLCB5ZWFyc10sXG4gICAgICAgIFsnbW9udGhzJywgbW9udGhzXSxcbiAgICAgICAgWyd3ZWVrcycsIHdlZWtzXSxcbiAgICAgICAgWydkYXlzJywgZGF5c10sXG4gICAgICAgIFsnaG91cnMnLCBob3Vyc10sXG4gICAgICAgIFsnbWludXRlcycsIG1pbnV0ZXNdLFxuICAgICAgICBbJ3NlY29uZHMnLCBzZWNvbmRzXSxcbiAgICAgICAgWydtaWxsaXNlY29uZHMnLCBtaWxsaXNlY29uZHNdLFxuICAgICAgICBbJ21pY3Jvc2Vjb25kcycsIG1pY3Jvc2Vjb25kc10sXG4gICAgICAgIFsnbmFub3NlY29uZHMnLCBuYW5vc2Vjb25kc11cbiAgICBdKSB7XG4gICAgICAgIGlmICh2ICE9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIHNpbmd1bGFyLmdldChwcm9wKTtcbiAgICB9XG4gICAgcmV0dXJuICduYW5vc2Vjb25kJztcbn1cbmZ1bmN0aW9uIExhcmdlck9mVHdvVGVtcG9yYWxVbml0cyh1bml0MSwgdW5pdDIpIHtcbiAgICBpZiAoQUxMT1dFRF9VTklUUy5pbmRleE9mKHVuaXQxKSA+IEFMTE9XRURfVU5JVFMuaW5kZXhPZih1bml0MikpXG4gICAgICAgIHJldHVybiB1bml0MjtcbiAgICByZXR1cm4gdW5pdDE7XG59XG5mdW5jdGlvbiBUb1BhcnRpYWxSZWNvcmQoYmFnUGFyYW0sIGZpZWxkc1BhcmFtKSB7XG4gICAgLy8gRXh0ZXJuYWwgY2FsbGVycyBhcmUgbGltaXRlZCB0byBzcGVjaWZpYyB0eXBlcywgYnV0IHRoaXMgZnVuY3Rpb24nc1xuICAgIC8vIGltcGxlbWVudGF0aW9uIHVzZXMgZ2VuZXJpYyBwcm9wZXJ0eSB0eXBlcy4gVGhlIGNhc3RzIGJlbG93IChhbmQgYXQgdGhlXG4gICAgLy8gZW5kKSBjb252ZXJ0IHRvL2Zyb20gZ2VuZXJpYyByZWNvcmRzLlxuICAgIGNvbnN0IGJhZyA9IGJhZ1BhcmFtO1xuICAgIGNvbnN0IGZpZWxkcyA9IGZpZWxkc1BhcmFtO1xuICAgIGxldCBhbnkgPSBmYWxzZTtcbiAgICBsZXQgcmVzdWx0ID0ge307XG4gICAgZm9yIChjb25zdCBwcm9wZXJ0eSBvZiBmaWVsZHMpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBiYWdbcHJvcGVydHldO1xuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgYW55ID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChCVUlMVElOX0NBU1RTLmhhcyhwcm9wZXJ0eSkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRbcHJvcGVydHldID0gQlVJTFRJTl9DQVNUUy5nZXQocHJvcGVydHkpKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdFtwcm9wZXJ0eV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYW55ID8gcmVzdWx0IDogZmFsc2U7XG59XG5mdW5jdGlvbiBQcmVwYXJlVGVtcG9yYWxGaWVsZHMoYmFnUGFyYW0sIGZpZWxkc1BhcmFtKSB7XG4gICAgLy8gRXh0ZXJuYWwgY2FsbGVycyBhcmUgbGltaXRlZCB0byBzcGVjaWZpYyB0eXBlcywgYnV0IHRoaXMgZnVuY3Rpb24nc1xuICAgIC8vIGltcGxlbWVudGF0aW9uIHVzZXMgZ2VuZXJpYyBwcm9wZXJ0eSB0eXBlcy4gVGhlIGNhc3RzIGJlbG93IChhbmQgYXQgdGhlXG4gICAgLy8gZW5kKSBjb252ZXJ0IHRvL2Zyb20gZ2VuZXJpYyByZWNvcmRzLlxuICAgIGNvbnN0IGJhZyA9IGJhZ1BhcmFtO1xuICAgIGNvbnN0IGZpZWxkcyA9IGZpZWxkc1BhcmFtO1xuICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgIGxldCBhbnkgPSBmYWxzZTtcbiAgICBmb3IgKGNvbnN0IGZpZWxkUmVjb3JkIG9mIGZpZWxkcykge1xuICAgICAgICBjb25zdCBbcHJvcGVydHksIGRlZmF1bHRWYWx1ZV0gPSBmaWVsZFJlY29yZDtcbiAgICAgICAgbGV0IHZhbHVlID0gYmFnW3Byb3BlcnR5XTtcbiAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmIChmaWVsZFJlY29yZC5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGByZXF1aXJlZCBwcm9wZXJ0eSAnJHtwcm9wZXJ0eX0nIG1pc3Npbmcgb3IgdW5kZWZpbmVkYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YWx1ZSA9IGRlZmF1bHRWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGFueSA9IHRydWU7XG4gICAgICAgICAgICBpZiAoQlVJTFRJTl9DQVNUUy5oYXMocHJvcGVydHkpKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBCVUlMVElOX0NBU1RTLmdldChwcm9wZXJ0eSkodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlc3VsdFtwcm9wZXJ0eV0gPSB2YWx1ZTtcbiAgICB9XG4gICAgaWYgKCFhbnkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbm8gc3VwcG9ydGVkIHByb3BlcnRpZXMgZm91bmQnKTtcbiAgICB9XG4gICAgaWYgKChyZXN1bHRbJ2VyYSddID09PSB1bmRlZmluZWQpICE9PVxuICAgICAgICAocmVzdWx0WydlcmFZZWFyJ10gPT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJwcm9wZXJ0aWVzICdlcmEnIGFuZCAnZXJhWWVhcicgbXVzdCBiZSBwcm92aWRlZCB0b2dldGhlclwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8vIGZpZWxkIGFjY2VzcyBpbiB0aGUgZm9sbG93aW5nIG9wZXJhdGlvbnMgaXMgaW50ZW50aW9uYWxseSBhbHBoYWJldGljYWxcbmZ1bmN0aW9uIFRvVGVtcG9yYWxEYXRlRmllbGRzKGJhZywgZmllbGROYW1lcykge1xuICAgIGNvbnN0IGVudHJpZXMgPSBbXG4gICAgICAgIFsnZGF5JywgdW5kZWZpbmVkXSxcbiAgICAgICAgWydtb250aCcsIHVuZGVmaW5lZF0sXG4gICAgICAgIFsnbW9udGhDb2RlJywgdW5kZWZpbmVkXSxcbiAgICAgICAgWyd5ZWFyJywgdW5kZWZpbmVkXVxuICAgIF07XG4gICAgLy8gQWRkIGV4dHJhIGZpZWxkcyBmcm9tIHRoZSBjYWxlbmRhciBhdCB0aGUgZW5kXG4gICAgZmllbGROYW1lcy5mb3JFYWNoKChmaWVsZE5hbWUpID0+IHtcbiAgICAgICAgaWYgKCFlbnRyaWVzLnNvbWUoKFtuYW1lXSkgPT4gbmFtZSA9PT0gZmllbGROYW1lKSkge1xuICAgICAgICAgICAgZW50cmllcy5wdXNoKFtmaWVsZE5hbWUsIHVuZGVmaW5lZF0pO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIFByZXBhcmVUZW1wb3JhbEZpZWxkcyhiYWcsIGVudHJpZXMpO1xufVxuZnVuY3Rpb24gVG9UZW1wb3JhbERhdGVUaW1lRmllbGRzKGJhZywgZmllbGROYW1lcykge1xuICAgIGNvbnN0IGVudHJpZXMgPSBbXG4gICAgICAgIFsnZGF5JywgdW5kZWZpbmVkXSxcbiAgICAgICAgWydob3VyJywgMF0sXG4gICAgICAgIFsnbWljcm9zZWNvbmQnLCAwXSxcbiAgICAgICAgWydtaWxsaXNlY29uZCcsIDBdLFxuICAgICAgICBbJ21pbnV0ZScsIDBdLFxuICAgICAgICBbJ21vbnRoJywgdW5kZWZpbmVkXSxcbiAgICAgICAgWydtb250aENvZGUnLCB1bmRlZmluZWRdLFxuICAgICAgICBbJ25hbm9zZWNvbmQnLCAwXSxcbiAgICAgICAgWydzZWNvbmQnLCAwXSxcbiAgICAgICAgWyd5ZWFyJywgdW5kZWZpbmVkXVxuICAgIF07XG4gICAgLy8gQWRkIGV4dHJhIGZpZWxkcyBmcm9tIHRoZSBjYWxlbmRhciBhdCB0aGUgZW5kXG4gICAgZmllbGROYW1lcy5mb3JFYWNoKChmaWVsZE5hbWUpID0+IHtcbiAgICAgICAgaWYgKCFlbnRyaWVzLnNvbWUoKFtuYW1lXSkgPT4gbmFtZSA9PT0gZmllbGROYW1lKSkge1xuICAgICAgICAgICAgZW50cmllcy5wdXNoKFtmaWVsZE5hbWUsIHVuZGVmaW5lZF0pO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIFByZXBhcmVUZW1wb3JhbEZpZWxkcyhiYWcsIGVudHJpZXMpO1xufVxuZnVuY3Rpb24gVG9UZW1wb3JhbE1vbnRoRGF5RmllbGRzKGJhZywgZmllbGROYW1lcykge1xuICAgIGNvbnN0IGVudHJpZXMgPSBbXG4gICAgICAgIFsnZGF5JywgdW5kZWZpbmVkXSxcbiAgICAgICAgWydtb250aCcsIHVuZGVmaW5lZF0sXG4gICAgICAgIFsnbW9udGhDb2RlJywgdW5kZWZpbmVkXSxcbiAgICAgICAgWyd5ZWFyJywgdW5kZWZpbmVkXVxuICAgIF07XG4gICAgLy8gQWRkIGV4dHJhIGZpZWxkcyBmcm9tIHRoZSBjYWxlbmRhciBhdCB0aGUgZW5kXG4gICAgZmllbGROYW1lcy5mb3JFYWNoKChmaWVsZE5hbWUpID0+IHtcbiAgICAgICAgaWYgKCFlbnRyaWVzLnNvbWUoKFtuYW1lXSkgPT4gbmFtZSA9PT0gZmllbGROYW1lKSkge1xuICAgICAgICAgICAgZW50cmllcy5wdXNoKFtmaWVsZE5hbWUsIHVuZGVmaW5lZF0pO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIFByZXBhcmVUZW1wb3JhbEZpZWxkcyhiYWcsIGVudHJpZXMpO1xufVxuZnVuY3Rpb24gVG9UZW1wb3JhbFRpbWVSZWNvcmQoYmFnKSB7XG4gICAgcmV0dXJuIFByZXBhcmVUZW1wb3JhbEZpZWxkcyhiYWcsIFtcbiAgICAgICAgWydob3VyJywgMF0sXG4gICAgICAgIFsnbWljcm9zZWNvbmQnLCAwXSxcbiAgICAgICAgWydtaWxsaXNlY29uZCcsIDBdLFxuICAgICAgICBbJ21pbnV0ZScsIDBdLFxuICAgICAgICBbJ25hbm9zZWNvbmQnLCAwXSxcbiAgICAgICAgWydzZWNvbmQnLCAwXVxuICAgIF0pO1xufVxuZnVuY3Rpb24gVG9UZW1wb3JhbFllYXJNb250aEZpZWxkcyhiYWcsIGZpZWxkTmFtZXMpIHtcbiAgICBjb25zdCBlbnRyaWVzID0gW1xuICAgICAgICBbJ21vbnRoJywgdW5kZWZpbmVkXSxcbiAgICAgICAgWydtb250aENvZGUnLCB1bmRlZmluZWRdLFxuICAgICAgICBbJ3llYXInLCB1bmRlZmluZWRdXG4gICAgXTtcbiAgICAvLyBBZGQgZXh0cmEgZmllbGRzIGZyb20gdGhlIGNhbGVuZGFyIGF0IHRoZSBlbmRcbiAgICBmaWVsZE5hbWVzLmZvckVhY2goKGZpZWxkTmFtZSkgPT4ge1xuICAgICAgICBpZiAoIWVudHJpZXMuc29tZSgoW25hbWVdKSA9PiBuYW1lID09PSBmaWVsZE5hbWUpKSB7XG4gICAgICAgICAgICBlbnRyaWVzLnB1c2goW2ZpZWxkTmFtZSwgdW5kZWZpbmVkXSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gUHJlcGFyZVRlbXBvcmFsRmllbGRzKGJhZywgZW50cmllcyk7XG59XG5mdW5jdGlvbiBUb1RlbXBvcmFsWm9uZWREYXRlVGltZUZpZWxkcyhiYWcsIGZpZWxkTmFtZXMpIHtcbiAgICBjb25zdCBlbnRyaWVzID0gW1xuICAgICAgICBbJ2RheScsIHVuZGVmaW5lZF0sXG4gICAgICAgIFsnaG91cicsIDBdLFxuICAgICAgICBbJ21pY3Jvc2Vjb25kJywgMF0sXG4gICAgICAgIFsnbWlsbGlzZWNvbmQnLCAwXSxcbiAgICAgICAgWydtaW51dGUnLCAwXSxcbiAgICAgICAgWydtb250aCcsIHVuZGVmaW5lZF0sXG4gICAgICAgIFsnbW9udGhDb2RlJywgdW5kZWZpbmVkXSxcbiAgICAgICAgWyduYW5vc2Vjb25kJywgMF0sXG4gICAgICAgIFsnc2Vjb25kJywgMF0sXG4gICAgICAgIFsneWVhcicsIHVuZGVmaW5lZF0sXG4gICAgICAgIFsnb2Zmc2V0JywgdW5kZWZpbmVkXSxcbiAgICAgICAgWyd0aW1lWm9uZSddXG4gICAgXTtcbiAgICAvLyBBZGQgZXh0cmEgZmllbGRzIGZyb20gdGhlIGNhbGVuZGFyIGF0IHRoZSBlbmRcbiAgICBmaWVsZE5hbWVzLmZvckVhY2goKGZpZWxkTmFtZSkgPT4ge1xuICAgICAgICBpZiAoIWVudHJpZXMuc29tZSgoW25hbWVdKSA9PiBuYW1lID09PSBmaWVsZE5hbWUpKSB7XG4gICAgICAgICAgICBlbnRyaWVzLnB1c2goW2ZpZWxkTmFtZSwgdW5kZWZpbmVkXSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gUHJlcGFyZVRlbXBvcmFsRmllbGRzKGJhZywgZW50cmllcyk7XG59XG5mdW5jdGlvbiBUb1RlbXBvcmFsRGF0ZShpdGVtUGFyYW0sIG9wdGlvbnMgPSBPYmplY3RDcmVhdGUkMihudWxsKSkge1xuICAgIGxldCBpdGVtID0gaXRlbVBhcmFtO1xuICAgIGlmIChJc09iamVjdChpdGVtKSkge1xuICAgICAgICBpZiAoSXNUZW1wb3JhbERhdGUoaXRlbSkpXG4gICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgaWYgKElzVGVtcG9yYWxab25lZERhdGVUaW1lKGl0ZW0pKSB7XG4gICAgICAgICAgICBpdGVtID0gQnVpbHRpblRpbWVab25lR2V0UGxhaW5EYXRlVGltZUZvcihHZXRTbG90KGl0ZW0sIFRJTUVfWk9ORSksIEdldFNsb3QoaXRlbSwgSU5TVEFOVCksIEdldFNsb3QoaXRlbSwgQ0FMRU5EQVIpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoSXNUZW1wb3JhbERhdGVUaW1lKGl0ZW0pKSB7XG4gICAgICAgICAgICByZXR1cm4gQ3JlYXRlVGVtcG9yYWxEYXRlKEdldFNsb3QoaXRlbSwgSVNPX1lFQVIpLCBHZXRTbG90KGl0ZW0sIElTT19NT05USCksIEdldFNsb3QoaXRlbSwgSVNPX0RBWSksIEdldFNsb3QoaXRlbSwgQ0FMRU5EQVIpKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjYWxlbmRhciA9IEdldFRlbXBvcmFsQ2FsZW5kYXJXaXRoSVNPRGVmYXVsdChpdGVtKTtcbiAgICAgICAgY29uc3QgZmllbGROYW1lcyA9IENhbGVuZGFyRmllbGRzKGNhbGVuZGFyLCBbJ2RheScsICdtb250aCcsICdtb250aENvZGUnLCAneWVhciddKTtcbiAgICAgICAgY29uc3QgZmllbGRzID0gVG9UZW1wb3JhbERhdGVGaWVsZHMoaXRlbSwgZmllbGROYW1lcyk7XG4gICAgICAgIHJldHVybiBEYXRlRnJvbUZpZWxkcyhjYWxlbmRhciwgZmllbGRzLCBvcHRpb25zKTtcbiAgICB9XG4gICAgVG9UZW1wb3JhbE92ZXJmbG93KG9wdGlvbnMpOyAvLyB2YWxpZGF0ZSBhbmQgaWdub3JlXG4gICAgY29uc3QgeyB5ZWFyLCBtb250aCwgZGF5LCBjYWxlbmRhciwgeiB9ID0gUGFyc2VUZW1wb3JhbERhdGVTdHJpbmcoVG9TdHJpbmcoaXRlbSkpO1xuICAgIGlmICh6KVxuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignWiBkZXNpZ25hdG9yIG5vdCBzdXBwb3J0ZWQgZm9yIFBsYWluRGF0ZScpO1xuICAgIGNvbnN0IFRlbXBvcmFsUGxhaW5EYXRlID0gR2V0SW50cmluc2ljKCclVGVtcG9yYWwuUGxhaW5EYXRlJScpO1xuICAgIHJldHVybiBuZXcgVGVtcG9yYWxQbGFpbkRhdGUoeWVhciwgbW9udGgsIGRheSwgY2FsZW5kYXIpOyAvLyBpbmNsdWRlIHZhbGlkYXRpb25cbn1cbmZ1bmN0aW9uIEludGVycHJldFRlbXBvcmFsRGF0ZVRpbWVGaWVsZHMoY2FsZW5kYXIsIGZpZWxkcywgb3B0aW9ucykge1xuICAgIGxldCB7IGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZCwgbWljcm9zZWNvbmQsIG5hbm9zZWNvbmQgfSA9IFRvVGVtcG9yYWxUaW1lUmVjb3JkKGZpZWxkcyk7XG4gICAgY29uc3Qgb3ZlcmZsb3cgPSBUb1RlbXBvcmFsT3ZlcmZsb3cob3B0aW9ucyk7XG4gICAgY29uc3QgZGF0ZSA9IERhdGVGcm9tRmllbGRzKGNhbGVuZGFyLCBmaWVsZHMsIG9wdGlvbnMpO1xuICAgIGNvbnN0IHllYXIgPSBHZXRTbG90KGRhdGUsIElTT19ZRUFSKTtcbiAgICBjb25zdCBtb250aCA9IEdldFNsb3QoZGF0ZSwgSVNPX01PTlRIKTtcbiAgICBjb25zdCBkYXkgPSBHZXRTbG90KGRhdGUsIElTT19EQVkpO1xuICAgICh7IGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZCwgbWljcm9zZWNvbmQsIG5hbm9zZWNvbmQgfSA9IFJlZ3VsYXRlVGltZShob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQsIG1pY3Jvc2Vjb25kLCBuYW5vc2Vjb25kLCBvdmVyZmxvdykpO1xuICAgIHJldHVybiB7IHllYXIsIG1vbnRoLCBkYXksIGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZCwgbWljcm9zZWNvbmQsIG5hbm9zZWNvbmQgfTtcbn1cbmZ1bmN0aW9uIFRvVGVtcG9yYWxEYXRlVGltZShpdGVtLCBvcHRpb25zID0gT2JqZWN0Q3JlYXRlJDIobnVsbCkpIHtcbiAgICBsZXQgeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kLCBtaWNyb3NlY29uZCwgbmFub3NlY29uZCwgY2FsZW5kYXI7XG4gICAgaWYgKElzT2JqZWN0KGl0ZW0pKSB7XG4gICAgICAgIGlmIChJc1RlbXBvcmFsRGF0ZVRpbWUoaXRlbSkpXG4gICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgaWYgKElzVGVtcG9yYWxab25lZERhdGVUaW1lKGl0ZW0pKSB7XG4gICAgICAgICAgICByZXR1cm4gQnVpbHRpblRpbWVab25lR2V0UGxhaW5EYXRlVGltZUZvcihHZXRTbG90KGl0ZW0sIFRJTUVfWk9ORSksIEdldFNsb3QoaXRlbSwgSU5TVEFOVCksIEdldFNsb3QoaXRlbSwgQ0FMRU5EQVIpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoSXNUZW1wb3JhbERhdGUoaXRlbSkpIHtcbiAgICAgICAgICAgIHJldHVybiBDcmVhdGVUZW1wb3JhbERhdGVUaW1lKEdldFNsb3QoaXRlbSwgSVNPX1lFQVIpLCBHZXRTbG90KGl0ZW0sIElTT19NT05USCksIEdldFNsb3QoaXRlbSwgSVNPX0RBWSksIDAsIDAsIDAsIDAsIDAsIDAsIEdldFNsb3QoaXRlbSwgQ0FMRU5EQVIpKTtcbiAgICAgICAgfVxuICAgICAgICBjYWxlbmRhciA9IEdldFRlbXBvcmFsQ2FsZW5kYXJXaXRoSVNPRGVmYXVsdChpdGVtKTtcbiAgICAgICAgY29uc3QgZmllbGROYW1lcyA9IENhbGVuZGFyRmllbGRzKGNhbGVuZGFyLCBbXG4gICAgICAgICAgICAnZGF5JyxcbiAgICAgICAgICAgICdob3VyJyxcbiAgICAgICAgICAgICdtaWNyb3NlY29uZCcsXG4gICAgICAgICAgICAnbWlsbGlzZWNvbmQnLFxuICAgICAgICAgICAgJ21pbnV0ZScsXG4gICAgICAgICAgICAnbW9udGgnLFxuICAgICAgICAgICAgJ21vbnRoQ29kZScsXG4gICAgICAgICAgICAnbmFub3NlY29uZCcsXG4gICAgICAgICAgICAnc2Vjb25kJyxcbiAgICAgICAgICAgICd5ZWFyJ1xuICAgICAgICBdKTtcbiAgICAgICAgY29uc3QgZmllbGRzID0gVG9UZW1wb3JhbERhdGVUaW1lRmllbGRzKGl0ZW0sIGZpZWxkTmFtZXMpO1xuICAgICAgICAoeyB5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQsIG1pY3Jvc2Vjb25kLCBuYW5vc2Vjb25kIH0gPSBJbnRlcnByZXRUZW1wb3JhbERhdGVUaW1lRmllbGRzKGNhbGVuZGFyLCBmaWVsZHMsIG9wdGlvbnMpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIFRvVGVtcG9yYWxPdmVyZmxvdyhvcHRpb25zKTsgLy8gdmFsaWRhdGUgYW5kIGlnbm9yZVxuICAgICAgICBsZXQgejtcbiAgICAgICAgKHsgeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kLCBtaWNyb3NlY29uZCwgbmFub3NlY29uZCwgY2FsZW5kYXIsIHogfSA9XG4gICAgICAgICAgICBQYXJzZVRlbXBvcmFsRGF0ZVRpbWVTdHJpbmcoVG9TdHJpbmcoaXRlbSkpKTtcbiAgICAgICAgaWYgKHopXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignWiBkZXNpZ25hdG9yIG5vdCBzdXBwb3J0ZWQgZm9yIFBsYWluRGF0ZVRpbWUnKTtcbiAgICAgICAgUmVqZWN0RGF0ZVRpbWUoeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kLCBtaWNyb3NlY29uZCwgbmFub3NlY29uZCk7XG4gICAgICAgIGlmIChjYWxlbmRhciA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgY2FsZW5kYXIgPSBHZXRJU084NjAxQ2FsZW5kYXIoKTtcbiAgICAgICAgY2FsZW5kYXIgPSBUb1RlbXBvcmFsQ2FsZW5kYXIoY2FsZW5kYXIpO1xuICAgIH1cbiAgICByZXR1cm4gQ3JlYXRlVGVtcG9yYWxEYXRlVGltZSh5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQsIG1pY3Jvc2Vjb25kLCBuYW5vc2Vjb25kLCBjYWxlbmRhcik7XG59XG5mdW5jdGlvbiBUb1RlbXBvcmFsRHVyYXRpb24oaXRlbSkge1xuICAgIGxldCB5ZWFycywgbW9udGhzLCB3ZWVrcywgZGF5cywgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc2Vjb25kcywgbWljcm9zZWNvbmRzLCBuYW5vc2Vjb25kcztcbiAgICBpZiAoSXNPYmplY3QoaXRlbSkpIHtcbiAgICAgICAgaWYgKElzVGVtcG9yYWxEdXJhdGlvbihpdGVtKSlcbiAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICAoeyB5ZWFycywgbW9udGhzLCB3ZWVrcywgZGF5cywgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc2Vjb25kcywgbWljcm9zZWNvbmRzLCBuYW5vc2Vjb25kcyB9ID1cbiAgICAgICAgICAgIFRvVGVtcG9yYWxEdXJhdGlvblJlY29yZChpdGVtKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAoeyB5ZWFycywgbW9udGhzLCB3ZWVrcywgZGF5cywgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc2Vjb25kcywgbWljcm9zZWNvbmRzLCBuYW5vc2Vjb25kcyB9ID1cbiAgICAgICAgICAgIFBhcnNlVGVtcG9yYWxEdXJhdGlvblN0cmluZyhUb1N0cmluZyhpdGVtKSkpO1xuICAgIH1cbiAgICBjb25zdCBUZW1wb3JhbER1cmF0aW9uID0gR2V0SW50cmluc2ljKCclVGVtcG9yYWwuRHVyYXRpb24lJyk7XG4gICAgcmV0dXJuIG5ldyBUZW1wb3JhbER1cmF0aW9uKHllYXJzLCBtb250aHMsIHdlZWtzLCBkYXlzLCBob3VycywgbWludXRlcywgc2Vjb25kcywgbWlsbGlzZWNvbmRzLCBtaWNyb3NlY29uZHMsIG5hbm9zZWNvbmRzKTtcbn1cbmZ1bmN0aW9uIFRvVGVtcG9yYWxJbnN0YW50KGl0ZW0pIHtcbiAgICBpZiAoSXNUZW1wb3JhbEluc3RhbnQoaXRlbSkpXG4gICAgICAgIHJldHVybiBpdGVtO1xuICAgIGlmIChJc1RlbXBvcmFsWm9uZWREYXRlVGltZShpdGVtKSkge1xuICAgICAgICBjb25zdCBUZW1wb3JhbEluc3RhbnQgPSBHZXRJbnRyaW5zaWMoJyVUZW1wb3JhbC5JbnN0YW50JScpO1xuICAgICAgICByZXR1cm4gbmV3IFRlbXBvcmFsSW5zdGFudChHZXRTbG90KGl0ZW0sIEVQT0NITkFOT1NFQ09ORFMpKTtcbiAgICB9XG4gICAgY29uc3QgbnMgPSBQYXJzZVRlbXBvcmFsSW5zdGFudChUb1N0cmluZyhpdGVtKSk7XG4gICAgY29uc3QgVGVtcG9yYWxJbnN0YW50ID0gR2V0SW50cmluc2ljKCclVGVtcG9yYWwuSW5zdGFudCUnKTtcbiAgICByZXR1cm4gbmV3IFRlbXBvcmFsSW5zdGFudChucyk7XG59XG5mdW5jdGlvbiBUb1RlbXBvcmFsTW9udGhEYXkoaXRlbSwgb3B0aW9ucyA9IE9iamVjdENyZWF0ZSQyKG51bGwpKSB7XG4gICAgaWYgKElzT2JqZWN0KGl0ZW0pKSB7XG4gICAgICAgIGlmIChJc1RlbXBvcmFsTW9udGhEYXkoaXRlbSkpXG4gICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgbGV0IGNhbGVuZGFyLCBjYWxlbmRhckFic2VudDtcbiAgICAgICAgaWYgKEhhc1Nsb3QoaXRlbSwgQ0FMRU5EQVIpKSB7XG4gICAgICAgICAgICBjYWxlbmRhciA9IEdldFNsb3QoaXRlbSwgQ0FMRU5EQVIpO1xuICAgICAgICAgICAgY2FsZW5kYXJBYnNlbnQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBtYXliZVN0cmluZ0NhbGVuZGFyID0gaXRlbS5jYWxlbmRhcjtcbiAgICAgICAgICAgIGNhbGVuZGFyQWJzZW50ID0gbWF5YmVTdHJpbmdDYWxlbmRhciA9PT0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKG1heWJlU3RyaW5nQ2FsZW5kYXIgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICBtYXliZVN0cmluZ0NhbGVuZGFyID0gR2V0SVNPODYwMUNhbGVuZGFyKCk7XG4gICAgICAgICAgICBjYWxlbmRhciA9IFRvVGVtcG9yYWxDYWxlbmRhcihtYXliZVN0cmluZ0NhbGVuZGFyKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmaWVsZE5hbWVzID0gQ2FsZW5kYXJGaWVsZHMoY2FsZW5kYXIsIFsnZGF5JywgJ21vbnRoJywgJ21vbnRoQ29kZScsICd5ZWFyJ10pO1xuICAgICAgICBjb25zdCBmaWVsZHMgPSBUb1RlbXBvcmFsTW9udGhEYXlGaWVsZHMoaXRlbSwgZmllbGROYW1lcyk7XG4gICAgICAgIC8vIENhbGxlcnMgd2hvIG9taXQgdGhlIGNhbGVuZGFyIGFyZSBub3Qgd3JpdGluZyBjYWxlbmRhci1pbmRlcGVuZGVudFxuICAgICAgICAvLyBjb2RlLiBJbiB0aGF0IGNhc2UsIGBtb250aENvZGVgL2B5ZWFyYCBjYW4gYmUgb21pdHRlZDsgYG1vbnRoYCBhbmRcbiAgICAgICAgLy8gYGRheWAgYXJlIHN1ZmZpY2llbnQuIEFkZCBhIGB5ZWFyYCB0byBzYXRpc2Z5IGNhbGVuZGFyIHZhbGlkYXRpb24uXG4gICAgICAgIGlmIChjYWxlbmRhckFic2VudCAmJiBmaWVsZHMubW9udGggIT09IHVuZGVmaW5lZCAmJiBmaWVsZHMubW9udGhDb2RlID09PSB1bmRlZmluZWQgJiYgZmllbGRzLnllYXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZmllbGRzLnllYXIgPSAxOTcyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBNb250aERheUZyb21GaWVsZHMoY2FsZW5kYXIsIGZpZWxkcywgb3B0aW9ucyk7XG4gICAgfVxuICAgIFRvVGVtcG9yYWxPdmVyZmxvdyhvcHRpb25zKTsgLy8gdmFsaWRhdGUgYW5kIGlnbm9yZVxuICAgIGxldCB7IG1vbnRoLCBkYXksIHJlZmVyZW5jZUlTT1llYXIsIGNhbGVuZGFyOiBtYXliZVN0cmluZ0NhbGVuZGFyIH0gPSBQYXJzZVRlbXBvcmFsTW9udGhEYXlTdHJpbmcoVG9TdHJpbmcoaXRlbSkpO1xuICAgIGxldCBjYWxlbmRhciA9IG1heWJlU3RyaW5nQ2FsZW5kYXI7XG4gICAgaWYgKGNhbGVuZGFyID09PSB1bmRlZmluZWQpXG4gICAgICAgIGNhbGVuZGFyID0gR2V0SVNPODYwMUNhbGVuZGFyKCk7XG4gICAgY2FsZW5kYXIgPSBUb1RlbXBvcmFsQ2FsZW5kYXIoY2FsZW5kYXIpO1xuICAgIGlmIChyZWZlcmVuY2VJU09ZZWFyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgUmVqZWN0SVNPRGF0ZSgxOTcyLCBtb250aCwgZGF5KTtcbiAgICAgICAgcmV0dXJuIENyZWF0ZVRlbXBvcmFsTW9udGhEYXkobW9udGgsIGRheSwgY2FsZW5kYXIpO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSBDcmVhdGVUZW1wb3JhbE1vbnRoRGF5KG1vbnRoLCBkYXksIGNhbGVuZGFyLCByZWZlcmVuY2VJU09ZZWFyKTtcbiAgICBjb25zdCBjYW5vbmljYWxPcHRpb25zID0gT2JqZWN0Q3JlYXRlJDIobnVsbCk7XG4gICAgcmV0dXJuIE1vbnRoRGF5RnJvbUZpZWxkcyhjYWxlbmRhciwgcmVzdWx0LCBjYW5vbmljYWxPcHRpb25zKTtcbn1cbmZ1bmN0aW9uIFRvVGVtcG9yYWxUaW1lKGl0ZW1QYXJhbSwgb3ZlcmZsb3cgPSAnY29uc3RyYWluJykge1xuICAgIGxldCBpdGVtID0gaXRlbVBhcmFtO1xuICAgIGxldCBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQsIG1pY3Jvc2Vjb25kLCBuYW5vc2Vjb25kLCBjYWxlbmRhcjtcbiAgICBpZiAoSXNPYmplY3QoaXRlbSkpIHtcbiAgICAgICAgaWYgKElzVGVtcG9yYWxUaW1lKGl0ZW0pKVxuICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgIGlmIChJc1RlbXBvcmFsWm9uZWREYXRlVGltZShpdGVtKSkge1xuICAgICAgICAgICAgaXRlbSA9IEJ1aWx0aW5UaW1lWm9uZUdldFBsYWluRGF0ZVRpbWVGb3IoR2V0U2xvdChpdGVtLCBUSU1FX1pPTkUpLCBHZXRTbG90KGl0ZW0sIElOU1RBTlQpLCBHZXRTbG90KGl0ZW0sIENBTEVOREFSKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKElzVGVtcG9yYWxEYXRlVGltZShpdGVtKSkge1xuICAgICAgICAgICAgY29uc3QgVGVtcG9yYWxQbGFpblRpbWUgPSBHZXRJbnRyaW5zaWMoJyVUZW1wb3JhbC5QbGFpblRpbWUlJyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFRlbXBvcmFsUGxhaW5UaW1lKEdldFNsb3QoaXRlbSwgSVNPX0hPVVIpLCBHZXRTbG90KGl0ZW0sIElTT19NSU5VVEUpLCBHZXRTbG90KGl0ZW0sIElTT19TRUNPTkQpLCBHZXRTbG90KGl0ZW0sIElTT19NSUxMSVNFQ09ORCksIEdldFNsb3QoaXRlbSwgSVNPX01JQ1JPU0VDT05EKSwgR2V0U2xvdChpdGVtLCBJU09fTkFOT1NFQ09ORCkpO1xuICAgICAgICB9XG4gICAgICAgIGNhbGVuZGFyID0gR2V0VGVtcG9yYWxDYWxlbmRhcldpdGhJU09EZWZhdWx0KGl0ZW0pO1xuICAgICAgICBpZiAoVG9TdHJpbmcoY2FsZW5kYXIpICE9PSAnaXNvODYwMScpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdQbGFpblRpbWUgY2FuIG9ubHkgaGF2ZSBpc284NjAxIGNhbGVuZGFyJyk7XG4gICAgICAgIH1cbiAgICAgICAgKHsgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kLCBtaWNyb3NlY29uZCwgbmFub3NlY29uZCB9ID0gVG9UZW1wb3JhbFRpbWVSZWNvcmQoaXRlbSkpO1xuICAgICAgICAoeyBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQsIG1pY3Jvc2Vjb25kLCBuYW5vc2Vjb25kIH0gPSBSZWd1bGF0ZVRpbWUoaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kLCBtaWNyb3NlY29uZCwgbmFub3NlY29uZCwgb3ZlcmZsb3cpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgICh7IGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZCwgbWljcm9zZWNvbmQsIG5hbm9zZWNvbmQsIGNhbGVuZGFyIH0gPSBQYXJzZVRlbXBvcmFsVGltZVN0cmluZyhUb1N0cmluZyhpdGVtKSkpO1xuICAgICAgICBSZWplY3RUaW1lKGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZCwgbWljcm9zZWNvbmQsIG5hbm9zZWNvbmQpO1xuICAgICAgICBpZiAoY2FsZW5kYXIgIT09IHVuZGVmaW5lZCAmJiBjYWxlbmRhciAhPT0gJ2lzbzg2MDEnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignUGxhaW5UaW1lIGNhbiBvbmx5IGhhdmUgaXNvODYwMSBjYWxlbmRhcicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IFRlbXBvcmFsUGxhaW5UaW1lID0gR2V0SW50cmluc2ljKCclVGVtcG9yYWwuUGxhaW5UaW1lJScpO1xuICAgIHJldHVybiBuZXcgVGVtcG9yYWxQbGFpblRpbWUoaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kLCBtaWNyb3NlY29uZCwgbmFub3NlY29uZCk7XG59XG5mdW5jdGlvbiBUb1RlbXBvcmFsWWVhck1vbnRoKGl0ZW0sIG9wdGlvbnMgPSBPYmplY3RDcmVhdGUkMihudWxsKSkge1xuICAgIGlmIChJc09iamVjdChpdGVtKSkge1xuICAgICAgICBpZiAoSXNUZW1wb3JhbFllYXJNb250aChpdGVtKSlcbiAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICBjb25zdCBjYWxlbmRhciA9IEdldFRlbXBvcmFsQ2FsZW5kYXJXaXRoSVNPRGVmYXVsdChpdGVtKTtcbiAgICAgICAgY29uc3QgZmllbGROYW1lcyA9IENhbGVuZGFyRmllbGRzKGNhbGVuZGFyLCBbJ21vbnRoJywgJ21vbnRoQ29kZScsICd5ZWFyJ10pO1xuICAgICAgICBjb25zdCBmaWVsZHMgPSBUb1RlbXBvcmFsWWVhck1vbnRoRmllbGRzKGl0ZW0sIGZpZWxkTmFtZXMpO1xuICAgICAgICByZXR1cm4gWWVhck1vbnRoRnJvbUZpZWxkcyhjYWxlbmRhciwgZmllbGRzLCBvcHRpb25zKTtcbiAgICB9XG4gICAgVG9UZW1wb3JhbE92ZXJmbG93KG9wdGlvbnMpOyAvLyB2YWxpZGF0ZSBhbmQgaWdub3JlXG4gICAgbGV0IHsgeWVhciwgbW9udGgsIHJlZmVyZW5jZUlTT0RheSwgY2FsZW5kYXI6IG1heWJlU3RyaW5nQ2FsZW5kYXIgfSA9IFBhcnNlVGVtcG9yYWxZZWFyTW9udGhTdHJpbmcoVG9TdHJpbmcoaXRlbSkpO1xuICAgIC8vIFRPRE86IHJlcGxhY2Ugd2l0aCB0ZXJuYXJ5P1xuICAgIGxldCBjYWxlbmRhciA9IG1heWJlU3RyaW5nQ2FsZW5kYXI7XG4gICAgaWYgKGNhbGVuZGFyID09PSB1bmRlZmluZWQpXG4gICAgICAgIGNhbGVuZGFyID0gR2V0SVNPODYwMUNhbGVuZGFyKCk7XG4gICAgY2FsZW5kYXIgPSBUb1RlbXBvcmFsQ2FsZW5kYXIoY2FsZW5kYXIpO1xuICAgIGlmIChyZWZlcmVuY2VJU09EYXkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBSZWplY3RJU09EYXRlKHllYXIsIG1vbnRoLCAxKTtcbiAgICAgICAgcmV0dXJuIENyZWF0ZVRlbXBvcmFsWWVhck1vbnRoKHllYXIsIG1vbnRoLCBjYWxlbmRhcik7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IENyZWF0ZVRlbXBvcmFsWWVhck1vbnRoKHllYXIsIG1vbnRoLCBjYWxlbmRhciwgcmVmZXJlbmNlSVNPRGF5KTtcbiAgICBjb25zdCBjYW5vbmljYWxPcHRpb25zID0gT2JqZWN0Q3JlYXRlJDIobnVsbCk7XG4gICAgcmV0dXJuIFllYXJNb250aEZyb21GaWVsZHMoY2FsZW5kYXIsIHJlc3VsdCwgY2Fub25pY2FsT3B0aW9ucyk7XG59XG5mdW5jdGlvbiBJbnRlcnByZXRJU09EYXRlVGltZU9mZnNldCh5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQsIG1pY3Jvc2Vjb25kLCBuYW5vc2Vjb25kLCBvZmZzZXRCZWhhdmlvdXIsIG9mZnNldE5zLCB0aW1lWm9uZSwgZGlzYW1iaWd1YXRpb24sIG9mZnNldE9wdCwgbWF0Y2hNaW51dGUpIHtcbiAgICBjb25zdCBEYXRlVGltZSA9IEdldEludHJpbnNpYygnJVRlbXBvcmFsLlBsYWluRGF0ZVRpbWUlJyk7XG4gICAgY29uc3QgZHQgPSBuZXcgRGF0ZVRpbWUoeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kLCBtaWNyb3NlY29uZCwgbmFub3NlY29uZCk7XG4gICAgaWYgKG9mZnNldEJlaGF2aW91ciA9PT0gJ3dhbGwnIHx8IG9mZnNldE9wdCA9PT0gJ2lnbm9yZScpIHtcbiAgICAgICAgLy8gU2ltcGxlIGNhc2U6IElTTyBzdHJpbmcgd2l0aG91dCBhIFRaIG9mZnNldCAob3IgY2FsbGVyIHdhbnRzIHRvIGlnbm9yZVxuICAgICAgICAvLyB0aGUgb2Zmc2V0KSwgc28ganVzdCBjb252ZXJ0IERhdGVUaW1lIHRvIEluc3RhbnQgaW4gdGhlIGdpdmVuIHRpbWUgem9uZVxuICAgICAgICBjb25zdCBpbnN0YW50ID0gQnVpbHRpblRpbWVab25lR2V0SW5zdGFudEZvcih0aW1lWm9uZSwgZHQsIGRpc2FtYmlndWF0aW9uKTtcbiAgICAgICAgcmV0dXJuIEdldFNsb3QoaW5zdGFudCwgRVBPQ0hOQU5PU0VDT05EUyk7XG4gICAgfVxuICAgIC8vIFRoZSBjYWxsZXIgd2FudHMgdGhlIG9mZnNldCB0byBhbHdheXMgd2luICgndXNlJykgT1IgdGhlIGNhbGxlciBpcyBPS1xuICAgIC8vIHdpdGggdGhlIG9mZnNldCB3aW5uaW5nICgncHJlZmVyJyBvciAncmVqZWN0JykgYXMgbG9uZyBhcyBpdCdzIHZhbGlkXG4gICAgLy8gZm9yIHRoaXMgdGltZXpvbmUgYW5kIGRhdGUvdGltZS5cbiAgICBpZiAob2Zmc2V0QmVoYXZpb3VyID09PSAnZXhhY3QnIHx8IG9mZnNldE9wdCA9PT0gJ3VzZScpIHtcbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBpbnN0YW50IGZvciB0aGUgaW5wdXQncyBkYXRlL3RpbWUgYW5kIG9mZnNldFxuICAgICAgICBjb25zdCBlcG9jaE5zID0gR2V0RXBvY2hGcm9tSVNPUGFydHMoeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kLCBtaWNyb3NlY29uZCwgbmFub3NlY29uZCk7XG4gICAgICAgIGlmIChlcG9jaE5zID09PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1pvbmVkRGF0ZVRpbWUgb3V0c2lkZSBvZiBzdXBwb3J0ZWQgcmFuZ2UnKTtcbiAgICAgICAgcmV0dXJuIEpTQkkuc3VidHJhY3QoZXBvY2hOcywgSlNCSS5CaWdJbnQob2Zmc2V0TnMpKTtcbiAgICB9XG4gICAgLy8gXCJwcmVmZXJcIiBvciBcInJlamVjdFwiXG4gICAgY29uc3QgcG9zc2libGVJbnN0YW50cyA9IEdldFBvc3NpYmxlSW5zdGFudHNGb3IodGltZVpvbmUsIGR0KTtcbiAgICBmb3IgKGNvbnN0IGNhbmRpZGF0ZSBvZiBwb3NzaWJsZUluc3RhbnRzKSB7XG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZU9mZnNldCA9IEdldE9mZnNldE5hbm9zZWNvbmRzRm9yKHRpbWVab25lLCBjYW5kaWRhdGUpO1xuICAgICAgICBjb25zdCByb3VuZGVkQ2FuZGlkYXRlT2Zmc2V0ID0gSlNCSS50b051bWJlcihSb3VuZE51bWJlclRvSW5jcmVtZW50KEpTQkkuQmlnSW50KGNhbmRpZGF0ZU9mZnNldCksIDYwZTksICdoYWxmRXhwYW5kJykpO1xuICAgICAgICBpZiAoY2FuZGlkYXRlT2Zmc2V0ID09PSBvZmZzZXROcyB8fCAobWF0Y2hNaW51dGUgJiYgcm91bmRlZENhbmRpZGF0ZU9mZnNldCA9PT0gb2Zmc2V0TnMpKSB7XG4gICAgICAgICAgICByZXR1cm4gR2V0U2xvdChjYW5kaWRhdGUsIEVQT0NITkFOT1NFQ09ORFMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIHRoZSB1c2VyLXByb3ZpZGVkIG9mZnNldCBkb2Vzbid0IG1hdGNoIGFueSBpbnN0YW50cyBmb3IgdGhpcyB0aW1lXG4gICAgLy8gem9uZSBhbmQgZGF0ZS90aW1lLlxuICAgIGlmIChvZmZzZXRPcHQgPT09ICdyZWplY3QnKSB7XG4gICAgICAgIGNvbnN0IG9mZnNldFN0ciA9IEZvcm1hdFRpbWVab25lT2Zmc2V0U3RyaW5nKG9mZnNldE5zKTtcbiAgICAgICAgY29uc3QgdGltZVpvbmVTdHJpbmcgPSBJc1RlbXBvcmFsVGltZVpvbmUodGltZVpvbmUpID8gR2V0U2xvdCh0aW1lWm9uZSwgVElNRVpPTkVfSUQpIDogJ3RpbWUgem9uZSc7XG4gICAgICAgIC8vIFRoZSB0c2MgZW1pdCBmb3IgdGhpcyBsaW5lIHJld3JpdGVzIHRvIGludm9rZSB0aGUgUGxhaW5EYXRlVGltZSdzIHZhbHVlT2YgbWV0aG9kLCBOT1RcbiAgICAgICAgLy8gdG9TdHJpbmcgKHdoaWNoIGlzIGludm9rZWQgYnkgTm9kZSB3aGVuIHVzaW5nIHRlbXBsYXRlIGxpdGVyYWxzIGRpcmVjdGx5KS5cbiAgICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9taWNyb3NvZnQvVHlwZVNjcmlwdC9pc3N1ZXMvMzk3NDQgZm9yIHRoZSBwcm9wb3NlZCBmaXggaW4gdHNjIGVtaXRcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYE9mZnNldCAke29mZnNldFN0cn0gaXMgaW52YWxpZCBmb3IgJHtkdC50b1N0cmluZygpfSBpbiAke3RpbWVab25lU3RyaW5nfWApO1xuICAgIH1cbiAgICAvLyBmYWxsIHRocm91Z2g6IG9mZnNldE9wdCA9PT0gJ3ByZWZlcicsIGJ1dCB0aGUgb2Zmc2V0IGRvZXNuJ3QgbWF0Y2hcbiAgICAvLyBzbyBmYWxsIGJhY2sgdG8gdXNlIHRoZSB0aW1lIHpvbmUgaW5zdGVhZC5cbiAgICBjb25zdCBpbnN0YW50ID0gRGlzYW1iaWd1YXRlUG9zc2libGVJbnN0YW50cyhwb3NzaWJsZUluc3RhbnRzLCB0aW1lWm9uZSwgZHQsIGRpc2FtYmlndWF0aW9uKTtcbiAgICByZXR1cm4gR2V0U2xvdChpbnN0YW50LCBFUE9DSE5BTk9TRUNPTkRTKTtcbn1cbmZ1bmN0aW9uIFRvVGVtcG9yYWxab25lZERhdGVUaW1lKGl0ZW0sIG9wdGlvbnMgPSBPYmplY3RDcmVhdGUkMihudWxsKSkge1xuICAgIGxldCB5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQsIG1pY3Jvc2Vjb25kLCBuYW5vc2Vjb25kLCB0aW1lWm9uZSwgb2Zmc2V0LCBjYWxlbmRhcjtcbiAgICBsZXQgbWF0Y2hNaW51dGUgPSBmYWxzZTtcbiAgICBsZXQgb2Zmc2V0QmVoYXZpb3VyID0gJ29wdGlvbic7XG4gICAgaWYgKElzT2JqZWN0KGl0ZW0pKSB7XG4gICAgICAgIGlmIChJc1RlbXBvcmFsWm9uZWREYXRlVGltZShpdGVtKSlcbiAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICBjYWxlbmRhciA9IEdldFRlbXBvcmFsQ2FsZW5kYXJXaXRoSVNPRGVmYXVsdChpdGVtKTtcbiAgICAgICAgY29uc3QgZmllbGROYW1lcyA9IENhbGVuZGFyRmllbGRzKGNhbGVuZGFyLCBbXG4gICAgICAgICAgICAnZGF5JyxcbiAgICAgICAgICAgICdob3VyJyxcbiAgICAgICAgICAgICdtaWNyb3NlY29uZCcsXG4gICAgICAgICAgICAnbWlsbGlzZWNvbmQnLFxuICAgICAgICAgICAgJ21pbnV0ZScsXG4gICAgICAgICAgICAnbW9udGgnLFxuICAgICAgICAgICAgJ21vbnRoQ29kZScsXG4gICAgICAgICAgICAnbmFub3NlY29uZCcsXG4gICAgICAgICAgICAnc2Vjb25kJyxcbiAgICAgICAgICAgICd5ZWFyJ1xuICAgICAgICBdKTtcbiAgICAgICAgY29uc3QgZmllbGRzID0gVG9UZW1wb3JhbFpvbmVkRGF0ZVRpbWVGaWVsZHMoaXRlbSwgZmllbGROYW1lcyk7XG4gICAgICAgICh7IHllYXIsIG1vbnRoLCBkYXksIGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZCwgbWljcm9zZWNvbmQsIG5hbm9zZWNvbmQgfSA9IEludGVycHJldFRlbXBvcmFsRGF0ZVRpbWVGaWVsZHMoY2FsZW5kYXIsIGZpZWxkcywgb3B0aW9ucykpO1xuICAgICAgICB0aW1lWm9uZSA9IFRvVGVtcG9yYWxUaW1lWm9uZShmaWVsZHMudGltZVpvbmUpO1xuICAgICAgICBvZmZzZXQgPSBmaWVsZHMub2Zmc2V0O1xuICAgICAgICBpZiAob2Zmc2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG9mZnNldEJlaGF2aW91ciA9ICd3YWxsJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9mZnNldCA9IFRvU3RyaW5nKG9mZnNldCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIFRvVGVtcG9yYWxPdmVyZmxvdyhvcHRpb25zKTsgLy8gdmFsaWRhdGUgYW5kIGlnbm9yZVxuICAgICAgICBsZXQgaWFuYU5hbWUsIHo7XG4gICAgICAgICh7IHllYXIsIG1vbnRoLCBkYXksIGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZCwgbWljcm9zZWNvbmQsIG5hbm9zZWNvbmQsIGlhbmFOYW1lLCBvZmZzZXQsIHosIGNhbGVuZGFyIH0gPVxuICAgICAgICAgICAgUGFyc2VUZW1wb3JhbFpvbmVkRGF0ZVRpbWVTdHJpbmcoVG9TdHJpbmcoaXRlbSkpKTtcbiAgICAgICAgaWYgKCFpYW5hTmFtZSlcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCd0aW1lIHpvbmUgSUQgcmVxdWlyZWQgaW4gYnJhY2tldHMnKTtcbiAgICAgICAgaWYgKHopIHtcbiAgICAgICAgICAgIG9mZnNldEJlaGF2aW91ciA9ICdleGFjdCc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIW9mZnNldCkge1xuICAgICAgICAgICAgb2Zmc2V0QmVoYXZpb3VyID0gJ3dhbGwnO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IFRlbXBvcmFsVGltZVpvbmUgPSBHZXRJbnRyaW5zaWMoJyVUZW1wb3JhbC5UaW1lWm9uZSUnKTtcbiAgICAgICAgdGltZVpvbmUgPSBuZXcgVGVtcG9yYWxUaW1lWm9uZShpYW5hTmFtZSk7XG4gICAgICAgIGlmICghY2FsZW5kYXIpXG4gICAgICAgICAgICBjYWxlbmRhciA9IEdldElTTzg2MDFDYWxlbmRhcigpO1xuICAgICAgICBjYWxlbmRhciA9IFRvVGVtcG9yYWxDYWxlbmRhcihjYWxlbmRhcik7XG4gICAgICAgIG1hdGNoTWludXRlID0gdHJ1ZTsgLy8gSVNPIHN0cmluZ3MgbWF5IHNwZWNpZnkgb2Zmc2V0IHdpdGggbGVzcyBwcmVjaXNpb25cbiAgICB9XG4gICAgbGV0IG9mZnNldE5zID0gMDtcbiAgICAvLyBUaGUgY29kZSBhYm92ZSBndWFyYW50ZWVzIHRoYXQgaWYgb2Zmc2V0QmVoYXZpb3VyID09PSAnb3B0aW9uJywgdGhlblxuICAgIC8vIGBvZmZzZXRgIGlzIG5vdCB1bmRlZmluZWQuXG4gICAgaWYgKG9mZnNldEJlaGF2aW91ciA9PT0gJ29wdGlvbicpXG4gICAgICAgIG9mZnNldE5zID0gUGFyc2VUaW1lWm9uZU9mZnNldFN0cmluZyhvZmZzZXQpO1xuICAgIGNvbnN0IGRpc2FtYmlndWF0aW9uID0gVG9UZW1wb3JhbERpc2FtYmlndWF0aW9uKG9wdGlvbnMpO1xuICAgIGNvbnN0IG9mZnNldE9wdCA9IFRvVGVtcG9yYWxPZmZzZXQob3B0aW9ucywgJ3JlamVjdCcpO1xuICAgIGNvbnN0IGVwb2NoTmFub3NlY29uZHMgPSBJbnRlcnByZXRJU09EYXRlVGltZU9mZnNldCh5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQsIG1pY3Jvc2Vjb25kLCBuYW5vc2Vjb25kLCBvZmZzZXRCZWhhdmlvdXIsIG9mZnNldE5zLCB0aW1lWm9uZSwgZGlzYW1iaWd1YXRpb24sIG9mZnNldE9wdCwgbWF0Y2hNaW51dGUpO1xuICAgIHJldHVybiBDcmVhdGVUZW1wb3JhbFpvbmVkRGF0ZVRpbWUoZXBvY2hOYW5vc2Vjb25kcywgdGltZVpvbmUsIGNhbGVuZGFyKTtcbn1cbmZ1bmN0aW9uIENyZWF0ZVRlbXBvcmFsRGF0ZVNsb3RzKHJlc3VsdCwgaXNvWWVhciwgaXNvTW9udGgsIGlzb0RheSwgY2FsZW5kYXIpIHtcbiAgICBSZWplY3RJU09EYXRlKGlzb1llYXIsIGlzb01vbnRoLCBpc29EYXkpO1xuICAgIFJlamVjdERhdGVSYW5nZShpc29ZZWFyLCBpc29Nb250aCwgaXNvRGF5KTtcbiAgICBDcmVhdGVTbG90cyhyZXN1bHQpO1xuICAgIFNldFNsb3QocmVzdWx0LCBJU09fWUVBUiwgaXNvWWVhcik7XG4gICAgU2V0U2xvdChyZXN1bHQsIElTT19NT05USCwgaXNvTW9udGgpO1xuICAgIFNldFNsb3QocmVzdWx0LCBJU09fREFZLCBpc29EYXkpO1xuICAgIFNldFNsb3QocmVzdWx0LCBDQUxFTkRBUiwgY2FsZW5kYXIpO1xuICAgIFNldFNsb3QocmVzdWx0LCBEQVRFX0JSQU5ELCB0cnVlKTtcbiAgICB7XG4gICAgICAgIE9iamVjdERlZmluZVByb3BlcnR5KHJlc3VsdCwgJ19yZXByXycsIHtcbiAgICAgICAgICAgIHZhbHVlOiBgJHtyZXN1bHRbU3ltYm9sLnRvU3RyaW5nVGFnXX0gPCR7VGVtcG9yYWxEYXRlVG9TdHJpbmcocmVzdWx0KX0+YCxcbiAgICAgICAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICB9XG59XG5mdW5jdGlvbiBDcmVhdGVUZW1wb3JhbERhdGUoaXNvWWVhciwgaXNvTW9udGgsIGlzb0RheSwgY2FsZW5kYXIgPSBHZXRJU084NjAxQ2FsZW5kYXIoKSkge1xuICAgIGNvbnN0IFRlbXBvcmFsUGxhaW5EYXRlID0gR2V0SW50cmluc2ljKCclVGVtcG9yYWwuUGxhaW5EYXRlJScpO1xuICAgIGNvbnN0IHJlc3VsdCA9IE9iamVjdENyZWF0ZSQyKFRlbXBvcmFsUGxhaW5EYXRlLnByb3RvdHlwZSk7XG4gICAgQ3JlYXRlVGVtcG9yYWxEYXRlU2xvdHMocmVzdWx0LCBpc29ZZWFyLCBpc29Nb250aCwgaXNvRGF5LCBjYWxlbmRhcik7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIENyZWF0ZVRlbXBvcmFsRGF0ZVRpbWVTbG90cyhyZXN1bHQsIGlzb1llYXIsIGlzb01vbnRoLCBpc29EYXksIGgsIG1pbiwgcywgbXMsIMK1cywgbnMsIGNhbGVuZGFyKSB7XG4gICAgUmVqZWN0RGF0ZVRpbWUoaXNvWWVhciwgaXNvTW9udGgsIGlzb0RheSwgaCwgbWluLCBzLCBtcywgwrVzLCBucyk7XG4gICAgUmVqZWN0RGF0ZVRpbWVSYW5nZShpc29ZZWFyLCBpc29Nb250aCwgaXNvRGF5LCBoLCBtaW4sIHMsIG1zLCDCtXMsIG5zKTtcbiAgICBDcmVhdGVTbG90cyhyZXN1bHQpO1xuICAgIFNldFNsb3QocmVzdWx0LCBJU09fWUVBUiwgaXNvWWVhcik7XG4gICAgU2V0U2xvdChyZXN1bHQsIElTT19NT05USCwgaXNvTW9udGgpO1xuICAgIFNldFNsb3QocmVzdWx0LCBJU09fREFZLCBpc29EYXkpO1xuICAgIFNldFNsb3QocmVzdWx0LCBJU09fSE9VUiwgaCk7XG4gICAgU2V0U2xvdChyZXN1bHQsIElTT19NSU5VVEUsIG1pbik7XG4gICAgU2V0U2xvdChyZXN1bHQsIElTT19TRUNPTkQsIHMpO1xuICAgIFNldFNsb3QocmVzdWx0LCBJU09fTUlMTElTRUNPTkQsIG1zKTtcbiAgICBTZXRTbG90KHJlc3VsdCwgSVNPX01JQ1JPU0VDT05ELCDCtXMpO1xuICAgIFNldFNsb3QocmVzdWx0LCBJU09fTkFOT1NFQ09ORCwgbnMpO1xuICAgIFNldFNsb3QocmVzdWx0LCBDQUxFTkRBUiwgY2FsZW5kYXIpO1xuICAgIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlc3VsdCwgJ19yZXByXycsIHtcbiAgICAgICAgICAgIHZhbHVlOiBgJHtyZXN1bHRbU3ltYm9sLnRvU3RyaW5nVGFnXX0gPCR7VGVtcG9yYWxEYXRlVGltZVRvU3RyaW5nKHJlc3VsdCwgJ2F1dG8nKX0+YCxcbiAgICAgICAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICB9XG59XG5mdW5jdGlvbiBDcmVhdGVUZW1wb3JhbERhdGVUaW1lKGlzb1llYXIsIGlzb01vbnRoLCBpc29EYXksIGgsIG1pbiwgcywgbXMsIMK1cywgbnMsIGNhbGVuZGFyID0gR2V0SVNPODYwMUNhbGVuZGFyKCkpIHtcbiAgICBjb25zdCBUZW1wb3JhbFBsYWluRGF0ZVRpbWUgPSBHZXRJbnRyaW5zaWMoJyVUZW1wb3JhbC5QbGFpbkRhdGVUaW1lJScpO1xuICAgIGNvbnN0IHJlc3VsdCA9IE9iamVjdENyZWF0ZSQyKFRlbXBvcmFsUGxhaW5EYXRlVGltZS5wcm90b3R5cGUpO1xuICAgIENyZWF0ZVRlbXBvcmFsRGF0ZVRpbWVTbG90cyhyZXN1bHQsIGlzb1llYXIsIGlzb01vbnRoLCBpc29EYXksIGgsIG1pbiwgcywgbXMsIMK1cywgbnMsIGNhbGVuZGFyKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gQ3JlYXRlVGVtcG9yYWxNb250aERheVNsb3RzKHJlc3VsdCwgaXNvTW9udGgsIGlzb0RheSwgY2FsZW5kYXIsIHJlZmVyZW5jZUlTT1llYXIpIHtcbiAgICBSZWplY3RJU09EYXRlKHJlZmVyZW5jZUlTT1llYXIsIGlzb01vbnRoLCBpc29EYXkpO1xuICAgIFJlamVjdERhdGVSYW5nZShyZWZlcmVuY2VJU09ZZWFyLCBpc29Nb250aCwgaXNvRGF5KTtcbiAgICBDcmVhdGVTbG90cyhyZXN1bHQpO1xuICAgIFNldFNsb3QocmVzdWx0LCBJU09fTU9OVEgsIGlzb01vbnRoKTtcbiAgICBTZXRTbG90KHJlc3VsdCwgSVNPX0RBWSwgaXNvRGF5KTtcbiAgICBTZXRTbG90KHJlc3VsdCwgSVNPX1lFQVIsIHJlZmVyZW5jZUlTT1llYXIpO1xuICAgIFNldFNsb3QocmVzdWx0LCBDQUxFTkRBUiwgY2FsZW5kYXIpO1xuICAgIFNldFNsb3QocmVzdWx0LCBNT05USF9EQVlfQlJBTkQsIHRydWUpO1xuICAgIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlc3VsdCwgJ19yZXByXycsIHtcbiAgICAgICAgICAgIHZhbHVlOiBgJHtyZXN1bHRbU3ltYm9sLnRvU3RyaW5nVGFnXX0gPCR7VGVtcG9yYWxNb250aERheVRvU3RyaW5nKHJlc3VsdCl9PmAsXG4gICAgICAgICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZnVuY3Rpb24gQ3JlYXRlVGVtcG9yYWxNb250aERheShpc29Nb250aCwgaXNvRGF5LCBjYWxlbmRhciA9IEdldElTTzg2MDFDYWxlbmRhcigpLCByZWZlcmVuY2VJU09ZZWFyID0gMTk3Mikge1xuICAgIGNvbnN0IFRlbXBvcmFsUGxhaW5Nb250aERheSA9IEdldEludHJpbnNpYygnJVRlbXBvcmFsLlBsYWluTW9udGhEYXklJyk7XG4gICAgY29uc3QgcmVzdWx0ID0gT2JqZWN0Q3JlYXRlJDIoVGVtcG9yYWxQbGFpbk1vbnRoRGF5LnByb3RvdHlwZSk7XG4gICAgQ3JlYXRlVGVtcG9yYWxNb250aERheVNsb3RzKHJlc3VsdCwgaXNvTW9udGgsIGlzb0RheSwgY2FsZW5kYXIsIHJlZmVyZW5jZUlTT1llYXIpO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBDcmVhdGVUZW1wb3JhbFllYXJNb250aFNsb3RzKHJlc3VsdCwgaXNvWWVhciwgaXNvTW9udGgsIGNhbGVuZGFyLCByZWZlcmVuY2VJU09EYXkpIHtcbiAgICBSZWplY3RJU09EYXRlKGlzb1llYXIsIGlzb01vbnRoLCByZWZlcmVuY2VJU09EYXkpO1xuICAgIFJlamVjdFllYXJNb250aFJhbmdlKGlzb1llYXIsIGlzb01vbnRoKTtcbiAgICBDcmVhdGVTbG90cyhyZXN1bHQpO1xuICAgIFNldFNsb3QocmVzdWx0LCBJU09fWUVBUiwgaXNvWWVhcik7XG4gICAgU2V0U2xvdChyZXN1bHQsIElTT19NT05USCwgaXNvTW9udGgpO1xuICAgIFNldFNsb3QocmVzdWx0LCBJU09fREFZLCByZWZlcmVuY2VJU09EYXkpO1xuICAgIFNldFNsb3QocmVzdWx0LCBDQUxFTkRBUiwgY2FsZW5kYXIpO1xuICAgIFNldFNsb3QocmVzdWx0LCBZRUFSX01PTlRIX0JSQU5ELCB0cnVlKTtcbiAgICB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZXN1bHQsICdfcmVwcl8nLCB7XG4gICAgICAgICAgICB2YWx1ZTogYCR7cmVzdWx0W1N5bWJvbC50b1N0cmluZ1RhZ119IDwke1RlbXBvcmFsWWVhck1vbnRoVG9TdHJpbmcocmVzdWx0KX0+YCxcbiAgICAgICAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICB9XG59XG5mdW5jdGlvbiBDcmVhdGVUZW1wb3JhbFllYXJNb250aChpc29ZZWFyLCBpc29Nb250aCwgY2FsZW5kYXIgPSBHZXRJU084NjAxQ2FsZW5kYXIoKSwgcmVmZXJlbmNlSVNPRGF5ID0gMSkge1xuICAgIGNvbnN0IFRlbXBvcmFsUGxhaW5ZZWFyTW9udGggPSBHZXRJbnRyaW5zaWMoJyVUZW1wb3JhbC5QbGFpblllYXJNb250aCUnKTtcbiAgICBjb25zdCByZXN1bHQgPSBPYmplY3RDcmVhdGUkMihUZW1wb3JhbFBsYWluWWVhck1vbnRoLnByb3RvdHlwZSk7XG4gICAgQ3JlYXRlVGVtcG9yYWxZZWFyTW9udGhTbG90cyhyZXN1bHQsIGlzb1llYXIsIGlzb01vbnRoLCBjYWxlbmRhciwgcmVmZXJlbmNlSVNPRGF5KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gQ3JlYXRlVGVtcG9yYWxab25lZERhdGVUaW1lU2xvdHMocmVzdWx0LCBlcG9jaE5hbm9zZWNvbmRzLCB0aW1lWm9uZSwgY2FsZW5kYXIpIHtcbiAgICBWYWxpZGF0ZUVwb2NoTmFub3NlY29uZHMoZXBvY2hOYW5vc2Vjb25kcyk7XG4gICAgQ3JlYXRlU2xvdHMocmVzdWx0KTtcbiAgICBTZXRTbG90KHJlc3VsdCwgRVBPQ0hOQU5PU0VDT05EUywgZXBvY2hOYW5vc2Vjb25kcyk7XG4gICAgU2V0U2xvdChyZXN1bHQsIFRJTUVfWk9ORSwgdGltZVpvbmUpO1xuICAgIFNldFNsb3QocmVzdWx0LCBDQUxFTkRBUiwgY2FsZW5kYXIpO1xuICAgIGNvbnN0IFRlbXBvcmFsSW5zdGFudCA9IEdldEludHJpbnNpYygnJVRlbXBvcmFsLkluc3RhbnQlJyk7XG4gICAgY29uc3QgaW5zdGFudCA9IG5ldyBUZW1wb3JhbEluc3RhbnQoR2V0U2xvdChyZXN1bHQsIEVQT0NITkFOT1NFQ09ORFMpKTtcbiAgICBTZXRTbG90KHJlc3VsdCwgSU5TVEFOVCwgaW5zdGFudCk7XG4gICAge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVzdWx0LCAnX3JlcHJfJywge1xuICAgICAgICAgICAgdmFsdWU6IGAke3Jlc3VsdFtTeW1ib2wudG9TdHJpbmdUYWddfSA8JHtUZW1wb3JhbFpvbmVkRGF0ZVRpbWVUb1N0cmluZyhyZXN1bHQsICdhdXRvJyl9PmAsXG4gICAgICAgICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZnVuY3Rpb24gQ3JlYXRlVGVtcG9yYWxab25lZERhdGVUaW1lKGVwb2NoTmFub3NlY29uZHMsIHRpbWVab25lLCBjYWxlbmRhciA9IEdldElTTzg2MDFDYWxlbmRhcigpKSB7XG4gICAgY29uc3QgVGVtcG9yYWxab25lZERhdGVUaW1lID0gR2V0SW50cmluc2ljKCclVGVtcG9yYWwuWm9uZWREYXRlVGltZSUnKTtcbiAgICBjb25zdCByZXN1bHQgPSBPYmplY3RDcmVhdGUkMihUZW1wb3JhbFpvbmVkRGF0ZVRpbWUucHJvdG90eXBlKTtcbiAgICBDcmVhdGVUZW1wb3JhbFpvbmVkRGF0ZVRpbWVTbG90cyhyZXN1bHQsIGVwb2NoTmFub3NlY29uZHMsIHRpbWVab25lLCBjYWxlbmRhcik7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIEdldElTTzg2MDFDYWxlbmRhcigpIHtcbiAgICBjb25zdCBUZW1wb3JhbENhbGVuZGFyID0gR2V0SW50cmluc2ljKCclVGVtcG9yYWwuQ2FsZW5kYXIlJyk7XG4gICAgcmV0dXJuIG5ldyBUZW1wb3JhbENhbGVuZGFyKCdpc284NjAxJyk7XG59XG4vLyBUT0RPOiBzaG91bGQgKGNhbj8pIHdlIG1ha2UgdGhpcyBnZW5lcmljIHNvIHRoZSBmaWVsZCBuYW1lcyBhcmUgY2hlY2tlZFxuLy8gYWdhaW5zdCB0aGUgdHlwZSB0aGF0IHRoZSBjYWxlbmRhciBpcyBhIHByb3BlcnR5IG9mP1xuZnVuY3Rpb24gQ2FsZW5kYXJGaWVsZHMoY2FsZW5kYXIsIGZpZWxkTmFtZXNQYXJhbSkge1xuICAgIGxldCBmaWVsZE5hbWVzID0gZmllbGROYW1lc1BhcmFtO1xuICAgIGlmIChjYWxlbmRhci5maWVsZHMpIHtcbiAgICAgICAgZmllbGROYW1lcyA9IGNhbGVuZGFyLmZpZWxkcyhmaWVsZE5hbWVzKTtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgZm9yIChjb25zdCBuYW1lIG9mIGZpZWxkTmFtZXMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lICE9PSAnc3RyaW5nJylcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2JhZCByZXR1cm4gZnJvbSBjYWxlbmRhci5maWVsZHMoKScpO1xuICAgICAgICBBcnJheVByb3RvdHlwZVB1c2gkMS5jYWxsKHJlc3VsdCwgbmFtZSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBDYWxlbmRhck1lcmdlRmllbGRzKGNhbGVuZGFyLCBmaWVsZHMsIGFkZGl0aW9uYWxGaWVsZHMpIHtcbiAgICBjb25zdCBjYWxNZXJnZUZpZWxkcyA9IGNhbGVuZGFyLm1lcmdlRmllbGRzO1xuICAgIGlmICghY2FsTWVyZ2VGaWVsZHMpIHtcbiAgICAgICAgcmV0dXJuIHsgLi4uZmllbGRzLCAuLi5hZGRpdGlvbmFsRmllbGRzIH07XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IFJlZmxlY3QuYXBwbHkoY2FsTWVyZ2VGaWVsZHMsIGNhbGVuZGFyLCBbZmllbGRzLCBhZGRpdGlvbmFsRmllbGRzXSk7XG4gICAgaWYgKCFJc09iamVjdChyZXN1bHQpKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdiYWQgcmV0dXJuIGZyb20gY2FsZW5kYXIubWVyZ2VGaWVsZHMoKScpO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBDYWxlbmRhckRhdGVBZGQoY2FsZW5kYXIsIGRhdGUsIGR1cmF0aW9uLCBvcHRpb25zLCBkYXRlQWRkUGFyYW0pIHtcbiAgICBsZXQgZGF0ZUFkZCA9IGRhdGVBZGRQYXJhbTtcbiAgICBpZiAoZGF0ZUFkZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGRhdGVBZGQgPSBjYWxlbmRhci5kYXRlQWRkO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSBSZWZsZWN0QXBwbHkkMShkYXRlQWRkLCBjYWxlbmRhciwgW2RhdGUsIGR1cmF0aW9uLCBvcHRpb25zXSk7XG4gICAgaWYgKCFJc1RlbXBvcmFsRGF0ZShyZXN1bHQpKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlc3VsdCcpO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBDYWxlbmRhckRhdGVVbnRpbChjYWxlbmRhciwgZGF0ZSwgb3RoZXJEYXRlLCBvcHRpb25zLCBkYXRlVW50aWxQYXJhbSkge1xuICAgIGxldCBkYXRlVW50aWwgPSBkYXRlVW50aWxQYXJhbTtcbiAgICBpZiAoZGF0ZVVudGlsID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZGF0ZVVudGlsID0gY2FsZW5kYXIuZGF0ZVVudGlsO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSBSZWZsZWN0QXBwbHkkMShkYXRlVW50aWwsIGNhbGVuZGFyLCBbZGF0ZSwgb3RoZXJEYXRlLCBvcHRpb25zXSk7XG4gICAgaWYgKCFJc1RlbXBvcmFsRHVyYXRpb24ocmVzdWx0KSlcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZXN1bHQnKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gQ2FsZW5kYXJZZWFyKGNhbGVuZGFyLCBkYXRlTGlrZSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IGNhbGVuZGFyLnllYXIoZGF0ZUxpa2UpO1xuICAgIGlmIChyZXN1bHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignY2FsZW5kYXIgeWVhciByZXN1bHQgbXVzdCBiZSBhbiBpbnRlZ2VyJyk7XG4gICAgfVxuICAgIHJldHVybiBUb0ludGVnZXJUaHJvd09uSW5maW5pdHkocmVzdWx0KTtcbn1cbmZ1bmN0aW9uIENhbGVuZGFyTW9udGgoY2FsZW5kYXIsIGRhdGVMaWtlKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gY2FsZW5kYXIubW9udGgoZGF0ZUxpa2UpO1xuICAgIGlmIChyZXN1bHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignY2FsZW5kYXIgbW9udGggcmVzdWx0IG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyJyk7XG4gICAgfVxuICAgIHJldHVybiBUb1Bvc2l0aXZlSW50ZWdlcihyZXN1bHQpO1xufVxuZnVuY3Rpb24gQ2FsZW5kYXJNb250aENvZGUoY2FsZW5kYXIsIGRhdGVMaWtlKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gY2FsZW5kYXIubW9udGhDb2RlKGRhdGVMaWtlKTtcbiAgICBpZiAocmVzdWx0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2NhbGVuZGFyIG1vbnRoQ29kZSByZXN1bHQgbXVzdCBiZSBhIHN0cmluZycpO1xuICAgIH1cbiAgICByZXR1cm4gVG9TdHJpbmcocmVzdWx0KTtcbn1cbmZ1bmN0aW9uIENhbGVuZGFyRGF5KGNhbGVuZGFyLCBkYXRlTGlrZSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IGNhbGVuZGFyLmRheShkYXRlTGlrZSk7XG4gICAgaWYgKHJlc3VsdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdjYWxlbmRhciBkYXkgcmVzdWx0IG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyJyk7XG4gICAgfVxuICAgIHJldHVybiBUb1Bvc2l0aXZlSW50ZWdlcihyZXN1bHQpO1xufVxuZnVuY3Rpb24gQ2FsZW5kYXJFcmEoY2FsZW5kYXIsIGRhdGVMaWtlKSB7XG4gICAgbGV0IHJlc3VsdCA9IGNhbGVuZGFyLmVyYShkYXRlTGlrZSk7XG4gICAgaWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJlc3VsdCA9IFRvU3RyaW5nKHJlc3VsdCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBDYWxlbmRhckVyYVllYXIoY2FsZW5kYXIsIGRhdGVMaWtlKSB7XG4gICAgbGV0IHJlc3VsdCA9IGNhbGVuZGFyLmVyYVllYXIoZGF0ZUxpa2UpO1xuICAgIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXN1bHQgPSBUb0ludGVnZXJUaHJvd09uSW5maW5pdHkocmVzdWx0KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIENhbGVuZGFyRGF5T2ZXZWVrKGNhbGVuZGFyLCBkYXRlTGlrZSkge1xuICAgIHJldHVybiBjYWxlbmRhci5kYXlPZldlZWsoZGF0ZUxpa2UpO1xufVxuZnVuY3Rpb24gQ2FsZW5kYXJEYXlPZlllYXIoY2FsZW5kYXIsIGRhdGVMaWtlKSB7XG4gICAgcmV0dXJuIGNhbGVuZGFyLmRheU9mWWVhcihkYXRlTGlrZSk7XG59XG5mdW5jdGlvbiBDYWxlbmRhcldlZWtPZlllYXIoY2FsZW5kYXIsIGRhdGVMaWtlKSB7XG4gICAgcmV0dXJuIGNhbGVuZGFyLndlZWtPZlllYXIoZGF0ZUxpa2UpO1xufVxuZnVuY3Rpb24gQ2FsZW5kYXJEYXlzSW5XZWVrKGNhbGVuZGFyLCBkYXRlTGlrZSkge1xuICAgIHJldHVybiBjYWxlbmRhci5kYXlzSW5XZWVrKGRhdGVMaWtlKTtcbn1cbmZ1bmN0aW9uIENhbGVuZGFyRGF5c0luTW9udGgoY2FsZW5kYXIsIGRhdGVMaWtlKSB7XG4gICAgcmV0dXJuIGNhbGVuZGFyLmRheXNJbk1vbnRoKGRhdGVMaWtlKTtcbn1cbmZ1bmN0aW9uIENhbGVuZGFyRGF5c0luWWVhcihjYWxlbmRhciwgZGF0ZUxpa2UpIHtcbiAgICByZXR1cm4gY2FsZW5kYXIuZGF5c0luWWVhcihkYXRlTGlrZSk7XG59XG5mdW5jdGlvbiBDYWxlbmRhck1vbnRoc0luWWVhcihjYWxlbmRhciwgZGF0ZUxpa2UpIHtcbiAgICByZXR1cm4gY2FsZW5kYXIubW9udGhzSW5ZZWFyKGRhdGVMaWtlKTtcbn1cbmZ1bmN0aW9uIENhbGVuZGFySW5MZWFwWWVhcihjYWxlbmRhciwgZGF0ZUxpa2UpIHtcbiAgICByZXR1cm4gY2FsZW5kYXIuaW5MZWFwWWVhcihkYXRlTGlrZSk7XG59XG5mdW5jdGlvbiBUb1RlbXBvcmFsQ2FsZW5kYXIoY2FsZW5kYXJMaWtlUGFyYW0pIHtcbiAgICBsZXQgY2FsZW5kYXJMaWtlID0gY2FsZW5kYXJMaWtlUGFyYW07XG4gICAgaWYgKElzT2JqZWN0KGNhbGVuZGFyTGlrZSkpIHtcbiAgICAgICAgaWYgKEhhc1Nsb3QoY2FsZW5kYXJMaWtlLCBDQUxFTkRBUikpXG4gICAgICAgICAgICByZXR1cm4gR2V0U2xvdChjYWxlbmRhckxpa2UsIENBTEVOREFSKTtcbiAgICAgICAgaWYgKCEoJ2NhbGVuZGFyJyBpbiBjYWxlbmRhckxpa2UpKVxuICAgICAgICAgICAgcmV0dXJuIGNhbGVuZGFyTGlrZTtcbiAgICAgICAgY2FsZW5kYXJMaWtlID0gY2FsZW5kYXJMaWtlLmNhbGVuZGFyO1xuICAgICAgICBpZiAoSXNPYmplY3QoY2FsZW5kYXJMaWtlKSAmJiAhKCdjYWxlbmRhcicgaW4gY2FsZW5kYXJMaWtlKSlcbiAgICAgICAgICAgIHJldHVybiBjYWxlbmRhckxpa2U7XG4gICAgfVxuICAgIGNvbnN0IGlkZW50aWZpZXIgPSBUb1N0cmluZyhjYWxlbmRhckxpa2UpO1xuICAgIGNvbnN0IFRlbXBvcmFsQ2FsZW5kYXIgPSBHZXRJbnRyaW5zaWMoJyVUZW1wb3JhbC5DYWxlbmRhciUnKTtcbiAgICBpZiAoSXNCdWlsdGluQ2FsZW5kYXIoaWRlbnRpZmllcikpXG4gICAgICAgIHJldHVybiBuZXcgVGVtcG9yYWxDYWxlbmRhcihpZGVudGlmaWVyKTtcbiAgICBsZXQgY2FsZW5kYXI7XG4gICAgdHJ5IHtcbiAgICAgICAgKHsgY2FsZW5kYXIgfSA9IFBhcnNlSVNPRGF0ZVRpbWUoaWRlbnRpZmllcikpO1xuICAgIH1cbiAgICBjYXRjaCB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBJbnZhbGlkIGNhbGVuZGFyOiAke2lkZW50aWZpZXJ9YCk7XG4gICAgfVxuICAgIGlmICghY2FsZW5kYXIpXG4gICAgICAgIGNhbGVuZGFyID0gJ2lzbzg2MDEnO1xuICAgIHJldHVybiBuZXcgVGVtcG9yYWxDYWxlbmRhcihjYWxlbmRhcik7XG59XG5mdW5jdGlvbiBHZXRUZW1wb3JhbENhbGVuZGFyV2l0aElTT0RlZmF1bHQoaXRlbSkge1xuICAgIGlmIChIYXNTbG90KGl0ZW0sIENBTEVOREFSKSlcbiAgICAgICAgcmV0dXJuIEdldFNsb3QoaXRlbSwgQ0FMRU5EQVIpO1xuICAgIGNvbnN0IHsgY2FsZW5kYXIgfSA9IGl0ZW07XG4gICAgaWYgKGNhbGVuZGFyID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiBHZXRJU084NjAxQ2FsZW5kYXIoKTtcbiAgICByZXR1cm4gVG9UZW1wb3JhbENhbGVuZGFyKGNhbGVuZGFyKTtcbn1cbmZ1bmN0aW9uIENhbGVuZGFyRXF1YWxzKG9uZSwgdHdvKSB7XG4gICAgaWYgKG9uZSA9PT0gdHdvKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBjb25zdCBjYWwxID0gVG9TdHJpbmcob25lKTtcbiAgICBjb25zdCBjYWwyID0gVG9TdHJpbmcodHdvKTtcbiAgICByZXR1cm4gY2FsMSA9PT0gY2FsMjtcbn1cbmZ1bmN0aW9uIENvbnNvbGlkYXRlQ2FsZW5kYXJzKG9uZSwgdHdvKSB7XG4gICAgaWYgKG9uZSA9PT0gdHdvKVxuICAgICAgICByZXR1cm4gdHdvO1xuICAgIGNvbnN0IHNPbmUgPSBUb1N0cmluZyhvbmUpO1xuICAgIGNvbnN0IHNUd28gPSBUb1N0cmluZyh0d28pO1xuICAgIGlmIChzT25lID09PSBzVHdvIHx8IHNPbmUgPT09ICdpc284NjAxJykge1xuICAgICAgICByZXR1cm4gdHdvO1xuICAgIH1cbiAgICBlbHNlIGlmIChzVHdvID09PSAnaXNvODYwMScpIHtcbiAgICAgICAgcmV0dXJuIG9uZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdpcnJlY29uY2lsYWJsZSBjYWxlbmRhcnMnKTtcbiAgICB9XG59XG5mdW5jdGlvbiBEYXRlRnJvbUZpZWxkcyhjYWxlbmRhciwgZmllbGRzLCBvcHRpb25zKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gY2FsZW5kYXIuZGF0ZUZyb21GaWVsZHMoZmllbGRzLCBvcHRpb25zKTtcbiAgICBpZiAoIUlzVGVtcG9yYWxEYXRlKHJlc3VsdCkpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVzdWx0Jyk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIFllYXJNb250aEZyb21GaWVsZHMoY2FsZW5kYXIsIGZpZWxkcywgb3B0aW9ucykge1xuICAgIGNvbnN0IHJlc3VsdCA9IGNhbGVuZGFyLnllYXJNb250aEZyb21GaWVsZHMoZmllbGRzLCBvcHRpb25zKTtcbiAgICBpZiAoIUlzVGVtcG9yYWxZZWFyTW9udGgocmVzdWx0KSlcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZXN1bHQnKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gTW9udGhEYXlGcm9tRmllbGRzKGNhbGVuZGFyLCBmaWVsZHMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCByZXN1bHQgPSBjYWxlbmRhci5tb250aERheUZyb21GaWVsZHMoZmllbGRzLCBvcHRpb25zKTtcbiAgICBpZiAoIUlzVGVtcG9yYWxNb250aERheShyZXN1bHQpKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlc3VsdCcpO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBUb1RlbXBvcmFsVGltZVpvbmUodGVtcG9yYWxUaW1lWm9uZUxpa2VQYXJhbSkge1xuICAgIGxldCB0ZW1wb3JhbFRpbWVab25lTGlrZSA9IHRlbXBvcmFsVGltZVpvbmVMaWtlUGFyYW07XG4gICAgaWYgKElzT2JqZWN0KHRlbXBvcmFsVGltZVpvbmVMaWtlKSkge1xuICAgICAgICBpZiAoSXNUZW1wb3JhbFpvbmVkRGF0ZVRpbWUodGVtcG9yYWxUaW1lWm9uZUxpa2UpKVxuICAgICAgICAgICAgcmV0dXJuIEdldFNsb3QodGVtcG9yYWxUaW1lWm9uZUxpa2UsIFRJTUVfWk9ORSk7XG4gICAgICAgIGlmICghKCd0aW1lWm9uZScgaW4gdGVtcG9yYWxUaW1lWm9uZUxpa2UpKVxuICAgICAgICAgICAgcmV0dXJuIHRlbXBvcmFsVGltZVpvbmVMaWtlO1xuICAgICAgICB0ZW1wb3JhbFRpbWVab25lTGlrZSA9IHRlbXBvcmFsVGltZVpvbmVMaWtlLnRpbWVab25lO1xuICAgICAgICBpZiAoSXNPYmplY3QodGVtcG9yYWxUaW1lWm9uZUxpa2UpICYmICEoJ3RpbWVab25lJyBpbiB0ZW1wb3JhbFRpbWVab25lTGlrZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0ZW1wb3JhbFRpbWVab25lTGlrZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBpZGVudGlmaWVyID0gVG9TdHJpbmcodGVtcG9yYWxUaW1lWm9uZUxpa2UpO1xuICAgIGNvbnN0IHRpbWVab25lID0gUGFyc2VUZW1wb3JhbFRpbWVab25lKGlkZW50aWZpZXIpO1xuICAgIGNvbnN0IFRlbXBvcmFsVGltZVpvbmUgPSBHZXRJbnRyaW5zaWMoJyVUZW1wb3JhbC5UaW1lWm9uZSUnKTtcbiAgICByZXR1cm4gbmV3IFRlbXBvcmFsVGltZVpvbmUodGltZVpvbmUpO1xufVxuZnVuY3Rpb24gVGltZVpvbmVFcXVhbHMob25lLCB0d28pIHtcbiAgICBpZiAob25lID09PSB0d28pXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIGNvbnN0IHR6MSA9IFRvU3RyaW5nKG9uZSk7XG4gICAgY29uc3QgdHoyID0gVG9TdHJpbmcodHdvKTtcbiAgICByZXR1cm4gdHoxID09PSB0ejI7XG59XG5mdW5jdGlvbiBUZW1wb3JhbERhdGVUaW1lVG9EYXRlKGRhdGVUaW1lKSB7XG4gICAgcmV0dXJuIENyZWF0ZVRlbXBvcmFsRGF0ZShHZXRTbG90KGRhdGVUaW1lLCBJU09fWUVBUiksIEdldFNsb3QoZGF0ZVRpbWUsIElTT19NT05USCksIEdldFNsb3QoZGF0ZVRpbWUsIElTT19EQVkpLCBHZXRTbG90KGRhdGVUaW1lLCBDQUxFTkRBUikpO1xufVxuZnVuY3Rpb24gVGVtcG9yYWxEYXRlVGltZVRvVGltZShkYXRlVGltZSkge1xuICAgIGNvbnN0IFRpbWUgPSBHZXRJbnRyaW5zaWMoJyVUZW1wb3JhbC5QbGFpblRpbWUlJyk7XG4gICAgcmV0dXJuIG5ldyBUaW1lKEdldFNsb3QoZGF0ZVRpbWUsIElTT19IT1VSKSwgR2V0U2xvdChkYXRlVGltZSwgSVNPX01JTlVURSksIEdldFNsb3QoZGF0ZVRpbWUsIElTT19TRUNPTkQpLCBHZXRTbG90KGRhdGVUaW1lLCBJU09fTUlMTElTRUNPTkQpLCBHZXRTbG90KGRhdGVUaW1lLCBJU09fTUlDUk9TRUNPTkQpLCBHZXRTbG90KGRhdGVUaW1lLCBJU09fTkFOT1NFQ09ORCkpO1xufVxuZnVuY3Rpb24gR2V0T2Zmc2V0TmFub3NlY29uZHNGb3IodGltZVpvbmUsIGluc3RhbnQpIHtcbiAgICBsZXQgZ2V0T2Zmc2V0TmFub3NlY29uZHNGb3IgPSB0aW1lWm9uZS5nZXRPZmZzZXROYW5vc2Vjb25kc0ZvcjtcbiAgICBpZiAodHlwZW9mIGdldE9mZnNldE5hbm9zZWNvbmRzRm9yICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2dldE9mZnNldE5hbm9zZWNvbmRzRm9yIG5vdCBjYWxsYWJsZScpO1xuICAgIH1cbiAgICBjb25zdCBvZmZzZXROcyA9IFJlZmxlY3QuYXBwbHkoZ2V0T2Zmc2V0TmFub3NlY29uZHNGb3IsIHRpbWVab25lLCBbaW5zdGFudF0pO1xuICAgIGlmICh0eXBlb2Ygb2Zmc2V0TnMgIT09ICdudW1iZXInKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2JhZCByZXR1cm4gZnJvbSBnZXRPZmZzZXROYW5vc2Vjb25kc0ZvcicpO1xuICAgIH1cbiAgICBpZiAoIUlzSW50ZWdlcihvZmZzZXROcykgfHwgTWF0aEFicyhvZmZzZXROcykgPiA4NjQwMGU5KSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdvdXQtb2YtcmFuZ2UgcmV0dXJuIGZyb20gZ2V0T2Zmc2V0TmFub3NlY29uZHNGb3InKTtcbiAgICB9XG4gICAgcmV0dXJuIG9mZnNldE5zO1xufVxuZnVuY3Rpb24gQnVpbHRpblRpbWVab25lR2V0T2Zmc2V0U3RyaW5nRm9yKHRpbWVab25lLCBpbnN0YW50KSB7XG4gICAgY29uc3Qgb2Zmc2V0TnMgPSBHZXRPZmZzZXROYW5vc2Vjb25kc0Zvcih0aW1lWm9uZSwgaW5zdGFudCk7XG4gICAgcmV0dXJuIEZvcm1hdFRpbWVab25lT2Zmc2V0U3RyaW5nKG9mZnNldE5zKTtcbn1cbmZ1bmN0aW9uIEJ1aWx0aW5UaW1lWm9uZUdldFBsYWluRGF0ZVRpbWVGb3IodGltZVpvbmUsIGluc3RhbnQsIGNhbGVuZGFyKSB7XG4gICAgY29uc3QgbnMgPSBHZXRTbG90KGluc3RhbnQsIEVQT0NITkFOT1NFQ09ORFMpO1xuICAgIGNvbnN0IG9mZnNldE5zID0gR2V0T2Zmc2V0TmFub3NlY29uZHNGb3IodGltZVpvbmUsIGluc3RhbnQpO1xuICAgIGxldCB7IHllYXIsIG1vbnRoLCBkYXksIGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZCwgbWljcm9zZWNvbmQsIG5hbm9zZWNvbmQgfSA9IEdldElTT1BhcnRzRnJvbUVwb2NoKG5zKTtcbiAgICAoeyB5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQsIG1pY3Jvc2Vjb25kLCBuYW5vc2Vjb25kIH0gPSBCYWxhbmNlSVNPRGF0ZVRpbWUoeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kLCBtaWNyb3NlY29uZCwgbmFub3NlY29uZCArIG9mZnNldE5zKSk7XG4gICAgcmV0dXJuIENyZWF0ZVRlbXBvcmFsRGF0ZVRpbWUoeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kLCBtaWNyb3NlY29uZCwgbmFub3NlY29uZCwgY2FsZW5kYXIpO1xufVxuZnVuY3Rpb24gQnVpbHRpblRpbWVab25lR2V0SW5zdGFudEZvcih0aW1lWm9uZSwgZGF0ZVRpbWUsIGRpc2FtYmlndWF0aW9uKSB7XG4gICAgY29uc3QgcG9zc2libGVJbnN0YW50cyA9IEdldFBvc3NpYmxlSW5zdGFudHNGb3IodGltZVpvbmUsIGRhdGVUaW1lKTtcbiAgICByZXR1cm4gRGlzYW1iaWd1YXRlUG9zc2libGVJbnN0YW50cyhwb3NzaWJsZUluc3RhbnRzLCB0aW1lWm9uZSwgZGF0ZVRpbWUsIGRpc2FtYmlndWF0aW9uKTtcbn1cbmZ1bmN0aW9uIERpc2FtYmlndWF0ZVBvc3NpYmxlSW5zdGFudHMocG9zc2libGVJbnN0YW50cywgdGltZVpvbmUsIGRhdGVUaW1lLCBkaXNhbWJpZ3VhdGlvbikge1xuICAgIGNvbnN0IEluc3RhbnQgPSBHZXRJbnRyaW5zaWMoJyVUZW1wb3JhbC5JbnN0YW50JScpO1xuICAgIGNvbnN0IG51bUluc3RhbnRzID0gcG9zc2libGVJbnN0YW50cy5sZW5ndGg7XG4gICAgaWYgKG51bUluc3RhbnRzID09PSAxKVxuICAgICAgICByZXR1cm4gcG9zc2libGVJbnN0YW50c1swXTtcbiAgICBpZiAobnVtSW5zdGFudHMpIHtcbiAgICAgICAgc3dpdGNoIChkaXNhbWJpZ3VhdGlvbikge1xuICAgICAgICAgICAgY2FzZSAnY29tcGF0aWJsZSc6XG4gICAgICAgICAgICAvLyBmYWxsIHRocm91Z2ggYmVjYXVzZSAnY29tcGF0aWJsZScgbWVhbnMgJ2VhcmxpZXInIGZvciBcImZhbGwgYmFja1wiIHRyYW5zaXRpb25zXG4gICAgICAgICAgICBjYXNlICdlYXJsaWVyJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gcG9zc2libGVJbnN0YW50c1swXTtcbiAgICAgICAgICAgIGNhc2UgJ2xhdGVyJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gcG9zc2libGVJbnN0YW50c1tudW1JbnN0YW50cyAtIDFdO1xuICAgICAgICAgICAgY2FzZSAncmVqZWN0Jzoge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdtdWx0aXBsZSBpbnN0YW50cyBmb3VuZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHllYXIgPSBHZXRTbG90KGRhdGVUaW1lLCBJU09fWUVBUik7XG4gICAgY29uc3QgbW9udGggPSBHZXRTbG90KGRhdGVUaW1lLCBJU09fTU9OVEgpO1xuICAgIGNvbnN0IGRheSA9IEdldFNsb3QoZGF0ZVRpbWUsIElTT19EQVkpO1xuICAgIGNvbnN0IGhvdXIgPSBHZXRTbG90KGRhdGVUaW1lLCBJU09fSE9VUik7XG4gICAgY29uc3QgbWludXRlID0gR2V0U2xvdChkYXRlVGltZSwgSVNPX01JTlVURSk7XG4gICAgY29uc3Qgc2Vjb25kID0gR2V0U2xvdChkYXRlVGltZSwgSVNPX1NFQ09ORCk7XG4gICAgY29uc3QgbWlsbGlzZWNvbmQgPSBHZXRTbG90KGRhdGVUaW1lLCBJU09fTUlMTElTRUNPTkQpO1xuICAgIGNvbnN0IG1pY3Jvc2Vjb25kID0gR2V0U2xvdChkYXRlVGltZSwgSVNPX01JQ1JPU0VDT05EKTtcbiAgICBjb25zdCBuYW5vc2Vjb25kID0gR2V0U2xvdChkYXRlVGltZSwgSVNPX05BTk9TRUNPTkQpO1xuICAgIGNvbnN0IHV0Y25zID0gR2V0RXBvY2hGcm9tSVNPUGFydHMoeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kLCBtaWNyb3NlY29uZCwgbmFub3NlY29uZCk7XG4gICAgaWYgKHV0Y25zID09PSBudWxsKVxuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignRGF0ZVRpbWUgb3V0c2lkZSBvZiBzdXBwb3J0ZWQgcmFuZ2UnKTtcbiAgICBjb25zdCBkYXlCZWZvcmUgPSBuZXcgSW5zdGFudChKU0JJLnN1YnRyYWN0KHV0Y25zLCBEQVlfTkFOT1MpKTtcbiAgICBjb25zdCBkYXlBZnRlciA9IG5ldyBJbnN0YW50KEpTQkkuYWRkKHV0Y25zLCBEQVlfTkFOT1MpKTtcbiAgICBjb25zdCBvZmZzZXRCZWZvcmUgPSBHZXRPZmZzZXROYW5vc2Vjb25kc0Zvcih0aW1lWm9uZSwgZGF5QmVmb3JlKTtcbiAgICBjb25zdCBvZmZzZXRBZnRlciA9IEdldE9mZnNldE5hbm9zZWNvbmRzRm9yKHRpbWVab25lLCBkYXlBZnRlcik7XG4gICAgY29uc3QgbmFub3NlY29uZHMgPSBvZmZzZXRBZnRlciAtIG9mZnNldEJlZm9yZTtcbiAgICBzd2l0Y2ggKGRpc2FtYmlndWF0aW9uKSB7XG4gICAgICAgIGNhc2UgJ2VhcmxpZXInOiB7XG4gICAgICAgICAgICBjb25zdCBjYWxlbmRhciA9IEdldFNsb3QoZGF0ZVRpbWUsIENBTEVOREFSKTtcbiAgICAgICAgICAgIGNvbnN0IFBsYWluRGF0ZVRpbWUgPSBHZXRJbnRyaW5zaWMoJyVUZW1wb3JhbC5QbGFpbkRhdGVUaW1lJScpO1xuICAgICAgICAgICAgY29uc3QgZWFybGllciA9IEFkZERhdGVUaW1lKHllYXIsIG1vbnRoLCBkYXksIGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZCwgbWljcm9zZWNvbmQsIG5hbm9zZWNvbmQsIGNhbGVuZGFyLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAtbmFub3NlY29uZHMsIHVuZGVmaW5lZCk7XG4gICAgICAgICAgICBjb25zdCBlYXJsaWVyUGxhaW5EYXRlVGltZSA9IG5ldyBQbGFpbkRhdGVUaW1lKGVhcmxpZXIueWVhciwgZWFybGllci5tb250aCwgZWFybGllci5kYXksIGVhcmxpZXIuaG91ciwgZWFybGllci5taW51dGUsIGVhcmxpZXIuc2Vjb25kLCBlYXJsaWVyLm1pbGxpc2Vjb25kLCBlYXJsaWVyLm1pY3Jvc2Vjb25kLCBlYXJsaWVyLm5hbm9zZWNvbmQsIGNhbGVuZGFyKTtcbiAgICAgICAgICAgIHJldHVybiBHZXRQb3NzaWJsZUluc3RhbnRzRm9yKHRpbWVab25lLCBlYXJsaWVyUGxhaW5EYXRlVGltZSlbMF07XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnY29tcGF0aWJsZSc6XG4gICAgICAgIC8vIGZhbGwgdGhyb3VnaCBiZWNhdXNlICdjb21wYXRpYmxlJyBtZWFucyAnbGF0ZXInIGZvciBcInNwcmluZyBmb3J3YXJkXCIgdHJhbnNpdGlvbnNcbiAgICAgICAgY2FzZSAnbGF0ZXInOiB7XG4gICAgICAgICAgICBjb25zdCBjYWxlbmRhciA9IEdldFNsb3QoZGF0ZVRpbWUsIENBTEVOREFSKTtcbiAgICAgICAgICAgIGNvbnN0IFBsYWluRGF0ZVRpbWUgPSBHZXRJbnRyaW5zaWMoJyVUZW1wb3JhbC5QbGFpbkRhdGVUaW1lJScpO1xuICAgICAgICAgICAgY29uc3QgbGF0ZXIgPSBBZGREYXRlVGltZSh5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQsIG1pY3Jvc2Vjb25kLCBuYW5vc2Vjb25kLCBjYWxlbmRhciwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgbmFub3NlY29uZHMsIHVuZGVmaW5lZCk7XG4gICAgICAgICAgICBjb25zdCBsYXRlclBsYWluRGF0ZVRpbWUgPSBuZXcgUGxhaW5EYXRlVGltZShsYXRlci55ZWFyLCBsYXRlci5tb250aCwgbGF0ZXIuZGF5LCBsYXRlci5ob3VyLCBsYXRlci5taW51dGUsIGxhdGVyLnNlY29uZCwgbGF0ZXIubWlsbGlzZWNvbmQsIGxhdGVyLm1pY3Jvc2Vjb25kLCBsYXRlci5uYW5vc2Vjb25kLCBjYWxlbmRhcik7XG4gICAgICAgICAgICBjb25zdCBwb3NzaWJsZSA9IEdldFBvc3NpYmxlSW5zdGFudHNGb3IodGltZVpvbmUsIGxhdGVyUGxhaW5EYXRlVGltZSk7XG4gICAgICAgICAgICByZXR1cm4gcG9zc2libGVbcG9zc2libGUubGVuZ3RoIC0gMV07XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAncmVqZWN0Jzoge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ25vIHN1Y2ggaW5zdGFudCBmb3VuZCcpO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gR2V0UG9zc2libGVJbnN0YW50c0Zvcih0aW1lWm9uZSwgZGF0ZVRpbWUpIHtcbiAgICBjb25zdCBwb3NzaWJsZUluc3RhbnRzID0gdGltZVpvbmUuZ2V0UG9zc2libGVJbnN0YW50c0ZvcihkYXRlVGltZSk7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgZm9yIChjb25zdCBpbnN0YW50IG9mIHBvc3NpYmxlSW5zdGFudHMpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsSW5zdGFudChpbnN0YW50KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYmFkIHJldHVybiBmcm9tIGdldFBvc3NpYmxlSW5zdGFudHNGb3InKTtcbiAgICAgICAgfVxuICAgICAgICBBcnJheVByb3RvdHlwZVB1c2gkMS5jYWxsKHJlc3VsdCwgaW5zdGFudCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBJU09ZZWFyU3RyaW5nKHllYXIpIHtcbiAgICBsZXQgeWVhclN0cmluZztcbiAgICBpZiAoeWVhciA8IDEwMDAgfHwgeWVhciA+IDk5OTkpIHtcbiAgICAgICAgY29uc3Qgc2lnbiA9IHllYXIgPCAwID8gJy0nIDogJysnO1xuICAgICAgICBjb25zdCB5ZWFyTnVtYmVyID0gTWF0aEFicyh5ZWFyKTtcbiAgICAgICAgeWVhclN0cmluZyA9IHNpZ24gKyBgMDAwMDAwJHt5ZWFyTnVtYmVyfWAuc2xpY2UoLTYpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgeWVhclN0cmluZyA9IGAke3llYXJ9YDtcbiAgICB9XG4gICAgcmV0dXJuIHllYXJTdHJpbmc7XG59XG5mdW5jdGlvbiBJU09EYXRlVGltZVBhcnRTdHJpbmcocGFydCkge1xuICAgIHJldHVybiBgMDAke3BhcnR9YC5zbGljZSgtMik7XG59XG5mdW5jdGlvbiBGb3JtYXRTZWNvbmRzU3RyaW5nUGFydChzZWNvbmQsIG1pbGxpc2Vjb25kLCBtaWNyb3NlY29uZCwgbmFub3NlY29uZCwgcHJlY2lzaW9uKSB7XG4gICAgaWYgKHByZWNpc2lvbiA9PT0gJ21pbnV0ZScpXG4gICAgICAgIHJldHVybiAnJztcbiAgICBjb25zdCBzZWNzID0gYDoke0lTT0RhdGVUaW1lUGFydFN0cmluZyhzZWNvbmQpfWA7XG4gICAgbGV0IGZyYWN0aW9uTnVtYmVyID0gbWlsbGlzZWNvbmQgKiAxZTYgKyBtaWNyb3NlY29uZCAqIDFlMyArIG5hbm9zZWNvbmQ7XG4gICAgbGV0IGZyYWN0aW9uO1xuICAgIGlmIChwcmVjaXNpb24gPT09ICdhdXRvJykge1xuICAgICAgICBpZiAoZnJhY3Rpb25OdW1iZXIgPT09IDApXG4gICAgICAgICAgICByZXR1cm4gc2VjcztcbiAgICAgICAgZnJhY3Rpb24gPSBgJHtmcmFjdGlvbk51bWJlcn1gLnBhZFN0YXJ0KDksICcwJyk7XG4gICAgICAgIHdoaWxlIChmcmFjdGlvbltmcmFjdGlvbi5sZW5ndGggLSAxXSA9PT0gJzAnKVxuICAgICAgICAgICAgZnJhY3Rpb24gPSBmcmFjdGlvbi5zbGljZSgwLCAtMSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAocHJlY2lzaW9uID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuIHNlY3M7XG4gICAgICAgIGZyYWN0aW9uID0gYCR7ZnJhY3Rpb25OdW1iZXJ9YC5wYWRTdGFydCg5LCAnMCcpLnNsaWNlKDAsIHByZWNpc2lvbik7XG4gICAgfVxuICAgIHJldHVybiBgJHtzZWNzfS4ke2ZyYWN0aW9ufWA7XG59XG5mdW5jdGlvbiBUZW1wb3JhbEluc3RhbnRUb1N0cmluZyhpbnN0YW50LCB0aW1lWm9uZSwgcHJlY2lzaW9uKSB7XG4gICAgbGV0IG91dHB1dFRpbWVab25lID0gdGltZVpvbmU7XG4gICAgaWYgKG91dHB1dFRpbWVab25lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3QgVGVtcG9yYWxUaW1lWm9uZSA9IEdldEludHJpbnNpYygnJVRlbXBvcmFsLlRpbWVab25lJScpO1xuICAgICAgICBvdXRwdXRUaW1lWm9uZSA9IG5ldyBUZW1wb3JhbFRpbWVab25lKCdVVEMnKTtcbiAgICB9XG4gICAgY29uc3QgaXNvID0gR2V0SVNPODYwMUNhbGVuZGFyKCk7XG4gICAgY29uc3QgZGF0ZVRpbWUgPSBCdWlsdGluVGltZVpvbmVHZXRQbGFpbkRhdGVUaW1lRm9yKG91dHB1dFRpbWVab25lLCBpbnN0YW50LCBpc28pO1xuICAgIGNvbnN0IHllYXIgPSBJU09ZZWFyU3RyaW5nKEdldFNsb3QoZGF0ZVRpbWUsIElTT19ZRUFSKSk7XG4gICAgY29uc3QgbW9udGggPSBJU09EYXRlVGltZVBhcnRTdHJpbmcoR2V0U2xvdChkYXRlVGltZSwgSVNPX01PTlRIKSk7XG4gICAgY29uc3QgZGF5ID0gSVNPRGF0ZVRpbWVQYXJ0U3RyaW5nKEdldFNsb3QoZGF0ZVRpbWUsIElTT19EQVkpKTtcbiAgICBjb25zdCBob3VyID0gSVNPRGF0ZVRpbWVQYXJ0U3RyaW5nKEdldFNsb3QoZGF0ZVRpbWUsIElTT19IT1VSKSk7XG4gICAgY29uc3QgbWludXRlID0gSVNPRGF0ZVRpbWVQYXJ0U3RyaW5nKEdldFNsb3QoZGF0ZVRpbWUsIElTT19NSU5VVEUpKTtcbiAgICBjb25zdCBzZWNvbmRzID0gRm9ybWF0U2Vjb25kc1N0cmluZ1BhcnQoR2V0U2xvdChkYXRlVGltZSwgSVNPX1NFQ09ORCksIEdldFNsb3QoZGF0ZVRpbWUsIElTT19NSUxMSVNFQ09ORCksIEdldFNsb3QoZGF0ZVRpbWUsIElTT19NSUNST1NFQ09ORCksIEdldFNsb3QoZGF0ZVRpbWUsIElTT19OQU5PU0VDT05EKSwgcHJlY2lzaW9uKTtcbiAgICBsZXQgdGltZVpvbmVTdHJpbmcgPSAnWic7XG4gICAgaWYgKHRpbWVab25lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3Qgb2Zmc2V0TnMgPSBHZXRPZmZzZXROYW5vc2Vjb25kc0ZvcihvdXRwdXRUaW1lWm9uZSwgaW5zdGFudCk7XG4gICAgICAgIHRpbWVab25lU3RyaW5nID0gRm9ybWF0SVNPVGltZVpvbmVPZmZzZXRTdHJpbmcob2Zmc2V0TnMpO1xuICAgIH1cbiAgICByZXR1cm4gYCR7eWVhcn0tJHttb250aH0tJHtkYXl9VCR7aG91cn06JHttaW51dGV9JHtzZWNvbmRzfSR7dGltZVpvbmVTdHJpbmd9YDtcbn1cbmZ1bmN0aW9uIFRlbXBvcmFsRHVyYXRpb25Ub1N0cmluZyhkdXJhdGlvbiwgcHJlY2lzaW9uID0gJ2F1dG8nLCBvcHRpb25zID0gdW5kZWZpbmVkKSB7XG4gICAgZnVuY3Rpb24gZm9ybWF0TnVtYmVyKG51bSkge1xuICAgICAgICBpZiAobnVtIDw9IE51bWJlck1heFNhZmVJbnRlZ2VyKVxuICAgICAgICAgICAgcmV0dXJuIG51bS50b1N0cmluZygxMCk7XG4gICAgICAgIHJldHVybiBKU0JJLkJpZ0ludChudW0pLnRvU3RyaW5nKDEwKTtcbiAgICB9XG4gICAgY29uc3QgeWVhcnMgPSBHZXRTbG90KGR1cmF0aW9uLCBZRUFSUyk7XG4gICAgY29uc3QgbW9udGhzID0gR2V0U2xvdChkdXJhdGlvbiwgTU9OVEhTKTtcbiAgICBjb25zdCB3ZWVrcyA9IEdldFNsb3QoZHVyYXRpb24sIFdFRUtTKTtcbiAgICBjb25zdCBkYXlzID0gR2V0U2xvdChkdXJhdGlvbiwgREFZUyk7XG4gICAgY29uc3QgaG91cnMgPSBHZXRTbG90KGR1cmF0aW9uLCBIT1VSUyk7XG4gICAgY29uc3QgbWludXRlcyA9IEdldFNsb3QoZHVyYXRpb24sIE1JTlVURVMpO1xuICAgIGxldCBzZWNvbmRzID0gR2V0U2xvdChkdXJhdGlvbiwgU0VDT05EUyk7XG4gICAgbGV0IG1zID0gR2V0U2xvdChkdXJhdGlvbiwgTUlMTElTRUNPTkRTKTtcbiAgICBsZXQgwrVzID0gR2V0U2xvdChkdXJhdGlvbiwgTUlDUk9TRUNPTkRTKTtcbiAgICBsZXQgbnMgPSBHZXRTbG90KGR1cmF0aW9uLCBOQU5PU0VDT05EUyk7XG4gICAgY29uc3Qgc2lnbiA9IER1cmF0aW9uU2lnbih5ZWFycywgbW9udGhzLCB3ZWVrcywgZGF5cywgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIG1zLCDCtXMsIG5zKTtcbiAgICBpZiAob3B0aW9ucykge1xuICAgICAgICBjb25zdCB7IHVuaXQsIGluY3JlbWVudCwgcm91bmRpbmdNb2RlIH0gPSBvcHRpb25zO1xuICAgICAgICAoe1xuICAgICAgICAgICAgc2Vjb25kcyxcbiAgICAgICAgICAgIG1pbGxpc2Vjb25kczogbXMsXG4gICAgICAgICAgICBtaWNyb3NlY29uZHM6IMK1cyxcbiAgICAgICAgICAgIG5hbm9zZWNvbmRzOiBuc1xuICAgICAgICB9ID0gUm91bmREdXJhdGlvbigwLCAwLCAwLCAwLCAwLCAwLCBzZWNvbmRzLCBtcywgwrVzLCBucywgaW5jcmVtZW50LCB1bml0LCByb3VuZGluZ01vZGUpKTtcbiAgICB9XG4gICAgY29uc3QgZGF0ZVBhcnRzID0gW107XG4gICAgaWYgKHllYXJzKVxuICAgICAgICBkYXRlUGFydHMucHVzaChgJHtmb3JtYXROdW1iZXIoTWF0aEFicyh5ZWFycykpfVlgKTtcbiAgICBpZiAobW9udGhzKVxuICAgICAgICBkYXRlUGFydHMucHVzaChgJHtmb3JtYXROdW1iZXIoTWF0aEFicyhtb250aHMpKX1NYCk7XG4gICAgaWYgKHdlZWtzKVxuICAgICAgICBkYXRlUGFydHMucHVzaChgJHtmb3JtYXROdW1iZXIoTWF0aEFicyh3ZWVrcykpfVdgKTtcbiAgICBpZiAoZGF5cylcbiAgICAgICAgZGF0ZVBhcnRzLnB1c2goYCR7Zm9ybWF0TnVtYmVyKE1hdGhBYnMoZGF5cykpfURgKTtcbiAgICBjb25zdCB0aW1lUGFydHMgPSBbXTtcbiAgICBpZiAoaG91cnMpXG4gICAgICAgIHRpbWVQYXJ0cy5wdXNoKGAke2Zvcm1hdE51bWJlcihNYXRoQWJzKGhvdXJzKSl9SGApO1xuICAgIGlmIChtaW51dGVzKVxuICAgICAgICB0aW1lUGFydHMucHVzaChgJHtmb3JtYXROdW1iZXIoTWF0aEFicyhtaW51dGVzKSl9TWApO1xuICAgIGNvbnN0IHNlY29uZFBhcnRzID0gW107XG4gICAgbGV0IHRvdGFsID0gVG90YWxEdXJhdGlvbk5hbm9zZWNvbmRzKDAsIDAsIDAsIHNlY29uZHMsIG1zLCDCtXMsIG5zLCAwKTtcbiAgICBsZXQgbnNCaWdJbnQsIMK1c0JpZ0ludCwgbXNCaWdJbnQsIHNlY29uZHNCaWdJbnQ7XG4gICAgKHsgcXVvdGllbnQ6IHRvdGFsLCByZW1haW5kZXI6IG5zQmlnSW50IH0gPSBkaXZtb2QodG90YWwsIFRIT1VTQU5EKSk7XG4gICAgKHsgcXVvdGllbnQ6IHRvdGFsLCByZW1haW5kZXI6IMK1c0JpZ0ludCB9ID0gZGl2bW9kKHRvdGFsLCBUSE9VU0FORCkpO1xuICAgICh7IHF1b3RpZW50OiBzZWNvbmRzQmlnSW50LCByZW1haW5kZXI6IG1zQmlnSW50IH0gPSBkaXZtb2QodG90YWwsIFRIT1VTQU5EKSk7XG4gICAgY29uc3QgZnJhY3Rpb24gPSBNYXRoQWJzKEpTQkkudG9OdW1iZXIobXNCaWdJbnQpKSAqIDFlNiArIE1hdGhBYnMoSlNCSS50b051bWJlcijCtXNCaWdJbnQpKSAqIDFlMyArIE1hdGhBYnMoSlNCSS50b051bWJlcihuc0JpZ0ludCkpO1xuICAgIGxldCBkZWNpbWFsUGFydDtcbiAgICBpZiAocHJlY2lzaW9uID09PSAnYXV0bycpIHtcbiAgICAgICAgaWYgKGZyYWN0aW9uICE9PSAwKSB7XG4gICAgICAgICAgICBkZWNpbWFsUGFydCA9IGAke2ZyYWN0aW9ufWAucGFkU3RhcnQoOSwgJzAnKTtcbiAgICAgICAgICAgIHdoaWxlIChkZWNpbWFsUGFydFtkZWNpbWFsUGFydC5sZW5ndGggLSAxXSA9PT0gJzAnKSB7XG4gICAgICAgICAgICAgICAgZGVjaW1hbFBhcnQgPSBkZWNpbWFsUGFydC5zbGljZSgwLCAtMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAocHJlY2lzaW9uICE9PSAwKSB7XG4gICAgICAgIGRlY2ltYWxQYXJ0ID0gYCR7ZnJhY3Rpb259YC5wYWRTdGFydCg5LCAnMCcpLnNsaWNlKDAsIHByZWNpc2lvbik7XG4gICAgfVxuICAgIGlmIChkZWNpbWFsUGFydClcbiAgICAgICAgc2Vjb25kUGFydHMudW5zaGlmdCgnLicsIGRlY2ltYWxQYXJ0KTtcbiAgICBpZiAoIUpTQkkuZXF1YWwoc2Vjb25kc0JpZ0ludCwgWkVSTykgfHwgc2Vjb25kUGFydHMubGVuZ3RoIHx8IHByZWNpc2lvbiAhPT0gJ2F1dG8nKSB7XG4gICAgICAgIHNlY29uZFBhcnRzLnVuc2hpZnQoYWJzKHNlY29uZHNCaWdJbnQpLnRvU3RyaW5nKCkpO1xuICAgIH1cbiAgICBpZiAoc2Vjb25kUGFydHMubGVuZ3RoKVxuICAgICAgICB0aW1lUGFydHMucHVzaChgJHtzZWNvbmRQYXJ0cy5qb2luKCcnKX1TYCk7XG4gICAgaWYgKHRpbWVQYXJ0cy5sZW5ndGgpXG4gICAgICAgIHRpbWVQYXJ0cy51bnNoaWZ0KCdUJyk7XG4gICAgaWYgKCFkYXRlUGFydHMubGVuZ3RoICYmICF0aW1lUGFydHMubGVuZ3RoKVxuICAgICAgICByZXR1cm4gJ1BUMFMnO1xuICAgIHJldHVybiBgJHtzaWduIDwgMCA/ICctJyA6ICcnfVAke2RhdGVQYXJ0cy5qb2luKCcnKX0ke3RpbWVQYXJ0cy5qb2luKCcnKX1gO1xufVxuZnVuY3Rpb24gVGVtcG9yYWxEYXRlVG9TdHJpbmcoZGF0ZSwgc2hvd0NhbGVuZGFyID0gJ2F1dG8nKSB7XG4gICAgY29uc3QgeWVhciA9IElTT1llYXJTdHJpbmcoR2V0U2xvdChkYXRlLCBJU09fWUVBUikpO1xuICAgIGNvbnN0IG1vbnRoID0gSVNPRGF0ZVRpbWVQYXJ0U3RyaW5nKEdldFNsb3QoZGF0ZSwgSVNPX01PTlRIKSk7XG4gICAgY29uc3QgZGF5ID0gSVNPRGF0ZVRpbWVQYXJ0U3RyaW5nKEdldFNsb3QoZGF0ZSwgSVNPX0RBWSkpO1xuICAgIGNvbnN0IGNhbGVuZGFySUQgPSBUb1N0cmluZyhHZXRTbG90KGRhdGUsIENBTEVOREFSKSk7XG4gICAgY29uc3QgY2FsZW5kYXIgPSBGb3JtYXRDYWxlbmRhckFubm90YXRpb24oY2FsZW5kYXJJRCwgc2hvd0NhbGVuZGFyKTtcbiAgICByZXR1cm4gYCR7eWVhcn0tJHttb250aH0tJHtkYXl9JHtjYWxlbmRhcn1gO1xufVxuZnVuY3Rpb24gVGVtcG9yYWxEYXRlVGltZVRvU3RyaW5nKGRhdGVUaW1lLCBwcmVjaXNpb24sIHNob3dDYWxlbmRhciA9ICdhdXRvJywgb3B0aW9ucyA9IHVuZGVmaW5lZCkge1xuICAgIGxldCB5ZWFyID0gR2V0U2xvdChkYXRlVGltZSwgSVNPX1lFQVIpO1xuICAgIGxldCBtb250aCA9IEdldFNsb3QoZGF0ZVRpbWUsIElTT19NT05USCk7XG4gICAgbGV0IGRheSA9IEdldFNsb3QoZGF0ZVRpbWUsIElTT19EQVkpO1xuICAgIGxldCBob3VyID0gR2V0U2xvdChkYXRlVGltZSwgSVNPX0hPVVIpO1xuICAgIGxldCBtaW51dGUgPSBHZXRTbG90KGRhdGVUaW1lLCBJU09fTUlOVVRFKTtcbiAgICBsZXQgc2Vjb25kID0gR2V0U2xvdChkYXRlVGltZSwgSVNPX1NFQ09ORCk7XG4gICAgbGV0IG1pbGxpc2Vjb25kID0gR2V0U2xvdChkYXRlVGltZSwgSVNPX01JTExJU0VDT05EKTtcbiAgICBsZXQgbWljcm9zZWNvbmQgPSBHZXRTbG90KGRhdGVUaW1lLCBJU09fTUlDUk9TRUNPTkQpO1xuICAgIGxldCBuYW5vc2Vjb25kID0gR2V0U2xvdChkYXRlVGltZSwgSVNPX05BTk9TRUNPTkQpO1xuICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHsgdW5pdCwgaW5jcmVtZW50LCByb3VuZGluZ01vZGUgfSA9IG9wdGlvbnM7XG4gICAgICAgICh7IHllYXIsIG1vbnRoLCBkYXksIGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZCwgbWljcm9zZWNvbmQsIG5hbm9zZWNvbmQgfSA9IFJvdW5kSVNPRGF0ZVRpbWUoeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kLCBtaWNyb3NlY29uZCwgbmFub3NlY29uZCwgaW5jcmVtZW50LCB1bml0LCByb3VuZGluZ01vZGUpKTtcbiAgICB9XG4gICAgY29uc3QgeWVhclN0cmluZyA9IElTT1llYXJTdHJpbmcoeWVhcik7XG4gICAgY29uc3QgbW9udGhTdHJpbmcgPSBJU09EYXRlVGltZVBhcnRTdHJpbmcobW9udGgpO1xuICAgIGNvbnN0IGRheVN0cmluZyA9IElTT0RhdGVUaW1lUGFydFN0cmluZyhkYXkpO1xuICAgIGNvbnN0IGhvdXJTdHJpbmcgPSBJU09EYXRlVGltZVBhcnRTdHJpbmcoaG91cik7XG4gICAgY29uc3QgbWludXRlU3RyaW5nID0gSVNPRGF0ZVRpbWVQYXJ0U3RyaW5nKG1pbnV0ZSk7XG4gICAgY29uc3Qgc2Vjb25kc1N0cmluZyA9IEZvcm1hdFNlY29uZHNTdHJpbmdQYXJ0KHNlY29uZCwgbWlsbGlzZWNvbmQsIG1pY3Jvc2Vjb25kLCBuYW5vc2Vjb25kLCBwcmVjaXNpb24pO1xuICAgIGNvbnN0IGNhbGVuZGFySUQgPSBUb1N0cmluZyhHZXRTbG90KGRhdGVUaW1lLCBDQUxFTkRBUikpO1xuICAgIGNvbnN0IGNhbGVuZGFyID0gRm9ybWF0Q2FsZW5kYXJBbm5vdGF0aW9uKGNhbGVuZGFySUQsIHNob3dDYWxlbmRhcik7XG4gICAgcmV0dXJuIGAke3llYXJTdHJpbmd9LSR7bW9udGhTdHJpbmd9LSR7ZGF5U3RyaW5nfVQke2hvdXJTdHJpbmd9OiR7bWludXRlU3RyaW5nfSR7c2Vjb25kc1N0cmluZ30ke2NhbGVuZGFyfWA7XG59XG5mdW5jdGlvbiBUZW1wb3JhbE1vbnRoRGF5VG9TdHJpbmcobW9udGhEYXksIHNob3dDYWxlbmRhciA9ICdhdXRvJykge1xuICAgIGNvbnN0IG1vbnRoID0gSVNPRGF0ZVRpbWVQYXJ0U3RyaW5nKEdldFNsb3QobW9udGhEYXksIElTT19NT05USCkpO1xuICAgIGNvbnN0IGRheSA9IElTT0RhdGVUaW1lUGFydFN0cmluZyhHZXRTbG90KG1vbnRoRGF5LCBJU09fREFZKSk7XG4gICAgbGV0IHJlc3VsdFN0cmluZyA9IGAke21vbnRofS0ke2RheX1gO1xuICAgIGNvbnN0IGNhbGVuZGFyID0gR2V0U2xvdChtb250aERheSwgQ0FMRU5EQVIpO1xuICAgIGNvbnN0IGNhbGVuZGFySUQgPSBUb1N0cmluZyhjYWxlbmRhcik7XG4gICAgaWYgKGNhbGVuZGFySUQgIT09ICdpc284NjAxJykge1xuICAgICAgICBjb25zdCB5ZWFyID0gSVNPWWVhclN0cmluZyhHZXRTbG90KG1vbnRoRGF5LCBJU09fWUVBUikpO1xuICAgICAgICByZXN1bHRTdHJpbmcgPSBgJHt5ZWFyfS0ke3Jlc3VsdFN0cmluZ31gO1xuICAgIH1cbiAgICBjb25zdCBjYWxlbmRhclN0cmluZyA9IEZvcm1hdENhbGVuZGFyQW5ub3RhdGlvbihjYWxlbmRhcklELCBzaG93Q2FsZW5kYXIpO1xuICAgIGlmIChjYWxlbmRhclN0cmluZylcbiAgICAgICAgcmVzdWx0U3RyaW5nICs9IGNhbGVuZGFyU3RyaW5nO1xuICAgIHJldHVybiByZXN1bHRTdHJpbmc7XG59XG5mdW5jdGlvbiBUZW1wb3JhbFllYXJNb250aFRvU3RyaW5nKHllYXJNb250aCwgc2hvd0NhbGVuZGFyID0gJ2F1dG8nKSB7XG4gICAgY29uc3QgeWVhciA9IElTT1llYXJTdHJpbmcoR2V0U2xvdCh5ZWFyTW9udGgsIElTT19ZRUFSKSk7XG4gICAgY29uc3QgbW9udGggPSBJU09EYXRlVGltZVBhcnRTdHJpbmcoR2V0U2xvdCh5ZWFyTW9udGgsIElTT19NT05USCkpO1xuICAgIGxldCByZXN1bHRTdHJpbmcgPSBgJHt5ZWFyfS0ke21vbnRofWA7XG4gICAgY29uc3QgY2FsZW5kYXIgPSBHZXRTbG90KHllYXJNb250aCwgQ0FMRU5EQVIpO1xuICAgIGNvbnN0IGNhbGVuZGFySUQgPSBUb1N0cmluZyhjYWxlbmRhcik7XG4gICAgaWYgKGNhbGVuZGFySUQgIT09ICdpc284NjAxJykge1xuICAgICAgICBjb25zdCBkYXkgPSBJU09EYXRlVGltZVBhcnRTdHJpbmcoR2V0U2xvdCh5ZWFyTW9udGgsIElTT19EQVkpKTtcbiAgICAgICAgcmVzdWx0U3RyaW5nICs9IGAtJHtkYXl9YDtcbiAgICB9XG4gICAgY29uc3QgY2FsZW5kYXJTdHJpbmcgPSBGb3JtYXRDYWxlbmRhckFubm90YXRpb24oY2FsZW5kYXJJRCwgc2hvd0NhbGVuZGFyKTtcbiAgICBpZiAoY2FsZW5kYXJTdHJpbmcpXG4gICAgICAgIHJlc3VsdFN0cmluZyArPSBjYWxlbmRhclN0cmluZztcbiAgICByZXR1cm4gcmVzdWx0U3RyaW5nO1xufVxuZnVuY3Rpb24gVGVtcG9yYWxab25lZERhdGVUaW1lVG9TdHJpbmcoemR0LCBwcmVjaXNpb24sIHNob3dDYWxlbmRhciA9ICdhdXRvJywgc2hvd1RpbWVab25lID0gJ2F1dG8nLCBzaG93T2Zmc2V0ID0gJ2F1dG8nLCBvcHRpb25zID0gdW5kZWZpbmVkKSB7XG4gICAgbGV0IGluc3RhbnQgPSBHZXRTbG90KHpkdCwgSU5TVEFOVCk7XG4gICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgeyB1bml0LCBpbmNyZW1lbnQsIHJvdW5kaW5nTW9kZSB9ID0gb3B0aW9ucztcbiAgICAgICAgY29uc3QgbnMgPSBSb3VuZEluc3RhbnQoR2V0U2xvdCh6ZHQsIEVQT0NITkFOT1NFQ09ORFMpLCBpbmNyZW1lbnQsIHVuaXQsIHJvdW5kaW5nTW9kZSk7XG4gICAgICAgIGNvbnN0IFRlbXBvcmFsSW5zdGFudCA9IEdldEludHJpbnNpYygnJVRlbXBvcmFsLkluc3RhbnQlJyk7XG4gICAgICAgIGluc3RhbnQgPSBuZXcgVGVtcG9yYWxJbnN0YW50KG5zKTtcbiAgICB9XG4gICAgY29uc3QgdHogPSBHZXRTbG90KHpkdCwgVElNRV9aT05FKTtcbiAgICBjb25zdCBpc28gPSBHZXRJU084NjAxQ2FsZW5kYXIoKTtcbiAgICBjb25zdCBkYXRlVGltZSA9IEJ1aWx0aW5UaW1lWm9uZUdldFBsYWluRGF0ZVRpbWVGb3IodHosIGluc3RhbnQsIGlzbyk7XG4gICAgY29uc3QgeWVhciA9IElTT1llYXJTdHJpbmcoR2V0U2xvdChkYXRlVGltZSwgSVNPX1lFQVIpKTtcbiAgICBjb25zdCBtb250aCA9IElTT0RhdGVUaW1lUGFydFN0cmluZyhHZXRTbG90KGRhdGVUaW1lLCBJU09fTU9OVEgpKTtcbiAgICBjb25zdCBkYXkgPSBJU09EYXRlVGltZVBhcnRTdHJpbmcoR2V0U2xvdChkYXRlVGltZSwgSVNPX0RBWSkpO1xuICAgIGNvbnN0IGhvdXIgPSBJU09EYXRlVGltZVBhcnRTdHJpbmcoR2V0U2xvdChkYXRlVGltZSwgSVNPX0hPVVIpKTtcbiAgICBjb25zdCBtaW51dGUgPSBJU09EYXRlVGltZVBhcnRTdHJpbmcoR2V0U2xvdChkYXRlVGltZSwgSVNPX01JTlVURSkpO1xuICAgIGNvbnN0IHNlY29uZHMgPSBGb3JtYXRTZWNvbmRzU3RyaW5nUGFydChHZXRTbG90KGRhdGVUaW1lLCBJU09fU0VDT05EKSwgR2V0U2xvdChkYXRlVGltZSwgSVNPX01JTExJU0VDT05EKSwgR2V0U2xvdChkYXRlVGltZSwgSVNPX01JQ1JPU0VDT05EKSwgR2V0U2xvdChkYXRlVGltZSwgSVNPX05BTk9TRUNPTkQpLCBwcmVjaXNpb24pO1xuICAgIGxldCByZXN1bHQgPSBgJHt5ZWFyfS0ke21vbnRofS0ke2RheX1UJHtob3VyfToke21pbnV0ZX0ke3NlY29uZHN9YDtcbiAgICBpZiAoc2hvd09mZnNldCAhPT0gJ25ldmVyJykge1xuICAgICAgICBjb25zdCBvZmZzZXROcyA9IEdldE9mZnNldE5hbm9zZWNvbmRzRm9yKHR6LCBpbnN0YW50KTtcbiAgICAgICAgcmVzdWx0ICs9IEZvcm1hdElTT1RpbWVab25lT2Zmc2V0U3RyaW5nKG9mZnNldE5zKTtcbiAgICB9XG4gICAgaWYgKHNob3dUaW1lWm9uZSAhPT0gJ25ldmVyJylcbiAgICAgICAgcmVzdWx0ICs9IGBbJHt0en1dYDtcbiAgICBjb25zdCBjYWxlbmRhcklEID0gVG9TdHJpbmcoR2V0U2xvdCh6ZHQsIENBTEVOREFSKSk7XG4gICAgcmVzdWx0ICs9IEZvcm1hdENhbGVuZGFyQW5ub3RhdGlvbihjYWxlbmRhcklELCBzaG93Q2FsZW5kYXIpO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBUZXN0VGltZVpvbmVPZmZzZXRTdHJpbmcoc3RyaW5nKSB7XG4gICAgcmV0dXJuIE9GRlNFVC50ZXN0KFN0cmluZ0N0b3Ioc3RyaW5nKSk7XG59XG5mdW5jdGlvbiBQYXJzZVRpbWVab25lT2Zmc2V0U3RyaW5nKHN0cmluZykge1xuICAgIGNvbnN0IG1hdGNoID0gT0ZGU0VULmV4ZWMoU3RyaW5nQ3RvcihzdHJpbmcpKTtcbiAgICBpZiAoIW1hdGNoKSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBpbnZhbGlkIHRpbWUgem9uZSBvZmZzZXQ6ICR7c3RyaW5nfWApO1xuICAgIH1cbiAgICBjb25zdCBzaWduID0gbWF0Y2hbMV0gPT09ICctJyB8fCBtYXRjaFsxXSA9PT0gJ1xcdTIyMTInID8gLTEgOiArMTtcbiAgICBjb25zdCBob3VycyA9ICttYXRjaFsyXTtcbiAgICBjb25zdCBtaW51dGVzID0gKyhtYXRjaFszXSB8fCAwKTtcbiAgICBjb25zdCBzZWNvbmRzID0gKyhtYXRjaFs0XSB8fCAwKTtcbiAgICBjb25zdCBuYW5vc2Vjb25kcyA9ICsoKG1hdGNoWzVdIHx8IDApICsgJzAwMDAwMDAwMCcpLnNsaWNlKDAsIDkpO1xuICAgIHJldHVybiBzaWduICogKCgoaG91cnMgKiA2MCArIG1pbnV0ZXMpICogNjAgKyBzZWNvbmRzKSAqIDFlOSArIG5hbm9zZWNvbmRzKTtcbn1cbmZ1bmN0aW9uIEdldENhbm9uaWNhbFRpbWVab25lSWRlbnRpZmllcih0aW1lWm9uZUlkZW50aWZpZXIpIHtcbiAgICBpZiAoVGVzdFRpbWVab25lT2Zmc2V0U3RyaW5nKHRpbWVab25lSWRlbnRpZmllcikpIHtcbiAgICAgICAgY29uc3Qgb2Zmc2V0TnMgPSBQYXJzZVRpbWVab25lT2Zmc2V0U3RyaW5nKHRpbWVab25lSWRlbnRpZmllcik7XG4gICAgICAgIHJldHVybiBGb3JtYXRUaW1lWm9uZU9mZnNldFN0cmluZyhvZmZzZXROcyk7XG4gICAgfVxuICAgIGNvbnN0IGZvcm1hdHRlciA9IGdldEludGxEYXRlVGltZUZvcm1hdEVuVXNGb3JUaW1lWm9uZShTdHJpbmdDdG9yKHRpbWVab25lSWRlbnRpZmllcikpO1xuICAgIHJldHVybiBmb3JtYXR0ZXIucmVzb2x2ZWRPcHRpb25zKCkudGltZVpvbmU7XG59XG5mdW5jdGlvbiBHZXRJQU5BVGltZVpvbmVPZmZzZXROYW5vc2Vjb25kcyhlcG9jaE5hbm9zZWNvbmRzLCBpZCkge1xuICAgIGNvbnN0IHsgeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kLCBtaWNyb3NlY29uZCwgbmFub3NlY29uZCB9ID0gR2V0SUFOQVRpbWVab25lRGF0ZVRpbWVQYXJ0cyhlcG9jaE5hbm9zZWNvbmRzLCBpZCk7XG4gICAgY29uc3QgdXRjID0gR2V0RXBvY2hGcm9tSVNPUGFydHMoeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kLCBtaWNyb3NlY29uZCwgbmFub3NlY29uZCk7XG4gICAgaWYgKHV0YyA9PT0gbnVsbClcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0RhdGUgb3V0c2lkZSBvZiBzdXBwb3J0ZWQgcmFuZ2UnKTtcbiAgICByZXR1cm4gSlNCSS50b051bWJlcihKU0JJLnN1YnRyYWN0KHV0YywgZXBvY2hOYW5vc2Vjb25kcykpO1xufVxuZnVuY3Rpb24gRm9ybWF0VGltZVpvbmVPZmZzZXRTdHJpbmcob2Zmc2V0TmFub3NlY29uZHNQYXJhbSkge1xuICAgIGNvbnN0IHNpZ24gPSBvZmZzZXROYW5vc2Vjb25kc1BhcmFtIDwgMCA/ICctJyA6ICcrJztcbiAgICBjb25zdCBvZmZzZXROYW5vc2Vjb25kcyA9IE1hdGhBYnMob2Zmc2V0TmFub3NlY29uZHNQYXJhbSk7XG4gICAgY29uc3QgbmFub3NlY29uZHMgPSBvZmZzZXROYW5vc2Vjb25kcyAlIDFlOTtcbiAgICBjb25zdCBzZWNvbmRzID0gTWF0aEZsb29yKG9mZnNldE5hbm9zZWNvbmRzIC8gMWU5KSAlIDYwO1xuICAgIGNvbnN0IG1pbnV0ZXMgPSBNYXRoRmxvb3Iob2Zmc2V0TmFub3NlY29uZHMgLyA2MGU5KSAlIDYwO1xuICAgIGNvbnN0IGhvdXJzID0gTWF0aEZsb29yKG9mZnNldE5hbm9zZWNvbmRzIC8gMzYwMGU5KTtcbiAgICBjb25zdCBob3VyU3RyaW5nID0gSVNPRGF0ZVRpbWVQYXJ0U3RyaW5nKGhvdXJzKTtcbiAgICBjb25zdCBtaW51dGVTdHJpbmcgPSBJU09EYXRlVGltZVBhcnRTdHJpbmcobWludXRlcyk7XG4gICAgY29uc3Qgc2Vjb25kU3RyaW5nID0gSVNPRGF0ZVRpbWVQYXJ0U3RyaW5nKHNlY29uZHMpO1xuICAgIGxldCBwb3N0ID0gJyc7XG4gICAgaWYgKG5hbm9zZWNvbmRzKSB7XG4gICAgICAgIGxldCBmcmFjdGlvbiA9IGAke25hbm9zZWNvbmRzfWAucGFkU3RhcnQoOSwgJzAnKTtcbiAgICAgICAgd2hpbGUgKGZyYWN0aW9uW2ZyYWN0aW9uLmxlbmd0aCAtIDFdID09PSAnMCcpXG4gICAgICAgICAgICBmcmFjdGlvbiA9IGZyYWN0aW9uLnNsaWNlKDAsIC0xKTtcbiAgICAgICAgcG9zdCA9IGA6JHtzZWNvbmRTdHJpbmd9LiR7ZnJhY3Rpb259YDtcbiAgICB9XG4gICAgZWxzZSBpZiAoc2Vjb25kcykge1xuICAgICAgICBwb3N0ID0gYDoke3NlY29uZFN0cmluZ31gO1xuICAgIH1cbiAgICByZXR1cm4gYCR7c2lnbn0ke2hvdXJTdHJpbmd9OiR7bWludXRlU3RyaW5nfSR7cG9zdH1gO1xufVxuZnVuY3Rpb24gRm9ybWF0SVNPVGltZVpvbmVPZmZzZXRTdHJpbmcob2Zmc2V0TmFub3NlY29uZHNQYXJhbSkge1xuICAgIGxldCBvZmZzZXROYW5vc2Vjb25kcyA9IEpTQkkudG9OdW1iZXIoUm91bmROdW1iZXJUb0luY3JlbWVudChKU0JJLkJpZ0ludChvZmZzZXROYW5vc2Vjb25kc1BhcmFtKSwgNjBlOSwgJ2hhbGZFeHBhbmQnKSk7XG4gICAgY29uc3Qgc2lnbiA9IG9mZnNldE5hbm9zZWNvbmRzIDwgMCA/ICctJyA6ICcrJztcbiAgICBvZmZzZXROYW5vc2Vjb25kcyA9IE1hdGhBYnMob2Zmc2V0TmFub3NlY29uZHMpO1xuICAgIGNvbnN0IG1pbnV0ZXMgPSAob2Zmc2V0TmFub3NlY29uZHMgLyA2MGU5KSAlIDYwO1xuICAgIGNvbnN0IGhvdXJzID0gTWF0aEZsb29yKG9mZnNldE5hbm9zZWNvbmRzIC8gMzYwMGU5KTtcbiAgICBjb25zdCBob3VyU3RyaW5nID0gSVNPRGF0ZVRpbWVQYXJ0U3RyaW5nKGhvdXJzKTtcbiAgICBjb25zdCBtaW51dGVTdHJpbmcgPSBJU09EYXRlVGltZVBhcnRTdHJpbmcobWludXRlcyk7XG4gICAgcmV0dXJuIGAke3NpZ259JHtob3VyU3RyaW5nfToke21pbnV0ZVN0cmluZ31gO1xufVxuZnVuY3Rpb24gR2V0RXBvY2hGcm9tSVNPUGFydHMoeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kLCBtaWNyb3NlY29uZCwgbmFub3NlY29uZCkge1xuICAgIC8vIE5vdGU6IERhdGUuVVRDKCkgaW50ZXJwcmV0cyBvbmUgYW5kIHR3by1kaWdpdCB5ZWFycyBhcyBiZWluZyBpbiB0aGVcbiAgICAvLyAyMHRoIGNlbnR1cnksIHNvIGRvbid0IHVzZSBpdFxuICAgIGNvbnN0IGxlZ2FjeURhdGUgPSBuZXcgRGF0ZSgpO1xuICAgIGxlZ2FjeURhdGUuc2V0VVRDSG91cnMoaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kKTtcbiAgICBsZWdhY3lEYXRlLnNldFVUQ0Z1bGxZZWFyKHllYXIsIG1vbnRoIC0gMSwgZGF5KTtcbiAgICBjb25zdCBtcyA9IGxlZ2FjeURhdGUuZ2V0VGltZSgpO1xuICAgIGlmIChOdW1iZXJJc05hTihtcykpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGxldCBucyA9IEpTQkkubXVsdGlwbHkoSlNCSS5CaWdJbnQobXMpLCBNSUxMSU9OKTtcbiAgICBucyA9IEpTQkkuYWRkKG5zLCBKU0JJLm11bHRpcGx5KEpTQkkuQmlnSW50KG1pY3Jvc2Vjb25kKSwgVEhPVVNBTkQpKTtcbiAgICBucyA9IEpTQkkuYWRkKG5zLCBKU0JJLkJpZ0ludChuYW5vc2Vjb25kKSk7XG4gICAgaWYgKEpTQkkubGVzc1RoYW4obnMsIE5TX01JTikgfHwgSlNCSS5ncmVhdGVyVGhhbihucywgTlNfTUFYKSlcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIG5zO1xufVxuZnVuY3Rpb24gR2V0SVNPUGFydHNGcm9tRXBvY2goZXBvY2hOYW5vc2Vjb25kcykge1xuICAgIGNvbnN0IHsgcXVvdGllbnQsIHJlbWFpbmRlciB9ID0gZGl2bW9kKGVwb2NoTmFub3NlY29uZHMsIE1JTExJT04pO1xuICAgIGxldCBlcG9jaE1pbGxpc2Vjb25kcyA9IEpTQkkudG9OdW1iZXIocXVvdGllbnQpO1xuICAgIGxldCBuYW5vcyA9IEpTQkkudG9OdW1iZXIocmVtYWluZGVyKTtcbiAgICBpZiAobmFub3MgPCAwKSB7XG4gICAgICAgIG5hbm9zICs9IDFlNjtcbiAgICAgICAgZXBvY2hNaWxsaXNlY29uZHMgLT0gMTtcbiAgICB9XG4gICAgY29uc3QgbWljcm9zZWNvbmQgPSBNYXRoRmxvb3IobmFub3MgLyAxZTMpICUgMWUzO1xuICAgIGNvbnN0IG5hbm9zZWNvbmQgPSBuYW5vcyAlIDFlMztcbiAgICBjb25zdCBpdGVtID0gbmV3IERhdGUoZXBvY2hNaWxsaXNlY29uZHMpO1xuICAgIGNvbnN0IHllYXIgPSBpdGVtLmdldFVUQ0Z1bGxZZWFyKCk7XG4gICAgY29uc3QgbW9udGggPSBpdGVtLmdldFVUQ01vbnRoKCkgKyAxO1xuICAgIGNvbnN0IGRheSA9IGl0ZW0uZ2V0VVRDRGF0ZSgpO1xuICAgIGNvbnN0IGhvdXIgPSBpdGVtLmdldFVUQ0hvdXJzKCk7XG4gICAgY29uc3QgbWludXRlID0gaXRlbS5nZXRVVENNaW51dGVzKCk7XG4gICAgY29uc3Qgc2Vjb25kID0gaXRlbS5nZXRVVENTZWNvbmRzKCk7XG4gICAgY29uc3QgbWlsbGlzZWNvbmQgPSBpdGVtLmdldFVUQ01pbGxpc2Vjb25kcygpO1xuICAgIHJldHVybiB7IGVwb2NoTWlsbGlzZWNvbmRzLCB5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQsIG1pY3Jvc2Vjb25kLCBuYW5vc2Vjb25kIH07XG59XG4vLyB0cy1wcnVuZS1pZ25vcmUtbmV4dCBUT0RPOiByZW1vdmUgdGhpcyBhZnRlciB0ZXN0cyBhcmUgY29udmVydGVkIHRvIFRTXG5mdW5jdGlvbiBHZXRJQU5BVGltZVpvbmVEYXRlVGltZVBhcnRzKGVwb2NoTmFub3NlY29uZHMsIGlkKSB7XG4gICAgY29uc3QgeyBlcG9jaE1pbGxpc2Vjb25kcywgbWlsbGlzZWNvbmQsIG1pY3Jvc2Vjb25kLCBuYW5vc2Vjb25kIH0gPSBHZXRJU09QYXJ0c0Zyb21FcG9jaChlcG9jaE5hbm9zZWNvbmRzKTtcbiAgICBjb25zdCB7IHllYXIsIG1vbnRoLCBkYXksIGhvdXIsIG1pbnV0ZSwgc2Vjb25kIH0gPSBHZXRGb3JtYXR0ZXJQYXJ0cyhpZCwgZXBvY2hNaWxsaXNlY29uZHMpO1xuICAgIHJldHVybiBCYWxhbmNlSVNPRGF0ZVRpbWUoeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kLCBtaWNyb3NlY29uZCwgbmFub3NlY29uZCk7XG59XG5mdW5jdGlvbiBtYXhKU0JJKG9uZSwgdHdvKSB7XG4gICAgcmV0dXJuIEpTQkkubGVzc1RoYW4ob25lLCB0d28pID8gdHdvIDogb25lO1xufVxuLyoqXG4gKiBPdXIgYmVzdCBndWVzcyBhdCBob3cgZmFyIGluIGFkdmFuY2UgbmV3IHJ1bGVzIHdpbGwgYmUgcHV0IGludG8gdGhlIFRaREIgZm9yXG4gKiBmdXR1cmUgb2Zmc2V0IHRyYW5zaXRpb25zLiBXZSdsbCBwaWNrIDEwIHllYXJzIGJ1dCBjYW4gYWx3YXlzIHJldmlzZSBpdCBpZlxuICogd2UgZmluZCB0aGF0IGNvdW50cmllcyBhcmUgYmVpbmcgdW51c3VhbGx5IHByb2FjdGl2ZSBpbiB0aGVpciBhbm5vdW5jaW5nXG4gKiBvZiBvZmZzZXQgY2hhbmdlcy5cbiAqL1xuZnVuY3Rpb24gYWZ0ZXJMYXRlc3RQb3NzaWJsZVR6ZGJSdWxlQ2hhbmdlKCkge1xuICAgIHJldHVybiBKU0JJLmFkZChTeXN0ZW1VVENFcG9jaE5hbm9TZWNvbmRzKCksIEFCT1VUX1RFTl9ZRUFSU19OQU5PUyk7XG59XG5mdW5jdGlvbiBHZXRJQU5BVGltZVpvbmVOZXh0VHJhbnNpdGlvbihlcG9jaE5hbm9zZWNvbmRzLCBpZCkge1xuICAgIC8vIERlY2lkZSBob3cgZmFyIGluIHRoZSBmdXR1cmUgYWZ0ZXIgYGVwb2NoTmFub3NlY29uZHNgIHdlJ2xsIGxvb2sgZm9yIGFuXG4gICAgLy8gb2Zmc2V0IGNoYW5nZS4gVGhlcmUgYXJlIHR3byBjYXNlczpcbiAgICAvLyAxLiBJZiBpdCdzIGEgcGFzdCBkYXRlIChvciBhIGRhdGUgaW4gdGhlIG5lYXIgZnV0dXJlKSB0aGVuIGl0J3MgcG9zc2libGVcbiAgICAvLyAgICB0aGF0IHRoZSB0aW1lIHpvbmUgbWF5IGhhdmUgbmV3bHkgYWRkZWQgRFNUIGluIHRoZSBuZXh0IGZldyB5ZWFycy4gU29cbiAgICAvLyAgICB3ZSdsbCBoYXZlIHRvIGxvb2sgZnJvbSB0aGUgcHJvdmlkZWQgdGltZSB1bnRpbCBhIGZldyB5ZWFycyBhZnRlciB0aGVcbiAgICAvLyAgICBjdXJyZW50IHN5c3RlbSB0aW1lLiAoQ2hhbmdlcyB0byBEU1QgcG9saWN5IGFyZSB1c3VhbGx5IGFubm91bmNlZCBhIGZld1xuICAgIC8vICAgIHllYXJzIGluIHRoZSBmdXR1cmUuKSBOb3RlIHRoYXQgdGhlIGZpcnN0IERTVCBhbnl3aGVyZSBzdGFydGVkIGluIDE4NDcsXG4gICAgLy8gICAgc28gd2UnbGwgc3RhcnQgY2hlY2tzIGluIDE4NDcgaW5zdGVhZCBvZiB3YXN0aW5nIGN5Y2xlcyBvbiB5ZWFycyB3aGVyZVxuICAgIC8vICAgIHRoZXJlIHdpbGwgbmV2ZXIgYmUgdHJhbnNpdGlvbnMuXG4gICAgLy8gMi4gSWYgaXQncyBhIGZ1dHVyZSBkYXRlIGJleW9uZCB0aGUgbmV4dCBmZXcgeWVhcnMsIHRoZW4gd2UnbGwganVzdCBhc3N1bWVcbiAgICAvLyAgICB0aGF0IHRoZSBsYXRlc3QgRFNUIHBvbGljeSBpbiBUWkRCIHdpbGwgc3RpbGwgYmUgaW4gZWZmZWN0LiAgSW4gdGhpc1xuICAgIC8vICAgIGNhc2UsIHdlIG9ubHkgbmVlZCB0byBsb29rIG9uZSB5ZWFyIGluIHRoZSBmdXR1cmUgdG8gc2VlIGlmIHRoZXJlIGFyZVxuICAgIC8vICAgIGFueSBEU1QgdHJhbnNpdGlvbnMuICBXZSBhY3R1YWxseSBvbmx5IG5lZWQgdG8gbG9vayA5LTEwIG1vbnRocyBiZWNhdXNlXG4gICAgLy8gICAgRFNUIGhhcyB0d28gdHJhbnNpdGlvbnMgcGVyIHllYXIsIGJ1dCB3ZSdsbCB1c2UgYSB5ZWFyIGp1c3QgdG8gYmUgc2FmZS5cbiAgICBjb25zdCBvbmVZZWFyTGF0ZXIgPSBKU0JJLmFkZChlcG9jaE5hbm9zZWNvbmRzLCBBQk9VVF9PTkVfWUVBUl9OQU5PUyk7XG4gICAgY29uc3QgdXBwZXJjYXAgPSBtYXhKU0JJKGFmdGVyTGF0ZXN0UG9zc2libGVUemRiUnVsZUNoYW5nZSgpLCBvbmVZZWFyTGF0ZXIpO1xuICAgIC8vIFRoZSBmaXJzdCB0cmFuc2l0aW9uIChpbiBhbnkgdGltZXpvbmUpIHJlY29yZGVkIGluIHRoZSBUWkRCIHdhcyBpbiAxODQ3LCBzb1xuICAgIC8vIHN0YXJ0IHRoZXJlIGlmIGFuIGVhcmxpZXIgZGF0ZSBpcyBzdXBwbGllZC5cbiAgICBsZXQgbGVmdE5hbm9zID0gbWF4SlNCSShCRUZPUkVfRklSU1RfT0ZGU0VUX1RSQU5TSVRJT04sIGVwb2NoTmFub3NlY29uZHMpO1xuICAgIGNvbnN0IGxlZnRPZmZzZXROcyA9IEdldElBTkFUaW1lWm9uZU9mZnNldE5hbm9zZWNvbmRzKGxlZnROYW5vcywgaWQpO1xuICAgIGxldCByaWdodE5hbm9zID0gbGVmdE5hbm9zO1xuICAgIGxldCByaWdodE9mZnNldE5zID0gbGVmdE9mZnNldE5zO1xuICAgIHdoaWxlIChsZWZ0T2Zmc2V0TnMgPT09IHJpZ2h0T2Zmc2V0TnMgJiYgSlNCSS5sZXNzVGhhbihKU0JJLkJpZ0ludChsZWZ0TmFub3MpLCB1cHBlcmNhcCkpIHtcbiAgICAgICAgcmlnaHROYW5vcyA9IEpTQkkuYWRkKGxlZnROYW5vcywgVFdPX1dFRUtTX05BTk9TKTtcbiAgICAgICAgcmlnaHRPZmZzZXROcyA9IEdldElBTkFUaW1lWm9uZU9mZnNldE5hbm9zZWNvbmRzKHJpZ2h0TmFub3MsIGlkKTtcbiAgICAgICAgaWYgKGxlZnRPZmZzZXROcyA9PT0gcmlnaHRPZmZzZXROcykge1xuICAgICAgICAgICAgbGVmdE5hbm9zID0gcmlnaHROYW5vcztcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAobGVmdE9mZnNldE5zID09PSByaWdodE9mZnNldE5zKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBjb25zdCByZXN1bHQgPSBiaXNlY3QoKGVwb2NoTnMpID0+IEdldElBTkFUaW1lWm9uZU9mZnNldE5hbm9zZWNvbmRzKGVwb2NoTnMsIGlkKSwgbGVmdE5hbm9zLCByaWdodE5hbm9zLCBsZWZ0T2Zmc2V0TnMsIHJpZ2h0T2Zmc2V0TnMpO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBHZXRJQU5BVGltZVpvbmVQcmV2aW91c1RyYW5zaXRpb24oZXBvY2hOYW5vc2Vjb25kcywgaWQpIHtcbiAgICAvLyBJZiBhIHRpbWUgem9uZSB1c2VzIERTVCAoYXQgdGhlIHRpbWUgb2YgYGVwb2NoTmFub3NlY29uZHNgKSwgdGhlbiB3ZSBvbmx5XG4gICAgLy8gaGF2ZSB0byBsb29rIGJhY2sgb25lIHllYXIgdG8gZmluZCBhIHRyYW5zaXRpb24uIEJ1dCBpZiBpdCBkb2Vzbid0IHVzZSBEU1QsXG4gICAgLy8gdGhlbiB3ZSBuZWVkIHRvIGxvb2sgYWxsIHRoZSB3YXkgYmFjayB0byAxODQ3ICh0aGUgZWFybGllc3QgcnVsZSBpbiB0aGVcbiAgICAvLyBUWkRCKSB0byBzZWUgaWYgaXQgaGFkIG90aGVyIG9mZnNldCB0cmFuc2l0aW9ucyBpbiB0aGUgcGFzdC4gTG9vcGluZyBiYWNrXG4gICAgLy8gZnJvbSBhIGZhci1mdXR1cmUgZGF0ZSB0byAxODQ3IGlzIHZlcnkgc2xvdyAobWludXRlcyBvZiAxMDAlIENQVSEpLCBhbmQgaXNcbiAgICAvLyBhbHNvIHVubmVjZXNzYXJ5IGJlY2F1c2UgRFNUIHJ1bGVzIGFyZW4ndCBwdXQgaW50byB0aGUgVFpEQiBtb3JlIHRoYW4gYSBmZXdcbiAgICAvLyB5ZWFycyBpbiB0aGUgZnV0dXJlIGJlY2F1c2UgdGhlIHBvbGl0aWNhbCBjaGFuZ2VzIGluIHRpbWUgem9uZXMgaGFwcGVuIHdpdGhcbiAgICAvLyBvbmx5IGEgZmV3IHllYXJzJyB3YXJuaW5nLiBUaGVyZWZvcmUsIGlmIGEgZmFyLWZ1dHVyZSBkYXRlIGlzIHByb3ZpZGVkLFxuICAgIC8vIHRoZW4gd2UnbGwgcnVuIHRoZSBjaGVjayBpbiB0d28gcGFydHM6XG4gICAgLy8gMS4gRmlyc3QsIHdlJ2xsIGxvb2sgYmFjayBmb3IgdXAgdG8gb25lIHllYXIgdG8gc2VlIGlmIHRoZSBsYXRlc3QgVFpEQlxuICAgIC8vICAgIHJ1bGVzIGhhdmUgRFNULlxuICAgIC8vIDIuIElmIG5vdCwgdGhlbiB3ZSdsbCBcImZhc3QtcmV2ZXJzZVwiIGJhY2sgdG8gYSBmZXcgeWVhcnMgbGF0ZXIgdGhhbiB0aGVcbiAgICAvLyAgICBjdXJyZW50IHN5c3RlbSB0aW1lLCBhbmQgdGhlbiBsb29rIGJhY2sgdG8gMTg0Ny4gVGhpcyByZWR1Y2VzIHRoZVxuICAgIC8vICAgIHdvcnN0LWNhc2UgbG9vcCBmcm9tIDI3M0sgeWVhcnMgdG8gMTc1IHllYXJzLCBmb3IgYSB+MTUwMHggaW1wcm92ZW1lbnRcbiAgICAvLyAgICBpbiB3b3JzdC1jYXNlIHBlcmYuXG4gICAgY29uc3QgYWZ0ZXJMYXRlc3RSdWxlID0gYWZ0ZXJMYXRlc3RQb3NzaWJsZVR6ZGJSdWxlQ2hhbmdlKCk7XG4gICAgY29uc3QgaXNGYXJGdXR1cmUgPSBKU0JJLmdyZWF0ZXJUaGFuKGVwb2NoTmFub3NlY29uZHMsIGFmdGVyTGF0ZXN0UnVsZSk7XG4gICAgY29uc3QgbG93ZXJjYXAgPSBpc0ZhckZ1dHVyZSA/IEpTQkkuc3VidHJhY3QoZXBvY2hOYW5vc2Vjb25kcywgQUJPVVRfT05FX1lFQVJfTkFOT1MpIDogQkVGT1JFX0ZJUlNUX09GRlNFVF9UUkFOU0lUSU9OO1xuICAgIGxldCByaWdodE5hbm9zID0gSlNCSS5zdWJ0cmFjdChlcG9jaE5hbm9zZWNvbmRzLCBPTkUpO1xuICAgIGNvbnN0IHJpZ2h0T2Zmc2V0TnMgPSBHZXRJQU5BVGltZVpvbmVPZmZzZXROYW5vc2Vjb25kcyhyaWdodE5hbm9zLCBpZCk7XG4gICAgbGV0IGxlZnROYW5vcyA9IHJpZ2h0TmFub3M7XG4gICAgbGV0IGxlZnRPZmZzZXROcyA9IHJpZ2h0T2Zmc2V0TnM7XG4gICAgd2hpbGUgKHJpZ2h0T2Zmc2V0TnMgPT09IGxlZnRPZmZzZXROcyAmJiBKU0JJLmdyZWF0ZXJUaGFuKHJpZ2h0TmFub3MsIGxvd2VyY2FwKSkge1xuICAgICAgICBsZWZ0TmFub3MgPSBKU0JJLnN1YnRyYWN0KHJpZ2h0TmFub3MsIFRXT19XRUVLU19OQU5PUyk7XG4gICAgICAgIGxlZnRPZmZzZXROcyA9IEdldElBTkFUaW1lWm9uZU9mZnNldE5hbm9zZWNvbmRzKGxlZnROYW5vcywgaWQpO1xuICAgICAgICBpZiAocmlnaHRPZmZzZXROcyA9PT0gbGVmdE9mZnNldE5zKSB7XG4gICAgICAgICAgICByaWdodE5hbm9zID0gbGVmdE5hbm9zO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChyaWdodE9mZnNldE5zID09PSBsZWZ0T2Zmc2V0TnMpIHtcbiAgICAgICAgaWYgKGlzRmFyRnV0dXJlKSB7XG4gICAgICAgICAgICAvLyBUaGVyZSB3YXMgbm8gRFNUIGFmdGVyIGxvb2tpbmcgYmFjayBvbmUgeWVhciwgd2hpY2ggbWVhbnMgdGhhdCB0aGUgbW9zdFxuICAgICAgICAgICAgLy8gcmVjZW50IFRaREIgcnVsZXMgZG9uJ3QgaGF2ZSBhbnkgcmVjdXJyaW5nIHRyYW5zaXRpb25zLiBUbyBjaGVjayBmb3JcbiAgICAgICAgICAgIC8vIHRyYW5zaXRpb25zIGluIG9sZGVyIHJ1bGVzLCBiYWNrIHVwIHRvIGEgZmV3IHllYXJzIGFmdGVyIHRoZSBjdXJyZW50XG4gICAgICAgICAgICAvLyBkYXRlIGFuZCB0aGVuIGxvb2sgYWxsIHRoZSB3YXkgYmFjayB0byAxODQ3LiBOb3RlIHRoYXQgd2UgbW92ZSBiYWNrIG9uZVxuICAgICAgICAgICAgLy8gZGF5IGZyb20gdGhlIGxhdGVzdCBwb3NzaWJsZSBydWxlIHNvIHRoYXQgd2hlbiB0aGUgcmVjdXJzaW9uIHJ1bnMgaXRcbiAgICAgICAgICAgIC8vIHdvbid0IGNvbnNpZGVyIHRoZSBuZXcgdGltZSB0byBiZSBcImZhciBmdXR1cmVcIiBiZWNhdXNlIHRoZSBzeXN0ZW0gY2xvY2tcbiAgICAgICAgICAgIC8vIGhhcyBhZHZhbmNlZCBpbiB0aGUgbWVhbnRpbWUuXG4gICAgICAgICAgICBjb25zdCBuZXdUaW1lVG9DaGVjayA9IEpTQkkuc3VidHJhY3QoYWZ0ZXJMYXRlc3RSdWxlLCBEQVlfTkFOT1MpO1xuICAgICAgICAgICAgcmV0dXJuIEdldElBTkFUaW1lWm9uZVByZXZpb3VzVHJhbnNpdGlvbihuZXdUaW1lVG9DaGVjaywgaWQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSBiaXNlY3QoKGVwb2NoTnMpID0+IEdldElBTkFUaW1lWm9uZU9mZnNldE5hbm9zZWNvbmRzKGVwb2NoTnMsIGlkKSwgbGVmdE5hbm9zLCByaWdodE5hbm9zLCBsZWZ0T2Zmc2V0TnMsIHJpZ2h0T2Zmc2V0TnMpO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG4vLyB0cy1wcnVuZS1pZ25vcmUtbmV4dCBUT0RPOiByZW1vdmUgdGhpcyBhZnRlciB0ZXN0cyBhcmUgY29udmVydGVkIHRvIFRTXG5mdW5jdGlvbiBwYXJzZUZyb21FblVzRm9ybWF0KGRhdGV0aW1lKSB7XG4gICAgY29uc3QgcGFydHMgPSBkYXRldGltZS5zcGxpdCgvW15cXHddKy8pO1xuICAgIGlmIChwYXJ0cy5sZW5ndGggIT09IDcpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYGV4cGVjdGVkIDcgcGFydHMgaW4gXCIke2RhdGV0aW1lfWApO1xuICAgIH1cbiAgICBjb25zdCBtb250aCA9ICtwYXJ0c1swXTtcbiAgICBjb25zdCBkYXkgPSArcGFydHNbMV07XG4gICAgbGV0IHllYXIgPSArcGFydHNbMl07XG4gICAgY29uc3QgZXJhID0gcGFydHNbM10udG9VcHBlckNhc2UoKTtcbiAgICBpZiAoZXJhID09PSAnQicgfHwgZXJhID09PSAnQkMnKSB7XG4gICAgICAgIHllYXIgPSAteWVhciArIDE7XG4gICAgfVxuICAgIGVsc2UgaWYgKGVyYSAhPT0gJ0EnICYmIGVyYSAhPT0gJ0FEJykge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgVW5rbm93biBlcmEgJHtlcmF9IGluIFwiJHtkYXRldGltZX1gKTtcbiAgICB9XG4gICAgbGV0IGhvdXIgPSArcGFydHNbNF07XG4gICAgaWYgKGhvdXIgPT09IDI0KSB7XG4gICAgICAgIC8vIGJ1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0xMDQ1NzkxXG4gICAgICAgIGhvdXIgPSAwO1xuICAgIH1cbiAgICBjb25zdCBtaW51dGUgPSArcGFydHNbNV07XG4gICAgY29uc3Qgc2Vjb25kID0gK3BhcnRzWzZdO1xuICAgIGlmICghTnVtYmVySXNGaW5pdGUoeWVhcikgfHxcbiAgICAgICAgIU51bWJlcklzRmluaXRlKG1vbnRoKSB8fFxuICAgICAgICAhTnVtYmVySXNGaW5pdGUoZGF5KSB8fFxuICAgICAgICAhTnVtYmVySXNGaW5pdGUoaG91cikgfHxcbiAgICAgICAgIU51bWJlcklzRmluaXRlKG1pbnV0ZSkgfHxcbiAgICAgICAgIU51bWJlcklzRmluaXRlKHNlY29uZCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYEludmFsaWQgbnVtYmVyIGluIFwiJHtkYXRldGltZX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQgfTtcbn1cbi8vIHRzLXBydW5lLWlnbm9yZS1uZXh0IFRPRE86IHJlbW92ZSB0aGlzIGFmdGVyIHRlc3RzIGFyZSBjb252ZXJ0ZWQgdG8gVFNcbmZ1bmN0aW9uIEdldEZvcm1hdHRlclBhcnRzKHRpbWVab25lLCBlcG9jaE1pbGxpc2Vjb25kcykge1xuICAgIGNvbnN0IGZvcm1hdHRlciA9IGdldEludGxEYXRlVGltZUZvcm1hdEVuVXNGb3JUaW1lWm9uZSh0aW1lWm9uZSk7XG4gICAgLy8gVXNpbmcgYGZvcm1hdGAgaW5zdGVhZCBvZiBgZm9ybWF0VG9QYXJ0c2AgZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBvbGRlciBjbGllbnRzXG4gICAgY29uc3QgZGF0ZXRpbWUgPSBmb3JtYXR0ZXIuZm9ybWF0KG5ldyBEYXRlKGVwb2NoTWlsbGlzZWNvbmRzKSk7XG4gICAgcmV0dXJuIHBhcnNlRnJvbUVuVXNGb3JtYXQoZGF0ZXRpbWUpO1xufVxuZnVuY3Rpb24gR2V0SUFOQVRpbWVab25lRXBvY2hWYWx1ZShpZCwgeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kLCBtaWNyb3NlY29uZCwgbmFub3NlY29uZCkge1xuICAgIGNvbnN0IG5zID0gR2V0RXBvY2hGcm9tSVNPUGFydHMoeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kLCBtaWNyb3NlY29uZCwgbmFub3NlY29uZCk7XG4gICAgaWYgKG5zID09PSBudWxsKVxuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignRGF0ZVRpbWUgb3V0c2lkZSBvZiBzdXBwb3J0ZWQgcmFuZ2UnKTtcbiAgICBsZXQgbnNFYXJsaWVyID0gSlNCSS5zdWJ0cmFjdChucywgREFZX05BTk9TKTtcbiAgICBpZiAoSlNCSS5sZXNzVGhhbihuc0VhcmxpZXIsIE5TX01JTikpXG4gICAgICAgIG5zRWFybGllciA9IG5zO1xuICAgIGxldCBuc0xhdGVyID0gSlNCSS5hZGQobnMsIERBWV9OQU5PUyk7XG4gICAgaWYgKEpTQkkuZ3JlYXRlclRoYW4obnNMYXRlciwgTlNfTUFYKSlcbiAgICAgICAgbnNMYXRlciA9IG5zO1xuICAgIGNvbnN0IGVhcmxpZXN0ID0gR2V0SUFOQVRpbWVab25lT2Zmc2V0TmFub3NlY29uZHMobnNFYXJsaWVyLCBpZCk7XG4gICAgY29uc3QgbGF0ZXN0ID0gR2V0SUFOQVRpbWVab25lT2Zmc2V0TmFub3NlY29uZHMobnNMYXRlciwgaWQpO1xuICAgIGNvbnN0IGZvdW5kID0gZWFybGllc3QgPT09IGxhdGVzdCA/IFtlYXJsaWVzdF0gOiBbZWFybGllc3QsIGxhdGVzdF07XG4gICAgcmV0dXJuIGZvdW5kXG4gICAgICAgIC5tYXAoKG9mZnNldE5hbm9zZWNvbmRzKSA9PiB7XG4gICAgICAgIGNvbnN0IGVwb2NoTmFub3NlY29uZHMgPSBKU0JJLnN1YnRyYWN0KG5zLCBKU0JJLkJpZ0ludChvZmZzZXROYW5vc2Vjb25kcykpO1xuICAgICAgICBjb25zdCBwYXJ0cyA9IEdldElBTkFUaW1lWm9uZURhdGVUaW1lUGFydHMoZXBvY2hOYW5vc2Vjb25kcywgaWQpO1xuICAgICAgICBpZiAoeWVhciAhPT0gcGFydHMueWVhciB8fFxuICAgICAgICAgICAgbW9udGggIT09IHBhcnRzLm1vbnRoIHx8XG4gICAgICAgICAgICBkYXkgIT09IHBhcnRzLmRheSB8fFxuICAgICAgICAgICAgaG91ciAhPT0gcGFydHMuaG91ciB8fFxuICAgICAgICAgICAgbWludXRlICE9PSBwYXJ0cy5taW51dGUgfHxcbiAgICAgICAgICAgIHNlY29uZCAhPT0gcGFydHMuc2Vjb25kIHx8XG4gICAgICAgICAgICBtaWxsaXNlY29uZCAhPT0gcGFydHMubWlsbGlzZWNvbmQgfHxcbiAgICAgICAgICAgIG1pY3Jvc2Vjb25kICE9PSBwYXJ0cy5taWNyb3NlY29uZCB8fFxuICAgICAgICAgICAgbmFub3NlY29uZCAhPT0gcGFydHMubmFub3NlY29uZCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXBvY2hOYW5vc2Vjb25kcztcbiAgICB9KVxuICAgICAgICAuZmlsdGVyKCh4KSA9PiB4ICE9PSB1bmRlZmluZWQpO1xufVxuZnVuY3Rpb24gTGVhcFllYXIoeWVhcikge1xuICAgIGlmICh1bmRlZmluZWQgPT09IHllYXIpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBjb25zdCBpc0RpdjQgPSB5ZWFyICUgNCA9PT0gMDtcbiAgICBjb25zdCBpc0RpdjEwMCA9IHllYXIgJSAxMDAgPT09IDA7XG4gICAgY29uc3QgaXNEaXY0MDAgPSB5ZWFyICUgNDAwID09PSAwO1xuICAgIHJldHVybiBpc0RpdjQgJiYgKCFpc0RpdjEwMCB8fCBpc0RpdjQwMCk7XG59XG5mdW5jdGlvbiBJU09EYXlzSW5Nb250aCh5ZWFyLCBtb250aCkge1xuICAgIGNvbnN0IERvTSA9IHtcbiAgICAgICAgc3RhbmRhcmQ6IFszMSwgMjgsIDMxLCAzMCwgMzEsIDMwLCAzMSwgMzEsIDMwLCAzMSwgMzAsIDMxXSxcbiAgICAgICAgbGVhcHllYXI6IFszMSwgMjksIDMxLCAzMCwgMzEsIDMwLCAzMSwgMzEsIDMwLCAzMSwgMzAsIDMxXVxuICAgIH07XG4gICAgcmV0dXJuIERvTVtMZWFwWWVhcih5ZWFyKSA/ICdsZWFweWVhcicgOiAnc3RhbmRhcmQnXVttb250aCAtIDFdO1xufVxuZnVuY3Rpb24gRGF5T2ZXZWVrKHllYXIsIG1vbnRoLCBkYXkpIHtcbiAgICBjb25zdCBtID0gbW9udGggKyAobW9udGggPCAzID8gMTAgOiAtMik7XG4gICAgY29uc3QgWSA9IHllYXIgLSAobW9udGggPCAzID8gMSA6IDApO1xuICAgIGNvbnN0IGMgPSBNYXRoRmxvb3IoWSAvIDEwMCk7XG4gICAgY29uc3QgeSA9IFkgLSBjICogMTAwO1xuICAgIGNvbnN0IGQgPSBkYXk7XG4gICAgY29uc3QgcEQgPSBkO1xuICAgIGNvbnN0IHBNID0gTWF0aEZsb29yKDIuNiAqIG0gLSAwLjIpO1xuICAgIGNvbnN0IHBZID0geSArIE1hdGhGbG9vcih5IC8gNCk7XG4gICAgY29uc3QgcEMgPSBNYXRoRmxvb3IoYyAvIDQpIC0gMiAqIGM7XG4gICAgY29uc3QgZG93ID0gKHBEICsgcE0gKyBwWSArIHBDKSAlIDc7XG4gICAgcmV0dXJuIGRvdyArIChkb3cgPD0gMCA/IDcgOiAwKTtcbn1cbmZ1bmN0aW9uIERheU9mWWVhcih5ZWFyLCBtb250aCwgZGF5KSB7XG4gICAgbGV0IGRheXMgPSBkYXk7XG4gICAgZm9yIChsZXQgbSA9IG1vbnRoIC0gMTsgbSA+IDA7IG0tLSkge1xuICAgICAgICBkYXlzICs9IElTT0RheXNJbk1vbnRoKHllYXIsIG0pO1xuICAgIH1cbiAgICByZXR1cm4gZGF5cztcbn1cbmZ1bmN0aW9uIFdlZWtPZlllYXIoeWVhciwgbW9udGgsIGRheSkge1xuICAgIGNvbnN0IGRveSA9IERheU9mWWVhcih5ZWFyLCBtb250aCwgZGF5KTtcbiAgICBjb25zdCBkb3cgPSBEYXlPZldlZWsoeWVhciwgbW9udGgsIGRheSkgfHwgNztcbiAgICBjb25zdCBkb2ogPSBEYXlPZldlZWsoeWVhciwgMSwgMSk7XG4gICAgY29uc3Qgd2VlayA9IE1hdGhGbG9vcigoZG95IC0gZG93ICsgMTApIC8gNyk7XG4gICAgaWYgKHdlZWsgPCAxKSB7XG4gICAgICAgIGlmIChkb2ogPT09IDUgfHwgKGRvaiA9PT0gNiAmJiBMZWFwWWVhcih5ZWFyIC0gMSkpKSB7XG4gICAgICAgICAgICByZXR1cm4gNTM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gNTI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHdlZWsgPT09IDUzKSB7XG4gICAgICAgIGlmICgoTGVhcFllYXIoeWVhcikgPyAzNjYgOiAzNjUpIC0gZG95IDwgNCAtIGRvdykge1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHdlZWs7XG59XG5mdW5jdGlvbiBEdXJhdGlvblNpZ24oeSwgbW9uLCB3LCBkLCBoLCBtaW4sIHMsIG1zLCDCtXMsIG5zKSB7XG4gICAgZm9yIChjb25zdCBwcm9wIG9mIFt5LCBtb24sIHcsIGQsIGgsIG1pbiwgcywgbXMsIMK1cywgbnNdKSB7XG4gICAgICAgIGlmIChwcm9wICE9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIHByb3AgPCAwID8gLTEgOiAxO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbn1cbmZ1bmN0aW9uIEJhbGFuY2VJU09ZZWFyTW9udGgoeWVhclBhcmFtLCBtb250aFBhcmFtKSB7XG4gICAgbGV0IHllYXIgPSB5ZWFyUGFyYW07XG4gICAgbGV0IG1vbnRoID0gbW9udGhQYXJhbTtcbiAgICBpZiAoIU51bWJlcklzRmluaXRlKHllYXIpIHx8ICFOdW1iZXJJc0Zpbml0ZShtb250aCkpXG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdpbmZpbml0eSBpcyBvdXQgb2YgcmFuZ2UnKTtcbiAgICBtb250aCAtPSAxO1xuICAgIHllYXIgKz0gTWF0aEZsb29yKG1vbnRoIC8gMTIpO1xuICAgIG1vbnRoICU9IDEyO1xuICAgIGlmIChtb250aCA8IDApXG4gICAgICAgIG1vbnRoICs9IDEyO1xuICAgIG1vbnRoICs9IDE7XG4gICAgcmV0dXJuIHsgeWVhciwgbW9udGggfTtcbn1cbmZ1bmN0aW9uIEJhbGFuY2VJU09EYXRlKHllYXJQYXJhbSwgbW9udGhQYXJhbSwgZGF5UGFyYW0pIHtcbiAgICBsZXQgeWVhciA9IHllYXJQYXJhbTtcbiAgICBsZXQgbW9udGggPSBtb250aFBhcmFtO1xuICAgIGxldCBkYXkgPSBkYXlQYXJhbTtcbiAgICBpZiAoIU51bWJlcklzRmluaXRlKGRheSkpXG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdpbmZpbml0eSBpcyBvdXQgb2YgcmFuZ2UnKTtcbiAgICAoeyB5ZWFyLCBtb250aCB9ID0gQmFsYW5jZUlTT1llYXJNb250aCh5ZWFyLCBtb250aCkpO1xuICAgIGxldCBkYXlzSW5ZZWFyID0gMDtcbiAgICBsZXQgdGVzdFllYXIgPSBtb250aCA+IDIgPyB5ZWFyIDogeWVhciAtIDE7XG4gICAgd2hpbGUgKCgoZGF5c0luWWVhciA9IExlYXBZZWFyKHRlc3RZZWFyKSA/IDM2NiA6IDM2NSksIGRheSA8IC1kYXlzSW5ZZWFyKSkge1xuICAgICAgICB5ZWFyIC09IDE7XG4gICAgICAgIHRlc3RZZWFyIC09IDE7XG4gICAgICAgIGRheSArPSBkYXlzSW5ZZWFyO1xuICAgIH1cbiAgICB0ZXN0WWVhciArPSAxO1xuICAgIHdoaWxlICgoKGRheXNJblllYXIgPSBMZWFwWWVhcih0ZXN0WWVhcikgPyAzNjYgOiAzNjUpLCBkYXkgPiBkYXlzSW5ZZWFyKSkge1xuICAgICAgICB5ZWFyICs9IDE7XG4gICAgICAgIHRlc3RZZWFyICs9IDE7XG4gICAgICAgIGRheSAtPSBkYXlzSW5ZZWFyO1xuICAgIH1cbiAgICB3aGlsZSAoZGF5IDwgMSkge1xuICAgICAgICAoeyB5ZWFyLCBtb250aCB9ID0gQmFsYW5jZUlTT1llYXJNb250aCh5ZWFyLCBtb250aCAtIDEpKTtcbiAgICAgICAgZGF5ICs9IElTT0RheXNJbk1vbnRoKHllYXIsIG1vbnRoKTtcbiAgICB9XG4gICAgd2hpbGUgKGRheSA+IElTT0RheXNJbk1vbnRoKHllYXIsIG1vbnRoKSkge1xuICAgICAgICBkYXkgLT0gSVNPRGF5c0luTW9udGgoeWVhciwgbW9udGgpO1xuICAgICAgICAoeyB5ZWFyLCBtb250aCB9ID0gQmFsYW5jZUlTT1llYXJNb250aCh5ZWFyLCBtb250aCArIDEpKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgeWVhciwgbW9udGgsIGRheSB9O1xufVxuZnVuY3Rpb24gQmFsYW5jZUlTT0RhdGVUaW1lKHllYXJQYXJhbSwgbW9udGhQYXJhbSwgZGF5UGFyYW0sIGhvdXJQYXJhbSwgbWludXRlUGFyYW0sIHNlY29uZFBhcmFtLCBtaWxsaXNlY29uZFBhcmFtLCBtaWNyb3NlY29uZFBhcmFtLCBuYW5vc2Vjb25kUGFyYW0pIHtcbiAgICBjb25zdCB7IGRlbHRhRGF5cywgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kLCBtaWNyb3NlY29uZCwgbmFub3NlY29uZCB9ID0gQmFsYW5jZVRpbWUoaG91clBhcmFtLCBtaW51dGVQYXJhbSwgc2Vjb25kUGFyYW0sIG1pbGxpc2Vjb25kUGFyYW0sIG1pY3Jvc2Vjb25kUGFyYW0sIG5hbm9zZWNvbmRQYXJhbSk7XG4gICAgY29uc3QgeyB5ZWFyLCBtb250aCwgZGF5IH0gPSBCYWxhbmNlSVNPRGF0ZSh5ZWFyUGFyYW0sIG1vbnRoUGFyYW0sIGRheVBhcmFtICsgZGVsdGFEYXlzKTtcbiAgICByZXR1cm4geyB5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQsIG1pY3Jvc2Vjb25kLCBuYW5vc2Vjb25kIH07XG59XG5mdW5jdGlvbiBCYWxhbmNlVGltZShob3VyUGFyYW0sIG1pbnV0ZVBhcmFtLCBzZWNvbmRQYXJhbSwgbWlsbGlzZWNvbmRQYXJhbSwgbWljcm9zZWNvbmRQYXJhbSwgbmFub3NlY29uZFBhcmFtKSB7XG4gICAgbGV0IGhvdXIgPSBob3VyUGFyYW07XG4gICAgbGV0IG1pbnV0ZSA9IG1pbnV0ZVBhcmFtO1xuICAgIGxldCBzZWNvbmQgPSBzZWNvbmRQYXJhbTtcbiAgICBsZXQgbWlsbGlzZWNvbmQgPSBtaWxsaXNlY29uZFBhcmFtO1xuICAgIGxldCBtaWNyb3NlY29uZCA9IG1pY3Jvc2Vjb25kUGFyYW07XG4gICAgbGV0IG5hbm9zZWNvbmQgPSBuYW5vc2Vjb25kUGFyYW07XG4gICAgaWYgKCFOdW1iZXJJc0Zpbml0ZShob3VyKSB8fFxuICAgICAgICAhTnVtYmVySXNGaW5pdGUobWludXRlKSB8fFxuICAgICAgICAhTnVtYmVySXNGaW5pdGUoc2Vjb25kKSB8fFxuICAgICAgICAhTnVtYmVySXNGaW5pdGUobWlsbGlzZWNvbmQpIHx8XG4gICAgICAgICFOdW1iZXJJc0Zpbml0ZShtaWNyb3NlY29uZCkgfHxcbiAgICAgICAgIU51bWJlcklzRmluaXRlKG5hbm9zZWNvbmQpKSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdpbmZpbml0eSBpcyBvdXQgb2YgcmFuZ2UnKTtcbiAgICB9XG4gICAgbWljcm9zZWNvbmQgKz0gTWF0aEZsb29yKG5hbm9zZWNvbmQgLyAxMDAwKTtcbiAgICBuYW5vc2Vjb25kID0gTm9uTmVnYXRpdmVNb2R1bG8obmFub3NlY29uZCwgMTAwMCk7XG4gICAgbWlsbGlzZWNvbmQgKz0gTWF0aEZsb29yKG1pY3Jvc2Vjb25kIC8gMTAwMCk7XG4gICAgbWljcm9zZWNvbmQgPSBOb25OZWdhdGl2ZU1vZHVsbyhtaWNyb3NlY29uZCwgMTAwMCk7XG4gICAgc2Vjb25kICs9IE1hdGhGbG9vcihtaWxsaXNlY29uZCAvIDEwMDApO1xuICAgIG1pbGxpc2Vjb25kID0gTm9uTmVnYXRpdmVNb2R1bG8obWlsbGlzZWNvbmQsIDEwMDApO1xuICAgIG1pbnV0ZSArPSBNYXRoRmxvb3Ioc2Vjb25kIC8gNjApO1xuICAgIHNlY29uZCA9IE5vbk5lZ2F0aXZlTW9kdWxvKHNlY29uZCwgNjApO1xuICAgIGhvdXIgKz0gTWF0aEZsb29yKG1pbnV0ZSAvIDYwKTtcbiAgICBtaW51dGUgPSBOb25OZWdhdGl2ZU1vZHVsbyhtaW51dGUsIDYwKTtcbiAgICBjb25zdCBkZWx0YURheXMgPSBNYXRoRmxvb3IoaG91ciAvIDI0KTtcbiAgICBob3VyID0gTm9uTmVnYXRpdmVNb2R1bG8oaG91ciwgMjQpO1xuICAgIHJldHVybiB7IGRlbHRhRGF5cywgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kLCBtaWNyb3NlY29uZCwgbmFub3NlY29uZCB9O1xufVxuZnVuY3Rpb24gVG90YWxEdXJhdGlvbk5hbm9zZWNvbmRzKGRheXNQYXJhbSwgaG91cnNQYXJhbSwgbWludXRlc1BhcmFtLCBzZWNvbmRzUGFyYW0sIG1pbGxpc2Vjb25kc1BhcmFtLCBtaWNyb3NlY29uZHNQYXJhbSwgbmFub3NlY29uZHNQYXJhbSwgb2Zmc2V0U2hpZnQpIHtcbiAgICBjb25zdCBkYXlzID0gSlNCSS5CaWdJbnQoZGF5c1BhcmFtKTtcbiAgICBsZXQgbmFub3NlY29uZHMgPSBKU0JJLkJpZ0ludChuYW5vc2Vjb25kc1BhcmFtKTtcbiAgICBpZiAoZGF5c1BhcmFtICE9PSAwKVxuICAgICAgICBuYW5vc2Vjb25kcyA9IEpTQkkuc3VidHJhY3QoSlNCSS5CaWdJbnQobmFub3NlY29uZHNQYXJhbSksIEpTQkkuQmlnSW50KG9mZnNldFNoaWZ0KSk7XG4gICAgY29uc3QgaG91cnMgPSBKU0JJLmFkZChKU0JJLkJpZ0ludChob3Vyc1BhcmFtKSwgSlNCSS5tdWx0aXBseShkYXlzLCBKU0JJLkJpZ0ludCgyNCkpKTtcbiAgICBjb25zdCBtaW51dGVzID0gSlNCSS5hZGQoSlNCSS5CaWdJbnQobWludXRlc1BhcmFtKSwgSlNCSS5tdWx0aXBseShob3VycywgU0lYVFkpKTtcbiAgICBjb25zdCBzZWNvbmRzID0gSlNCSS5hZGQoSlNCSS5CaWdJbnQoc2Vjb25kc1BhcmFtKSwgSlNCSS5tdWx0aXBseShtaW51dGVzLCBTSVhUWSkpO1xuICAgIGNvbnN0IG1pbGxpc2Vjb25kcyA9IEpTQkkuYWRkKEpTQkkuQmlnSW50KG1pbGxpc2Vjb25kc1BhcmFtKSwgSlNCSS5tdWx0aXBseShzZWNvbmRzLCBUSE9VU0FORCkpO1xuICAgIGNvbnN0IG1pY3Jvc2Vjb25kcyA9IEpTQkkuYWRkKEpTQkkuQmlnSW50KG1pY3Jvc2Vjb25kc1BhcmFtKSwgSlNCSS5tdWx0aXBseShtaWxsaXNlY29uZHMsIFRIT1VTQU5EKSk7XG4gICAgcmV0dXJuIEpTQkkuYWRkKEpTQkkuQmlnSW50KG5hbm9zZWNvbmRzKSwgSlNCSS5tdWx0aXBseShtaWNyb3NlY29uZHMsIFRIT1VTQU5EKSk7XG59XG5mdW5jdGlvbiBOYW5vc2Vjb25kc1RvRGF5cyhuYW5vc2Vjb25kc1BhcmFtLCByZWxhdGl2ZVRvKSB7XG4gICAgY29uc3QgVGVtcG9yYWxJbnN0YW50ID0gR2V0SW50cmluc2ljKCclVGVtcG9yYWwuSW5zdGFudCUnKTtcbiAgICBjb25zdCBzaWduID0gTWF0aFNpZ24oSlNCSS50b051bWJlcihuYW5vc2Vjb25kc1BhcmFtKSk7XG4gICAgbGV0IG5hbm9zZWNvbmRzID0gSlNCSS5CaWdJbnQobmFub3NlY29uZHNQYXJhbSk7XG4gICAgbGV0IGRheUxlbmd0aE5zID0gODY0MDBlOTtcbiAgICBpZiAoc2lnbiA9PT0gMClcbiAgICAgICAgcmV0dXJuIHsgZGF5czogMCwgbmFub3NlY29uZHM6IFpFUk8sIGRheUxlbmd0aE5zIH07XG4gICAgaWYgKCFJc1RlbXBvcmFsWm9uZWREYXRlVGltZShyZWxhdGl2ZVRvKSkge1xuICAgICAgICBsZXQgZGF5cztcbiAgICAgICAgKHsgcXVvdGllbnQ6IGRheXMsIHJlbWFpbmRlcjogbmFub3NlY29uZHMgfSA9IGRpdm1vZChuYW5vc2Vjb25kcywgSlNCSS5CaWdJbnQoZGF5TGVuZ3RoTnMpKSk7XG4gICAgICAgIHJldHVybiB7IGRheXM6IEpTQkkudG9OdW1iZXIoZGF5cyksIG5hbm9zZWNvbmRzLCBkYXlMZW5ndGhOcyB9O1xuICAgIH1cbiAgICBjb25zdCBzdGFydE5zID0gR2V0U2xvdChyZWxhdGl2ZVRvLCBFUE9DSE5BTk9TRUNPTkRTKTtcbiAgICBjb25zdCBzdGFydCA9IEdldFNsb3QocmVsYXRpdmVUbywgSU5TVEFOVCk7XG4gICAgY29uc3QgZW5kTnMgPSBKU0JJLmFkZChzdGFydE5zLCBuYW5vc2Vjb25kcyk7XG4gICAgY29uc3QgZW5kID0gbmV3IFRlbXBvcmFsSW5zdGFudChlbmROcyk7XG4gICAgY29uc3QgdGltZVpvbmUgPSBHZXRTbG90KHJlbGF0aXZlVG8sIFRJTUVfWk9ORSk7XG4gICAgY29uc3QgY2FsZW5kYXIgPSBHZXRTbG90KHJlbGF0aXZlVG8sIENBTEVOREFSKTtcbiAgICAvLyBGaW5kIHRoZSBkaWZmZXJlbmNlIGluIGRheXMgb25seS5cbiAgICBjb25zdCBkdFN0YXJ0ID0gQnVpbHRpblRpbWVab25lR2V0UGxhaW5EYXRlVGltZUZvcih0aW1lWm9uZSwgc3RhcnQsIGNhbGVuZGFyKTtcbiAgICBjb25zdCBkdEVuZCA9IEJ1aWx0aW5UaW1lWm9uZUdldFBsYWluRGF0ZVRpbWVGb3IodGltZVpvbmUsIGVuZCwgY2FsZW5kYXIpO1xuICAgIGxldCB7IGRheXMgfSA9IERpZmZlcmVuY2VJU09EYXRlVGltZShHZXRTbG90KGR0U3RhcnQsIElTT19ZRUFSKSwgR2V0U2xvdChkdFN0YXJ0LCBJU09fTU9OVEgpLCBHZXRTbG90KGR0U3RhcnQsIElTT19EQVkpLCBHZXRTbG90KGR0U3RhcnQsIElTT19IT1VSKSwgR2V0U2xvdChkdFN0YXJ0LCBJU09fTUlOVVRFKSwgR2V0U2xvdChkdFN0YXJ0LCBJU09fU0VDT05EKSwgR2V0U2xvdChkdFN0YXJ0LCBJU09fTUlMTElTRUNPTkQpLCBHZXRTbG90KGR0U3RhcnQsIElTT19NSUNST1NFQ09ORCksIEdldFNsb3QoZHRTdGFydCwgSVNPX05BTk9TRUNPTkQpLCBHZXRTbG90KGR0RW5kLCBJU09fWUVBUiksIEdldFNsb3QoZHRFbmQsIElTT19NT05USCksIEdldFNsb3QoZHRFbmQsIElTT19EQVkpLCBHZXRTbG90KGR0RW5kLCBJU09fSE9VUiksIEdldFNsb3QoZHRFbmQsIElTT19NSU5VVEUpLCBHZXRTbG90KGR0RW5kLCBJU09fU0VDT05EKSwgR2V0U2xvdChkdEVuZCwgSVNPX01JTExJU0VDT05EKSwgR2V0U2xvdChkdEVuZCwgSVNPX01JQ1JPU0VDT05EKSwgR2V0U2xvdChkdEVuZCwgSVNPX05BTk9TRUNPTkQpLCBjYWxlbmRhciwgJ2RheScpO1xuICAgIGxldCBpbnRlcm1lZGlhdGVOcyA9IEFkZFpvbmVkRGF0ZVRpbWUoc3RhcnQsIHRpbWVab25lLCBjYWxlbmRhciwgMCwgMCwgMCwgZGF5cywgMCwgMCwgMCwgMCwgMCwgMCk7XG4gICAgLy8gbWF5IGRpc2FtYmlndWF0ZVxuICAgIC8vIElmIGNsb2NrIHRpbWUgYWZ0ZXIgYWRkaXRpb24gd2FzIGluIHRoZSBtaWRkbGUgb2YgYSBza2lwcGVkIHBlcmlvZCwgdGhlXG4gICAgLy8gZW5kcG9pbnQgd2FzIGRpc2FtYmlndWF0ZWQgdG8gYSBsYXRlciBjbG9jayB0aW1lLiBTbyBpdCdzIHBvc3NpYmxlIHRoYXRcbiAgICAvLyB0aGUgcmVzdWx0aW5nIGRpc2FtYmlndWF0ZWQgcmVzdWx0IGlzIGxhdGVyIHRoYW4gZW5kTnMuIElmIHNvLCB0aGVuIGJhY2tcbiAgICAvLyB1cCBvbmUgZGF5IGFuZCB0cnkgYWdhaW4uIFJlcGVhdCBpZiBuZWNlc3NhcnkgKHNvbWUgdHJhbnNpdGlvbnMgYXJlXG4gICAgLy8gPiAyNCBob3VycykgdW50aWwgZWl0aGVyIHRoZXJlJ3MgemVybyBkYXlzIGxlZnQgb3IgdGhlIGRhdGUgZHVyYXRpb24gaXNcbiAgICAvLyBiYWNrIGluc2lkZSB0aGUgcGVyaW9kIHdoZXJlIGl0IGJlbG9uZ3MuIE5vdGUgdGhhdCB0aGlzIGNhc2Ugb25seSBjYW5cbiAgICAvLyBoYXBwZW4gZm9yIHBvc2l0aXZlIGR1cmF0aW9ucyBiZWNhdXNlIHRoZSBvbmx5IGRpcmVjdGlvbiB0aGF0XG4gICAgLy8gYGRpc2FtYmlndWF0aW9uOiAnY29tcGF0aWJsZSdgIGNhbiBjaGFuZ2UgY2xvY2sgdGltZSBpcyBmb3J3YXJkcy5cbiAgICBpZiAoc2lnbiA9PT0gMSkge1xuICAgICAgICB3aGlsZSAoZGF5cyA+IDAgJiYgSlNCSS5ncmVhdGVyVGhhbihpbnRlcm1lZGlhdGVOcywgZW5kTnMpKSB7XG4gICAgICAgICAgICAtLWRheXM7XG4gICAgICAgICAgICBpbnRlcm1lZGlhdGVOcyA9IEFkZFpvbmVkRGF0ZVRpbWUoc3RhcnQsIHRpbWVab25lLCBjYWxlbmRhciwgMCwgMCwgMCwgZGF5cywgMCwgMCwgMCwgMCwgMCwgMCk7XG4gICAgICAgICAgICAvLyBtYXkgZG8gZGlzYW1iaWd1YXRpb25cbiAgICAgICAgfVxuICAgIH1cbiAgICBuYW5vc2Vjb25kcyA9IEpTQkkuc3VidHJhY3QoZW5kTnMsIGludGVybWVkaWF0ZU5zKTtcbiAgICBsZXQgaXNPdmVyZmxvdyA9IGZhbHNlO1xuICAgIGxldCByZWxhdGl2ZUluc3RhbnQgPSBuZXcgVGVtcG9yYWxJbnN0YW50KGludGVybWVkaWF0ZU5zKTtcbiAgICBkbyB7XG4gICAgICAgIC8vIGNhbGN1bGF0ZSBsZW5ndGggb2YgdGhlIG5leHQgZGF5IChkYXkgdGhhdCBjb250YWlucyB0aGUgdGltZSByZW1haW5kZXIpXG4gICAgICAgIGNvbnN0IG9uZURheUZhcnRoZXJOcyA9IEFkZFpvbmVkRGF0ZVRpbWUocmVsYXRpdmVJbnN0YW50LCB0aW1lWm9uZSwgY2FsZW5kYXIsIDAsIDAsIDAsIHNpZ24sIDAsIDAsIDAsIDAsIDAsIDApO1xuICAgICAgICBjb25zdCByZWxhdGl2ZU5zID0gR2V0U2xvdChyZWxhdGl2ZUluc3RhbnQsIEVQT0NITkFOT1NFQ09ORFMpO1xuICAgICAgICBkYXlMZW5ndGhOcyA9IEpTQkkudG9OdW1iZXIoSlNCSS5zdWJ0cmFjdChvbmVEYXlGYXJ0aGVyTnMsIHJlbGF0aXZlTnMpKTtcbiAgICAgICAgaXNPdmVyZmxvdyA9IEpTQkkuZ3JlYXRlclRoYW4oSlNCSS5tdWx0aXBseShKU0JJLnN1YnRyYWN0KG5hbm9zZWNvbmRzLCBKU0JJLkJpZ0ludChkYXlMZW5ndGhOcykpLCBKU0JJLkJpZ0ludChzaWduKSksIFpFUk8pO1xuICAgICAgICBpZiAoaXNPdmVyZmxvdykge1xuICAgICAgICAgICAgbmFub3NlY29uZHMgPSBKU0JJLnN1YnRyYWN0KG5hbm9zZWNvbmRzLCBKU0JJLkJpZ0ludChkYXlMZW5ndGhOcykpO1xuICAgICAgICAgICAgcmVsYXRpdmVJbnN0YW50ID0gbmV3IFRlbXBvcmFsSW5zdGFudChvbmVEYXlGYXJ0aGVyTnMpO1xuICAgICAgICAgICAgZGF5cyArPSBzaWduO1xuICAgICAgICB9XG4gICAgfSB3aGlsZSAoaXNPdmVyZmxvdyk7XG4gICAgcmV0dXJuIHsgZGF5cywgbmFub3NlY29uZHMsIGRheUxlbmd0aE5zOiBNYXRoQWJzKGRheUxlbmd0aE5zKSB9O1xufVxuZnVuY3Rpb24gQmFsYW5jZUR1cmF0aW9uKGRheXNQYXJhbSwgaG91cnNQYXJhbSwgbWludXRlc1BhcmFtLCBzZWNvbmRzUGFyYW0sIG1pbGxpc2Vjb25kc1BhcmFtLCBtaWNyb3NlY29uZHNQYXJhbSwgbmFub3NlY29uZHNQYXJhbSwgbGFyZ2VzdFVuaXQsIHJlbGF0aXZlVG8gPSB1bmRlZmluZWQpIHtcbiAgICBsZXQgZGF5cyA9IGRheXNQYXJhbTtcbiAgICBsZXQgbmFub3NlY29uZHNCaWdJbnQsIG1pY3Jvc2Vjb25kc0JpZ0ludCwgbWlsbGlzZWNvbmRzQmlnSW50LCBzZWNvbmRzQmlnSW50LCBtaW51dGVzQmlnSW50LCBob3Vyc0JpZ0ludDtcbiAgICBpZiAoSXNUZW1wb3JhbFpvbmVkRGF0ZVRpbWUocmVsYXRpdmVUbykpIHtcbiAgICAgICAgY29uc3QgZW5kTnMgPSBBZGRab25lZERhdGVUaW1lKEdldFNsb3QocmVsYXRpdmVUbywgSU5TVEFOVCksIEdldFNsb3QocmVsYXRpdmVUbywgVElNRV9aT05FKSwgR2V0U2xvdChyZWxhdGl2ZVRvLCBDQUxFTkRBUiksIDAsIDAsIDAsIGRheXMsIGhvdXJzUGFyYW0sIG1pbnV0ZXNQYXJhbSwgc2Vjb25kc1BhcmFtLCBtaWxsaXNlY29uZHNQYXJhbSwgbWljcm9zZWNvbmRzUGFyYW0sIG5hbm9zZWNvbmRzUGFyYW0pO1xuICAgICAgICBjb25zdCBzdGFydE5zID0gR2V0U2xvdChyZWxhdGl2ZVRvLCBFUE9DSE5BTk9TRUNPTkRTKTtcbiAgICAgICAgbmFub3NlY29uZHNCaWdJbnQgPSBKU0JJLnN1YnRyYWN0KGVuZE5zLCBzdGFydE5zKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIG5hbm9zZWNvbmRzQmlnSW50ID0gVG90YWxEdXJhdGlvbk5hbm9zZWNvbmRzKGRheXMsIGhvdXJzUGFyYW0sIG1pbnV0ZXNQYXJhbSwgc2Vjb25kc1BhcmFtLCBtaWxsaXNlY29uZHNQYXJhbSwgbWljcm9zZWNvbmRzUGFyYW0sIG5hbm9zZWNvbmRzUGFyYW0sIDApO1xuICAgIH1cbiAgICBpZiAobGFyZ2VzdFVuaXQgPT09ICd5ZWFyJyB8fCBsYXJnZXN0VW5pdCA9PT0gJ21vbnRoJyB8fCBsYXJnZXN0VW5pdCA9PT0gJ3dlZWsnIHx8IGxhcmdlc3RVbml0ID09PSAnZGF5Jykge1xuICAgICAgICAoeyBkYXlzLCBuYW5vc2Vjb25kczogbmFub3NlY29uZHNCaWdJbnQgfSA9IE5hbm9zZWNvbmRzVG9EYXlzKG5hbm9zZWNvbmRzQmlnSW50LCByZWxhdGl2ZVRvKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBkYXlzID0gMDtcbiAgICB9XG4gICAgY29uc3Qgc2lnbiA9IEpTQkkubGVzc1RoYW4obmFub3NlY29uZHNCaWdJbnQsIFpFUk8pID8gLTEgOiAxO1xuICAgIG5hbm9zZWNvbmRzQmlnSW50ID0gYWJzKG5hbm9zZWNvbmRzQmlnSW50KTtcbiAgICBtaWNyb3NlY29uZHNCaWdJbnQgPSBtaWxsaXNlY29uZHNCaWdJbnQgPSBzZWNvbmRzQmlnSW50ID0gbWludXRlc0JpZ0ludCA9IGhvdXJzQmlnSW50ID0gWkVSTztcbiAgICBzd2l0Y2ggKGxhcmdlc3RVbml0KSB7XG4gICAgICAgIGNhc2UgJ3llYXInOlxuICAgICAgICBjYXNlICdtb250aCc6XG4gICAgICAgIGNhc2UgJ3dlZWsnOlxuICAgICAgICBjYXNlICdkYXknOlxuICAgICAgICBjYXNlICdob3VyJzpcbiAgICAgICAgICAgICh7IHF1b3RpZW50OiBtaWNyb3NlY29uZHNCaWdJbnQsIHJlbWFpbmRlcjogbmFub3NlY29uZHNCaWdJbnQgfSA9IGRpdm1vZChuYW5vc2Vjb25kc0JpZ0ludCwgVEhPVVNBTkQpKTtcbiAgICAgICAgICAgICh7IHF1b3RpZW50OiBtaWxsaXNlY29uZHNCaWdJbnQsIHJlbWFpbmRlcjogbWljcm9zZWNvbmRzQmlnSW50IH0gPSBkaXZtb2QobWljcm9zZWNvbmRzQmlnSW50LCBUSE9VU0FORCkpO1xuICAgICAgICAgICAgKHsgcXVvdGllbnQ6IHNlY29uZHNCaWdJbnQsIHJlbWFpbmRlcjogbWlsbGlzZWNvbmRzQmlnSW50IH0gPSBkaXZtb2QobWlsbGlzZWNvbmRzQmlnSW50LCBUSE9VU0FORCkpO1xuICAgICAgICAgICAgKHsgcXVvdGllbnQ6IG1pbnV0ZXNCaWdJbnQsIHJlbWFpbmRlcjogc2Vjb25kc0JpZ0ludCB9ID0gZGl2bW9kKHNlY29uZHNCaWdJbnQsIFNJWFRZKSk7XG4gICAgICAgICAgICAoeyBxdW90aWVudDogaG91cnNCaWdJbnQsIHJlbWFpbmRlcjogbWludXRlc0JpZ0ludCB9ID0gZGl2bW9kKG1pbnV0ZXNCaWdJbnQsIFNJWFRZKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnbWludXRlJzpcbiAgICAgICAgICAgICh7IHF1b3RpZW50OiBtaWNyb3NlY29uZHNCaWdJbnQsIHJlbWFpbmRlcjogbmFub3NlY29uZHNCaWdJbnQgfSA9IGRpdm1vZChuYW5vc2Vjb25kc0JpZ0ludCwgVEhPVVNBTkQpKTtcbiAgICAgICAgICAgICh7IHF1b3RpZW50OiBtaWxsaXNlY29uZHNCaWdJbnQsIHJlbWFpbmRlcjogbWljcm9zZWNvbmRzQmlnSW50IH0gPSBkaXZtb2QobWljcm9zZWNvbmRzQmlnSW50LCBUSE9VU0FORCkpO1xuICAgICAgICAgICAgKHsgcXVvdGllbnQ6IHNlY29uZHNCaWdJbnQsIHJlbWFpbmRlcjogbWlsbGlzZWNvbmRzQmlnSW50IH0gPSBkaXZtb2QobWlsbGlzZWNvbmRzQmlnSW50LCBUSE9VU0FORCkpO1xuICAgICAgICAgICAgKHsgcXVvdGllbnQ6IG1pbnV0ZXNCaWdJbnQsIHJlbWFpbmRlcjogc2Vjb25kc0JpZ0ludCB9ID0gZGl2bW9kKHNlY29uZHNCaWdJbnQsIFNJWFRZKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnc2Vjb25kJzpcbiAgICAgICAgICAgICh7IHF1b3RpZW50OiBtaWNyb3NlY29uZHNCaWdJbnQsIHJlbWFpbmRlcjogbmFub3NlY29uZHNCaWdJbnQgfSA9IGRpdm1vZChuYW5vc2Vjb25kc0JpZ0ludCwgVEhPVVNBTkQpKTtcbiAgICAgICAgICAgICh7IHF1b3RpZW50OiBtaWxsaXNlY29uZHNCaWdJbnQsIHJlbWFpbmRlcjogbWljcm9zZWNvbmRzQmlnSW50IH0gPSBkaXZtb2QobWljcm9zZWNvbmRzQmlnSW50LCBUSE9VU0FORCkpO1xuICAgICAgICAgICAgKHsgcXVvdGllbnQ6IHNlY29uZHNCaWdJbnQsIHJlbWFpbmRlcjogbWlsbGlzZWNvbmRzQmlnSW50IH0gPSBkaXZtb2QobWlsbGlzZWNvbmRzQmlnSW50LCBUSE9VU0FORCkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ21pbGxpc2Vjb25kJzpcbiAgICAgICAgICAgICh7IHF1b3RpZW50OiBtaWNyb3NlY29uZHNCaWdJbnQsIHJlbWFpbmRlcjogbmFub3NlY29uZHNCaWdJbnQgfSA9IGRpdm1vZChuYW5vc2Vjb25kc0JpZ0ludCwgVEhPVVNBTkQpKTtcbiAgICAgICAgICAgICh7IHF1b3RpZW50OiBtaWxsaXNlY29uZHNCaWdJbnQsIHJlbWFpbmRlcjogbWljcm9zZWNvbmRzQmlnSW50IH0gPSBkaXZtb2QobWljcm9zZWNvbmRzQmlnSW50LCBUSE9VU0FORCkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ21pY3Jvc2Vjb25kJzpcbiAgICAgICAgICAgICh7IHF1b3RpZW50OiBtaWNyb3NlY29uZHNCaWdJbnQsIHJlbWFpbmRlcjogbmFub3NlY29uZHNCaWdJbnQgfSA9IGRpdm1vZChuYW5vc2Vjb25kc0JpZ0ludCwgVEhPVVNBTkQpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICduYW5vc2Vjb25kJzpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhc3NlcnQgbm90IHJlYWNoZWQnKTtcbiAgICB9XG4gICAgY29uc3QgaG91cnMgPSBKU0JJLnRvTnVtYmVyKGhvdXJzQmlnSW50KSAqIHNpZ247XG4gICAgY29uc3QgbWludXRlcyA9IEpTQkkudG9OdW1iZXIobWludXRlc0JpZ0ludCkgKiBzaWduO1xuICAgIGNvbnN0IHNlY29uZHMgPSBKU0JJLnRvTnVtYmVyKHNlY29uZHNCaWdJbnQpICogc2lnbjtcbiAgICBjb25zdCBtaWxsaXNlY29uZHMgPSBKU0JJLnRvTnVtYmVyKG1pbGxpc2Vjb25kc0JpZ0ludCkgKiBzaWduO1xuICAgIGNvbnN0IG1pY3Jvc2Vjb25kcyA9IEpTQkkudG9OdW1iZXIobWljcm9zZWNvbmRzQmlnSW50KSAqIHNpZ247XG4gICAgY29uc3QgbmFub3NlY29uZHMgPSBKU0JJLnRvTnVtYmVyKG5hbm9zZWNvbmRzQmlnSW50KSAqIHNpZ247XG4gICAgcmV0dXJuIHsgZGF5cywgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc2Vjb25kcywgbWljcm9zZWNvbmRzLCBuYW5vc2Vjb25kcyB9O1xufVxuZnVuY3Rpb24gVW5iYWxhbmNlRHVyYXRpb25SZWxhdGl2ZSh5ZWFyc1BhcmFtLCBtb250aHNQYXJhbSwgd2Vla3NQYXJhbSwgZGF5c1BhcmFtLCBsYXJnZXN0VW5pdCwgcmVsYXRpdmVUb1BhcmFtKSB7XG4gICAgbGV0IHllYXJzID0geWVhcnNQYXJhbTtcbiAgICBsZXQgbW9udGhzID0gbW9udGhzUGFyYW07XG4gICAgbGV0IHdlZWtzID0gd2Vla3NQYXJhbTtcbiAgICBsZXQgZGF5cyA9IGRheXNQYXJhbTtcbiAgICBjb25zdCBUZW1wb3JhbER1cmF0aW9uID0gR2V0SW50cmluc2ljKCclVGVtcG9yYWwuRHVyYXRpb24lJyk7XG4gICAgY29uc3Qgc2lnbiA9IER1cmF0aW9uU2lnbih5ZWFycywgbW9udGhzLCB3ZWVrcywgZGF5cywgMCwgMCwgMCwgMCwgMCwgMCk7XG4gICAgbGV0IGNhbGVuZGFyO1xuICAgIGxldCByZWxhdGl2ZVRvO1xuICAgIGlmIChyZWxhdGl2ZVRvUGFyYW0pIHtcbiAgICAgICAgcmVsYXRpdmVUbyA9IFRvVGVtcG9yYWxEYXRlKHJlbGF0aXZlVG9QYXJhbSk7XG4gICAgICAgIGNhbGVuZGFyID0gR2V0U2xvdChyZWxhdGl2ZVRvLCBDQUxFTkRBUik7XG4gICAgfVxuICAgIGNvbnN0IG9uZVllYXIgPSBuZXcgVGVtcG9yYWxEdXJhdGlvbihzaWduKTtcbiAgICBjb25zdCBvbmVNb250aCA9IG5ldyBUZW1wb3JhbER1cmF0aW9uKDAsIHNpZ24pO1xuICAgIGNvbnN0IG9uZVdlZWsgPSBuZXcgVGVtcG9yYWxEdXJhdGlvbigwLCAwLCBzaWduKTtcbiAgICBzd2l0Y2ggKGxhcmdlc3RVbml0KSB7XG4gICAgICAgIGNhc2UgJ3llYXInOlxuICAgICAgICAgICAgLy8gbm8tb3BcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdtb250aCc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaWYgKCFjYWxlbmRhcilcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2Egc3RhcnRpbmcgcG9pbnQgaXMgcmVxdWlyZWQgZm9yIG1vbnRocyBiYWxhbmNpbmcnKTtcbiAgICAgICAgICAgICAgICAvLyBiYWxhbmNlIHllYXJzIGRvd24gdG8gbW9udGhzXG4gICAgICAgICAgICAgICAgY29uc3QgZGF0ZUFkZCA9IGNhbGVuZGFyLmRhdGVBZGQ7XG4gICAgICAgICAgICAgICAgY29uc3QgZGF0ZVVudGlsID0gY2FsZW5kYXIuZGF0ZVVudGlsO1xuICAgICAgICAgICAgICAgIGxldCByZWxhdGl2ZVRvRGF0ZU9ubHkgPSByZWxhdGl2ZVRvO1xuICAgICAgICAgICAgICAgIHdoaWxlIChNYXRoQWJzKHllYXJzKSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYWRkT3B0aW9ucyA9IE9iamVjdENyZWF0ZSQyKG51bGwpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXdSZWxhdGl2ZVRvID0gQ2FsZW5kYXJEYXRlQWRkKGNhbGVuZGFyLCByZWxhdGl2ZVRvRGF0ZU9ubHksIG9uZVllYXIsIGFkZE9wdGlvbnMsIGRhdGVBZGQpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB1bnRpbE9wdGlvbnMgPSBPYmplY3RDcmVhdGUkMihudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgdW50aWxPcHRpb25zLmxhcmdlc3RVbml0ID0gJ21vbnRoJztcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdW50aWxSZXN1bHQgPSBDYWxlbmRhckRhdGVVbnRpbChjYWxlbmRhciwgcmVsYXRpdmVUb0RhdGVPbmx5LCBuZXdSZWxhdGl2ZVRvLCB1bnRpbE9wdGlvbnMsIGRhdGVVbnRpbCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG9uZVllYXJNb250aHMgPSBHZXRTbG90KHVudGlsUmVzdWx0LCBNT05USFMpO1xuICAgICAgICAgICAgICAgICAgICByZWxhdGl2ZVRvRGF0ZU9ubHkgPSBuZXdSZWxhdGl2ZVRvO1xuICAgICAgICAgICAgICAgICAgICBtb250aHMgKz0gb25lWWVhck1vbnRocztcbiAgICAgICAgICAgICAgICAgICAgeWVhcnMgLT0gc2lnbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnd2Vlayc6XG4gICAgICAgICAgICBpZiAoIWNhbGVuZGFyKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdhIHN0YXJ0aW5nIHBvaW50IGlzIHJlcXVpcmVkIGZvciB3ZWVrcyBiYWxhbmNpbmcnKTtcbiAgICAgICAgICAgIC8vIGJhbGFuY2UgeWVhcnMgZG93biB0byBkYXlzXG4gICAgICAgICAgICB3aGlsZSAoTWF0aEFicyh5ZWFycykgPiAwKSB7XG4gICAgICAgICAgICAgICAgbGV0IG9uZVllYXJEYXlzO1xuICAgICAgICAgICAgICAgICh7IHJlbGF0aXZlVG8sIGRheXM6IG9uZVllYXJEYXlzIH0gPSBNb3ZlUmVsYXRpdmVEYXRlKGNhbGVuZGFyLCByZWxhdGl2ZVRvLCBvbmVZZWFyKSk7XG4gICAgICAgICAgICAgICAgZGF5cyArPSBvbmVZZWFyRGF5cztcbiAgICAgICAgICAgICAgICB5ZWFycyAtPSBzaWduO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gYmFsYW5jZSBtb250aHMgZG93biB0byBkYXlzXG4gICAgICAgICAgICB3aGlsZSAoTWF0aEFicyhtb250aHMpID4gMCkge1xuICAgICAgICAgICAgICAgIGxldCBvbmVNb250aERheXM7XG4gICAgICAgICAgICAgICAgKHsgcmVsYXRpdmVUbywgZGF5czogb25lTW9udGhEYXlzIH0gPSBNb3ZlUmVsYXRpdmVEYXRlKGNhbGVuZGFyLCByZWxhdGl2ZVRvLCBvbmVNb250aCkpO1xuICAgICAgICAgICAgICAgIGRheXMgKz0gb25lTW9udGhEYXlzO1xuICAgICAgICAgICAgICAgIG1vbnRocyAtPSBzaWduO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAvLyBiYWxhbmNlIHllYXJzIGRvd24gdG8gZGF5c1xuICAgICAgICAgICAgd2hpbGUgKE1hdGhBYnMoeWVhcnMpID4gMCkge1xuICAgICAgICAgICAgICAgIGlmICghY2FsZW5kYXIpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdhIHN0YXJ0aW5nIHBvaW50IGlzIHJlcXVpcmVkIGZvciBiYWxhbmNpbmcgY2FsZW5kYXIgdW5pdHMnKTtcbiAgICAgICAgICAgICAgICBsZXQgb25lWWVhckRheXM7XG4gICAgICAgICAgICAgICAgKHsgcmVsYXRpdmVUbywgZGF5czogb25lWWVhckRheXMgfSA9IE1vdmVSZWxhdGl2ZURhdGUoY2FsZW5kYXIsIHJlbGF0aXZlVG8sIG9uZVllYXIpKTtcbiAgICAgICAgICAgICAgICBkYXlzICs9IG9uZVllYXJEYXlzO1xuICAgICAgICAgICAgICAgIHllYXJzIC09IHNpZ247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBiYWxhbmNlIG1vbnRocyBkb3duIHRvIGRheXNcbiAgICAgICAgICAgIHdoaWxlIChNYXRoQWJzKG1vbnRocykgPiAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFjYWxlbmRhcilcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2Egc3RhcnRpbmcgcG9pbnQgaXMgcmVxdWlyZWQgZm9yIGJhbGFuY2luZyBjYWxlbmRhciB1bml0cycpO1xuICAgICAgICAgICAgICAgIGxldCBvbmVNb250aERheXM7XG4gICAgICAgICAgICAgICAgKHsgcmVsYXRpdmVUbywgZGF5czogb25lTW9udGhEYXlzIH0gPSBNb3ZlUmVsYXRpdmVEYXRlKGNhbGVuZGFyLCByZWxhdGl2ZVRvLCBvbmVNb250aCkpO1xuICAgICAgICAgICAgICAgIGRheXMgKz0gb25lTW9udGhEYXlzO1xuICAgICAgICAgICAgICAgIG1vbnRocyAtPSBzaWduO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gYmFsYW5jZSB3ZWVrcyBkb3duIHRvIGRheXNcbiAgICAgICAgICAgIHdoaWxlIChNYXRoQWJzKHdlZWtzKSA+IDApIHtcbiAgICAgICAgICAgICAgICBpZiAoIWNhbGVuZGFyKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignYSBzdGFydGluZyBwb2ludCBpcyByZXF1aXJlZCBmb3IgYmFsYW5jaW5nIGNhbGVuZGFyIHVuaXRzJyk7XG4gICAgICAgICAgICAgICAgbGV0IG9uZVdlZWtEYXlzO1xuICAgICAgICAgICAgICAgICh7IHJlbGF0aXZlVG8sIGRheXM6IG9uZVdlZWtEYXlzIH0gPSBNb3ZlUmVsYXRpdmVEYXRlKGNhbGVuZGFyLCByZWxhdGl2ZVRvLCBvbmVXZWVrKSk7XG4gICAgICAgICAgICAgICAgZGF5cyArPSBvbmVXZWVrRGF5cztcbiAgICAgICAgICAgICAgICB3ZWVrcyAtPSBzaWduO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiB7IHllYXJzLCBtb250aHMsIHdlZWtzLCBkYXlzIH07XG59XG5mdW5jdGlvbiBCYWxhbmNlRHVyYXRpb25SZWxhdGl2ZSh5ZWFyc1BhcmFtLCBtb250aHNQYXJhbSwgd2Vla3NQYXJhbSwgZGF5c1BhcmFtLCBsYXJnZXN0VW5pdCwgcmVsYXRpdmVUb1BhcmFtKSB7XG4gICAgbGV0IHllYXJzID0geWVhcnNQYXJhbTtcbiAgICBsZXQgbW9udGhzID0gbW9udGhzUGFyYW07XG4gICAgbGV0IHdlZWtzID0gd2Vla3NQYXJhbTtcbiAgICBsZXQgZGF5cyA9IGRheXNQYXJhbTtcbiAgICBjb25zdCBUZW1wb3JhbER1cmF0aW9uID0gR2V0SW50cmluc2ljKCclVGVtcG9yYWwuRHVyYXRpb24lJyk7XG4gICAgY29uc3Qgc2lnbiA9IER1cmF0aW9uU2lnbih5ZWFycywgbW9udGhzLCB3ZWVrcywgZGF5cywgMCwgMCwgMCwgMCwgMCwgMCk7XG4gICAgaWYgKHNpZ24gPT09IDApXG4gICAgICAgIHJldHVybiB7IHllYXJzLCBtb250aHMsIHdlZWtzLCBkYXlzIH07XG4gICAgbGV0IGNhbGVuZGFyO1xuICAgIGxldCByZWxhdGl2ZVRvO1xuICAgIGlmIChyZWxhdGl2ZVRvUGFyYW0pIHtcbiAgICAgICAgcmVsYXRpdmVUbyA9IFRvVGVtcG9yYWxEYXRlKHJlbGF0aXZlVG9QYXJhbSk7XG4gICAgICAgIGNhbGVuZGFyID0gR2V0U2xvdChyZWxhdGl2ZVRvLCBDQUxFTkRBUik7XG4gICAgfVxuICAgIGNvbnN0IG9uZVllYXIgPSBuZXcgVGVtcG9yYWxEdXJhdGlvbihzaWduKTtcbiAgICBjb25zdCBvbmVNb250aCA9IG5ldyBUZW1wb3JhbER1cmF0aW9uKDAsIHNpZ24pO1xuICAgIGNvbnN0IG9uZVdlZWsgPSBuZXcgVGVtcG9yYWxEdXJhdGlvbigwLCAwLCBzaWduKTtcbiAgICBzd2l0Y2ggKGxhcmdlc3RVbml0KSB7XG4gICAgICAgIGNhc2UgJ3llYXInOiB7XG4gICAgICAgICAgICBpZiAoIWNhbGVuZGFyKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdhIHN0YXJ0aW5nIHBvaW50IGlzIHJlcXVpcmVkIGZvciB5ZWFycyBiYWxhbmNpbmcnKTtcbiAgICAgICAgICAgIC8vIGJhbGFuY2UgZGF5cyB1cCB0byB5ZWFyc1xuICAgICAgICAgICAgbGV0IG5ld1JlbGF0aXZlVG8sIG9uZVllYXJEYXlzO1xuICAgICAgICAgICAgKHsgcmVsYXRpdmVUbzogbmV3UmVsYXRpdmVUbywgZGF5czogb25lWWVhckRheXMgfSA9IE1vdmVSZWxhdGl2ZURhdGUoY2FsZW5kYXIsIHJlbGF0aXZlVG8sIG9uZVllYXIpKTtcbiAgICAgICAgICAgIHdoaWxlIChNYXRoQWJzKGRheXMpID49IE1hdGhBYnMob25lWWVhckRheXMpKSB7XG4gICAgICAgICAgICAgICAgZGF5cyAtPSBvbmVZZWFyRGF5cztcbiAgICAgICAgICAgICAgICB5ZWFycyArPSBzaWduO1xuICAgICAgICAgICAgICAgIHJlbGF0aXZlVG8gPSBuZXdSZWxhdGl2ZVRvO1xuICAgICAgICAgICAgICAgICh7IHJlbGF0aXZlVG86IG5ld1JlbGF0aXZlVG8sIGRheXM6IG9uZVllYXJEYXlzIH0gPSBNb3ZlUmVsYXRpdmVEYXRlKGNhbGVuZGFyLCByZWxhdGl2ZVRvLCBvbmVZZWFyKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBiYWxhbmNlIGRheXMgdXAgdG8gbW9udGhzXG4gICAgICAgICAgICBsZXQgb25lTW9udGhEYXlzO1xuICAgICAgICAgICAgKHsgcmVsYXRpdmVUbzogbmV3UmVsYXRpdmVUbywgZGF5czogb25lTW9udGhEYXlzIH0gPSBNb3ZlUmVsYXRpdmVEYXRlKGNhbGVuZGFyLCByZWxhdGl2ZVRvLCBvbmVNb250aCkpO1xuICAgICAgICAgICAgd2hpbGUgKE1hdGhBYnMoZGF5cykgPj0gTWF0aEFicyhvbmVNb250aERheXMpKSB7XG4gICAgICAgICAgICAgICAgZGF5cyAtPSBvbmVNb250aERheXM7XG4gICAgICAgICAgICAgICAgbW9udGhzICs9IHNpZ247XG4gICAgICAgICAgICAgICAgcmVsYXRpdmVUbyA9IG5ld1JlbGF0aXZlVG87XG4gICAgICAgICAgICAgICAgKHsgcmVsYXRpdmVUbzogbmV3UmVsYXRpdmVUbywgZGF5czogb25lTW9udGhEYXlzIH0gPSBNb3ZlUmVsYXRpdmVEYXRlKGNhbGVuZGFyLCByZWxhdGl2ZVRvLCBvbmVNb250aCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gYmFsYW5jZSBtb250aHMgdXAgdG8geWVhcnNcbiAgICAgICAgICAgIGNvbnN0IGRhdGVBZGQgPSBjYWxlbmRhci5kYXRlQWRkO1xuICAgICAgICAgICAgY29uc3QgYWRkT3B0aW9ucyA9IE9iamVjdENyZWF0ZSQyKG51bGwpO1xuICAgICAgICAgICAgbmV3UmVsYXRpdmVUbyA9IENhbGVuZGFyRGF0ZUFkZChjYWxlbmRhciwgcmVsYXRpdmVUbywgb25lWWVhciwgYWRkT3B0aW9ucywgZGF0ZUFkZCk7XG4gICAgICAgICAgICBjb25zdCBkYXRlVW50aWwgPSBjYWxlbmRhci5kYXRlVW50aWw7XG4gICAgICAgICAgICBjb25zdCB1bnRpbE9wdGlvbnMgPSBPYmplY3RDcmVhdGUkMihudWxsKTtcbiAgICAgICAgICAgIHVudGlsT3B0aW9ucy5sYXJnZXN0VW5pdCA9ICdtb250aCc7XG4gICAgICAgICAgICBsZXQgdW50aWxSZXN1bHQgPSBDYWxlbmRhckRhdGVVbnRpbChjYWxlbmRhciwgcmVsYXRpdmVUbywgbmV3UmVsYXRpdmVUbywgdW50aWxPcHRpb25zLCBkYXRlVW50aWwpO1xuICAgICAgICAgICAgbGV0IG9uZVllYXJNb250aHMgPSBHZXRTbG90KHVudGlsUmVzdWx0LCBNT05USFMpO1xuICAgICAgICAgICAgd2hpbGUgKE1hdGhBYnMobW9udGhzKSA+PSBNYXRoQWJzKG9uZVllYXJNb250aHMpKSB7XG4gICAgICAgICAgICAgICAgbW9udGhzIC09IG9uZVllYXJNb250aHM7XG4gICAgICAgICAgICAgICAgeWVhcnMgKz0gc2lnbjtcbiAgICAgICAgICAgICAgICByZWxhdGl2ZVRvID0gbmV3UmVsYXRpdmVUbztcbiAgICAgICAgICAgICAgICBjb25zdCBhZGRPcHRpb25zID0gT2JqZWN0Q3JlYXRlJDIobnVsbCk7XG4gICAgICAgICAgICAgICAgbmV3UmVsYXRpdmVUbyA9IENhbGVuZGFyRGF0ZUFkZChjYWxlbmRhciwgcmVsYXRpdmVUbywgb25lWWVhciwgYWRkT3B0aW9ucywgZGF0ZUFkZCk7XG4gICAgICAgICAgICAgICAgY29uc3QgdW50aWxPcHRpb25zID0gT2JqZWN0Q3JlYXRlJDIobnVsbCk7XG4gICAgICAgICAgICAgICAgdW50aWxPcHRpb25zLmxhcmdlc3RVbml0ID0gJ21vbnRoJztcbiAgICAgICAgICAgICAgICB1bnRpbFJlc3VsdCA9IENhbGVuZGFyRGF0ZVVudGlsKGNhbGVuZGFyLCByZWxhdGl2ZVRvLCBuZXdSZWxhdGl2ZVRvLCB1bnRpbE9wdGlvbnMsIGRhdGVVbnRpbCk7XG4gICAgICAgICAgICAgICAgb25lWWVhck1vbnRocyA9IEdldFNsb3QodW50aWxSZXN1bHQsIE1PTlRIUyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdtb250aCc6IHtcbiAgICAgICAgICAgIGlmICghY2FsZW5kYXIpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2Egc3RhcnRpbmcgcG9pbnQgaXMgcmVxdWlyZWQgZm9yIG1vbnRocyBiYWxhbmNpbmcnKTtcbiAgICAgICAgICAgIC8vIGJhbGFuY2UgZGF5cyB1cCB0byBtb250aHNcbiAgICAgICAgICAgIGxldCBuZXdSZWxhdGl2ZVRvLCBvbmVNb250aERheXM7XG4gICAgICAgICAgICAoeyByZWxhdGl2ZVRvOiBuZXdSZWxhdGl2ZVRvLCBkYXlzOiBvbmVNb250aERheXMgfSA9IE1vdmVSZWxhdGl2ZURhdGUoY2FsZW5kYXIsIHJlbGF0aXZlVG8sIG9uZU1vbnRoKSk7XG4gICAgICAgICAgICB3aGlsZSAoTWF0aEFicyhkYXlzKSA+PSBNYXRoQWJzKG9uZU1vbnRoRGF5cykpIHtcbiAgICAgICAgICAgICAgICBkYXlzIC09IG9uZU1vbnRoRGF5cztcbiAgICAgICAgICAgICAgICBtb250aHMgKz0gc2lnbjtcbiAgICAgICAgICAgICAgICByZWxhdGl2ZVRvID0gbmV3UmVsYXRpdmVUbztcbiAgICAgICAgICAgICAgICAoeyByZWxhdGl2ZVRvOiBuZXdSZWxhdGl2ZVRvLCBkYXlzOiBvbmVNb250aERheXMgfSA9IE1vdmVSZWxhdGl2ZURhdGUoY2FsZW5kYXIsIHJlbGF0aXZlVG8sIG9uZU1vbnRoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlICd3ZWVrJzoge1xuICAgICAgICAgICAgaWYgKCFjYWxlbmRhcilcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignYSBzdGFydGluZyBwb2ludCBpcyByZXF1aXJlZCBmb3Igd2Vla3MgYmFsYW5jaW5nJyk7XG4gICAgICAgICAgICAvLyBiYWxhbmNlIGRheXMgdXAgdG8gd2Vla3NcbiAgICAgICAgICAgIGxldCBuZXdSZWxhdGl2ZVRvLCBvbmVXZWVrRGF5cztcbiAgICAgICAgICAgICh7IHJlbGF0aXZlVG86IG5ld1JlbGF0aXZlVG8sIGRheXM6IG9uZVdlZWtEYXlzIH0gPSBNb3ZlUmVsYXRpdmVEYXRlKGNhbGVuZGFyLCByZWxhdGl2ZVRvLCBvbmVXZWVrKSk7XG4gICAgICAgICAgICB3aGlsZSAoTWF0aEFicyhkYXlzKSA+PSBNYXRoQWJzKG9uZVdlZWtEYXlzKSkge1xuICAgICAgICAgICAgICAgIGRheXMgLT0gb25lV2Vla0RheXM7XG4gICAgICAgICAgICAgICAgd2Vla3MgKz0gc2lnbjtcbiAgICAgICAgICAgICAgICByZWxhdGl2ZVRvID0gbmV3UmVsYXRpdmVUbztcbiAgICAgICAgICAgICAgICAoeyByZWxhdGl2ZVRvOiBuZXdSZWxhdGl2ZVRvLCBkYXlzOiBvbmVXZWVrRGF5cyB9ID0gTW92ZVJlbGF0aXZlRGF0ZShjYWxlbmRhciwgcmVsYXRpdmVUbywgb25lV2VlaykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgeWVhcnMsIG1vbnRocywgd2Vla3MsIGRheXMgfTtcbn1cbmZ1bmN0aW9uIENhbGN1bGF0ZU9mZnNldFNoaWZ0KHJlbGF0aXZlVG8sIHksIG1vbiwgdywgZCwgaCwgbWluLCBzLCBtcywgwrVzLCBucykge1xuICAgIGlmIChJc1RlbXBvcmFsWm9uZWREYXRlVGltZShyZWxhdGl2ZVRvKSkge1xuICAgICAgICBjb25zdCBpbnN0YW50ID0gR2V0U2xvdChyZWxhdGl2ZVRvLCBJTlNUQU5UKTtcbiAgICAgICAgY29uc3QgdGltZVpvbmUgPSBHZXRTbG90KHJlbGF0aXZlVG8sIFRJTUVfWk9ORSk7XG4gICAgICAgIGNvbnN0IGNhbGVuZGFyID0gR2V0U2xvdChyZWxhdGl2ZVRvLCBDQUxFTkRBUik7XG4gICAgICAgIGNvbnN0IG9mZnNldEJlZm9yZSA9IEdldE9mZnNldE5hbm9zZWNvbmRzRm9yKHRpbWVab25lLCBpbnN0YW50KTtcbiAgICAgICAgY29uc3QgYWZ0ZXIgPSBBZGRab25lZERhdGVUaW1lKGluc3RhbnQsIHRpbWVab25lLCBjYWxlbmRhciwgeSwgbW9uLCB3LCBkLCBoLCBtaW4sIHMsIG1zLCDCtXMsIG5zKTtcbiAgICAgICAgY29uc3QgVGVtcG9yYWxJbnN0YW50ID0gR2V0SW50cmluc2ljKCclVGVtcG9yYWwuSW5zdGFudCUnKTtcbiAgICAgICAgY29uc3QgaW5zdGFudEFmdGVyID0gbmV3IFRlbXBvcmFsSW5zdGFudChhZnRlcik7XG4gICAgICAgIGNvbnN0IG9mZnNldEFmdGVyID0gR2V0T2Zmc2V0TmFub3NlY29uZHNGb3IodGltZVpvbmUsIGluc3RhbnRBZnRlcik7XG4gICAgICAgIHJldHVybiBvZmZzZXRBZnRlciAtIG9mZnNldEJlZm9yZTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG59XG5mdW5jdGlvbiBDcmVhdGVOZWdhdGVkVGVtcG9yYWxEdXJhdGlvbihkdXJhdGlvbikge1xuICAgIGNvbnN0IFRlbXBvcmFsRHVyYXRpb24gPSBHZXRJbnRyaW5zaWMoJyVUZW1wb3JhbC5EdXJhdGlvbiUnKTtcbiAgICByZXR1cm4gbmV3IFRlbXBvcmFsRHVyYXRpb24oLUdldFNsb3QoZHVyYXRpb24sIFlFQVJTKSwgLUdldFNsb3QoZHVyYXRpb24sIE1PTlRIUyksIC1HZXRTbG90KGR1cmF0aW9uLCBXRUVLUyksIC1HZXRTbG90KGR1cmF0aW9uLCBEQVlTKSwgLUdldFNsb3QoZHVyYXRpb24sIEhPVVJTKSwgLUdldFNsb3QoZHVyYXRpb24sIE1JTlVURVMpLCAtR2V0U2xvdChkdXJhdGlvbiwgU0VDT05EUyksIC1HZXRTbG90KGR1cmF0aW9uLCBNSUxMSVNFQ09ORFMpLCAtR2V0U2xvdChkdXJhdGlvbiwgTUlDUk9TRUNPTkRTKSwgLUdldFNsb3QoZHVyYXRpb24sIE5BTk9TRUNPTkRTKSk7XG59XG5mdW5jdGlvbiBDb25zdHJhaW5Ub1JhbmdlKHZhbHVlLCBtaW4sIG1heCkge1xuICAgIC8vIE1hdGguTWF4IGFjY2VwdHMgdW5kZWZpbmVkIHZhbHVlcyBhbmQgcmV0dXJucyBOYU4uIFVuZGVmaW5lZCB2YWx1ZXMgYXJlXG4gICAgLy8gdXNlZCBmb3Igb3B0aW9uYWwgcGFyYW1zIGluIHRoZSBtZXRob2QgYmVsb3cuXG4gICAgcmV0dXJuIE1hdGhNaW4obWF4LCBNYXRoTWF4KG1pbiwgdmFsdWUpKTtcbn1cbmZ1bmN0aW9uIENvbnN0cmFpbklTT0RhdGUoeWVhciwgbW9udGhQYXJhbSwgZGF5UGFyYW0pIHtcbiAgICBjb25zdCBtb250aCA9IENvbnN0cmFpblRvUmFuZ2UobW9udGhQYXJhbSwgMSwgMTIpO1xuICAgIGNvbnN0IGRheSA9IENvbnN0cmFpblRvUmFuZ2UoZGF5UGFyYW0sIDEsIElTT0RheXNJbk1vbnRoKHllYXIsIG1vbnRoKSk7XG4gICAgcmV0dXJuIHsgeWVhciwgbW9udGgsIGRheSB9O1xufVxuZnVuY3Rpb24gQ29uc3RyYWluVGltZShob3VyUGFyYW0sIG1pbnV0ZVBhcmFtLCBzZWNvbmRQYXJhbSwgbWlsbGlzZWNvbmRQYXJhbSwgbWljcm9zZWNvbmRQYXJhbSwgbmFub3NlY29uZFBhcmFtKSB7XG4gICAgY29uc3QgaG91ciA9IENvbnN0cmFpblRvUmFuZ2UoaG91clBhcmFtLCAwLCAyMyk7XG4gICAgY29uc3QgbWludXRlID0gQ29uc3RyYWluVG9SYW5nZShtaW51dGVQYXJhbSwgMCwgNTkpO1xuICAgIGNvbnN0IHNlY29uZCA9IENvbnN0cmFpblRvUmFuZ2Uoc2Vjb25kUGFyYW0sIDAsIDU5KTtcbiAgICBjb25zdCBtaWxsaXNlY29uZCA9IENvbnN0cmFpblRvUmFuZ2UobWlsbGlzZWNvbmRQYXJhbSwgMCwgOTk5KTtcbiAgICBjb25zdCBtaWNyb3NlY29uZCA9IENvbnN0cmFpblRvUmFuZ2UobWljcm9zZWNvbmRQYXJhbSwgMCwgOTk5KTtcbiAgICBjb25zdCBuYW5vc2Vjb25kID0gQ29uc3RyYWluVG9SYW5nZShuYW5vc2Vjb25kUGFyYW0sIDAsIDk5OSk7XG4gICAgcmV0dXJuIHsgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kLCBtaWNyb3NlY29uZCwgbmFub3NlY29uZCB9O1xufVxuZnVuY3Rpb24gUmVqZWN0VG9SYW5nZSh2YWx1ZSwgbWluLCBtYXgpIHtcbiAgICBpZiAodmFsdWUgPCBtaW4gfHwgdmFsdWUgPiBtYXgpXG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGB2YWx1ZSBvdXQgb2YgcmFuZ2U6ICR7bWlufSA8PSAke3ZhbHVlfSA8PSAke21heH1gKTtcbn1cbmZ1bmN0aW9uIFJlamVjdElTT0RhdGUoeWVhciwgbW9udGgsIGRheSkge1xuICAgIFJlamVjdFRvUmFuZ2UobW9udGgsIDEsIDEyKTtcbiAgICBSZWplY3RUb1JhbmdlKGRheSwgMSwgSVNPRGF5c0luTW9udGgoeWVhciwgbW9udGgpKTtcbn1cbmZ1bmN0aW9uIFJlamVjdERhdGVSYW5nZSh5ZWFyLCBtb250aCwgZGF5KSB7XG4gICAgLy8gTm9vbiBhdm9pZHMgdHJvdWJsZSBhdCBlZGdlcyBvZiBEYXRlVGltZSByYW5nZSAoZXhjbHVkZXMgbWlkbmlnaHQpXG4gICAgUmVqZWN0RGF0ZVRpbWVSYW5nZSh5ZWFyLCBtb250aCwgZGF5LCAxMiwgMCwgMCwgMCwgMCwgMCk7XG59XG5mdW5jdGlvbiBSZWplY3RUaW1lKGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZCwgbWljcm9zZWNvbmQsIG5hbm9zZWNvbmQpIHtcbiAgICBSZWplY3RUb1JhbmdlKGhvdXIsIDAsIDIzKTtcbiAgICBSZWplY3RUb1JhbmdlKG1pbnV0ZSwgMCwgNTkpO1xuICAgIFJlamVjdFRvUmFuZ2Uoc2Vjb25kLCAwLCA1OSk7XG4gICAgUmVqZWN0VG9SYW5nZShtaWxsaXNlY29uZCwgMCwgOTk5KTtcbiAgICBSZWplY3RUb1JhbmdlKG1pY3Jvc2Vjb25kLCAwLCA5OTkpO1xuICAgIFJlamVjdFRvUmFuZ2UobmFub3NlY29uZCwgMCwgOTk5KTtcbn1cbmZ1bmN0aW9uIFJlamVjdERhdGVUaW1lKHllYXIsIG1vbnRoLCBkYXksIGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZCwgbWljcm9zZWNvbmQsIG5hbm9zZWNvbmQpIHtcbiAgICBSZWplY3RJU09EYXRlKHllYXIsIG1vbnRoLCBkYXkpO1xuICAgIFJlamVjdFRpbWUoaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kLCBtaWNyb3NlY29uZCwgbmFub3NlY29uZCk7XG59XG5mdW5jdGlvbiBSZWplY3REYXRlVGltZVJhbmdlKHllYXIsIG1vbnRoLCBkYXksIGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZCwgbWljcm9zZWNvbmQsIG5hbm9zZWNvbmQpIHtcbiAgICBSZWplY3RUb1JhbmdlKHllYXIsIFlFQVJfTUlOLCBZRUFSX01BWCk7XG4gICAgLy8gUmVqZWN0IGFueSBEYXRlVGltZSAyNCBob3VycyBvciBtb3JlIG91dHNpZGUgdGhlIEluc3RhbnQgcmFuZ2VcbiAgICBpZiAoKHllYXIgPT09IFlFQVJfTUlOICYmXG4gICAgICAgIG51bGwgPT1cbiAgICAgICAgICAgIEdldEVwb2NoRnJvbUlTT1BhcnRzKHllYXIsIG1vbnRoLCBkYXkgKyAxLCBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQsIG1pY3Jvc2Vjb25kLCBuYW5vc2Vjb25kIC0gMSkpIHx8XG4gICAgICAgICh5ZWFyID09PSBZRUFSX01BWCAmJlxuICAgICAgICAgICAgbnVsbCA9PVxuICAgICAgICAgICAgICAgIEdldEVwb2NoRnJvbUlTT1BhcnRzKHllYXIsIG1vbnRoLCBkYXkgLSAxLCBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQsIG1pY3Jvc2Vjb25kLCBuYW5vc2Vjb25kICsgMSkpKSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdEYXRlVGltZSBvdXRzaWRlIG9mIHN1cHBvcnRlZCByYW5nZScpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIFZhbGlkYXRlRXBvY2hOYW5vc2Vjb25kcyhlcG9jaE5hbm9zZWNvbmRzKSB7XG4gICAgaWYgKEpTQkkubGVzc1RoYW4oZXBvY2hOYW5vc2Vjb25kcywgTlNfTUlOKSB8fCBKU0JJLmdyZWF0ZXJUaGFuKGVwb2NoTmFub3NlY29uZHMsIE5TX01BWCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luc3RhbnQgb3V0c2lkZSBvZiBzdXBwb3J0ZWQgcmFuZ2UnKTtcbiAgICB9XG59XG5mdW5jdGlvbiBSZWplY3RZZWFyTW9udGhSYW5nZSh5ZWFyLCBtb250aCkge1xuICAgIFJlamVjdFRvUmFuZ2UoeWVhciwgWUVBUl9NSU4sIFlFQVJfTUFYKTtcbiAgICBpZiAoeWVhciA9PT0gWUVBUl9NSU4pIHtcbiAgICAgICAgUmVqZWN0VG9SYW5nZShtb250aCwgNCwgMTIpO1xuICAgIH1cbiAgICBlbHNlIGlmICh5ZWFyID09PSBZRUFSX01BWCkge1xuICAgICAgICBSZWplY3RUb1JhbmdlKG1vbnRoLCAxLCA5KTtcbiAgICB9XG59XG5mdW5jdGlvbiBSZWplY3REdXJhdGlvbih5LCBtb24sIHcsIGQsIGgsIG1pbiwgcywgbXMsIMK1cywgbnMpIHtcbiAgICBjb25zdCBzaWduID0gRHVyYXRpb25TaWduKHksIG1vbiwgdywgZCwgaCwgbWluLCBzLCBtcywgwrVzLCBucyk7XG4gICAgZm9yIChjb25zdCBwcm9wIG9mIFt5LCBtb24sIHcsIGQsIGgsIG1pbiwgcywgbXMsIMK1cywgbnNdKSB7XG4gICAgICAgIGlmICghTnVtYmVySXNGaW5pdGUocHJvcCkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignaW5maW5pdGUgdmFsdWVzIG5vdCBhbGxvd2VkIGFzIGR1cmF0aW9uIGZpZWxkcycpO1xuICAgICAgICBjb25zdCBwcm9wU2lnbiA9IE1hdGhTaWduKHByb3ApO1xuICAgICAgICBpZiAocHJvcFNpZ24gIT09IDAgJiYgcHJvcFNpZ24gIT09IHNpZ24pXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignbWl4ZWQtc2lnbiB2YWx1ZXMgbm90IGFsbG93ZWQgYXMgZHVyYXRpb24gZmllbGRzJyk7XG4gICAgfVxufVxuZnVuY3Rpb24gRGlmZmVyZW5jZUlTT0RhdGUoeTEsIG0xLCBkMSwgeTIsIG0yLCBkMiwgbGFyZ2VzdFVuaXQpIHtcbiAgICBzd2l0Y2ggKGxhcmdlc3RVbml0KSB7XG4gICAgICAgIGNhc2UgJ3llYXInOlxuICAgICAgICBjYXNlICdtb250aCc6IHtcbiAgICAgICAgICAgIGNvbnN0IHNpZ24gPSAtQ29tcGFyZUlTT0RhdGUoeTEsIG0xLCBkMSwgeTIsIG0yLCBkMik7XG4gICAgICAgICAgICBpZiAoc2lnbiA9PT0gMClcbiAgICAgICAgICAgICAgICByZXR1cm4geyB5ZWFyczogMCwgbW9udGhzOiAwLCB3ZWVrczogMCwgZGF5czogMCB9O1xuICAgICAgICAgICAgY29uc3Qgc3RhcnQgPSB7IHllYXI6IHkxLCBtb250aDogbTEsIGRheTogZDEgfTtcbiAgICAgICAgICAgIGNvbnN0IGVuZCA9IHsgeWVhcjogeTIsIG1vbnRoOiBtMiwgZGF5OiBkMiB9O1xuICAgICAgICAgICAgbGV0IHllYXJzID0gZW5kLnllYXIgLSBzdGFydC55ZWFyO1xuICAgICAgICAgICAgbGV0IG1pZCA9IEFkZElTT0RhdGUoeTEsIG0xLCBkMSwgeWVhcnMsIDAsIDAsIDAsICdjb25zdHJhaW4nKTtcbiAgICAgICAgICAgIGxldCBtaWRTaWduID0gLUNvbXBhcmVJU09EYXRlKG1pZC55ZWFyLCBtaWQubW9udGgsIG1pZC5kYXksIHkyLCBtMiwgZDIpO1xuICAgICAgICAgICAgaWYgKG1pZFNpZ24gPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbGFyZ2VzdFVuaXQgPT09ICd5ZWFyJ1xuICAgICAgICAgICAgICAgICAgICA/IHsgeWVhcnMsIG1vbnRoczogMCwgd2Vla3M6IDAsIGRheXM6IDAgfVxuICAgICAgICAgICAgICAgICAgICA6IHsgeWVhcnM6IDAsIG1vbnRoczogeWVhcnMgKiAxMiwgd2Vla3M6IDAsIGRheXM6IDAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBtb250aHMgPSBlbmQubW9udGggLSBzdGFydC5tb250aDtcbiAgICAgICAgICAgIGlmIChtaWRTaWduICE9PSBzaWduKSB7XG4gICAgICAgICAgICAgICAgeWVhcnMgLT0gc2lnbjtcbiAgICAgICAgICAgICAgICBtb250aHMgKz0gc2lnbiAqIDEyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWlkID0gQWRkSVNPRGF0ZSh5MSwgbTEsIGQxLCB5ZWFycywgbW9udGhzLCAwLCAwLCAnY29uc3RyYWluJyk7XG4gICAgICAgICAgICBtaWRTaWduID0gLUNvbXBhcmVJU09EYXRlKG1pZC55ZWFyLCBtaWQubW9udGgsIG1pZC5kYXksIHkyLCBtMiwgZDIpO1xuICAgICAgICAgICAgaWYgKG1pZFNpZ24gPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbGFyZ2VzdFVuaXQgPT09ICd5ZWFyJ1xuICAgICAgICAgICAgICAgICAgICA/IHsgeWVhcnMsIG1vbnRocywgd2Vla3M6IDAsIGRheXM6IDAgfVxuICAgICAgICAgICAgICAgICAgICA6IHsgeWVhcnM6IDAsIG1vbnRoczogbW9udGhzICsgeWVhcnMgKiAxMiwgd2Vla3M6IDAsIGRheXM6IDAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtaWRTaWduICE9PSBzaWduKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIGVuZCBkYXRlIGlzIGxhdGVyIGluIHRoZSBtb250aCB0aGFuIG1pZCBkYXRlIChvciBlYXJsaWVyIGZvclxuICAgICAgICAgICAgICAgIC8vIG5lZ2F0aXZlIGR1cmF0aW9ucykuIEJhY2sgdXAgb25lIG1vbnRoLlxuICAgICAgICAgICAgICAgIG1vbnRocyAtPSBzaWduO1xuICAgICAgICAgICAgICAgIGlmIChtb250aHMgPT09IC1zaWduKSB7XG4gICAgICAgICAgICAgICAgICAgIHllYXJzIC09IHNpZ247XG4gICAgICAgICAgICAgICAgICAgIG1vbnRocyA9IDExICogc2lnbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbWlkID0gQWRkSVNPRGF0ZSh5MSwgbTEsIGQxLCB5ZWFycywgbW9udGhzLCAwLCAwLCAnY29uc3RyYWluJyk7XG4gICAgICAgICAgICAgICAgbWlkU2lnbiA9IC1Db21wYXJlSVNPRGF0ZSh5MSwgbTEsIGQxLCBtaWQueWVhciwgbWlkLm1vbnRoLCBtaWQuZGF5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBkYXlzID0gMDtcbiAgICAgICAgICAgIC8vIElmIHdlIGdldCBoZXJlLCBtb250aHMgYW5kIHllYXJzIGFyZSBjb3JyZWN0IChubyBvdmVyZmxvdyksIGFuZCBgbWlkYFxuICAgICAgICAgICAgLy8gaXMgd2l0aGluIHRoZSByYW5nZSBmcm9tIGBzdGFydGAgdG8gYGVuZGAuIFRvIGNvdW50IHRoZSBkYXlzIGJldHdlZW5cbiAgICAgICAgICAgIC8vIGBtaWRgIGFuZCBgZW5kYCwgdGhlcmUgYXJlIDMgY2FzZXM6XG4gICAgICAgICAgICAvLyAxKSBzYW1lIG1vbnRoOiB1c2Ugc2ltcGxlIHN1YnRyYWN0aW9uXG4gICAgICAgICAgICAvLyAyKSBlbmQgaXMgcHJldmlvdXMgbW9udGggZnJvbSBpbnRlcm1lZGlhdGUgKG5lZ2F0aXZlIGR1cmF0aW9uKVxuICAgICAgICAgICAgLy8gMykgZW5kIGlzIG5leHQgbW9udGggZnJvbSBpbnRlcm1lZGlhdGUgKHBvc2l0aXZlIGR1cmF0aW9uKVxuICAgICAgICAgICAgaWYgKG1pZC5tb250aCA9PT0gZW5kLm1vbnRoKSB7XG4gICAgICAgICAgICAgICAgLy8gMSkgc2FtZSBtb250aDogdXNlIHNpbXBsZSBzdWJ0cmFjdGlvblxuICAgICAgICAgICAgICAgIGRheXMgPSBlbmQuZGF5IC0gbWlkLmRheTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHNpZ24gPCAwKSB7XG4gICAgICAgICAgICAgICAgLy8gMikgZW5kIGlzIHByZXZpb3VzIG1vbnRoIGZyb20gaW50ZXJtZWRpYXRlIChuZWdhdGl2ZSBkdXJhdGlvbilcbiAgICAgICAgICAgICAgICAvLyBFeGFtcGxlOiBpbnRlcm1lZGlhdGU6IEZlYiAxLCBlbmQ6IEphbiAzMCwgRGF5c0luTW9udGggPSAzMSwgZGF5cyA9IC0yXG4gICAgICAgICAgICAgICAgZGF5cyA9IC1taWQuZGF5IC0gKElTT0RheXNJbk1vbnRoKGVuZC55ZWFyLCBlbmQubW9udGgpIC0gZW5kLmRheSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyAzKSBlbmQgaXMgbmV4dCBtb250aCBmcm9tIGludGVybWVkaWF0ZSAocG9zaXRpdmUgZHVyYXRpb24pXG4gICAgICAgICAgICAgICAgLy8gRXhhbXBsZTogaW50ZXJtZWRpYXRlOiBKYW4gMjksIGVuZDogRmViIDEsIERheXNJbk1vbnRoID0gMzEsIGRheXMgPSAzXG4gICAgICAgICAgICAgICAgZGF5cyA9IGVuZC5kYXkgKyAoSVNPRGF5c0luTW9udGgobWlkLnllYXIsIG1pZC5tb250aCkgLSBtaWQuZGF5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsYXJnZXN0VW5pdCA9PT0gJ21vbnRoJykge1xuICAgICAgICAgICAgICAgIG1vbnRocyArPSB5ZWFycyAqIDEyO1xuICAgICAgICAgICAgICAgIHllYXJzID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7IHllYXJzLCBtb250aHMsIHdlZWtzOiAwLCBkYXlzIH07XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnd2Vlayc6XG4gICAgICAgIGNhc2UgJ2RheSc6IHtcbiAgICAgICAgICAgIGxldCBsYXJnZXIsIHNtYWxsZXIsIHNpZ247XG4gICAgICAgICAgICBpZiAoQ29tcGFyZUlTT0RhdGUoeTEsIG0xLCBkMSwgeTIsIG0yLCBkMikgPCAwKSB7XG4gICAgICAgICAgICAgICAgc21hbGxlciA9IHsgeWVhcjogeTEsIG1vbnRoOiBtMSwgZGF5OiBkMSB9O1xuICAgICAgICAgICAgICAgIGxhcmdlciA9IHsgeWVhcjogeTIsIG1vbnRoOiBtMiwgZGF5OiBkMiB9O1xuICAgICAgICAgICAgICAgIHNpZ24gPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc21hbGxlciA9IHsgeWVhcjogeTIsIG1vbnRoOiBtMiwgZGF5OiBkMiB9O1xuICAgICAgICAgICAgICAgIGxhcmdlciA9IHsgeWVhcjogeTEsIG1vbnRoOiBtMSwgZGF5OiBkMSB9O1xuICAgICAgICAgICAgICAgIHNpZ24gPSAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBkYXlzID0gRGF5T2ZZZWFyKGxhcmdlci55ZWFyLCBsYXJnZXIubW9udGgsIGxhcmdlci5kYXkpIC0gRGF5T2ZZZWFyKHNtYWxsZXIueWVhciwgc21hbGxlci5tb250aCwgc21hbGxlci5kYXkpO1xuICAgICAgICAgICAgZm9yIChsZXQgeWVhciA9IHNtYWxsZXIueWVhcjsgeWVhciA8IGxhcmdlci55ZWFyOyArK3llYXIpIHtcbiAgICAgICAgICAgICAgICBkYXlzICs9IExlYXBZZWFyKHllYXIpID8gMzY2IDogMzY1O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHdlZWtzID0gMDtcbiAgICAgICAgICAgIGlmIChsYXJnZXN0VW5pdCA9PT0gJ3dlZWsnKSB7XG4gICAgICAgICAgICAgICAgd2Vla3MgPSBNYXRoRmxvb3IoZGF5cyAvIDcpO1xuICAgICAgICAgICAgICAgIGRheXMgJT0gNztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdlZWtzICo9IHNpZ247XG4gICAgICAgICAgICBkYXlzICo9IHNpZ247XG4gICAgICAgICAgICByZXR1cm4geyB5ZWFyczogMCwgbW9udGhzOiAwLCB3ZWVrcywgZGF5cyB9O1xuICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Fzc2VydCBub3QgcmVhY2hlZCcpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIERpZmZlcmVuY2VUaW1lKGgxLCBtaW4xLCBzMSwgbXMxLCDCtXMxLCBuczEsIGgyLCBtaW4yLCBzMiwgbXMyLCDCtXMyLCBuczIpIHtcbiAgICBsZXQgaG91cnMgPSBoMiAtIGgxO1xuICAgIGxldCBtaW51dGVzID0gbWluMiAtIG1pbjE7XG4gICAgbGV0IHNlY29uZHMgPSBzMiAtIHMxO1xuICAgIGxldCBtaWxsaXNlY29uZHMgPSBtczIgLSBtczE7XG4gICAgbGV0IG1pY3Jvc2Vjb25kcyA9IMK1czIgLSDCtXMxO1xuICAgIGxldCBuYW5vc2Vjb25kcyA9IG5zMiAtIG5zMTtcbiAgICBjb25zdCBzaWduID0gRHVyYXRpb25TaWduKDAsIDAsIDAsIDAsIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBtaWxsaXNlY29uZHMsIG1pY3Jvc2Vjb25kcywgbmFub3NlY29uZHMpO1xuICAgIGhvdXJzICo9IHNpZ247XG4gICAgbWludXRlcyAqPSBzaWduO1xuICAgIHNlY29uZHMgKj0gc2lnbjtcbiAgICBtaWxsaXNlY29uZHMgKj0gc2lnbjtcbiAgICBtaWNyb3NlY29uZHMgKj0gc2lnbjtcbiAgICBuYW5vc2Vjb25kcyAqPSBzaWduO1xuICAgIGxldCBkZWx0YURheXMgPSAwO1xuICAgICh7XG4gICAgICAgIGRlbHRhRGF5cyxcbiAgICAgICAgaG91cjogaG91cnMsXG4gICAgICAgIG1pbnV0ZTogbWludXRlcyxcbiAgICAgICAgc2Vjb25kOiBzZWNvbmRzLFxuICAgICAgICBtaWxsaXNlY29uZDogbWlsbGlzZWNvbmRzLFxuICAgICAgICBtaWNyb3NlY29uZDogbWljcm9zZWNvbmRzLFxuICAgICAgICBuYW5vc2Vjb25kOiBuYW5vc2Vjb25kc1xuICAgIH0gPSBCYWxhbmNlVGltZShob3VycywgbWludXRlcywgc2Vjb25kcywgbWlsbGlzZWNvbmRzLCBtaWNyb3NlY29uZHMsIG5hbm9zZWNvbmRzKSk7XG4gICAgZGVsdGFEYXlzICo9IHNpZ247XG4gICAgaG91cnMgKj0gc2lnbjtcbiAgICBtaW51dGVzICo9IHNpZ247XG4gICAgc2Vjb25kcyAqPSBzaWduO1xuICAgIG1pbGxpc2Vjb25kcyAqPSBzaWduO1xuICAgIG1pY3Jvc2Vjb25kcyAqPSBzaWduO1xuICAgIG5hbm9zZWNvbmRzICo9IHNpZ247XG4gICAgcmV0dXJuIHsgZGVsdGFEYXlzLCBob3VycywgbWludXRlcywgc2Vjb25kcywgbWlsbGlzZWNvbmRzLCBtaWNyb3NlY29uZHMsIG5hbm9zZWNvbmRzIH07XG59XG5mdW5jdGlvbiBEaWZmZXJlbmNlSW5zdGFudChuczEsIG5zMiwgaW5jcmVtZW50LCB1bml0LCByb3VuZGluZ01vZGUpIHtcbiAgICBjb25zdCBkaWZmID0gSlNCSS5zdWJ0cmFjdChuczIsIG5zMSk7XG4gICAgY29uc3QgcmVtYWluZGVyID0gSlNCSS5yZW1haW5kZXIoZGlmZiwgSlNCSS5CaWdJbnQoODY0MDBlOSkpO1xuICAgIGNvbnN0IHdob2xlRGF5cyA9IEpTQkkuc3VidHJhY3QoZGlmZiwgcmVtYWluZGVyKTtcbiAgICBjb25zdCByb3VuZGVkUmVtYWluZGVyID0gUm91bmROdW1iZXJUb0luY3JlbWVudChyZW1haW5kZXIsIG5zUGVyVGltZVVuaXRbdW5pdF0gKiBpbmNyZW1lbnQsIHJvdW5kaW5nTW9kZSk7XG4gICAgY29uc3Qgcm91bmRlZERpZmYgPSBKU0JJLmFkZCh3aG9sZURheXMsIHJvdW5kZWRSZW1haW5kZXIpO1xuICAgIGNvbnN0IG5hbm9zZWNvbmRzID0gSlNCSS50b051bWJlcihKU0JJLnJlbWFpbmRlcihyb3VuZGVkRGlmZiwgVEhPVVNBTkQpKTtcbiAgICBjb25zdCBtaWNyb3NlY29uZHMgPSBKU0JJLnRvTnVtYmVyKEpTQkkucmVtYWluZGVyKEpTQkkuZGl2aWRlKHJvdW5kZWREaWZmLCBUSE9VU0FORCksIFRIT1VTQU5EKSk7XG4gICAgY29uc3QgbWlsbGlzZWNvbmRzID0gSlNCSS50b051bWJlcihKU0JJLnJlbWFpbmRlcihKU0JJLmRpdmlkZShyb3VuZGVkRGlmZiwgTUlMTElPTiksIFRIT1VTQU5EKSk7XG4gICAgY29uc3Qgc2Vjb25kcyA9IEpTQkkudG9OdW1iZXIoSlNCSS5kaXZpZGUocm91bmRlZERpZmYsIEJJTExJT04pKTtcbiAgICByZXR1cm4geyBzZWNvbmRzLCBtaWxsaXNlY29uZHMsIG1pY3Jvc2Vjb25kcywgbmFub3NlY29uZHMgfTtcbn1cbmZ1bmN0aW9uIERpZmZlcmVuY2VJU09EYXRlVGltZSh5MVBhcmFtLCBtb24xUGFyYW0sIGQxUGFyYW0sIGgxLCBtaW4xLCBzMSwgbXMxLCDCtXMxLCBuczEsIHkyLCBtb24yLCBkMiwgaDIsIG1pbjIsIHMyLCBtczIsIMK1czIsIG5zMiwgY2FsZW5kYXIsIGxhcmdlc3RVbml0LCBvcHRpb25zID0gT2JqZWN0Q3JlYXRlJDIobnVsbCkpIHtcbiAgICBsZXQgeTEgPSB5MVBhcmFtO1xuICAgIGxldCBtb24xID0gbW9uMVBhcmFtO1xuICAgIGxldCBkMSA9IGQxUGFyYW07XG4gICAgbGV0IHsgZGVsdGFEYXlzLCBob3VycywgbWludXRlcywgc2Vjb25kcywgbWlsbGlzZWNvbmRzLCBtaWNyb3NlY29uZHMsIG5hbm9zZWNvbmRzIH0gPSBEaWZmZXJlbmNlVGltZShoMSwgbWluMSwgczEsIG1zMSwgwrVzMSwgbnMxLCBoMiwgbWluMiwgczIsIG1zMiwgwrVzMiwgbnMyKTtcbiAgICBjb25zdCB0aW1lU2lnbiA9IER1cmF0aW9uU2lnbigwLCAwLCAwLCBkZWx0YURheXMsIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBtaWxsaXNlY29uZHMsIG1pY3Jvc2Vjb25kcywgbmFub3NlY29uZHMpO1xuICAgICh7IHllYXI6IHkxLCBtb250aDogbW9uMSwgZGF5OiBkMSB9ID0gQmFsYW5jZUlTT0RhdGUoeTEsIG1vbjEsIGQxICsgZGVsdGFEYXlzKSk7XG4gICAgY29uc3QgZGF0ZVNpZ24gPSBDb21wYXJlSVNPRGF0ZSh5MiwgbW9uMiwgZDIsIHkxLCBtb24xLCBkMSk7XG4gICAgaWYgKGRhdGVTaWduID09PSAtdGltZVNpZ24pIHtcbiAgICAgICAgKHsgeWVhcjogeTEsIG1vbnRoOiBtb24xLCBkYXk6IGQxIH0gPSBCYWxhbmNlSVNPRGF0ZSh5MSwgbW9uMSwgZDEgLSB0aW1lU2lnbikpO1xuICAgICAgICAoeyBob3VycywgbWludXRlcywgc2Vjb25kcywgbWlsbGlzZWNvbmRzLCBtaWNyb3NlY29uZHMsIG5hbm9zZWNvbmRzIH0gPSBCYWxhbmNlRHVyYXRpb24oLXRpbWVTaWduLCBob3VycywgbWludXRlcywgc2Vjb25kcywgbWlsbGlzZWNvbmRzLCBtaWNyb3NlY29uZHMsIG5hbm9zZWNvbmRzLCBsYXJnZXN0VW5pdCkpO1xuICAgIH1cbiAgICBjb25zdCBkYXRlMSA9IENyZWF0ZVRlbXBvcmFsRGF0ZSh5MSwgbW9uMSwgZDEsIGNhbGVuZGFyKTtcbiAgICBjb25zdCBkYXRlMiA9IENyZWF0ZVRlbXBvcmFsRGF0ZSh5MiwgbW9uMiwgZDIsIGNhbGVuZGFyKTtcbiAgICBjb25zdCBkYXRlTGFyZ2VzdFVuaXQgPSBMYXJnZXJPZlR3b1RlbXBvcmFsVW5pdHMoJ2RheScsIGxhcmdlc3RVbml0KTtcbiAgICBjb25zdCB1bnRpbE9wdGlvbnMgPSB7IC4uLm9wdGlvbnMsIGxhcmdlc3RVbml0OiBkYXRlTGFyZ2VzdFVuaXQgfTtcbiAgICBsZXQgeyB5ZWFycywgbW9udGhzLCB3ZWVrcywgZGF5cyB9ID0gQ2FsZW5kYXJEYXRlVW50aWwoY2FsZW5kYXIsIGRhdGUxLCBkYXRlMiwgdW50aWxPcHRpb25zKTtcbiAgICAvLyBTaWducyBvZiBkYXRlIHBhcnQgYW5kIHRpbWUgcGFydCBtYXkgbm90IGFncmVlOyBiYWxhbmNlIHRoZW0gdG9nZXRoZXJcbiAgICAoeyBkYXlzLCBob3VycywgbWludXRlcywgc2Vjb25kcywgbWlsbGlzZWNvbmRzLCBtaWNyb3NlY29uZHMsIG5hbm9zZWNvbmRzIH0gPSBCYWxhbmNlRHVyYXRpb24oZGF5cywgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc2Vjb25kcywgbWljcm9zZWNvbmRzLCBuYW5vc2Vjb25kcywgbGFyZ2VzdFVuaXQpKTtcbiAgICByZXR1cm4geyB5ZWFycywgbW9udGhzLCB3ZWVrcywgZGF5cywgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc2Vjb25kcywgbWljcm9zZWNvbmRzLCBuYW5vc2Vjb25kcyB9O1xufVxuZnVuY3Rpb24gRGlmZmVyZW5jZVpvbmVkRGF0ZVRpbWUobnMxLCBuczIsIHRpbWVab25lLCBjYWxlbmRhciwgbGFyZ2VzdFVuaXQsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBuc0RpZmYgPSBKU0JJLnN1YnRyYWN0KG5zMiwgbnMxKTtcbiAgICBpZiAoSlNCSS5lcXVhbChuc0RpZmYsIFpFUk8pKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB5ZWFyczogMCxcbiAgICAgICAgICAgIG1vbnRoczogMCxcbiAgICAgICAgICAgIHdlZWtzOiAwLFxuICAgICAgICAgICAgZGF5czogMCxcbiAgICAgICAgICAgIGhvdXJzOiAwLFxuICAgICAgICAgICAgbWludXRlczogMCxcbiAgICAgICAgICAgIHNlY29uZHM6IDAsXG4gICAgICAgICAgICBtaWxsaXNlY29uZHM6IDAsXG4gICAgICAgICAgICBtaWNyb3NlY29uZHM6IDAsXG4gICAgICAgICAgICBuYW5vc2Vjb25kczogMFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBGaW5kIHRoZSBkaWZmZXJlbmNlIGluIGRhdGVzIG9ubHkuXG4gICAgY29uc3QgVGVtcG9yYWxJbnN0YW50ID0gR2V0SW50cmluc2ljKCclVGVtcG9yYWwuSW5zdGFudCUnKTtcbiAgICBjb25zdCBzdGFydCA9IG5ldyBUZW1wb3JhbEluc3RhbnQobnMxKTtcbiAgICBjb25zdCBlbmQgPSBuZXcgVGVtcG9yYWxJbnN0YW50KG5zMik7XG4gICAgY29uc3QgZHRTdGFydCA9IEJ1aWx0aW5UaW1lWm9uZUdldFBsYWluRGF0ZVRpbWVGb3IodGltZVpvbmUsIHN0YXJ0LCBjYWxlbmRhcik7XG4gICAgY29uc3QgZHRFbmQgPSBCdWlsdGluVGltZVpvbmVHZXRQbGFpbkRhdGVUaW1lRm9yKHRpbWVab25lLCBlbmQsIGNhbGVuZGFyKTtcbiAgICBsZXQgeyB5ZWFycywgbW9udGhzLCB3ZWVrcywgZGF5cyB9ID0gRGlmZmVyZW5jZUlTT0RhdGVUaW1lKEdldFNsb3QoZHRTdGFydCwgSVNPX1lFQVIpLCBHZXRTbG90KGR0U3RhcnQsIElTT19NT05USCksIEdldFNsb3QoZHRTdGFydCwgSVNPX0RBWSksIEdldFNsb3QoZHRTdGFydCwgSVNPX0hPVVIpLCBHZXRTbG90KGR0U3RhcnQsIElTT19NSU5VVEUpLCBHZXRTbG90KGR0U3RhcnQsIElTT19TRUNPTkQpLCBHZXRTbG90KGR0U3RhcnQsIElTT19NSUxMSVNFQ09ORCksIEdldFNsb3QoZHRTdGFydCwgSVNPX01JQ1JPU0VDT05EKSwgR2V0U2xvdChkdFN0YXJ0LCBJU09fTkFOT1NFQ09ORCksIEdldFNsb3QoZHRFbmQsIElTT19ZRUFSKSwgR2V0U2xvdChkdEVuZCwgSVNPX01PTlRIKSwgR2V0U2xvdChkdEVuZCwgSVNPX0RBWSksIEdldFNsb3QoZHRFbmQsIElTT19IT1VSKSwgR2V0U2xvdChkdEVuZCwgSVNPX01JTlVURSksIEdldFNsb3QoZHRFbmQsIElTT19TRUNPTkQpLCBHZXRTbG90KGR0RW5kLCBJU09fTUlMTElTRUNPTkQpLCBHZXRTbG90KGR0RW5kLCBJU09fTUlDUk9TRUNPTkQpLCBHZXRTbG90KGR0RW5kLCBJU09fTkFOT1NFQ09ORCksIGNhbGVuZGFyLCBsYXJnZXN0VW5pdCwgb3B0aW9ucyk7XG4gICAgY29uc3QgaW50ZXJtZWRpYXRlTnMgPSBBZGRab25lZERhdGVUaW1lKHN0YXJ0LCB0aW1lWm9uZSwgY2FsZW5kYXIsIHllYXJzLCBtb250aHMsIHdlZWtzLCAwLCAwLCAwLCAwLCAwLCAwLCAwKTtcbiAgICAvLyBtYXkgZGlzYW1iaWd1YXRlXG4gICAgbGV0IHRpbWVSZW1haW5kZXJOcyA9IEpTQkkuc3VidHJhY3QobnMyLCBpbnRlcm1lZGlhdGVOcyk7XG4gICAgY29uc3QgaW50ZXJtZWRpYXRlID0gQ3JlYXRlVGVtcG9yYWxab25lZERhdGVUaW1lKGludGVybWVkaWF0ZU5zLCB0aW1lWm9uZSwgY2FsZW5kYXIpO1xuICAgICh7IG5hbm9zZWNvbmRzOiB0aW1lUmVtYWluZGVyTnMsIGRheXMgfSA9IE5hbm9zZWNvbmRzVG9EYXlzKHRpbWVSZW1haW5kZXJOcywgaW50ZXJtZWRpYXRlKSk7XG4gICAgLy8gRmluYWxseSwgbWVyZ2UgdGhlIGRhdGUgYW5kIHRpbWUgZHVyYXRpb25zIGFuZCByZXR1cm4gdGhlIG1lcmdlZCByZXN1bHQuXG4gICAgY29uc3QgeyBob3VycywgbWludXRlcywgc2Vjb25kcywgbWlsbGlzZWNvbmRzLCBtaWNyb3NlY29uZHMsIG5hbm9zZWNvbmRzIH0gPSBCYWxhbmNlRHVyYXRpb24oMCwgMCwgMCwgMCwgMCwgMCwgSlNCSS50b051bWJlcih0aW1lUmVtYWluZGVyTnMpLCAnaG91cicpO1xuICAgIHJldHVybiB7IHllYXJzLCBtb250aHMsIHdlZWtzLCBkYXlzLCBob3VycywgbWludXRlcywgc2Vjb25kcywgbWlsbGlzZWNvbmRzLCBtaWNyb3NlY29uZHMsIG5hbm9zZWNvbmRzIH07XG59XG5mdW5jdGlvbiBBZGRJU09EYXRlKHllYXJQYXJhbSwgbW9udGhQYXJhbSwgZGF5UGFyYW0sIHllYXJzUGFyYW0sIG1vbnRoc1BhcmFtLCB3ZWVrc1BhcmFtLCBkYXlzUGFyYW0sIG92ZXJmbG93KSB7XG4gICAgbGV0IHllYXIgPSB5ZWFyUGFyYW07XG4gICAgbGV0IG1vbnRoID0gbW9udGhQYXJhbTtcbiAgICBsZXQgZGF5ID0gZGF5UGFyYW07XG4gICAgbGV0IHllYXJzID0geWVhcnNQYXJhbTtcbiAgICBsZXQgbW9udGhzID0gbW9udGhzUGFyYW07XG4gICAgbGV0IHdlZWtzID0gd2Vla3NQYXJhbTtcbiAgICBsZXQgZGF5cyA9IGRheXNQYXJhbTtcbiAgICB5ZWFyICs9IHllYXJzO1xuICAgIG1vbnRoICs9IG1vbnRocztcbiAgICAoeyB5ZWFyLCBtb250aCB9ID0gQmFsYW5jZUlTT1llYXJNb250aCh5ZWFyLCBtb250aCkpO1xuICAgICh7IHllYXIsIG1vbnRoLCBkYXkgfSA9IFJlZ3VsYXRlSVNPRGF0ZSh5ZWFyLCBtb250aCwgZGF5LCBvdmVyZmxvdykpO1xuICAgIGRheXMgKz0gNyAqIHdlZWtzO1xuICAgIGRheSArPSBkYXlzO1xuICAgICh7IHllYXIsIG1vbnRoLCBkYXkgfSA9IEJhbGFuY2VJU09EYXRlKHllYXIsIG1vbnRoLCBkYXkpKTtcbiAgICByZXR1cm4geyB5ZWFyLCBtb250aCwgZGF5IH07XG59XG5mdW5jdGlvbiBBZGRUaW1lKGhvdXJQYXJhbSwgbWludXRlUGFyYW0sIHNlY29uZFBhcmFtLCBtaWxsaXNlY29uZFBhcmFtLCBtaWNyb3NlY29uZFBhcmFtLCBuYW5vc2Vjb25kUGFyYW0sIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBtaWxsaXNlY29uZHMsIG1pY3Jvc2Vjb25kcywgbmFub3NlY29uZHMpIHtcbiAgICBsZXQgaG91ciA9IGhvdXJQYXJhbTtcbiAgICBsZXQgbWludXRlID0gbWludXRlUGFyYW07XG4gICAgbGV0IHNlY29uZCA9IHNlY29uZFBhcmFtO1xuICAgIGxldCBtaWxsaXNlY29uZCA9IG1pbGxpc2Vjb25kUGFyYW07XG4gICAgbGV0IG1pY3Jvc2Vjb25kID0gbWljcm9zZWNvbmRQYXJhbTtcbiAgICBsZXQgbmFub3NlY29uZCA9IG5hbm9zZWNvbmRQYXJhbTtcbiAgICBob3VyICs9IGhvdXJzO1xuICAgIG1pbnV0ZSArPSBtaW51dGVzO1xuICAgIHNlY29uZCArPSBzZWNvbmRzO1xuICAgIG1pbGxpc2Vjb25kICs9IG1pbGxpc2Vjb25kcztcbiAgICBtaWNyb3NlY29uZCArPSBtaWNyb3NlY29uZHM7XG4gICAgbmFub3NlY29uZCArPSBuYW5vc2Vjb25kcztcbiAgICBsZXQgZGVsdGFEYXlzID0gMDtcbiAgICAoeyBkZWx0YURheXMsIGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZCwgbWljcm9zZWNvbmQsIG5hbm9zZWNvbmQgfSA9IEJhbGFuY2VUaW1lKGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZCwgbWljcm9zZWNvbmQsIG5hbm9zZWNvbmQpKTtcbiAgICByZXR1cm4geyBkZWx0YURheXMsIGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZCwgbWljcm9zZWNvbmQsIG5hbm9zZWNvbmQgfTtcbn1cbmZ1bmN0aW9uIEFkZER1cmF0aW9uKHkxLCBtb24xLCB3MSwgZDEsIGgxLCBtaW4xLCBzMSwgbXMxLCDCtXMxLCBuczEsIHkyLCBtb24yLCB3MiwgZDIsIGgyLCBtaW4yLCBzMiwgbXMyLCDCtXMyLCBuczIsIHJlbGF0aXZlVG8pIHtcbiAgICBjb25zdCBsYXJnZXN0VW5pdDEgPSBEZWZhdWx0VGVtcG9yYWxMYXJnZXN0VW5pdCh5MSwgbW9uMSwgdzEsIGQxLCBoMSwgbWluMSwgczEsIG1zMSwgwrVzMSwgbnMxKTtcbiAgICBjb25zdCBsYXJnZXN0VW5pdDIgPSBEZWZhdWx0VGVtcG9yYWxMYXJnZXN0VW5pdCh5MiwgbW9uMiwgdzIsIGQyLCBoMiwgbWluMiwgczIsIG1zMiwgwrVzMiwgbnMyKTtcbiAgICBjb25zdCBsYXJnZXN0VW5pdCA9IExhcmdlck9mVHdvVGVtcG9yYWxVbml0cyhsYXJnZXN0VW5pdDEsIGxhcmdlc3RVbml0Mik7XG4gICAgbGV0IHllYXJzLCBtb250aHMsIHdlZWtzLCBkYXlzLCBob3VycywgbWludXRlcywgc2Vjb25kcywgbWlsbGlzZWNvbmRzLCBtaWNyb3NlY29uZHMsIG5hbm9zZWNvbmRzO1xuICAgIGlmICghcmVsYXRpdmVUbykge1xuICAgICAgICBpZiAobGFyZ2VzdFVuaXQgPT09ICd5ZWFyJyB8fCBsYXJnZXN0VW5pdCA9PT0gJ21vbnRoJyB8fCBsYXJnZXN0VW5pdCA9PT0gJ3dlZWsnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigncmVsYXRpdmVUbyBpcyByZXF1aXJlZCBmb3IgeWVhcnMsIG1vbnRocywgb3Igd2Vla3MgYXJpdGhtZXRpYycpO1xuICAgICAgICB9XG4gICAgICAgIHllYXJzID0gbW9udGhzID0gd2Vla3MgPSAwO1xuICAgICAgICAoeyBkYXlzLCBob3VycywgbWludXRlcywgc2Vjb25kcywgbWlsbGlzZWNvbmRzLCBtaWNyb3NlY29uZHMsIG5hbm9zZWNvbmRzIH0gPSBCYWxhbmNlRHVyYXRpb24oZDEgKyBkMiwgaDEgKyBoMiwgbWluMSArIG1pbjIsIHMxICsgczIsIG1zMSArIG1zMiwgwrVzMSArIMK1czIsIG5zMSArIG5zMiwgbGFyZ2VzdFVuaXQpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoSXNUZW1wb3JhbERhdGUocmVsYXRpdmVUbykpIHtcbiAgICAgICAgY29uc3QgVGVtcG9yYWxEdXJhdGlvbiA9IEdldEludHJpbnNpYygnJVRlbXBvcmFsLkR1cmF0aW9uJScpO1xuICAgICAgICBjb25zdCBjYWxlbmRhciA9IEdldFNsb3QocmVsYXRpdmVUbywgQ0FMRU5EQVIpO1xuICAgICAgICBjb25zdCBkYXRlRHVyYXRpb24xID0gbmV3IFRlbXBvcmFsRHVyYXRpb24oeTEsIG1vbjEsIHcxLCBkMSwgMCwgMCwgMCwgMCwgMCwgMCk7XG4gICAgICAgIGNvbnN0IGRhdGVEdXJhdGlvbjIgPSBuZXcgVGVtcG9yYWxEdXJhdGlvbih5MiwgbW9uMiwgdzIsIGQyLCAwLCAwLCAwLCAwLCAwLCAwKTtcbiAgICAgICAgY29uc3QgZGF0ZUFkZCA9IGNhbGVuZGFyLmRhdGVBZGQ7XG4gICAgICAgIGNvbnN0IGZpcnN0QWRkT3B0aW9ucyA9IE9iamVjdENyZWF0ZSQyKG51bGwpO1xuICAgICAgICBjb25zdCBpbnRlcm1lZGlhdGUgPSBDYWxlbmRhckRhdGVBZGQoY2FsZW5kYXIsIHJlbGF0aXZlVG8sIGRhdGVEdXJhdGlvbjEsIGZpcnN0QWRkT3B0aW9ucywgZGF0ZUFkZCk7XG4gICAgICAgIGNvbnN0IHNlY29uZEFkZE9wdGlvbnMgPSBPYmplY3RDcmVhdGUkMihudWxsKTtcbiAgICAgICAgY29uc3QgZW5kID0gQ2FsZW5kYXJEYXRlQWRkKGNhbGVuZGFyLCBpbnRlcm1lZGlhdGUsIGRhdGVEdXJhdGlvbjIsIHNlY29uZEFkZE9wdGlvbnMsIGRhdGVBZGQpO1xuICAgICAgICBjb25zdCBkYXRlTGFyZ2VzdFVuaXQgPSBMYXJnZXJPZlR3b1RlbXBvcmFsVW5pdHMoJ2RheScsIGxhcmdlc3RVbml0KTtcbiAgICAgICAgY29uc3QgZGlmZmVyZW5jZU9wdGlvbnMgPSBPYmplY3RDcmVhdGUkMihudWxsKTtcbiAgICAgICAgZGlmZmVyZW5jZU9wdGlvbnMubGFyZ2VzdFVuaXQgPSBkYXRlTGFyZ2VzdFVuaXQ7XG4gICAgICAgICh7IHllYXJzLCBtb250aHMsIHdlZWtzLCBkYXlzIH0gPSBDYWxlbmRhckRhdGVVbnRpbChjYWxlbmRhciwgcmVsYXRpdmVUbywgZW5kLCBkaWZmZXJlbmNlT3B0aW9ucykpO1xuICAgICAgICAvLyBTaWducyBvZiBkYXRlIHBhcnQgYW5kIHRpbWUgcGFydCBtYXkgbm90IGFncmVlOyBiYWxhbmNlIHRoZW0gdG9nZXRoZXJcbiAgICAgICAgKHsgZGF5cywgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc2Vjb25kcywgbWljcm9zZWNvbmRzLCBuYW5vc2Vjb25kcyB9ID0gQmFsYW5jZUR1cmF0aW9uKGRheXMsIGgxICsgaDIsIG1pbjEgKyBtaW4yLCBzMSArIHMyLCBtczEgKyBtczIsIMK1czEgKyDCtXMyLCBuczEgKyBuczIsIGxhcmdlc3RVbml0KSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyByZWxhdGl2ZVRvIGlzIGEgWm9uZWREYXRlVGltZVxuICAgICAgICBjb25zdCBUZW1wb3JhbEluc3RhbnQgPSBHZXRJbnRyaW5zaWMoJyVUZW1wb3JhbC5JbnN0YW50JScpO1xuICAgICAgICBjb25zdCB0aW1lWm9uZSA9IEdldFNsb3QocmVsYXRpdmVUbywgVElNRV9aT05FKTtcbiAgICAgICAgY29uc3QgY2FsZW5kYXIgPSBHZXRTbG90KHJlbGF0aXZlVG8sIENBTEVOREFSKTtcbiAgICAgICAgY29uc3QgaW50ZXJtZWRpYXRlTnMgPSBBZGRab25lZERhdGVUaW1lKEdldFNsb3QocmVsYXRpdmVUbywgSU5TVEFOVCksIHRpbWVab25lLCBjYWxlbmRhciwgeTEsIG1vbjEsIHcxLCBkMSwgaDEsIG1pbjEsIHMxLCBtczEsIMK1czEsIG5zMSk7XG4gICAgICAgIGNvbnN0IGVuZE5zID0gQWRkWm9uZWREYXRlVGltZShuZXcgVGVtcG9yYWxJbnN0YW50KGludGVybWVkaWF0ZU5zKSwgdGltZVpvbmUsIGNhbGVuZGFyLCB5MiwgbW9uMiwgdzIsIGQyLCBoMiwgbWluMiwgczIsIG1zMiwgwrVzMiwgbnMyKTtcbiAgICAgICAgaWYgKGxhcmdlc3RVbml0ICE9PSAneWVhcicgJiYgbGFyZ2VzdFVuaXQgIT09ICdtb250aCcgJiYgbGFyZ2VzdFVuaXQgIT09ICd3ZWVrJyAmJiBsYXJnZXN0VW5pdCAhPT0gJ2RheScpIHtcbiAgICAgICAgICAgIC8vIFRoZSB1c2VyIGlzIG9ubHkgYXNraW5nIGZvciBhIHRpbWUgZGlmZmVyZW5jZSwgc28gcmV0dXJuIGRpZmZlcmVuY2Ugb2YgaW5zdGFudHMuXG4gICAgICAgICAgICB5ZWFycyA9IDA7XG4gICAgICAgICAgICBtb250aHMgPSAwO1xuICAgICAgICAgICAgd2Vla3MgPSAwO1xuICAgICAgICAgICAgZGF5cyA9IDA7XG4gICAgICAgICAgICAoeyBzZWNvbmRzLCBtaWxsaXNlY29uZHMsIG1pY3Jvc2Vjb25kcywgbmFub3NlY29uZHMgfSA9IERpZmZlcmVuY2VJbnN0YW50KEdldFNsb3QocmVsYXRpdmVUbywgRVBPQ0hOQU5PU0VDT05EUyksIGVuZE5zLCAxLCAnbmFub3NlY29uZCcsICdoYWxmRXhwYW5kJykpO1xuICAgICAgICAgICAgKHsgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc2Vjb25kcywgbWljcm9zZWNvbmRzLCBuYW5vc2Vjb25kcyB9ID0gQmFsYW5jZUR1cmF0aW9uKDAsIDAsIDAsIHNlY29uZHMsIG1pbGxpc2Vjb25kcywgbWljcm9zZWNvbmRzLCBuYW5vc2Vjb25kcywgbGFyZ2VzdFVuaXQpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICh7IHllYXJzLCBtb250aHMsIHdlZWtzLCBkYXlzLCBob3VycywgbWludXRlcywgc2Vjb25kcywgbWlsbGlzZWNvbmRzLCBtaWNyb3NlY29uZHMsIG5hbm9zZWNvbmRzIH0gPVxuICAgICAgICAgICAgICAgIERpZmZlcmVuY2Vab25lZERhdGVUaW1lKEdldFNsb3QocmVsYXRpdmVUbywgRVBPQ0hOQU5PU0VDT05EUyksIGVuZE5zLCB0aW1lWm9uZSwgY2FsZW5kYXIsIGxhcmdlc3RVbml0KSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgUmVqZWN0RHVyYXRpb24oeWVhcnMsIG1vbnRocywgd2Vla3MsIGRheXMsIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBtaWxsaXNlY29uZHMsIG1pY3Jvc2Vjb25kcywgbmFub3NlY29uZHMpO1xuICAgIHJldHVybiB7IHllYXJzLCBtb250aHMsIHdlZWtzLCBkYXlzLCBob3VycywgbWludXRlcywgc2Vjb25kcywgbWlsbGlzZWNvbmRzLCBtaWNyb3NlY29uZHMsIG5hbm9zZWNvbmRzIH07XG59XG5mdW5jdGlvbiBBZGRJbnN0YW50KGVwb2NoTmFub3NlY29uZHMsIGgsIG1pbiwgcywgbXMsIMK1cywgbnMpIHtcbiAgICBsZXQgc3VtID0gWkVSTztcbiAgICBzdW0gPSBKU0JJLmFkZChzdW0sIEpTQkkuQmlnSW50KG5zKSk7XG4gICAgc3VtID0gSlNCSS5hZGQoc3VtLCBKU0JJLm11bHRpcGx5KEpTQkkuQmlnSW50KMK1cyksIFRIT1VTQU5EKSk7XG4gICAgc3VtID0gSlNCSS5hZGQoc3VtLCBKU0JJLm11bHRpcGx5KEpTQkkuQmlnSW50KG1zKSwgTUlMTElPTikpO1xuICAgIHN1bSA9IEpTQkkuYWRkKHN1bSwgSlNCSS5tdWx0aXBseShKU0JJLkJpZ0ludChzKSwgQklMTElPTikpO1xuICAgIHN1bSA9IEpTQkkuYWRkKHN1bSwgSlNCSS5tdWx0aXBseShKU0JJLkJpZ0ludChtaW4pLCBKU0JJLkJpZ0ludCg2MCAqIDFlOSkpKTtcbiAgICBzdW0gPSBKU0JJLmFkZChzdW0sIEpTQkkubXVsdGlwbHkoSlNCSS5CaWdJbnQoaCksIEpTQkkuQmlnSW50KDYwICogNjAgKiAxZTkpKSk7XG4gICAgY29uc3QgcmVzdWx0ID0gSlNCSS5hZGQoZXBvY2hOYW5vc2Vjb25kcywgc3VtKTtcbiAgICBWYWxpZGF0ZUVwb2NoTmFub3NlY29uZHMocmVzdWx0KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gQWRkRGF0ZVRpbWUoeWVhciwgbW9udGgsIGRheSwgaG91clBhcmFtLCBtaW51dGVQYXJhbSwgc2Vjb25kUGFyYW0sIG1pbGxpc2Vjb25kUGFyYW0sIG1pY3Jvc2Vjb25kUGFyYW0sIG5hbm9zZWNvbmRQYXJhbSwgY2FsZW5kYXIsIHllYXJzLCBtb250aHMsIHdlZWtzLCBkYXlzUGFyYW0sIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBtaWxsaXNlY29uZHMsIG1pY3Jvc2Vjb25kcywgbmFub3NlY29uZHMsIG9wdGlvbnMpIHtcbiAgICBsZXQgZGF5cyA9IGRheXNQYXJhbTtcbiAgICAvLyBBZGQgdGhlIHRpbWUgcGFydFxuICAgIGxldCB7IGRlbHRhRGF5cywgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kLCBtaWNyb3NlY29uZCwgbmFub3NlY29uZCB9ID0gQWRkVGltZShob3VyUGFyYW0sIG1pbnV0ZVBhcmFtLCBzZWNvbmRQYXJhbSwgbWlsbGlzZWNvbmRQYXJhbSwgbWljcm9zZWNvbmRQYXJhbSwgbmFub3NlY29uZFBhcmFtLCBob3VycywgbWludXRlcywgc2Vjb25kcywgbWlsbGlzZWNvbmRzLCBtaWNyb3NlY29uZHMsIG5hbm9zZWNvbmRzKTtcbiAgICBkYXlzICs9IGRlbHRhRGF5cztcbiAgICAvLyBEZWxlZ2F0ZSB0aGUgZGF0ZSBwYXJ0IGFkZGl0aW9uIHRvIHRoZSBjYWxlbmRhclxuICAgIGNvbnN0IFRlbXBvcmFsRHVyYXRpb24gPSBHZXRJbnRyaW5zaWMoJyVUZW1wb3JhbC5EdXJhdGlvbiUnKTtcbiAgICBjb25zdCBkYXRlUGFydCA9IENyZWF0ZVRlbXBvcmFsRGF0ZSh5ZWFyLCBtb250aCwgZGF5LCBjYWxlbmRhcik7XG4gICAgY29uc3QgZGF0ZUR1cmF0aW9uID0gbmV3IFRlbXBvcmFsRHVyYXRpb24oeWVhcnMsIG1vbnRocywgd2Vla3MsIGRheXMsIDAsIDAsIDAsIDAsIDAsIDApO1xuICAgIGNvbnN0IGFkZGVkRGF0ZSA9IENhbGVuZGFyRGF0ZUFkZChjYWxlbmRhciwgZGF0ZVBhcnQsIGRhdGVEdXJhdGlvbiwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgeWVhcjogR2V0U2xvdChhZGRlZERhdGUsIElTT19ZRUFSKSxcbiAgICAgICAgbW9udGg6IEdldFNsb3QoYWRkZWREYXRlLCBJU09fTU9OVEgpLFxuICAgICAgICBkYXk6IEdldFNsb3QoYWRkZWREYXRlLCBJU09fREFZKSxcbiAgICAgICAgaG91cixcbiAgICAgICAgbWludXRlLFxuICAgICAgICBzZWNvbmQsXG4gICAgICAgIG1pbGxpc2Vjb25kLFxuICAgICAgICBtaWNyb3NlY29uZCxcbiAgICAgICAgbmFub3NlY29uZFxuICAgIH07XG59XG5mdW5jdGlvbiBBZGRab25lZERhdGVUaW1lKGluc3RhbnQsIHRpbWVab25lLCBjYWxlbmRhciwgeWVhcnMsIG1vbnRocywgd2Vla3MsIGRheXMsIGgsIG1pbiwgcywgbXMsIMK1cywgbnMsIG9wdGlvbnMpIHtcbiAgICAvLyBJZiBvbmx5IHRpbWUgaXMgdG8gYmUgYWRkZWQsIHRoZW4gdXNlIEluc3RhbnQgbWF0aC4gSXQncyBub3QgT0sgdG8gZmFsbFxuICAgIC8vIHRocm91Z2ggdG8gdGhlIGRhdGUvdGltZSBjb2RlIGJlbG93IGJlY2F1c2UgY29tcGF0aWJsZSBkaXNhbWJpZ3VhdGlvbiBpblxuICAgIC8vIHRoZSBQbGFpbkRhdGVUaW1lPT5JbnN0YW50IGNvbnZlcnNpb24gd2lsbCBjaGFuZ2UgdGhlIG9mZnNldCBvZiBhbnlcbiAgICAvLyBab25lZERhdGVUaW1lIGluIHRoZSByZXBlYXRlZCBjbG9jayB0aW1lIGFmdGVyIGEgYmFja3dhcmRzIHRyYW5zaXRpb24uXG4gICAgLy8gV2hlbiBhZGRpbmcvc3VidHJhY3RpbmcgdGltZSB1bml0cyBhbmQgbm90IGRhdGVzLCB0aGlzIGRpc2FtYmlndWF0aW9uIGlzXG4gICAgLy8gbm90IGV4cGVjdGVkIGFuZCBzbyBpcyBhdm9pZGVkIGJlbG93IHZpYSBhIGZhc3QgcGF0aCBmb3IgdGltZS1vbmx5XG4gICAgLy8gYXJpdGhtZXRpYy5cbiAgICAvLyBCVFcsIHRoaXMgYmVoYXZpb3IgaXMgc2ltaWxhciBpbiBzcGlyaXQgdG8gb2Zmc2V0OiAncHJlZmVyJyBpbiBgd2l0aGAuXG4gICAgY29uc3QgVGVtcG9yYWxEdXJhdGlvbiA9IEdldEludHJpbnNpYygnJVRlbXBvcmFsLkR1cmF0aW9uJScpO1xuICAgIGlmIChEdXJhdGlvblNpZ24oeWVhcnMsIG1vbnRocywgd2Vla3MsIGRheXMsIDAsIDAsIDAsIDAsIDAsIDApID09PSAwKSB7XG4gICAgICAgIHJldHVybiBBZGRJbnN0YW50KEdldFNsb3QoaW5zdGFudCwgRVBPQ0hOQU5PU0VDT05EUyksIGgsIG1pbiwgcywgbXMsIMK1cywgbnMpO1xuICAgIH1cbiAgICAvLyBSRkMgNTU0NSByZXF1aXJlcyB0aGUgZGF0ZSBwb3J0aW9uIHRvIGJlIGFkZGVkIGluIGNhbGVuZGFyIGRheXMgYW5kIHRoZVxuICAgIC8vIHRpbWUgcG9ydGlvbiB0byBiZSBhZGRlZCBpbiBleGFjdCB0aW1lLlxuICAgIGNvbnN0IGR0ID0gQnVpbHRpblRpbWVab25lR2V0UGxhaW5EYXRlVGltZUZvcih0aW1lWm9uZSwgaW5zdGFudCwgY2FsZW5kYXIpO1xuICAgIGNvbnN0IGRhdGVQYXJ0ID0gQ3JlYXRlVGVtcG9yYWxEYXRlKEdldFNsb3QoZHQsIElTT19ZRUFSKSwgR2V0U2xvdChkdCwgSVNPX01PTlRIKSwgR2V0U2xvdChkdCwgSVNPX0RBWSksIGNhbGVuZGFyKTtcbiAgICBjb25zdCBkYXRlRHVyYXRpb24gPSBuZXcgVGVtcG9yYWxEdXJhdGlvbih5ZWFycywgbW9udGhzLCB3ZWVrcywgZGF5cywgMCwgMCwgMCwgMCwgMCwgMCk7XG4gICAgY29uc3QgYWRkZWREYXRlID0gQ2FsZW5kYXJEYXRlQWRkKGNhbGVuZGFyLCBkYXRlUGFydCwgZGF0ZUR1cmF0aW9uLCBvcHRpb25zKTtcbiAgICBjb25zdCBkdEludGVybWVkaWF0ZSA9IENyZWF0ZVRlbXBvcmFsRGF0ZVRpbWUoR2V0U2xvdChhZGRlZERhdGUsIElTT19ZRUFSKSwgR2V0U2xvdChhZGRlZERhdGUsIElTT19NT05USCksIEdldFNsb3QoYWRkZWREYXRlLCBJU09fREFZKSwgR2V0U2xvdChkdCwgSVNPX0hPVVIpLCBHZXRTbG90KGR0LCBJU09fTUlOVVRFKSwgR2V0U2xvdChkdCwgSVNPX1NFQ09ORCksIEdldFNsb3QoZHQsIElTT19NSUxMSVNFQ09ORCksIEdldFNsb3QoZHQsIElTT19NSUNST1NFQ09ORCksIEdldFNsb3QoZHQsIElTT19OQU5PU0VDT05EKSwgY2FsZW5kYXIpO1xuICAgIC8vIE5vdGUgdGhhdCAnY29tcGF0aWJsZScgaXMgdXNlZCBiZWxvdyBiZWNhdXNlIHRoaXMgZGlzYW1iaWd1YXRpb24gYmVoYXZpb3JcbiAgICAvLyBpcyByZXF1aXJlZCBieSBSRkMgNTU0NS5cbiAgICBjb25zdCBpbnN0YW50SW50ZXJtZWRpYXRlID0gQnVpbHRpblRpbWVab25lR2V0SW5zdGFudEZvcih0aW1lWm9uZSwgZHRJbnRlcm1lZGlhdGUsICdjb21wYXRpYmxlJyk7XG4gICAgcmV0dXJuIEFkZEluc3RhbnQoR2V0U2xvdChpbnN0YW50SW50ZXJtZWRpYXRlLCBFUE9DSE5BTk9TRUNPTkRTKSwgaCwgbWluLCBzLCBtcywgwrVzLCBucyk7XG59XG5mdW5jdGlvbiBSb3VuZE51bWJlclRvSW5jcmVtZW50KHF1YW50aXR5LCBpbmNyZW1lbnQsIG1vZGUpIHtcbiAgICBpZiAoaW5jcmVtZW50ID09PSAxKVxuICAgICAgICByZXR1cm4gcXVhbnRpdHk7XG4gICAgbGV0IHsgcXVvdGllbnQsIHJlbWFpbmRlciB9ID0gZGl2bW9kKHF1YW50aXR5LCBKU0JJLkJpZ0ludChpbmNyZW1lbnQpKTtcbiAgICBpZiAoSlNCSS5lcXVhbChyZW1haW5kZXIsIFpFUk8pKVxuICAgICAgICByZXR1cm4gcXVhbnRpdHk7XG4gICAgY29uc3Qgc2lnbiA9IEpTQkkubGVzc1RoYW4ocmVtYWluZGVyLCBaRVJPKSA/IC0xIDogMTtcbiAgICBzd2l0Y2ggKG1vZGUpIHtcbiAgICAgICAgY2FzZSAnY2VpbCc6XG4gICAgICAgICAgICBpZiAoc2lnbiA+IDApXG4gICAgICAgICAgICAgICAgcXVvdGllbnQgPSBKU0JJLmFkZChxdW90aWVudCwgSlNCSS5CaWdJbnQoc2lnbikpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2Zsb29yJzpcbiAgICAgICAgICAgIGlmIChzaWduIDwgMClcbiAgICAgICAgICAgICAgICBxdW90aWVudCA9IEpTQkkuYWRkKHF1b3RpZW50LCBKU0JJLkJpZ0ludChzaWduKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAndHJ1bmMnOlxuICAgICAgICAgICAgLy8gbm8gY2hhbmdlIG5lZWRlZCwgYmVjYXVzZSBkaXZtb2QgaXMgYSB0cnVuY2F0aW9uXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnaGFsZkV4cGFuZCc6XG4gICAgICAgICAgICAvLyBcImhhbGYgdXAgYXdheSBmcm9tIHplcm9cIlxuICAgICAgICAgICAgaWYgKEpTQkkudG9OdW1iZXIoYWJzKEpTQkkubXVsdGlwbHkocmVtYWluZGVyLCBKU0JJLkJpZ0ludCgyKSkpKSA+PSBpbmNyZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBxdW90aWVudCA9IEpTQkkuYWRkKHF1b3RpZW50LCBKU0JJLkJpZ0ludChzaWduKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIEpTQkkubXVsdGlwbHkocXVvdGllbnQsIEpTQkkuQmlnSW50KGluY3JlbWVudCkpO1xufVxuZnVuY3Rpb24gUm91bmRJbnN0YW50KGVwb2NoTnMsIGluY3JlbWVudCwgdW5pdCwgcm91bmRpbmdNb2RlKSB7XG4gICAgLy8gTm90ZTogTm9uTmVnYXRpdmVNb2R1bG8sIGJ1dCB3aXRoIEJpZ0ludFxuICAgIGxldCByZW1haW5kZXIgPSBKU0JJLnJlbWFpbmRlcihlcG9jaE5zLCBKU0JJLkJpZ0ludCg4NjQwMGU5KSk7XG4gICAgaWYgKEpTQkkubGVzc1RoYW4ocmVtYWluZGVyLCBaRVJPKSlcbiAgICAgICAgcmVtYWluZGVyID0gSlNCSS5hZGQocmVtYWluZGVyLCBKU0JJLkJpZ0ludCg4NjQwMGU5KSk7XG4gICAgY29uc3Qgd2hvbGVEYXlzID0gSlNCSS5zdWJ0cmFjdChlcG9jaE5zLCByZW1haW5kZXIpO1xuICAgIGNvbnN0IHJvdW5kZWRSZW1haW5kZXIgPSBSb3VuZE51bWJlclRvSW5jcmVtZW50KHJlbWFpbmRlciwgbnNQZXJUaW1lVW5pdFt1bml0XSAqIGluY3JlbWVudCwgcm91bmRpbmdNb2RlKTtcbiAgICByZXR1cm4gSlNCSS5hZGQod2hvbGVEYXlzLCByb3VuZGVkUmVtYWluZGVyKTtcbn1cbmZ1bmN0aW9uIFJvdW5kSVNPRGF0ZVRpbWUoeWVhclBhcmFtLCBtb250aFBhcmFtLCBkYXlQYXJhbSwgaG91clBhcmFtLCBtaW51dGVQYXJhbSwgc2Vjb25kUGFyYW0sIG1pbGxpc2Vjb25kUGFyYW0sIG1pY3Jvc2Vjb25kUGFyYW0sIG5hbm9zZWNvbmRQYXJhbSwgaW5jcmVtZW50LCB1bml0LCByb3VuZGluZ01vZGUsIGRheUxlbmd0aE5zID0gODY0MDBlOSkge1xuICAgIGNvbnN0IHsgZGVsdGFEYXlzLCBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQsIG1pY3Jvc2Vjb25kLCBuYW5vc2Vjb25kIH0gPSBSb3VuZFRpbWUoaG91clBhcmFtLCBtaW51dGVQYXJhbSwgc2Vjb25kUGFyYW0sIG1pbGxpc2Vjb25kUGFyYW0sIG1pY3Jvc2Vjb25kUGFyYW0sIG5hbm9zZWNvbmRQYXJhbSwgaW5jcmVtZW50LCB1bml0LCByb3VuZGluZ01vZGUsIGRheUxlbmd0aE5zKTtcbiAgICBjb25zdCB7IHllYXIsIG1vbnRoLCBkYXkgfSA9IEJhbGFuY2VJU09EYXRlKHllYXJQYXJhbSwgbW9udGhQYXJhbSwgZGF5UGFyYW0gKyBkZWx0YURheXMpO1xuICAgIHJldHVybiB7IHllYXIsIG1vbnRoLCBkYXksIGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZCwgbWljcm9zZWNvbmQsIG5hbm9zZWNvbmQgfTtcbn1cbmZ1bmN0aW9uIFJvdW5kVGltZShob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQsIG1pY3Jvc2Vjb25kLCBuYW5vc2Vjb25kLCBpbmNyZW1lbnQsIHVuaXQsIHJvdW5kaW5nTW9kZSwgZGF5TGVuZ3RoTnMgPSA4NjQwMGU5KSB7XG4gICAgbGV0IHF1YW50aXR5ID0gWkVSTztcbiAgICBzd2l0Y2ggKHVuaXQpIHtcbiAgICAgICAgY2FzZSAnZGF5JzpcbiAgICAgICAgY2FzZSAnaG91cic6XG4gICAgICAgICAgICBxdWFudGl0eSA9IEpTQkkuQmlnSW50KGhvdXIpO1xuICAgICAgICAvLyBmYWxsIHRocm91Z2hcbiAgICAgICAgY2FzZSAnbWludXRlJzpcbiAgICAgICAgICAgIHF1YW50aXR5ID0gSlNCSS5hZGQoSlNCSS5tdWx0aXBseShxdWFudGl0eSwgU0lYVFkpLCBKU0JJLkJpZ0ludChtaW51dGUpKTtcbiAgICAgICAgLy8gZmFsbCB0aHJvdWdoXG4gICAgICAgIGNhc2UgJ3NlY29uZCc6XG4gICAgICAgICAgICBxdWFudGl0eSA9IEpTQkkuYWRkKEpTQkkubXVsdGlwbHkocXVhbnRpdHksIFNJWFRZKSwgSlNCSS5CaWdJbnQoc2Vjb25kKSk7XG4gICAgICAgIC8vIGZhbGwgdGhyb3VnaFxuICAgICAgICBjYXNlICdtaWxsaXNlY29uZCc6XG4gICAgICAgICAgICBxdWFudGl0eSA9IEpTQkkuYWRkKEpTQkkubXVsdGlwbHkocXVhbnRpdHksIFRIT1VTQU5EKSwgSlNCSS5CaWdJbnQobWlsbGlzZWNvbmQpKTtcbiAgICAgICAgLy8gZmFsbCB0aHJvdWdoXG4gICAgICAgIGNhc2UgJ21pY3Jvc2Vjb25kJzpcbiAgICAgICAgICAgIHF1YW50aXR5ID0gSlNCSS5hZGQoSlNCSS5tdWx0aXBseShxdWFudGl0eSwgVEhPVVNBTkQpLCBKU0JJLkJpZ0ludChtaWNyb3NlY29uZCkpO1xuICAgICAgICAvLyBmYWxsIHRocm91Z2hcbiAgICAgICAgY2FzZSAnbmFub3NlY29uZCc6XG4gICAgICAgICAgICBxdWFudGl0eSA9IEpTQkkuYWRkKEpTQkkubXVsdGlwbHkocXVhbnRpdHksIFRIT1VTQU5EKSwgSlNCSS5CaWdJbnQobmFub3NlY29uZCkpO1xuICAgIH1cbiAgICBjb25zdCBuc1BlclVuaXQgPSB1bml0ID09PSAnZGF5JyA/IGRheUxlbmd0aE5zIDogbnNQZXJUaW1lVW5pdFt1bml0XTtcbiAgICBjb25zdCByb3VuZGVkID0gUm91bmROdW1iZXJUb0luY3JlbWVudChxdWFudGl0eSwgbnNQZXJVbml0ICogaW5jcmVtZW50LCByb3VuZGluZ01vZGUpO1xuICAgIGNvbnN0IHJlc3VsdCA9IEpTQkkudG9OdW1iZXIoSlNCSS5kaXZpZGUocm91bmRlZCwgSlNCSS5CaWdJbnQobnNQZXJVbml0KSkpO1xuICAgIHN3aXRjaCAodW5pdCkge1xuICAgICAgICBjYXNlICdkYXknOlxuICAgICAgICAgICAgcmV0dXJuIHsgZGVsdGFEYXlzOiByZXN1bHQsIGhvdXI6IDAsIG1pbnV0ZTogMCwgc2Vjb25kOiAwLCBtaWxsaXNlY29uZDogMCwgbWljcm9zZWNvbmQ6IDAsIG5hbm9zZWNvbmQ6IDAgfTtcbiAgICAgICAgY2FzZSAnaG91cic6XG4gICAgICAgICAgICByZXR1cm4gQmFsYW5jZVRpbWUocmVzdWx0LCAwLCAwLCAwLCAwLCAwKTtcbiAgICAgICAgY2FzZSAnbWludXRlJzpcbiAgICAgICAgICAgIHJldHVybiBCYWxhbmNlVGltZShob3VyLCByZXN1bHQsIDAsIDAsIDAsIDApO1xuICAgICAgICBjYXNlICdzZWNvbmQnOlxuICAgICAgICAgICAgcmV0dXJuIEJhbGFuY2VUaW1lKGhvdXIsIG1pbnV0ZSwgcmVzdWx0LCAwLCAwLCAwKTtcbiAgICAgICAgY2FzZSAnbWlsbGlzZWNvbmQnOlxuICAgICAgICAgICAgcmV0dXJuIEJhbGFuY2VUaW1lKGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCByZXN1bHQsIDAsIDApO1xuICAgICAgICBjYXNlICdtaWNyb3NlY29uZCc6XG4gICAgICAgICAgICByZXR1cm4gQmFsYW5jZVRpbWUoaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kLCByZXN1bHQsIDApO1xuICAgICAgICBjYXNlICduYW5vc2Vjb25kJzpcbiAgICAgICAgICAgIHJldHVybiBCYWxhbmNlVGltZShob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQsIG1pY3Jvc2Vjb25kLCByZXN1bHQpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHVuaXQgJHt1bml0fWApO1xuICAgIH1cbn1cbmZ1bmN0aW9uIERheXNVbnRpbChlYXJsaWVyLCBsYXRlcikge1xuICAgIHJldHVybiBEaWZmZXJlbmNlSVNPRGF0ZShHZXRTbG90KGVhcmxpZXIsIElTT19ZRUFSKSwgR2V0U2xvdChlYXJsaWVyLCBJU09fTU9OVEgpLCBHZXRTbG90KGVhcmxpZXIsIElTT19EQVkpLCBHZXRTbG90KGxhdGVyLCBJU09fWUVBUiksIEdldFNsb3QobGF0ZXIsIElTT19NT05USCksIEdldFNsb3QobGF0ZXIsIElTT19EQVkpLCAnZGF5JykuZGF5cztcbn1cbmZ1bmN0aW9uIE1vdmVSZWxhdGl2ZURhdGUoY2FsZW5kYXIsIHJlbGF0aXZlVG9QYXJhbSwgZHVyYXRpb24pIHtcbiAgICBjb25zdCBvcHRpb25zID0gT2JqZWN0Q3JlYXRlJDIobnVsbCk7XG4gICAgY29uc3QgbGF0ZXIgPSBDYWxlbmRhckRhdGVBZGQoY2FsZW5kYXIsIHJlbGF0aXZlVG9QYXJhbSwgZHVyYXRpb24sIG9wdGlvbnMpO1xuICAgIGNvbnN0IGRheXMgPSBEYXlzVW50aWwocmVsYXRpdmVUb1BhcmFtLCBsYXRlcik7XG4gICAgcmV0dXJuIHsgcmVsYXRpdmVUbzogbGF0ZXIsIGRheXMgfTtcbn1cbmZ1bmN0aW9uIE1vdmVSZWxhdGl2ZVpvbmVkRGF0ZVRpbWUocmVsYXRpdmVUbywgeWVhcnMsIG1vbnRocywgd2Vla3MsIGRheXMpIHtcbiAgICBjb25zdCB0aW1lWm9uZSA9IEdldFNsb3QocmVsYXRpdmVUbywgVElNRV9aT05FKTtcbiAgICBjb25zdCBjYWxlbmRhciA9IEdldFNsb3QocmVsYXRpdmVUbywgQ0FMRU5EQVIpO1xuICAgIGNvbnN0IGludGVybWVkaWF0ZU5zID0gQWRkWm9uZWREYXRlVGltZShHZXRTbG90KHJlbGF0aXZlVG8sIElOU1RBTlQpLCB0aW1lWm9uZSwgY2FsZW5kYXIsIHllYXJzLCBtb250aHMsIHdlZWtzLCBkYXlzLCAwLCAwLCAwLCAwLCAwLCAwKTtcbiAgICByZXR1cm4gQ3JlYXRlVGVtcG9yYWxab25lZERhdGVUaW1lKGludGVybWVkaWF0ZU5zLCB0aW1lWm9uZSwgY2FsZW5kYXIpO1xufVxuZnVuY3Rpb24gQWRqdXN0Um91bmRlZER1cmF0aW9uRGF5cyh5ZWFyc1BhcmFtLCBtb250aHNQYXJhbSwgd2Vla3NQYXJhbSwgZGF5c1BhcmFtLCBob3Vyc1BhcmFtLCBtaW51dGVzUGFyYW0sIHNlY29uZHNQYXJhbSwgbWlsbGlzZWNvbmRzUGFyYW0sIG1pY3Jvc2Vjb25kc1BhcmFtLCBuYW5vc2Vjb25kc1BhcmFtLCBpbmNyZW1lbnQsIHVuaXQsIHJvdW5kaW5nTW9kZSwgcmVsYXRpdmVUbykge1xuICAgIGxldCB5ZWFycyA9IHllYXJzUGFyYW07XG4gICAgbGV0IG1vbnRocyA9IG1vbnRoc1BhcmFtO1xuICAgIGxldCB3ZWVrcyA9IHdlZWtzUGFyYW07XG4gICAgbGV0IGRheXMgPSBkYXlzUGFyYW07XG4gICAgbGV0IGhvdXJzID0gaG91cnNQYXJhbTtcbiAgICBsZXQgbWludXRlcyA9IG1pbnV0ZXNQYXJhbTtcbiAgICBsZXQgc2Vjb25kcyA9IHNlY29uZHNQYXJhbTtcbiAgICBsZXQgbWlsbGlzZWNvbmRzID0gbWlsbGlzZWNvbmRzUGFyYW07XG4gICAgbGV0IG1pY3Jvc2Vjb25kcyA9IG1pY3Jvc2Vjb25kc1BhcmFtO1xuICAgIGxldCBuYW5vc2Vjb25kcyA9IG5hbm9zZWNvbmRzUGFyYW07XG4gICAgaWYgKCFJc1RlbXBvcmFsWm9uZWREYXRlVGltZShyZWxhdGl2ZVRvKSB8fFxuICAgICAgICB1bml0ID09PSAneWVhcicgfHxcbiAgICAgICAgdW5pdCA9PT0gJ21vbnRoJyB8fFxuICAgICAgICB1bml0ID09PSAnd2VlaycgfHxcbiAgICAgICAgdW5pdCA9PT0gJ2RheScgfHxcbiAgICAgICAgKHVuaXQgPT09ICduYW5vc2Vjb25kJyAmJiBpbmNyZW1lbnQgPT09IDEpKSB7XG4gICAgICAgIHJldHVybiB7IHllYXJzLCBtb250aHMsIHdlZWtzLCBkYXlzLCBob3VycywgbWludXRlcywgc2Vjb25kcywgbWlsbGlzZWNvbmRzLCBtaWNyb3NlY29uZHMsIG5hbm9zZWNvbmRzIH07XG4gICAgfVxuICAgIC8vIFRoZXJlJ3Mgb25lIG1vcmUgcm91bmQgb2Ygcm91bmRpbmcgcG9zc2libGU6IGlmIHJlbGF0aXZlVG8gaXMgYVxuICAgIC8vIFpvbmVkRGF0ZVRpbWUsIHRoZSB0aW1lIHVuaXRzIGNvdWxkIGhhdmUgcm91bmRlZCB1cCBpbnRvIGVub3VnaCBob3Vyc1xuICAgIC8vIHRvIGV4Y2VlZCB0aGUgZGF5IGxlbmd0aC4gSWYgdGhpcyBoYXBwZW5zLCBncm93IHRoZSBkYXRlIHBhcnQgYnkgYVxuICAgIC8vIHNpbmdsZSBkYXkgYW5kIHJlLXJ1biBleGFjdCB0aW1lIHJvdW5kaW5nIG9uIHRoZSBzbWFsbGVyIHJlbWFpbmRlci4gRE9cbiAgICAvLyBOT1QgUkVDVVJTRSwgYmVjYXVzZSBvbmNlIHRoZSBleHRyYSBob3VycyBhcmUgc3Vja2VkIHVwIGludG8gdGhlIGRhdGVcbiAgICAvLyBkdXJhdGlvbiwgdGhlcmUncyBubyB3YXkgZm9yIGFub3RoZXIgZnVsbCBkYXkgdG8gY29tZSBmcm9tIHRoZSBuZXh0XG4gICAgLy8gcm91bmQgb2Ygcm91bmRpbmcuIEFuZCBpZiBpdCB3ZXJlIHBvc3NpYmxlIChlLmcuIGNvbnRyaXZlZCBjYWxlbmRhclxuICAgIC8vIHdpdGggMzAtbWludXRlLWxvbmcgXCJkYXlzXCIpIHRoZW4gaXQnZCByaXNrIGFuIGluZmluaXRlIGxvb3AuXG4gICAgbGV0IHRpbWVSZW1haW5kZXJOcyA9IFRvdGFsRHVyYXRpb25OYW5vc2Vjb25kcygwLCBob3VycywgbWludXRlcywgc2Vjb25kcywgbWlsbGlzZWNvbmRzLCBtaWNyb3NlY29uZHMsIG5hbm9zZWNvbmRzLCAwKTtcbiAgICBjb25zdCBkaXJlY3Rpb24gPSBNYXRoU2lnbihKU0JJLnRvTnVtYmVyKHRpbWVSZW1haW5kZXJOcykpO1xuICAgIGNvbnN0IHRpbWVab25lID0gR2V0U2xvdChyZWxhdGl2ZVRvLCBUSU1FX1pPTkUpO1xuICAgIGNvbnN0IGNhbGVuZGFyID0gR2V0U2xvdChyZWxhdGl2ZVRvLCBDQUxFTkRBUik7XG4gICAgY29uc3QgZGF5U3RhcnQgPSBBZGRab25lZERhdGVUaW1lKEdldFNsb3QocmVsYXRpdmVUbywgSU5TVEFOVCksIHRpbWVab25lLCBjYWxlbmRhciwgeWVhcnMsIG1vbnRocywgd2Vla3MsIGRheXMsIDAsIDAsIDAsIDAsIDAsIDApO1xuICAgIGNvbnN0IFRlbXBvcmFsSW5zdGFudCA9IEdldEludHJpbnNpYygnJVRlbXBvcmFsLkluc3RhbnQlJyk7XG4gICAgY29uc3QgZGF5RW5kID0gQWRkWm9uZWREYXRlVGltZShuZXcgVGVtcG9yYWxJbnN0YW50KGRheVN0YXJ0KSwgdGltZVpvbmUsIGNhbGVuZGFyLCAwLCAwLCAwLCBkaXJlY3Rpb24sIDAsIDAsIDAsIDAsIDAsIDApO1xuICAgIGNvbnN0IGRheUxlbmd0aE5zID0gSlNCSS5zdWJ0cmFjdChkYXlFbmQsIGRheVN0YXJ0KTtcbiAgICBpZiAoSlNCSS5ncmVhdGVyVGhhbk9yRXF1YWwoSlNCSS5tdWx0aXBseShKU0JJLnN1YnRyYWN0KHRpbWVSZW1haW5kZXJOcywgZGF5TGVuZ3RoTnMpLCBKU0JJLkJpZ0ludChkaXJlY3Rpb24pKSwgWkVSTykpIHtcbiAgICAgICAgKHsgeWVhcnMsIG1vbnRocywgd2Vla3MsIGRheXMgfSA9IEFkZER1cmF0aW9uKHllYXJzLCBtb250aHMsIHdlZWtzLCBkYXlzLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCBkaXJlY3Rpb24sIDAsIDAsIDAsIDAsIDAsIDAsIHJlbGF0aXZlVG8pKTtcbiAgICAgICAgdGltZVJlbWFpbmRlck5zID0gUm91bmRJbnN0YW50KEpTQkkuc3VidHJhY3QodGltZVJlbWFpbmRlck5zLCBkYXlMZW5ndGhOcyksIGluY3JlbWVudCwgdW5pdCwgcm91bmRpbmdNb2RlKTtcbiAgICAgICAgKHsgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc2Vjb25kcywgbWljcm9zZWNvbmRzLCBuYW5vc2Vjb25kcyB9ID0gQmFsYW5jZUR1cmF0aW9uKDAsIDAsIDAsIDAsIDAsIDAsIEpTQkkudG9OdW1iZXIodGltZVJlbWFpbmRlck5zKSwgJ2hvdXInKSk7XG4gICAgfVxuICAgIHJldHVybiB7IHllYXJzLCBtb250aHMsIHdlZWtzLCBkYXlzLCBob3VycywgbWludXRlcywgc2Vjb25kcywgbWlsbGlzZWNvbmRzLCBtaWNyb3NlY29uZHMsIG5hbm9zZWNvbmRzIH07XG59XG5mdW5jdGlvbiBSb3VuZER1cmF0aW9uKHllYXJzUGFyYW0sIG1vbnRoc1BhcmFtLCB3ZWVrc1BhcmFtLCBkYXlzUGFyYW0sIGhvdXJzUGFyYW0sIG1pbnV0ZXNQYXJhbSwgc2Vjb25kc1BhcmFtLCBtaWxsaXNlY29uZHNQYXJhbSwgbWljcm9zZWNvbmRzUGFyYW0sIG5hbm9zZWNvbmRzUGFyYW0sIGluY3JlbWVudCwgdW5pdCwgcm91bmRpbmdNb2RlLCByZWxhdGl2ZVRvUGFyYW0gPSB1bmRlZmluZWQpIHtcbiAgICBsZXQgeWVhcnMgPSB5ZWFyc1BhcmFtO1xuICAgIGxldCBtb250aHMgPSBtb250aHNQYXJhbTtcbiAgICBsZXQgd2Vla3MgPSB3ZWVrc1BhcmFtO1xuICAgIGxldCBkYXlzID0gZGF5c1BhcmFtO1xuICAgIGxldCBob3VycyA9IGhvdXJzUGFyYW07XG4gICAgbGV0IG1pbnV0ZXMgPSBtaW51dGVzUGFyYW07XG4gICAgbGV0IHNlY29uZHMgPSBzZWNvbmRzUGFyYW07XG4gICAgbGV0IG1pbGxpc2Vjb25kcyA9IG1pbGxpc2Vjb25kc1BhcmFtO1xuICAgIGxldCBtaWNyb3NlY29uZHMgPSBtaWNyb3NlY29uZHNQYXJhbTtcbiAgICBsZXQgbmFub3NlY29uZHMgPSBKU0JJLkJpZ0ludChuYW5vc2Vjb25kc1BhcmFtKTtcbiAgICBjb25zdCBUZW1wb3JhbER1cmF0aW9uID0gR2V0SW50cmluc2ljKCclVGVtcG9yYWwuRHVyYXRpb24lJyk7XG4gICAgbGV0IGNhbGVuZGFyLCB6ZHRSZWxhdGl2ZTtcbiAgICAvLyBBIGNhc3QgaXMgdXNlZCBiZWxvdyBiZWNhdXNlIHJlbGF0aXZlVG8gd2lsbCBiZSBlaXRoZXIgUGxhaW5EYXRlIG9yXG4gICAgLy8gdW5kZWZpbmVkIGZvciB0aGUgcmVzdCBvZiB0aGlzIGxvbmcgbWV0aG9kIChhZnRlciBhbnkgWkRUPT5QbGFpbkRhdGVcbiAgICAvLyBjb252ZXJzaW9uIGJlbG93KSwgYW5kIFRTIGlzbid0IHNtYXJ0IGVub3VnaCB0byBrbm93IHRoYXQgdGhlIHR5cGUgaGFzXG4gICAgLy8gY2hhbmdlZC4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9taWNyb3NvZnQvVHlwZVNjcmlwdC9pc3N1ZXMvMjc3MDYuXG4gICAgbGV0IHJlbGF0aXZlVG8gPSByZWxhdGl2ZVRvUGFyYW07XG4gICAgaWYgKHJlbGF0aXZlVG8pIHtcbiAgICAgICAgaWYgKElzVGVtcG9yYWxab25lZERhdGVUaW1lKHJlbGF0aXZlVG8pKSB7XG4gICAgICAgICAgICB6ZHRSZWxhdGl2ZSA9IHJlbGF0aXZlVG87XG4gICAgICAgICAgICByZWxhdGl2ZVRvID0gVG9UZW1wb3JhbERhdGUocmVsYXRpdmVUbyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIUlzVGVtcG9yYWxEYXRlKHJlbGF0aXZlVG8pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdzdGFydGluZyBwb2ludCBtdXN0IGJlIFBsYWluRGF0ZSBvciBab25lZERhdGVUaW1lJyk7XG4gICAgICAgIH1cbiAgICAgICAgY2FsZW5kYXIgPSBHZXRTbG90KHJlbGF0aXZlVG8sIENBTEVOREFSKTtcbiAgICB9XG4gICAgLy8gRmlyc3QgY29udmVydCB0aW1lIHVuaXRzIHVwIHRvIGRheXMsIGlmIHJvdW5kaW5nIHRvIGRheXMgb3IgaGlnaGVyIHVuaXRzLlxuICAgIC8vIElmIHJvdW5kaW5nIHJlbGF0aXZlIHRvIGEgWm9uZWREYXRlVGltZSwgdGhlbiBzb21lIGRheXMgbWF5IG5vdCBiZSAyNGguXG4gICAgLy8gVFMgZG9lc24ndCBrbm93IHRoYXQgYGRheUxlbmd0aE5zYCBpcyBvbmx5IHVzZWQgaWYgdGhlIHVuaXQgaXMgZGF5IG9yXG4gICAgLy8gbGFyZ2VyLiBXZSdsbCBjYXN0IGF3YXkgYHVuZGVmaW5lZGAgd2hlbiBpdCdzIHVzZWQgbG93ZXIgZG93biBiZWxvdy5cbiAgICBsZXQgZGF5TGVuZ3RoTnM7XG4gICAgaWYgKHVuaXQgPT09ICd5ZWFyJyB8fCB1bml0ID09PSAnbW9udGgnIHx8IHVuaXQgPT09ICd3ZWVrJyB8fCB1bml0ID09PSAnZGF5Jykge1xuICAgICAgICBuYW5vc2Vjb25kcyA9IFRvdGFsRHVyYXRpb25OYW5vc2Vjb25kcygwLCBob3VycywgbWludXRlcywgc2Vjb25kcywgbWlsbGlzZWNvbmRzLCBtaWNyb3NlY29uZHMsIG5hbm9zZWNvbmRzUGFyYW0sIDApO1xuICAgICAgICBsZXQgaW50ZXJtZWRpYXRlO1xuICAgICAgICBpZiAoemR0UmVsYXRpdmUpIHtcbiAgICAgICAgICAgIGludGVybWVkaWF0ZSA9IE1vdmVSZWxhdGl2ZVpvbmVkRGF0ZVRpbWUoemR0UmVsYXRpdmUsIHllYXJzLCBtb250aHMsIHdlZWtzLCBkYXlzKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZGVsdGFEYXlzO1xuICAgICAgICBsZXQgZGF5TGVuZ3RoO1xuICAgICAgICAoeyBkYXlzOiBkZWx0YURheXMsIG5hbm9zZWNvbmRzLCBkYXlMZW5ndGhOczogZGF5TGVuZ3RoIH0gPSBOYW5vc2Vjb25kc1RvRGF5cyhuYW5vc2Vjb25kcywgaW50ZXJtZWRpYXRlKSk7XG4gICAgICAgIGRheUxlbmd0aE5zID0gSlNCSS5CaWdJbnQoZGF5TGVuZ3RoKTtcbiAgICAgICAgZGF5cyArPSBkZWx0YURheXM7XG4gICAgICAgIGhvdXJzID0gbWludXRlcyA9IHNlY29uZHMgPSBtaWxsaXNlY29uZHMgPSBtaWNyb3NlY29uZHMgPSAwO1xuICAgIH1cbiAgICBsZXQgdG90YWw7XG4gICAgc3dpdGNoICh1bml0KSB7XG4gICAgICAgIGNhc2UgJ3llYXInOiB7XG4gICAgICAgICAgICBpZiAoIWNhbGVuZGFyKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBIHN0YXJ0aW5nIHBvaW50IGlzIHJlcXVpcmVkIGZvciB5ZWFycyByb3VuZGluZycpO1xuICAgICAgICAgICAgLy8gY29udmVydCBtb250aHMgYW5kIHdlZWtzIHRvIGRheXMgYnkgY2FsY3VsYXRpbmcgZGlmZmVyZW5jZShcbiAgICAgICAgICAgIC8vIHJlbGF0aXZlVG8gKyB5ZWFycywgcmVsYXRpdmVUbyArIHsgeWVhcnMsIG1vbnRocywgd2Vla3MgfSlcbiAgICAgICAgICAgIGNvbnN0IHllYXJzRHVyYXRpb24gPSBuZXcgVGVtcG9yYWxEdXJhdGlvbih5ZWFycyk7XG4gICAgICAgICAgICBjb25zdCBkYXRlQWRkID0gY2FsZW5kYXIuZGF0ZUFkZDtcbiAgICAgICAgICAgIGNvbnN0IGZpcnN0QWRkT3B0aW9ucyA9IE9iamVjdENyZWF0ZSQyKG51bGwpO1xuICAgICAgICAgICAgY29uc3QgeWVhcnNMYXRlciA9IENhbGVuZGFyRGF0ZUFkZChjYWxlbmRhciwgcmVsYXRpdmVUbywgeWVhcnNEdXJhdGlvbiwgZmlyc3RBZGRPcHRpb25zLCBkYXRlQWRkKTtcbiAgICAgICAgICAgIGNvbnN0IHllYXJzTW9udGhzV2Vla3MgPSBuZXcgVGVtcG9yYWxEdXJhdGlvbih5ZWFycywgbW9udGhzLCB3ZWVrcyk7XG4gICAgICAgICAgICBjb25zdCBzZWNvbmRBZGRPcHRpb25zID0gT2JqZWN0Q3JlYXRlJDIobnVsbCk7XG4gICAgICAgICAgICBjb25zdCB5ZWFyc01vbnRoc1dlZWtzTGF0ZXIgPSBDYWxlbmRhckRhdGVBZGQoY2FsZW5kYXIsIHJlbGF0aXZlVG8sIHllYXJzTW9udGhzV2Vla3MsIHNlY29uZEFkZE9wdGlvbnMsIGRhdGVBZGQpO1xuICAgICAgICAgICAgY29uc3QgbW9udGhzV2Vla3NJbkRheXMgPSBEYXlzVW50aWwoeWVhcnNMYXRlciwgeWVhcnNNb250aHNXZWVrc0xhdGVyKTtcbiAgICAgICAgICAgIHJlbGF0aXZlVG8gPSB5ZWFyc0xhdGVyO1xuICAgICAgICAgICAgZGF5cyArPSBtb250aHNXZWVrc0luRGF5cztcbiAgICAgICAgICAgIGNvbnN0IHRoaXJkQWRkT3B0aW9ucyA9IE9iamVjdENyZWF0ZSQyKG51bGwpO1xuICAgICAgICAgICAgY29uc3QgZGF5c0xhdGVyID0gQ2FsZW5kYXJEYXRlQWRkKGNhbGVuZGFyLCByZWxhdGl2ZVRvLCB7IGRheXMgfSwgdGhpcmRBZGRPcHRpb25zLCBkYXRlQWRkKTtcbiAgICAgICAgICAgIGNvbnN0IHVudGlsT3B0aW9ucyA9IE9iamVjdENyZWF0ZSQyKG51bGwpO1xuICAgICAgICAgICAgdW50aWxPcHRpb25zLmxhcmdlc3RVbml0ID0gJ3llYXInO1xuICAgICAgICAgICAgY29uc3QgeWVhcnNQYXNzZWQgPSBDYWxlbmRhckRhdGVVbnRpbChjYWxlbmRhciwgcmVsYXRpdmVUbywgZGF5c0xhdGVyLCB1bnRpbE9wdGlvbnMpLnllYXJzO1xuICAgICAgICAgICAgeWVhcnMgKz0geWVhcnNQYXNzZWQ7XG4gICAgICAgICAgICBjb25zdCBvbGRSZWxhdGl2ZVRvID0gcmVsYXRpdmVUbztcbiAgICAgICAgICAgIGNvbnN0IGZvdXJ0aEFkZE9wdGlvbnMgPSBPYmplY3RDcmVhdGUkMihudWxsKTtcbiAgICAgICAgICAgIHJlbGF0aXZlVG8gPSBDYWxlbmRhckRhdGVBZGQoY2FsZW5kYXIsIHJlbGF0aXZlVG8sIHsgeWVhcnM6IHllYXJzUGFzc2VkIH0sIGZvdXJ0aEFkZE9wdGlvbnMsIGRhdGVBZGQpO1xuICAgICAgICAgICAgY29uc3QgZGF5c1Bhc3NlZCA9IERheXNVbnRpbChvbGRSZWxhdGl2ZVRvLCByZWxhdGl2ZVRvKTtcbiAgICAgICAgICAgIGRheXMgLT0gZGF5c1Bhc3NlZDtcbiAgICAgICAgICAgIGNvbnN0IG9uZVllYXIgPSBuZXcgVGVtcG9yYWxEdXJhdGlvbihkYXlzIDwgMCA/IC0xIDogMSk7XG4gICAgICAgICAgICBsZXQgeyBkYXlzOiBvbmVZZWFyRGF5cyB9ID0gTW92ZVJlbGF0aXZlRGF0ZShjYWxlbmRhciwgcmVsYXRpdmVUbywgb25lWWVhcik7XG4gICAgICAgICAgICAvLyBOb3RlIHRoYXQgYG5hbm9zZWNvbmRzYCBiZWxvdyAoaGVyZSBhbmQgaW4gc2ltaWxhciBjb2RlIGZvciBtb250aHMsXG4gICAgICAgICAgICAvLyB3ZWVrcywgYW5kIGRheXMgZnVydGhlciBiZWxvdykgaXNuJ3QgYWN0dWFsbHkgbmFub3NlY29uZHMgZm9yIHRoZVxuICAgICAgICAgICAgLy8gZnVsbCBkYXRlIHJhbmdlLiAgSW5zdGVhZCwgaXQncyBhIEJpZ0ludCByZXByZXNlbnRhdGlvbiBvZiB0b3RhbFxuICAgICAgICAgICAgLy8gZGF5cyBtdWx0aXBsaWVkIGJ5IHRoZSBudW1iZXIgb2YgbmFub3NlY29uZHMgaW4gdGhlIGxhc3QgZGF5IG9mXG4gICAgICAgICAgICAvLyB0aGUgZHVyYXRpb24uIFRoaXMgbGV0cyB1cyBkbyBkYXlzLW9yLWxhcmdlciByb3VuZGluZyB1c2luZyBCaWdJbnRcbiAgICAgICAgICAgIC8vIG1hdGggd2hpY2ggcmVkdWNlcyBwcmVjaXNpb24gbG9zcy5cbiAgICAgICAgICAgIG9uZVllYXJEYXlzID0gTWF0aEFicyhvbmVZZWFyRGF5cyk7XG4gICAgICAgICAgICAvLyBkYXlMZW5ndGhOcyBpcyBuZXZlciB1bmRlZmluZWQgaWYgdW5pdCBpcyBgZGF5YCBvciBsYXJnZXIuXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgICAgICAgY29uc3QgZGl2aXNvciA9IEpTQkkubXVsdGlwbHkoSlNCSS5CaWdJbnQob25lWWVhckRheXMpLCBkYXlMZW5ndGhOcyk7XG4gICAgICAgICAgICBuYW5vc2Vjb25kcyA9IEpTQkkuYWRkKFxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICAgICAgICAgIEpTQkkuYWRkKEpTQkkubXVsdGlwbHkoZGl2aXNvciwgSlNCSS5CaWdJbnQoeWVhcnMpKSwgSlNCSS5tdWx0aXBseShKU0JJLkJpZ0ludChkYXlzKSwgZGF5TGVuZ3RoTnMpKSwgbmFub3NlY29uZHMpO1xuICAgICAgICAgICAgY29uc3Qgcm91bmRlZCA9IFJvdW5kTnVtYmVyVG9JbmNyZW1lbnQobmFub3NlY29uZHMsIEpTQkkudG9OdW1iZXIoSlNCSS5tdWx0aXBseShkaXZpc29yLCBKU0JJLkJpZ0ludChpbmNyZW1lbnQpKSksIHJvdW5kaW5nTW9kZSk7XG4gICAgICAgICAgICB0b3RhbCA9IEpTQkkudG9OdW1iZXIobmFub3NlY29uZHMpIC8gSlNCSS50b051bWJlcihkaXZpc29yKTtcbiAgICAgICAgICAgIHllYXJzID0gSlNCSS50b051bWJlcihKU0JJLmRpdmlkZShyb3VuZGVkLCBkaXZpc29yKSk7XG4gICAgICAgICAgICBuYW5vc2Vjb25kcyA9IFpFUk87XG4gICAgICAgICAgICBtb250aHMgPSB3ZWVrcyA9IGRheXMgPSAwO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnbW9udGgnOiB7XG4gICAgICAgICAgICBpZiAoIWNhbGVuZGFyKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBIHN0YXJ0aW5nIHBvaW50IGlzIHJlcXVpcmVkIGZvciBtb250aHMgcm91bmRpbmcnKTtcbiAgICAgICAgICAgIC8vIGNvbnZlcnQgd2Vla3MgdG8gZGF5cyBieSBjYWxjdWxhdGluZyBkaWZmZXJlbmNlKHJlbGF0aXZlVG8gK1xuICAgICAgICAgICAgLy8gICB7IHllYXJzLCBtb250aHMgfSwgcmVsYXRpdmVUbyArIHsgeWVhcnMsIG1vbnRocywgd2Vla3MgfSlcbiAgICAgICAgICAgIGNvbnN0IHllYXJzTW9udGhzID0gbmV3IFRlbXBvcmFsRHVyYXRpb24oeWVhcnMsIG1vbnRocyk7XG4gICAgICAgICAgICBjb25zdCBkYXRlQWRkID0gY2FsZW5kYXIuZGF0ZUFkZDtcbiAgICAgICAgICAgIGNvbnN0IGZpcnN0QWRkT3B0aW9ucyA9IE9iamVjdENyZWF0ZSQyKG51bGwpO1xuICAgICAgICAgICAgY29uc3QgeWVhcnNNb250aHNMYXRlciA9IENhbGVuZGFyRGF0ZUFkZChjYWxlbmRhciwgcmVsYXRpdmVUbywgeWVhcnNNb250aHMsIGZpcnN0QWRkT3B0aW9ucywgZGF0ZUFkZCk7XG4gICAgICAgICAgICBjb25zdCB5ZWFyc01vbnRoc1dlZWtzID0gbmV3IFRlbXBvcmFsRHVyYXRpb24oeWVhcnMsIG1vbnRocywgd2Vla3MpO1xuICAgICAgICAgICAgY29uc3Qgc2Vjb25kQWRkT3B0aW9ucyA9IE9iamVjdENyZWF0ZSQyKG51bGwpO1xuICAgICAgICAgICAgY29uc3QgeWVhcnNNb250aHNXZWVrc0xhdGVyID0gQ2FsZW5kYXJEYXRlQWRkKGNhbGVuZGFyLCByZWxhdGl2ZVRvLCB5ZWFyc01vbnRoc1dlZWtzLCBzZWNvbmRBZGRPcHRpb25zLCBkYXRlQWRkKTtcbiAgICAgICAgICAgIGNvbnN0IHdlZWtzSW5EYXlzID0gRGF5c1VudGlsKHllYXJzTW9udGhzTGF0ZXIsIHllYXJzTW9udGhzV2Vla3NMYXRlcik7XG4gICAgICAgICAgICByZWxhdGl2ZVRvID0geWVhcnNNb250aHNMYXRlcjtcbiAgICAgICAgICAgIGRheXMgKz0gd2Vla3NJbkRheXM7XG4gICAgICAgICAgICAvLyBNb250aHMgbWF5IGJlIGRpZmZlcmVudCBsZW5ndGhzIG9mIGRheXMgZGVwZW5kaW5nIG9uIHRoZSBjYWxlbmRhcixcbiAgICAgICAgICAgIC8vIGNvbnZlcnQgZGF5cyB0byBtb250aHMgaW4gYSBsb29wIGFzIGRlc2NyaWJlZCBhYm92ZSB1bmRlciAneWVhcnMnLlxuICAgICAgICAgICAgY29uc3Qgc2lnbiA9IE1hdGhTaWduKGRheXMpO1xuICAgICAgICAgICAgY29uc3Qgb25lTW9udGggPSBuZXcgVGVtcG9yYWxEdXJhdGlvbigwLCBkYXlzIDwgMCA/IC0xIDogMSk7XG4gICAgICAgICAgICBsZXQgb25lTW9udGhEYXlzO1xuICAgICAgICAgICAgKHsgcmVsYXRpdmVUbywgZGF5czogb25lTW9udGhEYXlzIH0gPSBNb3ZlUmVsYXRpdmVEYXRlKGNhbGVuZGFyLCByZWxhdGl2ZVRvLCBvbmVNb250aCkpO1xuICAgICAgICAgICAgd2hpbGUgKE1hdGhBYnMoZGF5cykgPj0gTWF0aEFicyhvbmVNb250aERheXMpKSB7XG4gICAgICAgICAgICAgICAgbW9udGhzICs9IHNpZ247XG4gICAgICAgICAgICAgICAgZGF5cyAtPSBvbmVNb250aERheXM7XG4gICAgICAgICAgICAgICAgKHsgcmVsYXRpdmVUbywgZGF5czogb25lTW9udGhEYXlzIH0gPSBNb3ZlUmVsYXRpdmVEYXRlKGNhbGVuZGFyLCByZWxhdGl2ZVRvLCBvbmVNb250aCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb25lTW9udGhEYXlzID0gTWF0aEFicyhvbmVNb250aERheXMpO1xuICAgICAgICAgICAgLy8gZGF5TGVuZ3RoTnMgaXMgbmV2ZXIgdW5kZWZpbmVkIGlmIHVuaXQgaXMgYGRheWAgb3IgbGFyZ2VyLlxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICAgICAgICAgIGNvbnN0IGRpdmlzb3IgPSBKU0JJLm11bHRpcGx5KEpTQkkuQmlnSW50KG9uZU1vbnRoRGF5cyksIGRheUxlbmd0aE5zKTtcbiAgICAgICAgICAgIG5hbm9zZWNvbmRzID0gSlNCSS5hZGQoXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgICAgICAgSlNCSS5hZGQoSlNCSS5tdWx0aXBseShkaXZpc29yLCBKU0JJLkJpZ0ludChtb250aHMpKSwgSlNCSS5tdWx0aXBseShKU0JJLkJpZ0ludChkYXlzKSwgZGF5TGVuZ3RoTnMpKSwgbmFub3NlY29uZHMpO1xuICAgICAgICAgICAgY29uc3Qgcm91bmRlZCA9IFJvdW5kTnVtYmVyVG9JbmNyZW1lbnQobmFub3NlY29uZHMsIEpTQkkudG9OdW1iZXIoSlNCSS5tdWx0aXBseShkaXZpc29yLCBKU0JJLkJpZ0ludChpbmNyZW1lbnQpKSksIHJvdW5kaW5nTW9kZSk7XG4gICAgICAgICAgICB0b3RhbCA9IEpTQkkudG9OdW1iZXIobmFub3NlY29uZHMpIC8gSlNCSS50b051bWJlcihkaXZpc29yKTtcbiAgICAgICAgICAgIG1vbnRocyA9IEpTQkkudG9OdW1iZXIoSlNCSS5kaXZpZGUocm91bmRlZCwgZGl2aXNvcikpO1xuICAgICAgICAgICAgbmFub3NlY29uZHMgPSBaRVJPO1xuICAgICAgICAgICAgd2Vla3MgPSBkYXlzID0gMDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ3dlZWsnOiB7XG4gICAgICAgICAgICBpZiAoIWNhbGVuZGFyKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBIHN0YXJ0aW5nIHBvaW50IGlzIHJlcXVpcmVkIGZvciB3ZWVrcyByb3VuZGluZycpO1xuICAgICAgICAgICAgLy8gV2Vla3MgbWF5IGJlIGRpZmZlcmVudCBsZW5ndGhzIG9mIGRheXMgZGVwZW5kaW5nIG9uIHRoZSBjYWxlbmRhcixcbiAgICAgICAgICAgIC8vIGNvbnZlcnQgZGF5cyB0byB3ZWVrcyBpbiBhIGxvb3AgYXMgZGVzY3JpYmVkIGFib3ZlIHVuZGVyICd5ZWFycycuXG4gICAgICAgICAgICBjb25zdCBzaWduID0gTWF0aFNpZ24oZGF5cyk7XG4gICAgICAgICAgICBjb25zdCBvbmVXZWVrID0gbmV3IFRlbXBvcmFsRHVyYXRpb24oMCwgMCwgZGF5cyA8IDAgPyAtMSA6IDEpO1xuICAgICAgICAgICAgbGV0IG9uZVdlZWtEYXlzO1xuICAgICAgICAgICAgKHsgcmVsYXRpdmVUbywgZGF5czogb25lV2Vla0RheXMgfSA9IE1vdmVSZWxhdGl2ZURhdGUoY2FsZW5kYXIsIHJlbGF0aXZlVG8sIG9uZVdlZWspKTtcbiAgICAgICAgICAgIHdoaWxlIChNYXRoQWJzKGRheXMpID49IE1hdGhBYnMob25lV2Vla0RheXMpKSB7XG4gICAgICAgICAgICAgICAgd2Vla3MgKz0gc2lnbjtcbiAgICAgICAgICAgICAgICBkYXlzIC09IG9uZVdlZWtEYXlzO1xuICAgICAgICAgICAgICAgICh7IHJlbGF0aXZlVG8sIGRheXM6IG9uZVdlZWtEYXlzIH0gPSBNb3ZlUmVsYXRpdmVEYXRlKGNhbGVuZGFyLCByZWxhdGl2ZVRvLCBvbmVXZWVrKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvbmVXZWVrRGF5cyA9IE1hdGhBYnMob25lV2Vla0RheXMpO1xuICAgICAgICAgICAgLy8gZGF5TGVuZ3RoTnMgaXMgbmV2ZXIgdW5kZWZpbmVkIGlmIHVuaXQgaXMgYGRheWAgb3IgbGFyZ2VyLlxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICAgICAgICAgIGNvbnN0IGRpdmlzb3IgPSBKU0JJLm11bHRpcGx5KEpTQkkuQmlnSW50KG9uZVdlZWtEYXlzKSwgZGF5TGVuZ3RoTnMpO1xuICAgICAgICAgICAgbmFub3NlY29uZHMgPSBKU0JJLmFkZChcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICAgICAgICBKU0JJLmFkZChKU0JJLm11bHRpcGx5KGRpdmlzb3IsIEpTQkkuQmlnSW50KHdlZWtzKSksIEpTQkkubXVsdGlwbHkoSlNCSS5CaWdJbnQoZGF5cyksIGRheUxlbmd0aE5zKSksIG5hbm9zZWNvbmRzKTtcbiAgICAgICAgICAgIGNvbnN0IHJvdW5kZWQgPSBSb3VuZE51bWJlclRvSW5jcmVtZW50KG5hbm9zZWNvbmRzLCBKU0JJLnRvTnVtYmVyKEpTQkkubXVsdGlwbHkoZGl2aXNvciwgSlNCSS5CaWdJbnQoaW5jcmVtZW50KSkpLCByb3VuZGluZ01vZGUpO1xuICAgICAgICAgICAgdG90YWwgPSBKU0JJLnRvTnVtYmVyKG5hbm9zZWNvbmRzKSAvIEpTQkkudG9OdW1iZXIoZGl2aXNvcik7XG4gICAgICAgICAgICB3ZWVrcyA9IEpTQkkudG9OdW1iZXIoSlNCSS5kaXZpZGUocm91bmRlZCwgZGl2aXNvcikpO1xuICAgICAgICAgICAgbmFub3NlY29uZHMgPSBaRVJPO1xuICAgICAgICAgICAgZGF5cyA9IDA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdkYXknOiB7XG4gICAgICAgICAgICAvLyBkYXlMZW5ndGhOcyBpcyBuZXZlciB1bmRlZmluZWQgaWYgdW5pdCBpcyBgZGF5YCBvciBsYXJnZXIuXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgICAgICAgY29uc3QgZGl2aXNvciA9IGRheUxlbmd0aE5zO1xuICAgICAgICAgICAgbmFub3NlY29uZHMgPSBKU0JJLmFkZChKU0JJLm11bHRpcGx5KGRpdmlzb3IsIEpTQkkuQmlnSW50KGRheXMpKSwgbmFub3NlY29uZHMpO1xuICAgICAgICAgICAgY29uc3Qgcm91bmRlZCA9IFJvdW5kTnVtYmVyVG9JbmNyZW1lbnQobmFub3NlY29uZHMsIEpTQkkudG9OdW1iZXIoSlNCSS5tdWx0aXBseShkaXZpc29yLCBKU0JJLkJpZ0ludChpbmNyZW1lbnQpKSksIHJvdW5kaW5nTW9kZSk7XG4gICAgICAgICAgICB0b3RhbCA9IEpTQkkudG9OdW1iZXIobmFub3NlY29uZHMpIC8gSlNCSS50b051bWJlcihkaXZpc29yKTtcbiAgICAgICAgICAgIGRheXMgPSBKU0JJLnRvTnVtYmVyKEpTQkkuZGl2aWRlKHJvdW5kZWQsIGRpdmlzb3IpKTtcbiAgICAgICAgICAgIG5hbm9zZWNvbmRzID0gWkVSTztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ2hvdXInOiB7XG4gICAgICAgICAgICBjb25zdCBkaXZpc29yID0gMzYwMGU5O1xuICAgICAgICAgICAgbGV0IGFsbE5hbm9zZWNvbmRzID0gSlNCSS5tdWx0aXBseShKU0JJLkJpZ0ludChob3VycyksIEpTQkkuQmlnSW50KDM2MDBlOSkpO1xuICAgICAgICAgICAgYWxsTmFub3NlY29uZHMgPSBKU0JJLmFkZChhbGxOYW5vc2Vjb25kcywgSlNCSS5tdWx0aXBseShKU0JJLkJpZ0ludChtaW51dGVzKSwgSlNCSS5CaWdJbnQoNjBlOSkpKTtcbiAgICAgICAgICAgIGFsbE5hbm9zZWNvbmRzID0gSlNCSS5hZGQoYWxsTmFub3NlY29uZHMsIEpTQkkubXVsdGlwbHkoSlNCSS5CaWdJbnQoc2Vjb25kcyksIEJJTExJT04pKTtcbiAgICAgICAgICAgIGFsbE5hbm9zZWNvbmRzID0gSlNCSS5hZGQoYWxsTmFub3NlY29uZHMsIEpTQkkubXVsdGlwbHkoSlNCSS5CaWdJbnQobWlsbGlzZWNvbmRzKSwgTUlMTElPTikpO1xuICAgICAgICAgICAgYWxsTmFub3NlY29uZHMgPSBKU0JJLmFkZChhbGxOYW5vc2Vjb25kcywgSlNCSS5tdWx0aXBseShKU0JJLkJpZ0ludChtaWNyb3NlY29uZHMpLCBUSE9VU0FORCkpO1xuICAgICAgICAgICAgYWxsTmFub3NlY29uZHMgPSBKU0JJLmFkZChhbGxOYW5vc2Vjb25kcywgbmFub3NlY29uZHMpO1xuICAgICAgICAgICAgdG90YWwgPSBKU0JJLnRvTnVtYmVyKGFsbE5hbm9zZWNvbmRzKSAvIGRpdmlzb3I7XG4gICAgICAgICAgICBjb25zdCByb3VuZGVkID0gUm91bmROdW1iZXJUb0luY3JlbWVudChhbGxOYW5vc2Vjb25kcywgZGl2aXNvciAqIGluY3JlbWVudCwgcm91bmRpbmdNb2RlKTtcbiAgICAgICAgICAgIGhvdXJzID0gSlNCSS50b051bWJlcihKU0JJLmRpdmlkZShyb3VuZGVkLCBKU0JJLkJpZ0ludChkaXZpc29yKSkpO1xuICAgICAgICAgICAgbmFub3NlY29uZHMgPSBaRVJPO1xuICAgICAgICAgICAgbWludXRlcyA9IHNlY29uZHMgPSBtaWxsaXNlY29uZHMgPSBtaWNyb3NlY29uZHMgPSAwO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnbWludXRlJzoge1xuICAgICAgICAgICAgY29uc3QgZGl2aXNvciA9IDYwZTk7XG4gICAgICAgICAgICBsZXQgYWxsTmFub3NlY29uZHMgPSBKU0JJLm11bHRpcGx5KEpTQkkuQmlnSW50KG1pbnV0ZXMpLCBKU0JJLkJpZ0ludCg2MGU5KSk7XG4gICAgICAgICAgICBhbGxOYW5vc2Vjb25kcyA9IEpTQkkuYWRkKGFsbE5hbm9zZWNvbmRzLCBKU0JJLm11bHRpcGx5KEpTQkkuQmlnSW50KHNlY29uZHMpLCBCSUxMSU9OKSk7XG4gICAgICAgICAgICBhbGxOYW5vc2Vjb25kcyA9IEpTQkkuYWRkKGFsbE5hbm9zZWNvbmRzLCBKU0JJLm11bHRpcGx5KEpTQkkuQmlnSW50KG1pbGxpc2Vjb25kcyksIE1JTExJT04pKTtcbiAgICAgICAgICAgIGFsbE5hbm9zZWNvbmRzID0gSlNCSS5hZGQoYWxsTmFub3NlY29uZHMsIEpTQkkubXVsdGlwbHkoSlNCSS5CaWdJbnQobWljcm9zZWNvbmRzKSwgVEhPVVNBTkQpKTtcbiAgICAgICAgICAgIGFsbE5hbm9zZWNvbmRzID0gSlNCSS5hZGQoYWxsTmFub3NlY29uZHMsIG5hbm9zZWNvbmRzKTtcbiAgICAgICAgICAgIHRvdGFsID0gSlNCSS50b051bWJlcihhbGxOYW5vc2Vjb25kcykgLyBkaXZpc29yO1xuICAgICAgICAgICAgY29uc3Qgcm91bmRlZCA9IFJvdW5kTnVtYmVyVG9JbmNyZW1lbnQoYWxsTmFub3NlY29uZHMsIGRpdmlzb3IgKiBpbmNyZW1lbnQsIHJvdW5kaW5nTW9kZSk7XG4gICAgICAgICAgICBtaW51dGVzID0gSlNCSS50b051bWJlcihKU0JJLmRpdmlkZShyb3VuZGVkLCBKU0JJLkJpZ0ludChkaXZpc29yKSkpO1xuICAgICAgICAgICAgbmFub3NlY29uZHMgPSBaRVJPO1xuICAgICAgICAgICAgc2Vjb25kcyA9IG1pbGxpc2Vjb25kcyA9IG1pY3Jvc2Vjb25kcyA9IDA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdzZWNvbmQnOiB7XG4gICAgICAgICAgICBjb25zdCBkaXZpc29yID0gMWU5O1xuICAgICAgICAgICAgbGV0IGFsbE5hbm9zZWNvbmRzID0gSlNCSS5tdWx0aXBseShKU0JJLkJpZ0ludChzZWNvbmRzKSwgQklMTElPTik7XG4gICAgICAgICAgICBhbGxOYW5vc2Vjb25kcyA9IEpTQkkuYWRkKGFsbE5hbm9zZWNvbmRzLCBKU0JJLm11bHRpcGx5KEpTQkkuQmlnSW50KG1pbGxpc2Vjb25kcyksIE1JTExJT04pKTtcbiAgICAgICAgICAgIGFsbE5hbm9zZWNvbmRzID0gSlNCSS5hZGQoYWxsTmFub3NlY29uZHMsIEpTQkkubXVsdGlwbHkoSlNCSS5CaWdJbnQobWljcm9zZWNvbmRzKSwgVEhPVVNBTkQpKTtcbiAgICAgICAgICAgIGFsbE5hbm9zZWNvbmRzID0gSlNCSS5hZGQoYWxsTmFub3NlY29uZHMsIG5hbm9zZWNvbmRzKTtcbiAgICAgICAgICAgIHRvdGFsID0gSlNCSS50b051bWJlcihhbGxOYW5vc2Vjb25kcykgLyBkaXZpc29yO1xuICAgICAgICAgICAgY29uc3Qgcm91bmRlZCA9IFJvdW5kTnVtYmVyVG9JbmNyZW1lbnQoYWxsTmFub3NlY29uZHMsIGRpdmlzb3IgKiBpbmNyZW1lbnQsIHJvdW5kaW5nTW9kZSk7XG4gICAgICAgICAgICBzZWNvbmRzID0gSlNCSS50b051bWJlcihKU0JJLmRpdmlkZShyb3VuZGVkLCBKU0JJLkJpZ0ludChkaXZpc29yKSkpO1xuICAgICAgICAgICAgbmFub3NlY29uZHMgPSBaRVJPO1xuICAgICAgICAgICAgbWlsbGlzZWNvbmRzID0gbWljcm9zZWNvbmRzID0gMDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ21pbGxpc2Vjb25kJzoge1xuICAgICAgICAgICAgY29uc3QgZGl2aXNvciA9IDFlNjtcbiAgICAgICAgICAgIGxldCBhbGxOYW5vc2Vjb25kcyA9IEpTQkkubXVsdGlwbHkoSlNCSS5CaWdJbnQobWlsbGlzZWNvbmRzKSwgTUlMTElPTik7XG4gICAgICAgICAgICBhbGxOYW5vc2Vjb25kcyA9IEpTQkkuYWRkKGFsbE5hbm9zZWNvbmRzLCBKU0JJLm11bHRpcGx5KEpTQkkuQmlnSW50KG1pY3Jvc2Vjb25kcyksIFRIT1VTQU5EKSk7XG4gICAgICAgICAgICBhbGxOYW5vc2Vjb25kcyA9IEpTQkkuYWRkKGFsbE5hbm9zZWNvbmRzLCBuYW5vc2Vjb25kcyk7XG4gICAgICAgICAgICB0b3RhbCA9IEpTQkkudG9OdW1iZXIoYWxsTmFub3NlY29uZHMpIC8gZGl2aXNvcjtcbiAgICAgICAgICAgIGNvbnN0IHJvdW5kZWQgPSBSb3VuZE51bWJlclRvSW5jcmVtZW50KGFsbE5hbm9zZWNvbmRzLCBkaXZpc29yICogaW5jcmVtZW50LCByb3VuZGluZ01vZGUpO1xuICAgICAgICAgICAgbWlsbGlzZWNvbmRzID0gSlNCSS50b051bWJlcihKU0JJLmRpdmlkZShyb3VuZGVkLCBKU0JJLkJpZ0ludChkaXZpc29yKSkpO1xuICAgICAgICAgICAgbmFub3NlY29uZHMgPSBaRVJPO1xuICAgICAgICAgICAgbWljcm9zZWNvbmRzID0gMDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ21pY3Jvc2Vjb25kJzoge1xuICAgICAgICAgICAgY29uc3QgZGl2aXNvciA9IDFlMztcbiAgICAgICAgICAgIGxldCBhbGxOYW5vc2Vjb25kcyA9IEpTQkkubXVsdGlwbHkoSlNCSS5CaWdJbnQobWljcm9zZWNvbmRzKSwgVEhPVVNBTkQpO1xuICAgICAgICAgICAgYWxsTmFub3NlY29uZHMgPSBKU0JJLmFkZChhbGxOYW5vc2Vjb25kcywgbmFub3NlY29uZHMpO1xuICAgICAgICAgICAgdG90YWwgPSBKU0JJLnRvTnVtYmVyKGFsbE5hbm9zZWNvbmRzKSAvIGRpdmlzb3I7XG4gICAgICAgICAgICBjb25zdCByb3VuZGVkID0gUm91bmROdW1iZXJUb0luY3JlbWVudChhbGxOYW5vc2Vjb25kcywgZGl2aXNvciAqIGluY3JlbWVudCwgcm91bmRpbmdNb2RlKTtcbiAgICAgICAgICAgIG1pY3Jvc2Vjb25kcyA9IEpTQkkudG9OdW1iZXIoSlNCSS5kaXZpZGUocm91bmRlZCwgSlNCSS5CaWdJbnQoZGl2aXNvcikpKTtcbiAgICAgICAgICAgIG5hbm9zZWNvbmRzID0gWkVSTztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ25hbm9zZWNvbmQnOiB7XG4gICAgICAgICAgICB0b3RhbCA9IEpTQkkudG9OdW1iZXIobmFub3NlY29uZHMpO1xuICAgICAgICAgICAgbmFub3NlY29uZHMgPSBSb3VuZE51bWJlclRvSW5jcmVtZW50KG5hbm9zZWNvbmRzLCBpbmNyZW1lbnQsIHJvdW5kaW5nTW9kZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICB5ZWFycyxcbiAgICAgICAgbW9udGhzLFxuICAgICAgICB3ZWVrcyxcbiAgICAgICAgZGF5cyxcbiAgICAgICAgaG91cnMsXG4gICAgICAgIG1pbnV0ZXMsXG4gICAgICAgIHNlY29uZHMsXG4gICAgICAgIG1pbGxpc2Vjb25kcyxcbiAgICAgICAgbWljcm9zZWNvbmRzLFxuICAgICAgICBuYW5vc2Vjb25kczogSlNCSS50b051bWJlcihuYW5vc2Vjb25kcyksXG4gICAgICAgIHRvdGFsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIENvbXBhcmVJU09EYXRlKHkxLCBtMSwgZDEsIHkyLCBtMiwgZDIpIHtcbiAgICBmb3IgKGNvbnN0IFt4LCB5XSBvZiBbXG4gICAgICAgIFt5MSwgeTJdLFxuICAgICAgICBbbTEsIG0yXSxcbiAgICAgICAgW2QxLCBkMl1cbiAgICBdKSB7XG4gICAgICAgIGlmICh4ICE9PSB5KVxuICAgICAgICAgICAgcmV0dXJuIENvbXBhcmlzb25SZXN1bHQoeCAtIHkpO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbn1cbmZ1bmN0aW9uIE5vbk5lZ2F0aXZlTW9kdWxvKHgsIHkpIHtcbiAgICBsZXQgcmVzdWx0ID0geCAlIHk7XG4gICAgaWYgKE9iamVjdElzKHJlc3VsdCwgLTApKVxuICAgICAgICByZXR1cm4gMDtcbiAgICBpZiAocmVzdWx0IDwgMClcbiAgICAgICAgcmVzdWx0ICs9IHk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIFRvQmlnSW50RXh0ZXJuYWwoYXJnKSB7XG4gICAgY29uc3QganNiaUJJID0gVG9CaWdJbnQoYXJnKTtcbiAgICBpZiAodHlwZW9mIGdsb2JhbFRoaXMuQmlnSW50ICE9PSAndW5kZWZpbmVkJylcbiAgICAgICAgcmV0dXJuIGdsb2JhbFRoaXMuQmlnSW50KGpzYmlCSS50b1N0cmluZygxMCkpO1xuICAgIHJldHVybiBqc2JpQkk7XG59XG5mdW5jdGlvbiBUb0JpZ0ludChhcmcpIHtcbiAgICBpZiAoYXJnIGluc3RhbmNlb2YgSlNCSSkge1xuICAgICAgICByZXR1cm4gYXJnO1xuICAgIH1cbiAgICBsZXQgcHJpbSA9IGFyZztcbiAgICBpZiAodHlwZW9mIGFyZyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgY29uc3QgdG9QcmltRm4gPSBhcmdbU3ltYm9sLnRvUHJpbWl0aXZlXTtcbiAgICAgICAgaWYgKHRvUHJpbUZuICYmIHR5cGVvZiB0b1ByaW1GbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcHJpbSA9IFJlZmxlY3RBcHBseSQxKHRvUHJpbUZuLCBhcmcsIFsnbnVtYmVyJ10pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN3aXRjaCAodHlwZW9mIHByaW0pIHtcbiAgICAgICAgY2FzZSAndW5kZWZpbmVkJzpcbiAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgY2FzZSAnc3ltYm9sJzpcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYGNhbm5vdCBjb252ZXJ0ICR7dHlwZW9mIGFyZ30gdG8gYmlnaW50YCk7XG4gICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICBpZiAoIXByaW0ubWF0Y2goL15cXHMqKD86WystXT9cXGQrXFxzKik/JC8pKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdpbnZhbGlkIEJpZ0ludCBzeW50YXgnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgLy8gZXNsaW50OiBuby1mYWxsdGhyb3VnaDogZmFsc2VcbiAgICAgICAgY2FzZSAnYmlnaW50JzpcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEpTQkkuQmlnSW50KHByaW0udG9TdHJpbmcoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgRXJyb3IgJiYgZS5tZXNzYWdlLnN0YXJ0c1dpdGgoJ0ludmFsaWQgaW50ZWdlcicpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoZS5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgfVxuICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgIGlmIChwcmltKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE9ORTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBaRVJPO1xuICAgICAgICAgICAgfVxuICAgIH1cbn1cbi8vIE5vdGU6IFRoaXMgbWV0aG9kIHJldHVybnMgdmFsdWVzIHdpdGggYm9ndXMgbmFub3NlY29uZHMgYmFzZWQgb24gdGhlIHByZXZpb3VzIGl0ZXJhdGlvbidzXG4vLyBtaWxsaXNlY29uZHMuIFRoYXQgd2F5IHRoZXJlIGlzIGEgZ3VhcmFudGVlIHRoYXQgdGhlIGZ1bGwgbmFub3NlY29uZHMgYXJlIGFsd2F5cyBnb2luZyB0byBiZVxuLy8gaW5jcmVhc2luZyBhdCBsZWFzdCBhbmQgdGhhdCB0aGUgbWljcm9zZWNvbmQgYW5kIG5hbm9zZWNvbmQgZmllbGRzIGFyZSBsaWtlbHkgdG8gYmUgbm9uLXplcm8uXG5jb25zdCBTeXN0ZW1VVENFcG9jaE5hbm9TZWNvbmRzID0gKCgpID0+IHtcbiAgICBsZXQgbnMgPSBKU0JJLkJpZ0ludChEYXRlLm5vdygpICUgMWU2KTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBjb25zdCBtcyA9IEpTQkkuQmlnSW50KERhdGUubm93KCkpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBKU0JJLmFkZChKU0JJLm11bHRpcGx5KG1zLCBNSUxMSU9OKSwgbnMpO1xuICAgICAgICBucyA9IEpTQkkuZGl2aWRlKG1zLCBNSUxMSU9OKTtcbiAgICAgICAgaWYgKEpTQkkuZ3JlYXRlclRoYW4ocmVzdWx0LCBOU19NQVgpKVxuICAgICAgICAgICAgcmV0dXJuIE5TX01BWDtcbiAgICAgICAgaWYgKEpTQkkubGVzc1RoYW4ocmVzdWx0LCBOU19NSU4pKVxuICAgICAgICAgICAgcmV0dXJuIE5TX01JTjtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xufSkoKTtcbmZ1bmN0aW9uIFN5c3RlbVRpbWVab25lKCkge1xuICAgIGNvbnN0IGZtdCA9IG5ldyBJbnRsRGF0ZVRpbWVGb3JtYXQkMSgnZW4tdXMnKTtcbiAgICBjb25zdCBUZW1wb3JhbFRpbWVab25lID0gR2V0SW50cmluc2ljKCclVGVtcG9yYWwuVGltZVpvbmUlJyk7XG4gICAgcmV0dXJuIG5ldyBUZW1wb3JhbFRpbWVab25lKFBhcnNlVGVtcG9yYWxUaW1lWm9uZShmbXQucmVzb2x2ZWRPcHRpb25zKCkudGltZVpvbmUpKTtcbn1cbmZ1bmN0aW9uIENvbXBhcmlzb25SZXN1bHQodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPCAwID8gLTEgOiB2YWx1ZSA+IDAgPyAxIDogdmFsdWU7XG59XG5mdW5jdGlvbiBHZXRPcHRpb25zT2JqZWN0KG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gT2JqZWN0Q3JlYXRlJDIobnVsbCk7XG4gICAgaWYgKElzT2JqZWN0KG9wdGlvbnMpICYmIG9wdGlvbnMgIT09IG51bGwpXG4gICAgICAgIHJldHVybiBvcHRpb25zO1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE9wdGlvbnMgcGFyYW1ldGVyIG11c3QgYmUgYW4gb2JqZWN0LCBub3QgJHtvcHRpb25zID09PSBudWxsID8gJ251bGwnIDogYCR7dHlwZW9mIG9wdGlvbnN9YH1gKTtcbn1cbmZ1bmN0aW9uIENyZWF0ZU9uZVByb3BPYmplY3QocHJvcE5hbWUsIHByb3BWYWx1ZSkge1xuICAgIGNvbnN0IG8gPSBPYmplY3RDcmVhdGUkMihudWxsKTtcbiAgICBvW3Byb3BOYW1lXSA9IHByb3BWYWx1ZTtcbiAgICByZXR1cm4gbztcbn1cbmZ1bmN0aW9uIEdldE9wdGlvbihvcHRpb25zLCBwcm9wZXJ0eSwgYWxsb3dlZFZhbHVlcywgZmFsbGJhY2spIHtcbiAgICBsZXQgdmFsdWUgPSBvcHRpb25zW3Byb3BlcnR5XTtcbiAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YWx1ZSA9IFRvU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgaWYgKCFhbGxvd2VkVmFsdWVzLmluY2x1ZGVzKHZhbHVlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYCR7cHJvcGVydHl9IG11c3QgYmUgb25lIG9mICR7YWxsb3dlZFZhbHVlcy5qb2luKCcsICcpfSwgbm90ICR7dmFsdWV9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsbGJhY2s7XG59XG5mdW5jdGlvbiBHZXROdW1iZXJPcHRpb24ob3B0aW9ucywgcHJvcGVydHksIG1pbmltdW0sIG1heGltdW0sIGZhbGxiYWNrKSB7XG4gICAgbGV0IHZhbHVlUmF3ID0gb3B0aW9uc1twcm9wZXJ0eV07XG4gICAgaWYgKHZhbHVlUmF3ID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiBmYWxsYmFjaztcbiAgICBjb25zdCB2YWx1ZSA9IFRvTnVtYmVyKHZhbHVlUmF3KTtcbiAgICBpZiAoTnVtYmVySXNOYU4odmFsdWUpIHx8IHZhbHVlIDwgbWluaW11bSB8fCB2YWx1ZSA+IG1heGltdW0pIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYCR7cHJvcGVydHl9IG11c3QgYmUgYmV0d2VlbiAke21pbmltdW19IGFuZCAke21heGltdW19LCBub3QgJHt2YWx1ZX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIE1hdGhGbG9vcih2YWx1ZSk7XG59XG5jb25zdCBPRkZTRVQgPSBuZXcgUmVnRXhwKGBeJHtvZmZzZXQuc291cmNlfSRgKTtcbmZ1bmN0aW9uIGJpc2VjdChnZXRTdGF0ZSwgbGVmdFBhcmFtLCByaWdodFBhcmFtLCBsc3RhdGVQYXJhbSA9IGdldFN0YXRlKGxlZnRQYXJhbSksIHJzdGF0ZVBhcmFtID0gZ2V0U3RhdGUocmlnaHRQYXJhbSkpIHtcbiAgICAvLyBUaGlzIGRvZXNuJ3QgbWFrZSBtdWNoIHNlbnNlIC0gd2h5IGRvIHRoZXNlIGdldCBjb252ZXJ0ZWQgdW5uZWNlc3NhcmlseT9cbiAgICBsZXQgbGVmdCA9IEpTQkkuQmlnSW50KGxlZnRQYXJhbSk7XG4gICAgbGV0IHJpZ2h0ID0gSlNCSS5CaWdJbnQocmlnaHRQYXJhbSk7XG4gICAgbGV0IGxzdGF0ZSA9IGxzdGF0ZVBhcmFtO1xuICAgIGxldCByc3RhdGUgPSByc3RhdGVQYXJhbTtcbiAgICB3aGlsZSAoSlNCSS5ncmVhdGVyVGhhbihKU0JJLnN1YnRyYWN0KHJpZ2h0LCBsZWZ0KSwgT05FKSkge1xuICAgICAgICBjb25zdCBtaWRkbGUgPSBKU0JJLmRpdmlkZShKU0JJLmFkZChsZWZ0LCByaWdodCksIEpTQkkuQmlnSW50KDIpKTtcbiAgICAgICAgY29uc3QgbXN0YXRlID0gZ2V0U3RhdGUobWlkZGxlKTtcbiAgICAgICAgaWYgKG1zdGF0ZSA9PT0gbHN0YXRlKSB7XG4gICAgICAgICAgICBsZWZ0ID0gbWlkZGxlO1xuICAgICAgICAgICAgbHN0YXRlID0gbXN0YXRlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG1zdGF0ZSA9PT0gcnN0YXRlKSB7XG4gICAgICAgICAgICByaWdodCA9IG1pZGRsZTtcbiAgICAgICAgICAgIHJzdGF0ZSA9IG1zdGF0ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBzdGF0ZSBpbiBiaXNlY3Rpb24gJHtsc3RhdGV9IC0gJHttc3RhdGV9IC0gJHtyc3RhdGV9YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJpZ2h0O1xufVxuY29uc3QgbnNQZXJUaW1lVW5pdCA9IHtcbiAgICBob3VyOiAzNjAwZTksXG4gICAgbWludXRlOiA2MGU5LFxuICAgIHNlY29uZDogMWU5LFxuICAgIG1pbGxpc2Vjb25kOiAxZTYsXG4gICAgbWljcm9zZWNvbmQ6IDFlMyxcbiAgICBuYW5vc2Vjb25kOiAxXG59O1xuXG5jb25zdCBEQVRFID0gU3ltYm9sKCdkYXRlJyk7XG5jb25zdCBZTSA9IFN5bWJvbCgneW0nKTtcbmNvbnN0IE1EID0gU3ltYm9sKCdtZCcpO1xuY29uc3QgVElNRSA9IFN5bWJvbCgndGltZScpO1xuY29uc3QgREFURVRJTUUgPSBTeW1ib2woJ2RhdGV0aW1lJyk7XG5jb25zdCBaT05FRCA9IFN5bWJvbCgnem9uZWRkYXRldGltZScpO1xuY29uc3QgSU5TVCA9IFN5bWJvbCgnaW5zdGFudCcpO1xuY29uc3QgT1JJR0lOQUwgPSBTeW1ib2woJ29yaWdpbmFsJyk7XG5jb25zdCBUWl9SRVNPTFZFRCA9IFN5bWJvbCgndGltZXpvbmUnKTtcbmNvbnN0IFRaX0dJVkVOID0gU3ltYm9sKCd0aW1lem9uZS1pZC1naXZlbicpO1xuY29uc3QgQ0FMX0lEID0gU3ltYm9sKCdjYWxlbmRhci1pZCcpO1xuY29uc3QgTE9DQUxFID0gU3ltYm9sKCdsb2NhbGUnKTtcbmNvbnN0IE9QVElPTlMgPSBTeW1ib2woJ29wdGlvbnMnKTtcbmNvbnN0IGRlc2NyaXB0b3IgPSAodmFsdWUpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9O1xufTtcbmNvbnN0IEludGxEYXRlVGltZUZvcm1hdCA9IGdsb2JhbFRoaXMuSW50bC5EYXRlVGltZUZvcm1hdDtcbmNvbnN0IE9iamVjdEFzc2lnbiQxID0gT2JqZWN0LmFzc2lnbjtcbmNvbnN0IE9iamVjdEhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbmNvbnN0IFJlZmxlY3RBcHBseSA9IFJlZmxlY3QuYXBwbHk7XG4vLyBDb25zdHJ1Y3Rpb24gb2YgYnVpbHQtaW4gSW50bC5EYXRlVGltZUZvcm1hdCBvYmplY3RzIGlzIHNsb29vb29vdyxcbi8vIHNvIHdlJ2xsIG9ubHkgY3JlYXRlIHRob3NlIGluc3RhbmNlcyB3aGVuIHdlIG5lZWQgdGhlbS5cbi8vIFNlZSBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD02NTI4XG5mdW5jdGlvbiBnZXRQcm9wTGF6eShvYmosIHByb3ApIHtcbiAgICBsZXQgdmFsID0gb2JqW3Byb3BdO1xuICAgIGlmICh0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIElmIHdlIGdldCBoZXJlLCBgdmFsYCBpcyBhbiBcImFtZW5kZXIgZnVuY3Rpb25cIi4gSXQgd2lsbCB0YWtlIHRoZSB1c2VyJ3NcbiAgICAgICAgLy8gb3B0aW9ucyBhbmQgdHJhbnNmb3JtIHRoZW0gaW50byBzdWl0YWJsZSBvcHRpb25zIHRvIGJlIHBhc3NlZCBpbnRvIHRoZVxuICAgICAgICAvLyBidWlsdC1pbiAobm9uLXBvbHlmaWxsKSBJbnRsLkRhdGVUaW1lRm9ybWF0IGNvbnN0cnVjdG9yLiBUaGVzZSBvcHRpb25zXG4gICAgICAgIC8vIHdpbGwgdmFyeSBkZXBlbmRpbmcgb24gdGhlIFRlbXBvcmFsIHR5cGUsIHNvIHRoYXQncyB3aHkgd2Ugc3RvcmUgc2VwYXJhdGVcbiAgICAgICAgLy8gZm9ybWF0dGVycyBpbiBzZXBhcmF0ZSBwcm9wcyBvbiB0aGUgcG9seWZpbGwncyBEYXRlVGltZUZvcm1hdCBpbnN0YW5jZXMuXG4gICAgICAgIC8vIFRoZSBlZmZpY2llbmN5IGhhcHBlbnMgYmVjYXVzZSB3ZSBkb24ndCBjcmVhdGUgYW4gKGV4cGVuc2l2ZSkgZm9ybWF0dGVyXG4gICAgICAgIC8vIHVudGlsIHRoZSB1c2VyIGNhbGxzIHRvTG9jYWxlU3RyaW5nIGZvciB0aGF0IFRlbXBvcmFsIHR5cGUuXG4gICAgICAgIHZhbCA9IG5ldyBJbnRsRGF0ZVRpbWVGb3JtYXQob2JqW0xPQ0FMRV0sIHZhbChvYmpbT1BUSU9OU10pKTtcbiAgICAgICAgLy8gVE9ETzogY2FuIHRoaXMgYmUgdHlwZWQgbW9yZSBjbGVhbmx5P1xuICAgICAgICBvYmpbcHJvcF0gPSB2YWw7XG4gICAgfVxuICAgIHJldHVybiB2YWw7XG59XG4vLyBTaW1pbGFybHksIGxhenktaW5pdCBUaW1lWm9uZSBpbnN0YW5jZXMuXG5mdW5jdGlvbiBnZXRSZXNvbHZlZFRpbWVab25lTGF6eShvYmopIHtcbiAgICBsZXQgdmFsID0gb2JqW1RaX1JFU09MVkVEXTtcbiAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdmFsID0gVG9UZW1wb3JhbFRpbWVab25lKHZhbCk7XG4gICAgICAgIG9ialtUWl9SRVNPTFZFRF0gPSB2YWw7XG4gICAgfVxuICAgIHJldHVybiB2YWw7XG59XG5mdW5jdGlvbiBEYXRlVGltZUZvcm1hdEltcGwobG9jYWxlID0gdW5kZWZpbmVkLCBvcHRpb25zUGFyYW0gPSB7fSkge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBEYXRlVGltZUZvcm1hdEltcGwpKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZVRpbWVGb3JtYXRJbXBsKGxvY2FsZSwgb3B0aW9uc1BhcmFtKTtcbiAgICB9XG4gICAgY29uc3QgaGFzT3B0aW9ucyA9IHR5cGVvZiBvcHRpb25zUGFyYW0gIT09ICd1bmRlZmluZWQnO1xuICAgIGNvbnN0IG9wdGlvbnMgPSBoYXNPcHRpb25zID8gT2JqZWN0QXNzaWduJDEoe30sIG9wdGlvbnNQYXJhbSkgOiB7fTtcbiAgICAvLyBUT0RPOiByZW1vdmUgdHlwZSBhc3NlcnRpb24gYWZ0ZXIgVGVtcG9yYWwgdHlwZXMgbGFuZCBpbiBUUyBsaWIgdHlwZXNcbiAgICBjb25zdCBvcmlnaW5hbCA9IG5ldyBJbnRsRGF0ZVRpbWVGb3JtYXQobG9jYWxlLCBvcHRpb25zKTtcbiAgICBjb25zdCBybyA9IG9yaWdpbmFsLnJlc29sdmVkT3B0aW9ucygpO1xuICAgIC8vIERhdGVUaW1lRm9ybWF0IGluc3RhbmNlcyBhcmUgdmVyeSBleHBlbnNpdmUgdG8gY3JlYXRlLiBUaGVyZWZvcmUsIHRoZXkgd2lsbFxuICAgIC8vIGJlIGxhemlseSBjcmVhdGVkIG9ubHkgd2hlbiBuZWVkZWQsIHVzaW5nIHRoZSBsb2NhbGUgYW5kIG9wdGlvbnMgcHJvdmlkZWQuXG4gICAgLy8gQnV0IGl0J3MgcG9zc2libGUgZm9yIGNhbGxlcnMgdG8gbXV0YXRlIHRob3NlIGlucHV0cyBiZWZvcmUgbGF6eSBjcmVhdGlvblxuICAgIC8vIGhhcHBlbnMuIEZvciB0aGlzIHJlYXNvbiwgd2UgY2xvbmUgdGhlIGlucHV0cyBpbnN0ZWFkIG9mIGNhY2hpbmcgdGhlXG4gICAgLy8gb3JpZ2luYWwgb2JqZWN0cy4gVG8gYXZvaWQgdGhlIGNvbXBsZXhpdHkgb2YgZGVlcCBjbG9uaW5nIGFueSBpbnB1dHMgdGhhdFxuICAgIC8vIGFyZSB0aGVtc2VsdmVzIG9iamVjdHMgKGUuZy4gdGhlIGxvY2FsZXMgYXJyYXksIG9yIG9wdGlvbnMgcHJvcGVydHkgdmFsdWVzXG4gICAgLy8gdGhhdCB3aWxsIGJlIGNvZXJjZWQgdG8gc3RyaW5ncyksIHdlIHJlbHkgb24gYHJlc29sdmVkT3B0aW9ucygpYCB0byBkbyB0aGVcbiAgICAvLyBjb2VyY2lvbiBhbmQgY2xvbmluZyBmb3IgdXMuIFVuZm9ydHVuYXRlbHksIHdlIGNhbid0IGp1c3QgdXNlIHRoZSByZXNvbHZlZFxuICAgIC8vIG9wdGlvbnMgYXMtaXMgYmVjYXVzZSBvdXIgb3B0aW9ucy1hbWVuZGluZyBsb2dpYyBhZGRzIGFkZGl0aW9uYWwgZmllbGRzIGlmXG4gICAgLy8gdGhlIHVzZXIgZG9lc24ndCBzdXBwbHkgYW55IHVuaXQgZmllbGRzIGxpa2UgeWVhciwgbW9udGgsIGRheSwgaG91ciwgZXRjLlxuICAgIC8vIFRoZXJlZm9yZSwgd2UgbGltaXQgdGhlIHByb3BlcnRpZXMgaW4gdGhlIGNsb25lIHRvIHByb3BlcnRpZXMgdGhhdCB3ZXJlXG4gICAgLy8gcHJlc2VudCBpbiB0aGUgb3JpZ2luYWwgaW5wdXQuXG4gICAgaWYgKGhhc09wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgY2xvbmVkUmVzb2x2ZWQgPSBPYmplY3RBc3NpZ24kMSh7fSwgcm8pO1xuICAgICAgICBmb3IgKGNvbnN0IHByb3AgaW4gY2xvbmVkUmVzb2x2ZWQpIHtcbiAgICAgICAgICAgIGlmICghUmVmbGVjdEFwcGx5KE9iamVjdEhhc093blByb3BlcnR5LCBvcHRpb25zLCBbcHJvcF0pKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGNsb25lZFJlc29sdmVkW3Byb3BdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXNbT1BUSU9OU10gPSBjbG9uZWRSZXNvbHZlZDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRoaXNbT1BUSU9OU10gPSBvcHRpb25zO1xuICAgIH1cbiAgICB0aGlzW1RaX0dJVkVOXSA9IG9wdGlvbnMudGltZVpvbmUgPyBvcHRpb25zLnRpbWVab25lIDogbnVsbDtcbiAgICB0aGlzW0xPQ0FMRV0gPSByby5sb2NhbGU7XG4gICAgdGhpc1tPUklHSU5BTF0gPSBvcmlnaW5hbDtcbiAgICB0aGlzW1RaX1JFU09MVkVEXSA9IHJvLnRpbWVab25lO1xuICAgIHRoaXNbQ0FMX0lEXSA9IHJvLmNhbGVuZGFyO1xuICAgIHRoaXNbREFURV0gPSBkYXRlQW1lbmQ7XG4gICAgdGhpc1tZTV0gPSB5ZWFyTW9udGhBbWVuZDtcbiAgICB0aGlzW01EXSA9IG1vbnRoRGF5QW1lbmQ7XG4gICAgdGhpc1tUSU1FXSA9IHRpbWVBbWVuZDtcbiAgICB0aGlzW0RBVEVUSU1FXSA9IGRhdGV0aW1lQW1lbmQ7XG4gICAgdGhpc1taT05FRF0gPSB6b25lZERhdGVUaW1lQW1lbmQ7XG4gICAgdGhpc1tJTlNUXSA9IGluc3RhbnRBbWVuZDtcbiAgICByZXR1cm4gdW5kZWZpbmVkOyAvLyBUT0RPOiBJIGNvdWxkbid0IHNhdGlzZnkgVFMgd2l0aG91dCBhZGRpbmcgdGhpcy4gSXMgdGhlcmUgYW5vdGhlciB3YXk/XG59XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRGF0ZVRpbWVGb3JtYXRJbXBsLCAnbmFtZScsIHtcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogJ0RhdGVUaW1lRm9ybWF0J1xufSk7XG5EYXRlVGltZUZvcm1hdEltcGwuc3VwcG9ydGVkTG9jYWxlc09mID0gZnVuY3Rpb24gKGxvY2FsZXMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gSW50bERhdGVUaW1lRm9ybWF0LnN1cHBvcnRlZExvY2FsZXNPZihsb2NhbGVzLCBvcHRpb25zKTtcbn07XG5jb25zdCBwcm9wZXJ0aWVzID0ge1xuICAgIHJlc29sdmVkT3B0aW9uczogZGVzY3JpcHRvcihyZXNvbHZlZE9wdGlvbnMpLFxuICAgIGZvcm1hdDogZGVzY3JpcHRvcihmb3JtYXQpLFxuICAgIGZvcm1hdFJhbmdlOiBkZXNjcmlwdG9yKGZvcm1hdFJhbmdlKVxufTtcbmlmICgnZm9ybWF0VG9QYXJ0cycgaW4gSW50bERhdGVUaW1lRm9ybWF0LnByb3RvdHlwZSkge1xuICAgIHByb3BlcnRpZXMuZm9ybWF0VG9QYXJ0cyA9IGRlc2NyaXB0b3IoZm9ybWF0VG9QYXJ0cyk7XG59XG5pZiAoJ2Zvcm1hdFJhbmdlVG9QYXJ0cycgaW4gSW50bERhdGVUaW1lRm9ybWF0LnByb3RvdHlwZSkge1xuICAgIHByb3BlcnRpZXMuZm9ybWF0UmFuZ2VUb1BhcnRzID0gZGVzY3JpcHRvcihmb3JtYXRSYW5nZVRvUGFydHMpO1xufVxuRGF0ZVRpbWVGb3JtYXRJbXBsLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoSW50bERhdGVUaW1lRm9ybWF0LnByb3RvdHlwZSwgcHJvcGVydGllcyk7XG4vLyBFbnN1cmUgdGhhdCB0aGUgcHJvdG90eXBlIGlzbid0IHdyaXRlYWJsZS5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShEYXRlVGltZUZvcm1hdEltcGwsICdwcm90b3R5cGUnLCB7XG4gICAgd3JpdGFibGU6IGZhbHNlLFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogZmFsc2Vcbn0pO1xuY29uc3QgRGF0ZVRpbWVGb3JtYXQgPSBEYXRlVGltZUZvcm1hdEltcGw7XG5mdW5jdGlvbiByZXNvbHZlZE9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXNbT1JJR0lOQUxdLnJlc29sdmVkT3B0aW9ucygpO1xufVxuZnVuY3Rpb24gYWRqdXN0Rm9ybWF0dGVyVGltZVpvbmUoZm9ybWF0dGVyLCB0aW1lWm9uZSkge1xuICAgIGlmICghdGltZVpvbmUpXG4gICAgICAgIHJldHVybiBmb3JtYXR0ZXI7XG4gICAgY29uc3Qgb3B0aW9ucyA9IGZvcm1hdHRlci5yZXNvbHZlZE9wdGlvbnMoKTtcbiAgICBpZiAob3B0aW9ucy50aW1lWm9uZSA9PT0gdGltZVpvbmUpXG4gICAgICAgIHJldHVybiBmb3JtYXR0ZXI7XG4gICAgLy8gRXhpc3RpbmcgSW50bCBpc24ndCB0eXBlZCB0byBhY2NlcHQgVGVtcG9yYWwtc3BlY2lmaWMgb3B0aW9ucywgYnV0IHdpbGwgbm90XG4gICAgLy8gYnJlYWsgYXQgcnVudGltZSBpZiB3ZSBwYXNzIHRoZW0uIEFsc28sIHRoZSBsaWIgdHlwZXMgZm9yIHJlc29sdmVkIG9wdGlvbnNcbiAgICAvLyBhcmUgbGVzcyByZXN0cmljdGl2ZSB0aGFuIHRoZSB0eXBlcyBmb3Igb3B0aW9ucy4gRm9yIGV4YW1wbGUsIGB3ZWVrZGF5YCBpc1xuICAgIC8vIGAnbG9uZycgfCAnc2hvcnQnIHwgJ25hcnJvdydgIGluIG9wdGlvbnMgYnV0IGBzdHJpbmdgIGluIHJlc29sdmVkIG9wdGlvbnMuXG4gICAgLy8gVE9ETzogaW52ZXN0aWdhdGUgd2h5LCBhbmQgZmlsZSBhbiBpc3N1ZSBhZ2FpbnN0IFRTIGlmIGl0J3MgYSBidWcuXG4gICAgcmV0dXJuIG5ldyBJbnRsRGF0ZVRpbWVGb3JtYXQob3B0aW9ucy5sb2NhbGUsIHsgLi4ub3B0aW9ucywgdGltZVpvbmUgfSk7XG59XG4vLyBUT0RPOiBpbnZlc3RpZ2F0ZSB3aHkgdGhlcmUncyBhIHJlc3QgcGFyYW1ldGVyIGhlcmUuIERvZXMgdGhpcyBmdW5jdGlvbiByZWFsbHkgbmVlZCB0byBhY2NlcHQgZXh0cmEgcGFyYW1zP1xuLy8gQW5kIGlmIHNvLCB3aHkgZG9lc24ndCBmb3JtYXRSYW5nZSBhbHNvIGFjY2VwdCBleHRyYSBwYXJhbXM/XG5mdW5jdGlvbiBmb3JtYXQoZGF0ZXRpbWUsIC4uLnJlc3QpIHtcbiAgICBsZXQgeyBpbnN0YW50LCBmb3JtYXR0ZXIsIHRpbWVab25lIH0gPSBleHRyYWN0T3ZlcnJpZGVzKGRhdGV0aW1lLCB0aGlzKTtcbiAgICBpZiAoaW5zdGFudCAmJiBmb3JtYXR0ZXIpIHtcbiAgICAgICAgZm9ybWF0dGVyID0gYWRqdXN0Rm9ybWF0dGVyVGltZVpvbmUoZm9ybWF0dGVyLCB0aW1lWm9uZSk7XG4gICAgICAgIHJldHVybiBmb3JtYXR0ZXIuZm9ybWF0KGluc3RhbnQuZXBvY2hNaWxsaXNlY29uZHMpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpc1tPUklHSU5BTF0uZm9ybWF0KGRhdGV0aW1lLCAuLi5yZXN0KTtcbn1cbmZ1bmN0aW9uIGZvcm1hdFRvUGFydHMoZGF0ZXRpbWUsIC4uLnJlc3QpIHtcbiAgICBsZXQgeyBpbnN0YW50LCBmb3JtYXR0ZXIsIHRpbWVab25lIH0gPSBleHRyYWN0T3ZlcnJpZGVzKGRhdGV0aW1lLCB0aGlzKTtcbiAgICBpZiAoaW5zdGFudCAmJiBmb3JtYXR0ZXIpIHtcbiAgICAgICAgZm9ybWF0dGVyID0gYWRqdXN0Rm9ybWF0dGVyVGltZVpvbmUoZm9ybWF0dGVyLCB0aW1lWm9uZSk7XG4gICAgICAgIHJldHVybiBmb3JtYXR0ZXIuZm9ybWF0VG9QYXJ0cyhpbnN0YW50LmVwb2NoTWlsbGlzZWNvbmRzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXNbT1JJR0lOQUxdLmZvcm1hdFRvUGFydHMoZGF0ZXRpbWUsIC4uLnJlc3QpO1xufVxuZnVuY3Rpb24gZm9ybWF0UmFuZ2UoYSwgYikge1xuICAgIGlmIChpc1RlbXBvcmFsT2JqZWN0KGEpIHx8IGlzVGVtcG9yYWxPYmplY3QoYikpIHtcbiAgICAgICAgaWYgKCFzYW1lVGVtcG9yYWxUeXBlKGEsIGIpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnRsLkRhdGVUaW1lRm9ybWF0LmZvcm1hdFJhbmdlIGFjY2VwdHMgdHdvIHZhbHVlcyBvZiB0aGUgc2FtZSB0eXBlJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBpbnN0YW50OiBhYSwgZm9ybWF0dGVyOiBhZm9ybWF0dGVyLCB0aW1lWm9uZTogYXR6IH0gPSBleHRyYWN0T3ZlcnJpZGVzKGEsIHRoaXMpO1xuICAgICAgICBjb25zdCB7IGluc3RhbnQ6IGJiLCBmb3JtYXR0ZXI6IGJmb3JtYXR0ZXIsIHRpbWVab25lOiBidHogfSA9IGV4dHJhY3RPdmVycmlkZXMoYiwgdGhpcyk7XG4gICAgICAgIGlmIChhdHogJiYgYnR6ICYmIGF0eiAhPT0gYnR6KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignY2Fubm90IGZvcm1hdCByYW5nZSBiZXR3ZWVuIGRpZmZlcmVudCB0aW1lIHpvbmVzJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFhICYmIGJiICYmIGFmb3JtYXR0ZXIgJiYgYmZvcm1hdHRlciAmJiBhZm9ybWF0dGVyID09PSBiZm9ybWF0dGVyKSB7XG4gICAgICAgICAgICBjb25zdCBmb3JtYXR0ZXIgPSBhZGp1c3RGb3JtYXR0ZXJUaW1lWm9uZShhZm9ybWF0dGVyLCBhdHopO1xuICAgICAgICAgICAgLy8gVE9ETzogUmVtb3ZlIHR5cGUgYXNzZXJ0aW9uIGFmdGVyIHRoaXMgbWV0aG9kIGxhbmRzIGluIFRTIGxpYiB0eXBlc1xuICAgICAgICAgICAgcmV0dXJuIGZvcm1hdHRlci5mb3JtYXRSYW5nZShhYS5lcG9jaE1pbGxpc2Vjb25kcywgYmIuZXBvY2hNaWxsaXNlY29uZHMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFRPRE86IFJlbW92ZSB0eXBlIGFzc2VydGlvbiBhZnRlciB0aGlzIG1ldGhvZCBsYW5kcyBpbiBUUyBsaWIgdHlwZXNcbiAgICByZXR1cm4gdGhpc1tPUklHSU5BTF0uZm9ybWF0UmFuZ2UoYSwgYik7XG59XG5mdW5jdGlvbiBmb3JtYXRSYW5nZVRvUGFydHMoYSwgYikge1xuICAgIGlmIChpc1RlbXBvcmFsT2JqZWN0KGEpIHx8IGlzVGVtcG9yYWxPYmplY3QoYikpIHtcbiAgICAgICAgaWYgKCFzYW1lVGVtcG9yYWxUeXBlKGEsIGIpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnRsLkRhdGVUaW1lRm9ybWF0LmZvcm1hdFJhbmdlVG9QYXJ0cyBhY2NlcHRzIHR3byB2YWx1ZXMgb2YgdGhlIHNhbWUgdHlwZScpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgaW5zdGFudDogYWEsIGZvcm1hdHRlcjogYWZvcm1hdHRlciwgdGltZVpvbmU6IGF0eiB9ID0gZXh0cmFjdE92ZXJyaWRlcyhhLCB0aGlzKTtcbiAgICAgICAgY29uc3QgeyBpbnN0YW50OiBiYiwgZm9ybWF0dGVyOiBiZm9ybWF0dGVyLCB0aW1lWm9uZTogYnR6IH0gPSBleHRyYWN0T3ZlcnJpZGVzKGIsIHRoaXMpO1xuICAgICAgICBpZiAoYXR6ICYmIGJ0eiAmJiBhdHogIT09IGJ0eikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2Nhbm5vdCBmb3JtYXQgcmFuZ2UgYmV0d2VlbiBkaWZmZXJlbnQgdGltZSB6b25lcycpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhYSAmJiBiYiAmJiBhZm9ybWF0dGVyICYmIGJmb3JtYXR0ZXIgJiYgYWZvcm1hdHRlciA9PT0gYmZvcm1hdHRlcikge1xuICAgICAgICAgICAgY29uc3QgZm9ybWF0dGVyID0gYWRqdXN0Rm9ybWF0dGVyVGltZVpvbmUoYWZvcm1hdHRlciwgYXR6KTtcbiAgICAgICAgICAgIC8vIFRPRE86IFJlbW92ZSB0eXBlIGFzc2VydGlvbiBhZnRlciB0aGlzIG1ldGhvZCBsYW5kcyBpbiBUUyBsaWIgdHlwZXNcbiAgICAgICAgICAgIHJldHVybiBmb3JtYXR0ZXIuZm9ybWF0UmFuZ2VUb1BhcnRzKGFhLmVwb2NoTWlsbGlzZWNvbmRzLCBiYi5lcG9jaE1pbGxpc2Vjb25kcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gVE9ETzogUmVtb3ZlIHR5cGUgYXNzZXJ0aW9uIGFmdGVyIHRoaXMgbWV0aG9kIGxhbmRzIGluIFRTIGxpYiB0eXBlc1xuICAgIHJldHVybiB0aGlzW09SSUdJTkFMXS5mb3JtYXRSYW5nZVRvUGFydHMoYSwgYik7XG59XG5mdW5jdGlvbiBhbWVuZChvcHRpb25zUGFyYW0gPSB7fSwgYW1lbmRlZCA9IHt9KSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IE9iamVjdEFzc2lnbiQxKHt9LCBvcHRpb25zUGFyYW0pO1xuICAgIGZvciAoY29uc3Qgb3B0IG9mIFtcbiAgICAgICAgJ3llYXInLFxuICAgICAgICAnbW9udGgnLFxuICAgICAgICAnZGF5JyxcbiAgICAgICAgJ2hvdXInLFxuICAgICAgICAnbWludXRlJyxcbiAgICAgICAgJ3NlY29uZCcsXG4gICAgICAgICd3ZWVrZGF5JyxcbiAgICAgICAgJ2RheVBlcmlvZCcsXG4gICAgICAgICd0aW1lWm9uZU5hbWUnLFxuICAgICAgICAnZGF0ZVN0eWxlJyxcbiAgICAgICAgJ3RpbWVTdHlsZSdcbiAgICBdKSB7XG4gICAgICAgIG9wdGlvbnNbb3B0XSA9IG9wdCBpbiBhbWVuZGVkID8gYW1lbmRlZFtvcHRdIDogb3B0aW9uc1tvcHRdO1xuICAgICAgICBpZiAob3B0aW9uc1tvcHRdID09PSBmYWxzZSB8fCBvcHRpb25zW29wdF0gPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIGRlbGV0ZSBvcHRpb25zW29wdF07XG4gICAgfVxuICAgIHJldHVybiBvcHRpb25zO1xufVxuZnVuY3Rpb24gdGltZUFtZW5kKG9wdGlvbnNQYXJhbSkge1xuICAgIGxldCBvcHRpb25zID0gYW1lbmQob3B0aW9uc1BhcmFtLCB7XG4gICAgICAgIHllYXI6IGZhbHNlLFxuICAgICAgICBtb250aDogZmFsc2UsXG4gICAgICAgIGRheTogZmFsc2UsXG4gICAgICAgIHdlZWtkYXk6IGZhbHNlLFxuICAgICAgICB0aW1lWm9uZU5hbWU6IGZhbHNlLFxuICAgICAgICBkYXRlU3R5bGU6IGZhbHNlXG4gICAgfSk7XG4gICAgaWYgKCFoYXNUaW1lT3B0aW9ucyhvcHRpb25zKSkge1xuICAgICAgICBvcHRpb25zID0gT2JqZWN0QXNzaWduJDEoe30sIG9wdGlvbnMsIHtcbiAgICAgICAgICAgIGhvdXI6ICdudW1lcmljJyxcbiAgICAgICAgICAgIG1pbnV0ZTogJ251bWVyaWMnLFxuICAgICAgICAgICAgc2Vjb25kOiAnbnVtZXJpYydcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBvcHRpb25zO1xufVxuZnVuY3Rpb24geWVhck1vbnRoQW1lbmQob3B0aW9uc1BhcmFtKSB7XG4gICAgbGV0IG9wdGlvbnMgPSBhbWVuZChvcHRpb25zUGFyYW0sIHtcbiAgICAgICAgZGF5OiBmYWxzZSxcbiAgICAgICAgaG91cjogZmFsc2UsXG4gICAgICAgIG1pbnV0ZTogZmFsc2UsXG4gICAgICAgIHNlY29uZDogZmFsc2UsXG4gICAgICAgIHdlZWtkYXk6IGZhbHNlLFxuICAgICAgICBkYXlQZXJpb2Q6IGZhbHNlLFxuICAgICAgICB0aW1lWm9uZU5hbWU6IGZhbHNlLFxuICAgICAgICBkYXRlU3R5bGU6IGZhbHNlLFxuICAgICAgICB0aW1lU3R5bGU6IGZhbHNlXG4gICAgfSk7XG4gICAgaWYgKCEoJ3llYXInIGluIG9wdGlvbnMgfHwgJ21vbnRoJyBpbiBvcHRpb25zKSkge1xuICAgICAgICBvcHRpb25zID0gT2JqZWN0QXNzaWduJDEob3B0aW9ucywgeyB5ZWFyOiAnbnVtZXJpYycsIG1vbnRoOiAnbnVtZXJpYycgfSk7XG4gICAgfVxuICAgIHJldHVybiBvcHRpb25zO1xufVxuZnVuY3Rpb24gbW9udGhEYXlBbWVuZChvcHRpb25zUGFyYW0pIHtcbiAgICBsZXQgb3B0aW9ucyA9IGFtZW5kKG9wdGlvbnNQYXJhbSwge1xuICAgICAgICB5ZWFyOiBmYWxzZSxcbiAgICAgICAgaG91cjogZmFsc2UsXG4gICAgICAgIG1pbnV0ZTogZmFsc2UsXG4gICAgICAgIHNlY29uZDogZmFsc2UsXG4gICAgICAgIHdlZWtkYXk6IGZhbHNlLFxuICAgICAgICBkYXlQZXJpb2Q6IGZhbHNlLFxuICAgICAgICB0aW1lWm9uZU5hbWU6IGZhbHNlLFxuICAgICAgICBkYXRlU3R5bGU6IGZhbHNlLFxuICAgICAgICB0aW1lU3R5bGU6IGZhbHNlXG4gICAgfSk7XG4gICAgaWYgKCEoJ21vbnRoJyBpbiBvcHRpb25zIHx8ICdkYXknIGluIG9wdGlvbnMpKSB7XG4gICAgICAgIG9wdGlvbnMgPSBPYmplY3RBc3NpZ24kMSh7fSwgb3B0aW9ucywgeyBtb250aDogJ251bWVyaWMnLCBkYXk6ICdudW1lcmljJyB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG9wdGlvbnM7XG59XG5mdW5jdGlvbiBkYXRlQW1lbmQob3B0aW9uc1BhcmFtKSB7XG4gICAgbGV0IG9wdGlvbnMgPSBhbWVuZChvcHRpb25zUGFyYW0sIHtcbiAgICAgICAgaG91cjogZmFsc2UsXG4gICAgICAgIG1pbnV0ZTogZmFsc2UsXG4gICAgICAgIHNlY29uZDogZmFsc2UsXG4gICAgICAgIGRheVBlcmlvZDogZmFsc2UsXG4gICAgICAgIHRpbWVab25lTmFtZTogZmFsc2UsXG4gICAgICAgIHRpbWVTdHlsZTogZmFsc2VcbiAgICB9KTtcbiAgICBpZiAoIWhhc0RhdGVPcHRpb25zKG9wdGlvbnMpKSB7XG4gICAgICAgIG9wdGlvbnMgPSBPYmplY3RBc3NpZ24kMSh7fSwgb3B0aW9ucywge1xuICAgICAgICAgICAgeWVhcjogJ251bWVyaWMnLFxuICAgICAgICAgICAgbW9udGg6ICdudW1lcmljJyxcbiAgICAgICAgICAgIGRheTogJ251bWVyaWMnXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gb3B0aW9ucztcbn1cbmZ1bmN0aW9uIGRhdGV0aW1lQW1lbmQob3B0aW9uc1BhcmFtKSB7XG4gICAgbGV0IG9wdGlvbnMgPSBhbWVuZChvcHRpb25zUGFyYW0sIHsgdGltZVpvbmVOYW1lOiBmYWxzZSB9KTtcbiAgICBpZiAoIWhhc1RpbWVPcHRpb25zKG9wdGlvbnMpICYmICFoYXNEYXRlT3B0aW9ucyhvcHRpb25zKSkge1xuICAgICAgICBvcHRpb25zID0gT2JqZWN0QXNzaWduJDEoe30sIG9wdGlvbnMsIHtcbiAgICAgICAgICAgIHllYXI6ICdudW1lcmljJyxcbiAgICAgICAgICAgIG1vbnRoOiAnbnVtZXJpYycsXG4gICAgICAgICAgICBkYXk6ICdudW1lcmljJyxcbiAgICAgICAgICAgIGhvdXI6ICdudW1lcmljJyxcbiAgICAgICAgICAgIG1pbnV0ZTogJ251bWVyaWMnLFxuICAgICAgICAgICAgc2Vjb25kOiAnbnVtZXJpYydcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBvcHRpb25zO1xufVxuZnVuY3Rpb24gem9uZWREYXRlVGltZUFtZW5kKG9wdGlvbnNQYXJhbSkge1xuICAgIGxldCBvcHRpb25zID0gb3B0aW9uc1BhcmFtO1xuICAgIGlmICghaGFzVGltZU9wdGlvbnMob3B0aW9ucykgJiYgIWhhc0RhdGVPcHRpb25zKG9wdGlvbnMpKSB7XG4gICAgICAgIG9wdGlvbnMgPSBPYmplY3RBc3NpZ24kMSh7fSwgb3B0aW9ucywge1xuICAgICAgICAgICAgeWVhcjogJ251bWVyaWMnLFxuICAgICAgICAgICAgbW9udGg6ICdudW1lcmljJyxcbiAgICAgICAgICAgIGRheTogJ251bWVyaWMnLFxuICAgICAgICAgICAgaG91cjogJ251bWVyaWMnLFxuICAgICAgICAgICAgbWludXRlOiAnbnVtZXJpYycsXG4gICAgICAgICAgICBzZWNvbmQ6ICdudW1lcmljJ1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKG9wdGlvbnMudGltZVpvbmVOYW1lID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICBvcHRpb25zLnRpbWVab25lTmFtZSA9ICdzaG9ydCc7XG4gICAgfVxuICAgIHJldHVybiBvcHRpb25zO1xufVxuZnVuY3Rpb24gaW5zdGFudEFtZW5kKG9wdGlvbnNQYXJhbSkge1xuICAgIGxldCBvcHRpb25zID0gb3B0aW9uc1BhcmFtO1xuICAgIGlmICghaGFzVGltZU9wdGlvbnMob3B0aW9ucykgJiYgIWhhc0RhdGVPcHRpb25zKG9wdGlvbnMpKSB7XG4gICAgICAgIG9wdGlvbnMgPSBPYmplY3RBc3NpZ24kMSh7fSwgb3B0aW9ucywge1xuICAgICAgICAgICAgeWVhcjogJ251bWVyaWMnLFxuICAgICAgICAgICAgbW9udGg6ICdudW1lcmljJyxcbiAgICAgICAgICAgIGRheTogJ251bWVyaWMnLFxuICAgICAgICAgICAgaG91cjogJ251bWVyaWMnLFxuICAgICAgICAgICAgbWludXRlOiAnbnVtZXJpYycsXG4gICAgICAgICAgICBzZWNvbmQ6ICdudW1lcmljJ1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG9wdGlvbnM7XG59XG5mdW5jdGlvbiBoYXNEYXRlT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgcmV0dXJuICd5ZWFyJyBpbiBvcHRpb25zIHx8ICdtb250aCcgaW4gb3B0aW9ucyB8fCAnZGF5JyBpbiBvcHRpb25zIHx8ICd3ZWVrZGF5JyBpbiBvcHRpb25zIHx8ICdkYXRlU3R5bGUnIGluIG9wdGlvbnM7XG59XG5mdW5jdGlvbiBoYXNUaW1lT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgcmV0dXJuICgnaG91cicgaW4gb3B0aW9ucyB8fCAnbWludXRlJyBpbiBvcHRpb25zIHx8ICdzZWNvbmQnIGluIG9wdGlvbnMgfHwgJ3RpbWVTdHlsZScgaW4gb3B0aW9ucyB8fCAnZGF5UGVyaW9kJyBpbiBvcHRpb25zKTtcbn1cbmZ1bmN0aW9uIGlzVGVtcG9yYWxPYmplY3Qob2JqKSB7XG4gICAgcmV0dXJuIChJc1RlbXBvcmFsRGF0ZShvYmopIHx8XG4gICAgICAgIElzVGVtcG9yYWxUaW1lKG9iaikgfHxcbiAgICAgICAgSXNUZW1wb3JhbERhdGVUaW1lKG9iaikgfHxcbiAgICAgICAgSXNUZW1wb3JhbFpvbmVkRGF0ZVRpbWUob2JqKSB8fFxuICAgICAgICBJc1RlbXBvcmFsWWVhck1vbnRoKG9iaikgfHxcbiAgICAgICAgSXNUZW1wb3JhbE1vbnRoRGF5KG9iaikgfHxcbiAgICAgICAgSXNUZW1wb3JhbEluc3RhbnQob2JqKSk7XG59XG5mdW5jdGlvbiBzYW1lVGVtcG9yYWxUeXBlKHgsIHkpIHtcbiAgICBpZiAoIWlzVGVtcG9yYWxPYmplY3QoeCkgfHwgIWlzVGVtcG9yYWxPYmplY3QoeSkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoSXNUZW1wb3JhbFRpbWUoeCkgJiYgIUlzVGVtcG9yYWxUaW1lKHkpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKElzVGVtcG9yYWxEYXRlKHgpICYmICFJc1RlbXBvcmFsRGF0ZSh5KSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChJc1RlbXBvcmFsRGF0ZVRpbWUoeCkgJiYgIUlzVGVtcG9yYWxEYXRlVGltZSh5KSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChJc1RlbXBvcmFsWm9uZWREYXRlVGltZSh4KSAmJiAhSXNUZW1wb3JhbFpvbmVkRGF0ZVRpbWUoeSkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoSXNUZW1wb3JhbFllYXJNb250aCh4KSAmJiAhSXNUZW1wb3JhbFllYXJNb250aCh5KSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChJc1RlbXBvcmFsTW9udGhEYXkoeCkgJiYgIUlzVGVtcG9yYWxNb250aERheSh5KSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChJc1RlbXBvcmFsSW5zdGFudCh4KSAmJiAhSXNUZW1wb3JhbEluc3RhbnQoeSkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGV4dHJhY3RPdmVycmlkZXModGVtcG9yYWxPYmosIG1haW4pIHtcbiAgICBjb25zdCBEYXRlVGltZSA9IEdldEludHJpbnNpYygnJVRlbXBvcmFsLlBsYWluRGF0ZVRpbWUlJyk7XG4gICAgaWYgKElzVGVtcG9yYWxUaW1lKHRlbXBvcmFsT2JqKSkge1xuICAgICAgICBjb25zdCBob3VyID0gR2V0U2xvdCh0ZW1wb3JhbE9iaiwgSVNPX0hPVVIpO1xuICAgICAgICBjb25zdCBtaW51dGUgPSBHZXRTbG90KHRlbXBvcmFsT2JqLCBJU09fTUlOVVRFKTtcbiAgICAgICAgY29uc3Qgc2Vjb25kID0gR2V0U2xvdCh0ZW1wb3JhbE9iaiwgSVNPX1NFQ09ORCk7XG4gICAgICAgIGNvbnN0IG1pbGxpc2Vjb25kID0gR2V0U2xvdCh0ZW1wb3JhbE9iaiwgSVNPX01JTExJU0VDT05EKTtcbiAgICAgICAgY29uc3QgbWljcm9zZWNvbmQgPSBHZXRTbG90KHRlbXBvcmFsT2JqLCBJU09fTUlDUk9TRUNPTkQpO1xuICAgICAgICBjb25zdCBuYW5vc2Vjb25kID0gR2V0U2xvdCh0ZW1wb3JhbE9iaiwgSVNPX05BTk9TRUNPTkQpO1xuICAgICAgICBjb25zdCBkYXRldGltZSA9IG5ldyBEYXRlVGltZSgxOTcwLCAxLCAxLCBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQsIG1pY3Jvc2Vjb25kLCBuYW5vc2Vjb25kLCBtYWluW0NBTF9JRF0pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaW5zdGFudDogQnVpbHRpblRpbWVab25lR2V0SW5zdGFudEZvcihnZXRSZXNvbHZlZFRpbWVab25lTGF6eShtYWluKSwgZGF0ZXRpbWUsICdjb21wYXRpYmxlJyksXG4gICAgICAgICAgICBmb3JtYXR0ZXI6IGdldFByb3BMYXp5KG1haW4sIFRJTUUpXG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmIChJc1RlbXBvcmFsWWVhck1vbnRoKHRlbXBvcmFsT2JqKSkge1xuICAgICAgICBjb25zdCBpc29ZZWFyID0gR2V0U2xvdCh0ZW1wb3JhbE9iaiwgSVNPX1lFQVIpO1xuICAgICAgICBjb25zdCBpc29Nb250aCA9IEdldFNsb3QodGVtcG9yYWxPYmosIElTT19NT05USCk7XG4gICAgICAgIGNvbnN0IHJlZmVyZW5jZUlTT0RheSA9IEdldFNsb3QodGVtcG9yYWxPYmosIElTT19EQVkpO1xuICAgICAgICBjb25zdCBjYWxlbmRhciA9IFRvU3RyaW5nKEdldFNsb3QodGVtcG9yYWxPYmosIENBTEVOREFSKSk7XG4gICAgICAgIGlmIChjYWxlbmRhciAhPT0gbWFpbltDQUxfSURdKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgY2Fubm90IGZvcm1hdCBQbGFpblllYXJNb250aCB3aXRoIGNhbGVuZGFyICR7Y2FsZW5kYXJ9IGluIGxvY2FsZSB3aXRoIGNhbGVuZGFyICR7bWFpbltDQUxfSURdfWApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRhdGV0aW1lID0gbmV3IERhdGVUaW1lKGlzb1llYXIsIGlzb01vbnRoLCByZWZlcmVuY2VJU09EYXksIDEyLCAwLCAwLCAwLCAwLCAwLCBjYWxlbmRhcik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpbnN0YW50OiBCdWlsdGluVGltZVpvbmVHZXRJbnN0YW50Rm9yKGdldFJlc29sdmVkVGltZVpvbmVMYXp5KG1haW4pLCBkYXRldGltZSwgJ2NvbXBhdGlibGUnKSxcbiAgICAgICAgICAgIGZvcm1hdHRlcjogZ2V0UHJvcExhenkobWFpbiwgWU0pXG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmIChJc1RlbXBvcmFsTW9udGhEYXkodGVtcG9yYWxPYmopKSB7XG4gICAgICAgIGNvbnN0IHJlZmVyZW5jZUlTT1llYXIgPSBHZXRTbG90KHRlbXBvcmFsT2JqLCBJU09fWUVBUik7XG4gICAgICAgIGNvbnN0IGlzb01vbnRoID0gR2V0U2xvdCh0ZW1wb3JhbE9iaiwgSVNPX01PTlRIKTtcbiAgICAgICAgY29uc3QgaXNvRGF5ID0gR2V0U2xvdCh0ZW1wb3JhbE9iaiwgSVNPX0RBWSk7XG4gICAgICAgIGNvbnN0IGNhbGVuZGFyID0gVG9TdHJpbmcoR2V0U2xvdCh0ZW1wb3JhbE9iaiwgQ0FMRU5EQVIpKTtcbiAgICAgICAgaWYgKGNhbGVuZGFyICE9PSBtYWluW0NBTF9JRF0pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBjYW5ub3QgZm9ybWF0IFBsYWluTW9udGhEYXkgd2l0aCBjYWxlbmRhciAke2NhbGVuZGFyfSBpbiBsb2NhbGUgd2l0aCBjYWxlbmRhciAke21haW5bQ0FMX0lEXX1gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkYXRldGltZSA9IG5ldyBEYXRlVGltZShyZWZlcmVuY2VJU09ZZWFyLCBpc29Nb250aCwgaXNvRGF5LCAxMiwgMCwgMCwgMCwgMCwgMCwgY2FsZW5kYXIpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaW5zdGFudDogQnVpbHRpblRpbWVab25lR2V0SW5zdGFudEZvcihnZXRSZXNvbHZlZFRpbWVab25lTGF6eShtYWluKSwgZGF0ZXRpbWUsICdjb21wYXRpYmxlJyksXG4gICAgICAgICAgICBmb3JtYXR0ZXI6IGdldFByb3BMYXp5KG1haW4sIE1EKVxuICAgICAgICB9O1xuICAgIH1cbiAgICBpZiAoSXNUZW1wb3JhbERhdGUodGVtcG9yYWxPYmopKSB7XG4gICAgICAgIGNvbnN0IGlzb1llYXIgPSBHZXRTbG90KHRlbXBvcmFsT2JqLCBJU09fWUVBUik7XG4gICAgICAgIGNvbnN0IGlzb01vbnRoID0gR2V0U2xvdCh0ZW1wb3JhbE9iaiwgSVNPX01PTlRIKTtcbiAgICAgICAgY29uc3QgaXNvRGF5ID0gR2V0U2xvdCh0ZW1wb3JhbE9iaiwgSVNPX0RBWSk7XG4gICAgICAgIGNvbnN0IGNhbGVuZGFyID0gVG9TdHJpbmcoR2V0U2xvdCh0ZW1wb3JhbE9iaiwgQ0FMRU5EQVIpKTtcbiAgICAgICAgaWYgKGNhbGVuZGFyICE9PSAnaXNvODYwMScgJiYgY2FsZW5kYXIgIT09IG1haW5bQ0FMX0lEXSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYGNhbm5vdCBmb3JtYXQgUGxhaW5EYXRlIHdpdGggY2FsZW5kYXIgJHtjYWxlbmRhcn0gaW4gbG9jYWxlIHdpdGggY2FsZW5kYXIgJHttYWluW0NBTF9JRF19YCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGF0ZXRpbWUgPSBuZXcgRGF0ZVRpbWUoaXNvWWVhciwgaXNvTW9udGgsIGlzb0RheSwgMTIsIDAsIDAsIDAsIDAsIDAsIG1haW5bQ0FMX0lEXSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpbnN0YW50OiBCdWlsdGluVGltZVpvbmVHZXRJbnN0YW50Rm9yKGdldFJlc29sdmVkVGltZVpvbmVMYXp5KG1haW4pLCBkYXRldGltZSwgJ2NvbXBhdGlibGUnKSxcbiAgICAgICAgICAgIGZvcm1hdHRlcjogZ2V0UHJvcExhenkobWFpbiwgREFURSlcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKElzVGVtcG9yYWxEYXRlVGltZSh0ZW1wb3JhbE9iaikpIHtcbiAgICAgICAgY29uc3QgaXNvWWVhciA9IEdldFNsb3QodGVtcG9yYWxPYmosIElTT19ZRUFSKTtcbiAgICAgICAgY29uc3QgaXNvTW9udGggPSBHZXRTbG90KHRlbXBvcmFsT2JqLCBJU09fTU9OVEgpO1xuICAgICAgICBjb25zdCBpc29EYXkgPSBHZXRTbG90KHRlbXBvcmFsT2JqLCBJU09fREFZKTtcbiAgICAgICAgY29uc3QgaG91ciA9IEdldFNsb3QodGVtcG9yYWxPYmosIElTT19IT1VSKTtcbiAgICAgICAgY29uc3QgbWludXRlID0gR2V0U2xvdCh0ZW1wb3JhbE9iaiwgSVNPX01JTlVURSk7XG4gICAgICAgIGNvbnN0IHNlY29uZCA9IEdldFNsb3QodGVtcG9yYWxPYmosIElTT19TRUNPTkQpO1xuICAgICAgICBjb25zdCBtaWxsaXNlY29uZCA9IEdldFNsb3QodGVtcG9yYWxPYmosIElTT19NSUxMSVNFQ09ORCk7XG4gICAgICAgIGNvbnN0IG1pY3Jvc2Vjb25kID0gR2V0U2xvdCh0ZW1wb3JhbE9iaiwgSVNPX01JQ1JPU0VDT05EKTtcbiAgICAgICAgY29uc3QgbmFub3NlY29uZCA9IEdldFNsb3QodGVtcG9yYWxPYmosIElTT19OQU5PU0VDT05EKTtcbiAgICAgICAgY29uc3QgY2FsZW5kYXIgPSBUb1N0cmluZyhHZXRTbG90KHRlbXBvcmFsT2JqLCBDQUxFTkRBUikpO1xuICAgICAgICBpZiAoY2FsZW5kYXIgIT09ICdpc284NjAxJyAmJiBjYWxlbmRhciAhPT0gbWFpbltDQUxfSURdKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgY2Fubm90IGZvcm1hdCBQbGFpbkRhdGVUaW1lIHdpdGggY2FsZW5kYXIgJHtjYWxlbmRhcn0gaW4gbG9jYWxlIHdpdGggY2FsZW5kYXIgJHttYWluW0NBTF9JRF19YCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGRhdGV0aW1lID0gdGVtcG9yYWxPYmo7XG4gICAgICAgIGlmIChjYWxlbmRhciA9PT0gJ2lzbzg2MDEnKSB7XG4gICAgICAgICAgICBkYXRldGltZSA9IG5ldyBEYXRlVGltZShpc29ZZWFyLCBpc29Nb250aCwgaXNvRGF5LCBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQsIG1pY3Jvc2Vjb25kLCBuYW5vc2Vjb25kLCBtYWluW0NBTF9JRF0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpbnN0YW50OiBCdWlsdGluVGltZVpvbmVHZXRJbnN0YW50Rm9yKGdldFJlc29sdmVkVGltZVpvbmVMYXp5KG1haW4pLCBkYXRldGltZSwgJ2NvbXBhdGlibGUnKSxcbiAgICAgICAgICAgIGZvcm1hdHRlcjogZ2V0UHJvcExhenkobWFpbiwgREFURVRJTUUpXG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmIChJc1RlbXBvcmFsWm9uZWREYXRlVGltZSh0ZW1wb3JhbE9iaikpIHtcbiAgICAgICAgY29uc3QgY2FsZW5kYXIgPSBUb1N0cmluZyhHZXRTbG90KHRlbXBvcmFsT2JqLCBDQUxFTkRBUikpO1xuICAgICAgICBpZiAoY2FsZW5kYXIgIT09ICdpc284NjAxJyAmJiBjYWxlbmRhciAhPT0gbWFpbltDQUxfSURdKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgY2Fubm90IGZvcm1hdCBab25lZERhdGVUaW1lIHdpdGggY2FsZW5kYXIgJHtjYWxlbmRhcn0gaW4gbG9jYWxlIHdpdGggY2FsZW5kYXIgJHttYWluW0NBTF9JRF19YCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGltZVpvbmUgPSBHZXRTbG90KHRlbXBvcmFsT2JqLCBUSU1FX1pPTkUpO1xuICAgICAgICBjb25zdCBvYmpUaW1lWm9uZSA9IFRvU3RyaW5nKHRpbWVab25lKTtcbiAgICAgICAgaWYgKG1haW5bVFpfR0lWRU5dICYmIG1haW5bVFpfR0lWRU5dICE9PSBvYmpUaW1lWm9uZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYHRpbWVab25lIG9wdGlvbiAke21haW5bVFpfR0lWRU5dfSBkb2Vzbid0IG1hdGNoIGFjdHVhbCB0aW1lIHpvbmUgJHtvYmpUaW1lWm9uZX1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaW5zdGFudDogR2V0U2xvdCh0ZW1wb3JhbE9iaiwgSU5TVEFOVCksXG4gICAgICAgICAgICBmb3JtYXR0ZXI6IGdldFByb3BMYXp5KG1haW4sIFpPTkVEKSxcbiAgICAgICAgICAgIHRpbWVab25lOiBvYmpUaW1lWm9uZVxuICAgICAgICB9O1xuICAgIH1cbiAgICBpZiAoSXNUZW1wb3JhbEluc3RhbnQodGVtcG9yYWxPYmopKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpbnN0YW50OiB0ZW1wb3JhbE9iaixcbiAgICAgICAgICAgIGZvcm1hdHRlcjogZ2V0UHJvcExhenkobWFpbiwgSU5TVClcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHt9O1xufVxuXG52YXIgaW50bCA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgRGF0ZVRpbWVGb3JtYXQ6IERhdGVUaW1lRm9ybWF0XG59KTtcblxuY29uc3QgRElTQUxMT1dFRF9VTklUUyQzID0gWyd5ZWFyJywgJ21vbnRoJywgJ3dlZWsnLCAnZGF5J107XG5jb25zdCBNQVhfRElGRkVSRU5DRV9JTkNSRU1FTlRTID0ge1xuICAgIGhvdXI6IDI0LFxuICAgIG1pbnV0ZTogNjAsXG4gICAgc2Vjb25kOiA2MCxcbiAgICBtaWxsaXNlY29uZDogMTAwMCxcbiAgICBtaWNyb3NlY29uZDogMTAwMCxcbiAgICBuYW5vc2Vjb25kOiAxMDAwXG59O1xuY2xhc3MgSW5zdGFudCB7XG4gICAgY29uc3RydWN0b3IoZXBvY2hOYW5vc2Vjb25kcykge1xuICAgICAgICAvLyBOb3RlOiBpZiB0aGUgYXJndW1lbnQgaXMgbm90IHBhc3NlZCwgVG9CaWdJbnQodW5kZWZpbmVkKSB3aWxsIHRocm93LiBUaGlzIGNoZWNrIGV4aXN0cyBvbmx5XG4gICAgICAgIC8vICAgICAgIHRvIGltcHJvdmUgdGhlIGVycm9yIG1lc3NhZ2UuXG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbWlzc2luZyBhcmd1bWVudDogZXBvY2hOYW5vc2Vjb25kcyBpcyByZXF1aXJlZCcpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5zID0gVG9CaWdJbnQoZXBvY2hOYW5vc2Vjb25kcyk7XG4gICAgICAgIFZhbGlkYXRlRXBvY2hOYW5vc2Vjb25kcyhucyk7XG4gICAgICAgIENyZWF0ZVNsb3RzKHRoaXMpO1xuICAgICAgICBTZXRTbG90KHRoaXMsIEVQT0NITkFOT1NFQ09ORFMsIG5zKTtcbiAgICAgICAge1xuICAgICAgICAgICAgY29uc3QgcmVwciA9IFRlbXBvcmFsSW5zdGFudFRvU3RyaW5nKHRoaXMsIHVuZGVmaW5lZCwgJ2F1dG8nKTtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnX3JlcHJfJywge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBgJHt0aGlzW1N5bWJvbC50b1N0cmluZ1RhZ119IDwke3JlcHJ9PmAsXG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBlcG9jaFNlY29uZHMoKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbEluc3RhbnQodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gR2V0U2xvdCh0aGlzLCBFUE9DSE5BTk9TRUNPTkRTKTtcbiAgICAgICAgcmV0dXJuIEpTQkkudG9OdW1iZXIoSlNCSS5kaXZpZGUodmFsdWUsIEJJTExJT04pKTtcbiAgICB9XG4gICAgZ2V0IGVwb2NoTWlsbGlzZWNvbmRzKCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxJbnN0YW50KHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IEpTQkkuQmlnSW50KEdldFNsb3QodGhpcywgRVBPQ0hOQU5PU0VDT05EUykpO1xuICAgICAgICByZXR1cm4gSlNCSS50b051bWJlcihKU0JJLmRpdmlkZSh2YWx1ZSwgTUlMTElPTikpO1xuICAgIH1cbiAgICBnZXQgZXBvY2hNaWNyb3NlY29uZHMoKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbEluc3RhbnQodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gSlNCSS5CaWdJbnQoR2V0U2xvdCh0aGlzLCBFUE9DSE5BTk9TRUNPTkRTKSk7XG4gICAgICAgIHJldHVybiBUb0JpZ0ludEV4dGVybmFsKEpTQkkuZGl2aWRlKHZhbHVlLCBUSE9VU0FORCkpO1xuICAgIH1cbiAgICBnZXQgZXBvY2hOYW5vc2Vjb25kcygpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsSW5zdGFudCh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgcmV0dXJuIFRvQmlnSW50RXh0ZXJuYWwoSlNCSS5CaWdJbnQoR2V0U2xvdCh0aGlzLCBFUE9DSE5BTk9TRUNPTkRTKSkpO1xuICAgIH1cbiAgICBhZGQodGVtcG9yYWxEdXJhdGlvbkxpa2UpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsSW5zdGFudCh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgY29uc3QgeyBob3VycywgbWludXRlcywgc2Vjb25kcywgbWlsbGlzZWNvbmRzLCBtaWNyb3NlY29uZHMsIG5hbm9zZWNvbmRzIH0gPSBUb0xpbWl0ZWRUZW1wb3JhbER1cmF0aW9uKHRlbXBvcmFsRHVyYXRpb25MaWtlLCBbJ3llYXJzJywgJ21vbnRocycsICd3ZWVrcycsICdkYXlzJ10pO1xuICAgICAgICBjb25zdCBucyA9IEFkZEluc3RhbnQoR2V0U2xvdCh0aGlzLCBFUE9DSE5BTk9TRUNPTkRTKSwgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc2Vjb25kcywgbWljcm9zZWNvbmRzLCBuYW5vc2Vjb25kcyk7XG4gICAgICAgIHJldHVybiBuZXcgSW5zdGFudChucyk7XG4gICAgfVxuICAgIHN1YnRyYWN0KHRlbXBvcmFsRHVyYXRpb25MaWtlKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbEluc3RhbnQodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIGNvbnN0IHsgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc2Vjb25kcywgbWljcm9zZWNvbmRzLCBuYW5vc2Vjb25kcyB9ID0gVG9MaW1pdGVkVGVtcG9yYWxEdXJhdGlvbih0ZW1wb3JhbER1cmF0aW9uTGlrZSwgWyd5ZWFycycsICdtb250aHMnLCAnd2Vla3MnLCAnZGF5cyddKTtcbiAgICAgICAgY29uc3QgbnMgPSBBZGRJbnN0YW50KEdldFNsb3QodGhpcywgRVBPQ0hOQU5PU0VDT05EUyksIC1ob3VycywgLW1pbnV0ZXMsIC1zZWNvbmRzLCAtbWlsbGlzZWNvbmRzLCAtbWljcm9zZWNvbmRzLCAtbmFub3NlY29uZHMpO1xuICAgICAgICByZXR1cm4gbmV3IEluc3RhbnQobnMpO1xuICAgIH1cbiAgICB1bnRpbChvdGhlclBhcmFtLCBvcHRpb25zUGFyYW0gPSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsSW5zdGFudCh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgY29uc3Qgb3RoZXIgPSBUb1RlbXBvcmFsSW5zdGFudChvdGhlclBhcmFtKTtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IEdldE9wdGlvbnNPYmplY3Qob3B0aW9uc1BhcmFtKTtcbiAgICAgICAgY29uc3Qgc21hbGxlc3RVbml0ID0gVG9TbWFsbGVzdFRlbXBvcmFsVW5pdChvcHRpb25zLCAnbmFub3NlY29uZCcsIERJU0FMTE9XRURfVU5JVFMkMyk7XG4gICAgICAgIGNvbnN0IGRlZmF1bHRMYXJnZXN0VW5pdCA9IExhcmdlck9mVHdvVGVtcG9yYWxVbml0cygnc2Vjb25kJywgc21hbGxlc3RVbml0KTtcbiAgICAgICAgY29uc3QgbGFyZ2VzdFVuaXQgPSBUb0xhcmdlc3RUZW1wb3JhbFVuaXQob3B0aW9ucywgJ2F1dG8nLCBESVNBTExPV0VEX1VOSVRTJDMsIGRlZmF1bHRMYXJnZXN0VW5pdCk7XG4gICAgICAgIFZhbGlkYXRlVGVtcG9yYWxVbml0UmFuZ2UobGFyZ2VzdFVuaXQsIHNtYWxsZXN0VW5pdCk7XG4gICAgICAgIGNvbnN0IHJvdW5kaW5nTW9kZSA9IFRvVGVtcG9yYWxSb3VuZGluZ01vZGUob3B0aW9ucywgJ3RydW5jJyk7XG4gICAgICAgIGNvbnN0IHJvdW5kaW5nSW5jcmVtZW50ID0gVG9UZW1wb3JhbFJvdW5kaW5nSW5jcmVtZW50KG9wdGlvbnMsIE1BWF9ESUZGRVJFTkNFX0lOQ1JFTUVOVFNbc21hbGxlc3RVbml0XSwgZmFsc2UpO1xuICAgICAgICBjb25zdCBvbmVucyA9IEdldFNsb3QodGhpcywgRVBPQ0hOQU5PU0VDT05EUyk7XG4gICAgICAgIGNvbnN0IHR3b25zID0gR2V0U2xvdChvdGhlciwgRVBPQ0hOQU5PU0VDT05EUyk7XG4gICAgICAgIGxldCB7IHNlY29uZHMsIG1pbGxpc2Vjb25kcywgbWljcm9zZWNvbmRzLCBuYW5vc2Vjb25kcyB9ID0gRGlmZmVyZW5jZUluc3RhbnQob25lbnMsIHR3b25zLCByb3VuZGluZ0luY3JlbWVudCwgc21hbGxlc3RVbml0LCByb3VuZGluZ01vZGUpO1xuICAgICAgICBsZXQgaG91cnMsIG1pbnV0ZXM7XG4gICAgICAgICh7IGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBtaWxsaXNlY29uZHMsIG1pY3Jvc2Vjb25kcywgbmFub3NlY29uZHMgfSA9IEJhbGFuY2VEdXJhdGlvbigwLCAwLCAwLCBzZWNvbmRzLCBtaWxsaXNlY29uZHMsIG1pY3Jvc2Vjb25kcywgbmFub3NlY29uZHMsIGxhcmdlc3RVbml0KSk7XG4gICAgICAgIGNvbnN0IER1cmF0aW9uID0gR2V0SW50cmluc2ljKCclVGVtcG9yYWwuRHVyYXRpb24lJyk7XG4gICAgICAgIHJldHVybiBuZXcgRHVyYXRpb24oMCwgMCwgMCwgMCwgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc2Vjb25kcywgbWljcm9zZWNvbmRzLCBuYW5vc2Vjb25kcyk7XG4gICAgfVxuICAgIHNpbmNlKG90aGVyUGFyYW0sIG9wdGlvbnNQYXJhbSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxJbnN0YW50KHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICBjb25zdCBvdGhlciA9IFRvVGVtcG9yYWxJbnN0YW50KG90aGVyUGFyYW0pO1xuICAgICAgICBjb25zdCBvcHRpb25zID0gR2V0T3B0aW9uc09iamVjdChvcHRpb25zUGFyYW0pO1xuICAgICAgICBjb25zdCBzbWFsbGVzdFVuaXQgPSBUb1NtYWxsZXN0VGVtcG9yYWxVbml0KG9wdGlvbnMsICduYW5vc2Vjb25kJywgRElTQUxMT1dFRF9VTklUUyQzKTtcbiAgICAgICAgY29uc3QgZGVmYXVsdExhcmdlc3RVbml0ID0gTGFyZ2VyT2ZUd29UZW1wb3JhbFVuaXRzKCdzZWNvbmQnLCBzbWFsbGVzdFVuaXQpO1xuICAgICAgICBjb25zdCBsYXJnZXN0VW5pdCA9IFRvTGFyZ2VzdFRlbXBvcmFsVW5pdChvcHRpb25zLCAnYXV0bycsIERJU0FMTE9XRURfVU5JVFMkMywgZGVmYXVsdExhcmdlc3RVbml0KTtcbiAgICAgICAgVmFsaWRhdGVUZW1wb3JhbFVuaXRSYW5nZShsYXJnZXN0VW5pdCwgc21hbGxlc3RVbml0KTtcbiAgICAgICAgY29uc3Qgcm91bmRpbmdNb2RlID0gVG9UZW1wb3JhbFJvdW5kaW5nTW9kZShvcHRpb25zLCAndHJ1bmMnKTtcbiAgICAgICAgY29uc3Qgcm91bmRpbmdJbmNyZW1lbnQgPSBUb1RlbXBvcmFsUm91bmRpbmdJbmNyZW1lbnQob3B0aW9ucywgTUFYX0RJRkZFUkVOQ0VfSU5DUkVNRU5UU1tzbWFsbGVzdFVuaXRdLCBmYWxzZSk7XG4gICAgICAgIGNvbnN0IG9uZW5zID0gR2V0U2xvdChvdGhlciwgRVBPQ0hOQU5PU0VDT05EUyk7XG4gICAgICAgIGNvbnN0IHR3b25zID0gR2V0U2xvdCh0aGlzLCBFUE9DSE5BTk9TRUNPTkRTKTtcbiAgICAgICAgbGV0IHsgc2Vjb25kcywgbWlsbGlzZWNvbmRzLCBtaWNyb3NlY29uZHMsIG5hbm9zZWNvbmRzIH0gPSBEaWZmZXJlbmNlSW5zdGFudChvbmVucywgdHdvbnMsIHJvdW5kaW5nSW5jcmVtZW50LCBzbWFsbGVzdFVuaXQsIHJvdW5kaW5nTW9kZSk7XG4gICAgICAgIGxldCBob3VycywgbWludXRlcztcbiAgICAgICAgKHsgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc2Vjb25kcywgbWljcm9zZWNvbmRzLCBuYW5vc2Vjb25kcyB9ID0gQmFsYW5jZUR1cmF0aW9uKDAsIDAsIDAsIHNlY29uZHMsIG1pbGxpc2Vjb25kcywgbWljcm9zZWNvbmRzLCBuYW5vc2Vjb25kcywgbGFyZ2VzdFVuaXQpKTtcbiAgICAgICAgY29uc3QgRHVyYXRpb24gPSBHZXRJbnRyaW5zaWMoJyVUZW1wb3JhbC5EdXJhdGlvbiUnKTtcbiAgICAgICAgcmV0dXJuIG5ldyBEdXJhdGlvbigwLCAwLCAwLCAwLCBob3VycywgbWludXRlcywgc2Vjb25kcywgbWlsbGlzZWNvbmRzLCBtaWNyb3NlY29uZHMsIG5hbm9zZWNvbmRzKTtcbiAgICB9XG4gICAgcm91bmQob3B0aW9uc1BhcmFtKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbEluc3RhbnQodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIGlmIChvcHRpb25zUGFyYW0gPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ29wdGlvbnMgcGFyYW1ldGVyIGlzIHJlcXVpcmVkJyk7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB0eXBlb2Ygb3B0aW9uc1BhcmFtID09PSAnc3RyaW5nJ1xuICAgICAgICAgICAgPyBDcmVhdGVPbmVQcm9wT2JqZWN0KCdzbWFsbGVzdFVuaXQnLCBvcHRpb25zUGFyYW0pXG4gICAgICAgICAgICA6IEdldE9wdGlvbnNPYmplY3Qob3B0aW9uc1BhcmFtKTtcbiAgICAgICAgY29uc3Qgc21hbGxlc3RVbml0ID0gVG9TbWFsbGVzdFRlbXBvcmFsVW5pdChvcHRpb25zLCB1bmRlZmluZWQsIERJU0FMTE9XRURfVU5JVFMkMyk7XG4gICAgICAgIGlmIChzbWFsbGVzdFVuaXQgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdzbWFsbGVzdFVuaXQgaXMgcmVxdWlyZWQnKTtcbiAgICAgICAgY29uc3Qgcm91bmRpbmdNb2RlID0gVG9UZW1wb3JhbFJvdW5kaW5nTW9kZShvcHRpb25zLCAnaGFsZkV4cGFuZCcpO1xuICAgICAgICBjb25zdCBtYXhpbXVtSW5jcmVtZW50cyA9IHtcbiAgICAgICAgICAgIGhvdXI6IDI0LFxuICAgICAgICAgICAgbWludXRlOiAxNDQwLFxuICAgICAgICAgICAgc2Vjb25kOiA4NjQwMCxcbiAgICAgICAgICAgIG1pbGxpc2Vjb25kOiA4NjQwMGUzLFxuICAgICAgICAgICAgbWljcm9zZWNvbmQ6IDg2NDAwZTYsXG4gICAgICAgICAgICBuYW5vc2Vjb25kOiA4NjQwMGU5XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJvdW5kaW5nSW5jcmVtZW50ID0gVG9UZW1wb3JhbFJvdW5kaW5nSW5jcmVtZW50KG9wdGlvbnMsIG1heGltdW1JbmNyZW1lbnRzW3NtYWxsZXN0VW5pdF0sIHRydWUpO1xuICAgICAgICBjb25zdCBucyA9IEdldFNsb3QodGhpcywgRVBPQ0hOQU5PU0VDT05EUyk7XG4gICAgICAgIGNvbnN0IHJvdW5kZWROcyA9IFJvdW5kSW5zdGFudChucywgcm91bmRpbmdJbmNyZW1lbnQsIHNtYWxsZXN0VW5pdCwgcm91bmRpbmdNb2RlKTtcbiAgICAgICAgcmV0dXJuIG5ldyBJbnN0YW50KHJvdW5kZWROcyk7XG4gICAgfVxuICAgIGVxdWFscyhvdGhlclBhcmFtKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbEluc3RhbnQodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIGNvbnN0IG90aGVyID0gVG9UZW1wb3JhbEluc3RhbnQob3RoZXJQYXJhbSk7XG4gICAgICAgIGNvbnN0IG9uZSA9IEdldFNsb3QodGhpcywgRVBPQ0hOQU5PU0VDT05EUyk7XG4gICAgICAgIGNvbnN0IHR3byA9IEdldFNsb3Qob3RoZXIsIEVQT0NITkFOT1NFQ09ORFMpO1xuICAgICAgICByZXR1cm4gSlNCSS5lcXVhbChKU0JJLkJpZ0ludChvbmUpLCBKU0JJLkJpZ0ludCh0d28pKTtcbiAgICB9XG4gICAgdG9TdHJpbmcob3B0aW9uc1BhcmFtID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbEluc3RhbnQodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSBHZXRPcHRpb25zT2JqZWN0KG9wdGlvbnNQYXJhbSk7XG4gICAgICAgIGxldCB0aW1lWm9uZSA9IG9wdGlvbnMudGltZVpvbmU7XG4gICAgICAgIGlmICh0aW1lWm9uZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgdGltZVpvbmUgPSBUb1RlbXBvcmFsVGltZVpvbmUodGltZVpvbmUpO1xuICAgICAgICAvLyBBbHRob3VnaCBUUyBkb2Vzbid0IGFja25vd2xlZGdlIGl0LCBiZWxvdyBoZXJlIGB0aW1lWm9uZWAgaXMgYSBUZW1wb3JhbC5UaW1lWm9uZVByb3RvY29sXG4gICAgICAgIGNvbnN0IHsgcHJlY2lzaW9uLCB1bml0LCBpbmNyZW1lbnQgfSA9IFRvU2Vjb25kc1N0cmluZ1ByZWNpc2lvbihvcHRpb25zKTtcbiAgICAgICAgY29uc3Qgcm91bmRpbmdNb2RlID0gVG9UZW1wb3JhbFJvdW5kaW5nTW9kZShvcHRpb25zLCAndHJ1bmMnKTtcbiAgICAgICAgY29uc3QgbnMgPSBHZXRTbG90KHRoaXMsIEVQT0NITkFOT1NFQ09ORFMpO1xuICAgICAgICBjb25zdCByb3VuZGVkTnMgPSBSb3VuZEluc3RhbnQobnMsIGluY3JlbWVudCwgdW5pdCwgcm91bmRpbmdNb2RlKTtcbiAgICAgICAgY29uc3Qgcm91bmRlZEluc3RhbnQgPSBuZXcgSW5zdGFudChyb3VuZGVkTnMpO1xuICAgICAgICByZXR1cm4gVGVtcG9yYWxJbnN0YW50VG9TdHJpbmcocm91bmRlZEluc3RhbnQsIHRpbWVab25lLCBwcmVjaXNpb24pO1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbEluc3RhbnQodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIHJldHVybiBUZW1wb3JhbEluc3RhbnRUb1N0cmluZyh0aGlzLCB1bmRlZmluZWQsICdhdXRvJyk7XG4gICAgfVxuICAgIHRvTG9jYWxlU3RyaW5nKGxvY2FsZXMgPSB1bmRlZmluZWQsIG9wdGlvbnMgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsSW5zdGFudCh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlVGltZUZvcm1hdChsb2NhbGVzLCBvcHRpb25zKS5mb3JtYXQodGhpcyk7XG4gICAgfVxuICAgIHZhbHVlT2YoKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3VzZSBjb21wYXJlKCkgb3IgZXF1YWxzKCkgdG8gY29tcGFyZSBUZW1wb3JhbC5JbnN0YW50Jyk7XG4gICAgfVxuICAgIHRvWm9uZWREYXRlVGltZShpdGVtKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbEluc3RhbnQodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIGlmICghSXNPYmplY3QoaXRlbSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgYXJndW1lbnQgaW4gdG9ab25lZERhdGVUaW1lJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2FsZW5kYXJMaWtlID0gaXRlbS5jYWxlbmRhcjtcbiAgICAgICAgaWYgKGNhbGVuZGFyTGlrZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdtaXNzaW5nIGNhbGVuZGFyIHByb3BlcnR5IGluIHRvWm9uZWREYXRlVGltZScpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNhbGVuZGFyID0gVG9UZW1wb3JhbENhbGVuZGFyKGNhbGVuZGFyTGlrZSk7XG4gICAgICAgIGNvbnN0IHRlbXBvcmFsVGltZVpvbmVMaWtlID0gaXRlbS50aW1lWm9uZTtcbiAgICAgICAgaWYgKHRlbXBvcmFsVGltZVpvbmVMaWtlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ21pc3NpbmcgdGltZVpvbmUgcHJvcGVydHkgaW4gdG9ab25lZERhdGVUaW1lJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGltZVpvbmUgPSBUb1RlbXBvcmFsVGltZVpvbmUodGVtcG9yYWxUaW1lWm9uZUxpa2UpO1xuICAgICAgICByZXR1cm4gQ3JlYXRlVGVtcG9yYWxab25lZERhdGVUaW1lKEdldFNsb3QodGhpcywgRVBPQ0hOQU5PU0VDT05EUyksIHRpbWVab25lLCBjYWxlbmRhcik7XG4gICAgfVxuICAgIHRvWm9uZWREYXRlVGltZUlTTyhpdGVtUGFyYW0pIHtcbiAgICAgICAgbGV0IGl0ZW0gPSBpdGVtUGFyYW07XG4gICAgICAgIGlmICghSXNUZW1wb3JhbEluc3RhbnQodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIGlmIChJc09iamVjdChpdGVtKSkge1xuICAgICAgICAgICAgY29uc3QgdGltZVpvbmVQcm9wZXJ0eSA9IGl0ZW0udGltZVpvbmU7XG4gICAgICAgICAgICBpZiAodGltZVpvbmVQcm9wZXJ0eSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgaXRlbSA9IHRpbWVab25lUHJvcGVydHk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGltZVpvbmUgPSBUb1RlbXBvcmFsVGltZVpvbmUoaXRlbSk7XG4gICAgICAgIGNvbnN0IGNhbGVuZGFyID0gR2V0SVNPODYwMUNhbGVuZGFyKCk7XG4gICAgICAgIHJldHVybiBDcmVhdGVUZW1wb3JhbFpvbmVkRGF0ZVRpbWUoR2V0U2xvdCh0aGlzLCBFUE9DSE5BTk9TRUNPTkRTKSwgdGltZVpvbmUsIGNhbGVuZGFyKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21FcG9jaFNlY29uZHMoZXBvY2hTZWNvbmRzUGFyYW0pIHtcbiAgICAgICAgY29uc3QgZXBvY2hTZWNvbmRzID0gVG9OdW1iZXIoZXBvY2hTZWNvbmRzUGFyYW0pO1xuICAgICAgICBjb25zdCBlcG9jaE5hbm9zZWNvbmRzID0gSlNCSS5tdWx0aXBseShKU0JJLkJpZ0ludChlcG9jaFNlY29uZHMpLCBCSUxMSU9OKTtcbiAgICAgICAgVmFsaWRhdGVFcG9jaE5hbm9zZWNvbmRzKGVwb2NoTmFub3NlY29uZHMpO1xuICAgICAgICByZXR1cm4gbmV3IEluc3RhbnQoZXBvY2hOYW5vc2Vjb25kcyk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tRXBvY2hNaWxsaXNlY29uZHMoZXBvY2hNaWxsaXNlY29uZHNQYXJhbSkge1xuICAgICAgICBjb25zdCBlcG9jaE1pbGxpc2Vjb25kcyA9IFRvTnVtYmVyKGVwb2NoTWlsbGlzZWNvbmRzUGFyYW0pO1xuICAgICAgICBjb25zdCBlcG9jaE5hbm9zZWNvbmRzID0gSlNCSS5tdWx0aXBseShKU0JJLkJpZ0ludChlcG9jaE1pbGxpc2Vjb25kcyksIE1JTExJT04pO1xuICAgICAgICBWYWxpZGF0ZUVwb2NoTmFub3NlY29uZHMoZXBvY2hOYW5vc2Vjb25kcyk7XG4gICAgICAgIHJldHVybiBuZXcgSW5zdGFudChlcG9jaE5hbm9zZWNvbmRzKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21FcG9jaE1pY3Jvc2Vjb25kcyhlcG9jaE1pY3Jvc2Vjb25kc1BhcmFtKSB7XG4gICAgICAgIGNvbnN0IGVwb2NoTWljcm9zZWNvbmRzID0gVG9CaWdJbnQoZXBvY2hNaWNyb3NlY29uZHNQYXJhbSk7XG4gICAgICAgIGNvbnN0IGVwb2NoTmFub3NlY29uZHMgPSBKU0JJLm11bHRpcGx5KGVwb2NoTWljcm9zZWNvbmRzLCBUSE9VU0FORCk7XG4gICAgICAgIFZhbGlkYXRlRXBvY2hOYW5vc2Vjb25kcyhlcG9jaE5hbm9zZWNvbmRzKTtcbiAgICAgICAgcmV0dXJuIG5ldyBJbnN0YW50KGVwb2NoTmFub3NlY29uZHMpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUVwb2NoTmFub3NlY29uZHMoZXBvY2hOYW5vc2Vjb25kc1BhcmFtKSB7XG4gICAgICAgIGNvbnN0IGVwb2NoTmFub3NlY29uZHMgPSBUb0JpZ0ludChlcG9jaE5hbm9zZWNvbmRzUGFyYW0pO1xuICAgICAgICBWYWxpZGF0ZUVwb2NoTmFub3NlY29uZHMoZXBvY2hOYW5vc2Vjb25kcyk7XG4gICAgICAgIHJldHVybiBuZXcgSW5zdGFudChlcG9jaE5hbm9zZWNvbmRzKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb20oaXRlbSkge1xuICAgICAgICBpZiAoSXNUZW1wb3JhbEluc3RhbnQoaXRlbSkpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSW5zdGFudChHZXRTbG90KGl0ZW0sIEVQT0NITkFOT1NFQ09ORFMpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gVG9UZW1wb3JhbEluc3RhbnQoaXRlbSk7XG4gICAgfVxuICAgIHN0YXRpYyBjb21wYXJlKG9uZVBhcmFtLCB0d29QYXJhbSkge1xuICAgICAgICBjb25zdCBvbmUgPSBUb1RlbXBvcmFsSW5zdGFudChvbmVQYXJhbSk7XG4gICAgICAgIGNvbnN0IHR3byA9IFRvVGVtcG9yYWxJbnN0YW50KHR3b1BhcmFtKTtcbiAgICAgICAgY29uc3Qgb25lTnMgPSBHZXRTbG90KG9uZSwgRVBPQ0hOQU5PU0VDT05EUyk7XG4gICAgICAgIGNvbnN0IHR3b05zID0gR2V0U2xvdCh0d28sIEVQT0NITkFOT1NFQ09ORFMpO1xuICAgICAgICBpZiAoSlNCSS5sZXNzVGhhbihvbmVOcywgdHdvTnMpKVxuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICBpZiAoSlNCSS5ncmVhdGVyVGhhbihvbmVOcywgdHdvTnMpKVxuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbn1cbk1ha2VJbnRyaW5zaWNDbGFzcyhJbnN0YW50LCAnVGVtcG9yYWwuSW5zdGFudCcpO1xuXG5jb25zdCBESVNBTExPV0VEX1VOSVRTJDIgPSBbJ2hvdXInLCAnbWludXRlJywgJ3NlY29uZCcsICdtaWxsaXNlY29uZCcsICdtaWNyb3NlY29uZCcsICduYW5vc2Vjb25kJ107XG5jbGFzcyBQbGFpbkRhdGUge1xuICAgIGNvbnN0cnVjdG9yKGlzb1llYXJQYXJhbSwgaXNvTW9udGhQYXJhbSwgaXNvRGF5UGFyYW0sIGNhbGVuZGFyUGFyYW0gPSBHZXRJU084NjAxQ2FsZW5kYXIoKSkge1xuICAgICAgICBjb25zdCBpc29ZZWFyID0gVG9JbnRlZ2VyVGhyb3dPbkluZmluaXR5KGlzb1llYXJQYXJhbSk7XG4gICAgICAgIGNvbnN0IGlzb01vbnRoID0gVG9JbnRlZ2VyVGhyb3dPbkluZmluaXR5KGlzb01vbnRoUGFyYW0pO1xuICAgICAgICBjb25zdCBpc29EYXkgPSBUb0ludGVnZXJUaHJvd09uSW5maW5pdHkoaXNvRGF5UGFyYW0pO1xuICAgICAgICBjb25zdCBjYWxlbmRhciA9IFRvVGVtcG9yYWxDYWxlbmRhcihjYWxlbmRhclBhcmFtKTtcbiAgICAgICAgLy8gTm90ZTogaWYgdGhlIGFyZ3VtZW50cyBhcmUgbm90IHBhc3NlZCxcbiAgICAgICAgLy8gICAgICAgVG9JbnRlZ2VyVGhyb3dPbkluZmluaXR5KHVuZGVmaW5lZCkgd2lsbCBoYXZlIHJldHVybmVkIDAsIHdoaWNoIHdpbGxcbiAgICAgICAgLy8gICAgICAgYmUgcmVqZWN0ZWQgYnkgUmVqZWN0SVNPRGF0ZSBpbiBDcmVhdGVUZW1wb3JhbERhdGVTbG90cy4gVGhpcyBjaGVja1xuICAgICAgICAvLyAgICAgICBleGlzdHMgb25seSB0byBpbXByb3ZlIHRoZSBlcnJvciBtZXNzYWdlLlxuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdtaXNzaW5nIGFyZ3VtZW50OiBpc29ZZWFyLCBpc29Nb250aCBhbmQgaXNvRGF5IGFyZSByZXF1aXJlZCcpO1xuICAgICAgICB9XG4gICAgICAgIENyZWF0ZVRlbXBvcmFsRGF0ZVNsb3RzKHRoaXMsIGlzb1llYXIsIGlzb01vbnRoLCBpc29EYXksIGNhbGVuZGFyKTtcbiAgICB9XG4gICAgZ2V0IGNhbGVuZGFyKCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxEYXRlKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICByZXR1cm4gR2V0U2xvdCh0aGlzLCBDQUxFTkRBUik7XG4gICAgfVxuICAgIGdldCBlcmEoKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbERhdGUodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIHJldHVybiBDYWxlbmRhckVyYShHZXRTbG90KHRoaXMsIENBTEVOREFSKSwgdGhpcyk7XG4gICAgfVxuICAgIGdldCBlcmFZZWFyKCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxEYXRlKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICByZXR1cm4gQ2FsZW5kYXJFcmFZZWFyKEdldFNsb3QodGhpcywgQ0FMRU5EQVIpLCB0aGlzKTtcbiAgICB9XG4gICAgZ2V0IHllYXIoKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbERhdGUodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIHJldHVybiBDYWxlbmRhclllYXIoR2V0U2xvdCh0aGlzLCBDQUxFTkRBUiksIHRoaXMpO1xuICAgIH1cbiAgICBnZXQgbW9udGgoKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbERhdGUodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIHJldHVybiBDYWxlbmRhck1vbnRoKEdldFNsb3QodGhpcywgQ0FMRU5EQVIpLCB0aGlzKTtcbiAgICB9XG4gICAgZ2V0IG1vbnRoQ29kZSgpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsRGF0ZSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgcmV0dXJuIENhbGVuZGFyTW9udGhDb2RlKEdldFNsb3QodGhpcywgQ0FMRU5EQVIpLCB0aGlzKTtcbiAgICB9XG4gICAgZ2V0IGRheSgpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsRGF0ZSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgcmV0dXJuIENhbGVuZGFyRGF5KEdldFNsb3QodGhpcywgQ0FMRU5EQVIpLCB0aGlzKTtcbiAgICB9XG4gICAgZ2V0IGRheU9mV2VlaygpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsRGF0ZSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgcmV0dXJuIENhbGVuZGFyRGF5T2ZXZWVrKEdldFNsb3QodGhpcywgQ0FMRU5EQVIpLCB0aGlzKTtcbiAgICB9XG4gICAgZ2V0IGRheU9mWWVhcigpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsRGF0ZSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgcmV0dXJuIENhbGVuZGFyRGF5T2ZZZWFyKEdldFNsb3QodGhpcywgQ0FMRU5EQVIpLCB0aGlzKTtcbiAgICB9XG4gICAgZ2V0IHdlZWtPZlllYXIoKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbERhdGUodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIHJldHVybiBDYWxlbmRhcldlZWtPZlllYXIoR2V0U2xvdCh0aGlzLCBDQUxFTkRBUiksIHRoaXMpO1xuICAgIH1cbiAgICBnZXQgZGF5c0luV2VlaygpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsRGF0ZSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgcmV0dXJuIENhbGVuZGFyRGF5c0luV2VlayhHZXRTbG90KHRoaXMsIENBTEVOREFSKSwgdGhpcyk7XG4gICAgfVxuICAgIGdldCBkYXlzSW5Nb250aCgpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsRGF0ZSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgcmV0dXJuIENhbGVuZGFyRGF5c0luTW9udGgoR2V0U2xvdCh0aGlzLCBDQUxFTkRBUiksIHRoaXMpO1xuICAgIH1cbiAgICBnZXQgZGF5c0luWWVhcigpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsRGF0ZSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgcmV0dXJuIENhbGVuZGFyRGF5c0luWWVhcihHZXRTbG90KHRoaXMsIENBTEVOREFSKSwgdGhpcyk7XG4gICAgfVxuICAgIGdldCBtb250aHNJblllYXIoKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbERhdGUodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIHJldHVybiBDYWxlbmRhck1vbnRoc0luWWVhcihHZXRTbG90KHRoaXMsIENBTEVOREFSKSwgdGhpcyk7XG4gICAgfVxuICAgIGdldCBpbkxlYXBZZWFyKCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxEYXRlKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICByZXR1cm4gQ2FsZW5kYXJJbkxlYXBZZWFyKEdldFNsb3QodGhpcywgQ0FMRU5EQVIpLCB0aGlzKTtcbiAgICB9XG4gICAgd2l0aCh0ZW1wb3JhbERhdGVMaWtlLCBvcHRpb25zUGFyYW0gPSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsRGF0ZSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgaWYgKCFJc09iamVjdCh0ZW1wb3JhbERhdGVMaWtlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBhcmd1bWVudCcpO1xuICAgICAgICB9XG4gICAgICAgIFJlamVjdE9iamVjdFdpdGhDYWxlbmRhck9yVGltZVpvbmUodGVtcG9yYWxEYXRlTGlrZSk7XG4gICAgICAgIGNvbnN0IGNhbGVuZGFyID0gR2V0U2xvdCh0aGlzLCBDQUxFTkRBUik7XG4gICAgICAgIGNvbnN0IGZpZWxkTmFtZXMgPSBDYWxlbmRhckZpZWxkcyhjYWxlbmRhciwgWydkYXknLCAnbW9udGgnLCAnbW9udGhDb2RlJywgJ3llYXInXSk7XG4gICAgICAgIGNvbnN0IHByb3BzID0gVG9QYXJ0aWFsUmVjb3JkKHRlbXBvcmFsRGF0ZUxpa2UsIGZpZWxkTmFtZXMpO1xuICAgICAgICBpZiAoIXByb3BzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIGRhdGUtbGlrZScpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBmaWVsZHMgPSBUb1RlbXBvcmFsRGF0ZUZpZWxkcyh0aGlzLCBmaWVsZE5hbWVzKTtcbiAgICAgICAgZmllbGRzID0gQ2FsZW5kYXJNZXJnZUZpZWxkcyhjYWxlbmRhciwgZmllbGRzLCBwcm9wcyk7XG4gICAgICAgIGZpZWxkcyA9IFRvVGVtcG9yYWxEYXRlRmllbGRzKGZpZWxkcywgZmllbGROYW1lcyk7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSBHZXRPcHRpb25zT2JqZWN0KG9wdGlvbnNQYXJhbSk7XG4gICAgICAgIHJldHVybiBEYXRlRnJvbUZpZWxkcyhjYWxlbmRhciwgZmllbGRzLCBvcHRpb25zKTtcbiAgICB9XG4gICAgd2l0aENhbGVuZGFyKGNhbGVuZGFyUGFyYW0pIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsRGF0ZSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgY29uc3QgY2FsZW5kYXIgPSBUb1RlbXBvcmFsQ2FsZW5kYXIoY2FsZW5kYXJQYXJhbSk7XG4gICAgICAgIHJldHVybiBuZXcgUGxhaW5EYXRlKEdldFNsb3QodGhpcywgSVNPX1lFQVIpLCBHZXRTbG90KHRoaXMsIElTT19NT05USCksIEdldFNsb3QodGhpcywgSVNPX0RBWSksIGNhbGVuZGFyKTtcbiAgICB9XG4gICAgYWRkKHRlbXBvcmFsRHVyYXRpb25MaWtlLCBvcHRpb25zUGFyYW0gPSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsRGF0ZSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgY29uc3QgZHVyYXRpb24gPSBUb1RlbXBvcmFsRHVyYXRpb24odGVtcG9yYWxEdXJhdGlvbkxpa2UpO1xuICAgICAgICBjb25zdCBvcHRpb25zID0gR2V0T3B0aW9uc09iamVjdChvcHRpb25zUGFyYW0pO1xuICAgICAgICByZXR1cm4gQ2FsZW5kYXJEYXRlQWRkKEdldFNsb3QodGhpcywgQ0FMRU5EQVIpLCB0aGlzLCBkdXJhdGlvbiwgb3B0aW9ucyk7XG4gICAgfVxuICAgIHN1YnRyYWN0KHRlbXBvcmFsRHVyYXRpb25MaWtlLCBvcHRpb25zUGFyYW0gPSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsRGF0ZSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgY29uc3QgZHVyYXRpb24gPSBDcmVhdGVOZWdhdGVkVGVtcG9yYWxEdXJhdGlvbihUb1RlbXBvcmFsRHVyYXRpb24odGVtcG9yYWxEdXJhdGlvbkxpa2UpKTtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IEdldE9wdGlvbnNPYmplY3Qob3B0aW9uc1BhcmFtKTtcbiAgICAgICAgcmV0dXJuIENhbGVuZGFyRGF0ZUFkZChHZXRTbG90KHRoaXMsIENBTEVOREFSKSwgdGhpcywgZHVyYXRpb24sIG9wdGlvbnMpO1xuICAgIH1cbiAgICB1bnRpbChvdGhlclBhcmFtLCBvcHRpb25zUGFyYW0gPSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsRGF0ZSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgY29uc3Qgb3RoZXIgPSBUb1RlbXBvcmFsRGF0ZShvdGhlclBhcmFtKTtcbiAgICAgICAgY29uc3QgY2FsZW5kYXIgPSBHZXRTbG90KHRoaXMsIENBTEVOREFSKTtcbiAgICAgICAgY29uc3Qgb3RoZXJDYWxlbmRhciA9IEdldFNsb3Qob3RoZXIsIENBTEVOREFSKTtcbiAgICAgICAgY29uc3QgY2FsZW5kYXJJZCA9IFRvU3RyaW5nKGNhbGVuZGFyKTtcbiAgICAgICAgY29uc3Qgb3RoZXJDYWxlbmRhcklkID0gVG9TdHJpbmcob3RoZXJDYWxlbmRhcik7XG4gICAgICAgIGlmIChjYWxlbmRhcklkICE9PSBvdGhlckNhbGVuZGFySWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBjYW5ub3QgY29tcHV0ZSBkaWZmZXJlbmNlIGJldHdlZW4gZGF0ZXMgb2YgJHtjYWxlbmRhcklkfSBhbmQgJHtvdGhlckNhbGVuZGFySWR9IGNhbGVuZGFyc2ApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSBHZXRPcHRpb25zT2JqZWN0KG9wdGlvbnNQYXJhbSk7XG4gICAgICAgIGNvbnN0IHNtYWxsZXN0VW5pdCA9IFRvU21hbGxlc3RUZW1wb3JhbFVuaXQob3B0aW9ucywgJ2RheScsIERJU0FMTE9XRURfVU5JVFMkMik7XG4gICAgICAgIGNvbnN0IGRlZmF1bHRMYXJnZXN0VW5pdCA9IExhcmdlck9mVHdvVGVtcG9yYWxVbml0cygnZGF5Jywgc21hbGxlc3RVbml0KTtcbiAgICAgICAgY29uc3QgbGFyZ2VzdFVuaXQgPSBUb0xhcmdlc3RUZW1wb3JhbFVuaXQob3B0aW9ucywgJ2F1dG8nLCBESVNBTExPV0VEX1VOSVRTJDIsIGRlZmF1bHRMYXJnZXN0VW5pdCk7XG4gICAgICAgIFZhbGlkYXRlVGVtcG9yYWxVbml0UmFuZ2UobGFyZ2VzdFVuaXQsIHNtYWxsZXN0VW5pdCk7XG4gICAgICAgIGNvbnN0IHJvdW5kaW5nTW9kZSA9IFRvVGVtcG9yYWxSb3VuZGluZ01vZGUob3B0aW9ucywgJ3RydW5jJyk7XG4gICAgICAgIGNvbnN0IHJvdW5kaW5nSW5jcmVtZW50ID0gVG9UZW1wb3JhbFJvdW5kaW5nSW5jcmVtZW50KG9wdGlvbnMsIHVuZGVmaW5lZCwgZmFsc2UpO1xuICAgICAgICBjb25zdCB1bnRpbE9wdGlvbnMgPSB7IC4uLm9wdGlvbnMsIGxhcmdlc3RVbml0IH07XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IENhbGVuZGFyRGF0ZVVudGlsKGNhbGVuZGFyLCB0aGlzLCBvdGhlciwgdW50aWxPcHRpb25zKTtcbiAgICAgICAgaWYgKHNtYWxsZXN0VW5pdCA9PT0gJ2RheScgJiYgcm91bmRpbmdJbmNyZW1lbnQgPT09IDEpXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICBsZXQgeyB5ZWFycywgbW9udGhzLCB3ZWVrcywgZGF5cyB9ID0gcmVzdWx0O1xuICAgICAgICAoeyB5ZWFycywgbW9udGhzLCB3ZWVrcywgZGF5cyB9ID0gUm91bmREdXJhdGlvbih5ZWFycywgbW9udGhzLCB3ZWVrcywgZGF5cywgMCwgMCwgMCwgMCwgMCwgMCwgcm91bmRpbmdJbmNyZW1lbnQsIHNtYWxsZXN0VW5pdCwgcm91bmRpbmdNb2RlLCB0aGlzKSk7XG4gICAgICAgIGNvbnN0IER1cmF0aW9uID0gR2V0SW50cmluc2ljKCclVGVtcG9yYWwuRHVyYXRpb24lJyk7XG4gICAgICAgIHJldHVybiBuZXcgRHVyYXRpb24oeWVhcnMsIG1vbnRocywgd2Vla3MsIGRheXMsIDAsIDAsIDAsIDAsIDAsIDApO1xuICAgIH1cbiAgICBzaW5jZShvdGhlclBhcmFtLCBvcHRpb25zUGFyYW0gPSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsRGF0ZSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgY29uc3Qgb3RoZXIgPSBUb1RlbXBvcmFsRGF0ZShvdGhlclBhcmFtKTtcbiAgICAgICAgY29uc3QgY2FsZW5kYXIgPSBHZXRTbG90KHRoaXMsIENBTEVOREFSKTtcbiAgICAgICAgY29uc3Qgb3RoZXJDYWxlbmRhciA9IEdldFNsb3Qob3RoZXIsIENBTEVOREFSKTtcbiAgICAgICAgY29uc3QgY2FsZW5kYXJJZCA9IFRvU3RyaW5nKGNhbGVuZGFyKTtcbiAgICAgICAgY29uc3Qgb3RoZXJDYWxlbmRhcklkID0gVG9TdHJpbmcob3RoZXJDYWxlbmRhcik7XG4gICAgICAgIGlmIChjYWxlbmRhcklkICE9PSBvdGhlckNhbGVuZGFySWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBjYW5ub3QgY29tcHV0ZSBkaWZmZXJlbmNlIGJldHdlZW4gZGF0ZXMgb2YgJHtjYWxlbmRhcklkfSBhbmQgJHtvdGhlckNhbGVuZGFySWR9IGNhbGVuZGFyc2ApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSBHZXRPcHRpb25zT2JqZWN0KG9wdGlvbnNQYXJhbSk7XG4gICAgICAgIGNvbnN0IHNtYWxsZXN0VW5pdCA9IFRvU21hbGxlc3RUZW1wb3JhbFVuaXQob3B0aW9ucywgJ2RheScsIERJU0FMTE9XRURfVU5JVFMkMik7XG4gICAgICAgIGNvbnN0IGRlZmF1bHRMYXJnZXN0VW5pdCA9IExhcmdlck9mVHdvVGVtcG9yYWxVbml0cygnZGF5Jywgc21hbGxlc3RVbml0KTtcbiAgICAgICAgY29uc3QgbGFyZ2VzdFVuaXQgPSBUb0xhcmdlc3RUZW1wb3JhbFVuaXQob3B0aW9ucywgJ2F1dG8nLCBESVNBTExPV0VEX1VOSVRTJDIsIGRlZmF1bHRMYXJnZXN0VW5pdCk7XG4gICAgICAgIFZhbGlkYXRlVGVtcG9yYWxVbml0UmFuZ2UobGFyZ2VzdFVuaXQsIHNtYWxsZXN0VW5pdCk7XG4gICAgICAgIGNvbnN0IHJvdW5kaW5nTW9kZSA9IFRvVGVtcG9yYWxSb3VuZGluZ01vZGUob3B0aW9ucywgJ3RydW5jJyk7XG4gICAgICAgIGNvbnN0IHJvdW5kaW5nSW5jcmVtZW50ID0gVG9UZW1wb3JhbFJvdW5kaW5nSW5jcmVtZW50KG9wdGlvbnMsIHVuZGVmaW5lZCwgZmFsc2UpO1xuICAgICAgICBjb25zdCB1bnRpbE9wdGlvbnMgPSB7IC4uLm9wdGlvbnMsIGxhcmdlc3RVbml0IH07XG4gICAgICAgIGxldCB7IHllYXJzLCBtb250aHMsIHdlZWtzLCBkYXlzIH0gPSBDYWxlbmRhckRhdGVVbnRpbChjYWxlbmRhciwgdGhpcywgb3RoZXIsIHVudGlsT3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IER1cmF0aW9uID0gR2V0SW50cmluc2ljKCclVGVtcG9yYWwuRHVyYXRpb24lJyk7XG4gICAgICAgIGlmIChzbWFsbGVzdFVuaXQgPT09ICdkYXknICYmIHJvdW5kaW5nSW5jcmVtZW50ID09PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IER1cmF0aW9uKC15ZWFycywgLW1vbnRocywgLXdlZWtzLCAtZGF5cywgMCwgMCwgMCwgMCwgMCwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgKHsgeWVhcnMsIG1vbnRocywgd2Vla3MsIGRheXMgfSA9IFJvdW5kRHVyYXRpb24oeWVhcnMsIG1vbnRocywgd2Vla3MsIGRheXMsIDAsIDAsIDAsIDAsIDAsIDAsIHJvdW5kaW5nSW5jcmVtZW50LCBzbWFsbGVzdFVuaXQsIE5lZ2F0ZVRlbXBvcmFsUm91bmRpbmdNb2RlKHJvdW5kaW5nTW9kZSksIHRoaXMpKTtcbiAgICAgICAgcmV0dXJuIG5ldyBEdXJhdGlvbigteWVhcnMsIC1tb250aHMsIC13ZWVrcywgLWRheXMsIDAsIDAsIDAsIDAsIDAsIDApO1xuICAgIH1cbiAgICBlcXVhbHMob3RoZXJQYXJhbSkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxEYXRlKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICBjb25zdCBvdGhlciA9IFRvVGVtcG9yYWxEYXRlKG90aGVyUGFyYW0pO1xuICAgICAgICBmb3IgKGNvbnN0IHNsb3Qgb2YgW0lTT19ZRUFSLCBJU09fTU9OVEgsIElTT19EQVldKSB7XG4gICAgICAgICAgICBjb25zdCB2YWwxID0gR2V0U2xvdCh0aGlzLCBzbG90KTtcbiAgICAgICAgICAgIGNvbnN0IHZhbDIgPSBHZXRTbG90KG90aGVyLCBzbG90KTtcbiAgICAgICAgICAgIGlmICh2YWwxICE9PSB2YWwyKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQ2FsZW5kYXJFcXVhbHMoR2V0U2xvdCh0aGlzLCBDQUxFTkRBUiksIEdldFNsb3Qob3RoZXIsIENBTEVOREFSKSk7XG4gICAgfVxuICAgIHRvU3RyaW5nKG9wdGlvbnNQYXJhbSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxEYXRlKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICBjb25zdCBvcHRpb25zID0gR2V0T3B0aW9uc09iamVjdChvcHRpb25zUGFyYW0pO1xuICAgICAgICBjb25zdCBzaG93Q2FsZW5kYXIgPSBUb1Nob3dDYWxlbmRhck9wdGlvbihvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIFRlbXBvcmFsRGF0ZVRvU3RyaW5nKHRoaXMsIHNob3dDYWxlbmRhcik7XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsRGF0ZSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgcmV0dXJuIFRlbXBvcmFsRGF0ZVRvU3RyaW5nKHRoaXMpO1xuICAgIH1cbiAgICB0b0xvY2FsZVN0cmluZyhsb2NhbGVzID0gdW5kZWZpbmVkLCBvcHRpb25zID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbERhdGUodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZVRpbWVGb3JtYXQobG9jYWxlcywgb3B0aW9ucykuZm9ybWF0KHRoaXMpO1xuICAgIH1cbiAgICB2YWx1ZU9mKCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd1c2UgY29tcGFyZSgpIG9yIGVxdWFscygpIHRvIGNvbXBhcmUgVGVtcG9yYWwuUGxhaW5EYXRlJyk7XG4gICAgfVxuICAgIHRvUGxhaW5EYXRlVGltZSh0ZW1wb3JhbFRpbWVQYXJhbSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxEYXRlKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICBjb25zdCB5ZWFyID0gR2V0U2xvdCh0aGlzLCBJU09fWUVBUik7XG4gICAgICAgIGNvbnN0IG1vbnRoID0gR2V0U2xvdCh0aGlzLCBJU09fTU9OVEgpO1xuICAgICAgICBjb25zdCBkYXkgPSBHZXRTbG90KHRoaXMsIElTT19EQVkpO1xuICAgICAgICBjb25zdCBjYWxlbmRhciA9IEdldFNsb3QodGhpcywgQ0FMRU5EQVIpO1xuICAgICAgICBpZiAodGVtcG9yYWxUaW1lUGFyYW0gPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJldHVybiBDcmVhdGVUZW1wb3JhbERhdGVUaW1lKHllYXIsIG1vbnRoLCBkYXksIDAsIDAsIDAsIDAsIDAsIDAsIGNhbGVuZGFyKTtcbiAgICAgICAgY29uc3QgdGVtcG9yYWxUaW1lID0gVG9UZW1wb3JhbFRpbWUodGVtcG9yYWxUaW1lUGFyYW0pO1xuICAgICAgICBjb25zdCBob3VyID0gR2V0U2xvdCh0ZW1wb3JhbFRpbWUsIElTT19IT1VSKTtcbiAgICAgICAgY29uc3QgbWludXRlID0gR2V0U2xvdCh0ZW1wb3JhbFRpbWUsIElTT19NSU5VVEUpO1xuICAgICAgICBjb25zdCBzZWNvbmQgPSBHZXRTbG90KHRlbXBvcmFsVGltZSwgSVNPX1NFQ09ORCk7XG4gICAgICAgIGNvbnN0IG1pbGxpc2Vjb25kID0gR2V0U2xvdCh0ZW1wb3JhbFRpbWUsIElTT19NSUxMSVNFQ09ORCk7XG4gICAgICAgIGNvbnN0IG1pY3Jvc2Vjb25kID0gR2V0U2xvdCh0ZW1wb3JhbFRpbWUsIElTT19NSUNST1NFQ09ORCk7XG4gICAgICAgIGNvbnN0IG5hbm9zZWNvbmQgPSBHZXRTbG90KHRlbXBvcmFsVGltZSwgSVNPX05BTk9TRUNPTkQpO1xuICAgICAgICByZXR1cm4gQ3JlYXRlVGVtcG9yYWxEYXRlVGltZSh5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQsIG1pY3Jvc2Vjb25kLCBuYW5vc2Vjb25kLCBjYWxlbmRhcik7XG4gICAgfVxuICAgIHRvWm9uZWREYXRlVGltZShpdGVtKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbERhdGUodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIGxldCB0aW1lWm9uZSwgdGVtcG9yYWxUaW1lO1xuICAgICAgICBpZiAoSXNPYmplY3QoaXRlbSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHRpbWVab25lTGlrZSA9IGl0ZW0udGltZVpvbmU7XG4gICAgICAgICAgICBpZiAodGltZVpvbmVMaWtlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgY2FzdCBiZWxvdyBpcyBuZWVkZWQgYmVjYXVzZSBpdCdzIHBvc3NpYmxlIGhlcmUgZm9yXG4gICAgICAgICAgICAgICAgLy8gYHRpbWVab25lTGlrZWAgaGVyZSB0byBiZSBgeyBwbGFpblRpbWU6IFRlbXBvcmFsLlBsYWluVGltZUxpa2UgfWAsXG4gICAgICAgICAgICAgICAgLy8gbm90IGEgVGltZVpvbmVQcm90b2NvbC5cbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBzaG91bGQgd2UgY2hlY2sgZm9yIHRoYXQgc2hhcGUgdG8gaW1wcm92ZSBvbiB0aGUgKGJhZCkgZXJyb3JcbiAgICAgICAgICAgICAgICAvLyBtZXNzYWdlIHRoYXQgdGhlIGNhbGxlciB3aWxsIGdldCBmcm9tIFRvVGVtcG9yYWxUaW1lWm9uZT9cbiAgICAgICAgICAgICAgICB0aW1lWm9uZSA9IFRvVGVtcG9yYWxUaW1lWm9uZShpdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRpbWVab25lID0gVG9UZW1wb3JhbFRpbWVab25lKHRpbWVab25lTGlrZSk7XG4gICAgICAgICAgICAgICAgdGVtcG9yYWxUaW1lID0gaXRlbS5wbGFpblRpbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aW1lWm9uZSA9IFRvVGVtcG9yYWxUaW1lWm9uZShpdGVtKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB5ZWFyID0gR2V0U2xvdCh0aGlzLCBJU09fWUVBUik7XG4gICAgICAgIGNvbnN0IG1vbnRoID0gR2V0U2xvdCh0aGlzLCBJU09fTU9OVEgpO1xuICAgICAgICBjb25zdCBkYXkgPSBHZXRTbG90KHRoaXMsIElTT19EQVkpO1xuICAgICAgICBjb25zdCBjYWxlbmRhciA9IEdldFNsb3QodGhpcywgQ0FMRU5EQVIpO1xuICAgICAgICBsZXQgaG91ciA9IDAsIG1pbnV0ZSA9IDAsIHNlY29uZCA9IDAsIG1pbGxpc2Vjb25kID0gMCwgbWljcm9zZWNvbmQgPSAwLCBuYW5vc2Vjb25kID0gMDtcbiAgICAgICAgaWYgKHRlbXBvcmFsVGltZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0ZW1wb3JhbFRpbWUgPSBUb1RlbXBvcmFsVGltZSh0ZW1wb3JhbFRpbWUpO1xuICAgICAgICAgICAgaG91ciA9IEdldFNsb3QodGVtcG9yYWxUaW1lLCBJU09fSE9VUik7XG4gICAgICAgICAgICBtaW51dGUgPSBHZXRTbG90KHRlbXBvcmFsVGltZSwgSVNPX01JTlVURSk7XG4gICAgICAgICAgICBzZWNvbmQgPSBHZXRTbG90KHRlbXBvcmFsVGltZSwgSVNPX1NFQ09ORCk7XG4gICAgICAgICAgICBtaWxsaXNlY29uZCA9IEdldFNsb3QodGVtcG9yYWxUaW1lLCBJU09fTUlMTElTRUNPTkQpO1xuICAgICAgICAgICAgbWljcm9zZWNvbmQgPSBHZXRTbG90KHRlbXBvcmFsVGltZSwgSVNPX01JQ1JPU0VDT05EKTtcbiAgICAgICAgICAgIG5hbm9zZWNvbmQgPSBHZXRTbG90KHRlbXBvcmFsVGltZSwgSVNPX05BTk9TRUNPTkQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGR0ID0gQ3JlYXRlVGVtcG9yYWxEYXRlVGltZSh5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQsIG1pY3Jvc2Vjb25kLCBuYW5vc2Vjb25kLCBjYWxlbmRhcik7XG4gICAgICAgIGNvbnN0IGluc3RhbnQgPSBCdWlsdGluVGltZVpvbmVHZXRJbnN0YW50Rm9yKHRpbWVab25lLCBkdCwgJ2NvbXBhdGlibGUnKTtcbiAgICAgICAgcmV0dXJuIENyZWF0ZVRlbXBvcmFsWm9uZWREYXRlVGltZShHZXRTbG90KGluc3RhbnQsIEVQT0NITkFOT1NFQ09ORFMpLCB0aW1lWm9uZSwgY2FsZW5kYXIpO1xuICAgIH1cbiAgICB0b1BsYWluWWVhck1vbnRoKCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxEYXRlKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICBjb25zdCBjYWxlbmRhciA9IEdldFNsb3QodGhpcywgQ0FMRU5EQVIpO1xuICAgICAgICBjb25zdCBmaWVsZE5hbWVzID0gQ2FsZW5kYXJGaWVsZHMoY2FsZW5kYXIsIFsnbW9udGhDb2RlJywgJ3llYXInXSk7XG4gICAgICAgIGNvbnN0IGZpZWxkcyA9IFRvVGVtcG9yYWxZZWFyTW9udGhGaWVsZHModGhpcywgZmllbGROYW1lcyk7XG4gICAgICAgIHJldHVybiBZZWFyTW9udGhGcm9tRmllbGRzKGNhbGVuZGFyLCBmaWVsZHMpO1xuICAgIH1cbiAgICB0b1BsYWluTW9udGhEYXkoKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbERhdGUodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIGNvbnN0IGNhbGVuZGFyID0gR2V0U2xvdCh0aGlzLCBDQUxFTkRBUik7XG4gICAgICAgIGNvbnN0IGZpZWxkTmFtZXMgPSBDYWxlbmRhckZpZWxkcyhjYWxlbmRhciwgWydkYXknLCAnbW9udGhDb2RlJ10pO1xuICAgICAgICBjb25zdCBmaWVsZHMgPSBUb1RlbXBvcmFsTW9udGhEYXlGaWVsZHModGhpcywgZmllbGROYW1lcyk7XG4gICAgICAgIHJldHVybiBNb250aERheUZyb21GaWVsZHMoY2FsZW5kYXIsIGZpZWxkcyk7XG4gICAgfVxuICAgIGdldElTT0ZpZWxkcygpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsRGF0ZSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNhbGVuZGFyOiBHZXRTbG90KHRoaXMsIENBTEVOREFSKSxcbiAgICAgICAgICAgIGlzb0RheTogR2V0U2xvdCh0aGlzLCBJU09fREFZKSxcbiAgICAgICAgICAgIGlzb01vbnRoOiBHZXRTbG90KHRoaXMsIElTT19NT05USCksXG4gICAgICAgICAgICBpc29ZZWFyOiBHZXRTbG90KHRoaXMsIElTT19ZRUFSKVxuICAgICAgICB9O1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbShpdGVtLCBvcHRpb25zUGFyYW0gPSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IEdldE9wdGlvbnNPYmplY3Qob3B0aW9uc1BhcmFtKTtcbiAgICAgICAgaWYgKElzVGVtcG9yYWxEYXRlKGl0ZW0pKSB7XG4gICAgICAgICAgICBUb1RlbXBvcmFsT3ZlcmZsb3cob3B0aW9ucyk7IC8vIHZhbGlkYXRlIGFuZCBpZ25vcmVcbiAgICAgICAgICAgIHJldHVybiBDcmVhdGVUZW1wb3JhbERhdGUoR2V0U2xvdChpdGVtLCBJU09fWUVBUiksIEdldFNsb3QoaXRlbSwgSVNPX01PTlRIKSwgR2V0U2xvdChpdGVtLCBJU09fREFZKSwgR2V0U2xvdChpdGVtLCBDQUxFTkRBUikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBUb1RlbXBvcmFsRGF0ZShpdGVtLCBvcHRpb25zKTtcbiAgICB9XG4gICAgc3RhdGljIGNvbXBhcmUob25lUGFyYW0sIHR3b1BhcmFtKSB7XG4gICAgICAgIGNvbnN0IG9uZSA9IFRvVGVtcG9yYWxEYXRlKG9uZVBhcmFtKTtcbiAgICAgICAgY29uc3QgdHdvID0gVG9UZW1wb3JhbERhdGUodHdvUGFyYW0pO1xuICAgICAgICByZXR1cm4gQ29tcGFyZUlTT0RhdGUoR2V0U2xvdChvbmUsIElTT19ZRUFSKSwgR2V0U2xvdChvbmUsIElTT19NT05USCksIEdldFNsb3Qob25lLCBJU09fREFZKSwgR2V0U2xvdCh0d28sIElTT19ZRUFSKSwgR2V0U2xvdCh0d28sIElTT19NT05USCksIEdldFNsb3QodHdvLCBJU09fREFZKSk7XG4gICAgfVxufVxuTWFrZUludHJpbnNpY0NsYXNzKFBsYWluRGF0ZSwgJ1RlbXBvcmFsLlBsYWluRGF0ZScpO1xuXG5jbGFzcyBQbGFpbkRhdGVUaW1lIHtcbiAgICBjb25zdHJ1Y3Rvcihpc29ZZWFyUGFyYW0sIGlzb01vbnRoUGFyYW0sIGlzb0RheVBhcmFtLCBob3VyUGFyYW0gPSAwLCBtaW51dGVQYXJhbSA9IDAsIHNlY29uZFBhcmFtID0gMCwgbWlsbGlzZWNvbmRQYXJhbSA9IDAsIG1pY3Jvc2Vjb25kUGFyYW0gPSAwLCBuYW5vc2Vjb25kUGFyYW0gPSAwLCBjYWxlbmRhclBhcmFtID0gR2V0SVNPODYwMUNhbGVuZGFyKCkpIHtcbiAgICAgICAgY29uc3QgaXNvWWVhciA9IFRvSW50ZWdlclRocm93T25JbmZpbml0eShpc29ZZWFyUGFyYW0pO1xuICAgICAgICBjb25zdCBpc29Nb250aCA9IFRvSW50ZWdlclRocm93T25JbmZpbml0eShpc29Nb250aFBhcmFtKTtcbiAgICAgICAgY29uc3QgaXNvRGF5ID0gVG9JbnRlZ2VyVGhyb3dPbkluZmluaXR5KGlzb0RheVBhcmFtKTtcbiAgICAgICAgY29uc3QgaG91ciA9IFRvSW50ZWdlclRocm93T25JbmZpbml0eShob3VyUGFyYW0pO1xuICAgICAgICBjb25zdCBtaW51dGUgPSBUb0ludGVnZXJUaHJvd09uSW5maW5pdHkobWludXRlUGFyYW0pO1xuICAgICAgICBjb25zdCBzZWNvbmQgPSBUb0ludGVnZXJUaHJvd09uSW5maW5pdHkoc2Vjb25kUGFyYW0pO1xuICAgICAgICBjb25zdCBtaWxsaXNlY29uZCA9IFRvSW50ZWdlclRocm93T25JbmZpbml0eShtaWxsaXNlY29uZFBhcmFtKTtcbiAgICAgICAgY29uc3QgbWljcm9zZWNvbmQgPSBUb0ludGVnZXJUaHJvd09uSW5maW5pdHkobWljcm9zZWNvbmRQYXJhbSk7XG4gICAgICAgIGNvbnN0IG5hbm9zZWNvbmQgPSBUb0ludGVnZXJUaHJvd09uSW5maW5pdHkobmFub3NlY29uZFBhcmFtKTtcbiAgICAgICAgY29uc3QgY2FsZW5kYXIgPSBUb1RlbXBvcmFsQ2FsZW5kYXIoY2FsZW5kYXJQYXJhbSk7XG4gICAgICAgIC8vIE5vdGU6IGlmIHRoZSBhcmd1bWVudHMgYXJlIG5vdCBwYXNzZWQsXG4gICAgICAgIC8vICAgICAgIFRvSW50ZWdlclRocm93T25JbmZpbml0eSh1bmRlZmluZWQpIHdpbGwgaGF2ZSByZXR1cm5lZCAwLCB3aGljaCB3aWxsXG4gICAgICAgIC8vICAgICAgIGJlIHJlamVjdGVkIGJ5IFJlamVjdERhdGVUaW1lIGluIENyZWF0ZVRlbXBvcmFsRGF0ZVRpbWVTbG90cy4gVGhpc1xuICAgICAgICAvLyAgICAgICBjaGVjayBleGlzdHMgb25seSB0byBpbXByb3ZlIHRoZSBlcnJvciBtZXNzYWdlLlxuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdtaXNzaW5nIGFyZ3VtZW50OiBpc29ZZWFyLCBpc29Nb250aCBhbmQgaXNvRGF5IGFyZSByZXF1aXJlZCcpO1xuICAgICAgICB9XG4gICAgICAgIENyZWF0ZVRlbXBvcmFsRGF0ZVRpbWVTbG90cyh0aGlzLCBpc29ZZWFyLCBpc29Nb250aCwgaXNvRGF5LCBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQsIG1pY3Jvc2Vjb25kLCBuYW5vc2Vjb25kLCBjYWxlbmRhcik7XG4gICAgfVxuICAgIGdldCBjYWxlbmRhcigpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsRGF0ZVRpbWUodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIHJldHVybiBHZXRTbG90KHRoaXMsIENBTEVOREFSKTtcbiAgICB9XG4gICAgZ2V0IHllYXIoKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbERhdGVUaW1lKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICByZXR1cm4gQ2FsZW5kYXJZZWFyKEdldFNsb3QodGhpcywgQ0FMRU5EQVIpLCB0aGlzKTtcbiAgICB9XG4gICAgZ2V0IG1vbnRoKCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxEYXRlVGltZSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgcmV0dXJuIENhbGVuZGFyTW9udGgoR2V0U2xvdCh0aGlzLCBDQUxFTkRBUiksIHRoaXMpO1xuICAgIH1cbiAgICBnZXQgbW9udGhDb2RlKCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxEYXRlVGltZSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgcmV0dXJuIENhbGVuZGFyTW9udGhDb2RlKEdldFNsb3QodGhpcywgQ0FMRU5EQVIpLCB0aGlzKTtcbiAgICB9XG4gICAgZ2V0IGRheSgpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsRGF0ZVRpbWUodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIHJldHVybiBDYWxlbmRhckRheShHZXRTbG90KHRoaXMsIENBTEVOREFSKSwgdGhpcyk7XG4gICAgfVxuICAgIGdldCBob3VyKCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxEYXRlVGltZSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgcmV0dXJuIEdldFNsb3QodGhpcywgSVNPX0hPVVIpO1xuICAgIH1cbiAgICBnZXQgbWludXRlKCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxEYXRlVGltZSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgcmV0dXJuIEdldFNsb3QodGhpcywgSVNPX01JTlVURSk7XG4gICAgfVxuICAgIGdldCBzZWNvbmQoKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbERhdGVUaW1lKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICByZXR1cm4gR2V0U2xvdCh0aGlzLCBJU09fU0VDT05EKTtcbiAgICB9XG4gICAgZ2V0IG1pbGxpc2Vjb25kKCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxEYXRlVGltZSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgcmV0dXJuIEdldFNsb3QodGhpcywgSVNPX01JTExJU0VDT05EKTtcbiAgICB9XG4gICAgZ2V0IG1pY3Jvc2Vjb25kKCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxEYXRlVGltZSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgcmV0dXJuIEdldFNsb3QodGhpcywgSVNPX01JQ1JPU0VDT05EKTtcbiAgICB9XG4gICAgZ2V0IG5hbm9zZWNvbmQoKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbERhdGVUaW1lKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICByZXR1cm4gR2V0U2xvdCh0aGlzLCBJU09fTkFOT1NFQ09ORCk7XG4gICAgfVxuICAgIGdldCBlcmEoKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbERhdGVUaW1lKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICByZXR1cm4gQ2FsZW5kYXJFcmEoR2V0U2xvdCh0aGlzLCBDQUxFTkRBUiksIHRoaXMpO1xuICAgIH1cbiAgICBnZXQgZXJhWWVhcigpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsRGF0ZVRpbWUodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIHJldHVybiBDYWxlbmRhckVyYVllYXIoR2V0U2xvdCh0aGlzLCBDQUxFTkRBUiksIHRoaXMpO1xuICAgIH1cbiAgICBnZXQgZGF5T2ZXZWVrKCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxEYXRlVGltZSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgcmV0dXJuIENhbGVuZGFyRGF5T2ZXZWVrKEdldFNsb3QodGhpcywgQ0FMRU5EQVIpLCB0aGlzKTtcbiAgICB9XG4gICAgZ2V0IGRheU9mWWVhcigpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsRGF0ZVRpbWUodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIHJldHVybiBDYWxlbmRhckRheU9mWWVhcihHZXRTbG90KHRoaXMsIENBTEVOREFSKSwgdGhpcyk7XG4gICAgfVxuICAgIGdldCB3ZWVrT2ZZZWFyKCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxEYXRlVGltZSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgcmV0dXJuIENhbGVuZGFyV2Vla09mWWVhcihHZXRTbG90KHRoaXMsIENBTEVOREFSKSwgdGhpcyk7XG4gICAgfVxuICAgIGdldCBkYXlzSW5XZWVrKCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxEYXRlVGltZSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgcmV0dXJuIENhbGVuZGFyRGF5c0luV2VlayhHZXRTbG90KHRoaXMsIENBTEVOREFSKSwgdGhpcyk7XG4gICAgfVxuICAgIGdldCBkYXlzSW5ZZWFyKCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxEYXRlVGltZSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgcmV0dXJuIENhbGVuZGFyRGF5c0luWWVhcihHZXRTbG90KHRoaXMsIENBTEVOREFSKSwgdGhpcyk7XG4gICAgfVxuICAgIGdldCBkYXlzSW5Nb250aCgpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsRGF0ZVRpbWUodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIHJldHVybiBDYWxlbmRhckRheXNJbk1vbnRoKEdldFNsb3QodGhpcywgQ0FMRU5EQVIpLCB0aGlzKTtcbiAgICB9XG4gICAgZ2V0IG1vbnRoc0luWWVhcigpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsRGF0ZVRpbWUodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIHJldHVybiBDYWxlbmRhck1vbnRoc0luWWVhcihHZXRTbG90KHRoaXMsIENBTEVOREFSKSwgdGhpcyk7XG4gICAgfVxuICAgIGdldCBpbkxlYXBZZWFyKCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxEYXRlVGltZSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgcmV0dXJuIENhbGVuZGFySW5MZWFwWWVhcihHZXRTbG90KHRoaXMsIENBTEVOREFSKSwgdGhpcyk7XG4gICAgfVxuICAgIHdpdGgodGVtcG9yYWxEYXRlVGltZUxpa2UsIG9wdGlvbnNQYXJhbSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxEYXRlVGltZSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgaWYgKCFJc09iamVjdCh0ZW1wb3JhbERhdGVUaW1lTGlrZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgYXJndW1lbnQnKTtcbiAgICAgICAgfVxuICAgICAgICBSZWplY3RPYmplY3RXaXRoQ2FsZW5kYXJPclRpbWVab25lKHRlbXBvcmFsRGF0ZVRpbWVMaWtlKTtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IEdldE9wdGlvbnNPYmplY3Qob3B0aW9uc1BhcmFtKTtcbiAgICAgICAgY29uc3QgY2FsZW5kYXIgPSBHZXRTbG90KHRoaXMsIENBTEVOREFSKTtcbiAgICAgICAgY29uc3QgZmllbGROYW1lcyA9IENhbGVuZGFyRmllbGRzKGNhbGVuZGFyLCBbXG4gICAgICAgICAgICAnZGF5JyxcbiAgICAgICAgICAgICdob3VyJyxcbiAgICAgICAgICAgICdtaWNyb3NlY29uZCcsXG4gICAgICAgICAgICAnbWlsbGlzZWNvbmQnLFxuICAgICAgICAgICAgJ21pbnV0ZScsXG4gICAgICAgICAgICAnbW9udGgnLFxuICAgICAgICAgICAgJ21vbnRoQ29kZScsXG4gICAgICAgICAgICAnbmFub3NlY29uZCcsXG4gICAgICAgICAgICAnc2Vjb25kJyxcbiAgICAgICAgICAgICd5ZWFyJ1xuICAgICAgICBdKTtcbiAgICAgICAgY29uc3QgcHJvcHMgPSBUb1BhcnRpYWxSZWNvcmQodGVtcG9yYWxEYXRlVGltZUxpa2UsIGZpZWxkTmFtZXMpO1xuICAgICAgICBpZiAoIXByb3BzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIGRhdGUtdGltZS1saWtlJyk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGZpZWxkcyA9IFRvVGVtcG9yYWxEYXRlVGltZUZpZWxkcyh0aGlzLCBmaWVsZE5hbWVzKTtcbiAgICAgICAgZmllbGRzID0gQ2FsZW5kYXJNZXJnZUZpZWxkcyhjYWxlbmRhciwgZmllbGRzLCBwcm9wcyk7XG4gICAgICAgIGZpZWxkcyA9IFRvVGVtcG9yYWxEYXRlVGltZUZpZWxkcyhmaWVsZHMsIGZpZWxkTmFtZXMpO1xuICAgICAgICBjb25zdCB7IHllYXIsIG1vbnRoLCBkYXksIGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZCwgbWljcm9zZWNvbmQsIG5hbm9zZWNvbmQgfSA9IEludGVycHJldFRlbXBvcmFsRGF0ZVRpbWVGaWVsZHMoY2FsZW5kYXIsIGZpZWxkcywgb3B0aW9ucyk7XG4gICAgICAgIHJldHVybiBDcmVhdGVUZW1wb3JhbERhdGVUaW1lKHllYXIsIG1vbnRoLCBkYXksIGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZCwgbWljcm9zZWNvbmQsIG5hbm9zZWNvbmQsIGNhbGVuZGFyKTtcbiAgICB9XG4gICAgd2l0aFBsYWluVGltZSh0ZW1wb3JhbFRpbWVQYXJhbSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxEYXRlVGltZSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgY29uc3QgeWVhciA9IEdldFNsb3QodGhpcywgSVNPX1lFQVIpO1xuICAgICAgICBjb25zdCBtb250aCA9IEdldFNsb3QodGhpcywgSVNPX01PTlRIKTtcbiAgICAgICAgY29uc3QgZGF5ID0gR2V0U2xvdCh0aGlzLCBJU09fREFZKTtcbiAgICAgICAgY29uc3QgY2FsZW5kYXIgPSBHZXRTbG90KHRoaXMsIENBTEVOREFSKTtcbiAgICAgICAgaWYgKHRlbXBvcmFsVGltZVBhcmFtID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXR1cm4gQ3JlYXRlVGVtcG9yYWxEYXRlVGltZSh5ZWFyLCBtb250aCwgZGF5LCAwLCAwLCAwLCAwLCAwLCAwLCBjYWxlbmRhcik7XG4gICAgICAgIGNvbnN0IHRlbXBvcmFsVGltZSA9IFRvVGVtcG9yYWxUaW1lKHRlbXBvcmFsVGltZVBhcmFtKTtcbiAgICAgICAgY29uc3QgaG91ciA9IEdldFNsb3QodGVtcG9yYWxUaW1lLCBJU09fSE9VUik7XG4gICAgICAgIGNvbnN0IG1pbnV0ZSA9IEdldFNsb3QodGVtcG9yYWxUaW1lLCBJU09fTUlOVVRFKTtcbiAgICAgICAgY29uc3Qgc2Vjb25kID0gR2V0U2xvdCh0ZW1wb3JhbFRpbWUsIElTT19TRUNPTkQpO1xuICAgICAgICBjb25zdCBtaWxsaXNlY29uZCA9IEdldFNsb3QodGVtcG9yYWxUaW1lLCBJU09fTUlMTElTRUNPTkQpO1xuICAgICAgICBjb25zdCBtaWNyb3NlY29uZCA9IEdldFNsb3QodGVtcG9yYWxUaW1lLCBJU09fTUlDUk9TRUNPTkQpO1xuICAgICAgICBjb25zdCBuYW5vc2Vjb25kID0gR2V0U2xvdCh0ZW1wb3JhbFRpbWUsIElTT19OQU5PU0VDT05EKTtcbiAgICAgICAgcmV0dXJuIENyZWF0ZVRlbXBvcmFsRGF0ZVRpbWUoeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kLCBtaWNyb3NlY29uZCwgbmFub3NlY29uZCwgY2FsZW5kYXIpO1xuICAgIH1cbiAgICB3aXRoUGxhaW5EYXRlKHRlbXBvcmFsRGF0ZVBhcmFtKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbERhdGVUaW1lKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICBjb25zdCB0ZW1wb3JhbERhdGUgPSBUb1RlbXBvcmFsRGF0ZSh0ZW1wb3JhbERhdGVQYXJhbSk7XG4gICAgICAgIGNvbnN0IHllYXIgPSBHZXRTbG90KHRlbXBvcmFsRGF0ZSwgSVNPX1lFQVIpO1xuICAgICAgICBjb25zdCBtb250aCA9IEdldFNsb3QodGVtcG9yYWxEYXRlLCBJU09fTU9OVEgpO1xuICAgICAgICBjb25zdCBkYXkgPSBHZXRTbG90KHRlbXBvcmFsRGF0ZSwgSVNPX0RBWSk7XG4gICAgICAgIGxldCBjYWxlbmRhciA9IEdldFNsb3QodGVtcG9yYWxEYXRlLCBDQUxFTkRBUik7XG4gICAgICAgIGNvbnN0IGhvdXIgPSBHZXRTbG90KHRoaXMsIElTT19IT1VSKTtcbiAgICAgICAgY29uc3QgbWludXRlID0gR2V0U2xvdCh0aGlzLCBJU09fTUlOVVRFKTtcbiAgICAgICAgY29uc3Qgc2Vjb25kID0gR2V0U2xvdCh0aGlzLCBJU09fU0VDT05EKTtcbiAgICAgICAgY29uc3QgbWlsbGlzZWNvbmQgPSBHZXRTbG90KHRoaXMsIElTT19NSUxMSVNFQ09ORCk7XG4gICAgICAgIGNvbnN0IG1pY3Jvc2Vjb25kID0gR2V0U2xvdCh0aGlzLCBJU09fTUlDUk9TRUNPTkQpO1xuICAgICAgICBjb25zdCBuYW5vc2Vjb25kID0gR2V0U2xvdCh0aGlzLCBJU09fTkFOT1NFQ09ORCk7XG4gICAgICAgIGNhbGVuZGFyID0gQ29uc29saWRhdGVDYWxlbmRhcnMoR2V0U2xvdCh0aGlzLCBDQUxFTkRBUiksIGNhbGVuZGFyKTtcbiAgICAgICAgcmV0dXJuIENyZWF0ZVRlbXBvcmFsRGF0ZVRpbWUoeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kLCBtaWNyb3NlY29uZCwgbmFub3NlY29uZCwgY2FsZW5kYXIpO1xuICAgIH1cbiAgICB3aXRoQ2FsZW5kYXIoY2FsZW5kYXJQYXJhbSkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxEYXRlVGltZSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgY29uc3QgY2FsZW5kYXIgPSBUb1RlbXBvcmFsQ2FsZW5kYXIoY2FsZW5kYXJQYXJhbSk7XG4gICAgICAgIHJldHVybiBuZXcgUGxhaW5EYXRlVGltZShHZXRTbG90KHRoaXMsIElTT19ZRUFSKSwgR2V0U2xvdCh0aGlzLCBJU09fTU9OVEgpLCBHZXRTbG90KHRoaXMsIElTT19EQVkpLCBHZXRTbG90KHRoaXMsIElTT19IT1VSKSwgR2V0U2xvdCh0aGlzLCBJU09fTUlOVVRFKSwgR2V0U2xvdCh0aGlzLCBJU09fU0VDT05EKSwgR2V0U2xvdCh0aGlzLCBJU09fTUlMTElTRUNPTkQpLCBHZXRTbG90KHRoaXMsIElTT19NSUNST1NFQ09ORCksIEdldFNsb3QodGhpcywgSVNPX05BTk9TRUNPTkQpLCBjYWxlbmRhcik7XG4gICAgfVxuICAgIGFkZCh0ZW1wb3JhbER1cmF0aW9uTGlrZSwgb3B0aW9uc1BhcmFtID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbERhdGVUaW1lKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICBjb25zdCBkdXJhdGlvbiA9IFRvTGltaXRlZFRlbXBvcmFsRHVyYXRpb24odGVtcG9yYWxEdXJhdGlvbkxpa2UpO1xuICAgICAgICBjb25zdCB7IHllYXJzLCBtb250aHMsIHdlZWtzLCBkYXlzLCBob3VycywgbWludXRlcywgc2Vjb25kcywgbWlsbGlzZWNvbmRzLCBtaWNyb3NlY29uZHMsIG5hbm9zZWNvbmRzIH0gPSBkdXJhdGlvbjtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IEdldE9wdGlvbnNPYmplY3Qob3B0aW9uc1BhcmFtKTtcbiAgICAgICAgY29uc3QgY2FsZW5kYXIgPSBHZXRTbG90KHRoaXMsIENBTEVOREFSKTtcbiAgICAgICAgY29uc3QgeyB5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQsIG1pY3Jvc2Vjb25kLCBuYW5vc2Vjb25kIH0gPSBBZGREYXRlVGltZShHZXRTbG90KHRoaXMsIElTT19ZRUFSKSwgR2V0U2xvdCh0aGlzLCBJU09fTU9OVEgpLCBHZXRTbG90KHRoaXMsIElTT19EQVkpLCBHZXRTbG90KHRoaXMsIElTT19IT1VSKSwgR2V0U2xvdCh0aGlzLCBJU09fTUlOVVRFKSwgR2V0U2xvdCh0aGlzLCBJU09fU0VDT05EKSwgR2V0U2xvdCh0aGlzLCBJU09fTUlMTElTRUNPTkQpLCBHZXRTbG90KHRoaXMsIElTT19NSUNST1NFQ09ORCksIEdldFNsb3QodGhpcywgSVNPX05BTk9TRUNPTkQpLCBjYWxlbmRhciwgeWVhcnMsIG1vbnRocywgd2Vla3MsIGRheXMsIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBtaWxsaXNlY29uZHMsIG1pY3Jvc2Vjb25kcywgbmFub3NlY29uZHMsIG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gQ3JlYXRlVGVtcG9yYWxEYXRlVGltZSh5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQsIG1pY3Jvc2Vjb25kLCBuYW5vc2Vjb25kLCBjYWxlbmRhcik7XG4gICAgfVxuICAgIHN1YnRyYWN0KHRlbXBvcmFsRHVyYXRpb25MaWtlLCBvcHRpb25zUGFyYW0gPSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsRGF0ZVRpbWUodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIGNvbnN0IGR1cmF0aW9uID0gVG9MaW1pdGVkVGVtcG9yYWxEdXJhdGlvbih0ZW1wb3JhbER1cmF0aW9uTGlrZSk7XG4gICAgICAgIGNvbnN0IHsgeWVhcnMsIG1vbnRocywgd2Vla3MsIGRheXMsIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBtaWxsaXNlY29uZHMsIG1pY3Jvc2Vjb25kcywgbmFub3NlY29uZHMgfSA9IGR1cmF0aW9uO1xuICAgICAgICBjb25zdCBvcHRpb25zID0gR2V0T3B0aW9uc09iamVjdChvcHRpb25zUGFyYW0pO1xuICAgICAgICBjb25zdCBjYWxlbmRhciA9IEdldFNsb3QodGhpcywgQ0FMRU5EQVIpO1xuICAgICAgICBjb25zdCB7IHllYXIsIG1vbnRoLCBkYXksIGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZCwgbWljcm9zZWNvbmQsIG5hbm9zZWNvbmQgfSA9IEFkZERhdGVUaW1lKEdldFNsb3QodGhpcywgSVNPX1lFQVIpLCBHZXRTbG90KHRoaXMsIElTT19NT05USCksIEdldFNsb3QodGhpcywgSVNPX0RBWSksIEdldFNsb3QodGhpcywgSVNPX0hPVVIpLCBHZXRTbG90KHRoaXMsIElTT19NSU5VVEUpLCBHZXRTbG90KHRoaXMsIElTT19TRUNPTkQpLCBHZXRTbG90KHRoaXMsIElTT19NSUxMSVNFQ09ORCksIEdldFNsb3QodGhpcywgSVNPX01JQ1JPU0VDT05EKSwgR2V0U2xvdCh0aGlzLCBJU09fTkFOT1NFQ09ORCksIGNhbGVuZGFyLCAteWVhcnMsIC1tb250aHMsIC13ZWVrcywgLWRheXMsIC1ob3VycywgLW1pbnV0ZXMsIC1zZWNvbmRzLCAtbWlsbGlzZWNvbmRzLCAtbWljcm9zZWNvbmRzLCAtbmFub3NlY29uZHMsIG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gQ3JlYXRlVGVtcG9yYWxEYXRlVGltZSh5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQsIG1pY3Jvc2Vjb25kLCBuYW5vc2Vjb25kLCBjYWxlbmRhcik7XG4gICAgfVxuICAgIHVudGlsKG90aGVyUGFyYW0sIG9wdGlvbnNQYXJhbSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxEYXRlVGltZSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgY29uc3Qgb3RoZXIgPSBUb1RlbXBvcmFsRGF0ZVRpbWUob3RoZXJQYXJhbSk7XG4gICAgICAgIGNvbnN0IGNhbGVuZGFyID0gR2V0U2xvdCh0aGlzLCBDQUxFTkRBUik7XG4gICAgICAgIGNvbnN0IG90aGVyQ2FsZW5kYXIgPSBHZXRTbG90KG90aGVyLCBDQUxFTkRBUik7XG4gICAgICAgIGNvbnN0IGNhbGVuZGFySWQgPSBUb1N0cmluZyhjYWxlbmRhcik7XG4gICAgICAgIGNvbnN0IG90aGVyQ2FsZW5kYXJJZCA9IFRvU3RyaW5nKG90aGVyQ2FsZW5kYXIpO1xuICAgICAgICBpZiAoY2FsZW5kYXJJZCAhPT0gb3RoZXJDYWxlbmRhcklkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgY2Fubm90IGNvbXB1dGUgZGlmZmVyZW5jZSBiZXR3ZWVuIGRhdGVzIG9mICR7Y2FsZW5kYXJJZH0gYW5kICR7b3RoZXJDYWxlbmRhcklkfSBjYWxlbmRhcnNgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvcHRpb25zID0gR2V0T3B0aW9uc09iamVjdChvcHRpb25zUGFyYW0pO1xuICAgICAgICBjb25zdCBzbWFsbGVzdFVuaXQgPSBUb1NtYWxsZXN0VGVtcG9yYWxVbml0KG9wdGlvbnMsICduYW5vc2Vjb25kJyk7XG4gICAgICAgIGNvbnN0IGRlZmF1bHRMYXJnZXN0VW5pdCA9IExhcmdlck9mVHdvVGVtcG9yYWxVbml0cygnZGF5Jywgc21hbGxlc3RVbml0KTtcbiAgICAgICAgY29uc3QgbGFyZ2VzdFVuaXQgPSBUb0xhcmdlc3RUZW1wb3JhbFVuaXQob3B0aW9ucywgJ2F1dG8nLCBbXSwgZGVmYXVsdExhcmdlc3RVbml0KTtcbiAgICAgICAgVmFsaWRhdGVUZW1wb3JhbFVuaXRSYW5nZShsYXJnZXN0VW5pdCwgc21hbGxlc3RVbml0KTtcbiAgICAgICAgY29uc3Qgcm91bmRpbmdNb2RlID0gVG9UZW1wb3JhbFJvdW5kaW5nTW9kZShvcHRpb25zLCAndHJ1bmMnKTtcbiAgICAgICAgY29uc3Qgcm91bmRpbmdJbmNyZW1lbnQgPSBUb1RlbXBvcmFsRGF0ZVRpbWVSb3VuZGluZ0luY3JlbWVudChvcHRpb25zLCBzbWFsbGVzdFVuaXQpO1xuICAgICAgICBsZXQgeyB5ZWFycywgbW9udGhzLCB3ZWVrcywgZGF5cywgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc2Vjb25kcywgbWljcm9zZWNvbmRzLCBuYW5vc2Vjb25kcyB9ID0gRGlmZmVyZW5jZUlTT0RhdGVUaW1lKEdldFNsb3QodGhpcywgSVNPX1lFQVIpLCBHZXRTbG90KHRoaXMsIElTT19NT05USCksIEdldFNsb3QodGhpcywgSVNPX0RBWSksIEdldFNsb3QodGhpcywgSVNPX0hPVVIpLCBHZXRTbG90KHRoaXMsIElTT19NSU5VVEUpLCBHZXRTbG90KHRoaXMsIElTT19TRUNPTkQpLCBHZXRTbG90KHRoaXMsIElTT19NSUxMSVNFQ09ORCksIEdldFNsb3QodGhpcywgSVNPX01JQ1JPU0VDT05EKSwgR2V0U2xvdCh0aGlzLCBJU09fTkFOT1NFQ09ORCksIEdldFNsb3Qob3RoZXIsIElTT19ZRUFSKSwgR2V0U2xvdChvdGhlciwgSVNPX01PTlRIKSwgR2V0U2xvdChvdGhlciwgSVNPX0RBWSksIEdldFNsb3Qob3RoZXIsIElTT19IT1VSKSwgR2V0U2xvdChvdGhlciwgSVNPX01JTlVURSksIEdldFNsb3Qob3RoZXIsIElTT19TRUNPTkQpLCBHZXRTbG90KG90aGVyLCBJU09fTUlMTElTRUNPTkQpLCBHZXRTbG90KG90aGVyLCBJU09fTUlDUk9TRUNPTkQpLCBHZXRTbG90KG90aGVyLCBJU09fTkFOT1NFQ09ORCksIGNhbGVuZGFyLCBsYXJnZXN0VW5pdCwgb3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IHJlbGF0aXZlVG8gPSBUZW1wb3JhbERhdGVUaW1lVG9EYXRlKHRoaXMpO1xuICAgICAgICAoeyB5ZWFycywgbW9udGhzLCB3ZWVrcywgZGF5cywgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc2Vjb25kcywgbWljcm9zZWNvbmRzLCBuYW5vc2Vjb25kcyB9ID1cbiAgICAgICAgICAgIFJvdW5kRHVyYXRpb24oeWVhcnMsIG1vbnRocywgd2Vla3MsIGRheXMsIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBtaWxsaXNlY29uZHMsIG1pY3Jvc2Vjb25kcywgbmFub3NlY29uZHMsIHJvdW5kaW5nSW5jcmVtZW50LCBzbWFsbGVzdFVuaXQsIHJvdW5kaW5nTW9kZSwgcmVsYXRpdmVUbykpO1xuICAgICAgICAoeyBkYXlzLCBob3VycywgbWludXRlcywgc2Vjb25kcywgbWlsbGlzZWNvbmRzLCBtaWNyb3NlY29uZHMsIG5hbm9zZWNvbmRzIH0gPSBCYWxhbmNlRHVyYXRpb24oZGF5cywgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc2Vjb25kcywgbWljcm9zZWNvbmRzLCBuYW5vc2Vjb25kcywgbGFyZ2VzdFVuaXQpKTtcbiAgICAgICAgY29uc3QgRHVyYXRpb24gPSBHZXRJbnRyaW5zaWMoJyVUZW1wb3JhbC5EdXJhdGlvbiUnKTtcbiAgICAgICAgcmV0dXJuIG5ldyBEdXJhdGlvbih5ZWFycywgbW9udGhzLCB3ZWVrcywgZGF5cywgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc2Vjb25kcywgbWljcm9zZWNvbmRzLCBuYW5vc2Vjb25kcyk7XG4gICAgfVxuICAgIHNpbmNlKG90aGVyUGFyYW0sIG9wdGlvbnNQYXJhbSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxEYXRlVGltZSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgY29uc3Qgb3RoZXIgPSBUb1RlbXBvcmFsRGF0ZVRpbWUob3RoZXJQYXJhbSk7XG4gICAgICAgIGNvbnN0IGNhbGVuZGFyID0gR2V0U2xvdCh0aGlzLCBDQUxFTkRBUik7XG4gICAgICAgIGNvbnN0IG90aGVyQ2FsZW5kYXIgPSBHZXRTbG90KG90aGVyLCBDQUxFTkRBUik7XG4gICAgICAgIGNvbnN0IGNhbGVuZGFySWQgPSBUb1N0cmluZyhjYWxlbmRhcik7XG4gICAgICAgIGNvbnN0IG90aGVyQ2FsZW5kYXJJZCA9IFRvU3RyaW5nKG90aGVyQ2FsZW5kYXIpO1xuICAgICAgICBpZiAoY2FsZW5kYXJJZCAhPT0gb3RoZXJDYWxlbmRhcklkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgY2Fubm90IGNvbXB1dGUgZGlmZmVyZW5jZSBiZXR3ZWVuIGRhdGVzIG9mICR7Y2FsZW5kYXJJZH0gYW5kICR7b3RoZXJDYWxlbmRhcklkfSBjYWxlbmRhcnNgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvcHRpb25zID0gR2V0T3B0aW9uc09iamVjdChvcHRpb25zUGFyYW0pO1xuICAgICAgICBjb25zdCBzbWFsbGVzdFVuaXQgPSBUb1NtYWxsZXN0VGVtcG9yYWxVbml0KG9wdGlvbnMsICduYW5vc2Vjb25kJyk7XG4gICAgICAgIGNvbnN0IGRlZmF1bHRMYXJnZXN0VW5pdCA9IExhcmdlck9mVHdvVGVtcG9yYWxVbml0cygnZGF5Jywgc21hbGxlc3RVbml0KTtcbiAgICAgICAgY29uc3QgbGFyZ2VzdFVuaXQgPSBUb0xhcmdlc3RUZW1wb3JhbFVuaXQob3B0aW9ucywgJ2F1dG8nLCBbXSwgZGVmYXVsdExhcmdlc3RVbml0KTtcbiAgICAgICAgVmFsaWRhdGVUZW1wb3JhbFVuaXRSYW5nZShsYXJnZXN0VW5pdCwgc21hbGxlc3RVbml0KTtcbiAgICAgICAgY29uc3Qgcm91bmRpbmdNb2RlID0gVG9UZW1wb3JhbFJvdW5kaW5nTW9kZShvcHRpb25zLCAndHJ1bmMnKTtcbiAgICAgICAgY29uc3Qgcm91bmRpbmdJbmNyZW1lbnQgPSBUb1RlbXBvcmFsRGF0ZVRpbWVSb3VuZGluZ0luY3JlbWVudChvcHRpb25zLCBzbWFsbGVzdFVuaXQpO1xuICAgICAgICBsZXQgeyB5ZWFycywgbW9udGhzLCB3ZWVrcywgZGF5cywgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc2Vjb25kcywgbWljcm9zZWNvbmRzLCBuYW5vc2Vjb25kcyB9ID0gRGlmZmVyZW5jZUlTT0RhdGVUaW1lKEdldFNsb3QodGhpcywgSVNPX1lFQVIpLCBHZXRTbG90KHRoaXMsIElTT19NT05USCksIEdldFNsb3QodGhpcywgSVNPX0RBWSksIEdldFNsb3QodGhpcywgSVNPX0hPVVIpLCBHZXRTbG90KHRoaXMsIElTT19NSU5VVEUpLCBHZXRTbG90KHRoaXMsIElTT19TRUNPTkQpLCBHZXRTbG90KHRoaXMsIElTT19NSUxMSVNFQ09ORCksIEdldFNsb3QodGhpcywgSVNPX01JQ1JPU0VDT05EKSwgR2V0U2xvdCh0aGlzLCBJU09fTkFOT1NFQ09ORCksIEdldFNsb3Qob3RoZXIsIElTT19ZRUFSKSwgR2V0U2xvdChvdGhlciwgSVNPX01PTlRIKSwgR2V0U2xvdChvdGhlciwgSVNPX0RBWSksIEdldFNsb3Qob3RoZXIsIElTT19IT1VSKSwgR2V0U2xvdChvdGhlciwgSVNPX01JTlVURSksIEdldFNsb3Qob3RoZXIsIElTT19TRUNPTkQpLCBHZXRTbG90KG90aGVyLCBJU09fTUlMTElTRUNPTkQpLCBHZXRTbG90KG90aGVyLCBJU09fTUlDUk9TRUNPTkQpLCBHZXRTbG90KG90aGVyLCBJU09fTkFOT1NFQ09ORCksIGNhbGVuZGFyLCBsYXJnZXN0VW5pdCwgb3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IHJlbGF0aXZlVG8gPSBUZW1wb3JhbERhdGVUaW1lVG9EYXRlKHRoaXMpO1xuICAgICAgICAoeyB5ZWFycywgbW9udGhzLCB3ZWVrcywgZGF5cywgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc2Vjb25kcywgbWljcm9zZWNvbmRzLCBuYW5vc2Vjb25kcyB9ID1cbiAgICAgICAgICAgIFJvdW5kRHVyYXRpb24oeWVhcnMsIG1vbnRocywgd2Vla3MsIGRheXMsIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBtaWxsaXNlY29uZHMsIG1pY3Jvc2Vjb25kcywgbmFub3NlY29uZHMsIHJvdW5kaW5nSW5jcmVtZW50LCBzbWFsbGVzdFVuaXQsIE5lZ2F0ZVRlbXBvcmFsUm91bmRpbmdNb2RlKHJvdW5kaW5nTW9kZSksIHJlbGF0aXZlVG8pKTtcbiAgICAgICAgKHsgZGF5cywgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc2Vjb25kcywgbWljcm9zZWNvbmRzLCBuYW5vc2Vjb25kcyB9ID0gQmFsYW5jZUR1cmF0aW9uKGRheXMsIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBtaWxsaXNlY29uZHMsIG1pY3Jvc2Vjb25kcywgbmFub3NlY29uZHMsIGxhcmdlc3RVbml0KSk7XG4gICAgICAgIGNvbnN0IER1cmF0aW9uID0gR2V0SW50cmluc2ljKCclVGVtcG9yYWwuRHVyYXRpb24lJyk7XG4gICAgICAgIHJldHVybiBuZXcgRHVyYXRpb24oLXllYXJzLCAtbW9udGhzLCAtd2Vla3MsIC1kYXlzLCAtaG91cnMsIC1taW51dGVzLCAtc2Vjb25kcywgLW1pbGxpc2Vjb25kcywgLW1pY3Jvc2Vjb25kcywgLW5hbm9zZWNvbmRzKTtcbiAgICB9XG4gICAgcm91bmQob3B0aW9uc1BhcmFtKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbERhdGVUaW1lKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICBpZiAob3B0aW9uc1BhcmFtID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdvcHRpb25zIHBhcmFtZXRlciBpcyByZXF1aXJlZCcpO1xuICAgICAgICBjb25zdCBvcHRpb25zID0gdHlwZW9mIG9wdGlvbnNQYXJhbSA9PT0gJ3N0cmluZydcbiAgICAgICAgICAgID8gQ3JlYXRlT25lUHJvcE9iamVjdCgnc21hbGxlc3RVbml0Jywgb3B0aW9uc1BhcmFtKVxuICAgICAgICAgICAgOiBHZXRPcHRpb25zT2JqZWN0KG9wdGlvbnNQYXJhbSk7XG4gICAgICAgIGNvbnN0IHNtYWxsZXN0VW5pdCA9IFRvU21hbGxlc3RUZW1wb3JhbFVuaXQob3B0aW9ucywgdW5kZWZpbmVkLCBbJ3llYXInLCAnbW9udGgnLCAnd2VlayddKTtcbiAgICAgICAgaWYgKHNtYWxsZXN0VW5pdCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NtYWxsZXN0VW5pdCBpcyByZXF1aXJlZCcpO1xuICAgICAgICBjb25zdCByb3VuZGluZ01vZGUgPSBUb1RlbXBvcmFsUm91bmRpbmdNb2RlKG9wdGlvbnMsICdoYWxmRXhwYW5kJyk7XG4gICAgICAgIGNvbnN0IG1heGltdW1JbmNyZW1lbnRzID0ge1xuICAgICAgICAgICAgZGF5OiAxLFxuICAgICAgICAgICAgaG91cjogMjQsXG4gICAgICAgICAgICBtaW51dGU6IDYwLFxuICAgICAgICAgICAgc2Vjb25kOiA2MCxcbiAgICAgICAgICAgIG1pbGxpc2Vjb25kOiAxMDAwLFxuICAgICAgICAgICAgbWljcm9zZWNvbmQ6IDEwMDAsXG4gICAgICAgICAgICBuYW5vc2Vjb25kOiAxMDAwXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJvdW5kaW5nSW5jcmVtZW50ID0gVG9UZW1wb3JhbFJvdW5kaW5nSW5jcmVtZW50KG9wdGlvbnMsIG1heGltdW1JbmNyZW1lbnRzW3NtYWxsZXN0VW5pdF0sIGZhbHNlKTtcbiAgICAgICAgbGV0IHllYXIgPSBHZXRTbG90KHRoaXMsIElTT19ZRUFSKTtcbiAgICAgICAgbGV0IG1vbnRoID0gR2V0U2xvdCh0aGlzLCBJU09fTU9OVEgpO1xuICAgICAgICBsZXQgZGF5ID0gR2V0U2xvdCh0aGlzLCBJU09fREFZKTtcbiAgICAgICAgbGV0IGhvdXIgPSBHZXRTbG90KHRoaXMsIElTT19IT1VSKTtcbiAgICAgICAgbGV0IG1pbnV0ZSA9IEdldFNsb3QodGhpcywgSVNPX01JTlVURSk7XG4gICAgICAgIGxldCBzZWNvbmQgPSBHZXRTbG90KHRoaXMsIElTT19TRUNPTkQpO1xuICAgICAgICBsZXQgbWlsbGlzZWNvbmQgPSBHZXRTbG90KHRoaXMsIElTT19NSUxMSVNFQ09ORCk7XG4gICAgICAgIGxldCBtaWNyb3NlY29uZCA9IEdldFNsb3QodGhpcywgSVNPX01JQ1JPU0VDT05EKTtcbiAgICAgICAgbGV0IG5hbm9zZWNvbmQgPSBHZXRTbG90KHRoaXMsIElTT19OQU5PU0VDT05EKTtcbiAgICAgICAgKHsgeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kLCBtaWNyb3NlY29uZCwgbmFub3NlY29uZCB9ID0gUm91bmRJU09EYXRlVGltZSh5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQsIG1pY3Jvc2Vjb25kLCBuYW5vc2Vjb25kLCByb3VuZGluZ0luY3JlbWVudCwgc21hbGxlc3RVbml0LCByb3VuZGluZ01vZGUpKTtcbiAgICAgICAgcmV0dXJuIENyZWF0ZVRlbXBvcmFsRGF0ZVRpbWUoeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kLCBtaWNyb3NlY29uZCwgbmFub3NlY29uZCwgR2V0U2xvdCh0aGlzLCBDQUxFTkRBUikpO1xuICAgIH1cbiAgICBlcXVhbHMob3RoZXJQYXJhbSkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxEYXRlVGltZSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgY29uc3Qgb3RoZXIgPSBUb1RlbXBvcmFsRGF0ZVRpbWUob3RoZXJQYXJhbSk7XG4gICAgICAgIGZvciAoY29uc3Qgc2xvdCBvZiBbXG4gICAgICAgICAgICBJU09fWUVBUixcbiAgICAgICAgICAgIElTT19NT05USCxcbiAgICAgICAgICAgIElTT19EQVksXG4gICAgICAgICAgICBJU09fSE9VUixcbiAgICAgICAgICAgIElTT19NSU5VVEUsXG4gICAgICAgICAgICBJU09fU0VDT05ELFxuICAgICAgICAgICAgSVNPX01JTExJU0VDT05ELFxuICAgICAgICAgICAgSVNPX01JQ1JPU0VDT05ELFxuICAgICAgICAgICAgSVNPX05BTk9TRUNPTkRcbiAgICAgICAgXSkge1xuICAgICAgICAgICAgY29uc3QgdmFsMSA9IEdldFNsb3QodGhpcywgc2xvdCk7XG4gICAgICAgICAgICBjb25zdCB2YWwyID0gR2V0U2xvdChvdGhlciwgc2xvdCk7XG4gICAgICAgICAgICBpZiAodmFsMSAhPT0gdmFsMilcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIENhbGVuZGFyRXF1YWxzKEdldFNsb3QodGhpcywgQ0FMRU5EQVIpLCBHZXRTbG90KG90aGVyLCBDQUxFTkRBUikpO1xuICAgIH1cbiAgICB0b1N0cmluZyhvcHRpb25zUGFyYW0gPSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsRGF0ZVRpbWUodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSBHZXRPcHRpb25zT2JqZWN0KG9wdGlvbnNQYXJhbSk7XG4gICAgICAgIGNvbnN0IHsgcHJlY2lzaW9uLCB1bml0LCBpbmNyZW1lbnQgfSA9IFRvU2Vjb25kc1N0cmluZ1ByZWNpc2lvbihvcHRpb25zKTtcbiAgICAgICAgY29uc3Qgc2hvd0NhbGVuZGFyID0gVG9TaG93Q2FsZW5kYXJPcHRpb24ob3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IHJvdW5kaW5nTW9kZSA9IFRvVGVtcG9yYWxSb3VuZGluZ01vZGUob3B0aW9ucywgJ3RydW5jJyk7XG4gICAgICAgIHJldHVybiBUZW1wb3JhbERhdGVUaW1lVG9TdHJpbmcodGhpcywgcHJlY2lzaW9uLCBzaG93Q2FsZW5kYXIsIHsgdW5pdCwgaW5jcmVtZW50LCByb3VuZGluZ01vZGUgfSk7XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsRGF0ZVRpbWUodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIHJldHVybiBUZW1wb3JhbERhdGVUaW1lVG9TdHJpbmcodGhpcywgJ2F1dG8nKTtcbiAgICB9XG4gICAgdG9Mb2NhbGVTdHJpbmcobG9jYWxlcyA9IHVuZGVmaW5lZCwgb3B0aW9ucyA9IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxEYXRlVGltZSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlVGltZUZvcm1hdChsb2NhbGVzLCBvcHRpb25zKS5mb3JtYXQodGhpcyk7XG4gICAgfVxuICAgIHZhbHVlT2YoKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3VzZSBjb21wYXJlKCkgb3IgZXF1YWxzKCkgdG8gY29tcGFyZSBUZW1wb3JhbC5QbGFpbkRhdGVUaW1lJyk7XG4gICAgfVxuICAgIHRvWm9uZWREYXRlVGltZSh0ZW1wb3JhbFRpbWVab25lTGlrZSwgb3B0aW9uc1BhcmFtID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbERhdGVUaW1lKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICBjb25zdCB0aW1lWm9uZSA9IFRvVGVtcG9yYWxUaW1lWm9uZSh0ZW1wb3JhbFRpbWVab25lTGlrZSk7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSBHZXRPcHRpb25zT2JqZWN0KG9wdGlvbnNQYXJhbSk7XG4gICAgICAgIGNvbnN0IGRpc2FtYmlndWF0aW9uID0gVG9UZW1wb3JhbERpc2FtYmlndWF0aW9uKG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBpbnN0YW50ID0gQnVpbHRpblRpbWVab25lR2V0SW5zdGFudEZvcih0aW1lWm9uZSwgdGhpcywgZGlzYW1iaWd1YXRpb24pO1xuICAgICAgICByZXR1cm4gQ3JlYXRlVGVtcG9yYWxab25lZERhdGVUaW1lKEdldFNsb3QoaW5zdGFudCwgRVBPQ0hOQU5PU0VDT05EUyksIHRpbWVab25lLCBHZXRTbG90KHRoaXMsIENBTEVOREFSKSk7XG4gICAgfVxuICAgIHRvUGxhaW5EYXRlKCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxEYXRlVGltZSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgcmV0dXJuIFRlbXBvcmFsRGF0ZVRpbWVUb0RhdGUodGhpcyk7XG4gICAgfVxuICAgIHRvUGxhaW5ZZWFyTW9udGgoKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbERhdGVUaW1lKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICBjb25zdCBjYWxlbmRhciA9IEdldFNsb3QodGhpcywgQ0FMRU5EQVIpO1xuICAgICAgICBjb25zdCBmaWVsZE5hbWVzID0gQ2FsZW5kYXJGaWVsZHMoY2FsZW5kYXIsIFsnbW9udGhDb2RlJywgJ3llYXInXSk7XG4gICAgICAgIGNvbnN0IGZpZWxkcyA9IFRvVGVtcG9yYWxZZWFyTW9udGhGaWVsZHModGhpcywgZmllbGROYW1lcyk7XG4gICAgICAgIHJldHVybiBZZWFyTW9udGhGcm9tRmllbGRzKGNhbGVuZGFyLCBmaWVsZHMpO1xuICAgIH1cbiAgICB0b1BsYWluTW9udGhEYXkoKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbERhdGVUaW1lKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICBjb25zdCBjYWxlbmRhciA9IEdldFNsb3QodGhpcywgQ0FMRU5EQVIpO1xuICAgICAgICBjb25zdCBmaWVsZE5hbWVzID0gQ2FsZW5kYXJGaWVsZHMoY2FsZW5kYXIsIFsnZGF5JywgJ21vbnRoQ29kZSddKTtcbiAgICAgICAgY29uc3QgZmllbGRzID0gVG9UZW1wb3JhbE1vbnRoRGF5RmllbGRzKHRoaXMsIGZpZWxkTmFtZXMpO1xuICAgICAgICByZXR1cm4gTW9udGhEYXlGcm9tRmllbGRzKGNhbGVuZGFyLCBmaWVsZHMpO1xuICAgIH1cbiAgICB0b1BsYWluVGltZSgpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsRGF0ZVRpbWUodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIHJldHVybiBUZW1wb3JhbERhdGVUaW1lVG9UaW1lKHRoaXMpO1xuICAgIH1cbiAgICBnZXRJU09GaWVsZHMoKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbERhdGVUaW1lKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY2FsZW5kYXI6IEdldFNsb3QodGhpcywgQ0FMRU5EQVIpLFxuICAgICAgICAgICAgaXNvRGF5OiBHZXRTbG90KHRoaXMsIElTT19EQVkpLFxuICAgICAgICAgICAgaXNvSG91cjogR2V0U2xvdCh0aGlzLCBJU09fSE9VUiksXG4gICAgICAgICAgICBpc29NaWNyb3NlY29uZDogR2V0U2xvdCh0aGlzLCBJU09fTUlDUk9TRUNPTkQpLFxuICAgICAgICAgICAgaXNvTWlsbGlzZWNvbmQ6IEdldFNsb3QodGhpcywgSVNPX01JTExJU0VDT05EKSxcbiAgICAgICAgICAgIGlzb01pbnV0ZTogR2V0U2xvdCh0aGlzLCBJU09fTUlOVVRFKSxcbiAgICAgICAgICAgIGlzb01vbnRoOiBHZXRTbG90KHRoaXMsIElTT19NT05USCksXG4gICAgICAgICAgICBpc29OYW5vc2Vjb25kOiBHZXRTbG90KHRoaXMsIElTT19OQU5PU0VDT05EKSxcbiAgICAgICAgICAgIGlzb1NlY29uZDogR2V0U2xvdCh0aGlzLCBJU09fU0VDT05EKSxcbiAgICAgICAgICAgIGlzb1llYXI6IEdldFNsb3QodGhpcywgSVNPX1lFQVIpXG4gICAgICAgIH07XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tKGl0ZW0sIG9wdGlvbnNQYXJhbSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCBvcHRpb25zID0gR2V0T3B0aW9uc09iamVjdChvcHRpb25zUGFyYW0pO1xuICAgICAgICBpZiAoSXNUZW1wb3JhbERhdGVUaW1lKGl0ZW0pKSB7XG4gICAgICAgICAgICBUb1RlbXBvcmFsT3ZlcmZsb3cob3B0aW9ucyk7IC8vIHZhbGlkYXRlIGFuZCBpZ25vcmVcbiAgICAgICAgICAgIHJldHVybiBDcmVhdGVUZW1wb3JhbERhdGVUaW1lKEdldFNsb3QoaXRlbSwgSVNPX1lFQVIpLCBHZXRTbG90KGl0ZW0sIElTT19NT05USCksIEdldFNsb3QoaXRlbSwgSVNPX0RBWSksIEdldFNsb3QoaXRlbSwgSVNPX0hPVVIpLCBHZXRTbG90KGl0ZW0sIElTT19NSU5VVEUpLCBHZXRTbG90KGl0ZW0sIElTT19TRUNPTkQpLCBHZXRTbG90KGl0ZW0sIElTT19NSUxMSVNFQ09ORCksIEdldFNsb3QoaXRlbSwgSVNPX01JQ1JPU0VDT05EKSwgR2V0U2xvdChpdGVtLCBJU09fTkFOT1NFQ09ORCksIEdldFNsb3QoaXRlbSwgQ0FMRU5EQVIpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gVG9UZW1wb3JhbERhdGVUaW1lKGl0ZW0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBzdGF0aWMgY29tcGFyZShvbmVQYXJhbSwgdHdvUGFyYW0pIHtcbiAgICAgICAgY29uc3Qgb25lID0gVG9UZW1wb3JhbERhdGVUaW1lKG9uZVBhcmFtKTtcbiAgICAgICAgY29uc3QgdHdvID0gVG9UZW1wb3JhbERhdGVUaW1lKHR3b1BhcmFtKTtcbiAgICAgICAgZm9yIChjb25zdCBzbG90IG9mIFtcbiAgICAgICAgICAgIElTT19ZRUFSLFxuICAgICAgICAgICAgSVNPX01PTlRILFxuICAgICAgICAgICAgSVNPX0RBWSxcbiAgICAgICAgICAgIElTT19IT1VSLFxuICAgICAgICAgICAgSVNPX01JTlVURSxcbiAgICAgICAgICAgIElTT19TRUNPTkQsXG4gICAgICAgICAgICBJU09fTUlMTElTRUNPTkQsXG4gICAgICAgICAgICBJU09fTUlDUk9TRUNPTkQsXG4gICAgICAgICAgICBJU09fTkFOT1NFQ09ORFxuICAgICAgICBdKSB7XG4gICAgICAgICAgICBjb25zdCB2YWwxID0gR2V0U2xvdChvbmUsIHNsb3QpO1xuICAgICAgICAgICAgY29uc3QgdmFsMiA9IEdldFNsb3QodHdvLCBzbG90KTtcbiAgICAgICAgICAgIGlmICh2YWwxICE9PSB2YWwyKVxuICAgICAgICAgICAgICAgIHJldHVybiBDb21wYXJpc29uUmVzdWx0KHZhbDEgLSB2YWwyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG59XG5NYWtlSW50cmluc2ljQ2xhc3MoUGxhaW5EYXRlVGltZSwgJ1RlbXBvcmFsLlBsYWluRGF0ZVRpbWUnKTtcblxuY2xhc3MgRHVyYXRpb24ge1xuICAgIGNvbnN0cnVjdG9yKHllYXJzUGFyYW0gPSAwLCBtb250aHNQYXJhbSA9IDAsIHdlZWtzUGFyYW0gPSAwLCBkYXlzUGFyYW0gPSAwLCBob3Vyc1BhcmFtID0gMCwgbWludXRlc1BhcmFtID0gMCwgc2Vjb25kc1BhcmFtID0gMCwgbWlsbGlzZWNvbmRzUGFyYW0gPSAwLCBtaWNyb3NlY29uZHNQYXJhbSA9IDAsIG5hbm9zZWNvbmRzUGFyYW0gPSAwKSB7XG4gICAgICAgIGNvbnN0IHllYXJzID0gVG9JbnRlZ2VyV2l0aG91dFJvdW5kaW5nKHllYXJzUGFyYW0pO1xuICAgICAgICBjb25zdCBtb250aHMgPSBUb0ludGVnZXJXaXRob3V0Um91bmRpbmcobW9udGhzUGFyYW0pO1xuICAgICAgICBjb25zdCB3ZWVrcyA9IFRvSW50ZWdlcldpdGhvdXRSb3VuZGluZyh3ZWVrc1BhcmFtKTtcbiAgICAgICAgY29uc3QgZGF5cyA9IFRvSW50ZWdlcldpdGhvdXRSb3VuZGluZyhkYXlzUGFyYW0pO1xuICAgICAgICBjb25zdCBob3VycyA9IFRvSW50ZWdlcldpdGhvdXRSb3VuZGluZyhob3Vyc1BhcmFtKTtcbiAgICAgICAgY29uc3QgbWludXRlcyA9IFRvSW50ZWdlcldpdGhvdXRSb3VuZGluZyhtaW51dGVzUGFyYW0pO1xuICAgICAgICBjb25zdCBzZWNvbmRzID0gVG9JbnRlZ2VyV2l0aG91dFJvdW5kaW5nKHNlY29uZHNQYXJhbSk7XG4gICAgICAgIGNvbnN0IG1pbGxpc2Vjb25kcyA9IFRvSW50ZWdlcldpdGhvdXRSb3VuZGluZyhtaWxsaXNlY29uZHNQYXJhbSk7XG4gICAgICAgIGNvbnN0IG1pY3Jvc2Vjb25kcyA9IFRvSW50ZWdlcldpdGhvdXRSb3VuZGluZyhtaWNyb3NlY29uZHNQYXJhbSk7XG4gICAgICAgIGNvbnN0IG5hbm9zZWNvbmRzID0gVG9JbnRlZ2VyV2l0aG91dFJvdW5kaW5nKG5hbm9zZWNvbmRzUGFyYW0pO1xuICAgICAgICBjb25zdCBzaWduID0gRHVyYXRpb25TaWduKHllYXJzLCBtb250aHMsIHdlZWtzLCBkYXlzLCBob3VycywgbWludXRlcywgc2Vjb25kcywgbWlsbGlzZWNvbmRzLCBtaWNyb3NlY29uZHMsIG5hbm9zZWNvbmRzKTtcbiAgICAgICAgZm9yIChjb25zdCBwcm9wIG9mIFt5ZWFycywgbW9udGhzLCB3ZWVrcywgZGF5cywgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc2Vjb25kcywgbWljcm9zZWNvbmRzLCBuYW5vc2Vjb25kc10pIHtcbiAgICAgICAgICAgIGlmICghTnVtYmVyLmlzRmluaXRlKHByb3ApKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdpbmZpbml0ZSB2YWx1ZXMgbm90IGFsbG93ZWQgYXMgZHVyYXRpb24gZmllbGRzJyk7XG4gICAgICAgICAgICBjb25zdCBwcm9wU2lnbiA9IE1hdGguc2lnbihwcm9wKTtcbiAgICAgICAgICAgIGlmIChwcm9wU2lnbiAhPT0gMCAmJiBwcm9wU2lnbiAhPT0gc2lnbilcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignbWl4ZWQtc2lnbiB2YWx1ZXMgbm90IGFsbG93ZWQgYXMgZHVyYXRpb24gZmllbGRzJyk7XG4gICAgICAgIH1cbiAgICAgICAgQ3JlYXRlU2xvdHModGhpcyk7XG4gICAgICAgIFNldFNsb3QodGhpcywgWUVBUlMsIHllYXJzKTtcbiAgICAgICAgU2V0U2xvdCh0aGlzLCBNT05USFMsIG1vbnRocyk7XG4gICAgICAgIFNldFNsb3QodGhpcywgV0VFS1MsIHdlZWtzKTtcbiAgICAgICAgU2V0U2xvdCh0aGlzLCBEQVlTLCBkYXlzKTtcbiAgICAgICAgU2V0U2xvdCh0aGlzLCBIT1VSUywgaG91cnMpO1xuICAgICAgICBTZXRTbG90KHRoaXMsIE1JTlVURVMsIG1pbnV0ZXMpO1xuICAgICAgICBTZXRTbG90KHRoaXMsIFNFQ09ORFMsIHNlY29uZHMpO1xuICAgICAgICBTZXRTbG90KHRoaXMsIE1JTExJU0VDT05EUywgbWlsbGlzZWNvbmRzKTtcbiAgICAgICAgU2V0U2xvdCh0aGlzLCBNSUNST1NFQ09ORFMsIG1pY3Jvc2Vjb25kcyk7XG4gICAgICAgIFNldFNsb3QodGhpcywgTkFOT1NFQ09ORFMsIG5hbm9zZWNvbmRzKTtcbiAgICAgICAge1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdfcmVwcl8nLCB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IGAke3RoaXNbU3ltYm9sLnRvU3RyaW5nVGFnXX0gPCR7VGVtcG9yYWxEdXJhdGlvblRvU3RyaW5nKHRoaXMpfT5gLFxuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgeWVhcnMoKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbER1cmF0aW9uKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICByZXR1cm4gR2V0U2xvdCh0aGlzLCBZRUFSUyk7XG4gICAgfVxuICAgIGdldCBtb250aHMoKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbER1cmF0aW9uKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICByZXR1cm4gR2V0U2xvdCh0aGlzLCBNT05USFMpO1xuICAgIH1cbiAgICBnZXQgd2Vla3MoKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbER1cmF0aW9uKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICByZXR1cm4gR2V0U2xvdCh0aGlzLCBXRUVLUyk7XG4gICAgfVxuICAgIGdldCBkYXlzKCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxEdXJhdGlvbih0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgcmV0dXJuIEdldFNsb3QodGhpcywgREFZUyk7XG4gICAgfVxuICAgIGdldCBob3VycygpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsRHVyYXRpb24odGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIHJldHVybiBHZXRTbG90KHRoaXMsIEhPVVJTKTtcbiAgICB9XG4gICAgZ2V0IG1pbnV0ZXMoKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbER1cmF0aW9uKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICByZXR1cm4gR2V0U2xvdCh0aGlzLCBNSU5VVEVTKTtcbiAgICB9XG4gICAgZ2V0IHNlY29uZHMoKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbER1cmF0aW9uKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICByZXR1cm4gR2V0U2xvdCh0aGlzLCBTRUNPTkRTKTtcbiAgICB9XG4gICAgZ2V0IG1pbGxpc2Vjb25kcygpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsRHVyYXRpb24odGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIHJldHVybiBHZXRTbG90KHRoaXMsIE1JTExJU0VDT05EUyk7XG4gICAgfVxuICAgIGdldCBtaWNyb3NlY29uZHMoKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbER1cmF0aW9uKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICByZXR1cm4gR2V0U2xvdCh0aGlzLCBNSUNST1NFQ09ORFMpO1xuICAgIH1cbiAgICBnZXQgbmFub3NlY29uZHMoKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbER1cmF0aW9uKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICByZXR1cm4gR2V0U2xvdCh0aGlzLCBOQU5PU0VDT05EUyk7XG4gICAgfVxuICAgIGdldCBzaWduKCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxEdXJhdGlvbih0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgcmV0dXJuIER1cmF0aW9uU2lnbihHZXRTbG90KHRoaXMsIFlFQVJTKSwgR2V0U2xvdCh0aGlzLCBNT05USFMpLCBHZXRTbG90KHRoaXMsIFdFRUtTKSwgR2V0U2xvdCh0aGlzLCBEQVlTKSwgR2V0U2xvdCh0aGlzLCBIT1VSUyksIEdldFNsb3QodGhpcywgTUlOVVRFUyksIEdldFNsb3QodGhpcywgU0VDT05EUyksIEdldFNsb3QodGhpcywgTUlMTElTRUNPTkRTKSwgR2V0U2xvdCh0aGlzLCBNSUNST1NFQ09ORFMpLCBHZXRTbG90KHRoaXMsIE5BTk9TRUNPTkRTKSk7XG4gICAgfVxuICAgIGdldCBibGFuaygpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsRHVyYXRpb24odGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIHJldHVybiAoRHVyYXRpb25TaWduKEdldFNsb3QodGhpcywgWUVBUlMpLCBHZXRTbG90KHRoaXMsIE1PTlRIUyksIEdldFNsb3QodGhpcywgV0VFS1MpLCBHZXRTbG90KHRoaXMsIERBWVMpLCBHZXRTbG90KHRoaXMsIEhPVVJTKSwgR2V0U2xvdCh0aGlzLCBNSU5VVEVTKSwgR2V0U2xvdCh0aGlzLCBTRUNPTkRTKSwgR2V0U2xvdCh0aGlzLCBNSUxMSVNFQ09ORFMpLCBHZXRTbG90KHRoaXMsIE1JQ1JPU0VDT05EUyksIEdldFNsb3QodGhpcywgTkFOT1NFQ09ORFMpKSA9PT0gMCk7XG4gICAgfVxuICAgIHdpdGgoZHVyYXRpb25MaWtlKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbER1cmF0aW9uKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICBjb25zdCBwcm9wcyA9IFRvUGFydGlhbFJlY29yZChkdXJhdGlvbkxpa2UsIFtcbiAgICAgICAgICAgICdkYXlzJyxcbiAgICAgICAgICAgICdob3VycycsXG4gICAgICAgICAgICAnbWljcm9zZWNvbmRzJyxcbiAgICAgICAgICAgICdtaWxsaXNlY29uZHMnLFxuICAgICAgICAgICAgJ21pbnV0ZXMnLFxuICAgICAgICAgICAgJ21vbnRocycsXG4gICAgICAgICAgICAnbmFub3NlY29uZHMnLFxuICAgICAgICAgICAgJ3NlY29uZHMnLFxuICAgICAgICAgICAgJ3dlZWtzJyxcbiAgICAgICAgICAgICd5ZWFycydcbiAgICAgICAgXSk7XG4gICAgICAgIGlmICghcHJvcHMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgZHVyYXRpb24tbGlrZScpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgeWVhcnMgPSBHZXRTbG90KHRoaXMsIFlFQVJTKSwgbW9udGhzID0gR2V0U2xvdCh0aGlzLCBNT05USFMpLCB3ZWVrcyA9IEdldFNsb3QodGhpcywgV0VFS1MpLCBkYXlzID0gR2V0U2xvdCh0aGlzLCBEQVlTKSwgaG91cnMgPSBHZXRTbG90KHRoaXMsIEhPVVJTKSwgbWludXRlcyA9IEdldFNsb3QodGhpcywgTUlOVVRFUyksIHNlY29uZHMgPSBHZXRTbG90KHRoaXMsIFNFQ09ORFMpLCBtaWxsaXNlY29uZHMgPSBHZXRTbG90KHRoaXMsIE1JTExJU0VDT05EUyksIG1pY3Jvc2Vjb25kcyA9IEdldFNsb3QodGhpcywgTUlDUk9TRUNPTkRTKSwgbmFub3NlY29uZHMgPSBHZXRTbG90KHRoaXMsIE5BTk9TRUNPTkRTKSB9ID0gcHJvcHM7XG4gICAgICAgIHJldHVybiBuZXcgRHVyYXRpb24oeWVhcnMsIG1vbnRocywgd2Vla3MsIGRheXMsIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBtaWxsaXNlY29uZHMsIG1pY3Jvc2Vjb25kcywgbmFub3NlY29uZHMpO1xuICAgIH1cbiAgICBuZWdhdGVkKCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxEdXJhdGlvbih0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgcmV0dXJuIENyZWF0ZU5lZ2F0ZWRUZW1wb3JhbER1cmF0aW9uKHRoaXMpO1xuICAgIH1cbiAgICBhYnMoKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbER1cmF0aW9uKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICByZXR1cm4gbmV3IER1cmF0aW9uKE1hdGguYWJzKEdldFNsb3QodGhpcywgWUVBUlMpKSwgTWF0aC5hYnMoR2V0U2xvdCh0aGlzLCBNT05USFMpKSwgTWF0aC5hYnMoR2V0U2xvdCh0aGlzLCBXRUVLUykpLCBNYXRoLmFicyhHZXRTbG90KHRoaXMsIERBWVMpKSwgTWF0aC5hYnMoR2V0U2xvdCh0aGlzLCBIT1VSUykpLCBNYXRoLmFicyhHZXRTbG90KHRoaXMsIE1JTlVURVMpKSwgTWF0aC5hYnMoR2V0U2xvdCh0aGlzLCBTRUNPTkRTKSksIE1hdGguYWJzKEdldFNsb3QodGhpcywgTUlMTElTRUNPTkRTKSksIE1hdGguYWJzKEdldFNsb3QodGhpcywgTUlDUk9TRUNPTkRTKSksIE1hdGguYWJzKEdldFNsb3QodGhpcywgTkFOT1NFQ09ORFMpKSk7XG4gICAgfVxuICAgIGFkZChvdGhlciwgb3B0aW9uc1BhcmFtID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbER1cmF0aW9uKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICBsZXQgeyB5ZWFycywgbW9udGhzLCB3ZWVrcywgZGF5cywgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc2Vjb25kcywgbWljcm9zZWNvbmRzLCBuYW5vc2Vjb25kcyB9ID0gVG9MaW1pdGVkVGVtcG9yYWxEdXJhdGlvbihvdGhlcik7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSBHZXRPcHRpb25zT2JqZWN0KG9wdGlvbnNQYXJhbSk7XG4gICAgICAgIGNvbnN0IHJlbGF0aXZlVG8gPSBUb1JlbGF0aXZlVGVtcG9yYWxPYmplY3Qob3B0aW9ucyk7XG4gICAgICAgICh7IHllYXJzLCBtb250aHMsIHdlZWtzLCBkYXlzLCBob3VycywgbWludXRlcywgc2Vjb25kcywgbWlsbGlzZWNvbmRzLCBtaWNyb3NlY29uZHMsIG5hbm9zZWNvbmRzIH0gPSBBZGREdXJhdGlvbihHZXRTbG90KHRoaXMsIFlFQVJTKSwgR2V0U2xvdCh0aGlzLCBNT05USFMpLCBHZXRTbG90KHRoaXMsIFdFRUtTKSwgR2V0U2xvdCh0aGlzLCBEQVlTKSwgR2V0U2xvdCh0aGlzLCBIT1VSUyksIEdldFNsb3QodGhpcywgTUlOVVRFUyksIEdldFNsb3QodGhpcywgU0VDT05EUyksIEdldFNsb3QodGhpcywgTUlMTElTRUNPTkRTKSwgR2V0U2xvdCh0aGlzLCBNSUNST1NFQ09ORFMpLCBHZXRTbG90KHRoaXMsIE5BTk9TRUNPTkRTKSwgeWVhcnMsIG1vbnRocywgd2Vla3MsIGRheXMsIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBtaWxsaXNlY29uZHMsIG1pY3Jvc2Vjb25kcywgbmFub3NlY29uZHMsIHJlbGF0aXZlVG8pKTtcbiAgICAgICAgcmV0dXJuIG5ldyBEdXJhdGlvbih5ZWFycywgbW9udGhzLCB3ZWVrcywgZGF5cywgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc2Vjb25kcywgbWljcm9zZWNvbmRzLCBuYW5vc2Vjb25kcyk7XG4gICAgfVxuICAgIHN1YnRyYWN0KG90aGVyLCBvcHRpb25zUGFyYW0gPSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsRHVyYXRpb24odGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIGxldCB7IHllYXJzLCBtb250aHMsIHdlZWtzLCBkYXlzLCBob3VycywgbWludXRlcywgc2Vjb25kcywgbWlsbGlzZWNvbmRzLCBtaWNyb3NlY29uZHMsIG5hbm9zZWNvbmRzIH0gPSBUb0xpbWl0ZWRUZW1wb3JhbER1cmF0aW9uKG90aGVyKTtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IEdldE9wdGlvbnNPYmplY3Qob3B0aW9uc1BhcmFtKTtcbiAgICAgICAgY29uc3QgcmVsYXRpdmVUbyA9IFRvUmVsYXRpdmVUZW1wb3JhbE9iamVjdChvcHRpb25zKTtcbiAgICAgICAgKHsgeWVhcnMsIG1vbnRocywgd2Vla3MsIGRheXMsIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBtaWxsaXNlY29uZHMsIG1pY3Jvc2Vjb25kcywgbmFub3NlY29uZHMgfSA9IEFkZER1cmF0aW9uKEdldFNsb3QodGhpcywgWUVBUlMpLCBHZXRTbG90KHRoaXMsIE1PTlRIUyksIEdldFNsb3QodGhpcywgV0VFS1MpLCBHZXRTbG90KHRoaXMsIERBWVMpLCBHZXRTbG90KHRoaXMsIEhPVVJTKSwgR2V0U2xvdCh0aGlzLCBNSU5VVEVTKSwgR2V0U2xvdCh0aGlzLCBTRUNPTkRTKSwgR2V0U2xvdCh0aGlzLCBNSUxMSVNFQ09ORFMpLCBHZXRTbG90KHRoaXMsIE1JQ1JPU0VDT05EUyksIEdldFNsb3QodGhpcywgTkFOT1NFQ09ORFMpLCAteWVhcnMsIC1tb250aHMsIC13ZWVrcywgLWRheXMsIC1ob3VycywgLW1pbnV0ZXMsIC1zZWNvbmRzLCAtbWlsbGlzZWNvbmRzLCAtbWljcm9zZWNvbmRzLCAtbmFub3NlY29uZHMsIHJlbGF0aXZlVG8pKTtcbiAgICAgICAgcmV0dXJuIG5ldyBEdXJhdGlvbih5ZWFycywgbW9udGhzLCB3ZWVrcywgZGF5cywgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc2Vjb25kcywgbWljcm9zZWNvbmRzLCBuYW5vc2Vjb25kcyk7XG4gICAgfVxuICAgIHJvdW5kKG9wdGlvbnNQYXJhbSkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxEdXJhdGlvbih0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgaWYgKG9wdGlvbnNQYXJhbSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignb3B0aW9ucyBwYXJhbWV0ZXIgaXMgcmVxdWlyZWQnKTtcbiAgICAgICAgbGV0IHllYXJzID0gR2V0U2xvdCh0aGlzLCBZRUFSUyk7XG4gICAgICAgIGxldCBtb250aHMgPSBHZXRTbG90KHRoaXMsIE1PTlRIUyk7XG4gICAgICAgIGxldCB3ZWVrcyA9IEdldFNsb3QodGhpcywgV0VFS1MpO1xuICAgICAgICBsZXQgZGF5cyA9IEdldFNsb3QodGhpcywgREFZUyk7XG4gICAgICAgIGxldCBob3VycyA9IEdldFNsb3QodGhpcywgSE9VUlMpO1xuICAgICAgICBsZXQgbWludXRlcyA9IEdldFNsb3QodGhpcywgTUlOVVRFUyk7XG4gICAgICAgIGxldCBzZWNvbmRzID0gR2V0U2xvdCh0aGlzLCBTRUNPTkRTKTtcbiAgICAgICAgbGV0IG1pbGxpc2Vjb25kcyA9IEdldFNsb3QodGhpcywgTUlMTElTRUNPTkRTKTtcbiAgICAgICAgbGV0IG1pY3Jvc2Vjb25kcyA9IEdldFNsb3QodGhpcywgTUlDUk9TRUNPTkRTKTtcbiAgICAgICAgbGV0IG5hbm9zZWNvbmRzID0gR2V0U2xvdCh0aGlzLCBOQU5PU0VDT05EUyk7XG4gICAgICAgIGxldCBkZWZhdWx0TGFyZ2VzdFVuaXQgPSBEZWZhdWx0VGVtcG9yYWxMYXJnZXN0VW5pdCh5ZWFycywgbW9udGhzLCB3ZWVrcywgZGF5cywgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc2Vjb25kcywgbWljcm9zZWNvbmRzLCBuYW5vc2Vjb25kcyk7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB0eXBlb2Ygb3B0aW9uc1BhcmFtID09PSAnc3RyaW5nJ1xuICAgICAgICAgICAgPyBDcmVhdGVPbmVQcm9wT2JqZWN0KCdzbWFsbGVzdFVuaXQnLCBvcHRpb25zUGFyYW0pXG4gICAgICAgICAgICA6IEdldE9wdGlvbnNPYmplY3Qob3B0aW9uc1BhcmFtKTtcbiAgICAgICAgbGV0IHNtYWxsZXN0VW5pdCA9IFRvU21hbGxlc3RUZW1wb3JhbFVuaXQob3B0aW9ucywgdW5kZWZpbmVkKTtcbiAgICAgICAgbGV0IHNtYWxsZXN0VW5pdFByZXNlbnQgPSB0cnVlO1xuICAgICAgICBpZiAoIXNtYWxsZXN0VW5pdCkge1xuICAgICAgICAgICAgc21hbGxlc3RVbml0UHJlc2VudCA9IGZhbHNlO1xuICAgICAgICAgICAgc21hbGxlc3RVbml0ID0gJ25hbm9zZWNvbmQnO1xuICAgICAgICB9XG4gICAgICAgIGRlZmF1bHRMYXJnZXN0VW5pdCA9IExhcmdlck9mVHdvVGVtcG9yYWxVbml0cyhkZWZhdWx0TGFyZ2VzdFVuaXQsIHNtYWxsZXN0VW5pdCk7XG4gICAgICAgIGxldCBsYXJnZXN0VW5pdCA9IFRvTGFyZ2VzdFRlbXBvcmFsVW5pdChvcHRpb25zLCB1bmRlZmluZWQpO1xuICAgICAgICBsZXQgbGFyZ2VzdFVuaXRQcmVzZW50ID0gdHJ1ZTtcbiAgICAgICAgaWYgKCFsYXJnZXN0VW5pdCkge1xuICAgICAgICAgICAgbGFyZ2VzdFVuaXRQcmVzZW50ID0gZmFsc2U7XG4gICAgICAgICAgICBsYXJnZXN0VW5pdCA9IGRlZmF1bHRMYXJnZXN0VW5pdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGFyZ2VzdFVuaXQgPT09ICdhdXRvJylcbiAgICAgICAgICAgIGxhcmdlc3RVbml0ID0gZGVmYXVsdExhcmdlc3RVbml0O1xuICAgICAgICBpZiAoIXNtYWxsZXN0VW5pdFByZXNlbnQgJiYgIWxhcmdlc3RVbml0UHJlc2VudCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2F0IGxlYXN0IG9uZSBvZiBzbWFsbGVzdFVuaXQgb3IgbGFyZ2VzdFVuaXQgaXMgcmVxdWlyZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBWYWxpZGF0ZVRlbXBvcmFsVW5pdFJhbmdlKGxhcmdlc3RVbml0LCBzbWFsbGVzdFVuaXQpO1xuICAgICAgICBjb25zdCByb3VuZGluZ01vZGUgPSBUb1RlbXBvcmFsUm91bmRpbmdNb2RlKG9wdGlvbnMsICdoYWxmRXhwYW5kJyk7XG4gICAgICAgIGNvbnN0IHJvdW5kaW5nSW5jcmVtZW50ID0gVG9UZW1wb3JhbERhdGVUaW1lUm91bmRpbmdJbmNyZW1lbnQob3B0aW9ucywgc21hbGxlc3RVbml0KTtcbiAgICAgICAgbGV0IHJlbGF0aXZlVG8gPSBUb1JlbGF0aXZlVGVtcG9yYWxPYmplY3Qob3B0aW9ucyk7XG4gICAgICAgICh7IHllYXJzLCBtb250aHMsIHdlZWtzLCBkYXlzIH0gPSBVbmJhbGFuY2VEdXJhdGlvblJlbGF0aXZlKHllYXJzLCBtb250aHMsIHdlZWtzLCBkYXlzLCBsYXJnZXN0VW5pdCwgcmVsYXRpdmVUbykpO1xuICAgICAgICAoeyB5ZWFycywgbW9udGhzLCB3ZWVrcywgZGF5cywgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc2Vjb25kcywgbWljcm9zZWNvbmRzLCBuYW5vc2Vjb25kcyB9ID1cbiAgICAgICAgICAgIFJvdW5kRHVyYXRpb24oeWVhcnMsIG1vbnRocywgd2Vla3MsIGRheXMsIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBtaWxsaXNlY29uZHMsIG1pY3Jvc2Vjb25kcywgbmFub3NlY29uZHMsIHJvdW5kaW5nSW5jcmVtZW50LCBzbWFsbGVzdFVuaXQsIHJvdW5kaW5nTW9kZSwgcmVsYXRpdmVUbykpO1xuICAgICAgICAoeyB5ZWFycywgbW9udGhzLCB3ZWVrcywgZGF5cywgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc2Vjb25kcywgbWljcm9zZWNvbmRzLCBuYW5vc2Vjb25kcyB9ID1cbiAgICAgICAgICAgIEFkanVzdFJvdW5kZWREdXJhdGlvbkRheXMoeWVhcnMsIG1vbnRocywgd2Vla3MsIGRheXMsIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBtaWxsaXNlY29uZHMsIG1pY3Jvc2Vjb25kcywgbmFub3NlY29uZHMsIHJvdW5kaW5nSW5jcmVtZW50LCBzbWFsbGVzdFVuaXQsIHJvdW5kaW5nTW9kZSwgcmVsYXRpdmVUbykpO1xuICAgICAgICAoeyB5ZWFycywgbW9udGhzLCB3ZWVrcywgZGF5cyB9ID0gQmFsYW5jZUR1cmF0aW9uUmVsYXRpdmUoeWVhcnMsIG1vbnRocywgd2Vla3MsIGRheXMsIGxhcmdlc3RVbml0LCByZWxhdGl2ZVRvKSk7XG4gICAgICAgIGlmIChJc1RlbXBvcmFsWm9uZWREYXRlVGltZShyZWxhdGl2ZVRvKSkge1xuICAgICAgICAgICAgcmVsYXRpdmVUbyA9IE1vdmVSZWxhdGl2ZVpvbmVkRGF0ZVRpbWUocmVsYXRpdmVUbywgeWVhcnMsIG1vbnRocywgd2Vla3MsIDApO1xuICAgICAgICB9XG4gICAgICAgICh7IGRheXMsIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBtaWxsaXNlY29uZHMsIG1pY3Jvc2Vjb25kcywgbmFub3NlY29uZHMgfSA9IEJhbGFuY2VEdXJhdGlvbihkYXlzLCBob3VycywgbWludXRlcywgc2Vjb25kcywgbWlsbGlzZWNvbmRzLCBtaWNyb3NlY29uZHMsIG5hbm9zZWNvbmRzLCBsYXJnZXN0VW5pdCwgcmVsYXRpdmVUbykpO1xuICAgICAgICByZXR1cm4gbmV3IER1cmF0aW9uKHllYXJzLCBtb250aHMsIHdlZWtzLCBkYXlzLCBob3VycywgbWludXRlcywgc2Vjb25kcywgbWlsbGlzZWNvbmRzLCBtaWNyb3NlY29uZHMsIG5hbm9zZWNvbmRzKTtcbiAgICB9XG4gICAgdG90YWwob3B0aW9uc1BhcmFtKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbER1cmF0aW9uKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICBsZXQgeWVhcnMgPSBHZXRTbG90KHRoaXMsIFlFQVJTKTtcbiAgICAgICAgbGV0IG1vbnRocyA9IEdldFNsb3QodGhpcywgTU9OVEhTKTtcbiAgICAgICAgbGV0IHdlZWtzID0gR2V0U2xvdCh0aGlzLCBXRUVLUyk7XG4gICAgICAgIGxldCBkYXlzID0gR2V0U2xvdCh0aGlzLCBEQVlTKTtcbiAgICAgICAgbGV0IGhvdXJzID0gR2V0U2xvdCh0aGlzLCBIT1VSUyk7XG4gICAgICAgIGxldCBtaW51dGVzID0gR2V0U2xvdCh0aGlzLCBNSU5VVEVTKTtcbiAgICAgICAgbGV0IHNlY29uZHMgPSBHZXRTbG90KHRoaXMsIFNFQ09ORFMpO1xuICAgICAgICBsZXQgbWlsbGlzZWNvbmRzID0gR2V0U2xvdCh0aGlzLCBNSUxMSVNFQ09ORFMpO1xuICAgICAgICBsZXQgbWljcm9zZWNvbmRzID0gR2V0U2xvdCh0aGlzLCBNSUNST1NFQ09ORFMpO1xuICAgICAgICBsZXQgbmFub3NlY29uZHMgPSBHZXRTbG90KHRoaXMsIE5BTk9TRUNPTkRTKTtcbiAgICAgICAgaWYgKG9wdGlvbnNQYXJhbSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignb3B0aW9ucyBhcmd1bWVudCBpcyByZXF1aXJlZCcpO1xuICAgICAgICBjb25zdCBvcHRpb25zID0gdHlwZW9mIG9wdGlvbnNQYXJhbSA9PT0gJ3N0cmluZydcbiAgICAgICAgICAgID8gQ3JlYXRlT25lUHJvcE9iamVjdCgndW5pdCcsIG9wdGlvbnNQYXJhbSlcbiAgICAgICAgICAgIDogR2V0T3B0aW9uc09iamVjdChvcHRpb25zUGFyYW0pO1xuICAgICAgICBjb25zdCB1bml0ID0gVG9UZW1wb3JhbER1cmF0aW9uVG90YWxVbml0KG9wdGlvbnMpO1xuICAgICAgICBpZiAodW5pdCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3VuaXQgb3B0aW9uIGlzIHJlcXVpcmVkJyk7XG4gICAgICAgIGNvbnN0IHJlbGF0aXZlVG8gPSBUb1JlbGF0aXZlVGVtcG9yYWxPYmplY3Qob3B0aW9ucyk7XG4gICAgICAgIC8vIENvbnZlcnQgbGFyZ2VyIHVuaXRzIGRvd24gdG8gZGF5c1xuICAgICAgICAoeyB5ZWFycywgbW9udGhzLCB3ZWVrcywgZGF5cyB9ID0gVW5iYWxhbmNlRHVyYXRpb25SZWxhdGl2ZSh5ZWFycywgbW9udGhzLCB3ZWVrcywgZGF5cywgdW5pdCwgcmVsYXRpdmVUbykpO1xuICAgICAgICAvLyBJZiB0aGUgdW5pdCB3ZSdyZSB0b3RhbGxpbmcgaXMgc21hbGxlciB0aGFuIGBkYXlzYCwgY29udmVydCBkYXlzIGRvd24gdG8gdGhhdCB1bml0LlxuICAgICAgICBsZXQgaW50ZXJtZWRpYXRlO1xuICAgICAgICBpZiAoSXNUZW1wb3JhbFpvbmVkRGF0ZVRpbWUocmVsYXRpdmVUbykpIHtcbiAgICAgICAgICAgIGludGVybWVkaWF0ZSA9IE1vdmVSZWxhdGl2ZVpvbmVkRGF0ZVRpbWUocmVsYXRpdmVUbywgeWVhcnMsIG1vbnRocywgd2Vla3MsIDApO1xuICAgICAgICB9XG4gICAgICAgICh7IGRheXMsIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBtaWxsaXNlY29uZHMsIG1pY3Jvc2Vjb25kcywgbmFub3NlY29uZHMgfSA9IEJhbGFuY2VEdXJhdGlvbihkYXlzLCBob3VycywgbWludXRlcywgc2Vjb25kcywgbWlsbGlzZWNvbmRzLCBtaWNyb3NlY29uZHMsIG5hbm9zZWNvbmRzLCB1bml0LCBpbnRlcm1lZGlhdGUpKTtcbiAgICAgICAgLy8gRmluYWxseSwgdHJ1bmNhdGUgdG8gdGhlIGNvcnJlY3QgdW5pdCBhbmQgY2FsY3VsYXRlIHJlbWFpbmRlclxuICAgICAgICBjb25zdCB7IHRvdGFsIH0gPSBSb3VuZER1cmF0aW9uKHllYXJzLCBtb250aHMsIHdlZWtzLCBkYXlzLCBob3VycywgbWludXRlcywgc2Vjb25kcywgbWlsbGlzZWNvbmRzLCBtaWNyb3NlY29uZHMsIG5hbm9zZWNvbmRzLCAxLCB1bml0LCAndHJ1bmMnLCByZWxhdGl2ZVRvKTtcbiAgICAgICAgcmV0dXJuIHRvdGFsO1xuICAgIH1cbiAgICB0b1N0cmluZyhvcHRpb25zUGFyYW0gPSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsRHVyYXRpb24odGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSBHZXRPcHRpb25zT2JqZWN0KG9wdGlvbnNQYXJhbSk7XG4gICAgICAgIGNvbnN0IHsgcHJlY2lzaW9uLCB1bml0LCBpbmNyZW1lbnQgfSA9IFRvU2Vjb25kc1N0cmluZ1ByZWNpc2lvbihvcHRpb25zKTtcbiAgICAgICAgaWYgKHByZWNpc2lvbiA9PT0gJ21pbnV0ZScpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc21hbGxlc3RVbml0IG11c3Qgbm90IGJlIFwibWludXRlXCInKTtcbiAgICAgICAgY29uc3Qgcm91bmRpbmdNb2RlID0gVG9UZW1wb3JhbFJvdW5kaW5nTW9kZShvcHRpb25zLCAndHJ1bmMnKTtcbiAgICAgICAgcmV0dXJuIFRlbXBvcmFsRHVyYXRpb25Ub1N0cmluZyh0aGlzLCBwcmVjaXNpb24sIHsgdW5pdCwgaW5jcmVtZW50LCByb3VuZGluZ01vZGUgfSk7XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsRHVyYXRpb24odGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIHJldHVybiBUZW1wb3JhbER1cmF0aW9uVG9TdHJpbmcodGhpcyk7XG4gICAgfVxuICAgIHRvTG9jYWxlU3RyaW5nKGxvY2FsZXMgPSB1bmRlZmluZWQsIG9wdGlvbnMgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsRHVyYXRpb24odGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIGlmICh0eXBlb2YgSW50bCAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIEludGwuRHVyYXRpb25Gb3JtYXQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEludGwuRHVyYXRpb25Gb3JtYXQobG9jYWxlcywgb3B0aW9ucykuZm9ybWF0KHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnNvbGUud2FybignVGVtcG9yYWwuRHVyYXRpb24ucHJvdG90eXBlLnRvTG9jYWxlU3RyaW5nKCkgcmVxdWlyZXMgSW50bC5EdXJhdGlvbkZvcm1hdC4nKTtcbiAgICAgICAgcmV0dXJuIFRlbXBvcmFsRHVyYXRpb25Ub1N0cmluZyh0aGlzKTtcbiAgICB9XG4gICAgdmFsdWVPZigpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigndXNlIGNvbXBhcmUoKSB0byBjb21wYXJlIFRlbXBvcmFsLkR1cmF0aW9uJyk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tKGl0ZW0pIHtcbiAgICAgICAgaWYgKElzVGVtcG9yYWxEdXJhdGlvbihpdGVtKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBEdXJhdGlvbihHZXRTbG90KGl0ZW0sIFlFQVJTKSwgR2V0U2xvdChpdGVtLCBNT05USFMpLCBHZXRTbG90KGl0ZW0sIFdFRUtTKSwgR2V0U2xvdChpdGVtLCBEQVlTKSwgR2V0U2xvdChpdGVtLCBIT1VSUyksIEdldFNsb3QoaXRlbSwgTUlOVVRFUyksIEdldFNsb3QoaXRlbSwgU0VDT05EUyksIEdldFNsb3QoaXRlbSwgTUlMTElTRUNPTkRTKSwgR2V0U2xvdChpdGVtLCBNSUNST1NFQ09ORFMpLCBHZXRTbG90KGl0ZW0sIE5BTk9TRUNPTkRTKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFRvVGVtcG9yYWxEdXJhdGlvbihpdGVtKTtcbiAgICB9XG4gICAgc3RhdGljIGNvbXBhcmUob25lUGFyYW0sIHR3b1BhcmFtLCBvcHRpb25zUGFyYW0gPSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3Qgb25lID0gVG9UZW1wb3JhbER1cmF0aW9uKG9uZVBhcmFtKTtcbiAgICAgICAgY29uc3QgdHdvID0gVG9UZW1wb3JhbER1cmF0aW9uKHR3b1BhcmFtKTtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IEdldE9wdGlvbnNPYmplY3Qob3B0aW9uc1BhcmFtKTtcbiAgICAgICAgY29uc3QgcmVsYXRpdmVUbyA9IFRvUmVsYXRpdmVUZW1wb3JhbE9iamVjdChvcHRpb25zKTtcbiAgICAgICAgY29uc3QgeTEgPSBHZXRTbG90KG9uZSwgWUVBUlMpO1xuICAgICAgICBjb25zdCBtb24xID0gR2V0U2xvdChvbmUsIE1PTlRIUyk7XG4gICAgICAgIGNvbnN0IHcxID0gR2V0U2xvdChvbmUsIFdFRUtTKTtcbiAgICAgICAgbGV0IGQxID0gR2V0U2xvdChvbmUsIERBWVMpO1xuICAgICAgICBjb25zdCBoMSA9IEdldFNsb3Qob25lLCBIT1VSUyk7XG4gICAgICAgIGNvbnN0IG1pbjEgPSBHZXRTbG90KG9uZSwgTUlOVVRFUyk7XG4gICAgICAgIGNvbnN0IHMxID0gR2V0U2xvdChvbmUsIFNFQ09ORFMpO1xuICAgICAgICBjb25zdCBtczEgPSBHZXRTbG90KG9uZSwgTUlMTElTRUNPTkRTKTtcbiAgICAgICAgY29uc3QgwrVzMSA9IEdldFNsb3Qob25lLCBNSUNST1NFQ09ORFMpO1xuICAgICAgICBsZXQgbnMxID0gR2V0U2xvdChvbmUsIE5BTk9TRUNPTkRTKTtcbiAgICAgICAgY29uc3QgeTIgPSBHZXRTbG90KHR3bywgWUVBUlMpO1xuICAgICAgICBjb25zdCBtb24yID0gR2V0U2xvdCh0d28sIE1PTlRIUyk7XG4gICAgICAgIGNvbnN0IHcyID0gR2V0U2xvdCh0d28sIFdFRUtTKTtcbiAgICAgICAgbGV0IGQyID0gR2V0U2xvdCh0d28sIERBWVMpO1xuICAgICAgICBjb25zdCBoMiA9IEdldFNsb3QodHdvLCBIT1VSUyk7XG4gICAgICAgIGNvbnN0IG1pbjIgPSBHZXRTbG90KHR3bywgTUlOVVRFUyk7XG4gICAgICAgIGNvbnN0IHMyID0gR2V0U2xvdCh0d28sIFNFQ09ORFMpO1xuICAgICAgICBjb25zdCBtczIgPSBHZXRTbG90KHR3bywgTUlMTElTRUNPTkRTKTtcbiAgICAgICAgY29uc3QgwrVzMiA9IEdldFNsb3QodHdvLCBNSUNST1NFQ09ORFMpO1xuICAgICAgICBsZXQgbnMyID0gR2V0U2xvdCh0d28sIE5BTk9TRUNPTkRTKTtcbiAgICAgICAgY29uc3Qgc2hpZnQxID0gQ2FsY3VsYXRlT2Zmc2V0U2hpZnQocmVsYXRpdmVUbywgeTEsIG1vbjEsIHcxLCBkMSwgaDEsIG1pbjEsIHMxLCBtczEsIMK1czEsIG5zMSk7XG4gICAgICAgIGNvbnN0IHNoaWZ0MiA9IENhbGN1bGF0ZU9mZnNldFNoaWZ0KHJlbGF0aXZlVG8sIHkyLCBtb24yLCB3MiwgZDIsIGgyLCBtaW4yLCBzMiwgbXMyLCDCtXMyLCBuczIpO1xuICAgICAgICBpZiAoeTEgIT09IDAgfHwgeTIgIT09IDAgfHwgbW9uMSAhPT0gMCB8fCBtb24yICE9PSAwIHx8IHcxICE9PSAwIHx8IHcyICE9PSAwKSB7XG4gICAgICAgICAgICAoeyBkYXlzOiBkMSB9ID0gVW5iYWxhbmNlRHVyYXRpb25SZWxhdGl2ZSh5MSwgbW9uMSwgdzEsIGQxLCAnZGF5JywgcmVsYXRpdmVUbykpO1xuICAgICAgICAgICAgKHsgZGF5czogZDIgfSA9IFVuYmFsYW5jZUR1cmF0aW9uUmVsYXRpdmUoeTIsIG1vbjIsIHcyLCBkMiwgJ2RheScsIHJlbGF0aXZlVG8pKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0b3RhbE5zMSA9IFRvdGFsRHVyYXRpb25OYW5vc2Vjb25kcyhkMSwgaDEsIG1pbjEsIHMxLCBtczEsIMK1czEsIG5zMSwgc2hpZnQxKTtcbiAgICAgICAgY29uc3QgdG90YWxOczIgPSBUb3RhbER1cmF0aW9uTmFub3NlY29uZHMoZDIsIGgyLCBtaW4yLCBzMiwgbXMyLCDCtXMyLCBuczIsIHNoaWZ0Mik7XG4gICAgICAgIHJldHVybiBDb21wYXJpc29uUmVzdWx0KEpTQkkudG9OdW1iZXIoSlNCSS5zdWJ0cmFjdCh0b3RhbE5zMSwgdG90YWxOczIpKSk7XG4gICAgfVxufVxuTWFrZUludHJpbnNpY0NsYXNzKER1cmF0aW9uLCAnVGVtcG9yYWwuRHVyYXRpb24nKTtcblxuY29uc3QgT2JqZWN0Q3JlYXRlJDEgPSBPYmplY3QuY3JlYXRlO1xuY2xhc3MgUGxhaW5Nb250aERheSB7XG4gICAgY29uc3RydWN0b3IoaXNvTW9udGhQYXJhbSwgaXNvRGF5UGFyYW0sIGNhbGVuZGFyUGFyYW0gPSBHZXRJU084NjAxQ2FsZW5kYXIoKSwgcmVmZXJlbmNlSVNPWWVhclBhcmFtID0gMTk3Mikge1xuICAgICAgICBjb25zdCBpc29Nb250aCA9IFRvSW50ZWdlclRocm93T25JbmZpbml0eShpc29Nb250aFBhcmFtKTtcbiAgICAgICAgY29uc3QgaXNvRGF5ID0gVG9JbnRlZ2VyVGhyb3dPbkluZmluaXR5KGlzb0RheVBhcmFtKTtcbiAgICAgICAgY29uc3QgY2FsZW5kYXIgPSBUb1RlbXBvcmFsQ2FsZW5kYXIoY2FsZW5kYXJQYXJhbSk7XG4gICAgICAgIGNvbnN0IHJlZmVyZW5jZUlTT1llYXIgPSBUb0ludGVnZXJUaHJvd09uSW5maW5pdHkocmVmZXJlbmNlSVNPWWVhclBhcmFtKTtcbiAgICAgICAgLy8gTm90ZTogaWYgdGhlIGFyZ3VtZW50cyBhcmUgbm90IHBhc3NlZCxcbiAgICAgICAgLy8gICAgICAgVG9JbnRlZ2VyVGhyb3dPbkluZmluaXR5KHVuZGVmaW5lZCkgd2lsbCBoYXZlIHJldHVybmVkIDAsIHdoaWNoIHdpbGxcbiAgICAgICAgLy8gICAgICAgYmUgcmVqZWN0ZWQgYnkgUmVqZWN0SVNPRGF0ZSBpbiBDcmVhdGVUZW1wb3JhbE1vbnRoRGF5U2xvdHMuIFRoaXNcbiAgICAgICAgLy8gICAgICAgY2hlY2sgZXhpc3RzIG9ubHkgdG8gaW1wcm92ZSB0aGUgZXJyb3IgbWVzc2FnZS5cbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignbWlzc2luZyBhcmd1bWVudDogaXNvTW9udGggYW5kIGlzb0RheSBhcmUgcmVxdWlyZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBDcmVhdGVUZW1wb3JhbE1vbnRoRGF5U2xvdHModGhpcywgaXNvTW9udGgsIGlzb0RheSwgY2FsZW5kYXIsIHJlZmVyZW5jZUlTT1llYXIpO1xuICAgIH1cbiAgICBnZXQgbW9udGhDb2RlKCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxNb250aERheSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgcmV0dXJuIENhbGVuZGFyTW9udGhDb2RlKEdldFNsb3QodGhpcywgQ0FMRU5EQVIpLCB0aGlzKTtcbiAgICB9XG4gICAgZ2V0IGRheSgpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsTW9udGhEYXkodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIHJldHVybiBDYWxlbmRhckRheShHZXRTbG90KHRoaXMsIENBTEVOREFSKSwgdGhpcyk7XG4gICAgfVxuICAgIGdldCBjYWxlbmRhcigpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsTW9udGhEYXkodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIHJldHVybiBHZXRTbG90KHRoaXMsIENBTEVOREFSKTtcbiAgICB9XG4gICAgd2l0aCh0ZW1wb3JhbE1vbnRoRGF5TGlrZSwgb3B0aW9uc1BhcmFtID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbE1vbnRoRGF5KHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICBpZiAoIUlzT2JqZWN0KHRlbXBvcmFsTW9udGhEYXlMaWtlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBhcmd1bWVudCcpO1xuICAgICAgICB9XG4gICAgICAgIFJlamVjdE9iamVjdFdpdGhDYWxlbmRhck9yVGltZVpvbmUodGVtcG9yYWxNb250aERheUxpa2UpO1xuICAgICAgICBjb25zdCBjYWxlbmRhciA9IEdldFNsb3QodGhpcywgQ0FMRU5EQVIpO1xuICAgICAgICBjb25zdCBmaWVsZE5hbWVzID0gQ2FsZW5kYXJGaWVsZHMoY2FsZW5kYXIsIFsnZGF5JywgJ21vbnRoJywgJ21vbnRoQ29kZScsICd5ZWFyJ10pO1xuICAgICAgICBjb25zdCBwcm9wcyA9IFRvUGFydGlhbFJlY29yZCh0ZW1wb3JhbE1vbnRoRGF5TGlrZSwgZmllbGROYW1lcyk7XG4gICAgICAgIGlmICghcHJvcHMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgbW9udGgtZGF5LWxpa2UnKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZmllbGRzID0gVG9UZW1wb3JhbE1vbnRoRGF5RmllbGRzKHRoaXMsIGZpZWxkTmFtZXMpO1xuICAgICAgICBmaWVsZHMgPSBDYWxlbmRhck1lcmdlRmllbGRzKGNhbGVuZGFyLCBmaWVsZHMsIHByb3BzKTtcbiAgICAgICAgZmllbGRzID0gVG9UZW1wb3JhbE1vbnRoRGF5RmllbGRzKGZpZWxkcywgZmllbGROYW1lcyk7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSBHZXRPcHRpb25zT2JqZWN0KG9wdGlvbnNQYXJhbSk7XG4gICAgICAgIHJldHVybiBNb250aERheUZyb21GaWVsZHMoY2FsZW5kYXIsIGZpZWxkcywgb3B0aW9ucyk7XG4gICAgfVxuICAgIGVxdWFscyhvdGhlclBhcmFtKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbE1vbnRoRGF5KHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICBjb25zdCBvdGhlciA9IFRvVGVtcG9yYWxNb250aERheShvdGhlclBhcmFtKTtcbiAgICAgICAgZm9yIChjb25zdCBzbG90IG9mIFtJU09fTU9OVEgsIElTT19EQVksIElTT19ZRUFSXSkge1xuICAgICAgICAgICAgY29uc3QgdmFsMSA9IEdldFNsb3QodGhpcywgc2xvdCk7XG4gICAgICAgICAgICBjb25zdCB2YWwyID0gR2V0U2xvdChvdGhlciwgc2xvdCk7XG4gICAgICAgICAgICBpZiAodmFsMSAhPT0gdmFsMilcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIENhbGVuZGFyRXF1YWxzKEdldFNsb3QodGhpcywgQ0FMRU5EQVIpLCBHZXRTbG90KG90aGVyLCBDQUxFTkRBUikpO1xuICAgIH1cbiAgICB0b1N0cmluZyhvcHRpb25zUGFyYW0gPSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsTW9udGhEYXkodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSBHZXRPcHRpb25zT2JqZWN0KG9wdGlvbnNQYXJhbSk7XG4gICAgICAgIGNvbnN0IHNob3dDYWxlbmRhciA9IFRvU2hvd0NhbGVuZGFyT3B0aW9uKG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gVGVtcG9yYWxNb250aERheVRvU3RyaW5nKHRoaXMsIHNob3dDYWxlbmRhcik7XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsTW9udGhEYXkodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIHJldHVybiBUZW1wb3JhbE1vbnRoRGF5VG9TdHJpbmcodGhpcyk7XG4gICAgfVxuICAgIHRvTG9jYWxlU3RyaW5nKGxvY2FsZXMgPSB1bmRlZmluZWQsIG9wdGlvbnMgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsTW9udGhEYXkodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZVRpbWVGb3JtYXQobG9jYWxlcywgb3B0aW9ucykuZm9ybWF0KHRoaXMpO1xuICAgIH1cbiAgICB2YWx1ZU9mKCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd1c2UgZXF1YWxzKCkgdG8gY29tcGFyZSBUZW1wb3JhbC5QbGFpbk1vbnRoRGF5Jyk7XG4gICAgfVxuICAgIHRvUGxhaW5EYXRlKGl0ZW0pIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsTW9udGhEYXkodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIGlmICghSXNPYmplY3QoaXRlbSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdhcmd1bWVudCBzaG91bGQgYmUgYW4gb2JqZWN0Jyk7XG4gICAgICAgIGNvbnN0IGNhbGVuZGFyID0gR2V0U2xvdCh0aGlzLCBDQUxFTkRBUik7XG4gICAgICAgIGNvbnN0IHJlY2VpdmVyRmllbGROYW1lcyA9IENhbGVuZGFyRmllbGRzKGNhbGVuZGFyLCBbJ2RheScsICdtb250aENvZGUnXSk7XG4gICAgICAgIGNvbnN0IGZpZWxkcyA9IFRvVGVtcG9yYWxNb250aERheUZpZWxkcyh0aGlzLCByZWNlaXZlckZpZWxkTmFtZXMpO1xuICAgICAgICBjb25zdCBpbnB1dEZpZWxkTmFtZXMgPSBDYWxlbmRhckZpZWxkcyhjYWxlbmRhciwgWyd5ZWFyJ10pO1xuICAgICAgICBjb25zdCBpbnB1dEVudHJpZXMgPSBbWyd5ZWFyJywgdW5kZWZpbmVkXV07XG4gICAgICAgIC8vIEFkZCBleHRyYSBmaWVsZHMgZnJvbSB0aGUgY2FsZW5kYXIgYXQgdGhlIGVuZFxuICAgICAgICBpbnB1dEZpZWxkTmFtZXMuZm9yRWFjaCgoZmllbGROYW1lKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWlucHV0RW50cmllcy5zb21lKChbbmFtZV0pID0+IG5hbWUgPT09IGZpZWxkTmFtZSkpIHtcbiAgICAgICAgICAgICAgICBpbnB1dEVudHJpZXMucHVzaChbZmllbGROYW1lLCB1bmRlZmluZWRdKTsgLy8gTWFrZSBUUyBpZ25vcmUgZXh0cmEgZmllbGRzXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBpbnB1dEZpZWxkcyA9IFByZXBhcmVUZW1wb3JhbEZpZWxkcyhpdGVtLCBpbnB1dEVudHJpZXMpO1xuICAgICAgICBsZXQgbWVyZ2VkRmllbGRzID0gQ2FsZW5kYXJNZXJnZUZpZWxkcyhjYWxlbmRhciwgZmllbGRzLCBpbnB1dEZpZWxkcyk7XG4gICAgICAgIGNvbnN0IG1lcmdlZEZpZWxkTmFtZXMgPSBbLi4ubmV3IFNldChbLi4ucmVjZWl2ZXJGaWVsZE5hbWVzLCAuLi5pbnB1dEZpZWxkTmFtZXNdKV07XG4gICAgICAgIGNvbnN0IG1lcmdlZEVudHJpZXMgPSBbXTtcbiAgICAgICAgbWVyZ2VkRmllbGROYW1lcy5mb3JFYWNoKChmaWVsZE5hbWUpID0+IHtcbiAgICAgICAgICAgIGlmICghbWVyZ2VkRW50cmllcy5zb21lKChbbmFtZV0pID0+IG5hbWUgPT09IGZpZWxkTmFtZSkpIHtcbiAgICAgICAgICAgICAgICBtZXJnZWRFbnRyaWVzLnB1c2goW2ZpZWxkTmFtZSwgdW5kZWZpbmVkXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBtZXJnZWRGaWVsZHMgPSBQcmVwYXJlVGVtcG9yYWxGaWVsZHMobWVyZ2VkRmllbGRzLCBtZXJnZWRFbnRyaWVzKTtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IE9iamVjdENyZWF0ZSQxKG51bGwpO1xuICAgICAgICBvcHRpb25zLm92ZXJmbG93ID0gJ3JlamVjdCc7XG4gICAgICAgIHJldHVybiBEYXRlRnJvbUZpZWxkcyhjYWxlbmRhciwgbWVyZ2VkRmllbGRzLCBvcHRpb25zKTtcbiAgICB9XG4gICAgZ2V0SVNPRmllbGRzKCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxNb250aERheSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNhbGVuZGFyOiBHZXRTbG90KHRoaXMsIENBTEVOREFSKSxcbiAgICAgICAgICAgIGlzb0RheTogR2V0U2xvdCh0aGlzLCBJU09fREFZKSxcbiAgICAgICAgICAgIGlzb01vbnRoOiBHZXRTbG90KHRoaXMsIElTT19NT05USCksXG4gICAgICAgICAgICBpc29ZZWFyOiBHZXRTbG90KHRoaXMsIElTT19ZRUFSKVxuICAgICAgICB9O1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbShpdGVtLCBvcHRpb25zUGFyYW0gPSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IEdldE9wdGlvbnNPYmplY3Qob3B0aW9uc1BhcmFtKTtcbiAgICAgICAgaWYgKElzVGVtcG9yYWxNb250aERheShpdGVtKSkge1xuICAgICAgICAgICAgVG9UZW1wb3JhbE92ZXJmbG93KG9wdGlvbnMpOyAvLyB2YWxpZGF0ZSBhbmQgaWdub3JlXG4gICAgICAgICAgICByZXR1cm4gQ3JlYXRlVGVtcG9yYWxNb250aERheShHZXRTbG90KGl0ZW0sIElTT19NT05USCksIEdldFNsb3QoaXRlbSwgSVNPX0RBWSksIEdldFNsb3QoaXRlbSwgQ0FMRU5EQVIpLCBHZXRTbG90KGl0ZW0sIElTT19ZRUFSKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFRvVGVtcG9yYWxNb250aERheShpdGVtLCBvcHRpb25zKTtcbiAgICB9XG59XG5NYWtlSW50cmluc2ljQ2xhc3MoUGxhaW5Nb250aERheSwgJ1RlbXBvcmFsLlBsYWluTW9udGhEYXknKTtcblxuY29uc3QgaW5zdGFudCA9ICgpID0+IHtcbiAgICBjb25zdCBJbnN0YW50ID0gR2V0SW50cmluc2ljKCclVGVtcG9yYWwuSW5zdGFudCUnKTtcbiAgICByZXR1cm4gbmV3IEluc3RhbnQoU3lzdGVtVVRDRXBvY2hOYW5vU2Vjb25kcygpKTtcbn07XG5jb25zdCBwbGFpbkRhdGVUaW1lID0gKGNhbGVuZGFyTGlrZSwgdGVtcG9yYWxUaW1lWm9uZUxpa2UgPSB0aW1lWm9uZSgpKSA9PiB7XG4gICAgY29uc3QgdFogPSBUb1RlbXBvcmFsVGltZVpvbmUodGVtcG9yYWxUaW1lWm9uZUxpa2UpO1xuICAgIGNvbnN0IGNhbGVuZGFyID0gVG9UZW1wb3JhbENhbGVuZGFyKGNhbGVuZGFyTGlrZSk7XG4gICAgY29uc3QgaW5zdCA9IGluc3RhbnQoKTtcbiAgICByZXR1cm4gQnVpbHRpblRpbWVab25lR2V0UGxhaW5EYXRlVGltZUZvcih0WiwgaW5zdCwgY2FsZW5kYXIpO1xufTtcbmNvbnN0IHBsYWluRGF0ZVRpbWVJU08gPSAodGVtcG9yYWxUaW1lWm9uZUxpa2UgPSB0aW1lWm9uZSgpKSA9PiB7XG4gICAgY29uc3QgdFogPSBUb1RlbXBvcmFsVGltZVpvbmUodGVtcG9yYWxUaW1lWm9uZUxpa2UpO1xuICAgIGNvbnN0IGNhbGVuZGFyID0gR2V0SVNPODYwMUNhbGVuZGFyKCk7XG4gICAgY29uc3QgaW5zdCA9IGluc3RhbnQoKTtcbiAgICByZXR1cm4gQnVpbHRpblRpbWVab25lR2V0UGxhaW5EYXRlVGltZUZvcih0WiwgaW5zdCwgY2FsZW5kYXIpO1xufTtcbmNvbnN0IHpvbmVkRGF0ZVRpbWUgPSAoY2FsZW5kYXJMaWtlLCB0ZW1wb3JhbFRpbWVab25lTGlrZSA9IHRpbWVab25lKCkpID0+IHtcbiAgICBjb25zdCB0WiA9IFRvVGVtcG9yYWxUaW1lWm9uZSh0ZW1wb3JhbFRpbWVab25lTGlrZSk7XG4gICAgY29uc3QgY2FsZW5kYXIgPSBUb1RlbXBvcmFsQ2FsZW5kYXIoY2FsZW5kYXJMaWtlKTtcbiAgICByZXR1cm4gQ3JlYXRlVGVtcG9yYWxab25lZERhdGVUaW1lKFN5c3RlbVVUQ0Vwb2NoTmFub1NlY29uZHMoKSwgdFosIGNhbGVuZGFyKTtcbn07XG5jb25zdCB6b25lZERhdGVUaW1lSVNPID0gKHRlbXBvcmFsVGltZVpvbmVMaWtlID0gdGltZVpvbmUoKSkgPT4ge1xuICAgIHJldHVybiB6b25lZERhdGVUaW1lKEdldElTTzg2MDFDYWxlbmRhcigpLCB0ZW1wb3JhbFRpbWVab25lTGlrZSk7XG59O1xuY29uc3QgcGxhaW5EYXRlID0gKGNhbGVuZGFyTGlrZSwgdGVtcG9yYWxUaW1lWm9uZUxpa2UgPSB0aW1lWm9uZSgpKSA9PiB7XG4gICAgcmV0dXJuIFRlbXBvcmFsRGF0ZVRpbWVUb0RhdGUocGxhaW5EYXRlVGltZShjYWxlbmRhckxpa2UsIHRlbXBvcmFsVGltZVpvbmVMaWtlKSk7XG59O1xuY29uc3QgcGxhaW5EYXRlSVNPID0gKHRlbXBvcmFsVGltZVpvbmVMaWtlID0gdGltZVpvbmUoKSkgPT4ge1xuICAgIHJldHVybiBUZW1wb3JhbERhdGVUaW1lVG9EYXRlKHBsYWluRGF0ZVRpbWVJU08odGVtcG9yYWxUaW1lWm9uZUxpa2UpKTtcbn07XG5jb25zdCBwbGFpblRpbWVJU08gPSAodGVtcG9yYWxUaW1lWm9uZUxpa2UgPSB0aW1lWm9uZSgpKSA9PiB7XG4gICAgcmV0dXJuIFRlbXBvcmFsRGF0ZVRpbWVUb1RpbWUocGxhaW5EYXRlVGltZUlTTyh0ZW1wb3JhbFRpbWVab25lTGlrZSkpO1xufTtcbmNvbnN0IHRpbWVab25lID0gKCkgPT4ge1xuICAgIHJldHVybiBTeXN0ZW1UaW1lWm9uZSgpO1xufTtcbmNvbnN0IE5vdyA9IHtcbiAgICBpbnN0YW50LFxuICAgIHBsYWluRGF0ZVRpbWUsXG4gICAgcGxhaW5EYXRlVGltZUlTTyxcbiAgICBwbGFpbkRhdGUsXG4gICAgcGxhaW5EYXRlSVNPLFxuICAgIHBsYWluVGltZUlTTyxcbiAgICB0aW1lWm9uZSxcbiAgICB6b25lZERhdGVUaW1lLFxuICAgIHpvbmVkRGF0ZVRpbWVJU08sXG4gICAgW1N5bWJvbC50b1N0cmluZ1RhZ106ICdUZW1wb3JhbC5Ob3cnXG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KE5vdywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7XG4gICAgdmFsdWU6ICdUZW1wb3JhbC5Ob3cnLFxuICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbn0pO1xuXG5jb25zdCBPYmplY3RBc3NpZ24gPSBPYmplY3QuYXNzaWduO1xuY29uc3QgRElTQUxMT1dFRF9VTklUUyQxID0gWyd5ZWFyJywgJ21vbnRoJywgJ3dlZWsnLCAnZGF5J107XG5jb25zdCBNQVhfSU5DUkVNRU5UUyA9IHtcbiAgICBob3VyOiAyNCxcbiAgICBtaW51dGU6IDYwLFxuICAgIHNlY29uZDogNjAsXG4gICAgbWlsbGlzZWNvbmQ6IDEwMDAsXG4gICAgbWljcm9zZWNvbmQ6IDEwMDAsXG4gICAgbmFub3NlY29uZDogMTAwMFxufTtcbmZ1bmN0aW9uIFRlbXBvcmFsVGltZVRvU3RyaW5nKHRpbWUsIHByZWNpc2lvbiwgb3B0aW9ucyA9IHVuZGVmaW5lZCkge1xuICAgIGxldCBob3VyID0gR2V0U2xvdCh0aW1lLCBJU09fSE9VUik7XG4gICAgbGV0IG1pbnV0ZSA9IEdldFNsb3QodGltZSwgSVNPX01JTlVURSk7XG4gICAgbGV0IHNlY29uZCA9IEdldFNsb3QodGltZSwgSVNPX1NFQ09ORCk7XG4gICAgbGV0IG1pbGxpc2Vjb25kID0gR2V0U2xvdCh0aW1lLCBJU09fTUlMTElTRUNPTkQpO1xuICAgIGxldCBtaWNyb3NlY29uZCA9IEdldFNsb3QodGltZSwgSVNPX01JQ1JPU0VDT05EKTtcbiAgICBsZXQgbmFub3NlY29uZCA9IEdldFNsb3QodGltZSwgSVNPX05BTk9TRUNPTkQpO1xuICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHsgdW5pdCwgaW5jcmVtZW50LCByb3VuZGluZ01vZGUgfSA9IG9wdGlvbnM7XG4gICAgICAgICh7IGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZCwgbWljcm9zZWNvbmQsIG5hbm9zZWNvbmQgfSA9IFJvdW5kVGltZShob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQsIG1pY3Jvc2Vjb25kLCBuYW5vc2Vjb25kLCBpbmNyZW1lbnQsIHVuaXQsIHJvdW5kaW5nTW9kZSkpO1xuICAgIH1cbiAgICBjb25zdCBob3VyU3RyaW5nID0gSVNPRGF0ZVRpbWVQYXJ0U3RyaW5nKGhvdXIpO1xuICAgIGNvbnN0IG1pbnV0ZVN0cmluZyA9IElTT0RhdGVUaW1lUGFydFN0cmluZyhtaW51dGUpO1xuICAgIGNvbnN0IHNlY29uZHMgPSBGb3JtYXRTZWNvbmRzU3RyaW5nUGFydChzZWNvbmQsIG1pbGxpc2Vjb25kLCBtaWNyb3NlY29uZCwgbmFub3NlY29uZCwgcHJlY2lzaW9uKTtcbiAgICByZXR1cm4gYCR7aG91clN0cmluZ306JHttaW51dGVTdHJpbmd9JHtzZWNvbmRzfWA7XG59XG5jbGFzcyBQbGFpblRpbWUge1xuICAgIGNvbnN0cnVjdG9yKGlzb0hvdXJQYXJhbSA9IDAsIGlzb01pbnV0ZVBhcmFtID0gMCwgaXNvU2Vjb25kUGFyYW0gPSAwLCBpc29NaWxsaXNlY29uZFBhcmFtID0gMCwgaXNvTWljcm9zZWNvbmRQYXJhbSA9IDAsIGlzb05hbm9zZWNvbmRQYXJhbSA9IDApIHtcbiAgICAgICAgY29uc3QgaXNvSG91ciA9IFRvSW50ZWdlclRocm93T25JbmZpbml0eShpc29Ib3VyUGFyYW0pO1xuICAgICAgICBjb25zdCBpc29NaW51dGUgPSBUb0ludGVnZXJUaHJvd09uSW5maW5pdHkoaXNvTWludXRlUGFyYW0pO1xuICAgICAgICBjb25zdCBpc29TZWNvbmQgPSBUb0ludGVnZXJUaHJvd09uSW5maW5pdHkoaXNvU2Vjb25kUGFyYW0pO1xuICAgICAgICBjb25zdCBpc29NaWxsaXNlY29uZCA9IFRvSW50ZWdlclRocm93T25JbmZpbml0eShpc29NaWxsaXNlY29uZFBhcmFtKTtcbiAgICAgICAgY29uc3QgaXNvTWljcm9zZWNvbmQgPSBUb0ludGVnZXJUaHJvd09uSW5maW5pdHkoaXNvTWljcm9zZWNvbmRQYXJhbSk7XG4gICAgICAgIGNvbnN0IGlzb05hbm9zZWNvbmQgPSBUb0ludGVnZXJUaHJvd09uSW5maW5pdHkoaXNvTmFub3NlY29uZFBhcmFtKTtcbiAgICAgICAgUmVqZWN0VGltZShpc29Ib3VyLCBpc29NaW51dGUsIGlzb1NlY29uZCwgaXNvTWlsbGlzZWNvbmQsIGlzb01pY3Jvc2Vjb25kLCBpc29OYW5vc2Vjb25kKTtcbiAgICAgICAgQ3JlYXRlU2xvdHModGhpcyk7XG4gICAgICAgIFNldFNsb3QodGhpcywgSVNPX0hPVVIsIGlzb0hvdXIpO1xuICAgICAgICBTZXRTbG90KHRoaXMsIElTT19NSU5VVEUsIGlzb01pbnV0ZSk7XG4gICAgICAgIFNldFNsb3QodGhpcywgSVNPX1NFQ09ORCwgaXNvU2Vjb25kKTtcbiAgICAgICAgU2V0U2xvdCh0aGlzLCBJU09fTUlMTElTRUNPTkQsIGlzb01pbGxpc2Vjb25kKTtcbiAgICAgICAgU2V0U2xvdCh0aGlzLCBJU09fTUlDUk9TRUNPTkQsIGlzb01pY3Jvc2Vjb25kKTtcbiAgICAgICAgU2V0U2xvdCh0aGlzLCBJU09fTkFOT1NFQ09ORCwgaXNvTmFub3NlY29uZCk7XG4gICAgICAgIFNldFNsb3QodGhpcywgQ0FMRU5EQVIsIEdldElTTzg2MDFDYWxlbmRhcigpKTtcbiAgICAgICAge1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdfcmVwcl8nLCB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IGAke3RoaXNbU3ltYm9sLnRvU3RyaW5nVGFnXX0gPCR7VGVtcG9yYWxUaW1lVG9TdHJpbmcodGhpcywgJ2F1dG8nKX0+YCxcbiAgICAgICAgICAgICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGNhbGVuZGFyKCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxUaW1lKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICAvLyBQbGFpblRpbWUncyBjYWxlbmRhciBpc24ndCBzZXR0YWJsZSwgc28gY2FuJ3QgYmUgYSB1c2VybGFuZCBjYWxlbmRhclxuICAgICAgICByZXR1cm4gR2V0U2xvdCh0aGlzLCBDQUxFTkRBUik7XG4gICAgfVxuICAgIGdldCBob3VyKCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxUaW1lKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICByZXR1cm4gR2V0U2xvdCh0aGlzLCBJU09fSE9VUik7XG4gICAgfVxuICAgIGdldCBtaW51dGUoKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbFRpbWUodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIHJldHVybiBHZXRTbG90KHRoaXMsIElTT19NSU5VVEUpO1xuICAgIH1cbiAgICBnZXQgc2Vjb25kKCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxUaW1lKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICByZXR1cm4gR2V0U2xvdCh0aGlzLCBJU09fU0VDT05EKTtcbiAgICB9XG4gICAgZ2V0IG1pbGxpc2Vjb25kKCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxUaW1lKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICByZXR1cm4gR2V0U2xvdCh0aGlzLCBJU09fTUlMTElTRUNPTkQpO1xuICAgIH1cbiAgICBnZXQgbWljcm9zZWNvbmQoKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbFRpbWUodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIHJldHVybiBHZXRTbG90KHRoaXMsIElTT19NSUNST1NFQ09ORCk7XG4gICAgfVxuICAgIGdldCBuYW5vc2Vjb25kKCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxUaW1lKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICByZXR1cm4gR2V0U2xvdCh0aGlzLCBJU09fTkFOT1NFQ09ORCk7XG4gICAgfVxuICAgIHdpdGgodGVtcG9yYWxUaW1lTGlrZSwgb3B0aW9uc1BhcmFtID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbFRpbWUodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIGlmICghSXNPYmplY3QodGVtcG9yYWxUaW1lTGlrZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgYXJndW1lbnQnKTtcbiAgICAgICAgfVxuICAgICAgICBSZWplY3RPYmplY3RXaXRoQ2FsZW5kYXJPclRpbWVab25lKHRlbXBvcmFsVGltZUxpa2UpO1xuICAgICAgICBjb25zdCBvcHRpb25zID0gR2V0T3B0aW9uc09iamVjdChvcHRpb25zUGFyYW0pO1xuICAgICAgICBjb25zdCBvdmVyZmxvdyA9IFRvVGVtcG9yYWxPdmVyZmxvdyhvcHRpb25zKTtcbiAgICAgICAgY29uc3QgcHJvcHMgPSBUb1BhcnRpYWxSZWNvcmQodGVtcG9yYWxUaW1lTGlrZSwgW1xuICAgICAgICAgICAgJ2hvdXInLFxuICAgICAgICAgICAgJ21pY3Jvc2Vjb25kJyxcbiAgICAgICAgICAgICdtaWxsaXNlY29uZCcsXG4gICAgICAgICAgICAnbWludXRlJyxcbiAgICAgICAgICAgICduYW5vc2Vjb25kJyxcbiAgICAgICAgICAgICdzZWNvbmQnXG4gICAgICAgIF0pO1xuICAgICAgICBpZiAoIXByb3BzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHRpbWUtbGlrZScpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZpZWxkcyA9IFRvVGVtcG9yYWxUaW1lUmVjb3JkKHRoaXMpO1xuICAgICAgICBsZXQgeyBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQsIG1pY3Jvc2Vjb25kLCBuYW5vc2Vjb25kIH0gPSBPYmplY3RBc3NpZ24oZmllbGRzLCBwcm9wcyk7XG4gICAgICAgICh7IGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZCwgbWljcm9zZWNvbmQsIG5hbm9zZWNvbmQgfSA9IFJlZ3VsYXRlVGltZShob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQsIG1pY3Jvc2Vjb25kLCBuYW5vc2Vjb25kLCBvdmVyZmxvdykpO1xuICAgICAgICByZXR1cm4gbmV3IFBsYWluVGltZShob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQsIG1pY3Jvc2Vjb25kLCBuYW5vc2Vjb25kKTtcbiAgICB9XG4gICAgYWRkKHRlbXBvcmFsRHVyYXRpb25MaWtlKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbFRpbWUodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIGNvbnN0IGR1cmF0aW9uID0gVG9MaW1pdGVkVGVtcG9yYWxEdXJhdGlvbih0ZW1wb3JhbER1cmF0aW9uTGlrZSk7XG4gICAgICAgIGNvbnN0IHsgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc2Vjb25kcywgbWljcm9zZWNvbmRzLCBuYW5vc2Vjb25kcyB9ID0gZHVyYXRpb247XG4gICAgICAgIGxldCBob3VyID0gR2V0U2xvdCh0aGlzLCBJU09fSE9VUik7XG4gICAgICAgIGxldCBtaW51dGUgPSBHZXRTbG90KHRoaXMsIElTT19NSU5VVEUpO1xuICAgICAgICBsZXQgc2Vjb25kID0gR2V0U2xvdCh0aGlzLCBJU09fU0VDT05EKTtcbiAgICAgICAgbGV0IG1pbGxpc2Vjb25kID0gR2V0U2xvdCh0aGlzLCBJU09fTUlMTElTRUNPTkQpO1xuICAgICAgICBsZXQgbWljcm9zZWNvbmQgPSBHZXRTbG90KHRoaXMsIElTT19NSUNST1NFQ09ORCk7XG4gICAgICAgIGxldCBuYW5vc2Vjb25kID0gR2V0U2xvdCh0aGlzLCBJU09fTkFOT1NFQ09ORCk7XG4gICAgICAgICh7IGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZCwgbWljcm9zZWNvbmQsIG5hbm9zZWNvbmQgfSA9IEFkZFRpbWUoaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kLCBtaWNyb3NlY29uZCwgbmFub3NlY29uZCwgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc2Vjb25kcywgbWljcm9zZWNvbmRzLCBuYW5vc2Vjb25kcykpO1xuICAgICAgICAoeyBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQsIG1pY3Jvc2Vjb25kLCBuYW5vc2Vjb25kIH0gPSBSZWd1bGF0ZVRpbWUoaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kLCBtaWNyb3NlY29uZCwgbmFub3NlY29uZCwgJ3JlamVjdCcpKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQbGFpblRpbWUoaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kLCBtaWNyb3NlY29uZCwgbmFub3NlY29uZCk7XG4gICAgfVxuICAgIHN1YnRyYWN0KHRlbXBvcmFsRHVyYXRpb25MaWtlKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbFRpbWUodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIGNvbnN0IGR1cmF0aW9uID0gVG9MaW1pdGVkVGVtcG9yYWxEdXJhdGlvbih0ZW1wb3JhbER1cmF0aW9uTGlrZSk7XG4gICAgICAgIGNvbnN0IHsgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc2Vjb25kcywgbWljcm9zZWNvbmRzLCBuYW5vc2Vjb25kcyB9ID0gZHVyYXRpb247XG4gICAgICAgIGxldCBob3VyID0gR2V0U2xvdCh0aGlzLCBJU09fSE9VUik7XG4gICAgICAgIGxldCBtaW51dGUgPSBHZXRTbG90KHRoaXMsIElTT19NSU5VVEUpO1xuICAgICAgICBsZXQgc2Vjb25kID0gR2V0U2xvdCh0aGlzLCBJU09fU0VDT05EKTtcbiAgICAgICAgbGV0IG1pbGxpc2Vjb25kID0gR2V0U2xvdCh0aGlzLCBJU09fTUlMTElTRUNPTkQpO1xuICAgICAgICBsZXQgbWljcm9zZWNvbmQgPSBHZXRTbG90KHRoaXMsIElTT19NSUNST1NFQ09ORCk7XG4gICAgICAgIGxldCBuYW5vc2Vjb25kID0gR2V0U2xvdCh0aGlzLCBJU09fTkFOT1NFQ09ORCk7XG4gICAgICAgICh7IGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZCwgbWljcm9zZWNvbmQsIG5hbm9zZWNvbmQgfSA9IEFkZFRpbWUoaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kLCBtaWNyb3NlY29uZCwgbmFub3NlY29uZCwgLWhvdXJzLCAtbWludXRlcywgLXNlY29uZHMsIC1taWxsaXNlY29uZHMsIC1taWNyb3NlY29uZHMsIC1uYW5vc2Vjb25kcykpO1xuICAgICAgICAoeyBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQsIG1pY3Jvc2Vjb25kLCBuYW5vc2Vjb25kIH0gPSBSZWd1bGF0ZVRpbWUoaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kLCBtaWNyb3NlY29uZCwgbmFub3NlY29uZCwgJ3JlamVjdCcpKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQbGFpblRpbWUoaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kLCBtaWNyb3NlY29uZCwgbmFub3NlY29uZCk7XG4gICAgfVxuICAgIHVudGlsKG90aGVyUGFyYW0sIG9wdGlvbnNQYXJhbSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxUaW1lKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICBjb25zdCBvdGhlciA9IFRvVGVtcG9yYWxUaW1lKG90aGVyUGFyYW0pO1xuICAgICAgICBjb25zdCBvcHRpb25zID0gR2V0T3B0aW9uc09iamVjdChvcHRpb25zUGFyYW0pO1xuICAgICAgICBjb25zdCBsYXJnZXN0VW5pdCA9IFRvTGFyZ2VzdFRlbXBvcmFsVW5pdChvcHRpb25zLCAnYXV0bycsIERJU0FMTE9XRURfVU5JVFMkMSwgJ2hvdXInKTtcbiAgICAgICAgY29uc3Qgc21hbGxlc3RVbml0ID0gVG9TbWFsbGVzdFRlbXBvcmFsVW5pdChvcHRpb25zLCAnbmFub3NlY29uZCcsIERJU0FMTE9XRURfVU5JVFMkMSk7XG4gICAgICAgIFZhbGlkYXRlVGVtcG9yYWxVbml0UmFuZ2UobGFyZ2VzdFVuaXQsIHNtYWxsZXN0VW5pdCk7XG4gICAgICAgIGNvbnN0IHJvdW5kaW5nTW9kZSA9IFRvVGVtcG9yYWxSb3VuZGluZ01vZGUob3B0aW9ucywgJ3RydW5jJyk7XG4gICAgICAgIGNvbnN0IHJvdW5kaW5nSW5jcmVtZW50ID0gVG9UZW1wb3JhbFJvdW5kaW5nSW5jcmVtZW50KG9wdGlvbnMsIE1BWF9JTkNSRU1FTlRTW3NtYWxsZXN0VW5pdF0sIGZhbHNlKTtcbiAgICAgICAgbGV0IHsgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc2Vjb25kcywgbWljcm9zZWNvbmRzLCBuYW5vc2Vjb25kcyB9ID0gRGlmZmVyZW5jZVRpbWUoR2V0U2xvdCh0aGlzLCBJU09fSE9VUiksIEdldFNsb3QodGhpcywgSVNPX01JTlVURSksIEdldFNsb3QodGhpcywgSVNPX1NFQ09ORCksIEdldFNsb3QodGhpcywgSVNPX01JTExJU0VDT05EKSwgR2V0U2xvdCh0aGlzLCBJU09fTUlDUk9TRUNPTkQpLCBHZXRTbG90KHRoaXMsIElTT19OQU5PU0VDT05EKSwgR2V0U2xvdChvdGhlciwgSVNPX0hPVVIpLCBHZXRTbG90KG90aGVyLCBJU09fTUlOVVRFKSwgR2V0U2xvdChvdGhlciwgSVNPX1NFQ09ORCksIEdldFNsb3Qob3RoZXIsIElTT19NSUxMSVNFQ09ORCksIEdldFNsb3Qob3RoZXIsIElTT19NSUNST1NFQ09ORCksIEdldFNsb3Qob3RoZXIsIElTT19OQU5PU0VDT05EKSk7XG4gICAgICAgICh7IGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBtaWxsaXNlY29uZHMsIG1pY3Jvc2Vjb25kcywgbmFub3NlY29uZHMgfSA9IFJvdW5kRHVyYXRpb24oMCwgMCwgMCwgMCwgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc2Vjb25kcywgbWljcm9zZWNvbmRzLCBuYW5vc2Vjb25kcywgcm91bmRpbmdJbmNyZW1lbnQsIHNtYWxsZXN0VW5pdCwgcm91bmRpbmdNb2RlKSk7XG4gICAgICAgICh7IGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBtaWxsaXNlY29uZHMsIG1pY3Jvc2Vjb25kcywgbmFub3NlY29uZHMgfSA9IEJhbGFuY2VEdXJhdGlvbigwLCBob3VycywgbWludXRlcywgc2Vjb25kcywgbWlsbGlzZWNvbmRzLCBtaWNyb3NlY29uZHMsIG5hbm9zZWNvbmRzLCBsYXJnZXN0VW5pdCkpO1xuICAgICAgICBjb25zdCBEdXJhdGlvbiA9IEdldEludHJpbnNpYygnJVRlbXBvcmFsLkR1cmF0aW9uJScpO1xuICAgICAgICByZXR1cm4gbmV3IER1cmF0aW9uKDAsIDAsIDAsIDAsIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBtaWxsaXNlY29uZHMsIG1pY3Jvc2Vjb25kcywgbmFub3NlY29uZHMpO1xuICAgIH1cbiAgICBzaW5jZShvdGhlclBhcmFtLCBvcHRpb25zUGFyYW0gPSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsVGltZSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgY29uc3Qgb3RoZXIgPSBUb1RlbXBvcmFsVGltZShvdGhlclBhcmFtKTtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IEdldE9wdGlvbnNPYmplY3Qob3B0aW9uc1BhcmFtKTtcbiAgICAgICAgY29uc3QgbGFyZ2VzdFVuaXQgPSBUb0xhcmdlc3RUZW1wb3JhbFVuaXQob3B0aW9ucywgJ2F1dG8nLCBESVNBTExPV0VEX1VOSVRTJDEsICdob3VyJyk7XG4gICAgICAgIGNvbnN0IHNtYWxsZXN0VW5pdCA9IFRvU21hbGxlc3RUZW1wb3JhbFVuaXQob3B0aW9ucywgJ25hbm9zZWNvbmQnLCBESVNBTExPV0VEX1VOSVRTJDEpO1xuICAgICAgICBWYWxpZGF0ZVRlbXBvcmFsVW5pdFJhbmdlKGxhcmdlc3RVbml0LCBzbWFsbGVzdFVuaXQpO1xuICAgICAgICBjb25zdCByb3VuZGluZ01vZGUgPSBUb1RlbXBvcmFsUm91bmRpbmdNb2RlKG9wdGlvbnMsICd0cnVuYycpO1xuICAgICAgICBjb25zdCByb3VuZGluZ0luY3JlbWVudCA9IFRvVGVtcG9yYWxSb3VuZGluZ0luY3JlbWVudChvcHRpb25zLCBNQVhfSU5DUkVNRU5UU1tzbWFsbGVzdFVuaXRdLCBmYWxzZSk7XG4gICAgICAgIGxldCB7IGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBtaWxsaXNlY29uZHMsIG1pY3Jvc2Vjb25kcywgbmFub3NlY29uZHMgfSA9IERpZmZlcmVuY2VUaW1lKEdldFNsb3Qob3RoZXIsIElTT19IT1VSKSwgR2V0U2xvdChvdGhlciwgSVNPX01JTlVURSksIEdldFNsb3Qob3RoZXIsIElTT19TRUNPTkQpLCBHZXRTbG90KG90aGVyLCBJU09fTUlMTElTRUNPTkQpLCBHZXRTbG90KG90aGVyLCBJU09fTUlDUk9TRUNPTkQpLCBHZXRTbG90KG90aGVyLCBJU09fTkFOT1NFQ09ORCksIEdldFNsb3QodGhpcywgSVNPX0hPVVIpLCBHZXRTbG90KHRoaXMsIElTT19NSU5VVEUpLCBHZXRTbG90KHRoaXMsIElTT19TRUNPTkQpLCBHZXRTbG90KHRoaXMsIElTT19NSUxMSVNFQ09ORCksIEdldFNsb3QodGhpcywgSVNPX01JQ1JPU0VDT05EKSwgR2V0U2xvdCh0aGlzLCBJU09fTkFOT1NFQ09ORCkpO1xuICAgICAgICAoeyBob3VycywgbWludXRlcywgc2Vjb25kcywgbWlsbGlzZWNvbmRzLCBtaWNyb3NlY29uZHMsIG5hbm9zZWNvbmRzIH0gPSBSb3VuZER1cmF0aW9uKDAsIDAsIDAsIDAsIC1ob3VycywgLW1pbnV0ZXMsIC1zZWNvbmRzLCAtbWlsbGlzZWNvbmRzLCAtbWljcm9zZWNvbmRzLCAtbmFub3NlY29uZHMsIHJvdW5kaW5nSW5jcmVtZW50LCBzbWFsbGVzdFVuaXQsIE5lZ2F0ZVRlbXBvcmFsUm91bmRpbmdNb2RlKHJvdW5kaW5nTW9kZSkpKTtcbiAgICAgICAgaG91cnMgPSAtaG91cnM7XG4gICAgICAgIG1pbnV0ZXMgPSAtbWludXRlcztcbiAgICAgICAgc2Vjb25kcyA9IC1zZWNvbmRzO1xuICAgICAgICBtaWxsaXNlY29uZHMgPSAtbWlsbGlzZWNvbmRzO1xuICAgICAgICBtaWNyb3NlY29uZHMgPSAtbWljcm9zZWNvbmRzO1xuICAgICAgICBuYW5vc2Vjb25kcyA9IC1uYW5vc2Vjb25kcztcbiAgICAgICAgKHsgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc2Vjb25kcywgbWljcm9zZWNvbmRzLCBuYW5vc2Vjb25kcyB9ID0gQmFsYW5jZUR1cmF0aW9uKDAsIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBtaWxsaXNlY29uZHMsIG1pY3Jvc2Vjb25kcywgbmFub3NlY29uZHMsIGxhcmdlc3RVbml0KSk7XG4gICAgICAgIGNvbnN0IER1cmF0aW9uID0gR2V0SW50cmluc2ljKCclVGVtcG9yYWwuRHVyYXRpb24lJyk7XG4gICAgICAgIHJldHVybiBuZXcgRHVyYXRpb24oMCwgMCwgMCwgMCwgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc2Vjb25kcywgbWljcm9zZWNvbmRzLCBuYW5vc2Vjb25kcyk7XG4gICAgfVxuICAgIHJvdW5kKG9wdGlvbnNQYXJhbSkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxUaW1lKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICBpZiAob3B0aW9uc1BhcmFtID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdvcHRpb25zIHBhcmFtZXRlciBpcyByZXF1aXJlZCcpO1xuICAgICAgICBjb25zdCBvcHRpb25zID0gdHlwZW9mIG9wdGlvbnNQYXJhbSA9PT0gJ3N0cmluZydcbiAgICAgICAgICAgID8gQ3JlYXRlT25lUHJvcE9iamVjdCgnc21hbGxlc3RVbml0Jywgb3B0aW9uc1BhcmFtKVxuICAgICAgICAgICAgOiBHZXRPcHRpb25zT2JqZWN0KG9wdGlvbnNQYXJhbSk7XG4gICAgICAgIGNvbnN0IHNtYWxsZXN0VW5pdCA9IFRvU21hbGxlc3RUZW1wb3JhbFVuaXQob3B0aW9ucywgdW5kZWZpbmVkLCBESVNBTExPV0VEX1VOSVRTJDEpO1xuICAgICAgICBpZiAoc21hbGxlc3RVbml0ID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc21hbGxlc3RVbml0IGlzIHJlcXVpcmVkJyk7XG4gICAgICAgIGNvbnN0IHJvdW5kaW5nTW9kZSA9IFRvVGVtcG9yYWxSb3VuZGluZ01vZGUob3B0aW9ucywgJ2hhbGZFeHBhbmQnKTtcbiAgICAgICAgY29uc3Qgcm91bmRpbmdJbmNyZW1lbnQgPSBUb1RlbXBvcmFsUm91bmRpbmdJbmNyZW1lbnQob3B0aW9ucywgTUFYX0lOQ1JFTUVOVFNbc21hbGxlc3RVbml0XSwgZmFsc2UpO1xuICAgICAgICBsZXQgaG91ciA9IEdldFNsb3QodGhpcywgSVNPX0hPVVIpO1xuICAgICAgICBsZXQgbWludXRlID0gR2V0U2xvdCh0aGlzLCBJU09fTUlOVVRFKTtcbiAgICAgICAgbGV0IHNlY29uZCA9IEdldFNsb3QodGhpcywgSVNPX1NFQ09ORCk7XG4gICAgICAgIGxldCBtaWxsaXNlY29uZCA9IEdldFNsb3QodGhpcywgSVNPX01JTExJU0VDT05EKTtcbiAgICAgICAgbGV0IG1pY3Jvc2Vjb25kID0gR2V0U2xvdCh0aGlzLCBJU09fTUlDUk9TRUNPTkQpO1xuICAgICAgICBsZXQgbmFub3NlY29uZCA9IEdldFNsb3QodGhpcywgSVNPX05BTk9TRUNPTkQpO1xuICAgICAgICAoeyBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQsIG1pY3Jvc2Vjb25kLCBuYW5vc2Vjb25kIH0gPSBSb3VuZFRpbWUoaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kLCBtaWNyb3NlY29uZCwgbmFub3NlY29uZCwgcm91bmRpbmdJbmNyZW1lbnQsIHNtYWxsZXN0VW5pdCwgcm91bmRpbmdNb2RlKSk7XG4gICAgICAgIHJldHVybiBuZXcgUGxhaW5UaW1lKGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZCwgbWljcm9zZWNvbmQsIG5hbm9zZWNvbmQpO1xuICAgIH1cbiAgICBlcXVhbHMob3RoZXJQYXJhbSkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxUaW1lKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICBjb25zdCBvdGhlciA9IFRvVGVtcG9yYWxUaW1lKG90aGVyUGFyYW0pO1xuICAgICAgICBmb3IgKGNvbnN0IHNsb3Qgb2YgW0lTT19IT1VSLCBJU09fTUlOVVRFLCBJU09fU0VDT05ELCBJU09fTUlMTElTRUNPTkQsIElTT19NSUNST1NFQ09ORCwgSVNPX05BTk9TRUNPTkRdKSB7XG4gICAgICAgICAgICBjb25zdCB2YWwxID0gR2V0U2xvdCh0aGlzLCBzbG90KTtcbiAgICAgICAgICAgIGNvbnN0IHZhbDIgPSBHZXRTbG90KG90aGVyLCBzbG90KTtcbiAgICAgICAgICAgIGlmICh2YWwxICE9PSB2YWwyKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgdG9TdHJpbmcob3B0aW9uc1BhcmFtID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbFRpbWUodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSBHZXRPcHRpb25zT2JqZWN0KG9wdGlvbnNQYXJhbSk7XG4gICAgICAgIGNvbnN0IHsgcHJlY2lzaW9uLCB1bml0LCBpbmNyZW1lbnQgfSA9IFRvU2Vjb25kc1N0cmluZ1ByZWNpc2lvbihvcHRpb25zKTtcbiAgICAgICAgY29uc3Qgcm91bmRpbmdNb2RlID0gVG9UZW1wb3JhbFJvdW5kaW5nTW9kZShvcHRpb25zLCAndHJ1bmMnKTtcbiAgICAgICAgcmV0dXJuIFRlbXBvcmFsVGltZVRvU3RyaW5nKHRoaXMsIHByZWNpc2lvbiwgeyB1bml0LCBpbmNyZW1lbnQsIHJvdW5kaW5nTW9kZSB9KTtcbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxUaW1lKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICByZXR1cm4gVGVtcG9yYWxUaW1lVG9TdHJpbmcodGhpcywgJ2F1dG8nKTtcbiAgICB9XG4gICAgdG9Mb2NhbGVTdHJpbmcobG9jYWxlcyA9IHVuZGVmaW5lZCwgb3B0aW9ucyA9IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxUaW1lKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICByZXR1cm4gbmV3IERhdGVUaW1lRm9ybWF0KGxvY2FsZXMsIG9wdGlvbnMpLmZvcm1hdCh0aGlzKTtcbiAgICB9XG4gICAgdmFsdWVPZigpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigndXNlIGNvbXBhcmUoKSBvciBlcXVhbHMoKSB0byBjb21wYXJlIFRlbXBvcmFsLlBsYWluVGltZScpO1xuICAgIH1cbiAgICB0b1BsYWluRGF0ZVRpbWUodGVtcG9yYWxEYXRlUGFyYW0pIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsVGltZSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgY29uc3QgdGVtcG9yYWxEYXRlID0gVG9UZW1wb3JhbERhdGUodGVtcG9yYWxEYXRlUGFyYW0pO1xuICAgICAgICBjb25zdCB5ZWFyID0gR2V0U2xvdCh0ZW1wb3JhbERhdGUsIElTT19ZRUFSKTtcbiAgICAgICAgY29uc3QgbW9udGggPSBHZXRTbG90KHRlbXBvcmFsRGF0ZSwgSVNPX01PTlRIKTtcbiAgICAgICAgY29uc3QgZGF5ID0gR2V0U2xvdCh0ZW1wb3JhbERhdGUsIElTT19EQVkpO1xuICAgICAgICBjb25zdCBjYWxlbmRhciA9IEdldFNsb3QodGVtcG9yYWxEYXRlLCBDQUxFTkRBUik7XG4gICAgICAgIGNvbnN0IGhvdXIgPSBHZXRTbG90KHRoaXMsIElTT19IT1VSKTtcbiAgICAgICAgY29uc3QgbWludXRlID0gR2V0U2xvdCh0aGlzLCBJU09fTUlOVVRFKTtcbiAgICAgICAgY29uc3Qgc2Vjb25kID0gR2V0U2xvdCh0aGlzLCBJU09fU0VDT05EKTtcbiAgICAgICAgY29uc3QgbWlsbGlzZWNvbmQgPSBHZXRTbG90KHRoaXMsIElTT19NSUxMSVNFQ09ORCk7XG4gICAgICAgIGNvbnN0IG1pY3Jvc2Vjb25kID0gR2V0U2xvdCh0aGlzLCBJU09fTUlDUk9TRUNPTkQpO1xuICAgICAgICBjb25zdCBuYW5vc2Vjb25kID0gR2V0U2xvdCh0aGlzLCBJU09fTkFOT1NFQ09ORCk7XG4gICAgICAgIHJldHVybiBDcmVhdGVUZW1wb3JhbERhdGVUaW1lKHllYXIsIG1vbnRoLCBkYXksIGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZCwgbWljcm9zZWNvbmQsIG5hbm9zZWNvbmQsIGNhbGVuZGFyKTtcbiAgICB9XG4gICAgdG9ab25lZERhdGVUaW1lKGl0ZW0pIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsVGltZSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgaWYgKCFJc09iamVjdChpdGVtKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBhcmd1bWVudCcpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRhdGVMaWtlID0gaXRlbS5wbGFpbkRhdGU7XG4gICAgICAgIGlmIChkYXRlTGlrZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdtaXNzaW5nIGRhdGUgcHJvcGVydHknKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0ZW1wb3JhbERhdGUgPSBUb1RlbXBvcmFsRGF0ZShkYXRlTGlrZSk7XG4gICAgICAgIGNvbnN0IHRpbWVab25lTGlrZSA9IGl0ZW0udGltZVpvbmU7XG4gICAgICAgIGlmICh0aW1lWm9uZUxpa2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbWlzc2luZyB0aW1lWm9uZSBwcm9wZXJ0eScpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRpbWVab25lID0gVG9UZW1wb3JhbFRpbWVab25lKHRpbWVab25lTGlrZSk7XG4gICAgICAgIGNvbnN0IHllYXIgPSBHZXRTbG90KHRlbXBvcmFsRGF0ZSwgSVNPX1lFQVIpO1xuICAgICAgICBjb25zdCBtb250aCA9IEdldFNsb3QodGVtcG9yYWxEYXRlLCBJU09fTU9OVEgpO1xuICAgICAgICBjb25zdCBkYXkgPSBHZXRTbG90KHRlbXBvcmFsRGF0ZSwgSVNPX0RBWSk7XG4gICAgICAgIGNvbnN0IGNhbGVuZGFyID0gR2V0U2xvdCh0ZW1wb3JhbERhdGUsIENBTEVOREFSKTtcbiAgICAgICAgY29uc3QgaG91ciA9IEdldFNsb3QodGhpcywgSVNPX0hPVVIpO1xuICAgICAgICBjb25zdCBtaW51dGUgPSBHZXRTbG90KHRoaXMsIElTT19NSU5VVEUpO1xuICAgICAgICBjb25zdCBzZWNvbmQgPSBHZXRTbG90KHRoaXMsIElTT19TRUNPTkQpO1xuICAgICAgICBjb25zdCBtaWxsaXNlY29uZCA9IEdldFNsb3QodGhpcywgSVNPX01JTExJU0VDT05EKTtcbiAgICAgICAgY29uc3QgbWljcm9zZWNvbmQgPSBHZXRTbG90KHRoaXMsIElTT19NSUNST1NFQ09ORCk7XG4gICAgICAgIGNvbnN0IG5hbm9zZWNvbmQgPSBHZXRTbG90KHRoaXMsIElTT19OQU5PU0VDT05EKTtcbiAgICAgICAgY29uc3QgUGxhaW5EYXRlVGltZSA9IEdldEludHJpbnNpYygnJVRlbXBvcmFsLlBsYWluRGF0ZVRpbWUlJyk7XG4gICAgICAgIGNvbnN0IGR0ID0gbmV3IFBsYWluRGF0ZVRpbWUoeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kLCBtaWNyb3NlY29uZCwgbmFub3NlY29uZCwgY2FsZW5kYXIpO1xuICAgICAgICBjb25zdCBpbnN0YW50ID0gQnVpbHRpblRpbWVab25lR2V0SW5zdGFudEZvcih0aW1lWm9uZSwgZHQsICdjb21wYXRpYmxlJyk7XG4gICAgICAgIHJldHVybiBDcmVhdGVUZW1wb3JhbFpvbmVkRGF0ZVRpbWUoR2V0U2xvdChpbnN0YW50LCBFUE9DSE5BTk9TRUNPTkRTKSwgdGltZVpvbmUsIGNhbGVuZGFyKTtcbiAgICB9XG4gICAgZ2V0SVNPRmllbGRzKCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxUaW1lKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY2FsZW5kYXI6IEdldFNsb3QodGhpcywgQ0FMRU5EQVIpLFxuICAgICAgICAgICAgaXNvSG91cjogR2V0U2xvdCh0aGlzLCBJU09fSE9VUiksXG4gICAgICAgICAgICBpc29NaWNyb3NlY29uZDogR2V0U2xvdCh0aGlzLCBJU09fTUlDUk9TRUNPTkQpLFxuICAgICAgICAgICAgaXNvTWlsbGlzZWNvbmQ6IEdldFNsb3QodGhpcywgSVNPX01JTExJU0VDT05EKSxcbiAgICAgICAgICAgIGlzb01pbnV0ZTogR2V0U2xvdCh0aGlzLCBJU09fTUlOVVRFKSxcbiAgICAgICAgICAgIGlzb05hbm9zZWNvbmQ6IEdldFNsb3QodGhpcywgSVNPX05BTk9TRUNPTkQpLFxuICAgICAgICAgICAgaXNvU2Vjb25kOiBHZXRTbG90KHRoaXMsIElTT19TRUNPTkQpXG4gICAgICAgIH07XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tKGl0ZW0sIG9wdGlvbnNQYXJhbSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCBvcHRpb25zID0gR2V0T3B0aW9uc09iamVjdChvcHRpb25zUGFyYW0pO1xuICAgICAgICBjb25zdCBvdmVyZmxvdyA9IFRvVGVtcG9yYWxPdmVyZmxvdyhvcHRpb25zKTtcbiAgICAgICAgaWYgKElzVGVtcG9yYWxUaW1lKGl0ZW0pKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFBsYWluVGltZShHZXRTbG90KGl0ZW0sIElTT19IT1VSKSwgR2V0U2xvdChpdGVtLCBJU09fTUlOVVRFKSwgR2V0U2xvdChpdGVtLCBJU09fU0VDT05EKSwgR2V0U2xvdChpdGVtLCBJU09fTUlMTElTRUNPTkQpLCBHZXRTbG90KGl0ZW0sIElTT19NSUNST1NFQ09ORCksIEdldFNsb3QoaXRlbSwgSVNPX05BTk9TRUNPTkQpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gVG9UZW1wb3JhbFRpbWUoaXRlbSwgb3ZlcmZsb3cpO1xuICAgIH1cbiAgICBzdGF0aWMgY29tcGFyZShvbmVQYXJhbSwgdHdvUGFyYW0pIHtcbiAgICAgICAgY29uc3Qgb25lID0gVG9UZW1wb3JhbFRpbWUob25lUGFyYW0pO1xuICAgICAgICBjb25zdCB0d28gPSBUb1RlbXBvcmFsVGltZSh0d29QYXJhbSk7XG4gICAgICAgIGZvciAoY29uc3Qgc2xvdCBvZiBbSVNPX0hPVVIsIElTT19NSU5VVEUsIElTT19TRUNPTkQsIElTT19NSUxMSVNFQ09ORCwgSVNPX01JQ1JPU0VDT05ELCBJU09fTkFOT1NFQ09ORF0pIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbDEgPSBHZXRTbG90KG9uZSwgc2xvdCk7XG4gICAgICAgICAgICBjb25zdCB2YWwyID0gR2V0U2xvdCh0d28sIHNsb3QpO1xuICAgICAgICAgICAgaWYgKHZhbDEgIT09IHZhbDIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIENvbXBhcmlzb25SZXN1bHQodmFsMSAtIHZhbDIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbn1cbk1ha2VJbnRyaW5zaWNDbGFzcyhQbGFpblRpbWUsICdUZW1wb3JhbC5QbGFpblRpbWUnKTtcblxuY2xhc3MgVGltZVpvbmUge1xuICAgIGNvbnN0cnVjdG9yKHRpbWVab25lSWRlbnRpZmllclBhcmFtKSB7XG4gICAgICAgIC8vIE5vdGU6IGlmIHRoZSBhcmd1bWVudCBpcyBub3QgcGFzc2VkLCBHZXRDYW5vbmljYWxUaW1lWm9uZUlkZW50aWZpZXIodW5kZWZpbmVkKSB3aWxsIHRocm93LlxuICAgICAgICAvLyAgICAgICBUaGlzIGNoZWNrIGV4aXN0cyBvbmx5IHRvIGltcHJvdmUgdGhlIGVycm9yIG1lc3NhZ2UuXG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ21pc3NpbmcgYXJndW1lbnQ6IGlkZW50aWZpZXIgaXMgcmVxdWlyZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0aW1lWm9uZUlkZW50aWZpZXIgPSBHZXRDYW5vbmljYWxUaW1lWm9uZUlkZW50aWZpZXIodGltZVpvbmVJZGVudGlmaWVyUGFyYW0pO1xuICAgICAgICBDcmVhdGVTbG90cyh0aGlzKTtcbiAgICAgICAgU2V0U2xvdCh0aGlzLCBUSU1FWk9ORV9JRCwgdGltZVpvbmVJZGVudGlmaWVyKTtcbiAgICAgICAge1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdfcmVwcl8nLCB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IGAke3RoaXNbU3ltYm9sLnRvU3RyaW5nVGFnXX0gPCR7dGltZVpvbmVJZGVudGlmaWVyfT5gLFxuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgaWQoKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbFRpbWVab25lKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICByZXR1cm4gVG9TdHJpbmcodGhpcyk7XG4gICAgfVxuICAgIGdldE9mZnNldE5hbm9zZWNvbmRzRm9yKGluc3RhbnRQYXJhbSkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxUaW1lWm9uZSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgY29uc3QgaW5zdGFudCA9IFRvVGVtcG9yYWxJbnN0YW50KGluc3RhbnRQYXJhbSk7XG4gICAgICAgIGNvbnN0IGlkID0gR2V0U2xvdCh0aGlzLCBUSU1FWk9ORV9JRCk7XG4gICAgICAgIGlmIChUZXN0VGltZVpvbmVPZmZzZXRTdHJpbmcoaWQpKSB7XG4gICAgICAgICAgICByZXR1cm4gUGFyc2VUaW1lWm9uZU9mZnNldFN0cmluZyhpZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEdldElBTkFUaW1lWm9uZU9mZnNldE5hbm9zZWNvbmRzKEdldFNsb3QoaW5zdGFudCwgRVBPQ0hOQU5PU0VDT05EUyksIGlkKTtcbiAgICB9XG4gICAgZ2V0T2Zmc2V0U3RyaW5nRm9yKGluc3RhbnRQYXJhbSkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxUaW1lWm9uZSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgY29uc3QgaW5zdGFudCA9IFRvVGVtcG9yYWxJbnN0YW50KGluc3RhbnRQYXJhbSk7XG4gICAgICAgIHJldHVybiBCdWlsdGluVGltZVpvbmVHZXRPZmZzZXRTdHJpbmdGb3IodGhpcywgaW5zdGFudCk7XG4gICAgfVxuICAgIGdldFBsYWluRGF0ZVRpbWVGb3IoaW5zdGFudFBhcmFtLCBjYWxlbmRhclBhcmFtID0gR2V0SVNPODYwMUNhbGVuZGFyKCkpIHtcbiAgICAgICAgY29uc3QgaW5zdGFudCA9IFRvVGVtcG9yYWxJbnN0YW50KGluc3RhbnRQYXJhbSk7XG4gICAgICAgIGNvbnN0IGNhbGVuZGFyID0gVG9UZW1wb3JhbENhbGVuZGFyKGNhbGVuZGFyUGFyYW0pO1xuICAgICAgICByZXR1cm4gQnVpbHRpblRpbWVab25lR2V0UGxhaW5EYXRlVGltZUZvcih0aGlzLCBpbnN0YW50LCBjYWxlbmRhcik7XG4gICAgfVxuICAgIGdldEluc3RhbnRGb3IoZGF0ZVRpbWVQYXJhbSwgb3B0aW9uc1BhcmFtID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbFRpbWVab25lKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICBjb25zdCBkYXRlVGltZSA9IFRvVGVtcG9yYWxEYXRlVGltZShkYXRlVGltZVBhcmFtKTtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IEdldE9wdGlvbnNPYmplY3Qob3B0aW9uc1BhcmFtKTtcbiAgICAgICAgY29uc3QgZGlzYW1iaWd1YXRpb24gPSBUb1RlbXBvcmFsRGlzYW1iaWd1YXRpb24ob3B0aW9ucyk7XG4gICAgICAgIHJldHVybiBCdWlsdGluVGltZVpvbmVHZXRJbnN0YW50Rm9yKHRoaXMsIGRhdGVUaW1lLCBkaXNhbWJpZ3VhdGlvbik7XG4gICAgfVxuICAgIGdldFBvc3NpYmxlSW5zdGFudHNGb3IoZGF0ZVRpbWVQYXJhbSkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxUaW1lWm9uZSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgY29uc3QgZGF0ZVRpbWUgPSBUb1RlbXBvcmFsRGF0ZVRpbWUoZGF0ZVRpbWVQYXJhbSk7XG4gICAgICAgIGNvbnN0IEluc3RhbnQgPSBHZXRJbnRyaW5zaWMoJyVUZW1wb3JhbC5JbnN0YW50JScpO1xuICAgICAgICBjb25zdCBpZCA9IEdldFNsb3QodGhpcywgVElNRVpPTkVfSUQpO1xuICAgICAgICBpZiAoVGVzdFRpbWVab25lT2Zmc2V0U3RyaW5nKGlkKSkge1xuICAgICAgICAgICAgY29uc3QgZXBvY2hOcyA9IEdldEVwb2NoRnJvbUlTT1BhcnRzKEdldFNsb3QoZGF0ZVRpbWUsIElTT19ZRUFSKSwgR2V0U2xvdChkYXRlVGltZSwgSVNPX01PTlRIKSwgR2V0U2xvdChkYXRlVGltZSwgSVNPX0RBWSksIEdldFNsb3QoZGF0ZVRpbWUsIElTT19IT1VSKSwgR2V0U2xvdChkYXRlVGltZSwgSVNPX01JTlVURSksIEdldFNsb3QoZGF0ZVRpbWUsIElTT19TRUNPTkQpLCBHZXRTbG90KGRhdGVUaW1lLCBJU09fTUlMTElTRUNPTkQpLCBHZXRTbG90KGRhdGVUaW1lLCBJU09fTUlDUk9TRUNPTkQpLCBHZXRTbG90KGRhdGVUaW1lLCBJU09fTkFOT1NFQ09ORCkpO1xuICAgICAgICAgICAgaWYgKGVwb2NoTnMgPT09IG51bGwpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0RhdGVUaW1lIG91dHNpZGUgb2Ygc3VwcG9ydGVkIHJhbmdlJyk7XG4gICAgICAgICAgICBjb25zdCBvZmZzZXROcyA9IFBhcnNlVGltZVpvbmVPZmZzZXRTdHJpbmcoaWQpO1xuICAgICAgICAgICAgcmV0dXJuIFtuZXcgSW5zdGFudChKU0JJLnN1YnRyYWN0KGVwb2NoTnMsIEpTQkkuQmlnSW50KG9mZnNldE5zKSkpXTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwb3NzaWJsZUVwb2NoTnMgPSBHZXRJQU5BVGltZVpvbmVFcG9jaFZhbHVlKGlkLCBHZXRTbG90KGRhdGVUaW1lLCBJU09fWUVBUiksIEdldFNsb3QoZGF0ZVRpbWUsIElTT19NT05USCksIEdldFNsb3QoZGF0ZVRpbWUsIElTT19EQVkpLCBHZXRTbG90KGRhdGVUaW1lLCBJU09fSE9VUiksIEdldFNsb3QoZGF0ZVRpbWUsIElTT19NSU5VVEUpLCBHZXRTbG90KGRhdGVUaW1lLCBJU09fU0VDT05EKSwgR2V0U2xvdChkYXRlVGltZSwgSVNPX01JTExJU0VDT05EKSwgR2V0U2xvdChkYXRlVGltZSwgSVNPX01JQ1JPU0VDT05EKSwgR2V0U2xvdChkYXRlVGltZSwgSVNPX05BTk9TRUNPTkQpKTtcbiAgICAgICAgcmV0dXJuIHBvc3NpYmxlRXBvY2hOcy5tYXAoKG5zKSA9PiBuZXcgSW5zdGFudChucykpO1xuICAgIH1cbiAgICBnZXROZXh0VHJhbnNpdGlvbihzdGFydGluZ1BvaW50UGFyYW0pIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsVGltZVpvbmUodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIGNvbnN0IHN0YXJ0aW5nUG9pbnQgPSBUb1RlbXBvcmFsSW5zdGFudChzdGFydGluZ1BvaW50UGFyYW0pO1xuICAgICAgICBjb25zdCBpZCA9IEdldFNsb3QodGhpcywgVElNRVpPTkVfSUQpO1xuICAgICAgICAvLyBPZmZzZXQgdGltZSB6b25lcyBvciBVVEMgaGF2ZSBubyB0cmFuc2l0aW9uc1xuICAgICAgICBpZiAoVGVzdFRpbWVab25lT2Zmc2V0U3RyaW5nKGlkKSB8fCBpZCA9PT0gJ1VUQycpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGxldCBlcG9jaE5hbm9zZWNvbmRzID0gR2V0U2xvdChzdGFydGluZ1BvaW50LCBFUE9DSE5BTk9TRUNPTkRTKTtcbiAgICAgICAgY29uc3QgSW5zdGFudCA9IEdldEludHJpbnNpYygnJVRlbXBvcmFsLkluc3RhbnQlJyk7XG4gICAgICAgIGVwb2NoTmFub3NlY29uZHMgPSBHZXRJQU5BVGltZVpvbmVOZXh0VHJhbnNpdGlvbihlcG9jaE5hbm9zZWNvbmRzLCBpZCk7XG4gICAgICAgIHJldHVybiBlcG9jaE5hbm9zZWNvbmRzID09PSBudWxsID8gbnVsbCA6IG5ldyBJbnN0YW50KGVwb2NoTmFub3NlY29uZHMpO1xuICAgIH1cbiAgICBnZXRQcmV2aW91c1RyYW5zaXRpb24oc3RhcnRpbmdQb2ludFBhcmFtKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbFRpbWVab25lKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICBjb25zdCBzdGFydGluZ1BvaW50ID0gVG9UZW1wb3JhbEluc3RhbnQoc3RhcnRpbmdQb2ludFBhcmFtKTtcbiAgICAgICAgY29uc3QgaWQgPSBHZXRTbG90KHRoaXMsIFRJTUVaT05FX0lEKTtcbiAgICAgICAgLy8gT2Zmc2V0IHRpbWUgem9uZXMgb3IgVVRDIGhhdmUgbm8gdHJhbnNpdGlvbnNcbiAgICAgICAgaWYgKFRlc3RUaW1lWm9uZU9mZnNldFN0cmluZyhpZCkgfHwgaWQgPT09ICdVVEMnKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZXBvY2hOYW5vc2Vjb25kcyA9IEdldFNsb3Qoc3RhcnRpbmdQb2ludCwgRVBPQ0hOQU5PU0VDT05EUyk7XG4gICAgICAgIGNvbnN0IEluc3RhbnQgPSBHZXRJbnRyaW5zaWMoJyVUZW1wb3JhbC5JbnN0YW50JScpO1xuICAgICAgICBlcG9jaE5hbm9zZWNvbmRzID0gR2V0SUFOQVRpbWVab25lUHJldmlvdXNUcmFuc2l0aW9uKGVwb2NoTmFub3NlY29uZHMsIGlkKTtcbiAgICAgICAgcmV0dXJuIGVwb2NoTmFub3NlY29uZHMgPT09IG51bGwgPyBudWxsIDogbmV3IEluc3RhbnQoZXBvY2hOYW5vc2Vjb25kcyk7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxUaW1lWm9uZSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgcmV0dXJuIFRvU3RyaW5nKEdldFNsb3QodGhpcywgVElNRVpPTkVfSUQpKTtcbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxUaW1lWm9uZSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgcmV0dXJuIFRvU3RyaW5nKHRoaXMpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbShpdGVtKSB7XG4gICAgICAgIHJldHVybiBUb1RlbXBvcmFsVGltZVpvbmUoaXRlbSk7XG4gICAgfVxufVxuTWFrZUludHJpbnNpY0NsYXNzKFRpbWVab25lLCAnVGVtcG9yYWwuVGltZVpvbmUnKTtcblxuY29uc3QgT2JqZWN0Q3JlYXRlID0gT2JqZWN0LmNyZWF0ZTtcbmNvbnN0IERJU0FMTE9XRURfVU5JVFMgPSBbXG4gICAgJ3dlZWsnLFxuICAgICdkYXknLFxuICAgICdob3VyJyxcbiAgICAnbWludXRlJyxcbiAgICAnc2Vjb25kJyxcbiAgICAnbWlsbGlzZWNvbmQnLFxuICAgICdtaWNyb3NlY29uZCcsXG4gICAgJ25hbm9zZWNvbmQnXG5dO1xuY2xhc3MgUGxhaW5ZZWFyTW9udGgge1xuICAgIGNvbnN0cnVjdG9yKGlzb1llYXJQYXJhbSwgaXNvTW9udGhQYXJhbSwgY2FsZW5kYXJQYXJhbSA9IEdldElTTzg2MDFDYWxlbmRhcigpLCByZWZlcmVuY2VJU09EYXlQYXJhbSA9IDEpIHtcbiAgICAgICAgY29uc3QgaXNvWWVhciA9IFRvSW50ZWdlclRocm93T25JbmZpbml0eShpc29ZZWFyUGFyYW0pO1xuICAgICAgICBjb25zdCBpc29Nb250aCA9IFRvSW50ZWdlclRocm93T25JbmZpbml0eShpc29Nb250aFBhcmFtKTtcbiAgICAgICAgY29uc3QgY2FsZW5kYXIgPSBUb1RlbXBvcmFsQ2FsZW5kYXIoY2FsZW5kYXJQYXJhbSk7XG4gICAgICAgIGNvbnN0IHJlZmVyZW5jZUlTT0RheSA9IFRvSW50ZWdlclRocm93T25JbmZpbml0eShyZWZlcmVuY2VJU09EYXlQYXJhbSk7XG4gICAgICAgIC8vIE5vdGU6IGlmIHRoZSBhcmd1bWVudHMgYXJlIG5vdCBwYXNzZWQsXG4gICAgICAgIC8vICAgICAgIFRvSW50ZWdlclRocm93T25JbmZpbml0eSh1bmRlZmluZWQpIHdpbGwgaGF2ZSByZXR1cm5lZCAwLCB3aGljaCB3aWxsXG4gICAgICAgIC8vICAgICAgIGJlIHJlamVjdGVkIGJ5IFJlamVjdElTT0RhdGUgaW4gQ3JlYXRlVGVtcG9yYWxZZWFyTW9udGhTbG90cy4gVGhpc1xuICAgICAgICAvLyAgICAgICBjaGVjayBleGlzdHMgb25seSB0byBpbXByb3ZlIHRoZSBlcnJvciBtZXNzYWdlLlxuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdtaXNzaW5nIGFyZ3VtZW50OiBpc29ZZWFyIGFuZCBpc29Nb250aCBhcmUgcmVxdWlyZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBDcmVhdGVUZW1wb3JhbFllYXJNb250aFNsb3RzKHRoaXMsIGlzb1llYXIsIGlzb01vbnRoLCBjYWxlbmRhciwgcmVmZXJlbmNlSVNPRGF5KTtcbiAgICB9XG4gICAgZ2V0IHllYXIoKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbFllYXJNb250aCh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgcmV0dXJuIENhbGVuZGFyWWVhcihHZXRTbG90KHRoaXMsIENBTEVOREFSKSwgdGhpcyk7XG4gICAgfVxuICAgIGdldCBtb250aCgpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsWWVhck1vbnRoKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICByZXR1cm4gQ2FsZW5kYXJNb250aChHZXRTbG90KHRoaXMsIENBTEVOREFSKSwgdGhpcyk7XG4gICAgfVxuICAgIGdldCBtb250aENvZGUoKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbFllYXJNb250aCh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgcmV0dXJuIENhbGVuZGFyTW9udGhDb2RlKEdldFNsb3QodGhpcywgQ0FMRU5EQVIpLCB0aGlzKTtcbiAgICB9XG4gICAgZ2V0IGNhbGVuZGFyKCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxZZWFyTW9udGgodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIHJldHVybiBHZXRTbG90KHRoaXMsIENBTEVOREFSKTtcbiAgICB9XG4gICAgZ2V0IGVyYSgpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsWWVhck1vbnRoKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICByZXR1cm4gQ2FsZW5kYXJFcmEoR2V0U2xvdCh0aGlzLCBDQUxFTkRBUiksIHRoaXMpO1xuICAgIH1cbiAgICBnZXQgZXJhWWVhcigpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsWWVhck1vbnRoKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICByZXR1cm4gQ2FsZW5kYXJFcmFZZWFyKEdldFNsb3QodGhpcywgQ0FMRU5EQVIpLCB0aGlzKTtcbiAgICB9XG4gICAgZ2V0IGRheXNJbk1vbnRoKCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxZZWFyTW9udGgodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIHJldHVybiBDYWxlbmRhckRheXNJbk1vbnRoKEdldFNsb3QodGhpcywgQ0FMRU5EQVIpLCB0aGlzKTtcbiAgICB9XG4gICAgZ2V0IGRheXNJblllYXIoKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbFllYXJNb250aCh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgcmV0dXJuIENhbGVuZGFyRGF5c0luWWVhcihHZXRTbG90KHRoaXMsIENBTEVOREFSKSwgdGhpcyk7XG4gICAgfVxuICAgIGdldCBtb250aHNJblllYXIoKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbFllYXJNb250aCh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgcmV0dXJuIENhbGVuZGFyTW9udGhzSW5ZZWFyKEdldFNsb3QodGhpcywgQ0FMRU5EQVIpLCB0aGlzKTtcbiAgICB9XG4gICAgZ2V0IGluTGVhcFllYXIoKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbFllYXJNb250aCh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgcmV0dXJuIENhbGVuZGFySW5MZWFwWWVhcihHZXRTbG90KHRoaXMsIENBTEVOREFSKSwgdGhpcyk7XG4gICAgfVxuICAgIHdpdGgodGVtcG9yYWxZZWFyTW9udGhMaWtlLCBvcHRpb25zUGFyYW0gPSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsWWVhck1vbnRoKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICBpZiAoIUlzT2JqZWN0KHRlbXBvcmFsWWVhck1vbnRoTGlrZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgYXJndW1lbnQnKTtcbiAgICAgICAgfVxuICAgICAgICBSZWplY3RPYmplY3RXaXRoQ2FsZW5kYXJPclRpbWVab25lKHRlbXBvcmFsWWVhck1vbnRoTGlrZSk7XG4gICAgICAgIGNvbnN0IGNhbGVuZGFyID0gR2V0U2xvdCh0aGlzLCBDQUxFTkRBUik7XG4gICAgICAgIGNvbnN0IGZpZWxkTmFtZXMgPSBDYWxlbmRhckZpZWxkcyhjYWxlbmRhciwgWydtb250aCcsICdtb250aENvZGUnLCAneWVhciddKTtcbiAgICAgICAgY29uc3QgcHJvcHMgPSBUb1BhcnRpYWxSZWNvcmQodGVtcG9yYWxZZWFyTW9udGhMaWtlLCBmaWVsZE5hbWVzKTtcbiAgICAgICAgaWYgKCFwcm9wcykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCB5ZWFyLW1vbnRoLWxpa2UnKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZmllbGRzID0gVG9UZW1wb3JhbFllYXJNb250aEZpZWxkcyh0aGlzLCBmaWVsZE5hbWVzKTtcbiAgICAgICAgZmllbGRzID0gQ2FsZW5kYXJNZXJnZUZpZWxkcyhjYWxlbmRhciwgZmllbGRzLCBwcm9wcyk7XG4gICAgICAgIGZpZWxkcyA9IFRvVGVtcG9yYWxZZWFyTW9udGhGaWVsZHMoZmllbGRzLCBmaWVsZE5hbWVzKTtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IEdldE9wdGlvbnNPYmplY3Qob3B0aW9uc1BhcmFtKTtcbiAgICAgICAgcmV0dXJuIFllYXJNb250aEZyb21GaWVsZHMoY2FsZW5kYXIsIGZpZWxkcywgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFkZCh0ZW1wb3JhbER1cmF0aW9uTGlrZSwgb3B0aW9uc1BhcmFtID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbFllYXJNb250aCh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgY29uc3QgZHVyYXRpb24gPSBUb0xpbWl0ZWRUZW1wb3JhbER1cmF0aW9uKHRlbXBvcmFsRHVyYXRpb25MaWtlKTtcbiAgICAgICAgbGV0IHsgeWVhcnMsIG1vbnRocywgd2Vla3MsIGRheXMsIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBtaWxsaXNlY29uZHMsIG1pY3Jvc2Vjb25kcywgbmFub3NlY29uZHMgfSA9IGR1cmF0aW9uO1xuICAgICAgICAoeyBkYXlzIH0gPSBCYWxhbmNlRHVyYXRpb24oZGF5cywgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc2Vjb25kcywgbWljcm9zZWNvbmRzLCBuYW5vc2Vjb25kcywgJ2RheScpKTtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IEdldE9wdGlvbnNPYmplY3Qob3B0aW9uc1BhcmFtKTtcbiAgICAgICAgY29uc3QgY2FsZW5kYXIgPSBHZXRTbG90KHRoaXMsIENBTEVOREFSKTtcbiAgICAgICAgY29uc3QgZmllbGROYW1lcyA9IENhbGVuZGFyRmllbGRzKGNhbGVuZGFyLCBbJ21vbnRoQ29kZScsICd5ZWFyJ10pO1xuICAgICAgICBjb25zdCBmaWVsZHMgPSBUb1RlbXBvcmFsWWVhck1vbnRoRmllbGRzKHRoaXMsIGZpZWxkTmFtZXMpO1xuICAgICAgICBjb25zdCBzaWduID0gRHVyYXRpb25TaWduKHllYXJzLCBtb250aHMsIHdlZWtzLCBkYXlzLCAwLCAwLCAwLCAwLCAwLCAwKTtcbiAgICAgICAgY29uc3QgZGF5ID0gc2lnbiA8IDAgPyBUb1Bvc2l0aXZlSW50ZWdlcihDYWxlbmRhckRheXNJbk1vbnRoKGNhbGVuZGFyLCB0aGlzKSkgOiAxO1xuICAgICAgICBjb25zdCBzdGFydERhdGUgPSBEYXRlRnJvbUZpZWxkcyhjYWxlbmRhciwgeyAuLi5maWVsZHMsIGRheSB9KTtcbiAgICAgICAgY29uc3Qgb3B0aW9uc0NvcHkgPSB7IC4uLm9wdGlvbnMgfTtcbiAgICAgICAgY29uc3QgYWRkZWREYXRlID0gQ2FsZW5kYXJEYXRlQWRkKGNhbGVuZGFyLCBzdGFydERhdGUsIHsgLi4uZHVyYXRpb24sIGRheXMgfSwgb3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IGFkZGVkRGF0ZUZpZWxkcyA9IFRvVGVtcG9yYWxZZWFyTW9udGhGaWVsZHMoYWRkZWREYXRlLCBmaWVsZE5hbWVzKTtcbiAgICAgICAgcmV0dXJuIFllYXJNb250aEZyb21GaWVsZHMoY2FsZW5kYXIsIGFkZGVkRGF0ZUZpZWxkcywgb3B0aW9uc0NvcHkpO1xuICAgIH1cbiAgICBzdWJ0cmFjdCh0ZW1wb3JhbER1cmF0aW9uTGlrZSwgb3B0aW9uc1BhcmFtID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbFllYXJNb250aCh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgbGV0IGR1cmF0aW9uID0gVG9MaW1pdGVkVGVtcG9yYWxEdXJhdGlvbih0ZW1wb3JhbER1cmF0aW9uTGlrZSk7XG4gICAgICAgIGR1cmF0aW9uID0ge1xuICAgICAgICAgICAgeWVhcnM6IC1kdXJhdGlvbi55ZWFycyxcbiAgICAgICAgICAgIG1vbnRoczogLWR1cmF0aW9uLm1vbnRocyxcbiAgICAgICAgICAgIHdlZWtzOiAtZHVyYXRpb24ud2Vla3MsXG4gICAgICAgICAgICBkYXlzOiAtZHVyYXRpb24uZGF5cyxcbiAgICAgICAgICAgIGhvdXJzOiAtZHVyYXRpb24uaG91cnMsXG4gICAgICAgICAgICBtaW51dGVzOiAtZHVyYXRpb24ubWludXRlcyxcbiAgICAgICAgICAgIHNlY29uZHM6IC1kdXJhdGlvbi5zZWNvbmRzLFxuICAgICAgICAgICAgbWlsbGlzZWNvbmRzOiAtZHVyYXRpb24ubWlsbGlzZWNvbmRzLFxuICAgICAgICAgICAgbWljcm9zZWNvbmRzOiAtZHVyYXRpb24ubWljcm9zZWNvbmRzLFxuICAgICAgICAgICAgbmFub3NlY29uZHM6IC1kdXJhdGlvbi5uYW5vc2Vjb25kc1xuICAgICAgICB9O1xuICAgICAgICBsZXQgeyB5ZWFycywgbW9udGhzLCB3ZWVrcywgZGF5cywgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc2Vjb25kcywgbWljcm9zZWNvbmRzLCBuYW5vc2Vjb25kcyB9ID0gZHVyYXRpb247XG4gICAgICAgICh7IGRheXMgfSA9IEJhbGFuY2VEdXJhdGlvbihkYXlzLCBob3VycywgbWludXRlcywgc2Vjb25kcywgbWlsbGlzZWNvbmRzLCBtaWNyb3NlY29uZHMsIG5hbm9zZWNvbmRzLCAnZGF5JykpO1xuICAgICAgICBjb25zdCBvcHRpb25zID0gR2V0T3B0aW9uc09iamVjdChvcHRpb25zUGFyYW0pO1xuICAgICAgICBjb25zdCBjYWxlbmRhciA9IEdldFNsb3QodGhpcywgQ0FMRU5EQVIpO1xuICAgICAgICBjb25zdCBmaWVsZE5hbWVzID0gQ2FsZW5kYXJGaWVsZHMoY2FsZW5kYXIsIFsnbW9udGhDb2RlJywgJ3llYXInXSk7XG4gICAgICAgIGNvbnN0IGZpZWxkcyA9IFRvVGVtcG9yYWxZZWFyTW9udGhGaWVsZHModGhpcywgZmllbGROYW1lcyk7XG4gICAgICAgIGNvbnN0IHNpZ24gPSBEdXJhdGlvblNpZ24oeWVhcnMsIG1vbnRocywgd2Vla3MsIGRheXMsIDAsIDAsIDAsIDAsIDAsIDApO1xuICAgICAgICBjb25zdCBkYXkgPSBzaWduIDwgMCA/IFRvUG9zaXRpdmVJbnRlZ2VyKENhbGVuZGFyRGF5c0luTW9udGgoY2FsZW5kYXIsIHRoaXMpKSA6IDE7XG4gICAgICAgIGNvbnN0IHN0YXJ0RGF0ZSA9IERhdGVGcm9tRmllbGRzKGNhbGVuZGFyLCB7IC4uLmZpZWxkcywgZGF5IH0pO1xuICAgICAgICBjb25zdCBvcHRpb25zQ29weSA9IHsgLi4ub3B0aW9ucyB9O1xuICAgICAgICBjb25zdCBhZGRlZERhdGUgPSBDYWxlbmRhckRhdGVBZGQoY2FsZW5kYXIsIHN0YXJ0RGF0ZSwgeyAuLi5kdXJhdGlvbiwgZGF5cyB9LCBvcHRpb25zKTtcbiAgICAgICAgY29uc3QgYWRkZWREYXRlRmllbGRzID0gVG9UZW1wb3JhbFllYXJNb250aEZpZWxkcyhhZGRlZERhdGUsIGZpZWxkTmFtZXMpO1xuICAgICAgICByZXR1cm4gWWVhck1vbnRoRnJvbUZpZWxkcyhjYWxlbmRhciwgYWRkZWREYXRlRmllbGRzLCBvcHRpb25zQ29weSk7XG4gICAgfVxuICAgIHVudGlsKG90aGVyUGFyYW0sIG9wdGlvbnNQYXJhbSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxZZWFyTW9udGgodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIGNvbnN0IG90aGVyID0gVG9UZW1wb3JhbFllYXJNb250aChvdGhlclBhcmFtKTtcbiAgICAgICAgY29uc3QgY2FsZW5kYXIgPSBHZXRTbG90KHRoaXMsIENBTEVOREFSKTtcbiAgICAgICAgY29uc3Qgb3RoZXJDYWxlbmRhciA9IEdldFNsb3Qob3RoZXIsIENBTEVOREFSKTtcbiAgICAgICAgY29uc3QgY2FsZW5kYXJJRCA9IFRvU3RyaW5nKGNhbGVuZGFyKTtcbiAgICAgICAgY29uc3Qgb3RoZXJDYWxlbmRhcklEID0gVG9TdHJpbmcob3RoZXJDYWxlbmRhcik7XG4gICAgICAgIGlmIChjYWxlbmRhcklEICE9PSBvdGhlckNhbGVuZGFySUQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBjYW5ub3QgY29tcHV0ZSBkaWZmZXJlbmNlIGJldHdlZW4gbW9udGhzIG9mICR7Y2FsZW5kYXJJRH0gYW5kICR7b3RoZXJDYWxlbmRhcklEfSBjYWxlbmRhcnNgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvcHRpb25zID0gR2V0T3B0aW9uc09iamVjdChvcHRpb25zUGFyYW0pO1xuICAgICAgICBjb25zdCBzbWFsbGVzdFVuaXQgPSBUb1NtYWxsZXN0VGVtcG9yYWxVbml0KG9wdGlvbnMsICdtb250aCcsIERJU0FMTE9XRURfVU5JVFMpO1xuICAgICAgICBjb25zdCBsYXJnZXN0VW5pdCA9IFRvTGFyZ2VzdFRlbXBvcmFsVW5pdChvcHRpb25zLCAnYXV0bycsIERJU0FMTE9XRURfVU5JVFMsICd5ZWFyJyk7XG4gICAgICAgIFZhbGlkYXRlVGVtcG9yYWxVbml0UmFuZ2UobGFyZ2VzdFVuaXQsIHNtYWxsZXN0VW5pdCk7XG4gICAgICAgIGNvbnN0IHJvdW5kaW5nTW9kZSA9IFRvVGVtcG9yYWxSb3VuZGluZ01vZGUob3B0aW9ucywgJ3RydW5jJyk7XG4gICAgICAgIGNvbnN0IHJvdW5kaW5nSW5jcmVtZW50ID0gVG9UZW1wb3JhbFJvdW5kaW5nSW5jcmVtZW50KG9wdGlvbnMsIHVuZGVmaW5lZCwgZmFsc2UpO1xuICAgICAgICBjb25zdCBmaWVsZE5hbWVzID0gQ2FsZW5kYXJGaWVsZHMoY2FsZW5kYXIsIFsnbW9udGhDb2RlJywgJ3llYXInXSk7XG4gICAgICAgIGNvbnN0IG90aGVyRmllbGRzID0gVG9UZW1wb3JhbFllYXJNb250aEZpZWxkcyhvdGhlciwgZmllbGROYW1lcyk7XG4gICAgICAgIGNvbnN0IHRoaXNGaWVsZHMgPSBUb1RlbXBvcmFsWWVhck1vbnRoRmllbGRzKHRoaXMsIGZpZWxkTmFtZXMpO1xuICAgICAgICBjb25zdCBvdGhlckRhdGUgPSBEYXRlRnJvbUZpZWxkcyhjYWxlbmRhciwgeyAuLi5vdGhlckZpZWxkcywgZGF5OiAxIH0pO1xuICAgICAgICBjb25zdCB0aGlzRGF0ZSA9IERhdGVGcm9tRmllbGRzKGNhbGVuZGFyLCB7IC4uLnRoaXNGaWVsZHMsIGRheTogMSB9KTtcbiAgICAgICAgY29uc3QgdW50aWxPcHRpb25zID0geyAuLi5vcHRpb25zLCBsYXJnZXN0VW5pdCB9O1xuICAgICAgICBjb25zdCByZXN1bHQgPSBDYWxlbmRhckRhdGVVbnRpbChjYWxlbmRhciwgdGhpc0RhdGUsIG90aGVyRGF0ZSwgdW50aWxPcHRpb25zKTtcbiAgICAgICAgaWYgKHNtYWxsZXN0VW5pdCA9PT0gJ21vbnRoJyAmJiByb3VuZGluZ0luY3JlbWVudCA9PT0gMSlcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIGxldCB7IHllYXJzLCBtb250aHMgfSA9IHJlc3VsdDtcbiAgICAgICAgKHsgeWVhcnMsIG1vbnRocyB9ID0gUm91bmREdXJhdGlvbih5ZWFycywgbW9udGhzLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCByb3VuZGluZ0luY3JlbWVudCwgc21hbGxlc3RVbml0LCByb3VuZGluZ01vZGUsIHRoaXNEYXRlKSk7XG4gICAgICAgIGNvbnN0IER1cmF0aW9uID0gR2V0SW50cmluc2ljKCclVGVtcG9yYWwuRHVyYXRpb24lJyk7XG4gICAgICAgIHJldHVybiBuZXcgRHVyYXRpb24oeWVhcnMsIG1vbnRocywgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCk7XG4gICAgfVxuICAgIHNpbmNlKG90aGVyUGFyYW0sIG9wdGlvbnNQYXJhbSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxZZWFyTW9udGgodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIGNvbnN0IG90aGVyID0gVG9UZW1wb3JhbFllYXJNb250aChvdGhlclBhcmFtKTtcbiAgICAgICAgY29uc3QgY2FsZW5kYXIgPSBHZXRTbG90KHRoaXMsIENBTEVOREFSKTtcbiAgICAgICAgY29uc3Qgb3RoZXJDYWxlbmRhciA9IEdldFNsb3Qob3RoZXIsIENBTEVOREFSKTtcbiAgICAgICAgY29uc3QgY2FsZW5kYXJJRCA9IFRvU3RyaW5nKGNhbGVuZGFyKTtcbiAgICAgICAgY29uc3Qgb3RoZXJDYWxlbmRhcklEID0gVG9TdHJpbmcob3RoZXJDYWxlbmRhcik7XG4gICAgICAgIGlmIChjYWxlbmRhcklEICE9PSBvdGhlckNhbGVuZGFySUQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBjYW5ub3QgY29tcHV0ZSBkaWZmZXJlbmNlIGJldHdlZW4gbW9udGhzIG9mICR7Y2FsZW5kYXJJRH0gYW5kICR7b3RoZXJDYWxlbmRhcklEfSBjYWxlbmRhcnNgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvcHRpb25zID0gR2V0T3B0aW9uc09iamVjdChvcHRpb25zUGFyYW0pO1xuICAgICAgICBjb25zdCBzbWFsbGVzdFVuaXQgPSBUb1NtYWxsZXN0VGVtcG9yYWxVbml0KG9wdGlvbnMsICdtb250aCcsIERJU0FMTE9XRURfVU5JVFMpO1xuICAgICAgICBjb25zdCBsYXJnZXN0VW5pdCA9IFRvTGFyZ2VzdFRlbXBvcmFsVW5pdChvcHRpb25zLCAnYXV0bycsIERJU0FMTE9XRURfVU5JVFMsICd5ZWFyJyk7XG4gICAgICAgIFZhbGlkYXRlVGVtcG9yYWxVbml0UmFuZ2UobGFyZ2VzdFVuaXQsIHNtYWxsZXN0VW5pdCk7XG4gICAgICAgIGNvbnN0IHJvdW5kaW5nTW9kZSA9IFRvVGVtcG9yYWxSb3VuZGluZ01vZGUob3B0aW9ucywgJ3RydW5jJyk7XG4gICAgICAgIGNvbnN0IHJvdW5kaW5nSW5jcmVtZW50ID0gVG9UZW1wb3JhbFJvdW5kaW5nSW5jcmVtZW50KG9wdGlvbnMsIHVuZGVmaW5lZCwgZmFsc2UpO1xuICAgICAgICBjb25zdCBmaWVsZE5hbWVzID0gQ2FsZW5kYXJGaWVsZHMoY2FsZW5kYXIsIFsnbW9udGhDb2RlJywgJ3llYXInXSk7XG4gICAgICAgIGNvbnN0IG90aGVyRmllbGRzID0gVG9UZW1wb3JhbFllYXJNb250aEZpZWxkcyhvdGhlciwgZmllbGROYW1lcyk7XG4gICAgICAgIGNvbnN0IHRoaXNGaWVsZHMgPSBUb1RlbXBvcmFsWWVhck1vbnRoRmllbGRzKHRoaXMsIGZpZWxkTmFtZXMpO1xuICAgICAgICBjb25zdCBvdGhlckRhdGUgPSBEYXRlRnJvbUZpZWxkcyhjYWxlbmRhciwgeyAuLi5vdGhlckZpZWxkcywgZGF5OiAxIH0pO1xuICAgICAgICBjb25zdCB0aGlzRGF0ZSA9IERhdGVGcm9tRmllbGRzKGNhbGVuZGFyLCB7IC4uLnRoaXNGaWVsZHMsIGRheTogMSB9KTtcbiAgICAgICAgY29uc3QgdW50aWxPcHRpb25zID0geyAuLi5vcHRpb25zLCBsYXJnZXN0VW5pdCB9O1xuICAgICAgICBsZXQgeyB5ZWFycywgbW9udGhzIH0gPSBDYWxlbmRhckRhdGVVbnRpbChjYWxlbmRhciwgdGhpc0RhdGUsIG90aGVyRGF0ZSwgdW50aWxPcHRpb25zKTtcbiAgICAgICAgY29uc3QgRHVyYXRpb24gPSBHZXRJbnRyaW5zaWMoJyVUZW1wb3JhbC5EdXJhdGlvbiUnKTtcbiAgICAgICAgaWYgKHNtYWxsZXN0VW5pdCA9PT0gJ21vbnRoJyAmJiByb3VuZGluZ0luY3JlbWVudCA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBEdXJhdGlvbigteWVhcnMsIC1tb250aHMsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDApO1xuICAgICAgICB9XG4gICAgICAgICh7IHllYXJzLCBtb250aHMgfSA9IFJvdW5kRHVyYXRpb24oeWVhcnMsIG1vbnRocywgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgcm91bmRpbmdJbmNyZW1lbnQsIHNtYWxsZXN0VW5pdCwgTmVnYXRlVGVtcG9yYWxSb3VuZGluZ01vZGUocm91bmRpbmdNb2RlKSwgdGhpc0RhdGUpKTtcbiAgICAgICAgcmV0dXJuIG5ldyBEdXJhdGlvbigteWVhcnMsIC1tb250aHMsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDApO1xuICAgIH1cbiAgICBlcXVhbHMob3RoZXJQYXJhbSkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxZZWFyTW9udGgodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIGNvbnN0IG90aGVyID0gVG9UZW1wb3JhbFllYXJNb250aChvdGhlclBhcmFtKTtcbiAgICAgICAgZm9yIChjb25zdCBzbG90IG9mIFtJU09fWUVBUiwgSVNPX01PTlRILCBJU09fREFZXSkge1xuICAgICAgICAgICAgY29uc3QgdmFsMSA9IEdldFNsb3QodGhpcywgc2xvdCk7XG4gICAgICAgICAgICBjb25zdCB2YWwyID0gR2V0U2xvdChvdGhlciwgc2xvdCk7XG4gICAgICAgICAgICBpZiAodmFsMSAhPT0gdmFsMilcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIENhbGVuZGFyRXF1YWxzKEdldFNsb3QodGhpcywgQ0FMRU5EQVIpLCBHZXRTbG90KG90aGVyLCBDQUxFTkRBUikpO1xuICAgIH1cbiAgICB0b1N0cmluZyhvcHRpb25zUGFyYW0gPSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsWWVhck1vbnRoKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICBjb25zdCBvcHRpb25zID0gR2V0T3B0aW9uc09iamVjdChvcHRpb25zUGFyYW0pO1xuICAgICAgICBjb25zdCBzaG93Q2FsZW5kYXIgPSBUb1Nob3dDYWxlbmRhck9wdGlvbihvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIFRlbXBvcmFsWWVhck1vbnRoVG9TdHJpbmcodGhpcywgc2hvd0NhbGVuZGFyKTtcbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxZZWFyTW9udGgodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIHJldHVybiBUZW1wb3JhbFllYXJNb250aFRvU3RyaW5nKHRoaXMpO1xuICAgIH1cbiAgICB0b0xvY2FsZVN0cmluZyhsb2NhbGVzID0gdW5kZWZpbmVkLCBvcHRpb25zID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbFllYXJNb250aCh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlVGltZUZvcm1hdChsb2NhbGVzLCBvcHRpb25zKS5mb3JtYXQodGhpcyk7XG4gICAgfVxuICAgIHZhbHVlT2YoKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3VzZSBjb21wYXJlKCkgb3IgZXF1YWxzKCkgdG8gY29tcGFyZSBUZW1wb3JhbC5QbGFpblllYXJNb250aCcpO1xuICAgIH1cbiAgICB0b1BsYWluRGF0ZShpdGVtKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbFllYXJNb250aCh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgaWYgKCFJc09iamVjdChpdGVtKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2FyZ3VtZW50IHNob3VsZCBiZSBhbiBvYmplY3QnKTtcbiAgICAgICAgY29uc3QgY2FsZW5kYXIgPSBHZXRTbG90KHRoaXMsIENBTEVOREFSKTtcbiAgICAgICAgY29uc3QgcmVjZWl2ZXJGaWVsZE5hbWVzID0gQ2FsZW5kYXJGaWVsZHMoY2FsZW5kYXIsIFsnbW9udGhDb2RlJywgJ3llYXInXSk7XG4gICAgICAgIGNvbnN0IGZpZWxkcyA9IFRvVGVtcG9yYWxZZWFyTW9udGhGaWVsZHModGhpcywgcmVjZWl2ZXJGaWVsZE5hbWVzKTtcbiAgICAgICAgY29uc3QgaW5wdXRGaWVsZE5hbWVzID0gQ2FsZW5kYXJGaWVsZHMoY2FsZW5kYXIsIFsnZGF5J10pO1xuICAgICAgICBjb25zdCBpbnB1dEVudHJpZXMgPSBbWydkYXknXV07XG4gICAgICAgIC8vIEFkZCBleHRyYSBmaWVsZHMgZnJvbSB0aGUgY2FsZW5kYXIgYXQgdGhlIGVuZFxuICAgICAgICBpbnB1dEZpZWxkTmFtZXMuZm9yRWFjaCgoZmllbGROYW1lKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWlucHV0RW50cmllcy5zb21lKChbbmFtZV0pID0+IG5hbWUgPT09IGZpZWxkTmFtZSkpIHtcbiAgICAgICAgICAgICAgICBpbnB1dEVudHJpZXMucHVzaChbXG4gICAgICAgICAgICAgICAgICAgIGZpZWxkTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgXSk7IC8vIE1ha2UgVFMgaWdub3JlIGV4dHJhIGZpZWxkc1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgaW5wdXRGaWVsZHMgPSBQcmVwYXJlVGVtcG9yYWxGaWVsZHMoaXRlbSwgaW5wdXRFbnRyaWVzKTtcbiAgICAgICAgbGV0IG1lcmdlZEZpZWxkcyA9IENhbGVuZGFyTWVyZ2VGaWVsZHMoY2FsZW5kYXIsIGZpZWxkcywgaW5wdXRGaWVsZHMpO1xuICAgICAgICBjb25zdCBtZXJnZWRGaWVsZE5hbWVzID0gWy4uLm5ldyBTZXQoWy4uLnJlY2VpdmVyRmllbGROYW1lcywgLi4uaW5wdXRGaWVsZE5hbWVzXSldO1xuICAgICAgICBjb25zdCBtZXJnZWRFbnRyaWVzID0gW107XG4gICAgICAgIG1lcmdlZEZpZWxkTmFtZXMuZm9yRWFjaCgoZmllbGROYW1lKSA9PiB7XG4gICAgICAgICAgICBpZiAoIW1lcmdlZEVudHJpZXMuc29tZSgoW25hbWVdKSA9PiBuYW1lID09PSBmaWVsZE5hbWUpKSB7XG4gICAgICAgICAgICAgICAgbWVyZ2VkRW50cmllcy5wdXNoKFtmaWVsZE5hbWUsIHVuZGVmaW5lZF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgbWVyZ2VkRmllbGRzID0gUHJlcGFyZVRlbXBvcmFsRmllbGRzKG1lcmdlZEZpZWxkcywgbWVyZ2VkRW50cmllcyk7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSBPYmplY3RDcmVhdGUobnVsbCk7XG4gICAgICAgIG9wdGlvbnMub3ZlcmZsb3cgPSAncmVqZWN0JztcbiAgICAgICAgcmV0dXJuIERhdGVGcm9tRmllbGRzKGNhbGVuZGFyLCBtZXJnZWRGaWVsZHMsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBnZXRJU09GaWVsZHMoKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbFllYXJNb250aCh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNhbGVuZGFyOiBHZXRTbG90KHRoaXMsIENBTEVOREFSKSxcbiAgICAgICAgICAgIGlzb0RheTogR2V0U2xvdCh0aGlzLCBJU09fREFZKSxcbiAgICAgICAgICAgIGlzb01vbnRoOiBHZXRTbG90KHRoaXMsIElTT19NT05USCksXG4gICAgICAgICAgICBpc29ZZWFyOiBHZXRTbG90KHRoaXMsIElTT19ZRUFSKVxuICAgICAgICB9O1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbShpdGVtLCBvcHRpb25zUGFyYW0gPSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IEdldE9wdGlvbnNPYmplY3Qob3B0aW9uc1BhcmFtKTtcbiAgICAgICAgaWYgKElzVGVtcG9yYWxZZWFyTW9udGgoaXRlbSkpIHtcbiAgICAgICAgICAgIFRvVGVtcG9yYWxPdmVyZmxvdyhvcHRpb25zKTsgLy8gdmFsaWRhdGUgYW5kIGlnbm9yZVxuICAgICAgICAgICAgcmV0dXJuIENyZWF0ZVRlbXBvcmFsWWVhck1vbnRoKEdldFNsb3QoaXRlbSwgSVNPX1lFQVIpLCBHZXRTbG90KGl0ZW0sIElTT19NT05USCksIEdldFNsb3QoaXRlbSwgQ0FMRU5EQVIpLCBHZXRTbG90KGl0ZW0sIElTT19EQVkpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gVG9UZW1wb3JhbFllYXJNb250aChpdGVtLCBvcHRpb25zKTtcbiAgICB9XG4gICAgc3RhdGljIGNvbXBhcmUob25lUGFyYW0sIHR3b1BhcmFtKSB7XG4gICAgICAgIGNvbnN0IG9uZSA9IFRvVGVtcG9yYWxZZWFyTW9udGgob25lUGFyYW0pO1xuICAgICAgICBjb25zdCB0d28gPSBUb1RlbXBvcmFsWWVhck1vbnRoKHR3b1BhcmFtKTtcbiAgICAgICAgcmV0dXJuIENvbXBhcmVJU09EYXRlKEdldFNsb3Qob25lLCBJU09fWUVBUiksIEdldFNsb3Qob25lLCBJU09fTU9OVEgpLCBHZXRTbG90KG9uZSwgSVNPX0RBWSksIEdldFNsb3QodHdvLCBJU09fWUVBUiksIEdldFNsb3QodHdvLCBJU09fTU9OVEgpLCBHZXRTbG90KHR3bywgSVNPX0RBWSkpO1xuICAgIH1cbn1cbk1ha2VJbnRyaW5zaWNDbGFzcyhQbGFpblllYXJNb250aCwgJ1RlbXBvcmFsLlBsYWluWWVhck1vbnRoJyk7XG5cbmNvbnN0IEFycmF5UHJvdG90eXBlUHVzaCA9IEFycmF5LnByb3RvdHlwZS5wdXNoO1xuY2xhc3MgWm9uZWREYXRlVGltZSB7XG4gICAgY29uc3RydWN0b3IoZXBvY2hOYW5vc2Vjb25kc1BhcmFtLCB0aW1lWm9uZVBhcmFtLCBjYWxlbmRhclBhcmFtID0gR2V0SVNPODYwMUNhbGVuZGFyKCkpIHtcbiAgICAgICAgLy8gTm90ZTogaWYgdGhlIGFyZ3VtZW50IGlzIG5vdCBwYXNzZWQsIFRvQmlnSW50KHVuZGVmaW5lZCkgd2lsbCB0aHJvdy4gVGhpcyBjaGVjayBleGlzdHMgb25seVxuICAgICAgICAvLyAgICAgICB0byBpbXByb3ZlIHRoZSBlcnJvciBtZXNzYWdlLlxuICAgICAgICAvLyAgICAgICBUb1RlbXBvcmFsVGltZVpvbmUodW5kZWZpbmVkKSB3aWxsIGVuZCB1cCBjYWxsaW5nIFRpbWVab25lLmZyb20oXCJ1bmRlZmluZWRcIiksIHdoaWNoXG4gICAgICAgIC8vICAgICAgIGNvdWxkIHN1Y2NlZWQuXG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbWlzc2luZyBhcmd1bWVudDogZXBvY2hOYW5vc2Vjb25kcyBpcyByZXF1aXJlZCcpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVwb2NoTmFub3NlY29uZHMgPSBUb0JpZ0ludChlcG9jaE5hbm9zZWNvbmRzUGFyYW0pO1xuICAgICAgICBjb25zdCB0aW1lWm9uZSA9IFRvVGVtcG9yYWxUaW1lWm9uZSh0aW1lWm9uZVBhcmFtKTtcbiAgICAgICAgY29uc3QgY2FsZW5kYXIgPSBUb1RlbXBvcmFsQ2FsZW5kYXIoY2FsZW5kYXJQYXJhbSk7XG4gICAgICAgIENyZWF0ZVRlbXBvcmFsWm9uZWREYXRlVGltZVNsb3RzKHRoaXMsIGVwb2NoTmFub3NlY29uZHMsIHRpbWVab25lLCBjYWxlbmRhcik7XG4gICAgfVxuICAgIGdldCBjYWxlbmRhcigpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsWm9uZWREYXRlVGltZSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgcmV0dXJuIEdldFNsb3QodGhpcywgQ0FMRU5EQVIpO1xuICAgIH1cbiAgICBnZXQgdGltZVpvbmUoKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbFpvbmVkRGF0ZVRpbWUodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIHJldHVybiBHZXRTbG90KHRoaXMsIFRJTUVfWk9ORSk7XG4gICAgfVxuICAgIGdldCB5ZWFyKCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxab25lZERhdGVUaW1lKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICByZXR1cm4gQ2FsZW5kYXJZZWFyKEdldFNsb3QodGhpcywgQ0FMRU5EQVIpLCBkYXRlVGltZSh0aGlzKSk7XG4gICAgfVxuICAgIGdldCBtb250aCgpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsWm9uZWREYXRlVGltZSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgcmV0dXJuIENhbGVuZGFyTW9udGgoR2V0U2xvdCh0aGlzLCBDQUxFTkRBUiksIGRhdGVUaW1lKHRoaXMpKTtcbiAgICB9XG4gICAgZ2V0IG1vbnRoQ29kZSgpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsWm9uZWREYXRlVGltZSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgcmV0dXJuIENhbGVuZGFyTW9udGhDb2RlKEdldFNsb3QodGhpcywgQ0FMRU5EQVIpLCBkYXRlVGltZSh0aGlzKSk7XG4gICAgfVxuICAgIGdldCBkYXkoKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbFpvbmVkRGF0ZVRpbWUodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIHJldHVybiBDYWxlbmRhckRheShHZXRTbG90KHRoaXMsIENBTEVOREFSKSwgZGF0ZVRpbWUodGhpcykpO1xuICAgIH1cbiAgICBnZXQgaG91cigpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsWm9uZWREYXRlVGltZSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgcmV0dXJuIEdldFNsb3QoZGF0ZVRpbWUodGhpcyksIElTT19IT1VSKTtcbiAgICB9XG4gICAgZ2V0IG1pbnV0ZSgpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsWm9uZWREYXRlVGltZSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgcmV0dXJuIEdldFNsb3QoZGF0ZVRpbWUodGhpcyksIElTT19NSU5VVEUpO1xuICAgIH1cbiAgICBnZXQgc2Vjb25kKCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxab25lZERhdGVUaW1lKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICByZXR1cm4gR2V0U2xvdChkYXRlVGltZSh0aGlzKSwgSVNPX1NFQ09ORCk7XG4gICAgfVxuICAgIGdldCBtaWxsaXNlY29uZCgpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsWm9uZWREYXRlVGltZSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgcmV0dXJuIEdldFNsb3QoZGF0ZVRpbWUodGhpcyksIElTT19NSUxMSVNFQ09ORCk7XG4gICAgfVxuICAgIGdldCBtaWNyb3NlY29uZCgpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsWm9uZWREYXRlVGltZSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgcmV0dXJuIEdldFNsb3QoZGF0ZVRpbWUodGhpcyksIElTT19NSUNST1NFQ09ORCk7XG4gICAgfVxuICAgIGdldCBuYW5vc2Vjb25kKCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxab25lZERhdGVUaW1lKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICByZXR1cm4gR2V0U2xvdChkYXRlVGltZSh0aGlzKSwgSVNPX05BTk9TRUNPTkQpO1xuICAgIH1cbiAgICBnZXQgZXJhKCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxab25lZERhdGVUaW1lKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICByZXR1cm4gQ2FsZW5kYXJFcmEoR2V0U2xvdCh0aGlzLCBDQUxFTkRBUiksIGRhdGVUaW1lKHRoaXMpKTtcbiAgICB9XG4gICAgZ2V0IGVyYVllYXIoKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbFpvbmVkRGF0ZVRpbWUodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIHJldHVybiBDYWxlbmRhckVyYVllYXIoR2V0U2xvdCh0aGlzLCBDQUxFTkRBUiksIGRhdGVUaW1lKHRoaXMpKTtcbiAgICB9XG4gICAgZ2V0IGVwb2NoU2Vjb25kcygpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsWm9uZWREYXRlVGltZSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBHZXRTbG90KHRoaXMsIEVQT0NITkFOT1NFQ09ORFMpO1xuICAgICAgICByZXR1cm4gSlNCSS50b051bWJlcihKU0JJLmRpdmlkZSh2YWx1ZSwgQklMTElPTikpO1xuICAgIH1cbiAgICBnZXQgZXBvY2hNaWxsaXNlY29uZHMoKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbFpvbmVkRGF0ZVRpbWUodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gR2V0U2xvdCh0aGlzLCBFUE9DSE5BTk9TRUNPTkRTKTtcbiAgICAgICAgcmV0dXJuIEpTQkkudG9OdW1iZXIoSlNCSS5kaXZpZGUodmFsdWUsIE1JTExJT04pKTtcbiAgICB9XG4gICAgZ2V0IGVwb2NoTWljcm9zZWNvbmRzKCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxab25lZERhdGVUaW1lKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IEdldFNsb3QodGhpcywgRVBPQ0hOQU5PU0VDT05EUyk7XG4gICAgICAgIHJldHVybiBUb0JpZ0ludEV4dGVybmFsKEpTQkkuZGl2aWRlKHZhbHVlLCBUSE9VU0FORCkpO1xuICAgIH1cbiAgICBnZXQgZXBvY2hOYW5vc2Vjb25kcygpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsWm9uZWREYXRlVGltZSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgcmV0dXJuIFRvQmlnSW50RXh0ZXJuYWwoR2V0U2xvdCh0aGlzLCBFUE9DSE5BTk9TRUNPTkRTKSk7XG4gICAgfVxuICAgIGdldCBkYXlPZldlZWsoKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbFpvbmVkRGF0ZVRpbWUodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIHJldHVybiBDYWxlbmRhckRheU9mV2VlayhHZXRTbG90KHRoaXMsIENBTEVOREFSKSwgZGF0ZVRpbWUodGhpcykpO1xuICAgIH1cbiAgICBnZXQgZGF5T2ZZZWFyKCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxab25lZERhdGVUaW1lKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICByZXR1cm4gQ2FsZW5kYXJEYXlPZlllYXIoR2V0U2xvdCh0aGlzLCBDQUxFTkRBUiksIGRhdGVUaW1lKHRoaXMpKTtcbiAgICB9XG4gICAgZ2V0IHdlZWtPZlllYXIoKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbFpvbmVkRGF0ZVRpbWUodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIHJldHVybiBDYWxlbmRhcldlZWtPZlllYXIoR2V0U2xvdCh0aGlzLCBDQUxFTkRBUiksIGRhdGVUaW1lKHRoaXMpKTtcbiAgICB9XG4gICAgZ2V0IGhvdXJzSW5EYXkoKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbFpvbmVkRGF0ZVRpbWUodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIGNvbnN0IGR0ID0gZGF0ZVRpbWUodGhpcyk7XG4gICAgICAgIGNvbnN0IERhdGVUaW1lID0gR2V0SW50cmluc2ljKCclVGVtcG9yYWwuUGxhaW5EYXRlVGltZSUnKTtcbiAgICAgICAgY29uc3QgeWVhciA9IEdldFNsb3QoZHQsIElTT19ZRUFSKTtcbiAgICAgICAgY29uc3QgbW9udGggPSBHZXRTbG90KGR0LCBJU09fTU9OVEgpO1xuICAgICAgICBjb25zdCBkYXkgPSBHZXRTbG90KGR0LCBJU09fREFZKTtcbiAgICAgICAgY29uc3QgdG9kYXkgPSBuZXcgRGF0ZVRpbWUoeWVhciwgbW9udGgsIGRheSwgMCwgMCwgMCwgMCwgMCwgMCk7XG4gICAgICAgIGNvbnN0IHRvbW9ycm93RmllbGRzID0gQWRkSVNPRGF0ZSh5ZWFyLCBtb250aCwgZGF5LCAwLCAwLCAwLCAxLCAncmVqZWN0Jyk7XG4gICAgICAgIGNvbnN0IHRvbW9ycm93ID0gbmV3IERhdGVUaW1lKHRvbW9ycm93RmllbGRzLnllYXIsIHRvbW9ycm93RmllbGRzLm1vbnRoLCB0b21vcnJvd0ZpZWxkcy5kYXksIDAsIDAsIDAsIDAsIDAsIDApO1xuICAgICAgICBjb25zdCB0aW1lWm9uZSA9IEdldFNsb3QodGhpcywgVElNRV9aT05FKTtcbiAgICAgICAgY29uc3QgdG9kYXlOcyA9IEdldFNsb3QoQnVpbHRpblRpbWVab25lR2V0SW5zdGFudEZvcih0aW1lWm9uZSwgdG9kYXksICdjb21wYXRpYmxlJyksIEVQT0NITkFOT1NFQ09ORFMpO1xuICAgICAgICBjb25zdCB0b21vcnJvd05zID0gR2V0U2xvdChCdWlsdGluVGltZVpvbmVHZXRJbnN0YW50Rm9yKHRpbWVab25lLCB0b21vcnJvdywgJ2NvbXBhdGlibGUnKSwgRVBPQ0hOQU5PU0VDT05EUyk7XG4gICAgICAgIHJldHVybiBKU0JJLnRvTnVtYmVyKEpTQkkuc3VidHJhY3QodG9tb3Jyb3dOcywgdG9kYXlOcykpIC8gMy42ZTEyO1xuICAgIH1cbiAgICBnZXQgZGF5c0luV2VlaygpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsWm9uZWREYXRlVGltZSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgcmV0dXJuIENhbGVuZGFyRGF5c0luV2VlayhHZXRTbG90KHRoaXMsIENBTEVOREFSKSwgZGF0ZVRpbWUodGhpcykpO1xuICAgIH1cbiAgICBnZXQgZGF5c0luTW9udGgoKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbFpvbmVkRGF0ZVRpbWUodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIHJldHVybiBDYWxlbmRhckRheXNJbk1vbnRoKEdldFNsb3QodGhpcywgQ0FMRU5EQVIpLCBkYXRlVGltZSh0aGlzKSk7XG4gICAgfVxuICAgIGdldCBkYXlzSW5ZZWFyKCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxab25lZERhdGVUaW1lKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICByZXR1cm4gQ2FsZW5kYXJEYXlzSW5ZZWFyKEdldFNsb3QodGhpcywgQ0FMRU5EQVIpLCBkYXRlVGltZSh0aGlzKSk7XG4gICAgfVxuICAgIGdldCBtb250aHNJblllYXIoKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbFpvbmVkRGF0ZVRpbWUodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIHJldHVybiBDYWxlbmRhck1vbnRoc0luWWVhcihHZXRTbG90KHRoaXMsIENBTEVOREFSKSwgZGF0ZVRpbWUodGhpcykpO1xuICAgIH1cbiAgICBnZXQgaW5MZWFwWWVhcigpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsWm9uZWREYXRlVGltZSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgcmV0dXJuIENhbGVuZGFySW5MZWFwWWVhcihHZXRTbG90KHRoaXMsIENBTEVOREFSKSwgZGF0ZVRpbWUodGhpcykpO1xuICAgIH1cbiAgICBnZXQgb2Zmc2V0KCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxab25lZERhdGVUaW1lKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICByZXR1cm4gQnVpbHRpblRpbWVab25lR2V0T2Zmc2V0U3RyaW5nRm9yKEdldFNsb3QodGhpcywgVElNRV9aT05FKSwgR2V0U2xvdCh0aGlzLCBJTlNUQU5UKSk7XG4gICAgfVxuICAgIGdldCBvZmZzZXROYW5vc2Vjb25kcygpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsWm9uZWREYXRlVGltZSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgcmV0dXJuIEdldE9mZnNldE5hbm9zZWNvbmRzRm9yKEdldFNsb3QodGhpcywgVElNRV9aT05FKSwgR2V0U2xvdCh0aGlzLCBJTlNUQU5UKSk7XG4gICAgfVxuICAgIHdpdGgodGVtcG9yYWxab25lZERhdGVUaW1lTGlrZSwgb3B0aW9uc1BhcmFtID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbFpvbmVkRGF0ZVRpbWUodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIGlmICghSXNPYmplY3QodGVtcG9yYWxab25lZERhdGVUaW1lTGlrZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgem9uZWQtZGF0ZS10aW1lLWxpa2UnKTtcbiAgICAgICAgfVxuICAgICAgICBSZWplY3RPYmplY3RXaXRoQ2FsZW5kYXJPclRpbWVab25lKHRlbXBvcmFsWm9uZWREYXRlVGltZUxpa2UpO1xuICAgICAgICBjb25zdCBvcHRpb25zID0gR2V0T3B0aW9uc09iamVjdChvcHRpb25zUGFyYW0pO1xuICAgICAgICBjb25zdCBkaXNhbWJpZ3VhdGlvbiA9IFRvVGVtcG9yYWxEaXNhbWJpZ3VhdGlvbihvcHRpb25zKTtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gVG9UZW1wb3JhbE9mZnNldChvcHRpb25zLCAncHJlZmVyJyk7XG4gICAgICAgIGNvbnN0IHRpbWVab25lID0gR2V0U2xvdCh0aGlzLCBUSU1FX1pPTkUpO1xuICAgICAgICBjb25zdCBjYWxlbmRhciA9IEdldFNsb3QodGhpcywgQ0FMRU5EQVIpO1xuICAgICAgICBjb25zdCBmaWVsZE5hbWVzID0gQ2FsZW5kYXJGaWVsZHMoY2FsZW5kYXIsIFtcbiAgICAgICAgICAgICdkYXknLFxuICAgICAgICAgICAgJ2hvdXInLFxuICAgICAgICAgICAgJ21pY3Jvc2Vjb25kJyxcbiAgICAgICAgICAgICdtaWxsaXNlY29uZCcsXG4gICAgICAgICAgICAnbWludXRlJyxcbiAgICAgICAgICAgICdtb250aCcsXG4gICAgICAgICAgICAnbW9udGhDb2RlJyxcbiAgICAgICAgICAgICduYW5vc2Vjb25kJyxcbiAgICAgICAgICAgICdzZWNvbmQnLFxuICAgICAgICAgICAgJ3llYXInXG4gICAgICAgIF0pO1xuICAgICAgICBBcnJheVByb3RvdHlwZVB1c2guY2FsbChmaWVsZE5hbWVzLCAnb2Zmc2V0Jyk7XG4gICAgICAgIGNvbnN0IHByb3BzID0gVG9QYXJ0aWFsUmVjb3JkKHRlbXBvcmFsWm9uZWREYXRlVGltZUxpa2UsIGZpZWxkTmFtZXMpO1xuICAgICAgICBpZiAoIXByb3BzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHpvbmVkLWRhdGUtdGltZS1saWtlJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVW5saWtlIFRvVGVtcG9yYWxab25lZERhdGVUaW1lRmllbGRzLCB0aGUgb2Zmc2V0IHByb3BlcnR5IHdpbGwgYmUgcmVxdWlyZWQuXG4gICAgICAgIGNvbnN0IGVudHJpZXMgPSBbXG4gICAgICAgICAgICBbJ2RheScsIHVuZGVmaW5lZF0sXG4gICAgICAgICAgICBbJ2hvdXInLCAwXSxcbiAgICAgICAgICAgIFsnbWljcm9zZWNvbmQnLCAwXSxcbiAgICAgICAgICAgIFsnbWlsbGlzZWNvbmQnLCAwXSxcbiAgICAgICAgICAgIFsnbWludXRlJywgMF0sXG4gICAgICAgICAgICBbJ21vbnRoJywgdW5kZWZpbmVkXSxcbiAgICAgICAgICAgIFsnbW9udGhDb2RlJywgdW5kZWZpbmVkXSxcbiAgICAgICAgICAgIFsnbmFub3NlY29uZCcsIDBdLFxuICAgICAgICAgICAgWydzZWNvbmQnLCAwXSxcbiAgICAgICAgICAgIFsneWVhcicsIHVuZGVmaW5lZF0sXG4gICAgICAgICAgICBbJ29mZnNldCddLFxuICAgICAgICAgICAgWyd0aW1lWm9uZSddXG4gICAgICAgIF07XG4gICAgICAgIC8vIEFkZCBleHRyYSBmaWVsZHMgZnJvbSB0aGUgY2FsZW5kYXIgYXQgdGhlIGVuZFxuICAgICAgICBmaWVsZE5hbWVzLmZvckVhY2goKGZpZWxkTmFtZSkgPT4ge1xuICAgICAgICAgICAgaWYgKCFlbnRyaWVzLnNvbWUoKFtuYW1lXSkgPT4gbmFtZSA9PT0gZmllbGROYW1lKSkge1xuICAgICAgICAgICAgICAgIGVudHJpZXMucHVzaChbZmllbGROYW1lLCB1bmRlZmluZWRdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGxldCBmaWVsZHMgPSBQcmVwYXJlVGVtcG9yYWxGaWVsZHModGhpcywgZW50cmllcyk7XG4gICAgICAgIGZpZWxkcyA9IENhbGVuZGFyTWVyZ2VGaWVsZHMoY2FsZW5kYXIsIGZpZWxkcywgcHJvcHMpO1xuICAgICAgICBmaWVsZHMgPSBQcmVwYXJlVGVtcG9yYWxGaWVsZHMoZmllbGRzLCBlbnRyaWVzKTtcbiAgICAgICAgY29uc3QgeyB5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQsIG1pY3Jvc2Vjb25kLCBuYW5vc2Vjb25kIH0gPSBJbnRlcnByZXRUZW1wb3JhbERhdGVUaW1lRmllbGRzKGNhbGVuZGFyLCBmaWVsZHMsIG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBvZmZzZXROcyA9IFBhcnNlVGltZVpvbmVPZmZzZXRTdHJpbmcoZmllbGRzLm9mZnNldCk7XG4gICAgICAgIGNvbnN0IGVwb2NoTmFub3NlY29uZHMgPSBJbnRlcnByZXRJU09EYXRlVGltZU9mZnNldCh5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQsIG1pY3Jvc2Vjb25kLCBuYW5vc2Vjb25kLCAnb3B0aW9uJywgb2Zmc2V0TnMsIHRpbWVab25lLCBkaXNhbWJpZ3VhdGlvbiwgb2Zmc2V0LCBcbiAgICAgICAgLyogbWF0Y2hNaW51dGUgPSAqLyBmYWxzZSk7XG4gICAgICAgIHJldHVybiBDcmVhdGVUZW1wb3JhbFpvbmVkRGF0ZVRpbWUoZXBvY2hOYW5vc2Vjb25kcywgR2V0U2xvdCh0aGlzLCBUSU1FX1pPTkUpLCBjYWxlbmRhcik7XG4gICAgfVxuICAgIHdpdGhQbGFpbkRhdGUodGVtcG9yYWxEYXRlUGFyYW0pIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsWm9uZWREYXRlVGltZSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgY29uc3QgdGVtcG9yYWxEYXRlID0gVG9UZW1wb3JhbERhdGUodGVtcG9yYWxEYXRlUGFyYW0pO1xuICAgICAgICBjb25zdCB5ZWFyID0gR2V0U2xvdCh0ZW1wb3JhbERhdGUsIElTT19ZRUFSKTtcbiAgICAgICAgY29uc3QgbW9udGggPSBHZXRTbG90KHRlbXBvcmFsRGF0ZSwgSVNPX01PTlRIKTtcbiAgICAgICAgY29uc3QgZGF5ID0gR2V0U2xvdCh0ZW1wb3JhbERhdGUsIElTT19EQVkpO1xuICAgICAgICBsZXQgY2FsZW5kYXIgPSBHZXRTbG90KHRlbXBvcmFsRGF0ZSwgQ0FMRU5EQVIpO1xuICAgICAgICBjb25zdCB0aGlzRHQgPSBkYXRlVGltZSh0aGlzKTtcbiAgICAgICAgY29uc3QgaG91ciA9IEdldFNsb3QodGhpc0R0LCBJU09fSE9VUik7XG4gICAgICAgIGNvbnN0IG1pbnV0ZSA9IEdldFNsb3QodGhpc0R0LCBJU09fTUlOVVRFKTtcbiAgICAgICAgY29uc3Qgc2Vjb25kID0gR2V0U2xvdCh0aGlzRHQsIElTT19TRUNPTkQpO1xuICAgICAgICBjb25zdCBtaWxsaXNlY29uZCA9IEdldFNsb3QodGhpc0R0LCBJU09fTUlMTElTRUNPTkQpO1xuICAgICAgICBjb25zdCBtaWNyb3NlY29uZCA9IEdldFNsb3QodGhpc0R0LCBJU09fTUlDUk9TRUNPTkQpO1xuICAgICAgICBjb25zdCBuYW5vc2Vjb25kID0gR2V0U2xvdCh0aGlzRHQsIElTT19OQU5PU0VDT05EKTtcbiAgICAgICAgY2FsZW5kYXIgPSBDb25zb2xpZGF0ZUNhbGVuZGFycyhHZXRTbG90KHRoaXMsIENBTEVOREFSKSwgY2FsZW5kYXIpO1xuICAgICAgICBjb25zdCB0aW1lWm9uZSA9IEdldFNsb3QodGhpcywgVElNRV9aT05FKTtcbiAgICAgICAgY29uc3QgUGxhaW5EYXRlVGltZSA9IEdldEludHJpbnNpYygnJVRlbXBvcmFsLlBsYWluRGF0ZVRpbWUlJyk7XG4gICAgICAgIGNvbnN0IGR0ID0gbmV3IFBsYWluRGF0ZVRpbWUoeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kLCBtaWNyb3NlY29uZCwgbmFub3NlY29uZCwgY2FsZW5kYXIpO1xuICAgICAgICBjb25zdCBpbnN0YW50ID0gQnVpbHRpblRpbWVab25lR2V0SW5zdGFudEZvcih0aW1lWm9uZSwgZHQsICdjb21wYXRpYmxlJyk7XG4gICAgICAgIHJldHVybiBDcmVhdGVUZW1wb3JhbFpvbmVkRGF0ZVRpbWUoR2V0U2xvdChpbnN0YW50LCBFUE9DSE5BTk9TRUNPTkRTKSwgdGltZVpvbmUsIGNhbGVuZGFyKTtcbiAgICB9XG4gICAgd2l0aFBsYWluVGltZSh0ZW1wb3JhbFRpbWVQYXJhbSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxab25lZERhdGVUaW1lKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICBjb25zdCBQbGFpblRpbWUgPSBHZXRJbnRyaW5zaWMoJyVUZW1wb3JhbC5QbGFpblRpbWUlJyk7XG4gICAgICAgIGNvbnN0IHRlbXBvcmFsVGltZSA9IHRlbXBvcmFsVGltZVBhcmFtID09IHVuZGVmaW5lZCA/IG5ldyBQbGFpblRpbWUoKSA6IFRvVGVtcG9yYWxUaW1lKHRlbXBvcmFsVGltZVBhcmFtKTtcbiAgICAgICAgY29uc3QgdGhpc0R0ID0gZGF0ZVRpbWUodGhpcyk7XG4gICAgICAgIGNvbnN0IHllYXIgPSBHZXRTbG90KHRoaXNEdCwgSVNPX1lFQVIpO1xuICAgICAgICBjb25zdCBtb250aCA9IEdldFNsb3QodGhpc0R0LCBJU09fTU9OVEgpO1xuICAgICAgICBjb25zdCBkYXkgPSBHZXRTbG90KHRoaXNEdCwgSVNPX0RBWSk7XG4gICAgICAgIGNvbnN0IGNhbGVuZGFyID0gR2V0U2xvdCh0aGlzLCBDQUxFTkRBUik7XG4gICAgICAgIGNvbnN0IGhvdXIgPSBHZXRTbG90KHRlbXBvcmFsVGltZSwgSVNPX0hPVVIpO1xuICAgICAgICBjb25zdCBtaW51dGUgPSBHZXRTbG90KHRlbXBvcmFsVGltZSwgSVNPX01JTlVURSk7XG4gICAgICAgIGNvbnN0IHNlY29uZCA9IEdldFNsb3QodGVtcG9yYWxUaW1lLCBJU09fU0VDT05EKTtcbiAgICAgICAgY29uc3QgbWlsbGlzZWNvbmQgPSBHZXRTbG90KHRlbXBvcmFsVGltZSwgSVNPX01JTExJU0VDT05EKTtcbiAgICAgICAgY29uc3QgbWljcm9zZWNvbmQgPSBHZXRTbG90KHRlbXBvcmFsVGltZSwgSVNPX01JQ1JPU0VDT05EKTtcbiAgICAgICAgY29uc3QgbmFub3NlY29uZCA9IEdldFNsb3QodGVtcG9yYWxUaW1lLCBJU09fTkFOT1NFQ09ORCk7XG4gICAgICAgIGNvbnN0IHRpbWVab25lID0gR2V0U2xvdCh0aGlzLCBUSU1FX1pPTkUpO1xuICAgICAgICBjb25zdCBQbGFpbkRhdGVUaW1lID0gR2V0SW50cmluc2ljKCclVGVtcG9yYWwuUGxhaW5EYXRlVGltZSUnKTtcbiAgICAgICAgY29uc3QgZHQgPSBuZXcgUGxhaW5EYXRlVGltZSh5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQsIG1pY3Jvc2Vjb25kLCBuYW5vc2Vjb25kLCBjYWxlbmRhcik7XG4gICAgICAgIGNvbnN0IGluc3RhbnQgPSBCdWlsdGluVGltZVpvbmVHZXRJbnN0YW50Rm9yKHRpbWVab25lLCBkdCwgJ2NvbXBhdGlibGUnKTtcbiAgICAgICAgcmV0dXJuIENyZWF0ZVRlbXBvcmFsWm9uZWREYXRlVGltZShHZXRTbG90KGluc3RhbnQsIEVQT0NITkFOT1NFQ09ORFMpLCB0aW1lWm9uZSwgY2FsZW5kYXIpO1xuICAgIH1cbiAgICB3aXRoVGltZVpvbmUodGltZVpvbmVQYXJhbSkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxab25lZERhdGVUaW1lKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICBjb25zdCB0aW1lWm9uZSA9IFRvVGVtcG9yYWxUaW1lWm9uZSh0aW1lWm9uZVBhcmFtKTtcbiAgICAgICAgcmV0dXJuIENyZWF0ZVRlbXBvcmFsWm9uZWREYXRlVGltZShHZXRTbG90KHRoaXMsIEVQT0NITkFOT1NFQ09ORFMpLCB0aW1lWm9uZSwgR2V0U2xvdCh0aGlzLCBDQUxFTkRBUikpO1xuICAgIH1cbiAgICB3aXRoQ2FsZW5kYXIoY2FsZW5kYXJQYXJhbSkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxab25lZERhdGVUaW1lKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICBjb25zdCBjYWxlbmRhciA9IFRvVGVtcG9yYWxDYWxlbmRhcihjYWxlbmRhclBhcmFtKTtcbiAgICAgICAgcmV0dXJuIENyZWF0ZVRlbXBvcmFsWm9uZWREYXRlVGltZShHZXRTbG90KHRoaXMsIEVQT0NITkFOT1NFQ09ORFMpLCBHZXRTbG90KHRoaXMsIFRJTUVfWk9ORSksIGNhbGVuZGFyKTtcbiAgICB9XG4gICAgYWRkKHRlbXBvcmFsRHVyYXRpb25MaWtlLCBvcHRpb25zUGFyYW0gPSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsWm9uZWREYXRlVGltZSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgY29uc3QgZHVyYXRpb24gPSBUb0xpbWl0ZWRUZW1wb3JhbER1cmF0aW9uKHRlbXBvcmFsRHVyYXRpb25MaWtlKTtcbiAgICAgICAgY29uc3QgeyB5ZWFycywgbW9udGhzLCB3ZWVrcywgZGF5cywgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc2Vjb25kcywgbWljcm9zZWNvbmRzLCBuYW5vc2Vjb25kcyB9ID0gZHVyYXRpb247XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSBHZXRPcHRpb25zT2JqZWN0KG9wdGlvbnNQYXJhbSk7XG4gICAgICAgIGNvbnN0IHRpbWVab25lID0gR2V0U2xvdCh0aGlzLCBUSU1FX1pPTkUpO1xuICAgICAgICBjb25zdCBjYWxlbmRhciA9IEdldFNsb3QodGhpcywgQ0FMRU5EQVIpO1xuICAgICAgICBjb25zdCBlcG9jaE5hbm9zZWNvbmRzID0gQWRkWm9uZWREYXRlVGltZShHZXRTbG90KHRoaXMsIElOU1RBTlQpLCB0aW1lWm9uZSwgY2FsZW5kYXIsIHllYXJzLCBtb250aHMsIHdlZWtzLCBkYXlzLCBob3VycywgbWludXRlcywgc2Vjb25kcywgbWlsbGlzZWNvbmRzLCBtaWNyb3NlY29uZHMsIG5hbm9zZWNvbmRzLCBvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIENyZWF0ZVRlbXBvcmFsWm9uZWREYXRlVGltZShlcG9jaE5hbm9zZWNvbmRzLCB0aW1lWm9uZSwgY2FsZW5kYXIpO1xuICAgIH1cbiAgICBzdWJ0cmFjdCh0ZW1wb3JhbER1cmF0aW9uTGlrZSwgb3B0aW9uc1BhcmFtID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbFpvbmVkRGF0ZVRpbWUodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIGNvbnN0IGR1cmF0aW9uID0gVG9MaW1pdGVkVGVtcG9yYWxEdXJhdGlvbih0ZW1wb3JhbER1cmF0aW9uTGlrZSk7XG4gICAgICAgIGNvbnN0IHsgeWVhcnMsIG1vbnRocywgd2Vla3MsIGRheXMsIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBtaWxsaXNlY29uZHMsIG1pY3Jvc2Vjb25kcywgbmFub3NlY29uZHMgfSA9IGR1cmF0aW9uO1xuICAgICAgICBjb25zdCBvcHRpb25zID0gR2V0T3B0aW9uc09iamVjdChvcHRpb25zUGFyYW0pO1xuICAgICAgICBjb25zdCB0aW1lWm9uZSA9IEdldFNsb3QodGhpcywgVElNRV9aT05FKTtcbiAgICAgICAgY29uc3QgY2FsZW5kYXIgPSBHZXRTbG90KHRoaXMsIENBTEVOREFSKTtcbiAgICAgICAgY29uc3QgZXBvY2hOYW5vc2Vjb25kcyA9IEFkZFpvbmVkRGF0ZVRpbWUoR2V0U2xvdCh0aGlzLCBJTlNUQU5UKSwgdGltZVpvbmUsIGNhbGVuZGFyLCAteWVhcnMsIC1tb250aHMsIC13ZWVrcywgLWRheXMsIC1ob3VycywgLW1pbnV0ZXMsIC1zZWNvbmRzLCAtbWlsbGlzZWNvbmRzLCAtbWljcm9zZWNvbmRzLCAtbmFub3NlY29uZHMsIG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gQ3JlYXRlVGVtcG9yYWxab25lZERhdGVUaW1lKGVwb2NoTmFub3NlY29uZHMsIHRpbWVab25lLCBjYWxlbmRhcik7XG4gICAgfVxuICAgIHVudGlsKG90aGVyUGFyYW0sIG9wdGlvbnNQYXJhbSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxab25lZERhdGVUaW1lKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICBjb25zdCBvdGhlciA9IFRvVGVtcG9yYWxab25lZERhdGVUaW1lKG90aGVyUGFyYW0pO1xuICAgICAgICBjb25zdCBjYWxlbmRhciA9IEdldFNsb3QodGhpcywgQ0FMRU5EQVIpO1xuICAgICAgICBjb25zdCBvdGhlckNhbGVuZGFyID0gR2V0U2xvdChvdGhlciwgQ0FMRU5EQVIpO1xuICAgICAgICBjb25zdCBjYWxlbmRhcklkID0gVG9TdHJpbmcoY2FsZW5kYXIpO1xuICAgICAgICBjb25zdCBvdGhlckNhbGVuZGFySWQgPSBUb1N0cmluZyhvdGhlckNhbGVuZGFyKTtcbiAgICAgICAgaWYgKGNhbGVuZGFySWQgIT09IG90aGVyQ2FsZW5kYXJJZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYGNhbm5vdCBjb21wdXRlIGRpZmZlcmVuY2UgYmV0d2VlbiBkYXRlcyBvZiAke2NhbGVuZGFySWR9IGFuZCAke290aGVyQ2FsZW5kYXJJZH0gY2FsZW5kYXJzYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IEdldE9wdGlvbnNPYmplY3Qob3B0aW9uc1BhcmFtKTtcbiAgICAgICAgY29uc3Qgc21hbGxlc3RVbml0ID0gVG9TbWFsbGVzdFRlbXBvcmFsVW5pdChvcHRpb25zLCAnbmFub3NlY29uZCcpO1xuICAgICAgICBjb25zdCBkZWZhdWx0TGFyZ2VzdFVuaXQgPSBMYXJnZXJPZlR3b1RlbXBvcmFsVW5pdHMoJ2hvdXInLCBzbWFsbGVzdFVuaXQpO1xuICAgICAgICBjb25zdCBsYXJnZXN0VW5pdCA9IFRvTGFyZ2VzdFRlbXBvcmFsVW5pdChvcHRpb25zLCAnYXV0bycsIFtdLCBkZWZhdWx0TGFyZ2VzdFVuaXQpO1xuICAgICAgICBWYWxpZGF0ZVRlbXBvcmFsVW5pdFJhbmdlKGxhcmdlc3RVbml0LCBzbWFsbGVzdFVuaXQpO1xuICAgICAgICBjb25zdCByb3VuZGluZ01vZGUgPSBUb1RlbXBvcmFsUm91bmRpbmdNb2RlKG9wdGlvbnMsICd0cnVuYycpO1xuICAgICAgICBjb25zdCByb3VuZGluZ0luY3JlbWVudCA9IFRvVGVtcG9yYWxEYXRlVGltZVJvdW5kaW5nSW5jcmVtZW50KG9wdGlvbnMsIHNtYWxsZXN0VW5pdCk7XG4gICAgICAgIGNvbnN0IG5zMSA9IEdldFNsb3QodGhpcywgRVBPQ0hOQU5PU0VDT05EUyk7XG4gICAgICAgIGNvbnN0IG5zMiA9IEdldFNsb3Qob3RoZXIsIEVQT0NITkFOT1NFQ09ORFMpO1xuICAgICAgICBsZXQgeWVhcnMsIG1vbnRocywgd2Vla3MsIGRheXMsIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBtaWxsaXNlY29uZHMsIG1pY3Jvc2Vjb25kcywgbmFub3NlY29uZHM7XG4gICAgICAgIGlmIChsYXJnZXN0VW5pdCAhPT0gJ3llYXInICYmIGxhcmdlc3RVbml0ICE9PSAnbW9udGgnICYmIGxhcmdlc3RVbml0ICE9PSAnd2VlaycgJiYgbGFyZ2VzdFVuaXQgIT09ICdkYXknKSB7XG4gICAgICAgICAgICAvLyBUaGUgdXNlciBpcyBvbmx5IGFza2luZyBmb3IgYSB0aW1lIGRpZmZlcmVuY2UsIHNvIHJldHVybiBkaWZmZXJlbmNlIG9mIGluc3RhbnRzLlxuICAgICAgICAgICAgeWVhcnMgPSAwO1xuICAgICAgICAgICAgbW9udGhzID0gMDtcbiAgICAgICAgICAgIHdlZWtzID0gMDtcbiAgICAgICAgICAgIGRheXMgPSAwO1xuICAgICAgICAgICAgKHsgc2Vjb25kcywgbWlsbGlzZWNvbmRzLCBtaWNyb3NlY29uZHMsIG5hbm9zZWNvbmRzIH0gPSBEaWZmZXJlbmNlSW5zdGFudChuczEsIG5zMiwgcm91bmRpbmdJbmNyZW1lbnQsIHNtYWxsZXN0VW5pdCwgcm91bmRpbmdNb2RlKSk7XG4gICAgICAgICAgICAoeyBob3VycywgbWludXRlcywgc2Vjb25kcywgbWlsbGlzZWNvbmRzLCBtaWNyb3NlY29uZHMsIG5hbm9zZWNvbmRzIH0gPSBCYWxhbmNlRHVyYXRpb24oMCwgMCwgMCwgc2Vjb25kcywgbWlsbGlzZWNvbmRzLCBtaWNyb3NlY29uZHMsIG5hbm9zZWNvbmRzLCBsYXJnZXN0VW5pdCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgdGltZVpvbmUgPSBHZXRTbG90KHRoaXMsIFRJTUVfWk9ORSk7XG4gICAgICAgICAgICBpZiAoIVRpbWVab25lRXF1YWxzKHRpbWVab25lLCBHZXRTbG90KG90aGVyLCBUSU1FX1pPTkUpKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiV2hlbiBjYWxjdWxhdGluZyBkaWZmZXJlbmNlIGJldHdlZW4gdGltZSB6b25lcywgbGFyZ2VzdFVuaXQgbXVzdCBiZSAnaG91cnMnIFwiICtcbiAgICAgICAgICAgICAgICAgICAgJ29yIHNtYWxsZXIgYmVjYXVzZSBkYXkgbGVuZ3RocyBjYW4gdmFyeSBiZXR3ZWVuIHRpbWUgem9uZXMgZHVlIHRvIERTVCBvciB0aW1lIHpvbmUgb2Zmc2V0IGNoYW5nZXMuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB1bnRpbE9wdGlvbnMgPSB7IC4uLm9wdGlvbnMsIGxhcmdlc3RVbml0IH07XG4gICAgICAgICAgICAoeyB5ZWFycywgbW9udGhzLCB3ZWVrcywgZGF5cywgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc2Vjb25kcywgbWljcm9zZWNvbmRzLCBuYW5vc2Vjb25kcyB9ID1cbiAgICAgICAgICAgICAgICBEaWZmZXJlbmNlWm9uZWREYXRlVGltZShuczEsIG5zMiwgdGltZVpvbmUsIGNhbGVuZGFyLCBsYXJnZXN0VW5pdCwgdW50aWxPcHRpb25zKSk7XG4gICAgICAgICAgICAoeyB5ZWFycywgbW9udGhzLCB3ZWVrcywgZGF5cywgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc2Vjb25kcywgbWljcm9zZWNvbmRzLCBuYW5vc2Vjb25kcyB9ID1cbiAgICAgICAgICAgICAgICBSb3VuZER1cmF0aW9uKHllYXJzLCBtb250aHMsIHdlZWtzLCBkYXlzLCBob3VycywgbWludXRlcywgc2Vjb25kcywgbWlsbGlzZWNvbmRzLCBtaWNyb3NlY29uZHMsIG5hbm9zZWNvbmRzLCByb3VuZGluZ0luY3JlbWVudCwgc21hbGxlc3RVbml0LCByb3VuZGluZ01vZGUsIHRoaXMpKTtcbiAgICAgICAgICAgICh7IHllYXJzLCBtb250aHMsIHdlZWtzLCBkYXlzLCBob3VycywgbWludXRlcywgc2Vjb25kcywgbWlsbGlzZWNvbmRzLCBtaWNyb3NlY29uZHMsIG5hbm9zZWNvbmRzIH0gPVxuICAgICAgICAgICAgICAgIEFkanVzdFJvdW5kZWREdXJhdGlvbkRheXMoeWVhcnMsIG1vbnRocywgd2Vla3MsIGRheXMsIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBtaWxsaXNlY29uZHMsIG1pY3Jvc2Vjb25kcywgbmFub3NlY29uZHMsIHJvdW5kaW5nSW5jcmVtZW50LCBzbWFsbGVzdFVuaXQsIHJvdW5kaW5nTW9kZSwgdGhpcykpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IER1cmF0aW9uID0gR2V0SW50cmluc2ljKCclVGVtcG9yYWwuRHVyYXRpb24lJyk7XG4gICAgICAgIHJldHVybiBuZXcgRHVyYXRpb24oeWVhcnMsIG1vbnRocywgd2Vla3MsIGRheXMsIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBtaWxsaXNlY29uZHMsIG1pY3Jvc2Vjb25kcywgbmFub3NlY29uZHMpO1xuICAgIH1cbiAgICBzaW5jZShvdGhlclBhcmFtLCBvcHRpb25zUGFyYW0gPSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsWm9uZWREYXRlVGltZSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgY29uc3Qgb3RoZXIgPSBUb1RlbXBvcmFsWm9uZWREYXRlVGltZShvdGhlclBhcmFtKTtcbiAgICAgICAgY29uc3QgY2FsZW5kYXIgPSBHZXRTbG90KHRoaXMsIENBTEVOREFSKTtcbiAgICAgICAgY29uc3Qgb3RoZXJDYWxlbmRhciA9IEdldFNsb3Qob3RoZXIsIENBTEVOREFSKTtcbiAgICAgICAgY29uc3QgY2FsZW5kYXJJZCA9IFRvU3RyaW5nKGNhbGVuZGFyKTtcbiAgICAgICAgY29uc3Qgb3RoZXJDYWxlbmRhcklkID0gVG9TdHJpbmcob3RoZXJDYWxlbmRhcik7XG4gICAgICAgIGlmIChjYWxlbmRhcklkICE9PSBvdGhlckNhbGVuZGFySWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBjYW5ub3QgY29tcHV0ZSBkaWZmZXJlbmNlIGJldHdlZW4gZGF0ZXMgb2YgJHtjYWxlbmRhcklkfSBhbmQgJHtvdGhlckNhbGVuZGFySWR9IGNhbGVuZGFyc2ApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSBHZXRPcHRpb25zT2JqZWN0KG9wdGlvbnNQYXJhbSk7XG4gICAgICAgIGNvbnN0IHNtYWxsZXN0VW5pdCA9IFRvU21hbGxlc3RUZW1wb3JhbFVuaXQob3B0aW9ucywgJ25hbm9zZWNvbmQnKTtcbiAgICAgICAgY29uc3QgZGVmYXVsdExhcmdlc3RVbml0ID0gTGFyZ2VyT2ZUd29UZW1wb3JhbFVuaXRzKCdob3VyJywgc21hbGxlc3RVbml0KTtcbiAgICAgICAgY29uc3QgbGFyZ2VzdFVuaXQgPSBUb0xhcmdlc3RUZW1wb3JhbFVuaXQob3B0aW9ucywgJ2F1dG8nLCBbXSwgZGVmYXVsdExhcmdlc3RVbml0KTtcbiAgICAgICAgVmFsaWRhdGVUZW1wb3JhbFVuaXRSYW5nZShsYXJnZXN0VW5pdCwgc21hbGxlc3RVbml0KTtcbiAgICAgICAgbGV0IHJvdW5kaW5nTW9kZSA9IFRvVGVtcG9yYWxSb3VuZGluZ01vZGUob3B0aW9ucywgJ3RydW5jJyk7XG4gICAgICAgIHJvdW5kaW5nTW9kZSA9IE5lZ2F0ZVRlbXBvcmFsUm91bmRpbmdNb2RlKHJvdW5kaW5nTW9kZSk7XG4gICAgICAgIGNvbnN0IHJvdW5kaW5nSW5jcmVtZW50ID0gVG9UZW1wb3JhbERhdGVUaW1lUm91bmRpbmdJbmNyZW1lbnQob3B0aW9ucywgc21hbGxlc3RVbml0KTtcbiAgICAgICAgY29uc3QgbnMxID0gR2V0U2xvdCh0aGlzLCBFUE9DSE5BTk9TRUNPTkRTKTtcbiAgICAgICAgY29uc3QgbnMyID0gR2V0U2xvdChvdGhlciwgRVBPQ0hOQU5PU0VDT05EUyk7XG4gICAgICAgIGxldCB5ZWFycywgbW9udGhzLCB3ZWVrcywgZGF5cywgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc2Vjb25kcywgbWljcm9zZWNvbmRzLCBuYW5vc2Vjb25kcztcbiAgICAgICAgaWYgKGxhcmdlc3RVbml0ICE9PSAneWVhcicgJiYgbGFyZ2VzdFVuaXQgIT09ICdtb250aCcgJiYgbGFyZ2VzdFVuaXQgIT09ICd3ZWVrJyAmJiBsYXJnZXN0VW5pdCAhPT0gJ2RheScpIHtcbiAgICAgICAgICAgIC8vIFRoZSB1c2VyIGlzIG9ubHkgYXNraW5nIGZvciBhIHRpbWUgZGlmZmVyZW5jZSwgc28gcmV0dXJuIGRpZmZlcmVuY2Ugb2YgaW5zdGFudHMuXG4gICAgICAgICAgICB5ZWFycyA9IDA7XG4gICAgICAgICAgICBtb250aHMgPSAwO1xuICAgICAgICAgICAgd2Vla3MgPSAwO1xuICAgICAgICAgICAgZGF5cyA9IDA7XG4gICAgICAgICAgICAoeyBzZWNvbmRzLCBtaWxsaXNlY29uZHMsIG1pY3Jvc2Vjb25kcywgbmFub3NlY29uZHMgfSA9IERpZmZlcmVuY2VJbnN0YW50KG5zMSwgbnMyLCByb3VuZGluZ0luY3JlbWVudCwgc21hbGxlc3RVbml0LCByb3VuZGluZ01vZGUpKTtcbiAgICAgICAgICAgICh7IGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBtaWxsaXNlY29uZHMsIG1pY3Jvc2Vjb25kcywgbmFub3NlY29uZHMgfSA9IEJhbGFuY2VEdXJhdGlvbigwLCAwLCAwLCBzZWNvbmRzLCBtaWxsaXNlY29uZHMsIG1pY3Jvc2Vjb25kcywgbmFub3NlY29uZHMsIGxhcmdlc3RVbml0KSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCB0aW1lWm9uZSA9IEdldFNsb3QodGhpcywgVElNRV9aT05FKTtcbiAgICAgICAgICAgIGlmICghVGltZVpvbmVFcXVhbHModGltZVpvbmUsIEdldFNsb3Qob3RoZXIsIFRJTUVfWk9ORSkpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJXaGVuIGNhbGN1bGF0aW5nIGRpZmZlcmVuY2UgYmV0d2VlbiB0aW1lIHpvbmVzLCBsYXJnZXN0VW5pdCBtdXN0IGJlICdob3VycycgXCIgK1xuICAgICAgICAgICAgICAgICAgICAnb3Igc21hbGxlciBiZWNhdXNlIGRheSBsZW5ndGhzIGNhbiB2YXJ5IGJldHdlZW4gdGltZSB6b25lcyBkdWUgdG8gRFNUIG9yIHRpbWUgem9uZSBvZmZzZXQgY2hhbmdlcy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHVudGlsT3B0aW9ucyA9IHsgLi4ub3B0aW9ucywgbGFyZ2VzdFVuaXQgfTtcbiAgICAgICAgICAgICh7IHllYXJzLCBtb250aHMsIHdlZWtzLCBkYXlzLCBob3VycywgbWludXRlcywgc2Vjb25kcywgbWlsbGlzZWNvbmRzLCBtaWNyb3NlY29uZHMsIG5hbm9zZWNvbmRzIH0gPVxuICAgICAgICAgICAgICAgIERpZmZlcmVuY2Vab25lZERhdGVUaW1lKG5zMSwgbnMyLCB0aW1lWm9uZSwgY2FsZW5kYXIsIGxhcmdlc3RVbml0LCB1bnRpbE9wdGlvbnMpKTtcbiAgICAgICAgICAgICh7IHllYXJzLCBtb250aHMsIHdlZWtzLCBkYXlzLCBob3VycywgbWludXRlcywgc2Vjb25kcywgbWlsbGlzZWNvbmRzLCBtaWNyb3NlY29uZHMsIG5hbm9zZWNvbmRzIH0gPVxuICAgICAgICAgICAgICAgIFJvdW5kRHVyYXRpb24oeWVhcnMsIG1vbnRocywgd2Vla3MsIGRheXMsIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBtaWxsaXNlY29uZHMsIG1pY3Jvc2Vjb25kcywgbmFub3NlY29uZHMsIHJvdW5kaW5nSW5jcmVtZW50LCBzbWFsbGVzdFVuaXQsIHJvdW5kaW5nTW9kZSwgdGhpcykpO1xuICAgICAgICAgICAgKHsgeWVhcnMsIG1vbnRocywgd2Vla3MsIGRheXMsIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBtaWxsaXNlY29uZHMsIG1pY3Jvc2Vjb25kcywgbmFub3NlY29uZHMgfSA9XG4gICAgICAgICAgICAgICAgQWRqdXN0Um91bmRlZER1cmF0aW9uRGF5cyh5ZWFycywgbW9udGhzLCB3ZWVrcywgZGF5cywgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc2Vjb25kcywgbWljcm9zZWNvbmRzLCBuYW5vc2Vjb25kcywgcm91bmRpbmdJbmNyZW1lbnQsIHNtYWxsZXN0VW5pdCwgcm91bmRpbmdNb2RlLCB0aGlzKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgRHVyYXRpb24gPSBHZXRJbnRyaW5zaWMoJyVUZW1wb3JhbC5EdXJhdGlvbiUnKTtcbiAgICAgICAgcmV0dXJuIG5ldyBEdXJhdGlvbigteWVhcnMsIC1tb250aHMsIC13ZWVrcywgLWRheXMsIC1ob3VycywgLW1pbnV0ZXMsIC1zZWNvbmRzLCAtbWlsbGlzZWNvbmRzLCAtbWljcm9zZWNvbmRzLCAtbmFub3NlY29uZHMpO1xuICAgIH1cbiAgICByb3VuZChvcHRpb25zUGFyYW0pIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsWm9uZWREYXRlVGltZSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgaWYgKG9wdGlvbnNQYXJhbSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignb3B0aW9ucyBwYXJhbWV0ZXIgaXMgcmVxdWlyZWQnKTtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHR5cGVvZiBvcHRpb25zUGFyYW0gPT09ICdzdHJpbmcnXG4gICAgICAgICAgICA/IENyZWF0ZU9uZVByb3BPYmplY3QoJ3NtYWxsZXN0VW5pdCcsIG9wdGlvbnNQYXJhbSlcbiAgICAgICAgICAgIDogR2V0T3B0aW9uc09iamVjdChvcHRpb25zUGFyYW0pO1xuICAgICAgICBjb25zdCBzbWFsbGVzdFVuaXQgPSBUb1NtYWxsZXN0VGVtcG9yYWxVbml0KG9wdGlvbnMsIHVuZGVmaW5lZCwgWyd5ZWFyJywgJ21vbnRoJywgJ3dlZWsnXSk7XG4gICAgICAgIGlmIChzbWFsbGVzdFVuaXQgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdzbWFsbGVzdFVuaXQgaXMgcmVxdWlyZWQnKTtcbiAgICAgICAgY29uc3Qgcm91bmRpbmdNb2RlID0gVG9UZW1wb3JhbFJvdW5kaW5nTW9kZShvcHRpb25zLCAnaGFsZkV4cGFuZCcpO1xuICAgICAgICBjb25zdCBtYXhpbXVtSW5jcmVtZW50cyA9IHtcbiAgICAgICAgICAgIGRheTogMSxcbiAgICAgICAgICAgIGhvdXI6IDI0LFxuICAgICAgICAgICAgbWludXRlOiA2MCxcbiAgICAgICAgICAgIHNlY29uZDogNjAsXG4gICAgICAgICAgICBtaWxsaXNlY29uZDogMTAwMCxcbiAgICAgICAgICAgIG1pY3Jvc2Vjb25kOiAxMDAwLFxuICAgICAgICAgICAgbmFub3NlY29uZDogMTAwMFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCByb3VuZGluZ0luY3JlbWVudCA9IFRvVGVtcG9yYWxSb3VuZGluZ0luY3JlbWVudChvcHRpb25zLCBtYXhpbXVtSW5jcmVtZW50c1tzbWFsbGVzdFVuaXRdLCBmYWxzZSk7XG4gICAgICAgIC8vIGZpcnN0LCByb3VuZCB0aGUgdW5kZXJseWluZyBEYXRlVGltZSBmaWVsZHNcbiAgICAgICAgY29uc3QgZHQgPSBkYXRlVGltZSh0aGlzKTtcbiAgICAgICAgbGV0IHllYXIgPSBHZXRTbG90KGR0LCBJU09fWUVBUik7XG4gICAgICAgIGxldCBtb250aCA9IEdldFNsb3QoZHQsIElTT19NT05USCk7XG4gICAgICAgIGxldCBkYXkgPSBHZXRTbG90KGR0LCBJU09fREFZKTtcbiAgICAgICAgbGV0IGhvdXIgPSBHZXRTbG90KGR0LCBJU09fSE9VUik7XG4gICAgICAgIGxldCBtaW51dGUgPSBHZXRTbG90KGR0LCBJU09fTUlOVVRFKTtcbiAgICAgICAgbGV0IHNlY29uZCA9IEdldFNsb3QoZHQsIElTT19TRUNPTkQpO1xuICAgICAgICBsZXQgbWlsbGlzZWNvbmQgPSBHZXRTbG90KGR0LCBJU09fTUlMTElTRUNPTkQpO1xuICAgICAgICBsZXQgbWljcm9zZWNvbmQgPSBHZXRTbG90KGR0LCBJU09fTUlDUk9TRUNPTkQpO1xuICAgICAgICBsZXQgbmFub3NlY29uZCA9IEdldFNsb3QoZHQsIElTT19OQU5PU0VDT05EKTtcbiAgICAgICAgY29uc3QgRGF0ZVRpbWUgPSBHZXRJbnRyaW5zaWMoJyVUZW1wb3JhbC5QbGFpbkRhdGVUaW1lJScpO1xuICAgICAgICBjb25zdCB0aW1lWm9uZSA9IEdldFNsb3QodGhpcywgVElNRV9aT05FKTtcbiAgICAgICAgY29uc3QgY2FsZW5kYXIgPSBHZXRTbG90KHRoaXMsIENBTEVOREFSKTtcbiAgICAgICAgY29uc3QgZHRTdGFydCA9IG5ldyBEYXRlVGltZShHZXRTbG90KGR0LCBJU09fWUVBUiksIEdldFNsb3QoZHQsIElTT19NT05USCksIEdldFNsb3QoZHQsIElTT19EQVkpLCAwLCAwLCAwLCAwLCAwLCAwKTtcbiAgICAgICAgY29uc3QgaW5zdGFudFN0YXJ0ID0gQnVpbHRpblRpbWVab25lR2V0SW5zdGFudEZvcih0aW1lWm9uZSwgZHRTdGFydCwgJ2NvbXBhdGlibGUnKTtcbiAgICAgICAgY29uc3QgZW5kTnMgPSBBZGRab25lZERhdGVUaW1lKGluc3RhbnRTdGFydCwgdGltZVpvbmUsIGNhbGVuZGFyLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAwLCAwKTtcbiAgICAgICAgY29uc3QgZGF5TGVuZ3RoTnMgPSBKU0JJLnN1YnRyYWN0KGVuZE5zLCBKU0JJLkJpZ0ludChHZXRTbG90KGluc3RhbnRTdGFydCwgRVBPQ0hOQU5PU0VDT05EUykpKTtcbiAgICAgICAgaWYgKEpTQkkuZXF1YWwoZGF5TGVuZ3RoTnMsIFpFUk8pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignY2Fubm90IHJvdW5kIGEgWm9uZWREYXRlVGltZSBpbiBhIGNhbGVuZGFyIHdpdGggemVyby1sZW5ndGggZGF5cycpO1xuICAgICAgICB9XG4gICAgICAgICh7IHllYXIsIG1vbnRoLCBkYXksIGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZCwgbWljcm9zZWNvbmQsIG5hbm9zZWNvbmQgfSA9IFJvdW5kSVNPRGF0ZVRpbWUoeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kLCBtaWNyb3NlY29uZCwgbmFub3NlY29uZCwgcm91bmRpbmdJbmNyZW1lbnQsIHNtYWxsZXN0VW5pdCwgcm91bmRpbmdNb2RlLCBcbiAgICAgICAgLy8gRGF5cyBhcmUgZ3VhcmFudGVlZCB0byBiZSBzaG9ydGVyIHRoYW4gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJcbiAgICAgICAgLy8gKHdoaWNoIGNhbiBob2xkIHVwIHRvIDEwNCBkYXlzIGluIG5hbm9zZWNvbmRzKVxuICAgICAgICBKU0JJLnRvTnVtYmVyKGRheUxlbmd0aE5zKSkpO1xuICAgICAgICAvLyBOb3cgcmVzZXQgYWxsIERhdGVUaW1lIGZpZWxkcyBidXQgbGVhdmUgdGhlIFRpbWVab25lLiBUaGUgb2Zmc2V0IHdpbGxcbiAgICAgICAgLy8gYWxzbyBiZSByZXRhaW5lZCBpZiB0aGUgbmV3IGRhdGUvdGltZSB2YWx1ZXMgYXJlIHN0aWxsIE9LIHdpdGggdGhlIG9sZFxuICAgICAgICAvLyBvZmZzZXQuIE90aGVyd2lzZSB0aGUgb2Zmc2V0IHdpbGwgYmUgY2hhbmdlZCB0byBiZSBjb21wYXRpYmxlIHdpdGggdGhlXG4gICAgICAgIC8vIG5ldyBkYXRlL3RpbWUgdmFsdWVzLiBJZiBEU1QgZGlzYW1iaWd1YXRpb24gaXMgcmVxdWlyZWQsIHRoZSBgY29tcGF0aWJsZWBcbiAgICAgICAgLy8gZGlzYW1iaWd1YXRpb24gYWxnb3JpdGhtIHdpbGwgYmUgdXNlZC5cbiAgICAgICAgY29uc3Qgb2Zmc2V0TnMgPSBHZXRPZmZzZXROYW5vc2Vjb25kc0Zvcih0aW1lWm9uZSwgR2V0U2xvdCh0aGlzLCBJTlNUQU5UKSk7XG4gICAgICAgIGNvbnN0IGVwb2NoTmFub3NlY29uZHMgPSBJbnRlcnByZXRJU09EYXRlVGltZU9mZnNldCh5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQsIG1pY3Jvc2Vjb25kLCBuYW5vc2Vjb25kLCAnb3B0aW9uJywgb2Zmc2V0TnMsIHRpbWVab25lLCAnY29tcGF0aWJsZScsICdwcmVmZXInLCBcbiAgICAgICAgLyogbWF0Y2hNaW51dGUgPSAqLyBmYWxzZSk7XG4gICAgICAgIHJldHVybiBDcmVhdGVUZW1wb3JhbFpvbmVkRGF0ZVRpbWUoZXBvY2hOYW5vc2Vjb25kcywgdGltZVpvbmUsIEdldFNsb3QodGhpcywgQ0FMRU5EQVIpKTtcbiAgICB9XG4gICAgZXF1YWxzKG90aGVyUGFyYW0pIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsWm9uZWREYXRlVGltZSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgY29uc3Qgb3RoZXIgPSBUb1RlbXBvcmFsWm9uZWREYXRlVGltZShvdGhlclBhcmFtKTtcbiAgICAgICAgY29uc3Qgb25lID0gR2V0U2xvdCh0aGlzLCBFUE9DSE5BTk9TRUNPTkRTKTtcbiAgICAgICAgY29uc3QgdHdvID0gR2V0U2xvdChvdGhlciwgRVBPQ0hOQU5PU0VDT05EUyk7XG4gICAgICAgIGlmICghSlNCSS5lcXVhbChKU0JJLkJpZ0ludChvbmUpLCBKU0JJLkJpZ0ludCh0d28pKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKCFUaW1lWm9uZUVxdWFscyhHZXRTbG90KHRoaXMsIFRJTUVfWk9ORSksIEdldFNsb3Qob3RoZXIsIFRJTUVfWk9ORSkpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXR1cm4gQ2FsZW5kYXJFcXVhbHMoR2V0U2xvdCh0aGlzLCBDQUxFTkRBUiksIEdldFNsb3Qob3RoZXIsIENBTEVOREFSKSk7XG4gICAgfVxuICAgIHRvU3RyaW5nKG9wdGlvbnNQYXJhbSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxab25lZERhdGVUaW1lKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICBjb25zdCBvcHRpb25zID0gR2V0T3B0aW9uc09iamVjdChvcHRpb25zUGFyYW0pO1xuICAgICAgICBjb25zdCB7IHByZWNpc2lvbiwgdW5pdCwgaW5jcmVtZW50IH0gPSBUb1NlY29uZHNTdHJpbmdQcmVjaXNpb24ob3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IHJvdW5kaW5nTW9kZSA9IFRvVGVtcG9yYWxSb3VuZGluZ01vZGUob3B0aW9ucywgJ3RydW5jJyk7XG4gICAgICAgIGNvbnN0IHNob3dDYWxlbmRhciA9IFRvU2hvd0NhbGVuZGFyT3B0aW9uKG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBzaG93VGltZVpvbmUgPSBUb1Nob3dUaW1lWm9uZU5hbWVPcHRpb24ob3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IHNob3dPZmZzZXQgPSBUb1Nob3dPZmZzZXRPcHRpb24ob3B0aW9ucyk7XG4gICAgICAgIHJldHVybiBUZW1wb3JhbFpvbmVkRGF0ZVRpbWVUb1N0cmluZyh0aGlzLCBwcmVjaXNpb24sIHNob3dDYWxlbmRhciwgc2hvd1RpbWVab25lLCBzaG93T2Zmc2V0LCB7XG4gICAgICAgICAgICB1bml0LFxuICAgICAgICAgICAgaW5jcmVtZW50LFxuICAgICAgICAgICAgcm91bmRpbmdNb2RlXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB0b0xvY2FsZVN0cmluZyhsb2NhbGVzID0gdW5kZWZpbmVkLCBvcHRpb25zID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbFpvbmVkRGF0ZVRpbWUodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZVRpbWVGb3JtYXQobG9jYWxlcywgb3B0aW9ucykuZm9ybWF0KHRoaXMpO1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbFpvbmVkRGF0ZVRpbWUodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIHJldHVybiBUZW1wb3JhbFpvbmVkRGF0ZVRpbWVUb1N0cmluZyh0aGlzLCAnYXV0bycpO1xuICAgIH1cbiAgICB2YWx1ZU9mKCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd1c2UgY29tcGFyZSgpIG9yIGVxdWFscygpIHRvIGNvbXBhcmUgVGVtcG9yYWwuWm9uZWREYXRlVGltZScpO1xuICAgIH1cbiAgICBzdGFydE9mRGF5KCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxab25lZERhdGVUaW1lKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICBjb25zdCBkdCA9IGRhdGVUaW1lKHRoaXMpO1xuICAgICAgICBjb25zdCBEYXRlVGltZSA9IEdldEludHJpbnNpYygnJVRlbXBvcmFsLlBsYWluRGF0ZVRpbWUlJyk7XG4gICAgICAgIGNvbnN0IGNhbGVuZGFyID0gR2V0U2xvdCh0aGlzLCBDQUxFTkRBUik7XG4gICAgICAgIGNvbnN0IGR0U3RhcnQgPSBuZXcgRGF0ZVRpbWUoR2V0U2xvdChkdCwgSVNPX1lFQVIpLCBHZXRTbG90KGR0LCBJU09fTU9OVEgpLCBHZXRTbG90KGR0LCBJU09fREFZKSwgMCwgMCwgMCwgMCwgMCwgMCwgY2FsZW5kYXIpO1xuICAgICAgICBjb25zdCB0aW1lWm9uZSA9IEdldFNsb3QodGhpcywgVElNRV9aT05FKTtcbiAgICAgICAgY29uc3QgaW5zdGFudCA9IEJ1aWx0aW5UaW1lWm9uZUdldEluc3RhbnRGb3IodGltZVpvbmUsIGR0U3RhcnQsICdjb21wYXRpYmxlJyk7XG4gICAgICAgIHJldHVybiBDcmVhdGVUZW1wb3JhbFpvbmVkRGF0ZVRpbWUoR2V0U2xvdChpbnN0YW50LCBFUE9DSE5BTk9TRUNPTkRTKSwgdGltZVpvbmUsIGNhbGVuZGFyKTtcbiAgICB9XG4gICAgdG9JbnN0YW50KCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxab25lZERhdGVUaW1lKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICBjb25zdCBUZW1wb3JhbEluc3RhbnQgPSBHZXRJbnRyaW5zaWMoJyVUZW1wb3JhbC5JbnN0YW50JScpO1xuICAgICAgICByZXR1cm4gbmV3IFRlbXBvcmFsSW5zdGFudChHZXRTbG90KHRoaXMsIEVQT0NITkFOT1NFQ09ORFMpKTtcbiAgICB9XG4gICAgdG9QbGFpbkRhdGUoKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbFpvbmVkRGF0ZVRpbWUodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIHJldHVybiBUZW1wb3JhbERhdGVUaW1lVG9EYXRlKGRhdGVUaW1lKHRoaXMpKTtcbiAgICB9XG4gICAgdG9QbGFpblRpbWUoKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbFpvbmVkRGF0ZVRpbWUodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIHJldHVybiBUZW1wb3JhbERhdGVUaW1lVG9UaW1lKGRhdGVUaW1lKHRoaXMpKTtcbiAgICB9XG4gICAgdG9QbGFpbkRhdGVUaW1lKCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxab25lZERhdGVUaW1lKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICByZXR1cm4gZGF0ZVRpbWUodGhpcyk7XG4gICAgfVxuICAgIHRvUGxhaW5ZZWFyTW9udGgoKSB7XG4gICAgICAgIGlmICghSXNUZW1wb3JhbFpvbmVkRGF0ZVRpbWUodGhpcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlY2VpdmVyJyk7XG4gICAgICAgIGNvbnN0IGNhbGVuZGFyID0gR2V0U2xvdCh0aGlzLCBDQUxFTkRBUik7XG4gICAgICAgIGNvbnN0IGZpZWxkTmFtZXMgPSBDYWxlbmRhckZpZWxkcyhjYWxlbmRhciwgWydtb250aENvZGUnLCAneWVhciddKTtcbiAgICAgICAgY29uc3QgZmllbGRzID0gVG9UZW1wb3JhbFllYXJNb250aEZpZWxkcyh0aGlzLCBmaWVsZE5hbWVzKTtcbiAgICAgICAgcmV0dXJuIFllYXJNb250aEZyb21GaWVsZHMoY2FsZW5kYXIsIGZpZWxkcyk7XG4gICAgfVxuICAgIHRvUGxhaW5Nb250aERheSgpIHtcbiAgICAgICAgaWYgKCFJc1RlbXBvcmFsWm9uZWREYXRlVGltZSh0aGlzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcmVjZWl2ZXInKTtcbiAgICAgICAgY29uc3QgY2FsZW5kYXIgPSBHZXRTbG90KHRoaXMsIENBTEVOREFSKTtcbiAgICAgICAgY29uc3QgZmllbGROYW1lcyA9IENhbGVuZGFyRmllbGRzKGNhbGVuZGFyLCBbJ2RheScsICdtb250aENvZGUnXSk7XG4gICAgICAgIGNvbnN0IGZpZWxkcyA9IFRvVGVtcG9yYWxNb250aERheUZpZWxkcyh0aGlzLCBmaWVsZE5hbWVzKTtcbiAgICAgICAgcmV0dXJuIE1vbnRoRGF5RnJvbUZpZWxkcyhjYWxlbmRhciwgZmllbGRzKTtcbiAgICB9XG4gICAgZ2V0SVNPRmllbGRzKCkge1xuICAgICAgICBpZiAoIUlzVGVtcG9yYWxab25lZERhdGVUaW1lKHRoaXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZWNlaXZlcicpO1xuICAgICAgICBjb25zdCBkdCA9IGRhdGVUaW1lKHRoaXMpO1xuICAgICAgICBjb25zdCB0eiA9IEdldFNsb3QodGhpcywgVElNRV9aT05FKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNhbGVuZGFyOiBHZXRTbG90KHRoaXMsIENBTEVOREFSKSxcbiAgICAgICAgICAgIGlzb0RheTogR2V0U2xvdChkdCwgSVNPX0RBWSksXG4gICAgICAgICAgICBpc29Ib3VyOiBHZXRTbG90KGR0LCBJU09fSE9VUiksXG4gICAgICAgICAgICBpc29NaWNyb3NlY29uZDogR2V0U2xvdChkdCwgSVNPX01JQ1JPU0VDT05EKSxcbiAgICAgICAgICAgIGlzb01pbGxpc2Vjb25kOiBHZXRTbG90KGR0LCBJU09fTUlMTElTRUNPTkQpLFxuICAgICAgICAgICAgaXNvTWludXRlOiBHZXRTbG90KGR0LCBJU09fTUlOVVRFKSxcbiAgICAgICAgICAgIGlzb01vbnRoOiBHZXRTbG90KGR0LCBJU09fTU9OVEgpLFxuICAgICAgICAgICAgaXNvTmFub3NlY29uZDogR2V0U2xvdChkdCwgSVNPX05BTk9TRUNPTkQpLFxuICAgICAgICAgICAgaXNvU2Vjb25kOiBHZXRTbG90KGR0LCBJU09fU0VDT05EKSxcbiAgICAgICAgICAgIGlzb1llYXI6IEdldFNsb3QoZHQsIElTT19ZRUFSKSxcbiAgICAgICAgICAgIG9mZnNldDogQnVpbHRpblRpbWVab25lR2V0T2Zmc2V0U3RyaW5nRm9yKHR6LCBHZXRTbG90KHRoaXMsIElOU1RBTlQpKSxcbiAgICAgICAgICAgIHRpbWVab25lOiB0elxuICAgICAgICB9O1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbShpdGVtLCBvcHRpb25zUGFyYW0gPSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IEdldE9wdGlvbnNPYmplY3Qob3B0aW9uc1BhcmFtKTtcbiAgICAgICAgaWYgKElzVGVtcG9yYWxab25lZERhdGVUaW1lKGl0ZW0pKSB7XG4gICAgICAgICAgICBUb1RlbXBvcmFsT3ZlcmZsb3cob3B0aW9ucyk7IC8vIHZhbGlkYXRlIGFuZCBpZ25vcmVcbiAgICAgICAgICAgIFRvVGVtcG9yYWxEaXNhbWJpZ3VhdGlvbihvcHRpb25zKTtcbiAgICAgICAgICAgIFRvVGVtcG9yYWxPZmZzZXQob3B0aW9ucywgJ3JlamVjdCcpO1xuICAgICAgICAgICAgcmV0dXJuIENyZWF0ZVRlbXBvcmFsWm9uZWREYXRlVGltZShHZXRTbG90KGl0ZW0sIEVQT0NITkFOT1NFQ09ORFMpLCBHZXRTbG90KGl0ZW0sIFRJTUVfWk9ORSksIEdldFNsb3QoaXRlbSwgQ0FMRU5EQVIpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gVG9UZW1wb3JhbFpvbmVkRGF0ZVRpbWUoaXRlbSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIHN0YXRpYyBjb21wYXJlKG9uZVBhcmFtLCB0d29QYXJhbSkge1xuICAgICAgICBjb25zdCBvbmUgPSBUb1RlbXBvcmFsWm9uZWREYXRlVGltZShvbmVQYXJhbSk7XG4gICAgICAgIGNvbnN0IHR3byA9IFRvVGVtcG9yYWxab25lZERhdGVUaW1lKHR3b1BhcmFtKTtcbiAgICAgICAgY29uc3QgbnMxID0gR2V0U2xvdChvbmUsIEVQT0NITkFOT1NFQ09ORFMpO1xuICAgICAgICBjb25zdCBuczIgPSBHZXRTbG90KHR3bywgRVBPQ0hOQU5PU0VDT05EUyk7XG4gICAgICAgIGlmIChKU0JJLmxlc3NUaGFuKEpTQkkuQmlnSW50KG5zMSksIEpTQkkuQmlnSW50KG5zMikpKVxuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICBpZiAoSlNCSS5ncmVhdGVyVGhhbihKU0JJLkJpZ0ludChuczEpLCBKU0JJLkJpZ0ludChuczIpKSlcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG59XG5NYWtlSW50cmluc2ljQ2xhc3MoWm9uZWREYXRlVGltZSwgJ1RlbXBvcmFsLlpvbmVkRGF0ZVRpbWUnKTtcbmZ1bmN0aW9uIGRhdGVUaW1lKHpkdCkge1xuICAgIHJldHVybiBCdWlsdGluVGltZVpvbmVHZXRQbGFpbkRhdGVUaW1lRm9yKEdldFNsb3QoemR0LCBUSU1FX1pPTkUpLCBHZXRTbG90KHpkdCwgSU5TVEFOVCksIEdldFNsb3QoemR0LCBDQUxFTkRBUikpO1xufVxuXG52YXIgdGVtcG9yYWwgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIEluc3RhbnQ6IEluc3RhbnQsXG4gICAgQ2FsZW5kYXI6IENhbGVuZGFyLFxuICAgIFBsYWluRGF0ZTogUGxhaW5EYXRlLFxuICAgIFBsYWluRGF0ZVRpbWU6IFBsYWluRGF0ZVRpbWUsXG4gICAgRHVyYXRpb246IER1cmF0aW9uLFxuICAgIFBsYWluTW9udGhEYXk6IFBsYWluTW9udGhEYXksXG4gICAgTm93OiBOb3csXG4gICAgUGxhaW5UaW1lOiBQbGFpblRpbWUsXG4gICAgVGltZVpvbmU6IFRpbWVab25lLFxuICAgIFBsYWluWWVhck1vbnRoOiBQbGFpblllYXJNb250aCxcbiAgICBab25lZERhdGVUaW1lOiBab25lZERhdGVUaW1lXG59KTtcblxuZnVuY3Rpb24gdG9UZW1wb3JhbEluc3RhbnQoKSB7XG4gICAgLy8gT2JzZXJ2YWJsZSBhY2Nlc3MgdG8gdmFsdWVPZiBpcyBub3QgY29ycmVjdCBoZXJlLCBidXQgdW5hdm9pZGFibGVcbiAgICBjb25zdCBlcG9jaE5hbm9zZWNvbmRzID0gSlNCSS5tdWx0aXBseShKU0JJLkJpZ0ludCgrdGhpcyksIE1JTExJT04pO1xuICAgIHJldHVybiBuZXcgSW5zdGFudChUb0JpZ0ludChlcG9jaE5hbm9zZWNvbmRzKSk7XG59XG5cbi8vIFRoaXMgZW50cnkgcG9pbnQgdHJlYXRzIFRlbXBvcmFsIGFzIGEgbGlicmFyeSwgYW5kIGRvZXMgbm90IHBvbHlmaWxsIGl0IG9udG9cbi8vIFdvcmsgYXJvdW5kIGh0dHBzOi8vZ2l0aHViLmNvbS9iYWJlbC9iYWJlbC9pc3N1ZXMvMjAyNS5cbmNvbnN0IHR5cGVzID0gW1xuICAgIEluc3RhbnQsXG4gICAgQ2FsZW5kYXIsXG4gICAgUGxhaW5EYXRlLFxuICAgIFBsYWluRGF0ZVRpbWUsXG4gICAgRHVyYXRpb24sXG4gICAgUGxhaW5Nb250aERheSxcbiAgICAvLyBUZW1wb3JhbC5Ob3csIC8vIHBsYWluIG9iamVjdCAobm90IGEgY29uc3RydWN0b3IpLCBzbyBubyBgcHJvdG90eXBlYFxuICAgIFBsYWluVGltZSxcbiAgICBUaW1lWm9uZSxcbiAgICBQbGFpblllYXJNb250aCxcbiAgICBab25lZERhdGVUaW1lXG5dO1xuZm9yIChjb25zdCB0eXBlIG9mIHR5cGVzKSB7XG4gICAgY29uc3QgZGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodHlwZSwgJ3Byb3RvdHlwZScpO1xuICAgIGlmIChkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSB8fCBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZGVzY3JpcHRvci53cml0YWJsZSkge1xuICAgICAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IGZhbHNlO1xuICAgICAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBmYWxzZTtcbiAgICAgICAgZGVzY3JpcHRvci53cml0YWJsZSA9IGZhbHNlO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodHlwZSwgJ3Byb3RvdHlwZScsIGRlc2NyaXB0b3IpO1xuICAgIH1cbn1cblxuZXhwb3J0IHsgaW50bCBhcyBJbnRsLCB0ZW1wb3JhbCBhcyBUZW1wb3JhbCwgdG9UZW1wb3JhbEluc3RhbnQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmVzbS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@js-temporal/polyfill/dist/index.esm.js\n");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval-source-map devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.js");
/******/ 	
/******/ })()
;